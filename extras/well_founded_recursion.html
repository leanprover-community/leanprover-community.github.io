<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="https://leanprover-community.github.io//css/lean.css" >
  <link rel="shortcut icon" href="https://leanprover-community.github.io//img/favicon.ico">
  <link rel="search" type="application/opensearchdescription+xml" title="mathlib docs" href="https://leanprover-community.github.io//opensearch.xml">
<link href="https://fonts.googleapis.com/css2?family=Merriweather&family=Open+Sans&family=Source+Code+Pro:wght@400;600&display=swap" rel="stylesheet">
    

	<script>
                function buildShortcutsForStructures(names) {
                        const o = {}
                        names.forEach(name => o[name] = `\\mathbb\{${name}\}`)
                        return o
                }
		MathJax = {
			  tex: {
                                  macros: {
                                          ...buildShortcutsForStructures(["R", "Q", "Z", "N", "C"]),
                                  },
				      inlineMath: [['$', '$'], ['\\(', '\\)']]
				    },
		};
	</script>
	<script type="text/javascript" id="MathJax-script" async
		  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
	</script>

	<title>The equation compiler and using_well_founded</title>
  </head>
  <body>
  <nav class="navbar navbar-expand-lg navbar-light bg-gradient-light d-md-none">
    <div class="d-flex flex-grow-1">
		<a class="navbar-brand" href="https://leanprover-community.github.io/index.html">Lean Community
    </a>
    </div>

    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
  </nav>

<div id="mainbox">

  <main>
    
<div class="alert alert-info">
<p>
We are currently updating the Lean community website to describe working with Lean 4,
but most of the information you will find here today still describes Lean 3.
</p>
<p>
Pull requests updating this page for Lean 4 are very welcome.
There is a link at the bottom of this page.
</p>
<p>
Please visit <a href="https://leanprover.zulipchat.com">the leanprover zulip</a>
and ask for whatever help you need during this transitional period!
</p>
<p>
The website for Lean 3 has been <a href="https://leanprover-community.github.io/lean3/">archived</a>.
If you need to link to Lean 3 specific resources please link there.
</p>
</div>
<h1 id="the-equation-compiler-and-using_well_founded" class="markdown-heading">The equation compiler and using_well_founded <a class="hover-link" href="#the-equation-compiler-and-using_well_founded">#</a></h1>
<p>To define functions and proofs recursively you can use the equation compiler, if you have a well founded relation on that type</p>
<p>For example the definition of gcd on naturals uses well founded recursion</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="kd">def</span> <span class="n">gcd</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">→</span> <span class="n">nat</span> <span class="bp">→</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="mi">0</span>        <span class="n">y</span> <span class="o">:=</span> <span class="n">y</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">x</span><span class="o">)</span> <span class="n">y</span> <span class="o">:=</span> <span class="k">have</span> <span class="n">y</span> <span class="bp">%</span> <span class="n">succ</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">succ</span> <span class="n">x</span><span class="o">,</span> <span class="k">from</span> <span class="n">mod_lt</span> <span class="n">_</span> <span class="bp">$</span> <span class="n">succ_pos</span> <span class="n">_</span><span class="o">,</span>
                <span class="n">gcd</span> <span class="o">(</span><span class="n">y</span> <span class="bp">%</span> <span class="n">succ</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">succ</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>
</div>

<p>Because &lt; is a well founded relation on naturals, and because <code>y % succ x &lt; succ x</code> this recursive function is well_founded.</p>
<p>Whenever you use the equation compiler, there will be a default well founded relation on the type being recursed on (given by the <code>has_well_founded</code> instance) and the equation compiler will automatically attempt to prove the function is well founded under said relation.</p>
<p>When the equation compiler fails, there are two main causes.</p>
<ol>
<li>It has failed to prove the required inequality.</li>
<li>It is not using the correct well founded relation.</li>
</ol>
<h2 id="proving-required-inequality" class="markdown-heading">Proving required inequality <a class="hover-link" href="#proving-required-inequality">#</a></h2>
<p>If we modify the gcd example above, by removing the <code>have</code>, we get an error.</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="kd">def</span> <span class="n">gcd</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">→</span> <span class="n">nat</span> <span class="bp">→</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="mi">0</span>        <span class="n">y</span> <span class="o">:=</span> <span class="n">y</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">x</span><span class="o">)</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">gcd</span> <span class="o">(</span><span class="n">y</span> <span class="bp">%</span> <span class="n">succ</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">succ</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>
</div>

<div class="codehilite"><div class="codehilite"><pre><span></span><code>failed to prove recursive application is decreasing, well founded relation
  @has_well_founded.r (Σ&#39; (a : ℕ), ℕ)
    (@psigma.has_well_founded ℕ (λ (a : ℕ), ℕ) (@has_well_founded_of_has_sizeof ℕ nat.has_sizeof)
       (λ (a : ℕ), @has_well_founded_of_has_sizeof ℕ nat.has_sizeof))
Possible solutions:
  - Use &#39;using_well_founded&#39; keyword in the end of your definition to specify tactics for synthesizing well founded relations and decreasing proofs.
  - The default decreasing tactic uses the &#39;assumption&#39; tactic, thus hints (aka local proofs) can be provided using &#39;have&#39;-expressions.
The nested exception contains the failure state for the decreasing tactic.
nested exception message:
failed
state:
gcd : (Σ&#39; (a : ℕ), ℕ) → ℕ,
x y : ℕ
⊢ y % succ x &lt; succ x
</code></pre></div>
</div>

<p>The error message has given us a goal, <code>y % succ x &lt; succ x</code>. Including a proof of this goal as part of our definition using <code>have</code> removes the error.</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="kd">def</span> <span class="n">gcd</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">→</span> <span class="n">nat</span> <span class="bp">→</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="mi">0</span>        <span class="n">y</span> <span class="o">:=</span> <span class="n">y</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">x</span><span class="o">)</span> <span class="n">y</span> <span class="o">:=</span> <span class="k">have</span> <span class="n">y</span> <span class="bp">%</span> <span class="n">succ</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">succ</span> <span class="n">x</span><span class="o">,</span> <span class="k">from</span> <span class="n">mod_lt</span> <span class="n">_</span> <span class="bp">$</span> <span class="n">succ_pos</span> <span class="n">_</span><span class="o">,</span>
                <span class="n">gcd</span> <span class="o">(</span><span class="n">y</span> <span class="bp">%</span> <span class="n">succ</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">succ</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>
</div>

<p>Note that the <code>have</code> must not be in tactics mode, i.e. inside any <code>begin</code> <code>end</code>. If you are in tactics mode, there is the option of putting the <code>have</code> statement inside the exact statement, as in the following example.</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="kd">def</span> <span class="n">gcd</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">→</span> <span class="n">nat</span> <span class="bp">→</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="mi">0</span>        <span class="n">y</span> <span class="o">:=</span> <span class="n">y</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">x</span><span class="o">)</span> <span class="n">y</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">exact</span> <span class="k">have</span> <span class="n">y</span> <span class="bp">%</span> <span class="n">succ</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">succ</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">mod_lt</span> <span class="n">_</span> <span class="o">(</span><span class="n">succ_pos</span> <span class="n">_</span><span class="o">),</span>
  <span class="n">gcd</span> <span class="o">(</span><span class="n">y</span> <span class="bp">%</span> <span class="n">succ</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">succ</span> <span class="n">x</span><span class="o">)</span>
<span class="kd">end</span>
</code></pre></div>
</div>

<h2 id="order-of-arguments" class="markdown-heading">order of arguments <a class="hover-link" href="#order-of-arguments">#</a></h2>
<p>Sometimes the default relation the equation compiler uses is not the correct one. For example swapping the order of x and y in the above example causes a failure</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="kd">def</span> <span class="n">gcd</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">→</span> <span class="n">nat</span> <span class="bp">→</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">y</span> <span class="mi">0</span>        <span class="o">:=</span> <span class="n">y</span>
<span class="bp">|</span> <span class="n">y</span> <span class="o">(</span><span class="n">succ</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="k">have</span> <span class="n">y</span> <span class="bp">%</span> <span class="n">succ</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">succ</span> <span class="n">x</span><span class="o">,</span> <span class="k">from</span> <span class="n">mod_lt</span> <span class="n">_</span> <span class="bp">$</span> <span class="n">succ_pos</span> <span class="n">_</span><span class="o">,</span>
                <span class="n">gcd</span> <span class="o">(</span><span class="n">succ</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="bp">%</span> <span class="n">succ</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>
</div>

<p>Now the error message is asking us to prove <code>succ x &lt; y</code>. This is because by default the equation compiler tries to recurse on the first argument. More precisely, the relation that the equation compiler tries to use in this example is on the type of pairs of natural numbers <code>Σ' (a : ℕ), ℕ</code>, and it uses a lexicographical relation where the pair <code>⟨a, b⟩ ≺ ⟨c, d⟩</code> iff <code>a &lt; c ∨ (a = c ∧ b &lt; d)</code> This situation can be resolved, either by changing the order of the arguments or by specifying a <code>rel_tac</code> as decribed later in this doc.</p>
<p>Sometimes moving an argument outside of the equation compiler, can help the equation compiler prove a recursion is well_founded. For example the following proof from <code>data.nat.prime</code> fails.</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="kd">lemma</span> <span class="n">prod_factors</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">list.prod</span> <span class="o">(</span><span class="n">factors</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">n</span>
<span class="bp">|</span> <span class="mi">0</span>       <span class="n">h</span> <span class="o">:=</span> <span class="o">(</span><span class="n">lt_irrefl</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span> <span class="n">h</span>
<span class="bp">|</span> <span class="mi">1</span>       <span class="n">h</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="n">n</span><span class="bp">@</span><span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">2</span><span class="o">)</span> <span class="n">h</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">min_fac</span> <span class="n">n</span> <span class="k">in</span> <span class="k">have</span> <span class="n">n</span> <span class="bp">/</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">factors_lemma</span><span class="o">,</span>
  <span class="k">show</span> <span class="n">list.prod</span> <span class="o">(</span><span class="n">m</span> <span class="o">::</span> <span class="n">factors</span> <span class="o">(</span><span class="n">n</span> <span class="bp">/</span> <span class="n">m</span><span class="o">))</span> <span class="bp">=</span> <span class="n">n</span><span class="o">,</span> <span class="k">from</span>
  <span class="k">have</span> <span class="n">h₁</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">/</span> <span class="n">m</span> <span class="o">:=</span>
    <span class="n">nat.pos_of_ne_zero</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">*</span> <span class="n">m</span> <span class="o">:=</span> <span class="o">(</span><span class="n">nat.div_eq_iff_eq_mul_left</span> <span class="o">(</span><span class="n">min_fac_pos</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">min_fac_dvd</span> <span class="n">_</span><span class="o">))</span><span class="bp">.</span><span class="mi">1</span> <span class="n">h</span><span class="o">,</span>
    <span class="kd">by</span> <span class="n">rw</span> <span class="n">zero_mul</span> <span class="n">at</span> <span class="n">this</span><span class="bp">;</span> <span class="n">exact</span> <span class="o">(</span><span class="k">show</span> <span class="n">k</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">,</span> <span class="k">from</span> <span class="n">dec_trivial</span><span class="o">)</span> <span class="n">this</span><span class="o">,</span>
  <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">list.prod_cons</span><span class="o">,</span> <span class="n">prod_factors</span> <span class="n">_</span> <span class="n">h₁</span><span class="o">,</span> <span class="n">nat.mul_div_cancel&#39;</span> <span class="o">(</span><span class="n">min_fac_dvd</span> <span class="n">_</span><span class="o">)]</span>
</code></pre></div>
</div>

<p>But moving the <code>h</code> into a lambda after the <code>:=</code> makes it work</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="kd">lemma</span> <span class="n">prod_factors</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">list.prod</span> <span class="o">(</span><span class="n">factors</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">n</span>
<span class="bp">|</span> <span class="mi">0</span>       <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="o">(</span><span class="n">lt_irrefl</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span> <span class="n">h</span>
<span class="bp">|</span> <span class="mi">1</span>       <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="n">n</span><span class="bp">@</span><span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">2</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">min_fac</span> <span class="n">n</span> <span class="k">in</span> <span class="k">have</span> <span class="n">n</span> <span class="bp">/</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">factors_lemma</span><span class="o">,</span>
  <span class="k">show</span> <span class="n">list.prod</span> <span class="o">(</span><span class="n">m</span> <span class="o">::</span> <span class="n">factors</span> <span class="o">(</span><span class="n">n</span> <span class="bp">/</span> <span class="n">m</span><span class="o">))</span> <span class="bp">=</span> <span class="n">n</span><span class="o">,</span> <span class="k">from</span>
  <span class="k">have</span> <span class="n">h₁</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">/</span> <span class="n">m</span> <span class="o">:=</span>
    <span class="n">nat.pos_of_ne_zero</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">*</span> <span class="n">m</span> <span class="o">:=</span> <span class="o">(</span><span class="n">nat.div_eq_iff_eq_mul_left</span> <span class="o">(</span><span class="n">min_fac_pos</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">min_fac_dvd</span> <span class="n">_</span><span class="o">))</span><span class="bp">.</span><span class="mi">1</span> <span class="n">h</span><span class="o">,</span>
    <span class="kd">by</span> <span class="n">rw</span> <span class="n">zero_mul</span> <span class="n">at</span> <span class="n">this</span><span class="bp">;</span> <span class="n">exact</span> <span class="o">(</span><span class="k">show</span> <span class="n">k</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">,</span> <span class="k">from</span> <span class="n">dec_trivial</span><span class="o">)</span> <span class="n">this</span><span class="o">,</span>
  <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">list.prod_cons</span><span class="o">,</span> <span class="n">prod_factors</span> <span class="n">_</span> <span class="n">h₁</span><span class="o">,</span> <span class="n">nat.mul_div_cancel&#39;</span> <span class="o">(</span><span class="n">min_fac_dvd</span> <span class="n">_</span><span class="o">)]</span>
</code></pre></div>
</div>

<p>This is because for some reason, in the first example, the equation compiler tries to use the always false relation.</p>
<p>Conjecture : this is because the type of <code>h</code> depends on <code>n</code> and the equation compiler can only synthesize useful relations on non dependent products</p>
<h2 id="using_well_founded-rel_tac" class="markdown-heading">using_well_founded rel_tac <a class="hover-link" href="#using_well_founded-rel_tac">#</a></h2>
<p>Sometimes you need to change the well founded relation to prove that a recursion is well founded. To do this you need a <code>has_well_founded</code> instance. This is a structure with two fields, a relation and a proof that this relation is well founded. The easiest way to define a well founded relation is using a function to the natural numbers. For example on multisets the relation <code>λ s t, card s &lt; card t</code> is a well founded relation.</p>
<p>The following proof in <code>data.multiset</code> uses this relation.</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="kd">@[</span><span class="n">elab_as_eliminator</span><span class="kd">]</span> <span class="kd">lemma</span> <span class="n">strong_induction_on</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">),</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">s</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">t</span> <span class="bp">&lt;</span> <span class="n">s</span><span class="o">,</span> <span class="n">p</span> <span class="n">t</span><span class="o">)</span> <span class="bp">→</span> <span class="n">p</span> <span class="n">s</span><span class="o">)</span> <span class="bp">→</span> <span class="n">p</span> <span class="n">s</span>
<span class="bp">|</span> <span class="n">s</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">ih</span><span class="o">,</span> <span class="n">ih</span> <span class="n">s</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">t</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">card</span> <span class="n">t</span> <span class="bp">&lt;</span> <span class="n">card</span> <span class="n">s</span><span class="o">,</span> <span class="k">from</span> <span class="n">card_lt_of_lt</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">strong_induction_on</span> <span class="n">t</span> <span class="n">ih</span>
<span class="n">using_well_founded</span> <span class="o">{</span><span class="n">rel_tac</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="bp">`</span><span class="o">[</span><span class="n">exact</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">measure_wf</span> <span class="n">card</span><span class="o">⟩]}</span>
</code></pre></div>
</div>

<p>The final line tells the equation compiler to use this relation. It is not necessary to fully understand the final line to be able to use well_founded tactics. The most important part is <code>⟨_, measure_wf card⟩</code> This is the well_founded instance. <code>measure_wf</code> is a proof that for any relation generated from a function to the natural numbers, i.e. for a function <code>f : α → ℕ</code>, the relation <code>λ x y, f x &lt; f y</code> is well founded. The underscore is a placeholder for the relation, as it can be inferred from the type of the proof. Note that the well founded relation must be on a <code>psigma</code> type corresponding to the product of the types of the arguments after the vertical bar, if there are multiple arguments after the vertical bar.</p>
<p>In the gcd example the <code>psigma</code> type is <code>Σ' (a : ℕ), ℕ</code>. In order to solve the problem in the example where the order of the arguments was flipped, you could define a well founded relation on <code>Σ' (a : ℕ), ℕ</code> using the function <code>psigma.snd</code>, the function giving the second element of the pair, and then the error disappears.</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="kd">def</span> <span class="n">gcd</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">→</span> <span class="n">nat</span> <span class="bp">→</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">y</span> <span class="mi">0</span>        <span class="o">:=</span> <span class="n">y</span>
<span class="bp">|</span> <span class="n">y</span> <span class="o">(</span><span class="n">succ</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="k">have</span> <span class="n">y</span> <span class="bp">%</span> <span class="n">succ</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">succ</span> <span class="n">x</span><span class="o">,</span> <span class="k">from</span> <span class="n">mod_lt</span> <span class="n">_</span> <span class="bp">$</span> <span class="n">succ_pos</span> <span class="n">_</span><span class="o">,</span>
                <span class="n">gcd</span> <span class="o">(</span><span class="n">succ</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="bp">%</span> <span class="n">succ</span> <span class="n">x</span><span class="o">)</span>
<span class="n">using_well_founded</span> <span class="o">{</span><span class="n">rel_tac</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="bp">`</span><span class="o">[</span><span class="n">exact</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">measure_wf</span> <span class="n">psigma.snd</span><span class="o">⟩]}</span>
</code></pre></div>
</div>

  </main>

    <nav id="navbar" class="d-md-block bg-light sidebar collapse navbar-light pb-4">
      <div class="d-none d-md-block mt-4"><a class="navbar-brand" href="https://leanprover-community.github.io/index.html">Lean Community</a></div>
      
        <h6 class="sidebar-heading mt-4">Community</h6>
        <ul class="nav">
          <li class="nav-item col-12"><a href="https://leanprover.zulipchat.com/">Zulip chat</a></li>
        
          <li class="nav-item col-12"><a href="https://github.com/leanprover-community/mathlib4">GitHub</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/blog">Blog</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/meet.html">Community information</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/teams.html">Teams</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/papers.html">Papers about Lean</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/lean_projects.html">Projects using Lean</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/events.html">Events</a></li>
        </ul>
      
        <h6 class="sidebar-heading mt-4">Installation</h6>
        <ul class="nav">
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/get_started.html">Get started</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/install/debian.html">Debian/Ubuntu installation</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/install/linux.html">Generic Linux installation</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/install/macos.html">MacOS installation</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/install/windows.html">Windows installation</a></li>
        
          <li class="nav-item col-12"><a href="https://lean.math.hhu.de/">Online version (no installation)</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/install/project.html">Using Lake (build system)</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/toolchain.html">The Lean toolchain</a></li>
        </ul>
      
        <h6 class="sidebar-heading mt-4">Documentation</h6>
        <ul class="nav">
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/learn.html">Learning resources (start here)</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/mathlib4_docs">API documentation</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/extras/calc.html">Calc mode</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/extras/conv.html">Conv mode</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/extras/simp.html">Simplifier</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/extras/tactic_writing.html">Tactic writing tutorial</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/extras/well_founded_recursion.html">Well-founded recursion</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/mwe.html">About MWEs</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/glossary.html">Glossary</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/tips_and_tricks.html">Tips and tricks</a></li>
        </ul>
      
        <h6 class="sidebar-heading mt-4">Library overviews</h6>
        <ul class="nav">
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/mathlib-overview.html">Library overview</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/undergrad.html">Undergraduate maths</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/100.html">Wiedijk's 100 theorems</a></li>
        </ul>
      
        <h6 class="sidebar-heading mt-4">Theory docs</h6>
        <ul class="nav">
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/theories/category_theory.html">Category theory</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/theories/linear_algebra.html">Linear algebra</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/theories/naturals.html">Natural numbers</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/theories/sets.html">Sets and set-like objects</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/theories/topology.html">Topology</a></li>
        </ul>
      
        <h6 class="sidebar-heading mt-4">Contributing</h6>
        <ul class="nav">
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/contribute/index.html">Pull request lifecycle</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/contribute/naming.html">Naming conventions</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/contribute/style.html">Code style guideline</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/contribute/doc.html">Documentation style</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/contribute/commit.html">Commit conventions</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/contribute/pr-review.html">Pull request review guide</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/ci.html">CI for 3rd party projects</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/mathlib_stats.html">Contribution statistics</a></li>
        </ul>
      
    </nav>

</div>


  <nav class="footer navbar navbar-expand-lg navbar-light bg-light justify-content-end">
  <ul class="nav">
    <li class="nav-item">
      <a class="nav-link active" href="https://github.com/leanprover-community/leanprover-community.github.io/blob/lean4/templates/extras/well_founded_recursion.md">Suggest edits to this page on GitHub</a>
    </li>
  </ul>
  </nav>

    <script src="https://code.jquery.com/jquery-3.5.1.min.js"
      integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0="
      crossorigin="anonymous"></script>
    <script src="https://leanprover-community.github.io//js/bootstrap.min.js"></script>
    
  </body>
</html>