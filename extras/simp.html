<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="https://leanprover-community.github.io//css/lean.css" >
  <link rel="shortcut icon" href="https://leanprover-community.github.io//img/favicon.ico">
  <link rel="search" type="application/opensearchdescription+xml" title="mathlib docs" href="https://leanprover-community.github.io//opensearch.xml">
  <link href="https://fonts.googleapis.com/css2?family=Merriweather&family=Open+Sans&family=Source+Code+Pro:wght@400;600&display=swap" rel="stylesheet">
    

	<script>
                function buildShortcutsForStructures(names) {
                        const o = {}
                        names.forEach(name => o[name] = `\\mathbb\{${name}\}`)
                        return o
                }
		MathJax = {
			  tex: {
                                  macros: {
                                          ...buildShortcutsForStructures(["R", "Q", "Z", "N", "C"]),
                                  },
				      inlineMath: [['$', '$'], ['\\(', '\\)']]
				    },
		};
	</script>
	<script type="text/javascript" id="MathJax-script" async
		  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
	</script>

	<title>Simp</title>
  </head>
  <body>
  <nav class="navbar navbar-expand-lg navbar-light bg-gradient-light d-md-none">
    <div class="d-flex flex-grow-1">
		<a class="navbar-brand" href="https://leanprover-community.github.io/index.html">Lean Community
    </a>
    </div>

    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
  </nav>

<div id="mainbox">

  <main>
    
<h1 id="simp" class="markdown-heading">Simp <a class="hover-link" href="#simp">#</a></h1>
<h2 id="overview" class="markdown-heading">Overview <a class="hover-link" href="#overview">#</a></h2>
<p>In this document we will explain basic usage of the simplifier
tactic <a href="https://leanprover-community.github.io/mathlib4_docs/Init/Tactics.html#Lean.Parser.Tactic.simp"><code>simp</code></a>
and the related tactic <a href="https://leanprover-community.github.io/mathlib4_docs/Init/Tactics.html#Lean.Parser.Tactic.dsimp"><code>dsimp</code></a>
in Lean 4.</p>
<p>We give some pointers for how to avoid &quot;non-terminal <code>simp</code>s&quot;, and we
also give a short description of the configuration options for <code>simp</code>
and <code>dsimp</code>.</p>
<h2 id="introduction" class="markdown-heading">Introduction <a class="hover-link" href="#introduction">#</a></h2>
<p>Lean has a &quot;simplifier&quot;, called <code>simp</code>, that consults a database of
facts called <em><code>simp</code> lemmas</em> to (hopefully) simplify hypotheses and
goals. The simplifier is what is known as a <em>conditional term
rewriting system</em>: all it does is repeatedly replace (or <em>rewrite</em>)
subterms of the form <code>A</code> by <code>B</code>, for all applicable facts of the form
<code>A = B</code> or <code>A ↔ B</code>.
The simplifier mindlessly rewrites until it can rewrite no more.  The
<code>simp</code> lemmas are all oriented, with left-hand sides always being
replaced by right-hand sides, and never vice versa.</p>
<p>Ideally, the database of facts would result in expressions being simplified
into a normal form.
In practice, this is often unachievable (normal forms may not exist, or there
may not exist a collection of rewrite rules that produce them),
but nevertheless we aim to approximate this ideal where possible.
Even better, we would like the database of facts to be <em>confluent</em>,
meaning the order in which the simplifier considers rewrites does not matter.
Again, we aim to be close to confluent where possible.</p>
<p>While this system is able to prove many simple statements completely
automatically, proving all simple statements is not part of its job
description, as disappointing as that might be.</p>
<p>Here is an example (using mathlib).</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="n">Mathlib.Algebra.Group.Defs</span>

<span class="kd">variable</span><span class="w"> </span><span class="o">(</span><span class="n">G</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="o">)</span><span class="w"> </span><span class="o">[</span><span class="n">Group</span><span class="w"> </span><span class="n">G</span><span class="o">]</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">G</span><span class="o">)</span>

<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">a</span><span class="bp">⁻¹</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">c</span><span class="bp">⁻¹</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="kd">by</span>
<span class="w">  </span><span class="n">simp</span>
</code></pre></div>
</div>

<p>How would a human solve that goal? They would notice that <code>a * a⁻¹ = 1</code>,
that <code>1 * 1 = 1</code>, and so on, until they had simplified the example
to <code>b = b</code>, which is obviously true.</p>
<p>This is also what the simplifier is doing.  Indeed, if you add
<code>set_option trace.Meta.Tactic.simp.rewrite true</code> above the example, then a
squiggly blue underline will appear under <code>simp</code> (in VS Code) and
clicking on this will show you the sequence of rewrites that <code>simp</code>
performed:</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="o">[</span><span class="n">Meta.Tactic.simp.rewrite</span><span class="o">]</span><span class="w"> </span><span class="bp">@</span><span class="n">mul_right_inv</span><span class="o">:</span><span class="mi">1000</span><span class="o">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">a</span><span class="bp">⁻¹</span><span class="w"> </span><span class="bp">==&gt;</span><span class="w"> </span><span class="mi">1</span>

<span class="o">[</span><span class="n">Meta.Tactic.simp.rewrite</span><span class="o">]</span><span class="w"> </span><span class="bp">@</span><span class="n">mul_one</span><span class="o">:</span><span class="mi">1000</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="bp">==&gt;</span><span class="w"> </span><span class="mi">1</span>

<span class="o">[</span><span class="n">Meta.Tactic.simp.rewrite</span><span class="o">]</span><span class="w"> </span><span class="bp">@</span><span class="n">one_mul</span><span class="o">:</span><span class="mi">1000</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">==&gt;</span><span class="w"> </span><span class="n">b</span>

<span class="o">[</span><span class="n">Meta.Tactic.simp.rewrite</span><span class="o">]</span><span class="w"> </span><span class="bp">@</span><span class="n">mul_inv_cancel_right</span><span class="o">:</span><span class="mi">1000</span><span class="o">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">c</span><span class="bp">⁻¹</span><span class="w"> </span><span class="bp">==&gt;</span><span class="w"> </span><span class="n">b</span>

<span class="o">[</span><span class="n">Meta.Tactic.simp.rewrite</span><span class="o">]</span><span class="w"> </span><span class="bp">@</span><span class="n">eq_self</span><span class="o">:</span><span class="mi">1000</span><span class="o">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">==&gt;</span><span class="w"> </span><span class="n">True</span>
</code></pre></div>
</div>

<p>The <code>simp?</code> tactic is a useful way to extract the list of lemmas that <code>simp</code> applied.
It suggests</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="n">simp</span><span class="w"> </span><span class="n">only</span><span class="w"> </span><span class="o">[</span><span class="n">mul_right_inv</span><span class="o">,</span><span class="w"> </span><span class="n">mul_one</span><span class="o">,</span><span class="w"> </span><span class="n">one_mul</span><span class="o">,</span><span class="w"> </span><span class="n">mul_inv_cancel_right</span><span class="o">]</span>
</code></pre></div>
</div>

<p>which is an invocation of <code>simp</code> that makes use of this particular set of four lemmas.</p>
<p>To see both those rewrites that work and those that fail during the simplification process,
you can use the more verbose option <code>set_option trace.Meta.Tactic.simp true</code>.</p>
<h2 id="simp-lemmas" class="markdown-heading">Simp lemmas <a class="hover-link" href="#simp-lemmas">#</a></h2>
<p>So how did Lean's simplifier know that <code>a * a⁻¹ = 1</code>? It is because
there is a lemma in <code>Mathlib.Algebra.Group.Defs</code> that is tagged with the
<code>simp</code> attribute:</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="kd">@[</span><span class="n">simp</span><span class="kd">]</span><span class="w"> </span><span class="kd">lemma</span><span class="w"> </span><span class="n">mul_right_inv</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">G</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">a</span><span class="bp">⁻¹</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="bp">...</span>
</code></pre></div>
</div>

<p>We call lemmas tagged with the <code>simp</code> attribute &quot;<code>simp</code> lemmas&quot;. Here
are some more examples of <code>simp</code> lemmas in mathlib:</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="kd">@[</span><span class="n">simp</span><span class="kd">]</span><span class="w"> </span><span class="kd">theorem</span><span class="w"> </span><span class="n">Nat.dvd_one</span><span class="w"> </span><span class="o">{</span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ℕ</span><span class="o">}</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">∣</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="bp">↔</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="bp">...</span>
<span class="kd">@[</span><span class="n">simp</span><span class="kd">]</span><span class="w"> </span><span class="kd">theorem</span><span class="w"> </span><span class="n">mul_eq_zero</span><span class="w"> </span><span class="o">{</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ℕ</span><span class="o">}</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="bp">↔</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="bp">∨</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="bp">...</span>
<span class="kd">@[</span><span class="n">simp</span><span class="kd">]</span><span class="w"> </span><span class="kd">theorem</span><span class="w"> </span><span class="n">List.mem_singleton</span><span class="w"> </span><span class="o">{</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">α</span><span class="o">}</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">∈</span><span class="w"> </span><span class="o">[</span><span class="n">b</span><span class="o">]</span><span class="w"> </span><span class="bp">↔</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="bp">...</span>
<span class="kd">@[</span><span class="n">simp</span><span class="kd">]</span><span class="w"> </span><span class="kd">theorem</span><span class="w"> </span><span class="n">Set.setOf_false</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">{</span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">α</span><span class="w"> </span><span class="bp">|</span><span class="w"> </span><span class="n">False</span><span class="o">}</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="bp">∅</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="bp">...</span>
</code></pre></div>
</div>

<p>When the simplifier is attempting to simplify a term <code>T</code>, it looks
through the <code>simp</code> lemmas known to the system at that time, and if it
runs into an applicable lemma of the form <code>A = B</code> or <code>A ↔ B</code> for which
<code>A</code> appears as a subexpression in <code>T</code>, it rewrites the instance of <code>A</code> in <code>T</code> with <code>B</code>
and then starts again from the beginning. Note that <code>simp</code> starts on
innermost terms, working outward: it first simplifies the arguments of
a function before simplifying the function. Also, <code>simp</code> contains some
amount of cleverness to be able to avoid considering <em>all</em> <code>simp</code>
lemmas every time (there are over fourty thousand of them in mathlib as per February 2026).</p>
<p>The simplifier applies <code>simp</code> lemmas in one direction only: if <code>A = B</code> is a <code>simp</code>
lemma, then <code>simp</code> replaces <code>A</code>s with <code>B</code>s, but it doesn't replace
<code>B</code>s with <code>A</code>s. Hence a <code>simp</code> lemma should have the property that its
right-hand side is simpler than its left-hand side. In
particular, <code>=</code> and <code>↔</code> should not be viewed as symmetric operators in
this situation. The following would be a terrible <code>simp</code> lemma (if it
were even allowed):</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="kd">@[</span><span class="n">simp</span><span class="kd">]</span><span class="w"> </span><span class="kd">lemma</span><span class="w"> </span><span class="n">mul_right_inv_bad</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">G</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">a</span><span class="bp">⁻¹</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="bp">...</span>
</code></pre></div>
</div>

<p>Replacing <code>1</code> with <code>a * a⁻¹</code> is not a sensible default direction to
travel. Even worse would be a lemma that causes expressions to grow
without bound, causing <code>simp</code> to loop forever:</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="kd">@[</span><span class="n">simp</span><span class="kd">]</span><span class="w"> </span><span class="kd">lemma</span><span class="w"> </span><span class="n">even_worse_lemma</span><span class="o">:</span><span class="w"> </span><span class="o">(</span><span class="mi">1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">G</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="mi">1</span><span class="bp">⁻¹</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="bp">...</span>
</code></pre></div>
</div>

<p>When making a new definition, it is very common to also introduce
<code>simp</code> lemmas to put expressions involving the definition into a
sensible form. An example of this is in mathlib's
<a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Data/Complex/Basic.lean">Data.Complex.Basic</a>,
which has almost 100 <code>simp</code> lemmas. Even though they are true by definition, theorems such as</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="kd">@[</span><span class="n">simp</span><span class="kd">]</span><span class="w"> </span><span class="kd">lemma</span><span class="w"> </span><span class="n">add_re</span><span class="w"> </span><span class="o">(</span><span class="n">z</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ℂ</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">(</span><span class="n">z</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">w</span><span class="o">)</span><span class="bp">.</span><span class="n">re</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">z.re</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">w.re</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>
</code></pre></div>
</div>

<p>are introduced because they give <code>simp</code> the ability to reduce expressions and then make use of pre-existing facts.
This one, for example, converts complex addition into real addition.
If you give <code>simp</code> permission to use commutativity of real addition, then it is able to
automatically prove <code>(z + w).re = (w + z).re</code> through <code>z.re + w.re = w.re + z.re</code>, which is half of the proof that complex addition is commutative.</p>
<p>The Lean kernel itself is a rewrite system for lambda calculus, which has a definite
notion of forward progress.  With this in mind, a useful family of
<code>simp</code> lemmas are those that, in this sense, let <code>simp</code> partially evaluate an
expression. For example, if you have a structure type <code>Foo</code> and
define a structure <code>myFoo</code> with that type,</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="kd">structure</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="n">where</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ℕ</span>

<span class="kd">def</span><span class="w"> </span><span class="n">myFoo</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="n">where</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">37</span>
</code></pre></div>
</div>

<p>then if you add a <code>simp</code> lemma that <code>myFoo.n = 37</code>, you give the simplifier the
ability to evaluate the <code>Foo.n</code> projection for <code>myFoo</code>, which saves you from having
to unfold the definition of <code>myFoo</code> (by default <code>simp</code> does not unfold most definitions).
Creating these <code>simp</code> lemmas is so common that there is
<a href="https://leanprover-community.github.io/mathlib4_docs/Mathlib/Tactic/Simps/Basic.html#simpsAttr">an attribute</a>
that creates them all for you automatically:</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="kd">@[</span><span class="n">simps</span><span class="kd">]</span><span class="w"> </span><span class="kd">def</span><span class="w"> </span><span class="n">myFoo</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="n">where</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">37</span>
</code></pre></div>
</div>

<p>This generates the lemma <code>@[simp] lemma myFoo_n : myFoo.n = 37</code>.</p>
<h2 id="basic-usage" class="markdown-heading">Basic usage <a class="hover-link" href="#basic-usage">#</a></h2>
<ul>
<li>
<p><code>simp</code> tries to simplify the goal using all <code>simp</code> lemmas known to
Lean at that time.</p>
</li>
<li>
<p><code>simp [h1, h2]</code> uses all <code>simp</code> lemmas and also <code>h1</code> and <code>h2</code> (which can either be local hypotheses or other lemmas which are not tagged <code>simp</code> for some reason).</p>
</li>
<li>
<p><code>simp [← h]</code> uses all <code>simp</code> lemmas, and also <code>h : A = B</code> but in the form <code>B = A</code> (so <code>simp</code> rewrites <code>B</code>s to <code>A</code>s)</p>
</li>
<li>
<p><code>simp [-thm]</code> stops <code>simp</code> from using the <code>simp</code> lemma named <code>thm</code>.</p>
</li>
<li>
<p><code>simp [*]</code> uses all <code>simp</code> lemmas and also all current local hypotheses to try to simplify the goal.</p>
</li>
<li>
<p><code>simp at h</code> tries to simplify <code>h</code> using all <code>simp</code> lemmas.</p>
</li>
<li>
<p><code>simp [h1] at h2 ⊢</code> tries to simplify both <code>h2</code> and the goal using <code>h1</code> and all <code>simp</code> lemmas (note: type <code>⊢</code> with <code>\|-</code> or <code>\vdash</code> in VS Code).</p>
</li>
<li>
<p><code>simp [*] at *</code> : tries to simplify both the goal and all hypotheses, using all hypotheses and all <code>simp</code> lemmas. Sometimes worth a try.</p>
</li>
<li>
<p><code>simp only [h1, h2, ..., hn]</code> tells <code>simp</code> to use only the lemmas <code>h1</code>, <code>h2</code>, ..., rather than the full set of simp lemmas.
(It is acceptable to use <code>simp only [...]</code> in the middle of a proof, because subsequent changes to the <code>simp</code> set will not break the proof.)</p>
</li>
<li>
<p><code>simp [↓h1]</code> uses <code>h1</code> before entering the subterms. Usually, <code>simp</code> uses lemmas after entering the subterms.</p>
</li>
<li>
<p><code>simp [↑h1]</code> uses <code>h1</code> after entering the subterms. This syntax is used for a lemma tagged with <code>simp↓</code>.</p>
</li>
</ul>
<p>Note that some <code>simp</code> lemmas have additional hypotheses that must be satisfied.
For example, a theorem about cancelling a factor on both sides of an equation would
only be valid under the hypothesis that the factor is non-zero. If <code>h</code>
is a proof of hypothesis <code>P</code> and <code>P → A = B</code> is a <code>simp</code> lemma, then
<code>simp [h]</code> will replace <code>A</code>'s with <code>B</code>'s in the goal. The fact that
<code>simp</code> considers additional hypotheses is the reason it is called a
<em>conditional</em> term rewriting system.</p>
<h2 id="simp-normal-form" class="markdown-heading">Simp-normal form <a class="hover-link" href="#simp-normal-form">#</a></h2>
<p>There are sometimes several ways to say the same thing. For example,
if <code>n : ℕ</code> then the hypotheses <code>n ≠ 0</code>, <code>0 ≠ n</code>, <code>n &gt; 0</code>, <code>0 &lt; n</code>,
<code>1 ≤ n</code> and <code>n ≥ 1</code> are all logically equivalent. This can be
problematic for rewriting systems like the simplifier. The reason for this is
that the simplifier looks for subterms using <em>syntactic equality</em>. If the
simplifier is working on a term <code>T</code> and <code>A = B</code> is a <code>simp</code> lemma,
then, unless a subterm <code>A'</code> of <code>T</code> is syntactically the same as <code>A</code>
(approximately: they have literally the same textual representation), then <code>simp</code> won't
in general notice the rule applies, so it won't
be rewritten to <code>B</code>. Similarly, if nonzeroness of <code>n</code> (stated in
one way) is a precondition in a <code>simp</code> lemma of the form <code>A = B</code>, and <code>h</code> is a proof
of nonzeroness of <code>n</code> (stated in a different way), then <code>simp [h]</code> might
not replace <code>A</code>'s with <code>B</code>'s.</p>
<p>The way this issue is dealt with in mathlib is to fix once and for
all a <em><code>simp</code> normal form</em> for the way something is to be expressed
(like <code>0 &lt; n</code> for nonzeroness) and then sticking to this variant when
stating lemmas. This saves having to write duplicate lemmas
for every variant. To help the simplifier out, many times there are
normalizing lemmas whose only purpose is to put expressions into
<code>simp</code> normal form.</p>
<p>In general, if you are writing a lemma, you should know the &quot;normal
form&quot; way to express the ideas in the lemma. If you are writing a
lemma about a definition you made yourself, think about the normal
forms for ideas that can be expressed in more than one way.</p>
<p>An example of a <code>simp</code> normal form is a way of expressing nonemptiness
of a subset of a type.  If <code>α : Type</code> and <code>s : Set α</code> then
nonemptiness of <code>s</code> can be expressed both as <code>s.Nonempty</code> and <code>s ≠ ∅</code>.
In mathlib an effort is made to stick to <code>s.Nonempty</code> as the normal
form.</p>
<p>Another example: every finite set <code>s : Finset α</code> can be coerced
to <code>Set α</code>, so for <code>a : α</code> one can write both <code>a ∈ s</code> and
<code>a ∈ (s : Set α)</code> to mean the same thing.  The simp normal form for
membership in a finite set is <code>a ∈ s</code>, and moreover there is a
normalizing <code>simp</code> lemma</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="kd">@[</span><span class="n">simp</span><span class="kd">]</span><span class="w"> </span><span class="kd">lemma</span><span class="w"> </span><span class="n">mem_coe</span><span class="w"> </span><span class="o">{</span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">α</span><span class="o">}</span><span class="w"> </span><span class="o">{</span><span class="n">s</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Finset</span><span class="w"> </span><span class="n">α</span><span class="o">}</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">∈</span><span class="w"> </span><span class="o">(</span><span class="n">s</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Set</span><span class="w"> </span><span class="n">α</span><span class="o">)</span><span class="w"> </span><span class="bp">↔</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">∈</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="bp">...</span>
</code></pre></div>
</div>

<p>to replace occurrences of <code>a ∈ (s : Set α)</code> with the correct normal form.</p>
<p>Because the simplifier works from the inside out, simplifying
arguments of a function before simplifying the function, a <code>simp</code>
lemma should have the arguments to the function on its left-hand side in simp-normal
form. For example if <code>g 0</code> can be simplified, then <code>@[simp] lemma foo : f (g 0) = 0</code> will never be used.
Batteries' <code>simpNF</code> <a href="https://leanprover-community.github.io/mathlib4_docs/Batteries/Tactic/Lint/Frontend.html">linter</a> checks for this
(you can run mathlib's linters for a module yourself by putting <code>#lint</code> at the end of the file).</p>
<h2 id="simpa" class="markdown-heading"><code>simpa</code> <a class="hover-link" href="#simpa">#</a></h2>
<p>The <code>simpa</code> tactic is a variation on <code>simp</code> for finishing a proof -- as a &quot;finishing&quot; tactic, it will fail
if it's unable to close the goal.  The basic usage is</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="n">simpa</span><span class="w"> </span><span class="o">[</span><span class="n">h1</span><span class="o">,</span><span class="w"> </span><span class="n">h2</span><span class="o">]</span><span class="w"> </span><span class="n">using</span><span class="w"> </span><span class="n">e</span>
</code></pre></div>
</div>

<p>where <code>[h1, h2]</code> refers to an optional list of <code>simp</code> lemmas (using the same syntax as for <code>simp</code>)
and where <code>e</code> is an expression.  Commonly, <code>e</code> is the name of a hypothesis.
Both the type of <code>e</code> and the goal are simplified, and <code>simpa</code> succeeds if they are both simplified to the same thing.</p>
<p>Here is a simple example of <code>simpa</code>:</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ℕ</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="bp">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="bp">≠</span><span class="w"> </span><span class="mi">0</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="bp">≠</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="kd">by</span>
<span class="w">  </span><span class="n">simpa</span><span class="w"> </span><span class="n">using</span><span class="w"> </span><span class="n">h</span>
</code></pre></div>
</div>

<p>Without <code>simpa</code>, we might do <code>simp at ⊢ h; exact h</code>.
So-called &quot;non-terminal <code>simp</code>s&quot;, which are usages of <code>simp</code> that do not close a goal,
are best to be avoided (see the next section), and <code>simpa</code> is a way to avoid them.</p>
<p>If the <code>using</code> clause is not present, then <code>simpa</code> does the following three steps instead:</p>
<ol>
<li>The goal is simplified.</li>
<li>If a hypothesis named <code>this</code> is in the local context, then its type is simplified.</li>
<li>The <code>assumption</code> tactic is applied.</li>
</ol>
<p>Step 2 is to support a pattern where <code>simpa</code> follows a <code>have : P</code> or <code>suffices : P</code>, since
both of these default to using <code>this</code> as the name of the hypothesis they introduce.</p>
<h2 id="non-terminal-simps" class="markdown-heading">Non-terminal <code>simp</code>s <a class="hover-link" href="#non-terminal-simps">#</a></h2>
<p>The behaviour of <code>simp</code> changes over time as <code>simp</code> lemmas are added
to (or removed from) the library.  This means that proofs that use
<code>simp</code> can break, and, unless you know how the set of <code>simp</code> lemmas has
changed, it can be difficult to fix a proof.</p>
<p>For example if a proof looked like</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="w">  </span><span class="bp">...</span>
<span class="w">  </span><span class="n">simp</span>
<span class="w">  </span><span class="n">rw</span><span class="w"> </span><span class="o">[</span><span class="n">foo_eq_bar</span><span class="o">]</span>
<span class="w">  </span><span class="bp">...</span>
</code></pre></div>
</div>

<p>and then later someone added the <code>@[simp]</code> attribute to <code>foo_eq_bar</code>,
this rewrite would now fail.</p>
<p>While it is fine using <code>simp</code> in the middle of a proof during initial development,
the rule of thumb is that it is
easier to maintain Lean code when every <code>simp</code> closes a goal
completely.  When such a <code>simp</code> later breaks, this ensures that the
intended goal is known.</p>
<p>There are a few &quot;approved&quot; uses of <code>simp</code> for the middle of a proof:</p>
<ol>
<li>
<p><code>simp only [h1, h2, ..., hn]</code> to constrain <code>simp</code> to using only
lemmas from the given list, so it is not affected by changes to the
set of <code>simp</code> lemmas. Hint: use <code>simp?</code> to
automatically generate an appropriate <code>simp only</code>.</p>
</li>
<li>
<p>Use a construct like <code>have h : P := by ...; simp</code> to introduce a
hypothesis proved by <code>simp</code>. The <code>have</code> expression might be in the
middle of a proof, but the <code>simp</code> is closing the goal it introduces.</p>
</li>
<li>
<p>If <code>simp</code> turns your goal into <code>P</code>, then you can write</p>
</li>
</ol>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="w">  </span><span class="k">suffices</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">P</span><span class="w"> </span><span class="kd">by</span><span class="w"> </span><span class="n">simpa</span>
</code></pre></div>
</div>

<p>This adds a new goal of <code>P</code> after the current one, introduces a new
hypothesis <code>this : P</code>, simplifies both the goal and <code>this</code>,
then attempts to close the goal with <code>this</code>.  The <code>simpa</code> tactic <em>requires</em>
that a goal be closed, unlike <code>simp</code>, which makes it easier to know when it breaks.
The explicit <code>P</code> in the source code helps in finding a fix.</p>
<p>One way non-terminal <code>simp</code>s can appear is in a sequence of tactics like <code>simp at ⊢ h; exact h</code>.
These can be replaced by <code>simpa using h</code>.</p>
<h2 id="dsimp" class="markdown-heading"><code>dsimp</code> <a class="hover-link" href="#dsimp">#</a></h2>
<p><code>dsimp</code> is a variant of <code>simp</code> that only uses &quot;definitional&quot; <code>simp</code>
lemmas.  These are <code>simp</code> lemmas whose proof is <code>rfl</code> or <code>Iff.rfl</code>,
that is, lemmas where the two sides are equal by definition.</p>
<p>Like <code>simp</code> it is recommended that you do not use it in the middle of
a proof.  However if <code>dsimp</code> turns your goal into <code>h</code> then <code>change h</code>
will likely do the same thing.  Another common use of <code>dsimp</code> is</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="n">dsimp</span><span class="w"> </span><span class="n">only</span>
</code></pre></div>
</div>

<p>which is short for <code>dsimp only []</code>, a <code>dsimp</code> with an empty set of <code>simp</code> lemmas.
This can be safely used in the middle of a proof, and it can be a useful
way to tidy up a goal: among other things, it does beta reduction for lambda expressions
(it will turn <code>(fun x =&gt; f x) 37</code> into <code>f 37</code>) and it will reduce structure projections
(it will turn <code>{ toFun := f, ... }.toFun</code> into <code>f</code>).</p>
<h2 id="more-advanced-features" class="markdown-heading">More advanced features <a class="hover-link" href="#more-advanced-features">#</a></h2>
<h3 id="discharger" class="markdown-heading">Discharger <a class="hover-link" href="#discharger">#</a></h3>
<p>Lean has the following theorem:</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="kd">theorem</span><span class="w"> </span><span class="n">Nat.max_eq_left</span><span class="w"> </span><span class="o">{</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ℕ</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">≤</span><span class="w"> </span><span class="n">a</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">max</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">a</span>
</code></pre></div>
</div>

<p>However, <code>simp</code> can't prove the following goal with only this theorem.</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">max</span><span class="w"> </span><span class="o">(</span><span class="mi">1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ℕ</span><span class="o">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="kd">by</span>
<span class="w">  </span><span class="n">simp</span><span class="w"> </span><span class="n">only</span><span class="w"> </span><span class="o">[</span><span class="n">Nat.max_eq_left</span><span class="o">]</span>
<span class="c1">-- simp made no progress</span>
</code></pre></div>
</div>

<p>This is because <code>simp</code> fails to solve the side condition <code>(0 : ℕ) ≤ 1</code>; this can be seen with the command <code>set_option trace.Meta.Tactic.simp.discharge true</code>.</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="o">[</span><span class="n">Meta.Tactic.simp.discharge</span><span class="o">]</span><span class="w"> </span><span class="bp">@</span><span class="n">Nat.max_eq_left</span><span class="w"> </span><span class="n">discharge</span><span class="w"> </span><span class="bp">❌</span>
<span class="w">      </span><span class="mi">0</span><span class="w"> </span><span class="bp">≤</span><span class="w"> </span><span class="mi">1</span>
</code></pre></div>
</div>

<p>This side condition can be solved simply using <code>decide</code>:</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">(</span><span class="mi">0</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ℕ</span><span class="o">)</span><span class="w"> </span><span class="bp">≤</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="kd">by</span>
<span class="w">  </span><span class="n">decide</span>
</code></pre></div>
</div>

<p>How to use this tactic in <code>simp</code> to solve the side condition? Here is the answer:</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">max</span><span class="w"> </span><span class="o">(</span><span class="mi">1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ℕ</span><span class="o">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="kd">by</span>
<span class="w">  </span><span class="n">simp</span><span class="w"> </span><span class="o">(</span><span class="n">disch</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">decide</span><span class="o">)</span><span class="w"> </span><span class="n">only</span><span class="w"> </span><span class="o">[</span><span class="n">Nat.max_eq_left</span><span class="o">]</span>
</code></pre></div>
</div>

<h3 id="full-syntax" class="markdown-heading">Full syntax <a class="hover-link" href="#full-syntax">#</a></h3>
<p>This is the full syntax for the <code>dsimp</code> tactic:</p>
<blockquote>
<p><code>dsimp</code> (<code>?</code>)? (<code>!</code>)? (<code>(config :=</code> config <code>)</code>)? (<code>(disch :=</code> discharger <code>)</code>)? (<code>only</code>)? (<code>[</code>list of lemmas<code>]</code>)? (<code>at</code> locations)?</p>
</blockquote>
<p>where &quot;( ... )?&quot; means an optional part of the expression. The list of lemmas is similar to that of <code>rw</code>, but
additionally <code>-lemma_name</code> means a lemma is excluded from the set of <code>simp</code> lemmas.
Configuration options are described in a following section.</p>
<p>If <code>!</code> is present, it adds <code>autoUnfold := true</code> to the configuration options.
If <code>?</code> is present, it causes <code>simp</code> to suggest a set of <code>simp</code> lemmas that suffice.</p>
<p>This is the full syntax for the <code>simp</code> tactic:</p>
<blockquote>
<p><code>simp</code> (<code>?</code>)? (<code>!</code>)? (<code>(config :=</code> config <code>)</code>)? (<code>(disch :=</code> discharger <code>)</code>)? (<code>only</code>)? (<code>[</code>list of <code>*</code> and lemmas<code>]</code>)? (<code>at</code> locations)?</p>
</blockquote>
<p>This is the full syntax for the <code>simpa</code> tactic:</p>
<blockquote>
<p><code>simpa</code> (<code>?</code>)? (<code>!</code>)? (<code>(config :=</code> config <code>)</code>)? (<code>(disch :=</code> discharger <code>)</code>)? (<code>only</code>)? (<code>[</code>list of <code>*</code> and lemmas<code>]</code>)? (<code>using</code> expr)?</p>
</blockquote>
<p>The meanings are the same as for <code>simp</code>, but <code>using</code> can be given any expression, not just a local constant as required by <code>at</code>.</p>
<h3 id="custom-simp-attributes" class="markdown-heading">Custom simp attributes <a class="hover-link" href="#custom-simp-attributes">#</a></h3>
<p>Using the command <a href="https://leanprover-community.github.io/mathlib_docs/commands.html#mk_simp_attribute"><code>register_simp_attr</code></a>,
you can make your own <code>@[simp]</code>-like attribute, but with a key difference:
lemmas tagged with <code>@[new_attr]</code> are <em>not</em> in the default set of <code>simp</code> lemmas.
Instead, they should be included explicitly: <code>simp [new_attr]</code>. This can often replace lengthy
<code>simp only [...]</code> calls and facilitate easier-to-read code. Some examples of common usage are
<a href="https://leanprover-community.github.io/mathlib4_docs/Mathlib/Tactic/Attr/Register.html#Parser.Attr.mfld_simps"><code>mfld_simps</code></a>,
and <a href="https://leanprover-community.github.io/mathlib4_docs/Mathlib/Tactic/Attr/Register.html#Parser.Attr.field_simps"><code>field_simps</code></a>.</p>
<h3 id="configuration-options" class="markdown-heading">Configuration options <a class="hover-link" href="#configuration-options">#</a></h3>
<p>Both <code>simp</code> and <code>dsimp</code> can take additional configuration options using record syntax.
For example, <code>simp (config := { singlePass := true })</code> runs <code>simp</code> with the <code>singlePass</code> configuration option set to true.
One can use <code>singlePass</code> to avoid loops that might otherwise occur.</p>
<p>The core Lean file <code>Init/MetaTypes.lean</code> reveals other configuration options in
the <a href="https://leanprover-community.github.io/mathlib4_docs/Init/MetaTypes.html#Lean.Meta.DSimp.Config"><code>Lean.Meta.DSimp.Config</code></a> and <a href="https://leanprover-community.github.io/mathlib4_docs/Init/MetaTypes.html#Lean.Meta.Simp.Config"><code>Lean.Meta.Simp.Config</code></a> structures.
Most of them are not very relevant for the average user,
and some of them are not fully documented.  These are reproduced in the
following table, where the default value for a configuration option
for <code>simp</code> or <code>dsimp</code> is given in the respective column -- if no
default value is present, that option is unavailable.
The &quot;max&quot; default value refers to <code>Lean.Meta.Simp.defaultMaxSteps</code>, which is currently <code>100000</code>.</p>
<table>
<thead>
<tr>
<th align="left">Option</th>
<th align="left"><code>simp</code></th>
<th align="left"><code>dsimp</code></th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>maxSteps</code></td>
<td align="left">max</td>
<td align="left"></td>
<td align="left">The maximum number of steps allowed before failing</td>
</tr>
<tr>
<td align="left"><code>maxDischargeDepth</code></td>
<td align="left">2</td>
<td align="left"></td>
<td align="left">The maximum recursion depth when recursively applying simplification to side conditions</td>
</tr>
<tr>
<td align="left"><code>contextual</code></td>
<td align="left"><code>false</code></td>
<td align="left"></td>
<td align="left">Use additional <code>simp</code> lemmas based on the context of the current subexpression (see example below)</td>
</tr>
<tr>
<td align="left"><code>memoize</code></td>
<td align="left"><code>true</code></td>
<td align="left"></td>
<td align="left">Perform caching of simps of subterms</td>
</tr>
<tr>
<td align="left"><code>singlePass</code></td>
<td align="left"><code>false</code></td>
<td align="left"></td>
<td align="left">Visit each subterm no more than once</td>
</tr>
<tr>
<td align="left"><code>zeta</code></td>
<td align="left"><code>true</code></td>
<td align="left"><code>true</code></td>
<td align="left">Do zeta-reductions: <code>let x := a; b</code> ↝ <code>b[x := a]</code></td>
</tr>
<tr>
<td align="left"><code>beta</code></td>
<td align="left"><code>true</code></td>
<td align="left"><code>true</code></td>
<td align="left">Do beta-reductions: <code>(fun x =&gt; a) y</code> ↝ <code>a[x := y]</code></td>
</tr>
<tr>
<td align="left"><code>eta</code></td>
<td align="left"><code>true</code></td>
<td align="left"><code>true</code></td>
<td align="left">Allow eta-equivalence: <code>(fun x =&gt; f x)</code> ↝ <code>f</code> (currently unimplemented)</td>
</tr>
<tr>
<td align="left"><code>etaStruct</code></td>
<td align="left"><code>.all</code></td>
<td align="left"><code>.all</code></td>
<td align="left">Configures how to determine definitional equality between two structure instances. See documentation for <a href="https://leanprover-community.github.io/mathlib4_docs/Init/MetaTypes.html#Lean.Meta.EtaStructMode"><code>Lean.Meta.EtaStructMode</code></a></td>
</tr>
<tr>
<td align="left"><code>iota</code></td>
<td align="left"><code>true</code></td>
<td align="left"><code>true</code></td>
<td align="left">Reduce recursors: <code>Nat.recOn (succ n) Z R</code> ↝ <code>R n (Nat.recOn n Z R)</code></td>
</tr>
<tr>
<td align="left"><code>proj</code></td>
<td align="left"><code>true</code></td>
<td align="left"><code>true</code></td>
<td align="left">Reduce projections: <code>Prod.fst (a, b)</code> ↝ <code>a</code></td>
</tr>
<tr>
<td align="left"><code>decide</code></td>
<td align="left"><code>false</code></td>
<td align="left"><code>false</code></td>
<td align="left">Rewrites a proposition <code>p</code> to <code>True</code> or <code>False</code> by inferring a <code>Decidable p</code> instance and reducing it</td>
</tr>
<tr>
<td align="left"><code>arith</code></td>
<td align="left"><code>false</code></td>
<td align="left"></td>
<td align="left">Simplifies simple arithmetic expressions</td>
</tr>
<tr>
<td align="left"><code>autoUnfold</code></td>
<td align="left"><code>false</code></td>
<td align="left"><code>false</code></td>
<td align="left">Reduce using all equation lemmas generated by the equation compiler</td>
</tr>
<tr>
<td align="left"><code>dsimp</code></td>
<td align="left"><code>true</code></td>
<td align="left"></td>
<td align="left">When <code>true</code> then switches to <code>dsimp</code> on dependent arguments if there is no congruence theorem that would allow <code>simp</code> to visit them. When <code>dsimp</code> is <code>false</code>, then the argument is not visited.</td>
</tr>
<tr>
<td align="left"><code>failIfUnchanged</code></td>
<td align="left"><code>true</code></td>
<td align="left"><code>true</code></td>
<td align="left">Fail if no simplifications applied</td>
</tr>
<tr>
<td align="left"><code>ground</code></td>
<td align="left"><code>false</code></td>
<td align="left"></td>
<td align="left">Ground terms are reduced. A term is ground when it does not contain free or meta variables.</td>
</tr>
<tr>
<td align="left"><code>unfoldPartialApp</code></td>
<td align="left"><code>false</code></td>
<td align="left"><code>false</code></td>
<td align="left">Unfold even partial applications of <code>f</code> when we request <code>f</code> to be unfolded</td>
</tr>
<tr>
<td align="left"><code>zetaDelta</code></td>
<td align="left"><code>false</code></td>
<td align="left"><code>false</code></td>
<td align="left">Local definitions are unfolded. That is, given a local context containing entry <code>x : t := e</code>, the free variable <code>x</code> reduces to <code>e</code>.</td>
</tr>
</tbody>
</table>
<p><code>autoUnfold</code> adds equation lemmas generated by the
equation/pattern-matching compiler to the set of <code>simp</code> lemmas.</p>
<p>The <code>contextual</code> option gives <code>simp</code> the ability to consider
hypotheses as additional <code>simp</code> lemmas based on a subexpression's
surrounding context. For example, as it simplifies the consequent of an
implication it temporarily adds the antecedent as a <code>simp</code> lemma. This
is necessary for the following example:</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="kd">example</span><span class="w"> </span><span class="o">{</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ℕ</span><span class="o">}</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="bp">→</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="bp">→</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="kd">by</span>
<span class="w">  </span><span class="n">simp</span><span class="w"> </span><span class="o">(</span><span class="n">config</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">contextual</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">true</span><span class="w"> </span><span class="o">})</span>
</code></pre></div>
</div>

  </main>

    <nav id="navbar" class="d-md-block bg-light sidebar collapse navbar-light pb-4">
      <div class="d-none d-md-block mt-4"><a class="navbar-brand" href="https://leanprover-community.github.io/index.html">Lean Community</a></div>
      
        <h6 class="sidebar-heading mt-4">Community</h6>
        <ul class="nav">
          <li class="nav-item col-12"><a href="https://leanprover.zulipchat.com/">Zulip chat</a></li>
        
          <li class="nav-item col-12"><a href="https://github.com/leanprover-community/mathlib4">GitHub</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/blog">Blog</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/meet.html">Community information</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/meet.html#community-guidelines">Community guidelines</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/teams.html">Teams</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/papers.html">Papers about Lean</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/cite.html">Citing mathlib</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/lean_projects.html">Projects using Lean</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/teaching/index.html">Teaching using Lean</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/events.html">Events</a></li>
        </ul>
      
        <h6 class="sidebar-heading mt-4">Use Lean</h6>
        <ul class="nav">
          <li class="nav-item col-12"><a href="https://live.lean-lang.org/">Online version (no installation)</a></li>
        
          <li class="nav-item col-12"><a href="https://docs.lean-lang.org/lean4/doc/quickstart.html">Install Lean</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/get_started.html">More options</a></li>
        </ul>
      
        <h6 class="sidebar-heading mt-4">Documentation</h6>
        <ul class="nav">
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/learn.html">Learning resources (start here)</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/documentation.html">Documentation overview</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/mathlib4_docs">API documentation</a></li>
        
          <li class="nav-item col-12"><a href="https://loogle.lean-lang.org/">Declaration search (Loogle)</a></li>
        
          <li class="nav-item col-12"><a href="https://lean-lang.org/doc/reference/latest/">Language reference</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/mathlib-manual/html-multi/">Tactic list</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/glossary.html">Glossary</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/did_you_prove_it.html">Did you really prove it?</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/mwe.html">About MWEs</a></li>
        </ul>
      
        <h6 class="sidebar-heading mt-4">Library overviews</h6>
        <ul class="nav">
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/mathlib-overview.html">Library overview</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/undergrad.html">Undergraduate maths</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/100.html">Wiedijk's 100 theorems</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/1000.html">1000+ theorems</a></li>
        </ul>
      
        <h6 class="sidebar-heading mt-4">Theories</h6>
        <ul class="nav">
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/theories/naturals.html">Natural Numbers</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/theories/linear_algebra.html">Linear Algebra</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/theories/sets.html">Sets and finite sets</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/theories/topology.html">Topology</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/theories/category_theory.html">Category Theory</a></li>
        </ul>
      
        <h6 class="sidebar-heading mt-4">Contributing</h6>
        <ul class="nav">
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/contribute/index.html">Pull request lifecycle</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/queueboard/">Mathlib review and triage dashboard</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/contribute/git.html">Git Guide for Mathlib4 Contributors</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/contribute/naming.html">Naming conventions</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/contribute/style.html">Code style guideline</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/contribute/doc.html">Documentation style</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/contribute/commit.html">Commit conventions</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/contribute/pr-review.html">Pull request review guide</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/mathlib_stats.html">Contribution statistics</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/contribute/tags_and_branches.html">Tags and branches</a></li>
        </ul>
      
    </nav>

</div>


  <nav class="footer navbar navbar-expand-lg navbar-light bg-light justify-content-end">
  <ul class="nav">
    <li class="nav-item">
      <a class="nav-link active" href="https://github.com/leanprover-community/leanprover-community.github.io/blob/lean4/templates/extras/simp.md">Suggest edits to this page on GitHub</a>
    </li>
  </ul>
  </nav>

    <script src="https://code.jquery.com/jquery-3.5.1.min.js"
      integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0="
      crossorigin="anonymous"></script>
    <script src="https://leanprover-community.github.io//js/bootstrap.min.js"></script>
    <script type="module">
      import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
      mermaid.initialize({ startOnLoad: true });
    </script>
    
  </body>
</html>