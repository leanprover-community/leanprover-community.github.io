<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="https://leanprover-community.github.io//css/lean.css" >
  <link rel="shortcut icon" href="https://leanprover-community.github.io//img/favicon.ico">
  <link rel="search" type="application/opensearchdescription+xml" title="mathlib docs" href="https://leanprover-community.github.io//opensearch.xml">
  <link href="https://fonts.googleapis.com/css2?family=Merriweather&family=Open+Sans&family=Source+Code+Pro:wght@400;600&display=swap" rel="stylesheet">
    

	<script>
                function buildShortcutsForStructures(names) {
                        const o = {}
                        names.forEach(name => o[name] = `\\mathbb\{${name}\}`)
                        return o
                }
		MathJax = {
			  tex: {
                                  macros: {
                                          ...buildShortcutsForStructures(["R", "Q", "Z", "N", "C"]),
                                  },
				      inlineMath: [['$', '$'], ['\\(', '\\)']]
				    },
		};
	</script>
	<script type="text/javascript" id="MathJax-script" async
		  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
	</script>

	<title>Maths in Lean: Topological, uniform and metric spaces</title>
  </head>
  <body>
  <nav class="navbar navbar-expand-lg navbar-light bg-gradient-light d-md-none">
    <div class="d-flex flex-grow-1">
		<a class="navbar-brand" href="https://leanprover-community.github.io/index.html">Lean Community
    </a>
    </div>

    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
  </nav>

<div id="mainbox">

  <main>
    
<h1 id="maths-in-lean-topological-uniform-and-metric-spaces" class="markdown-heading">Maths in Lean: Topological, uniform and metric spaces <a class="hover-link" href="#maths-in-lean-topological-uniform-and-metric-spaces">#</a></h1>
<p>The <code>TopologicalSpace</code> typeclass is defined in mathlib,
in <code>Mathlib.Topology.Defs.Basic</code>. There a lot of
lines of code in <code>topology</code>,covering the basics of topological spaces, continuous functions,
topological groups and rings, and infinite sums. These docs
are just concerned with the contents of the <code>Mathlib.Topology</code>
folder.</p>
<h3 id="the-basic-typeclass" class="markdown-heading">The basic typeclass <a class="hover-link" href="#the-basic-typeclass">#</a></h3>
<p>The <code>TopologicalSpace</code> typeclass is an inductive type, defined
as a structure on a type <code>Œ±</code> in the obvious way: there is an <code>IsOpen</code>
predicate, telling us when <code>U : Set Œ±</code> is open, and then the axioms
for a topology (pedantic note: the axiom that the empty set is open
is omitted, as it follows from the fact that a union of open sets
is open, applied to the empty union!).</p>
<p>Note that there are two ways of formalizing the axiom that an arbitrary
union of open sets is open: one could either ask that given a set
of open sets, their union is open, or one could ask that given
a function from some index set <code>I</code> to the set of open sets, the union
of the values of the function is open. Mathlib goes for the first
one, so the axiom is</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="n">isOpen_sUnion</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">‚àÄ</span><span class="w"> </span><span class="o">(</span><span class="n">s</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Set</span><span class="w"> </span><span class="o">(</span><span class="n">set</span><span class="w"> </span><span class="n">Œ±</span><span class="o">)),</span><span class="w"> </span><span class="o">(</span><span class="bp">‚àÄ</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="bp">‚àà</span><span class="w"> </span><span class="n">s</span><span class="o">,</span><span class="w"> </span><span class="n">IsOpen</span><span class="w"> </span><span class="n">t</span><span class="o">)</span><span class="w"> </span><span class="bp">‚Üí</span><span class="w"> </span><span class="n">IsOpen</span><span class="w"> </span><span class="o">(</span><span class="bp">‚ãÉ‚ÇÄ</span><span class="w"> </span><span class="n">s</span><span class="o">)</span>
</code></pre></div>
</div>

<p>and then the index set version is a lemma:</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="kd">lemma</span><span class="w"> </span><span class="n">isOpen_biUnion</span><span class="w"> </span><span class="o">{</span><span class="n">f</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Œπ</span><span class="w"> </span><span class="bp">‚Üí</span><span class="w"> </span><span class="n">Set</span><span class="w"> </span><span class="n">Œ±</span><span class="o">}</span><span class="w"> </span><span class="o">{</span><span class="n">s</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Set</span><span class="w"> </span><span class="n">Œπ</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">‚àÄ</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="bp">‚àà</span><span class="w"> </span><span class="n">s</span><span class="o">,</span><span class="w"> </span><span class="n">IsOpen</span><span class="w"> </span><span class="o">(</span><span class="n">f</span><span class="w"> </span><span class="n">i</span><span class="o">))</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">IsOpen</span><span class="w"> </span><span class="o">(</span><span class="bp">‚ãÉ</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="bp">‚àà</span><span class="w"> </span><span class="n">s</span><span class="o">,</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">i</span><span class="o">)</span>
</code></pre></div>
</div>

<p>Note the naming conventions, standard across mathlib, that <code>sUnion</code>
is a union over sets and <code>biUnion</code> is a union over
the image of a function on an indexing set. The capital U's are
to indicate a union of arbitrary size, as opposed to <code>union</code>, which
indicates a union of two sets:</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="kd">lemma</span><span class="w"> </span><span class="n">IsOpen.union</span><span class="w"> </span><span class="o">(</span><span class="n">h‚ÇÅ</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">is_open</span><span class="w"> </span><span class="n">s‚ÇÅ</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">h‚ÇÇ</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">is_open</span><span class="w"> </span><span class="n">s‚ÇÇ</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">is_open</span><span class="w"> </span><span class="o">(</span><span class="n">s‚ÇÅ</span><span class="w"> </span><span class="bp">‚à™</span><span class="w"> </span><span class="n">s‚ÇÇ</span><span class="o">)</span>
</code></pre></div>
</div>

<p>The predicate <code>IsClosed</code>, and functions <code>interior</code>, <code>closure</code>, and
<code>frontier</code> (closure minus interior,
sometimes called boundary in mathematics) are defined, and basic
properties about them are proved. For example</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="n">Mathlib.Topology.Basic</span>


<span class="kn">open</span><span class="w"> </span><span class="n">TopologicalSpace</span>
<span class="kd">variable</span><span class="w"> </span><span class="o">{</span><span class="n">X</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="o">}</span><span class="w"> </span><span class="o">[</span><span class="n">TopologicalSpace</span><span class="w"> </span><span class="n">X</span><span class="o">]</span><span class="w"> </span><span class="o">{</span><span class="n">U</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="n">D</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="n">Z</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Set</span><span class="w"> </span><span class="n">X</span><span class="o">}</span>

<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">IsClosed</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="bp">‚Üí</span><span class="w"> </span><span class="n">IsClosed</span><span class="w"> </span><span class="n">D</span><span class="w"> </span><span class="bp">‚Üí</span><span class="w"> </span><span class="n">IsClosed</span><span class="w"> </span><span class="o">(</span><span class="n">C</span><span class="w"> </span><span class="bp">‚à™</span><span class="w"> </span><span class="n">D</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">IsClosed.union</span>

<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">IsOpen</span><span class="w"> </span><span class="n">C</span><span class="bp">·∂ú</span><span class="w"> </span><span class="bp">‚Üî</span><span class="w"> </span><span class="n">IsClosed</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">isOpen_compl_iff</span>

<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">IsOpen</span><span class="w"> </span><span class="n">U</span><span class="w"> </span><span class="bp">‚Üí</span><span class="w"> </span><span class="n">IsClosed</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="bp">‚Üí</span><span class="w"> </span><span class="n">IsOpen</span><span class="w"> </span><span class="o">(</span><span class="n">U</span><span class="w"> </span><span class="bp">\</span><span class="w"> </span><span class="n">C</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">IsOpen.sdiff</span>

<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">interior</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="bp">‚Üî</span><span class="w"> </span><span class="n">IsOpen</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">interior_eq_iff_isOpen</span>

<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="bp">‚äÜ</span><span class="w"> </span><span class="n">Z</span><span class="w"> </span><span class="bp">‚Üí</span><span class="w"> </span><span class="n">interior</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="bp">‚äÜ</span><span class="w"> </span><span class="n">interior</span><span class="w"> </span><span class="n">Z</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">interior_mono</span>

<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">IsOpen</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="bp">‚Üî</span><span class="w"> </span><span class="bp">‚àÄ</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">‚àà</span><span class="w"> </span><span class="n">Y</span><span class="o">,</span><span class="w"> </span><span class="bp">‚àÉ</span><span class="w"> </span><span class="n">U</span><span class="w"> </span><span class="bp">‚äÜ</span><span class="w"> </span><span class="n">Y</span><span class="o">,</span><span class="w"> </span><span class="n">IsOpen</span><span class="w"> </span><span class="n">U</span><span class="w"> </span><span class="bp">‚àß</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">‚àà</span><span class="w"> </span><span class="n">U</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">isOpen_iff_forall_mem_open</span>

<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">closure</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="bp">‚Üî</span><span class="w"> </span><span class="n">IsClosed</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">closure_eq_iff_isClosed</span>

<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">closure</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="o">(</span><span class="n">interior</span><span class="w"> </span><span class="n">Y</span><span class="bp">·∂ú</span><span class="o">)</span><span class="bp">·∂ú</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">closure_eq_compl_interior_compl</span>
</code></pre></div>
</div>

<h3 id="filters" class="markdown-heading">Filters <a class="hover-link" href="#filters">#</a></h3>
<p>In mathlib, unlike the typical approach in a mathematics textbook, extensive
use is made of filters as a tool in the theory of topological spaces. Let
us briefly review the notion of a filter in mathematics. A filter on a set
<code>X</code> is a non-empty collection <code>F</code> of subsets of <code>X</code> satisfying the following
two axioms:</p>
<ol>
<li>if <code>U ‚àà F</code> and <code>U ‚äÜ V</code>, then <code>V ‚àà F</code>; and</li>
<li>if <code>U, V ‚àà F</code> then there exists <code>W ‚àà F</code> with <code>W ‚äÜ U ‚à© V</code>.</li>
</ol>
<p>Informally, one can think of <code>F</code> as the set of &quot;big&quot; subsets of <code>X</code>. For example, if <code>X</code> is a set and <code>F</code> is the set of subsets <code>Y</code> of <code>X</code> such that <code>X \ Y</code> is finite, then <code>F</code> is a filter. This is called the <em>cofinite filter</em> on <code>X</code>.</p>
<p>Note that if <code>F</code> is a filter that contains the empty set, then it contains all subsets of <code>X</code> by the first axiom. This filter is sometimes called &quot;bottom&quot; (we will see why a little later on). Some references demand that the empty set is not allowed to be in a filter -- Lean does not have this restriction. A filter not containing the empty set is sometimes called a &quot;proper filter&quot;.</p>
<p>If <code>X</code> is a topological space, and <code>x ‚àà X</code>, then the <em>neighborhood filter</em> <code>ùìù x</code> of <code>x</code> is the set of subsets <code>Y</code> of <code>X</code> such that <code>x</code> is in the interior of <code>Y</code>. One checks easily that this is a filter (technical point: to see that this is actually the definition of <code>ùìù x</code> in mathlib, it helps to know that the set of all filters on a type is a complete lattice, partially ordered using <code>F ‚â§ G</code> iff <code>G ‚äÜ F</code>, so the definition, which involves an inf, is actually a union; also, the definition I give is not literally the definition in mathlib, but <code>lemma mem_nhds_iff</code> says that their definition is the one here. Note also that this is why the filter with the most sets is called bottom!).</p>
<p>Why are we interested in these filters? Well, given a map <code>f</code> from <code>‚Ñï</code> to a topological space <code>X</code>, one can check that the resulting sequence <code>f 0</code>, <code>f 1</code>, <code>f 2</code>... tends to <code>x ‚àà X</code> if and only if the pre-image of any element in the filter <code>ùìù x</code> is in the cofinite filter on <code>‚Ñï</code> -- this is just another way of saying that given any open set <code>U</code> containing <code>x</code>, there exists <code>N</code> such that for all <code>n ‚â• N</code>, <code>f n ‚àà U</code>. So filters provide a way of thinking about limits.</p>
<p>As an example, below are three limits formulated in Lean.
The example uses the filters <code>atTop</code> and <code>atBot</code> that represent &quot;tends to <code>‚àû</code>&quot; and &quot;tends to <code>-‚àû</code>&quot; in a type equipped with an order.</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="kn">open</span><span class="w"> </span><span class="n">Filter</span><span class="w"> </span><span class="n">Topology</span>

<span class="c1">-- The limit of `2 * x` as `x` tends to `3` is `6`</span>
<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Tendsto</span><span class="w"> </span><span class="o">(</span><span class="k">fun</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">‚Ñù</span><span class="w"> </span><span class="bp">‚Ü¶</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">x</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">ùìù</span><span class="w"> </span><span class="mi">3</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">ùìù</span><span class="w"> </span><span class="mi">6</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="gr">sorry</span>
<span class="c1">-- The limit of `1 / x` as `x` tends to `‚àû` is `0`</span>
<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Tendsto</span><span class="w"> </span><span class="o">(</span><span class="k">fun</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">‚Ñù</span><span class="w"> </span><span class="bp">‚Ü¶</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="bp">/</span><span class="w"> </span><span class="n">x</span><span class="o">)</span><span class="w"> </span><span class="n">atTop</span><span class="w"> </span><span class="o">(</span><span class="n">ùìù</span><span class="w"> </span><span class="mi">0</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="gr">sorry</span>
<span class="c1">-- The limit of `x ^ 2` as `x` tends to `-‚àû` is `‚àû`</span>
<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Tendsto</span><span class="w"> </span><span class="o">(</span><span class="k">fun</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">‚Ñù</span><span class="w"> </span><span class="bp">‚Ü¶</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">^</span><span class="w"> </span><span class="mi">2</span><span class="o">)</span><span class="w"> </span><span class="n">atBot</span><span class="w"> </span><span class="n">atTop</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="gr">sorry</span>
</code></pre></div>
</div>

<p>The <em>principal filter</em> <code>Filter.principal Y</code> attached to a subset <code>Y</code> of a set <code>X</code> is the collection of all subsets of <code>X</code> that contain <code>Y</code>. So it's not difficult to convince yourself that the following results should be true:</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="kd">variable</span><span class="w"> </span><span class="o">(</span><span class="n">X</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="o">)</span><span class="w"> </span><span class="o">[</span><span class="n">TopologicalSpace</span><span class="w"> </span><span class="n">X</span><span class="o">]</span><span class="w"> </span><span class="o">(</span><span class="n">Y</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Set</span><span class="w"> </span><span class="n">X</span><span class="o">)</span>

<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">interior</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="o">{</span><span class="n">x</span><span class="w"> </span><span class="bp">|</span><span class="w"> </span><span class="n">ùìù</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">‚â§</span><span class="w"> </span><span class="n">Filter.principal</span><span class="w"> </span><span class="n">Y</span><span class="o">}</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">interior_eq_nhds</span>

<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">IsOpen</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="bp">‚Üî</span><span class="w"> </span><span class="bp">‚àÄ</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="bp">‚àà</span><span class="w"> </span><span class="n">Y</span><span class="o">,</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="bp">‚àà</span><span class="w"> </span><span class="o">(</span><span class="n">ùìù</span><span class="w"> </span><span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">sets</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">isOpen_iff_eventually</span>
</code></pre></div>
</div>

<h3 id="compactness-with-filters" class="markdown-heading">Compactness with filters <a class="hover-link" href="#compactness-with-filters">#</a></h3>
<p>As a consequence of the filter-centric approach, some definitions in mathlib
look rather strange to a mathematician who is not used to this approach.
We have already seen a definition using filters
for what it means for a sequence to tend to a limit. The definition
of compactness is also written in filter-theoretic terms:</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="sd">/-- A set `s` is compact if for every nontrivial filter `f` that contains `s`,</span>
<span class="sd">    there exists `a ‚àà s` such that every set of `f` meets every neighborhood of `a`. -/</span>
<span class="kd">def</span><span class="w"> </span><span class="n">IsCompact</span><span class="w"> </span><span class="o">(</span><span class="n">s</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Set</span><span class="w"> </span><span class="n">X</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span>
<span class="w">  </span><span class="bp">‚àÄ</span><span class="w"> </span><span class="o">‚¶É</span><span class="n">f</span><span class="o">‚¶Ñ</span><span class="w"> </span><span class="o">[</span><span class="n">NeBot</span><span class="w"> </span><span class="n">f</span><span class="o">],</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="bp">‚â§</span><span class="w"> </span><span class="n">ùìü</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="bp">‚Üí</span><span class="w"> </span><span class="bp">‚àÉ</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">‚àà</span><span class="w"> </span><span class="n">s</span><span class="o">,</span><span class="w"> </span><span class="n">ClusterPt</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">f</span>
</code></pre></div>
</div>

<p>Translated, this says that a subset <code>Y</code> of a topological space <code>X</code> is compact if for every proper filter <code>F</code> on <code>X</code>, if <code>Y</code> is an element of <code>F</code> then there's an element <code>y</code> of <code>Y</code> such that the smallest filter containing both F and the neighborhood filter of <code>y</code> is not the filter of all subsets of <code>X</code> either. This should be thought of as being the correct general analogue of the Bolzano-Weierstrass theorem, that in a compact subspace of <code>‚Ñù^n</code>, any sequence has a convergent subsequence.</p>
<p>One might ask why this definition of compactness has been chosen, rather than the standard one about open covers having finite subcovers. The reasons for this are in some sense computer-scientific rather than mathematical -- the issue should not be what definition is ultimately chosen (indeed the developers should feel free to choose whatever definition they like as long as it is logically equivalent to the usual one, and they might have reasons related to non-mathematical points such as running times), the issue should be how to prove that the inbuilt definition is equivalent to the one you want to use in practice. And fortunately, we have</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">IsCompact</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="bp">‚Üî</span><span class="w"> </span><span class="bp">‚àÄ</span><span class="w"> </span><span class="o">{</span><span class="n">Œπ</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="n">U</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Œπ</span><span class="w"> </span><span class="bp">‚Üí</span><span class="w"> </span><span class="n">Set</span><span class="w"> </span><span class="n">X</span><span class="o">),</span>
<span class="w">      </span><span class="o">(</span><span class="bp">‚àÄ</span><span class="w"> </span><span class="n">i</span><span class="o">,</span><span class="w"> </span><span class="n">IsOpen</span><span class="w"> </span><span class="o">(</span><span class="n">U</span><span class="w"> </span><span class="n">i</span><span class="o">))</span><span class="w"> </span><span class="bp">‚Üí</span><span class="w"> </span><span class="o">(</span><span class="n">Y</span><span class="w"> </span><span class="bp">‚äÜ</span><span class="w"> </span><span class="bp">‚ãÉ</span><span class="w"> </span><span class="n">i</span><span class="o">,</span><span class="w"> </span><span class="n">U</span><span class="w"> </span><span class="n">i</span><span class="o">)</span><span class="w"> </span><span class="bp">‚Üí</span><span class="w"> </span><span class="bp">‚àÉ</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Finset</span><span class="w"> </span><span class="n">Œπ</span><span class="o">,</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="bp">‚äÜ</span><span class="w"> </span><span class="bp">‚ãÉ</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="bp">‚àà</span><span class="w"> </span><span class="n">t</span><span class="o">,</span><span class="w"> </span><span class="n">U</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">:=</span>
<span class="w">    </span><span class="n">isCompact_iff_finite_subcover</span>
</code></pre></div>
</div>

<p>so the Lean definition is equivalent to the standard one.</p>
<h3 id="hausdorff-spaces" class="markdown-heading">Hausdorff spaces <a class="hover-link" href="#hausdorff-spaces">#</a></h3>
<p>In Lean they chose the terminology <code>T2Space</code> to mean Hausdorff (perhaps because it is shorter!).</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="kd">class</span><span class="w"> </span><span class="n">T2Space</span><span class="w"> </span><span class="o">(</span><span class="n">X</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">u</span><span class="o">)</span><span class="w"> </span><span class="o">[</span><span class="n">TopologicalSpace</span><span class="w"> </span><span class="n">X</span><span class="o">]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="w"> </span><span class="n">where</span>
<span class="w">  </span><span class="sd">/-- Every two points in a Hausdorff space admit disjoint open neighbourhoods. -/</span>
<span class="w">  </span><span class="n">t2</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Pairwise</span><span class="w"> </span><span class="k">fun</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="bp">=&gt;</span><span class="w"> </span><span class="bp">‚àÉ</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Set</span><span class="w"> </span><span class="n">X</span><span class="o">,</span><span class="w"> </span><span class="n">IsOpen</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="bp">‚àß</span><span class="w"> </span><span class="n">IsOpen</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="bp">‚àß</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">‚àà</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="bp">‚àß</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="bp">‚àà</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="bp">‚àß</span><span class="w"> </span><span class="n">Disjoint</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="n">v</span>
</code></pre></div>
</div>

<p>Of course Hausdorffness is what we need to ensure that limits are unique, but because limits are defined using filters this statements ends up reading as follows:</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="kd">lemma</span><span class="w"> </span><span class="n">tendsto_nhds_unique</span><span class="w"> </span><span class="o">[</span><span class="n">T2Space</span><span class="w"> </span><span class="n">X</span><span class="o">]</span><span class="w"> </span><span class="o">{</span><span class="n">f</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Œ≤</span><span class="w"> </span><span class="bp">‚Üí</span><span class="w"> </span><span class="n">X</span><span class="o">}</span><span class="w"> </span><span class="o">{</span><span class="n">l</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Filter</span><span class="w"> </span><span class="n">Œ≤</span><span class="o">}</span><span class="w"> </span><span class="o">{</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">X</span><span class="o">}</span>
<span class="w">  </span><span class="o">[</span><span class="n">l.NeBot</span><span class="o">]</span><span class="w"> </span><span class="o">(</span><span class="n">hx</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Tendsto</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">(</span><span class="n">ùìù</span><span class="w"> </span><span class="n">x</span><span class="o">))</span><span class="w"> </span><span class="o">(</span><span class="n">hb</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Tendsto</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">(</span><span class="n">ùìù</span><span class="w"> </span><span class="n">y</span><span class="o">))</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">y</span>
</code></pre></div>
</div>

<p>Note that actually this statement is more general than the classical statement that if a sequence tends to two limits in a Hausdorff space then the limits are the same, because it applies to any non-trivial filter on any set rather than just the cofinite filter on the natural numbers.</p>
<h3 id="bases-for-topologies" class="markdown-heading">Bases for topologies. <a class="hover-link" href="#bases-for-topologies">#</a></h3>
<p>If <code>X</code> is a <em>set</em>, and <code>S</code> is a collection of subsets of <code>X</code>, then one can
consider the topology &quot;generated by&quot; <code>S</code>, which (as is typical in these
situations) can be defined in two ways: firstly as the intersection
of all the topologies on <code>X</code> containing <code>S</code> (where we are here identifying
a topology with the underlying collection of open sets), or more constructively
as the sets &quot;generated by&quot; <code>S</code> using the axioms of a topological space.
Unsurprisingly, it is this latter definition which is used in Lean, as the
open sets are naturally an inductive type; the open sets are called
<code>generate_open S</code> and the topology is <code>generate_from S</code>.</p>
<p>The definition of a basis for a topology in mathlib includes an axiom
that the topology is generated from the basis in the sense above, which may make
it hard to prove for an end user that a given set satisfies the definition
directly. However again we have a theorem which reduces us to checking
the two usual axioms for a basis:</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">B</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Set</span><span class="w"> </span><span class="o">(</span><span class="n">Set</span><span class="w"> </span><span class="n">X</span><span class="o">))</span><span class="w"> </span><span class="o">(</span><span class="n">h_open</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">‚àÄ</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="bp">‚àà</span><span class="w"> </span><span class="n">B</span><span class="o">,</span><span class="w"> </span><span class="n">IsOpen</span><span class="w"> </span><span class="n">V</span><span class="o">)</span>
<span class="w">  </span><span class="o">(</span><span class="n">h_nhds</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">‚àÄ</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">X</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">U</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Set</span><span class="w"> </span><span class="n">X</span><span class="o">),</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">‚àà</span><span class="w"> </span><span class="n">U</span><span class="w"> </span><span class="bp">‚Üí</span><span class="w"> </span><span class="n">IsOpen</span><span class="w"> </span><span class="n">U</span><span class="w"> </span><span class="bp">‚Üí</span><span class="w"> </span><span class="bp">‚àÉ</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="bp">‚àà</span><span class="w"> </span><span class="n">B</span><span class="o">,</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">‚àà</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="bp">‚àß</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="bp">‚äÜ</span><span class="w"> </span><span class="n">U</span><span class="o">)</span><span class="w"> </span><span class="o">:</span>
<span class="n">IsTopologicalBasis</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">:=</span>
<span class="n">isTopologicalBasis_of_isOpen_of_nhds</span><span class="w"> </span><span class="n">h_open</span><span class="w"> </span><span class="n">h_nhds</span>
</code></pre></div>
</div>

<h3 id="other-things" class="markdown-heading">Other things <a class="hover-link" href="#other-things">#</a></h3>
<p>There are other things involving filters, there are separable, first-countable
and second-countable spaces, product spaces, subspace and quotient
topologies (and more generally pull-back and push-forward of a topology)
and things like t1 and t3 spaces.</p>
<h2 id="file-organization" class="markdown-heading">File organization <a class="hover-link" href="#file-organization">#</a></h2>
<p>The following &quot;core&quot; modules form a linear chain of imports. A theorem involving concepts defined in several of these files should be found in the last such file in this ordering.</p>
<ul>
<li><code>Mathlib.Topology.Basic</code>
Topological spaces. Open and closed subsets, interior, closure and frontier (boundary). Neighborhood filters. Limit of a filter. Locally finite families. Continuity and continuity at a point.</li>
<li><code>Mathlib.Topology.Order.Basic</code>
The complete lattice structure on topologies on a fixed set. Induced and coinduced topologies.</li>
<li><code>maps</code>
Open and closed maps. &quot;Inducing&quot; maps. Embeddings, open embeddings and closed embeddings. Quotient maps.</li>
<li><code>Mathlib.Topology.Constructions</code>
Building new topological spaces from old ones: products, sums, subspaces and quotients.</li>
<li><code>Mathlib.Topology.Separation</code>
Separation axioms T‚ÇÄ through T‚ÇÑ, also known as Kolmogorov, Tychonoff or Fr√©chet, Hausdorff, regular, and normal spaces respectively.</li>
</ul>
<p>Some of the remaining directories and files, in no particular order:</p>
<ul>
<li><code>Mathlib.Topology.Algebra</code>
Topological spaces with compatible algebraic or ordered structure.</li>
<li><code>Mathlib.Topology.Category</code>
The categories of topological spaces, uniform spaces, etc.</li>
<li><code>Mathlib.Topology.Instances</code>
Specific topological spaces such as the real numbers and the complex numbers.</li>
<li><code>Mathlib.Topology.MetricSpace</code>
The theory of metric spaces; but some notions one might expect to find here are instead generalized to uniform spaces.</li>
<li><code>Mathlib.Topology.Sheaves</code>
Presheaves on a topological space.</li>
<li><code>Mathlib.Topology.UniformSpace</code>
The theory of uniform spaces, including notions such as completeness, uniform continuity and totally bounded sets.</li>
<li><code>Mathlib.Topology.Bases</code>
Bases for filters and topological spaces. Separable, first countable and second countable spaces.</li>
<li><code>Mathlib.Topology.CompactOpen</code>
The compact-open topology on the space of continuous maps between two topological spaces.</li>
<li><code>Mathlib.Topology.ContinuousOn</code>
Neighborhoods within a subset. Continuity on a subset, and continuity within a subset at a point.</li>
<li><code>Mathlib.Topology.DenseEmbedding</code>
Embeddings and other functions with dense image.</li>
<li><code>Mathlib.Topology.Homeomorph</code>
Homeomorphisms between topological spaces.</li>
<li><code>Mathlib.Topology.List</code>
Topologies on lists and vectors.</li>
<li><code>Mathlib.Topology.Sequences</code>
Sequential closure and sequential spaces. Sequentially continuous functions.</li>
<li><code>Mathlib.Topology.StoneCech</code>
The Stone-ƒåech compactification of a topological space.</li>
</ul>

  </main>

    <nav id="navbar" class="d-md-block bg-light sidebar collapse navbar-light pb-4">
      <div class="d-none d-md-block mt-4"><a class="navbar-brand" href="https://leanprover-community.github.io/index.html">Lean Community</a></div>
      
        <h6 class="sidebar-heading mt-4">Community</h6>
        <ul class="nav">
          <li class="nav-item col-12"><a href="https://leanprover.zulipchat.com/">Zulip chat</a></li>
        
          <li class="nav-item col-12"><a href="https://github.com/leanprover-community/mathlib4">GitHub</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/blog">Blog</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/meet.html">Community information</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/meet.html#community-guidelines">Community guidelines</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/teams.html">Teams</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/papers.html">Papers about Lean</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/lean_projects.html">Projects using Lean</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/teaching/index.html">Teaching using Lean</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/events.html">Events</a></li>
        </ul>
      
        <h6 class="sidebar-heading mt-4">Installation</h6>
        <ul class="nav">
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/get_started.html">Get started</a></li>
        
          <li class="nav-item col-12"><a href="https://live.lean-lang.org/">Online version (no installation)</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/install/project.html">Using Lake (build system)</a></li>
        </ul>
      
        <h6 class="sidebar-heading mt-4">Documentation</h6>
        <ul class="nav">
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/learn.html">Learning resources (start here)</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/mathlib4_docs">API documentation</a></li>
        
          <li class="nav-item col-12"><a href="https://loogle.lean-lang.org/">Declaration search (Loogle)</a></li>
        
          <li class="nav-item col-12"><a href="https://lean-lang.org/doc/reference/latest/">Language reference</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/mathlib-manual/html-multi/">Tactic list</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/extras/calc.html">Calc mode</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/extras/conv.html">Conv mode</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/extras/simp.html">Simplifier</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/extras/well_founded_recursion.html">Well-founded recursion</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/extras/speedup.html">Speeding up Lean files</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/mwe.html">About MWEs</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/glossary.html">Glossary</a></li>
        </ul>
      
        <h6 class="sidebar-heading mt-4">Library overviews</h6>
        <ul class="nav">
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/mathlib-overview.html">Library overview</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/undergrad.html">Undergraduate maths</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/100.html">Wiedijk's 100 theorems</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/1000.html">1000+ theorems</a></li>
        </ul>
      
        <h6 class="sidebar-heading mt-4">Theories</h6>
        <ul class="nav">
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/theories/naturals.html">Natural Numbers</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/theories/linear_algebra.html">Linear Algebra</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/theories/sets.html">Sets and finite sets</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/theories/topology.html">Topology</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/theories/category_theory.html">Category Theory</a></li>
        </ul>
      
        <h6 class="sidebar-heading mt-4">Contributing</h6>
        <ul class="nav">
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/contribute/index.html">Pull request lifecycle</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/contribute/naming.html">Naming conventions</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/contribute/style.html">Code style guideline</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/contribute/doc.html">Documentation style</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/contribute/commit.html">Commit conventions</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/contribute/pr-review.html">Pull request review guide</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/mathlib_stats.html">Contribution statistics</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/contribute/tags_and_branches.html">Tags and branches</a></li>
        </ul>
      
    </nav>

</div>


  <nav class="footer navbar navbar-expand-lg navbar-light bg-light justify-content-end">
  <ul class="nav">
    <li class="nav-item">
      <a class="nav-link active" href="https://github.com/leanprover-community/leanprover-community.github.io/blob/lean4/templates/theories/topology.md">Suggest edits to this page on GitHub</a>
    </li>
  </ul>
  </nav>

    <script src="https://code.jquery.com/jquery-3.5.1.min.js"
      integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0="
      crossorigin="anonymous"></script>
    <script src="https://leanprover-community.github.io//js/bootstrap.min.js"></script>
    <script type="module">
      import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
      mermaid.initialize({ startOnLoad: true });
    </script>
    
  </body>
</html>