<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Lean community blog (Posts by Patrick Massot)</title><link>https://leanprover-community.github.io/blog/</link><description></description><atom:link href="https://leanprover-community.github.io/blog/authors/patrick-massot.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2021 &lt;a href="mailto:"&gt;The Lean prover community&lt;/a&gt; </copyright><lastBuildDate>Mon, 23 Aug 2021 04:12:33 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Continuous partitions of unity</title><link>https://leanprover-community.github.io/blog/posts/continuous-partitions-of-unity/</link><dc:creator>Patrick Massot</dc:creator><description>&lt;div&gt;&lt;p&gt;In &lt;a href="https://github.com/leanprover-community/mathlib/pull/8281"&gt;PR #8281&lt;/a&gt;, Yury
Kudryashov completed his work on continuous and smooth partitions of unity.&lt;/p&gt;
&lt;p&gt;A continuous partition of unity on a topological space $X$ is a collection of continuous functions
$f_i : X → ℝ$ such that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the supports of $f_i$ form a locally finite family of sets, i.e., for every point $x$ in $X$, there
  exists a neighborhood $U$ of $x$ such that all but finitely many functions $f_i$ are zero on $U$;&lt;/li&gt;
&lt;li&gt;the functions $f_i$ are nonnegative;&lt;/li&gt;
&lt;li&gt;the sum $\sum_i f_i(x)$ is equal to one for all $x$.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;While the above definition is completely standard, it is often useful to have a collection of
functions that act as a paritition of unity only on some part $s$ of $X$. In that more general case,
we keep the above two conditions everywhere but ask that the sum in the last item equals one on $s$
and is less than or equal to one everywhere. This is encoded in the following Lean structure, from
&lt;code&gt;topology.partition_of_unity&lt;/code&gt;.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="kd"&gt;structure&lt;/span&gt; &lt;span class="n"&gt;partition_of_unity&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ι&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Type&lt;/span&gt;&lt;span class="bp"&gt;*&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;topological_space&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="n"&gt;univ&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to_fun&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;ι&lt;/span&gt; &lt;span class="bp"&gt;→&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ℝ&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;locally_finite'&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;locally_finite&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;λ&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;support&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to_fun&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;)))&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nonneg'&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="bp"&gt;≤&lt;/span&gt; &lt;span class="n"&gt;to_fun&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sum_eq_one'&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="bp"&gt;∀&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="bp"&gt;∈&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;∑ᶠ&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;to_fun&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="bp"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sum_le_one'&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="bp"&gt;∀&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;∑ᶠ&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;to_fun&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="bp"&gt;≤&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;The main result from that file is then the following existence theorem.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="sd"&gt;/-- If `X` is a paracompact normal topological space and `U` is an open covering of a closed set&lt;/span&gt;
&lt;span class="sd"&gt;`s`, then there exists a `partition_of_unity ι X s` that is subordinate to `U`. -/&lt;/span&gt;
&lt;span class="kd"&gt;lemma&lt;/span&gt; &lt;span class="n"&gt;exists_is_subordinate&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;normal_space&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;paracompact_space&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hs&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;is_closed&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;U&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;ι&lt;/span&gt; &lt;span class="bp"&gt;→&lt;/span&gt; &lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ho&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="bp"&gt;∀&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;is_open&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;U&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hU&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="bp"&gt;⊆&lt;/span&gt; &lt;span class="bp"&gt;⋃&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;U&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;
  &lt;span class="bp"&gt;∃&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;partition_of_unity&lt;/span&gt; &lt;span class="n"&gt;ι&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;f.is_subordinate&lt;/span&gt; &lt;span class="n"&gt;U&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</description><guid>https://leanprover-community.github.io/blog/posts/continuous-partitions-of-unity/</guid><pubDate>Sat, 07 Aug 2021 19:49:56 GMT</pubDate></item><item><title>Eric Wieser's scalar action paper</title><link>https://leanprover-community.github.io/blog/posts/eric-wiesers-scalar-action-paper/</link><dc:creator>Patrick Massot</dc:creator><description>&lt;div&gt;&lt;p&gt;Eric Wieser wrote a &lt;a href="https://easychair.org/publications/preprint/mC9X"&gt;paper about scalar actions in mathlib&lt;/a&gt; for the 
&lt;a href="https://cicm-conference.org/2021/"&gt;CICM 2021&lt;/a&gt; conference on intelligent computer
mathematics. &lt;/p&gt;
&lt;p&gt;Scalar actions are everywhere in mathematics. There are so many of
them that a given type can easily get several ones from different origins. For instance
$ℤ$ acts on itself by left multiplication but it also has the $ℤ$ scalar action
that every additive group has, by repeated addition or subtraction.
In general those multiple actions can be proven to be equal, but type class
inference needs definitional equality. So a great deal of care has been taken,
by Eric and others, when setting up the algebraic hierarchy in mathlib. &lt;/p&gt;
&lt;p&gt;The paper tells this fascinating story and is recommended for anyone interested
in multiple inheritance handling in Lean 3 type class system.&lt;/p&gt;&lt;/div&gt;</description><guid>https://leanprover-community.github.io/blog/posts/eric-wiesers-scalar-action-paper/</guid><pubDate>Sat, 07 Aug 2021 19:42:32 GMT</pubDate></item></channel></rss>