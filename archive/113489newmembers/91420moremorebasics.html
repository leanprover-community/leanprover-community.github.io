---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113489newmembers/91420moremorebasics.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html">more more basics</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="190786613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190786613" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190786613">Iocta (Mar 16 2020 at 22:13)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">natural</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">natural</span>
<span class="bp">|</span> <span class="n">succ</span> <span class="o">:</span> <span class="n">natural</span> <span class="bp">→</span> <span class="n">natural</span>


<span class="kn">open</span> <span class="n">natural</span>


<span class="n">def</span> <span class="n">pred</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">natural</span><span class="o">)</span> <span class="o">:</span> <span class="n">natural</span> <span class="o">:=</span>
<span class="n">natural</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">n</span> <span class="n">zero</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="n">pred_n</span><span class="o">,</span> <span class="n">n</span><span class="o">)</span>


<span class="n">def</span> <span class="n">plus</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">natural</span><span class="o">)</span> <span class="o">:</span> <span class="n">natural</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="n">zero</span> <span class="o">:=</span> <span class="n">m</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">n</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">plus</span> <span class="o">(</span><span class="n">pred</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span>
</pre></div>


<div class="codehilite"><pre><span></span> <span class="mi">08</span><span class="bp">.</span><span class="mi">02</span><span class="bp">.</span><span class="n">le</span><span class="err">…</span>    <span class="mi">15</span>   <span class="mi">3</span> <span class="n">error</span>           <span class="n">function</span> <span class="n">expected</span> <span class="n">at</span>
   <span class="n">plus</span>
 <span class="n">term</span> <span class="n">has</span> <span class="n">type</span>
   <span class="n">natural</span> <span class="o">(</span><span class="n">lean</span><span class="bp">-</span><span class="n">checker</span><span class="o">)</span>
 <span class="mi">08</span><span class="bp">.</span><span class="mi">02</span><span class="bp">.</span><span class="n">le</span><span class="err">…</span>    <span class="mi">15</span>  <span class="mi">10</span> <span class="n">error</span>           <span class="n">ill</span><span class="bp">-</span><span class="n">formed</span> <span class="k">match</span><span class="bp">/</span><span class="n">equation</span> <span class="n">expression</span> <span class="o">(</span><span class="n">lean</span><span class="bp">-</span><span class="n">checker</span><span class="o">)</span>
 <span class="mi">08</span><span class="bp">.</span><span class="mi">02</span><span class="bp">.</span><span class="n">le</span><span class="err">…</span>    <span class="mi">16</span>   <span class="mi">3</span> <span class="n">error</span>           <span class="n">function</span> <span class="n">expected</span> <span class="n">at</span>
   <span class="n">plus</span>
 <span class="n">term</span> <span class="n">has</span> <span class="n">type</span>
   <span class="n">natural</span> <span class="o">(</span><span class="n">lean</span><span class="bp">-</span><span class="n">checker</span><span class="o">)</span>
 <span class="mi">08</span><span class="bp">.</span><span class="mi">02</span><span class="bp">.</span><span class="n">le</span><span class="err">…</span>    <span class="mi">17</span>   <span class="mi">3</span> <span class="n">error</span>           <span class="n">function</span> <span class="n">expected</span> <span class="n">at</span>
   <span class="n">plus</span>
 <span class="n">term</span> <span class="n">has</span> <span class="n">type</span>
   <span class="n">natural</span> <span class="o">(</span><span class="n">lean</span><span class="bp">-</span><span class="n">checker</span><span class="o">)</span>
 <span class="mi">08</span><span class="bp">.</span><span class="mi">02</span><span class="bp">.</span><span class="n">le</span><span class="err">…</span>    <span class="mi">17</span>  <span class="mi">10</span> <span class="n">error</span>           <span class="n">function</span> <span class="n">expected</span> <span class="n">at</span>
   <span class="n">plus</span>
 <span class="n">term</span> <span class="n">has</span> <span class="n">type</span>
   <span class="n">natural</span> <span class="o">(</span><span class="n">lean</span><span class="bp">-</span><span class="n">checker</span><span class="o">)</span>
</pre></div>

<a name="190786656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190786656" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190786656">Iocta (Mar 16 2020 at 22:13)</a>:</h4>
<p>What's wrong?</p>

<a name="190786989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190786989" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190786989">Iocta (Mar 16 2020 at 22:17)</a>:</h4>
<p>looks like it wants a function in those <code>_</code>s, but why/which function?</p>

<a name="190787177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190787177" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190787177">Reid Barton (Mar 16 2020 at 22:19)</a>:</h4>
<p>Stuff to the left of the colon like <code>(m n : natural)</code> doesn't participate in the pattern match. You need to write <code>def plus : natural -&gt; natural -&gt; natural | ...</code></p>

<a name="190787231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190787231" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190787231">Reid Barton (Mar 16 2020 at 22:19)</a>:</h4>
<p>That stuff is also fixed/implicitly passed to the recursive call, which is why Lean is saying that <code>plus</code> is not a function</p>

<a name="190787301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190787301" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190787301">Reid Barton (Mar 16 2020 at 22:20)</a>:</h4>
<p>Moving the arguments to the right of the colon will fix that as well.</p>

<a name="190787460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190787460" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190787460">Iocta (Mar 16 2020 at 22:22)</a>:</h4>
<p>ok that's progress</p>

<a name="190787783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190787783" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190787783">Iocta (Mar 16 2020 at 22:26)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">plus</span> <span class="o">:</span> <span class="n">natural</span> <span class="bp">→</span> <span class="n">natural</span> <span class="bp">→</span> <span class="n">natural</span>
<span class="bp">|</span> <span class="n">a</span> <span class="n">zero</span> <span class="o">:=</span> <span class="n">a</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">b</span>
<span class="bp">|</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">plus</span> <span class="o">(</span><span class="n">pred</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">succ</span> <span class="n">b</span><span class="o">)</span>
</pre></div>


<p>now it wants <code>⊢ natural.sizeof (pred a) &lt; natural.sizeof a</code> which I guess makes sense</p>

<a name="190787819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190787819" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190787819">Mario Carneiro (Mar 16 2020 at 22:26)</a>:</h4>
<p>Don't use <code>pred a</code> like that</p>

<a name="190787829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190787829" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190787829">Mario Carneiro (Mar 16 2020 at 22:26)</a>:</h4>
<p>have a case for <code>succ a</code> and use <code>a</code></p>

<a name="190787879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190787879" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190787879">Reid Barton (Mar 16 2020 at 22:27)</a>:</h4>
<p>(<code>pred a</code> is not smaller than <code>a</code> when <code>a = 0</code>, and Lean doesn't "know" that <code>a</code> is not equal to <code>0</code> in the last case. Plus this definition would be awkward to prove things about anyways.)</p>

<a name="190787881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190787881" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190787881">Mario Carneiro (Mar 16 2020 at 22:27)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">plus</span> <span class="o">:</span> <span class="n">natural</span> <span class="bp">→</span> <span class="n">natural</span> <span class="bp">→</span> <span class="n">natural</span>
<span class="bp">|</span> <span class="n">a</span> <span class="n">zero</span> <span class="o">:=</span> <span class="n">a</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">b</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">a</span><span class="o">)</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">plus</span> <span class="n">a</span> <span class="o">(</span><span class="n">succ</span> <span class="n">b</span><span class="o">)</span>
</pre></div>

<a name="190787903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190787903" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190787903">Iocta (Mar 16 2020 at 22:27)</a>:</h4>
<p>yeah that works</p>

<a name="190787969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190787969" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190787969">Mario Carneiro (Mar 16 2020 at 22:28)</a>:</h4>
<p>(the first case is unnecessary)</p>

<a name="190788002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190788002" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190788002">Iocta (Mar 16 2020 at 22:28)</a>:</h4>
<p>mhmm</p>

<a name="190788387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190788387" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190788387">Iocta (Mar 16 2020 at 22:33)</a>:</h4>
<p>What's happening with the scope in <code> | here :=</code>? looks like it's referencing <code>zero</code> and <code>succ</code> but also defining <code>a</code> and <code>b</code>.</p>

<a name="190788467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190788467" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190788467">Iocta (Mar 16 2020 at 22:34)</a>:</h4>
<p>iow, how does it know whether to bind a name or reference a name?</p>

<a name="190788725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190788725" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190788725">Iocta (Mar 16 2020 at 22:37)</a>:</h4>
<p>perhaps it's just "define a name unless it's already defined, then use it"?</p>

<a name="190788750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190788750" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190788750">Mario Carneiro (Mar 16 2020 at 22:37)</a>:</h4>
<p>it's a pattern</p>

<a name="190788762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190788762" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190788762">Mario Carneiro (Mar 16 2020 at 22:37)</a>:</h4>
<p>you can use the names of constructors, but everything else becomes a new bound variable</p>

<a name="190788844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190788844" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190788844">Mario Carneiro (Mar 16 2020 at 22:38)</a>:</h4>
<p>it helps here if you have ever used a functional programming language with pattern matching capabilities</p>

<a name="190788990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190788990" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190788990">Iocta (Mar 16 2020 at 22:40)</a>:</h4>
<p>I see, <code>| a succ := succ</code> doesn't rebind <code>succ</code> because <code>succ</code> is a constructor</p>

<a name="190789031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190789031" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190789031">Iocta (Mar 16 2020 at 22:41)</a>:</h4>
<p>but given <code>def foo := 5</code> I can rebind "foo" with <code>| a foo := foo</code></p>

<a name="190789060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190789060" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190789060">Iocta (Mar 16 2020 at 22:41)</a>:</h4>
<p>because <code>foo</code> isn't a constructor of <code>natural</code></p>

<a name="190789122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190789122" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190789122">Iocta (Mar 16 2020 at 22:42)</a>:</h4>
<p>right?</p>

<a name="190789196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190789196" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190789196">Iocta (Mar 16 2020 at 22:43)</a>:</h4>
<p>I mean like </p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">foo</span> <span class="o">:=</span> <span class="mi">5</span>

<span class="n">def</span> <span class="n">plus</span> <span class="o">:</span> <span class="n">natural</span> <span class="bp">→</span> <span class="n">natural</span> <span class="bp">→</span> <span class="n">natural</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="n">foo</span> <span class="o">:=</span> <span class="n">foo</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">a</span><span class="o">)</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">plus</span> <span class="n">a</span> <span class="o">(</span><span class="n">succ</span> <span class="n">b</span><span class="o">)</span>
</pre></div>

<a name="190789249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190789249" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190789249">Iocta (Mar 16 2020 at 22:43)</a>:</h4>
<p>ok this makes sense</p>

<a name="190789637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190789637" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190789637">Reid Barton (Mar 16 2020 at 22:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="253355">Iocta</span> <a href="#narrow/stream/113489-new-members/topic/(no.20topic)/near/190788725" title="#narrow/stream/113489-new-members/topic/(no.20topic)/near/190788725">said</a>:</p>
<blockquote>
<p>perhaps it's just "define a name unless it's already defined, then use it"?</p>
</blockquote>
<p>Yes. To be fair, this is different from how it works in Haskell; I don't remember what ML-family languages do here</p>

<a name="190789742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190789742" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190789742">Mario Carneiro (Mar 16 2020 at 22:50)</a>:</h4>
<p>You actually have to be a bit careful here because if the constructor is in a namespace, then lean will interpret it as a variable instead. The following defines the constant <code>A</code> function, not the identity function:</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">foo</span>
<span class="bp">|</span> <span class="n">A</span>
<span class="bp">|</span> <span class="n">B</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">foo</span> <span class="bp">→</span> <span class="n">foo</span>
<span class="bp">|</span> <span class="n">A</span> <span class="o">:=</span> <span class="n">A</span>
<span class="bp">|</span> <span class="n">B</span> <span class="o">:=</span> <span class="n">B</span> <span class="c1">-- equation compiler error, equation #2 has not been used in the compilation, note that the left-hand-side of equation #1 is a variable</span>
</pre></div>

<a name="190789785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190789785" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190789785">Mario Carneiro (Mar 16 2020 at 22:51)</a>:</h4>
<p>the identity function is actually this:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">:</span> <span class="n">foo</span> <span class="bp">→</span> <span class="n">foo</span>
<span class="bp">|</span> <span class="n">foo</span><span class="bp">.</span><span class="n">A</span> <span class="o">:=</span> <span class="n">foo</span><span class="bp">.</span><span class="n">A</span>
<span class="bp">|</span> <span class="n">foo</span><span class="bp">.</span><span class="n">B</span> <span class="o">:=</span> <span class="n">foo</span><span class="bp">.</span><span class="n">B</span>
</pre></div>

<a name="190789813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190789813" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190789813">Reid Barton (Mar 16 2020 at 22:51)</a>:</h4>
<p>wait I'm confused, isn't your example also the identity function, but for the wrong reason?</p>

<a name="190789832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190789832" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190789832">Mario Carneiro (Mar 16 2020 at 22:51)</a>:</h4>
<p>aha, you're right</p>

<a name="190789885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190789885" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190789885">Mario Carneiro (Mar 16 2020 at 22:52)</a>:</h4>
<p>if I had <code>| A := foo.A</code> it would be the constant function but that's too obvious</p>

<a name="190789934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190789934" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190789934">Mario Carneiro (Mar 16 2020 at 22:52)</a>:</h4>
<p><code>| A := B</code> and <code>| B := A</code> would make the issue more clear since on the first line you would get "unknown identifier 'B'"</p>

<a name="190806168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190806168" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190806168">Iocta (Mar 17 2020 at 03:56)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">natural</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">natural</span>
<span class="bp">|</span> <span class="n">succ</span> <span class="o">:</span> <span class="n">natural</span> <span class="bp">→</span> <span class="n">natural</span>

<span class="kn">open</span> <span class="n">natural</span>


<span class="n">def</span> <span class="n">pred</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">natural</span><span class="o">)</span> <span class="o">:</span> <span class="n">natural</span> <span class="o">:=</span>
<span class="n">natural</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">n</span> <span class="n">zero</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="n">pred_n</span><span class="o">,</span> <span class="n">n</span><span class="o">)</span>


<span class="n">def</span> <span class="n">add</span> <span class="o">:</span> <span class="n">natural</span> <span class="bp">→</span> <span class="n">natural</span> <span class="bp">→</span> <span class="n">natural</span>
<span class="bp">|</span> <span class="n">m</span> <span class="n">zero</span> <span class="o">:=</span> <span class="n">m</span>
<span class="bp">|</span> <span class="n">m</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">add</span> <span class="n">m</span> <span class="n">n</span><span class="o">)</span>



<span class="kn">theorem</span> <span class="n">add_zero</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">m</span><span class="o">:</span> <span class="n">natural</span><span class="o">),</span> <span class="n">add</span> <span class="n">m</span> <span class="n">zero</span> <span class="bp">=</span> <span class="n">m</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">zero</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add</span><span class="o">]</span>

<span class="kn">theorem</span> <span class="n">zero_add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">m</span><span class="o">:</span> <span class="n">natural</span><span class="o">),</span> <span class="n">add</span> <span class="n">zero</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">m</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add</span><span class="o">,</span> <span class="n">zero_add</span><span class="o">]</span>

<span class="kn">theorem</span> <span class="n">succ_add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span><span class="o">:</span> <span class="n">natural</span><span class="o">),</span> <span class="n">add</span> <span class="n">m</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">add</span> <span class="n">m</span> <span class="n">n</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">m</span><span class="o">)</span> <span class="n">n</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">add</span>


<span class="kn">theorem</span> <span class="n">add_succ</span> <span class="o">:</span> <span class="k">forall</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span><span class="o">:</span> <span class="n">natural</span><span class="o">),</span> <span class="n">add</span> <span class="o">(</span><span class="n">succ</span> <span class="n">m</span><span class="o">)</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">add</span> <span class="n">m</span> <span class="n">n</span><span class="o">)</span>
<span class="o">:=</span> <span class="n">sorry</span>
</pre></div>


<p>How do I fill the <code>sorry</code>?</p>

<a name="190807960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190807960" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190807960">Mario Carneiro (Mar 17 2020 at 04:42)</a>:</h4>
<p><code>succ_add</code> should be provable by <code>rfl</code></p>

<a name="190807967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190807967" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190807967">Mario Carneiro (Mar 17 2020 at 04:43)</a>:</h4>
<p><code>add_succ</code> can be proven similar to <code>zero_add</code></p>

<a name="190807973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190807973" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190807973">Mario Carneiro (Mar 17 2020 at 04:43)</a>:</h4>
<p>(your names for <code>succ_add</code> and <code>add_succ</code> appear reversed)</p>

<a name="190809433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190809433" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190809433">Iocta (Mar 17 2020 at 05:23)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">succ_add</span> <span class="o">:</span> <span class="k">forall</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span><span class="o">:</span> <span class="n">natural</span><span class="o">),</span> <span class="n">add</span> <span class="o">(</span><span class="n">succ</span> <span class="n">m</span><span class="o">)</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">add</span> <span class="n">m</span> <span class="n">n</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">m</span> <span class="n">zero</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="n">m</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add_succ</span><span class="o">,</span> <span class="n">add</span><span class="o">,</span> <span class="n">succ_add</span><span class="o">]</span>
</pre></div>


<p>works. I didn't expect to be able to access <code>succ_add</code> in the <code>rw</code>, but apparently that's ok</p>

<a name="190811902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190811902" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190811902">Mario Carneiro (Mar 17 2020 at 06:33)</a>:</h4>
<p>it's because you are using the equation compiler to write the theorem. It's just like when you used <code>add</code> in the second clause for the definition of <code>add</code></p>

<a name="190811919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190811919" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190811919">Mario Carneiro (Mar 17 2020 at 06:33)</a>:</h4>
<p>If you attempted to use <code>succ_add</code> in the wrong way to make a circular proof, the equation compiler would complain about nontermination</p>

<a name="190812621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190812621" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190812621">Iocta (Mar 17 2020 at 06:51)</a>:</h4>
<p>ok</p>

<a name="190818404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190818404" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190818404">Kevin Buzzard (Mar 17 2020 at 08:29)</a>:</h4>
<p>The equation compiler is just a glorified <code>rec</code></p>

<a name="190911641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190911641" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190911641">Iocta (Mar 17 2020 at 21:14)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">add_comm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">natural</span><span class="o">),</span> <span class="n">add</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">add</span> <span class="n">b</span> <span class="n">a</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="n">zero</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">a</span><span class="o">)</span> <span class="n">zero</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">zero_add</span><span class="o">,</span> <span class="n">add_zero</span><span class="o">]</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">(</span><span class="n">succ</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">zero_add</span><span class="o">,</span> <span class="n">add_zero</span><span class="o">]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">succ</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add</span><span class="o">,</span> <span class="n">add</span><span class="o">,</span> <span class="n">succ_add</span><span class="o">,</span> <span class="n">succ_add</span><span class="o">,</span> <span class="n">add_comm</span><span class="o">]</span>
</pre></div>


<p>proves the same point as </p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">add_comm</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">natural</span> <span class="o">)</span> <span class="o">:</span> <span class="n">add</span> <span class="n">m</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">add</span> <span class="n">n</span> <span class="n">m</span> <span class="o">:=</span>
<span class="n">natural</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">n</span>
<span class="o">(</span><span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add_zero</span><span class="o">,</span> <span class="n">zero_add</span> <span class="o">])</span>
<span class="o">(</span><span class="k">assume</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="n">natural</span><span class="o">)</span> <span class="o">,</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">ih</span><span class="o">:</span> <span class="n">add</span> <span class="n">m</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">add</span> <span class="n">n</span> <span class="n">m</span><span class="o">,</span>
    <span class="k">show</span> <span class="n">add</span> <span class="n">m</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">add</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="n">m</span><span class="o">,</span>
    <span class="k">from</span> <span class="k">calc</span>
    <span class="n">add</span> <span class="n">m</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">add</span> <span class="n">m</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">rfl</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">add</span> <span class="n">n</span> <span class="n">m</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">ih</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">add</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="n">m</span> <span class="o">:</span> <span class="k">by</span> <span class="n">apply</span> <span class="n">succ_add</span><span class="o">))</span>
</pre></div>


<p>but in a different style. Can lean tell that these are similar, or can I convince it that they are?</p>

<a name="190911837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190911837" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190911837">Iocta (Mar 17 2020 at 21:16)</a>:</h4>
<p>given one of them, can it generate the other in case I want to see the <code>calc</code> version?</p>

<a name="190911999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190911999" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190911999">Iocta (Mar 17 2020 at 21:18)</a>:</h4>
<p>more generally, given a tactic proof can it generate a term proof?</p>

<a name="190912515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190912515" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190912515">Bryan Gin-ge Chen (Mar 17 2020 at 21:23)</a>:</h4>
<p>You can see the term that Lean generates from a tactic proof with <code>#print add_comm</code>.</p>

<a name="190913771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190913771" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190913771">Iocta (Mar 17 2020 at 21:34)</a>:</h4>
<p>Oh neat</p>

<a name="190914211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190914211" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190914211">Iocta (Mar 17 2020 at 21:38)</a>:</h4>
<p>Would it be hard to write a function that transforms that output into a <code>calc</code>-based proof?</p>

<a name="190915391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190915391" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190915391">Bryan Gin-ge Chen (Mar 17 2020 at 21:51)</a>:</h4>
<p>It's certainly too hard for me to do.</p>

<a name="190915730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190915730" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190915730">Iocta (Mar 17 2020 at 21:54)</a>:</h4>
<p>Sounds like it's pretty hard then :-)</p>

<a name="190916125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190916125" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190916125">Iocta (Mar 17 2020 at 21:57)</a>:</h4>
<p>Why does <code>inductive vector (α : Type u) : nat → Type u</code> have <code>\to Type u</code> and not <code>\to \a</code>?</p>

<a name="190916157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190916157" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190916157">Iocta (Mar 17 2020 at 21:57)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">vector</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">{}</span> <span class="o">:</span> <span class="n">vector</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">cons</span>   <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">n</span><span class="o">},</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">vector</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">vector</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>
</pre></div>

<a name="190916362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190916362" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190916362">Patrick Massot (Mar 17 2020 at 21:59)</a>:</h4>
<p>For each natural number n you want the type of vectors of objects of type alpha with length n</p>

<a name="190916374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190916374" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190916374">Patrick Massot (Mar 17 2020 at 21:59)</a>:</h4>
<p>This is indeed in Type u</p>

<a name="190916561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190916561" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190916561">Iocta (Mar 17 2020 at 22:01)</a>:</h4>
<p>ok I see</p>

<a name="190921510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190921510" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190921510">Iocta (Mar 17 2020 at 22:55)</a>:</h4>
<p>I had </p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">append</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span>
  <span class="bp">Π</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">},</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">vector</span> <span class="n">α</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="mi">0</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">nil</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="bp">_</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">m</span><span class="o">)</span> <span class="n">n</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="bp">_</span>
</pre></div>


<p>and I thought this would help</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">zero_add</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span>
 <span class="bp">Π</span> <span class="o">{</span><span class="n">n</span><span class="o">},</span> <span class="n">vector</span> <span class="n">α</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span> <span class="bp">→</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">nil</span>  <span class="o">:=</span> <span class="n">nil</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="bp">::</span><span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">h</span><span class="bp">::</span><span class="n">t</span><span class="o">)</span>
</pre></div>


<p>but I'm not sure how to eliminate the <code>0 +</code></p>
<div class="codehilite"><pre><span></span> <span class="mi">08</span><span class="bp">.</span><span class="mi">04</span><span class="bp">.</span><span class="n">le</span><span class="err">…</span>    <span class="mi">40</span>  <span class="mi">28</span> <span class="n">error</span>           <span class="n">equation</span> <span class="n">compiler</span> <span class="n">failed</span> <span class="n">to</span> <span class="n">create</span> <span class="n">auxiliary</span> <span class="n">declaration</span> <span class="err">&#39;</span><span class="n">zero_add</span><span class="bp">._</span><span class="n">main&#39;</span>
 <span class="n">nested</span> <span class="n">exception</span> <span class="n">message</span><span class="o">:</span>
 <span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
   <span class="n">a_a</span> <span class="bp">::</span> <span class="n">a_a_1</span>
 <span class="n">term</span>
   <span class="n">a_a_1</span>
 <span class="n">has</span> <span class="n">type</span>
   <span class="n">vector</span> <span class="n">α</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">add</span> <span class="mi">0</span> <span class="n">n</span><span class="o">)</span>
 <span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
   <span class="n">vector</span> <span class="n">α</span> <span class="mi">0</span> <span class="o">(</span><span class="n">lean</span><span class="bp">-</span><span class="n">checker</span><span class="o">)</span>
</pre></div>

<a name="190921887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190921887" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190921887">Kenny Lau (Mar 17 2020 at 22:58)</a>:</h4>
<p>you need to use <code>zero_add</code></p>

<a name="190921929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190921929" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190921929">Kevin Buzzard (Mar 17 2020 at 22:59)</a>:</h4>
<p>Welcome to dependent type theory.</p>

<a name="190923106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190923106" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190923106">Kevin Buzzard (Mar 17 2020 at 23:12)</a>:</h4>
<p>You can do it like this</p>
<div class="codehilite"><pre><span></span><span class="kn">universe</span> <span class="n">u</span>

<span class="kn">inductive</span> <span class="n">vector</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">{}</span> <span class="o">:</span> <span class="n">vector</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">cons</span>   <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">n</span><span class="o">},</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">vector</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">vector</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">vector</span>

<span class="n">def</span> <span class="n">zero_add</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">n</span><span class="o">},</span> <span class="n">vector</span> <span class="n">α</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span> <span class="bp">→</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">n</span> <span class="n">v</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">zero_add</span> <span class="n">at</span> <span class="n">v</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">v</span>

<span class="kn">end</span> <span class="n">vector</span>
</pre></div>


<p>but this is a complete disaster because I used tactics to define data, so <code>zero_add</code> will be hard to use in practice. The computer scientists know tricks around this. <a href="#narrow/stream/116395-maths/topic/CDGAs/near/167848869" title="#narrow/stream/116395-maths/topic/CDGAs/near/167848869">here</a> is a situation where this issue is really quite embedded and you have to dig hard to get out.</p>

<a name="190923575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190923575" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190923575">Kenny Lau (Mar 17 2020 at 23:18)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">universe</span> <span class="n">u</span>

<span class="kn">inductive</span> <span class="n">vector</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">{}</span> <span class="o">:</span> <span class="n">vector</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">cons</span>   <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">n</span><span class="o">},</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">vector</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">vector</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span>

<span class="n">def</span> <span class="n">vector</span><span class="bp">.</span><span class="n">zero_add</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span>
 <span class="bp">Π</span> <span class="o">{</span><span class="n">n</span><span class="o">},</span> <span class="n">vector</span> <span class="n">α</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span> <span class="bp">→</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">vector</span><span class="bp">.</span><span class="n">nil</span>  <span class="o">:=</span> <span class="n">vector</span><span class="bp">.</span><span class="n">nil</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">vector</span><span class="bp">.</span><span class="n">cons</span> <span class="n">h</span> <span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">vector</span><span class="bp">.</span><span class="n">cons</span> <span class="n">h</span> <span class="o">(</span><span class="n">vector</span><span class="bp">.</span><span class="n">zero_add</span> <span class="n">t</span><span class="o">)</span>
</pre></div>

<a name="190923580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190923580" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190923580">Kenny Lau (Mar 17 2020 at 23:18)</a>:</h4>
<p>this is what I meant</p>

<a name="190923730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190923730" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190923730">Kevin Buzzard (Mar 17 2020 at 23:20)</a>:</h4>
<p>This is some sort of a dark art, which fortunately doesn't seem to come up in the kind of mathematics I tend to formalise (which is one of the reasons I'm not very good at it)</p>

<a name="190923794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190923794" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190923794">Iocta (Mar 17 2020 at 23:21)</a>:</h4>
<p>hmm I'd actually tried </p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">zero_add</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span>
 <span class="bp">Π</span> <span class="o">{</span><span class="n">n</span><span class="o">},</span> <span class="n">vector</span> <span class="n">α</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span> <span class="bp">→</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">nil</span>  <span class="o">:=</span> <span class="n">nil</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="bp">::</span><span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">h</span><span class="bp">::</span><span class="o">(</span><span class="n">zero_add</span> <span class="n">t</span><span class="o">)</span>
</pre></div>


<p>which I think is the same, but it didn't work for me: </p>
<div class="codehilite"><pre><span></span> <span class="mi">08</span><span class="bp">.</span><span class="mi">04</span><span class="bp">.</span><span class="n">le</span><span class="err">…</span>    <span class="mi">37</span>   <span class="mi">5</span> <span class="n">error</span>           <span class="n">equation</span> <span class="n">compiler</span> <span class="n">failed</span> <span class="n">to</span> <span class="n">create</span> <span class="n">auxiliary</span> <span class="n">declaration</span> <span class="err">&#39;</span><span class="n">zero_add</span><span class="bp">._</span><span class="n">main&#39;</span>
 <span class="n">nested</span> <span class="n">exception</span> <span class="n">message</span><span class="o">:</span>
 <span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
   <span class="n">eq</span><span class="bp">.</span><span class="n">rec</span> <span class="o">(</span><span class="n">id_rhs</span> <span class="o">(</span><span class="n">vector</span> <span class="n">α</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">a_a</span> <span class="bp">::</span> <span class="err">⁇</span><span class="o">))</span>
 <span class="n">term</span>
   <span class="n">id_rhs</span> <span class="o">(</span><span class="n">vector</span> <span class="n">α</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">a_a</span> <span class="bp">::</span> <span class="err">⁇</span><span class="o">)</span>
 <span class="n">has</span> <span class="n">type</span>
   <span class="n">vector</span> <span class="n">α</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
 <span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
   <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">α</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">+</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">)),</span> <span class="n">vector</span> <span class="n">α</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">))</span> <span class="o">(</span><span class="n">a_a</span> <span class="bp">::</span> <span class="n">a_a_1</span><span class="o">)</span> <span class="o">(</span><span class="n">lean</span><span class="bp">-</span><span class="n">checker</span><span class="o">)</span>
 <span class="mi">08</span><span class="bp">.</span><span class="mi">04</span><span class="bp">.</span><span class="n">le</span><span class="err">…</span>    <span class="mi">40</span>  <span class="mi">30</span> <span class="n">error</span>           <span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
   <span class="n">zero_add</span> <span class="n">t</span>
 <span class="n">term</span>
   <span class="n">t</span>
 <span class="n">has</span> <span class="n">type</span>
   <span class="n">vector</span> <span class="n">α</span> <span class="mi">0</span>
 <span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
   <span class="n">vector</span> <span class="n">α</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">+</span> <span class="err">?</span><span class="n">m_1</span><span class="o">)</span> <span class="o">(</span><span class="n">lean</span><span class="bp">-</span><span class="n">checker</span><span class="o">)</span>
</pre></div>

<a name="190923883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190923883" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190923883">Kenny Lau (Mar 17 2020 at 23:23)</a>:</h4>
<p>the resulting type of <code>vector.cons</code> had to be <code>vector (nat.succ n)</code></p>

<a name="190924147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190924147" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190924147">Iocta (Mar 17 2020 at 23:26)</a>:</h4>
<p>What is the implication of that?</p>

<a name="190924966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190924966" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190924966">Kenny Lau (Mar 17 2020 at 23:38)</a>:</h4>
<p>Lean fails to unite <code>nat.succ n</code> with <code>?1 + 1</code></p>

<a name="190925014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190925014" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190925014">Reid Barton (Mar 17 2020 at 23:39)</a>:</h4>
<p>Is it possible to use <code>@</code> with the recursive call? <code>@zero_add n t</code>?</p>

<a name="190925738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190925738" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190925738">Kevin Buzzard (Mar 17 2020 at 23:50)</a>:</h4>
<p>Just to remark that these issues aren't there with what Mario calls the "untyped approach" in that CDGA thread linked to above:</p>
<div class="codehilite"><pre><span></span><span class="kn">universe</span> <span class="n">u</span>

<span class="n">def</span> <span class="n">vector</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="o">:=</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">l</span><span class="bp">.</span><span class="n">length</span> <span class="bp">=</span> <span class="n">n</span><span class="o">}</span>

<span class="n">def</span> <span class="n">append</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span>
  <span class="bp">Π</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">},</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">vector</span> <span class="n">α</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">m</span> <span class="n">n</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">v</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">++</span> <span class="n">w</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">list</span><span class="bp">.</span><span class="n">length_append</span><span class="o">,</span> <span class="n">v</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span> <span class="n">w</span><span class="bp">.</span><span class="mi">2</span><span class="o">]</span><span class="bp">⟩</span> <span class="c1">-- easy</span>
</pre></div>

<a name="190926459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190926459" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190926459">Iocta (Mar 18 2020 at 00:00)</a>:</h4>
<p>I don't see Mario's comments in that thread</p>

<a name="190926501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190926501" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190926501">Iocta (Mar 18 2020 at 00:01)</a>:</h4>
<p>scratch that</p>

<a name="190943659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190943659" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190943659">Iocta (Mar 18 2020 at 06:56)</a>:</h4>
<p>Just to clarify in case I missed the point.. what was the conclusion of this conversation?: is there a way to fill this?</p>
<div class="codehilite"><pre><span></span><span class="kn">universe</span> <span class="n">u</span>

<span class="kn">inductive</span> <span class="n">vector</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">{}</span> <span class="o">:</span> <span class="n">vector</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">cons</span>   <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">n</span><span class="o">},</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">vector</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">vector</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span>


<span class="n">def</span> <span class="n">append</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span>
  <span class="bp">Π</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">},</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">vector</span> <span class="n">α</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="mi">0</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">nil</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="bp">_</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">m</span><span class="o">)</span> <span class="n">n</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="bp">_</span>
</pre></div>

<a name="190950648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190950648" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190950648">Mario Carneiro (Mar 18 2020 at 08:39)</a>:</h4>
<p>Here's a definition that sidesteps the definitional equality problems:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">append</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span>
  <span class="bp">Π</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">},</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">vector</span> <span class="n">α</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="n">n</span> <span class="n">vector</span><span class="bp">.</span><span class="n">nil</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">b</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="n">n</span> <span class="o">(</span><span class="bp">@</span><span class="n">vector</span><span class="bp">.</span><span class="n">cons</span> <span class="bp">_</span> <span class="n">m</span> <span class="n">x</span> <span class="n">a</span><span class="o">)</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">vector</span><span class="bp">.</span><span class="n">cons</span> <span class="n">x</span> <span class="o">(</span><span class="n">append</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span>
</pre></div>

<a name="190950760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190950760" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190950760">Mario Carneiro (Mar 18 2020 at 08:41)</a>:</h4>
<p>To make this work, you need the recursion to follow the same structure on the vectors and on nat. Since addition is defined by recursion on the second argument, but append is defined by recursion on the first vector, that's why the addends are swapped</p>

<a name="190957263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/190957263" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#190957263">Mario Carneiro (Mar 18 2020 at 09:47)</a>:</h4>
<p>If you really want the addends to be in the right order, I don't think you can do better than just having a <code>cast</code> function that transports along equality for the type. (This is actually a special case of <code>eq.subst</code>, but it computes better if you really want to do this dependent type stuff.)</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">append&#39;</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span>
  <span class="bp">Π</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">},</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">vector</span> <span class="n">α</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="n">n</span> <span class="n">vector</span><span class="bp">.</span><span class="n">nil</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">b</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="n">n</span> <span class="o">(</span><span class="bp">@</span><span class="n">vector</span><span class="bp">.</span><span class="n">cons</span> <span class="bp">_</span> <span class="n">m</span> <span class="n">x</span> <span class="n">a</span><span class="o">)</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">vector</span><span class="bp">.</span><span class="n">cons</span> <span class="n">x</span> <span class="o">(</span><span class="n">append&#39;</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span>

<span class="n">def</span> <span class="n">vector</span><span class="bp">.</span><span class="n">cast</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span>
  <span class="bp">Π</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">nat</span><span class="o">},</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">m</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">},</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="n">vector</span><span class="bp">.</span><span class="n">nil</span> <span class="mi">0</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">vector</span><span class="bp">.</span><span class="n">nil</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">@</span><span class="n">vector</span><span class="bp">.</span><span class="n">cons</span> <span class="bp">_</span> <span class="n">m</span> <span class="n">x</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="n">e</span> <span class="o">:=</span>
  <span class="n">vector</span><span class="bp">.</span><span class="n">cons</span> <span class="n">x</span> <span class="o">(</span><span class="n">vector</span><span class="bp">.</span><span class="n">cast</span> <span class="n">a</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span><span class="bp">.</span><span class="n">inj</span> <span class="n">e</span><span class="o">))</span>

<span class="n">def</span> <span class="n">append</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">α</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">append&#39;</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">cast</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">add_comm</span> <span class="n">n</span> <span class="n">m</span><span class="o">)</span>
</pre></div>

<a name="191026530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191026530" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191026530">Iocta (Mar 18 2020 at 18:57)</a>:</h4>
<p>Thanks, gonna have to process this :-)</p>

<a name="191026756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191026756" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191026756">Kevin Buzzard (Mar 18 2020 at 18:59)</a>:</h4>
<p>I have seen this phenomenon several times now -- great, you can now append, but is this really what you want to be doing? You will presumably have to fight dependent type theory when you want to make your next definition on vectors. The approach where you define them as lists of a certain length removes all this headache.</p>

<a name="191027590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191027590" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191027590">Marc Huisinga (Mar 18 2020 at 19:05)</a>:</h4>
<p>Iocta is probably working through TPIL, where you're asked to implement append for vectors in 8.9.5</p>

<a name="191027614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191027614" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191027614">Kevin Buzzard (Mar 18 2020 at 19:05)</a>:</h4>
<p>harsh!</p>

<a name="191027739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191027739" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191027739">Kevin Buzzard (Mar 18 2020 at 19:06)</a>:</h4>
<p>Is the ability to write this sort of code important in formalising? I just try and avoid it...</p>

<a name="191027773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191027773" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191027773">Mario Carneiro (Mar 18 2020 at 19:06)</a>:</h4>
<p>I think you are only asked to write down the type of vector append in TPIL</p>

<a name="191027824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191027824" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191027824">Marc Huisinga (Mar 18 2020 at 19:07)</a>:</h4>
<p>"Following the examples in Section 8.6, define a function that will append two vectors. This is tricky; you will have to define an auxiliary function."</p>

<a name="191027870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191027870" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191027870">Kevin Buzzard (Mar 18 2020 at 19:07)</a>:</h4>
<p>oh mario posted spoilers!</p>

<a name="191028018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191028018" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191028018">Marc Huisinga (Mar 18 2020 at 19:08)</a>:</h4>
<p>it's probably not very important, but the vector example is used very commonly when motivating DTT, especially in programming languages with DTT. my only DTT experience is with lean - is this stuff less painful in any other DTT language?</p>

<a name="191028106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191028106" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191028106">Mario Carneiro (Mar 18 2020 at 19:09)</a>:</h4>
<p>I don't think so, the issues that come up are basically to do with DTT itself and not lean's implementation of it</p>

<a name="191028188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191028188" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191028188">Kevin Buzzard (Mar 18 2020 at 19:10)</a>:</h4>
<p>I think it's telling that both the definitions of vector that we have in mathlib are not this one.</p>

<a name="191028217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191028217" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191028217">Kevin Buzzard (Mar 18 2020 at 19:10)</a>:</h4>
<p>We have "lists of length n" and "functions fin n -&gt; alpha"</p>

<a name="191028259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191028259" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191028259">Marc Huisinga (Mar 18 2020 at 19:11)</a>:</h4>
<p>kind of weird that everyone uses the vector example to motivate DTT then, if it isn't practical anywhere</p>

<a name="191028277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191028277" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191028277">Mario Carneiro (Mar 18 2020 at 19:11)</a>:</h4>
<blockquote>
<p>the vector example is used very commonly when motivating DTT</p>
</blockquote>
<p>I also think it's telling that the very things that motivate DTT are the things that are most difficult to deal with in DTT</p>

<a name="191028348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191028348" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191028348">Kevin Buzzard (Mar 18 2020 at 19:11)</a>:</h4>
<p>They should just get beginners doing commutative algebra :-)</p>

<a name="191028450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191028450" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191028450">Marc Huisinga (Mar 18 2020 at 19:12)</a>:</h4>
<p>when i started formalizing things for my bsc thesis, i also started working with vectors when i wanted to carry around some length invariant.<br>
i think i wrote two definitions and then decided that this isn't a good use of my time :p</p>

<a name="191034661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191034661" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191034661">Patrick Massot (Mar 18 2020 at 20:04)</a>:</h4>
<p>At Big Proof 2, Gilles Dowek was ranting against vectors being presented as the motivation for DTT. He claims that <code>∀ x, P x</code> is the actual motivation.</p>

<a name="191034737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191034737" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191034737">Kevin Buzzard (Mar 18 2020 at 20:04)</a>:</h4>
<p>Exactly! The statement of Fermat's Last Theorem!</p>

<a name="191034774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191034774" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191034774">Kevin Buzzard (Mar 18 2020 at 20:04)</a>:</h4>
<p>For every n&gt;=3, some statement which depends on n is true.</p>

<a name="191037316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191037316" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191037316">Reid Barton (Mar 18 2020 at 20:26)</a>:</h4>
<p>But systems based on, say, first order logic don't have any trouble with such statements either</p>

<a name="191038530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191038530" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191038530">Mario Carneiro (Mar 18 2020 at 20:36)</a>:</h4>
<p>I think that if you follow the "untyped style" with data + proofs, then you are essentially rejecting curry howard, because proofs and data become entirely separate classes, with the thing that makes dependent type theory actually dependent, namely the use of terms inside types (not counting props), being avoided. If you follow this subset strictly, I think you land essentially in HOL.</p>
<p>But then this makes me wonder: we've argued before that HOL is too weak to represent some "real maths", like schemes and such. If that's the case, then this must be using "real dependent types", and there is probably an associated dependent type hell to be had. So how does it manifest?</p>

<a name="191040933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191040933" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191040933">Kevin Buzzard (Mar 18 2020 at 20:55)</a>:</h4>
<p>Recall that a sheaf of types is, amongst other things, a way of associating a type to each open subset of a topological space. We can make these types rings or abelian groups, and then talk about sheaves of modules over a sheaf of rings. I've always suspected that this is problematic in HOL because you won't be able to use typeclasses.</p>

<a name="191041899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191041899" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191041899">Mario Carneiro (Mar 18 2020 at 21:03)</a>:</h4>
<p>Right, so my question is what happens after that, when you do it in DTT. My general prediction is that anything that is impossible in HOL is DTT hell in DTT</p>

<a name="191042071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191042071" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191042071">Mario Carneiro (Mar 18 2020 at 21:04)</a>:</h4>
<p>I think in this case it shows up in some struggles you had about a year ago with using the restriction map for equal sets like <code>U \cap U = U</code></p>

<a name="191042312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191042312" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191042312">Kevin Buzzard (Mar 18 2020 at 21:06)</a>:</h4>
<p>I suspect that sheaves of modules over a fixed sheaf of rings should be some monoidal category (except that I only just found out what these were the other day). That might be a nice exercise :-)</p>

<a name="191042511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191042511" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191042511">Mario Carneiro (Mar 18 2020 at 21:08)</a>:</h4>
<p>and this is reminding me of some recent comments of Thorsten Altenkirch on the cross-mailing list DTT thread:</p>
<blockquote>
<p>But more practically: indeed you are right if you accept this point (i.e. univalence) then you have to give up some properties of equality in particular that it is propositional, i..e a property. This can be annoying because it may mean that you have to deal with coherence issues when using equality, but I suspect you should be used to this. However, as long as you only deal with simple objects, i.e. as in the “world of numbers” everything is fine and nothing changes. It is only when you leave the realm of “set level Mathematics” and talk about structures (as in the Grothendieck example) you encounter equalities which are not propositions (but structures themselves).</p>
</blockquote>

<a name="191042539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191042539" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191042539">Mario Carneiro (Mar 18 2020 at 21:09)</a>:</h4>
<p>"coherence issues when using equality" sounds like trouble</p>

<a name="191042679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191042679" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191042679">Kevin Buzzard (Mar 18 2020 at 21:10)</a>:</h4>
<p>This monoidal category stuff is exactly some sort of attempt to get around it -- Type is a monoidal category because product is not associative, it's only associative up to canonical isomorphism. But carrying around canonical isomorphisms is less painful than carrying around isomorphisms</p>

<a name="191042696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191042696" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191042696">Patrick Massot (Mar 18 2020 at 21:10)</a>:</h4>
<p>Mario, did you carefully look at what Sébastien explained to us in Pittsburgh, and the corresponding mathlib code?</p>

<a name="191042804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191042804" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191042804">Mario Carneiro (Mar 18 2020 at 21:11)</a>:</h4>
<p>probably not? I'm not sure what you are referring to</p>

<a name="191042875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191042875" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191042875">Patrick Massot (Mar 18 2020 at 21:12)</a>:</h4>
<p>Sébastien's motivation for leaving the automated world of Isabelle is not sheaf theory.</p>

<a name="191042944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191042944" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191042944">Mario Carneiro (Mar 18 2020 at 21:13)</a>:</h4>
<p>I'm not saying that HOL is the answer, but rather that DTT has only slightly improved the situation from "you can't do it" to "you <em>can</em> do it, but only if you are a masochist"</p>

<a name="191043015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191043015" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191043015">Mario Carneiro (Mar 18 2020 at 21:14)</a>:</h4>
<p>(or to put it more positively: if you like tricky technical puzzles)</p>

<a name="191043145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191043145" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191043145">Reid Barton (Mar 18 2020 at 21:15)</a>:</h4>
<p>Is it clear that <code>vector</code> (terms inside types) is really the same kind of issue as sheaves (types inside terms)?</p>

<a name="191043251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191043251" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191043251">Mario Carneiro (Mar 18 2020 at 21:16)</a>:</h4>
<p>that's an interesting way to put it</p>

<a name="191043412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191043412" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191043412">Mario Carneiro (Mar 18 2020 at 21:17)</a>:</h4>
<p>DTT (as implemented by lean) brings more than just terms in types, it also brings universes, which allows you to have types as terms. This use isn't particularly problematic AFAIK</p>

<a name="191043594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191043594" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191043594">Kevin Buzzard (Mar 18 2020 at 21:19)</a>:</h4>
<p>It should be noted that we have not yet defined Picard groups in Lean (isomorphism classes of certain sheaves of modules, with group law being tensor product)</p>

<a name="191043648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191043648" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191043648">Mario Carneiro (Mar 18 2020 at 21:19)</a>:</h4>
<p>is that actually a group? It sounds like a 2-group</p>

<a name="191043772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191043772" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191043772">Reid Barton (Mar 18 2020 at 21:20)</a>:</h4>
<p>It's a group because of the phrase "isomorphism classes of". It is true it is the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\pi_0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> of a 2-group or something.</p>

<a name="191043957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191043957" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191043957">Mario Carneiro (Mar 18 2020 at 21:22)</a>:</h4>
<p>aren't those isomorphism classes proper?</p>

<a name="191043998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191043998" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191043998">Kevin Buzzard (Mar 18 2020 at 21:22)</a>:</h4>
<p>It's isomorphism classes of so-called invertible sheaves of modules. This saves you.</p>

<a name="191044058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191044058" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191044058">Kevin Buzzard (Mar 18 2020 at 21:23)</a>:</h4>
<p>All sheaves of modules, you're doomed. An example of a scheme is: choose a field K. Now let the top space be 1 point, and let the sheaf of rings send the empty set to the zero ring, and the whole space to K.</p>

<a name="191044150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191044150" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191044150">Kevin Buzzard (Mar 18 2020 at 21:24)</a>:</h4>
<p>A sheaf of modules for that scheme is just a K-vector space. An invertible sheaf of modules is a 1-dimensional K-vector space.</p>

<a name="191044222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191044222" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191044222">Kevin Buzzard (Mar 18 2020 at 21:24)</a>:</h4>
<p>Tensor product of two 1-dimensional spaces is 1-dimensional; if V is 1-dimensional then the linear dual of V is its inverse. But it turns out they're all isomorphic to K anyway, so the Picard group is trivial.</p>

<a name="191044312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191044312" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191044312">Mario Carneiro (Mar 18 2020 at 21:26)</a>:</h4>
<p>it's still a proper class if you are talking about all 1D K-vector spaces, but I guess there is a small set of representatives</p>

<a name="191044385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191044385" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191044385">Kevin Buzzard (Mar 18 2020 at 21:26)</a>:</h4>
<p>The group is the isomorphism classes so it's trivial</p>

<a name="191044399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191044399" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191044399">Kevin Buzzard (Mar 18 2020 at 21:26)</a>:</h4>
<p>and in general you do some small set trickery to show the group is a set</p>

<a name="191044866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191044866" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191044866">Reid Barton (Mar 18 2020 at 21:31)</a>:</h4>
<p>If you took all the definitions literally in ZFC + one universe U (used to interpret "small" things) then the Picard group of a field would be a group with a single element which is not a member of U (hence neither is the group). But the group is isomorphic to the trivial group, so we pretend it is the trivial group and in particular small.</p>

<a name="191045008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191045008" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191045008">Reid Barton (Mar 18 2020 at 21:33)</a>:</h4>
<p>Similarly if you wrote down all the definitions in Lean you would get a group in <code>Type 1</code> (or <code>Type (u+1)</code>) but it's isomorphic (as a group) to some "ordinary"-sized group</p>

<a name="191051183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191051183" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191051183">Kevin Buzzard (Mar 18 2020 at 22:32)</a>:</h4>
<p>I envisage a future where we're doing etale cohomology or Picard schemes or condensed sets in Lean and every time the answer is in type <code>u+n</code> this means that there are <code>n</code> problems for the ZFC guys to sort out at a future date</p>

<a name="191051766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191051766" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191051766">Reid Barton (Mar 18 2020 at 22:39)</a>:</h4>
<p>Well there are two issues here. One is how to remove the "+U" part of ZFC+U when you want to "export" a Lean proof to ZFC. But even if you are happy to assume ZFC+U, you will probably still want operations like Pic, K-theory, etc. to not increase the universe level.</p>

<a name="191052393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191052393" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191052393">Kevin Buzzard (Mar 18 2020 at 22:46)</a>:</h4>
<p>Yeah but I figure that it's not my problem.</p>

<a name="191052467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191052467" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191052467">Kevin Buzzard (Mar 18 2020 at 22:47)</a>:</h4>
<p>I've worked through enough of these arguments to know that it will all be fine and hey, that's what universe polymorphism is for, right?</p>

<a name="191052523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191052523" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191052523">Kevin Buzzard (Mar 18 2020 at 22:47)</a>:</h4>
<p>The people who are interested in reading section 4 of Scholze etale cohomology of diamonds can fix it up later</p>

<a name="191052628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191052628" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191052628">Kevin Buzzard (Mar 18 2020 at 22:49)</a>:</h4>
<p>I wonder which universe the ideal class group of a number field will end up in</p>

<a name="191052768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191052768" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191052768">Reid Barton (Mar 18 2020 at 22:50)</a>:</h4>
<p>See, I expect the second one will eventually become your problem, though I admit I don't have a compelling example at the moment</p>

<a name="191053233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191053233" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191053233">Reid Barton (Mar 18 2020 at 22:55)</a>:</h4>
<p>The best I can do so far is <a href="https://ncatlab.org/nlab/show/red-shift+conjecture" target="_blank" title="https://ncatlab.org/nlab/show/red-shift+conjecture">the red-shift conjecture</a> which, if you take it as a statement about iterated K-theory, can't be stated in Lean without arranging for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K(R)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mclose">)</span></span></span></span> to live in the same universe as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>, but in the general formulation described on the nlab can be.</p>

<a name="191054898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191054898" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191054898">Kevin Buzzard (Mar 18 2020 at 23:15)</a>:</h4>
<p>Maybe we should ask Leo for a universe for every countable ordinal?</p>

<a name="191077924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191077924" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191077924">Jasmin Blanchette (Mar 19 2020 at 07:30)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> There are actually things that feel OK in HOL and considered hell in DTT. Namely, inductive predicates. HOL's inductive predicates are built on top of Knaster-Tarski and not encoded as inductive types (Curry-Howard). They work quite smoothly. Whereas in CIC, one ends up with the evil "vector" essentially, and dependently typed matching, etc. Maybe this is an argument against Curry-Howard -- or maybe it just shows that Lean's "induction/cases/match" could be improved.</p>
<p>I tried (with Johannes) to build a course that would almost exclusively remain in the HOL fragment of Lean, but in the end I had to give up because of inductive predicates. Now I'll even teach the (suboptimal) way of doing "vector", so that I can show the parallel with inductive predicates -- Curry-Howard in action.</p>

<a name="191078040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191078040" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191078040">Jasmin Blanchette (Mar 19 2020 at 07:32)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Concerning "you _can_ do it, but only if you are a masochist", I think things like dependent pairs (and structures) and higher-rank polymorphism are useful and not hellish.</p>

<a name="191078672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191078672" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191078672">Kevin Buzzard (Mar 19 2020 at 07:42)</a>:</h4>
<p>Equality of structures is hellish but in a lot of mathematics it turns out that we don't use the concept. We do use _some_ kind of equivalence relation, but it seems to be not any of the ones that these systems make available to us</p>

<a name="191079337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191079337" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191079337">Mario Carneiro (Mar 19 2020 at 07:52)</a>:</h4>
<p>the major hellish aspect of DTT here is what I call "rigid parameters" like the <code>n</code> in <code>vector A n</code>. Here we have a type <code>nat</code> about which we have a bunch of useful (propositional) equalities, but by putting the parameter in a type dependency, only defeq matters, and this isn't what we want, so we have to fight it with casts and things and it's downhill from there.</p>

<a name="191079490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191079490" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191079490">Mario Carneiro (Mar 19 2020 at 07:54)</a>:</h4>
<p>This is different from the issue that HoTT tries to solve, which is how to replace isomorphism of various kinds with equality (not defeq). You still have to use casts on rigid parameters, and the casts carry information now so you have coherences all over the place</p>

<a name="191079717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191079717" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191079717">Johan Commelin (Mar 19 2020 at 07:57)</a>:</h4>
<p>Why? You could <code>transfer</code> a <code>vector A n</code> to a <code>vector A m</code> along <code>h : n = m</code>, right?</p>

<a name="191079853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191079853" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191079853">Mario Carneiro (Mar 19 2020 at 07:59)</a>:</h4>
<p>that's just another way to use <code>cast</code></p>

<a name="191079892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191079892" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191079892">Mario Carneiro (Mar 19 2020 at 07:59)</a>:</h4>
<p>the problem is that because <code>vector</code> is data, that <code>cast</code> is not being used in a proof, it is being used in a definition and that means you will have to destructure this later</p>

<a name="191079897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191079897" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191079897">Mario Carneiro (Mar 19 2020 at 07:59)</a>:</h4>
<p>and that usually means second order <code>cast</code></p>

<a name="191080065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191080065" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191080065">Johan Commelin (Mar 19 2020 at 08:01)</a>:</h4>
<p>Well, sure. But my impression was that HoTT has better support for higher order cast. It's what you're supposed to be doing.</p>

<a name="191080112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191080112" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191080112">Mario Carneiro (Mar 19 2020 at 08:01)</a>:</h4>
<p>For example, I wrote down a definition of <code>append</code> above, using a <code>cast</code>. Proving that <code>append</code> is associative is both not fun and impossible because of type constraints</p>

<a name="191080193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191080193" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191080193">Johan Commelin (Mar 19 2020 at 08:02)</a>:</h4>
<p>Do you run into the same problem with HoTT?</p>

<a name="191080202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191080202" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191080202">Johan Commelin (Mar 19 2020 at 08:02)</a>:</h4>
<p>(I don't know, I never tried it.)</p>

<a name="191080233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191080233" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191080233">Mario Carneiro (Mar 19 2020 at 08:02)</a>:</h4>
<p>Yes, HoTT encourages analysis of the structure of higher order cast. That's why everyone gets distracted with this and forgets to get back to the maths</p>

<a name="191080243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191080243" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191080243">Johan Commelin (Mar 19 2020 at 08:02)</a>:</h4>
<p>My guess is that with HoTT you would be able to write down a higher homotopy that proves the assoc. And probably it's not even ugly.</p>

<a name="191080397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191080397" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191080397">Mario Carneiro (Mar 19 2020 at 08:05)</a>:</h4>
<p>one theoretical fact that's not so nice is that you can never be "done" with your library of theorems about equality. You can prove that eq is symmetric, but that's a definition; now you want to prove that this definition has an inverse, and that's another higher order thing, then you want that your associator satisfies a pentagon lemma, and it just keeps going</p>

<a name="191080419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191080419" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191080419">Mario Carneiro (Mar 19 2020 at 08:05)</a>:</h4>
<p>with a proof irrelevant equality it bottoms out at the first level, and then all equalities you need are just true</p>

<a name="191080471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191080471" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191080471">Mario Carneiro (Mar 19 2020 at 08:06)</a>:</h4>
<p>in HoTT it feels like you can never just say that a fact is true, because how it was proved always comes back later</p>

<a name="191080535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191080535" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191080535">Johan Commelin (Mar 19 2020 at 08:07)</a>:</h4>
<p>Sure, but it shifts the problem. Because when you're doing tensor products of modules, you end up with those pentagon lemmas anyway (but with lesser support). Higher-order equality is a real thing in math. And we need to be able to rewrite along it effortlessly.</p>

<a name="191080607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191080607" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191080607">Mario Carneiro (Mar 19 2020 at 08:08)</a>:</h4>
<p>I'm not convinced that HoTT actually makes dealing with any of it nicer than you can already do in lean, it just makes these problems pervasive</p>

<a name="191080836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191080836" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191080836">Mario Carneiro (Mar 19 2020 at 08:12)</a>:</h4>
<p>To put it another way, when you have Prop, every theorem tells you a little bit more about the mathematical structures of interest. In HoTT, every theorem is a definition, every answer results in several more questions, and no matter how much you work at it there is always a "raw end" where you haven't proven all the important theorems about some definition, because it's turtles all the way down. It's psychologically unsatisfying</p>

<a name="191080894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191080894" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191080894">Mario Carneiro (Mar 19 2020 at 08:13)</a>:</h4>
<p>which is why it's no surprise that people get distracted with the higher order stuff</p>

<a name="191080985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191080985" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191080985">Johan Commelin (Mar 19 2020 at 08:14)</a>:</h4>
<p>Well, you can prove that definition <code>X</code> is an <code>hProp</code> (assuming that it is the analogue of some Lean <code>Prop</code>). And you can prove once and for all that <code>hProp foobar</code> is an <code>hProp</code> for all <code>foobar</code>. So I think the turtles do become extremely trivial at some point.</p>

<a name="191081111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191081111" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191081111">Johan Commelin (Mar 19 2020 at 08:16)</a>:</h4>
<p>In mathlib we have <code>unique_unique</code>, but not <code>unique_unique_unique</code>...</p>

<a name="191081127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191081127" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191081127">Mario Carneiro (Mar 19 2020 at 08:16)</a>:</h4>
<p>But it's not like the h-levels exhaust the type universe, and why make an assumption if it's not needed? So you study general types instead and there is no bottom there</p>

<a name="191086687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191086687" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191086687">Kevin Buzzard (Mar 19 2020 at 09:21)</a>:</h4>
<p>I think that ultimately there is a big question: what happens if you try to do the mathematics which Johan and I think of as normal, but which turns out to be a million miles from anything done in these provers, and I don't think it's clear what the answer will be. I don't need the pentagon axiom to do Picard groups because an element of that group is an isomorphism class of shaves of modules and all I need to know for associativity in that group is that (A tensor B) tensor C is isomorphic to A tensor (B tensor C) and I don't seem to care about compatibilities. For this particular topic mathematicians are happy to truncate. For others, we just don't know. Do I need the pentagon axiom to prove Fermat's last theorem? I'm not so sure.</p>

<a name="191135968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191135968" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191135968">Scott Morrison (Mar 19 2020 at 16:11)</a>:</h4>
<p>This question is all about your "category number", i.e. what level in the hierarchy of n-categories you can/need/want to truncate at.</p>

<a name="191136003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191136003" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191136003">Scott Morrison (Mar 19 2020 at 16:11)</a>:</h4>
<p>Nearly all mathematicians' category number is one higher than they realise it is. :-)</p>

<a name="191136126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191136126" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191136126">Scott Morrison (Mar 19 2020 at 16:12)</a>:</h4>
<p>But maybe 50% of mathematicians have category number 0, another 40% category number 1, then 9% 2. (And then add +1 to most of those numbers when it's time to formalise their hunches about how things work. :-)</p>

<a name="191136252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191136252" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191136252">Scott Morrison (Mar 19 2020 at 16:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/113489-new-members/topic/more.20more.20basics/near/191136003" title="#narrow/stream/113489-new-members/topic/more.20more.20basics/near/191136003">said</a>:</p>
<blockquote>
<p>Nearly all mathematicians' category number is one higher than they realise it is. :-)</p>
</blockquote>
<p>Sadly, this is one of those rules that sometimes still applies even after you've taken into account that it applies.... It's a slippery slope!</p>

<a name="191136381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191136381" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191136381">Scott Morrison (Mar 19 2020 at 16:14)</a>:</h4>
<p>(And of course those percentages are total garbage.)</p>

<a name="191355821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191355821" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191355821">Ulrik Buchholtz (Mar 21 2020 at 17:08)</a>:</h4>
<p>I just saw this thread now, after Kevin pinged me. Of course many people are now interested in homotopified mathematics and brave new algebra and what-not, but the large majority are happy with sets and groupoids and the occasional 2-type.</p>

<a name="191356010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191356010" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191356010">Kevin Buzzard (Mar 21 2020 at 17:13)</a>:</h4>
<p>working mathematicians certainly work like this. Is it possible to work like this in a HoTT theory without any inconvenience? I guess I am hoping for concrete examples. I am hoping that Johan or others will soon show me such things.</p>

<a name="191356105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191356105" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191356105">Ulrik Buchholtz (Mar 21 2020 at 17:15)</a>:</h4>
<p>I don't see why not, we already have quite a bit of algebra done like this in some of the HoTT libraries.</p>

<a name="191356314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191356314" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191356314">Kevin Buzzard (Mar 21 2020 at 17:19)</a>:</h4>
<p>Which ones and what algebra? Can you answer in the thread on the HoTT Zulip? I am interested in a detailed overview of some of these systems, the README.md for these HoTT repos does not give this.</p>

<a name="191356364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191356364" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191356364">Kevin Buzzard (Mar 21 2020 at 17:20)</a>:</h4>
<p>I was thinking about defining Noetherian rings and then it occurred to me that some of these systems might not currently have a workable definition of a finite type. This is thousands of lines of Lean code.</p>

<a name="191356377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20more%20basics/near/191356377" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/91420moremorebasics.html#191356377">Ulrik Buchholtz (Mar 21 2020 at 17:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/more.20more.20basics/near/191356314" title="#narrow/stream/113489-new-members/topic/more.20more.20basics/near/191356314">said</a>:</p>
<blockquote>
<p>Which ones and what algebra? Can you answer in the thread on the HoTT Zulip?</p>
</blockquote>
<p>OK, let's continue there.</p>


{% endraw %}

{% include archive_update.html %}