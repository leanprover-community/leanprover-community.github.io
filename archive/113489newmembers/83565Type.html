---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113489newmembers/83565Type.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/83565Type.html">Type*</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="184686187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/184686187" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/83565Type.html#184686187">Enrico Borba (Jan 02 2020 at 21:33)</a>:</h4>
<p>Hi, thank you all for the awesome work done on Lean. I have been messing with it for the past month or so, and I'm absolutely amazed by it. Quick question: what does <code>Type*</code> mean? I haven't encountered an asterisk like that before, and first encountered it when reading Logic and Proof after doing all of the exercises in TPiL.</p>

<a name="184686474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/184686474" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/83565Type.html#184686474">Chris Hughes (Jan 02 2020 at 21:36)</a>:</h4>
<p>It usually means <code>Type u</code> where <code>u</code> is a universe variable. Basically it lets Lean choose the universe, and it usually chooses the most polymorphic option.</p>

<a name="184686544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/184686544" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/83565Type.html#184686544">Enrico Borba (Jan 02 2020 at 21:37)</a>:</h4>
<p>Oh interesting. Is this a more general notation that can be used elsewhere or is it specific to being a placeholder for universes?</p>

<a name="184689349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/184689349" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/83565Type.html#184689349">Chris Hughes (Jan 02 2020 at 22:24)</a>:</h4>
<p>I think it's just <code>Type*</code> and <code>Sort*</code>. I think <code>Type*</code> might be the same as <code>Type _</code> and underscores can be used in a lot of places</p>

<a name="184715911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/184715911" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/83565Type.html#184715911">Mukesh Tiwari (Jan 03 2020 at 07:37)</a>:</h4>
<p><span class="user-mention" data-user-id="110044">@Chris Hughes</span>  Does this means that if I don't want to go through the universe details, then I can use Type * or Type _ ?</p>

<a name="184718394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/184718394" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/83565Type.html#184718394">Chris Hughes (Jan 03 2020 at 08:40)</a>:</h4>
<p>Yes. <code>Type*</code> is what is used most of the time to avoid having to think about universes.</p>

<a name="184828115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/184828115" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/83565Type.html#184828115">Mukesh Tiwari (Jan 05 2020 at 01:35)</a>:</h4>
<p><span class="user-mention" data-user-id="110044">@Chris Hughes</span>  Sorry for disturbing you, but could you please tell me that why the second one is not accepted by Lean? <br>
This is accepted by Lean:</p>
<div class="codehilite"><pre><span></span>universe u
class Associative {G : Type u} (f : G → G → G) : Type u :=
(Hassoc : ∀ x y z : G, f (f x y) z = f x (f y z))
</pre></div>


<p>But this one not:</p>
<div class="codehilite"><pre><span></span>class Associative {G : Type _} (f : G → G → G) : Type _ :=
(Hassoc : ∀ x y z : G, f (f x y) z = f x (f y z))
</pre></div>

<a name="184828333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/184828333" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/83565Type.html#184828333">Chris Hughes (Jan 05 2020 at 01:42)</a>:</h4>
<p>I guess I was wrong about <code>Type*</code> being the same as <code>Type _</code>. <code>Type _</code> will probably try to infer from the context what the universe should be - it will fill it in with whatever it is forced to be, and will fail if there's nothing forcing it to be a particular universe. and <code>Type*</code> will fill it in with something sensible basically. I don't know the precise algorithms.</p>

<a name="184829264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/184829264" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/83565Type.html#184829264">Mario Carneiro (Jan 05 2020 at 02:17)</a>:</h4>
<p>These are not the same; one uses <code>Type u</code> and the other uses <code>Type _</code>. I'm pretty sure that <code>Type*</code> and <code>Type _</code> are identical</p>

<a name="184829336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/184829336" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/83565Type.html#184829336">Mario Carneiro (Jan 05 2020 at 02:19)</a>:</h4>
<p>The error message makes it clear what the problem is:</p>
<div class="codehilite"><pre><span></span>failed to add declaration &#39;Associative&#39; to environment, type has metavariables
</pre></div>


<p>It successfully unified, but it wasn't completely able to pin down the target type because this is also valid:</p>
<div class="codehilite"><pre><span></span><span class="kn">universe</span> <span class="n">u</span>
<span class="n">class</span> <span class="n">Associative</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">37</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">Hassoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="o">(</span><span class="n">f</span> <span class="n">y</span> <span class="n">z</span><span class="o">))</span>
</pre></div>

<a name="184834481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/184834481" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/83565Type.html#184834481">Mukesh Tiwari (Jan 05 2020 at 05:20)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  Thanks for the answer. The purpose of the question was to avoid universe hierarchy, and let Lean figured out the universe; hence, I left the return type as Type _.  If I do not mention any return type, then it is fine. </p>
<div class="codehilite"><pre><span></span>class Associative {G : Type _} (f : G → G → G) :=
(Hassoc : ∀ x y z : G, f (f x y) z = f x (f y z))

#check Associative
returns Associative : (?M_1 → ?M_1 → ?M_1) → Type
</pre></div>


<p>Coming back to my question (also because of my Coq background), if I want to avoid the universe hierarchy, then what is the best way to go?</p>


{% endraw %}

{% include archive_update.html %}