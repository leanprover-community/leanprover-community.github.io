---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/113489newmembers/86768ETCS.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html">ETCS</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="135520140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520140" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135520140">David Michael Roberts (Oct 10 2018 at 05:32)</a>:</h4>
<p>I might have a crack at showing that sets form a category that is a model of ETCS <a href="https://ncatlab.org/nlab/show/ETCS" target="_blank" title="https://ncatlab.org/nlab/show/ETCS">https://ncatlab.org/nlab/show/ETCS</a></p>

<a name="135520152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520152" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135520152">David Michael Roberts (Oct 10 2018 at 05:33)</a>:</h4>
<p>Or at least build a model of ETCS in Lean. Not sure quite what the sets of Lean <em>are</em> yet.</p>

<a name="135520216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520216" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135520216">David Michael Roberts (Oct 10 2018 at 05:35)</a>:</h4>
<p>I mean, I notice that in <code>set_theory.zfc</code> presets are used, but I can't tell if these are the same as Bishop-style presets (<a href="https://ncatlab.org/nlab/show/preset" target="_blank" title="https://ncatlab.org/nlab/show/preset">https://ncatlab.org/nlab/show/preset</a>) and then sets are what are sometimes called setoids (<a href="https://ncatlab.org/nlab/show/equivalence+relation#setoids" target="_blank" title="https://ncatlab.org/nlab/show/equivalence+relation#setoids">https://ncatlab.org/nlab/show/equivalence+relation#setoids</a>)</p>

<a name="135520260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520260" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135520260">Simon Hudon (Oct 10 2018 at 05:36)</a>:</h4>
<p>There are multiple formalizations of sets in Lean, depending on your needs. <code>set_theory.zfc</code> is if you're interested in (untyped) ZFC set theory, <code>data.set</code> formalize sets whose elements have a certain type as predicates on that type and <code>data.finset</code> formalizes finite sets whose elements also have a given type.</p>

<a name="135520277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520277" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135520277">Simon Hudon (Oct 10 2018 at 05:37)</a>:</h4>
<p>In <code>set_theory.zfc</code> there is <code>pSet</code> but there's also <code>Set</code> which might be more useful</p>

<a name="135520450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520450" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135520450">Mario Carneiro (Oct 10 2018 at 05:42)</a>:</h4>
<p>I think that <code>pSet</code> is indeed a preset in the nLab sense</p>

<a name="135520457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520457" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135520457">David Michael Roberts (Oct 10 2018 at 05:42)</a>:</h4>
<p>Yes, I could show that ZFC-sets give a model of ETCS, but it would be more interesting to show that one could build the category of "sets" directly, without knowing a well-founded \in-tree structure on them.</p>

<a name="135520466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520466" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135520466">Mario Carneiro (Oct 10 2018 at 05:43)</a>:</h4>
<p>although of course there is an equality relation on <code>pSet</code>, since it is a type; this equality is too fine for ZFC and <code>Set</code> is a quotient of this by set extensionality</p>

<a name="135520467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520467" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135520467">David Michael Roberts (Oct 10 2018 at 05:43)</a>:</h4>
<p>So I guess: is there a way to talk about sets native to Lean, as there is in HoTT, for instance? (where there is the type of hSets)</p>

<a name="135520468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520468" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135520468">Mario Carneiro (Oct 10 2018 at 05:43)</a>:</h4>
<p>hSet = Type in lean</p>

<a name="135520469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520469" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135520469">David Michael Roberts (Oct 10 2018 at 05:43)</a>:</h4>
<p>Oh, cool!</p>

<a name="135520472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520472" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135520472">Mario Carneiro (Oct 10 2018 at 05:43)</a>:</h4>
<p>all types are "sets" in the HoTT sense, because of proof irrelevance</p>

<a name="135520526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520526" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135520526">David Michael Roberts (Oct 10 2018 at 05:44)</a>:</h4>
<p>So, in principle, one could try to show that Type is (the objects of) a category—perhaps this is done already—and then show it is a term of type <code>ETCS</code>, once that is defined.</p>

<a name="135520544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520544" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135520544">Mario Carneiro (Oct 10 2018 at 05:45)</a>:</h4>
<p>yes, that should not be difficult</p>

<a name="135520546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520546" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135520546">Simon Hudon (Oct 10 2018 at 05:45)</a>:</h4>
<p>There is a category of types in <code>category_theory.types</code></p>

<a name="135520547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520547" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135520547">Scott Morrison (Oct 10 2018 at 05:45)</a>:</h4>
<p>The category structure on <code>Type</code> is at <a href="https://github.com/leanprover/mathlib/blob/master/category_theory/types.lean" target="_blank" title="https://github.com/leanprover/mathlib/blob/master/category_theory/types.lean">https://github.com/leanprover/mathlib/blob/master/category_theory/types.lean</a></p>

<a name="135520549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520549" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135520549">Mario Carneiro (Oct 10 2018 at 05:45)</a>:</h4>
<p>also ^ that</p>

<a name="135520589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520589" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135520589">Simon Hudon (Oct 10 2018 at 05:46)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> not fast enough!</p>

<a name="135520591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520591" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135520591">Scott Morrison (Oct 10 2018 at 05:46)</a>:</h4>
<p>:-)</p>

<a name="135520593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520593" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135520593">Scott Morrison (Oct 10 2018 at 05:46)</a>:</h4>
<p>I was running a longer race. :-)</p>

<a name="135520607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520607" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135520607">Simon Hudon (Oct 10 2018 at 05:47)</a>:</h4>
<p>Now you understand why some of my code snippets have small type errors in them :P</p>

<a name="135520725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520725" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135520725">David Michael Roberts (Oct 10 2018 at 05:50)</a>:</h4>
<p>OK, cool, thanks :-)</p>

<a name="135520730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520730" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135520730">Mario Carneiro (Oct 10 2018 at 05:50)</a>:</h4>
<p>What's more, I think there is a model of ETCS in <code>Type</code></p>

<a name="135520738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520738" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135520738">Mario Carneiro (Oct 10 2018 at 05:51)</a>:</h4>
<p>i.e. a suitably large inductive type can give you all the types you need to interpret the operations of ETCS</p>

<a name="135520740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520740" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135520740">David Michael Roberts (Oct 10 2018 at 05:51)</a>:</h4>
<p>As an aside: is there a handy chart that details the various unicode autocompletion shortcuts? and/or LaTeX : autocompl shortcut table?</p>

<a name="135520744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520744" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135520744">Mario Carneiro (Oct 10 2018 at 05:51)</a>:</h4>
<p>If you want the full list you should look at the vscode extension file</p>

<a name="135520791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520791" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135520791">Mario Carneiro (Oct 10 2018 at 05:52)</a>:</h4>
<p>but it is quite large and likely auto-populated with a bunch of things from LaTeX</p>

<a name="135520794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520794" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135520794">Bryan Gin-ge Chen (Oct 10 2018 at 05:52)</a>:</h4>
<p>You can also paste in symbols from <a href="https://github.com/EdAyers/mathlib/blob/doc/docs/unicode.md" target="_blank" title="https://github.com/EdAyers/mathlib/blob/doc/docs/unicode.md">this page</a> and hover over them to see what the completion is.</p>

<a name="135520796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520796" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135520796">David Michael Roberts (Oct 10 2018 at 05:52)</a>:</h4>
<p>Which lives...? (thanks, btw)</p>

<a name="135520801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520801" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135520801">David Michael Roberts (Oct 10 2018 at 05:52)</a>:</h4>
<p><span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span>  cool, thanks</p>

<a name="135520810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520810" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135520810">Mario Carneiro (Oct 10 2018 at 05:52)</a>:</h4>
<p><a href="https://github.com/leanprover/vscode-lean/blob/master/translations.json" target="_blank" title="https://github.com/leanprover/vscode-lean/blob/master/translations.json">https://github.com/leanprover/vscode-lean/blob/master/translations.json</a></p>

<a name="135520811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520811" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135520811">Bryan Gin-ge Chen (Oct 10 2018 at 05:52)</a>:</h4>
<p><a href="https://github.com/leanprover/vscode-lean/blob/master/translations.json" target="_blank" title="https://github.com/leanprover/vscode-lean/blob/master/translations.json">Here's</a> the vscode file</p>

<a name="135520872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520872" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135520872">David Michael Roberts (Oct 10 2018 at 05:54)</a>:</h4>
<p><span class="emoji emoji-1f44d" title="+1">:+1:</span></p>

<a name="135520877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520877" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135520877">Mario Carneiro (Oct 10 2018 at 05:55)</a>:</h4>
<p>The maintainer of the extension (Gabriel Ebner) is quite receptive to adding new symbols if you spot one in high unicode that you like</p>

<a name="135716573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135716573" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135716573">Jesse Michael Han (Oct 13 2018 at 04:14)</a>:</h4>
<p><span class="user-mention" data-user-id="130272">@David Michael Roberts</span> Nice seeing you here!</p>
<p><code>Type</code> is indeed a model of ETCS; function extensionality should correspond to well-pointedness,  working in <code>classical</code>, we have choice, <code>Prop</code> is the subobject classifier, and  the NNO is <code>nat</code>.</p>

<a name="135716828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135716828" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135716828">David Michael Roberts (Oct 13 2018 at 04:22)</a>:</h4>
<p>Sure, but is it _proved_ to be a model of ETCS? And, if I use the constructive fragment, do I get a model of the constructive version (a la I guess Mike Shulman's "material and structural set theories" paper)</p>

<a name="135716833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135716833" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135716833">David Michael Roberts (Oct 13 2018 at 04:22)</a>:</h4>
<p>Oh, and thanks, <span class="user-mention" data-user-id="116045">@Jesse Michael Han</span>  :-)</p>

<a name="135716853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135716853" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135716853">David Michael Roberts (Oct 13 2018 at 04:23)</a>:</h4>
<p>Also, one could go the whole hog and show without using even <code>Prop</code> that Type is some kind of predicative topos...</p>

<a name="135716897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135716897" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135716897">David Michael Roberts (Oct 13 2018 at 04:24)</a>:</h4>
<p>That said, this is just to get me wet behind the ears and play around with stuff that I care about.</p>

<a name="135716898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135716898" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135716898">Mario Carneiro (Oct 13 2018 at 04:24)</a>:</h4>
<p>Do you know what that should mean?</p>

<a name="135716988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135716988" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135716988">David Michael Roberts (Oct 13 2018 at 04:26)</a>:</h4>
<p>There is a constructive version of well-pointedness, that doesn't force Booleanness. just that "a global element of the subobject classifier is false if and only if it is not true." (from <a href="https://ncatlab.org/nlab/show/well-pointed+topos" target="_blank" title="https://ncatlab.org/nlab/show/well-pointed+topos">https://ncatlab.org/nlab/show/well-pointed+topos</a>)</p>

<a name="135717000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135717000" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135717000">David Michael Roberts (Oct 13 2018 at 04:27)</a>:</h4>
<p>And as far as predicative stuff, one could show directly that Type is a Pi-W-pretopos satisfying some version of WISC (??? not sure about that one), following eg Benno van den Berg</p>

<a name="135717053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135717053" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135717053">David Michael Roberts (Oct 13 2018 at 04:29)</a>:</h4>
<p>For instance "the category of Bishop sets in Martin-Löf type theory is a predicative topos" (<a href="https://ncatlab.org/nlab/show/predicative+topos" target="_blank" title="https://ncatlab.org/nlab/show/predicative+topos">https://ncatlab.org/nlab/show/predicative+topos</a>)</p>

<a name="135718340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135718340" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135718340">Mario Carneiro (Oct 13 2018 at 05:12)</a>:</h4>
<p>I'm not sure about WISC, seems like any version of the axiom of choice is likely to be false without <code>choice</code>, but I checked the proof that epis are surjective in lean:</p>
<div class="codehilite"><pre><span></span><span class="kn">universe</span> <span class="n">u</span>
<span class="kn">theorem</span> <span class="n">epi</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>
  <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="n">h</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">),</span> <span class="n">g</span> <span class="err">∘</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">h</span> <span class="err">∘</span> <span class="n">f</span> <span class="bp">→</span> <span class="n">g</span> <span class="bp">=</span> <span class="n">h</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">g</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">ulift</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">⟨∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">h</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">ulift</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">true</span><span class="bp">⟩</span> <span class="k">in</span>
<span class="k">have</span> <span class="n">g</span> <span class="bp">=</span> <span class="n">h</span><span class="o">,</span> <span class="k">from</span> <span class="n">H</span> <span class="bp">_</span> <span class="n">g</span> <span class="n">h</span> <span class="o">(</span><span class="n">funext</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">congr_arg</span> <span class="n">ulift</span><span class="bp">.</span><span class="n">up</span> <span class="err">$</span> <span class="n">eq_true_intro</span> <span class="err">$</span> <span class="k">by</span> <span class="n">exact</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">),</span>
<span class="k">by</span> <span class="n">injection</span> <span class="n">congr_fun</span> <span class="n">this</span> <span class="n">y</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">cast</span> <span class="n">eq_true</span> <span class="n">h_1</span>
</pre></div>


<p>and it looks like you need <code>Prop</code> and <code>propext</code> essentially (you can't prove it using <code>trunc</code>, and you certainly can't prove it "constructively" i.e. with a sigma)</p>

<a name="135718618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135718618" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135718618">Mario Carneiro (Oct 13 2018 at 05:24)</a>:</h4>
<p>Actually I find this to be an interesting example of a "nonconstructive" constructive exists, in the sense that you can't upgrade the exists to a data type even though the proof does not use choice.</p>

<a name="135719664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135719664" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135719664">Mario Carneiro (Oct 13 2018 at 06:02)</a>:</h4>
<p>I am almost certain that WISC is not provable, although I don't think there is an easy proof of this. I don't think Asaf Karagila's proof <a href="https://arxiv.org/pdf/1212.4396.pdf" target="_blank" title="https://arxiv.org/pdf/1212.4396.pdf">https://arxiv.org/pdf/1212.4396.pdf</a> is much affected by the presence of inaccessible cardinals, so it should be independent of lean as well by simulation in ZFC + omega inaccessibles (below the first inaccessible because we are working in <code>Type</code>).</p>

<a name="135721449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135721449" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135721449">David Michael Roberts (Oct 13 2018 at 07:11)</a>:</h4>
<p>Well, I did prove (on paper) that WISC isn't provable from the axioms of an elementary topos, by constructing a topos where it fails :-)</p>

<a name="135721505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135721505" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135721505">Mario Carneiro (Oct 13 2018 at 07:13)</a>:</h4>
<p>I suppose that's also an option... I guess lean has a bit more structure though, so maybe you have to do that with pi-W-toposes? Is that a thing?</p>

<a name="135743749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135743749" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135743749">Jesse Michael Han (Oct 13 2018 at 19:19)</a>:</h4>
<p><span class="user-mention" data-user-id="130272">@David Michael Roberts</span> I'm not sure if</p>
<blockquote>
<p>a global element of the subobject classifier is false if and only if it is not true</p>
</blockquote>
<p>holds without invoking <code>classical</code>. Without being able to take a filterquotient of <code>Prop</code>, it's just a massive Heyting algebra, and even with excluded middle, if Lean knows that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⊢</mo><mi>p</mi><mo>∨</mo><mi mathvariant="normal">¬</mi><mi>p</mi></mrow><annotation encoding="application/x-tex"> \vdash p \vee \neg p</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mrel">⊢</span><span class="mord mathit">p</span><span class="mbin">∨</span><span class="mord mathrm">¬</span><span class="mord mathit">p</span></span></span></span>, it does not necessarily decide if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit">p</span></span></span></span> is true or false.</p>
<p>Lean is also not quite a topos over <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="bold">S</mi><mi mathvariant="bold">e</mi><mi mathvariant="bold">t</mi></mrow></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68611em;"></span><span class="strut bottom" style="height:0.68611em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathbf">S</span><span class="mord mathbf">e</span><span class="mord mathbf">t</span></span></span></span></span>, for it lacks externally indexed colimits (while <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathrm">Σ</span></span></span></span>-types and quotient types give all internally indexed colimits).</p>

<a name="135752172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135752172" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135752172">Mario Carneiro (Oct 13 2018 at 23:40)</a>:</h4>
<p><span class="user-mention" data-user-id="116045">@Jesse Michael Han</span> Could you unpack what that statement about the subobject classifier should mean? I assume <code>Prop</code> is a subobject classifier for <code>Type</code> even without <code>choice</code> (but assuming <code>propext</code>), because every monomorphism in <code>Type</code> is an injection, and so it factors through the subtype on the range.</p>
<p>Actually, I see another problem: If f : A -&gt; X is a monomorphism and g : X -&gt; Prop is the function <code>g x = \ex a, f x = a</code>, then we want a pullback square with the <code>true : unit -&gt; Prop</code> function. But the subtype is a pullback, and A is not constructively isomorphic to the subtype, so I don't think it holds. That is, <code>Prop</code> isn't even a subobject classifier.</p>

<a name="135754838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135754838" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135754838">Jesse Michael Han (Oct 14 2018 at 00:56)</a>:</h4>
<p>That's interesting. (I assume you mean <code>g x = \ex a, f a = x</code>.) Why is the image of an injection not constructively isomorphic to its domain?</p>

<a name="135755636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135755636" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135755636">Mario Carneiro (Oct 14 2018 at 01:16)</a>:</h4>
<p>There are a few ways to look at it. My favorite is to think in terms of what is "data" vs "erased" stuff, which corresponds to stuff that the computer could actually execute or manipulate. If you have a function f : A -&gt; X where A and X are both data types, then f is a real <em>function</em>, something that transforms one kind of representation into another. There is no guarantee that this transformation is invertible, and in particular assuming that f is injective does not supply you with such an inverse. (This is why <code>equiv</code> contains an explicit inverse function, and <code>bijection</code> is a weaker notion.) So defining a function from A to {x // x \in range f} is easy by restricting the codomain of f, but you don't have enough data for the converse function.</p>
<p>In set theory you would use the exists assumption to give the value, but since this is a Prop, it is "not data" and can't be turned into data. If you use a Type-valued equivalent, like <code>trunc {a // f a = x}</code>, then it would be constructively bijective, but in this case I'm not sure it's a pullback.</p>

<a name="135755884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135755884" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135755884">Jesse Michael Han (Oct 14 2018 at 01:25)</a>:</h4>
<p>If that's the case, when maybe one does need 'classical' to show that <code>Prop</code> (which is then <code>bool</code>) is a subobject classifier after all.</p>
<p>Could you explain why couldn't we do something like, take the collection of pairs <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>f</mi><mo>(</mo><mi>a</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">(a, f(a))</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">(</span><span class="mord mathit">a</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> and flip the pairs to get an inverse?</p>

<a name="135755947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135755947" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135755947">Mario Carneiro (Oct 14 2018 at 01:26)</a>:</h4>
<p>Ah, here's another way to show choiceless <code>Type</code> is not a topos:</p>
<blockquote>
<p>Corollary 4.2. <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="bold">C</mi></mrow></mrow><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68611em;"></span><span class="strut bottom" style="height:0.68611em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathbf">C</span></span></span></span></span> is balanced, i.e., a morphism in <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="bold">C</mi></mrow></mrow><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68611em;"></span><span class="strut bottom" style="height:0.68611em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathbf">C</span></span></span></span></span> is an isomorphism iff it is both monic and epic. (<a href="https://ncatlab.org/nlab/show/subobject+classifier" target="_blank" title="https://ncatlab.org/nlab/show/subobject+classifier">https://ncatlab.org/nlab/show/subobject+classifier</a>)</p>
</blockquote>
<p>This is not true in <code>Type</code>, since as I said monic means <code>injective</code> and epic means <code>surjective</code>, and the conjunction of these is <code>bijective</code> which is not the same as <code>equiv</code> which is isomorphism.</p>

<a name="135755957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135755957" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135755957">Mario Carneiro (Oct 14 2018 at 01:27)</a>:</h4>
<p>Actually unique choice is enough to prove that a bijection is an equiv</p>

<a name="135755959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135755959" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135755959">Mario Carneiro (Oct 14 2018 at 01:27)</a>:</h4>
<p>so you can still get this property without collapsing Prop = bool</p>

<a name="135756014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135756014" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135756014">Mario Carneiro (Oct 14 2018 at 01:29)</a>:</h4>
<blockquote>
<p>Could you explain why couldn't we do something like, take the collection of pairs <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>f</mi><mo>(</mo><mi>a</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">(a, f(a))</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">(</span><span class="mord mathit">a</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> and flip the pairs to get an inverse?</p>
</blockquote>
<p>because that's not how functions are defined in type theory. In type theory every function is given by a term that has a free variable for the argument</p>

<a name="135756017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135756017" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135756017">Mario Carneiro (Oct 14 2018 at 01:29)</a>:</h4>
<p>That is, "functions" and "functional relations" are not the same</p>

<a name="135756071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135756071" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135756071">Mario Carneiro (Oct 14 2018 at 01:30)</a>:</h4>
<p>a definition like that one would give a functional relation, but proving that a functional relation induces a function requires unique choice</p>

<a name="135756084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135756084" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135756084">Mario Carneiro (Oct 14 2018 at 01:31)</a>:</h4>
<p>By the way, this kind of thing comes up even in "real math". For example, the derivative of a function is a functional relation, not a function</p>

<a name="135756136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135756136" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135756136">Mario Carneiro (Oct 14 2018 at 01:32)</a>:</h4>
<p>You can of course use choice to upgrade it to a function but it's not quite natural and lean will make it feel a little awkward</p>

<a name="135756215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135756215" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135756215">Jesse Michael Han (Oct 14 2018 at 01:34)</a>:</h4>
<p>Right, I see.</p>
<blockquote>
<p>Ah, here's another way to show choiceless <code>Type</code> is not a topos:</p>
<blockquote>
<p>Corollary 4.2. <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="bold">C</mi></mrow></mrow><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68611em;"></span><span class="strut bottom" style="height:0.68611em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathbf">C</span></span></span></span></span> is balanced, i.e., a morphism in <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="bold">C</mi></mrow></mrow><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68611em;"></span><span class="strut bottom" style="height:0.68611em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathbf">C</span></span></span></span></span> is an isomorphism iff it is both monic and epic. (<a href="https://ncatlab.org/nlab/show/subobject+classifier" target="_blank" title="https://ncatlab.org/nlab/show/subobject+classifier">https://ncatlab.org/nlab/show/subobject+classifier</a>)</p>
</blockquote>
<p>This is not true in <code>Type</code>, since as I said monic means <code>injective</code> and epic means <code>surjective</code>, and the conjunction of these is <code>bijective</code> which is not the same as <code>equiv</code> which is isomorphism.</p>
</blockquote>
<p>This is what one usually uses to show that the image of a mono is isomorphic to its domain, so that makes sense.</p>

<a name="135756739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135756739" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135756739">David Michael Roberts (Oct 14 2018 at 01:51)</a>:</h4>
<p>Well, that was the informal explanation. The real definition is Def 4.1 in Shulman's <a href="https://arxiv.org/pdf/1808.05204.pdf" target="_blank" title="https://arxiv.org/pdf/1808.05204.pdf">https://arxiv.org/pdf/1808.05204.pdf</a> and is stated in the context of a Heyting category, so no subobject classifier necessary.</p>

<a name="135756798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135756798" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135756798">David Michael Roberts (Oct 14 2018 at 01:52)</a>:</h4>
<p>Also, I wouldn't naively take Prop to be the subobject classifier. What about <code>1 -&gt;  Prop</code>?</p>

<a name="135756815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135756815" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135756815">Mario Carneiro (Oct 14 2018 at 01:54)</a>:</h4>
<p><code>Prop</code> and <code>1 -&gt; Prop</code> are isomorphic</p>

<a name="135756863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135756863" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135756863">David Michael Roberts (Oct 14 2018 at 01:55)</a>:</h4>
<p>Ah, well... :-/</p>

<a name="135756915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135756915" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135756915">David Michael Roberts (Oct 14 2018 at 01:57)</a>:</h4>
<p>Looking at </p>
<blockquote>
<p>Def 4.1 in Shulman's <a href="https://arxiv.org/pdf/1808.05204.pdf" target="_blank" title="https://arxiv.org/pdf/1808.05204.pdf">https://arxiv.org/pdf/1808.05204.pdf</a> </p>
</blockquote>
<p>part a) gives me pause. The other parts b)-d) seem ok (Epis are surjective, "every function 1-&gt; U \cup V factors through U or V" and <code>1-&gt;0</code> is empty).</p>

<a name="135756990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135756990" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135756990">Mario Carneiro (Oct 14 2018 at 01:59)</a>:</h4>
<p>I guess (b) isn't obvious to me, mostly because I'm learning the terminology as I go</p>

<a name="135757108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757108" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135757108">Mario Carneiro (Oct 14 2018 at 02:02)</a>:</h4>
<p>But (a) does indeed look to be false. If <code>m : A -&gt; X</code> is <code>bijective</code>, then for every <code>x : X</code> (add <code>1 -&gt; </code> if you like) there exists <code>y : A</code> such that <code>f x = y</code>, but it is not necessarily an isomorphism</p>

<a name="135757116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757116" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135757116">David Michael Roberts (Oct 14 2018 at 02:03)</a>:</h4>
<p>By Remark 4.2 b) is equiv to epis are surjective, which you proved above.</p>

<a name="135757119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757119" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135757119">Mario Carneiro (Oct 14 2018 at 02:03)</a>:</h4>
<p>But, I think we have to be more careful about what the actual category under discussion is. Is all the metatheory being internalized to Lean?</p>

<a name="135757171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757171" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135757171">Mario Carneiro (Oct 14 2018 at 02:04)</a>:</h4>
<p>That is, if you prove there exists a morphism that may not mean that there is a closed term morphism</p>

<a name="135757172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757172" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135757172">David Michael Roberts (Oct 14 2018 at 02:04)</a>:</h4>
<p>Hmm, not sure. I was vaguely planning on formalising Mike's definitions and seeing what happened.</p>

<a name="135757206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757206" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135757206">Mario Carneiro (Oct 14 2018 at 02:05)</a>:</h4>
<p>I can almost imagine that knowing that every <code>x : 1 -&gt; X </code> splits over <code>m</code> in some strong external sense implying that there is an inverse function</p>

<a name="135757207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757207" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135757207">Mario Carneiro (Oct 14 2018 at 02:05)</a>:</h4>
<p>but that has its own issues</p>

<a name="135757249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757249" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135757249">Mario Carneiro (Oct 14 2018 at 02:06)</a>:</h4>
<p>If you assume choice, then of course you get all these properties</p>

<a name="135757252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757252" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135757252">Reid Barton (Oct 14 2018 at 02:06)</a>:</h4>
<p>I just tuned in and I'm not really sure what is going on here, but in the opposite direction it seems that (c) could fail if you interpreted "either A or B must be ..." in a strong external sense, as well</p>

<a name="135757257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757257" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135757257">David Michael Roberts (Oct 14 2018 at 02:07)</a>:</h4>
<blockquote>
<p>I can almost imagine that knowing that every <code>x : 1 -&gt; X </code> splits over <code>m</code> in some strong external sense implying that there is an inverse function</p>
</blockquote>
<p>ah, that would be quantifying over <code>1-&gt;X</code> I suppose, leading to a section (?). This is the old problem that with the strong constructive quantifier the axiom of choice is simply true.</p>

<a name="135757296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757296" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135757296">Reid Barton (Oct 14 2018 at 02:08)</a>:</h4>
<p>Same with (b) if you interpret the statement as a Pi/Sigma rather than a forall/exists</p>

<a name="135757299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757299" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135757299">David Michael Roberts (Oct 14 2018 at 02:08)</a>:</h4>
<blockquote>
<p>I just tuned in and I'm not really sure what is going on here, but in the opposite direction it seems that (c) could fail if you interpreted "either A or B must be ..." in a strong external sense, as well</p>
</blockquote>
<p>I would imagine it's not meant to be exclusive or.</p>

<a name="135757302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757302" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135757302">Reid Barton (Oct 14 2018 at 02:08)</a>:</h4>
<p>I mean that you could interpret it as a sum type</p>

<a name="135757305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757305" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135757305">Mario Carneiro (Oct 14 2018 at 02:08)</a>:</h4>
<p>it's certainly exclusive or, but that's not the hard part</p>

<a name="135757306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757306" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135757306">David Michael Roberts (Oct 14 2018 at 02:08)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span>  yes, I imagine so.</p>

<a name="135757310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757310" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135757310">Reid Barton (Oct 14 2018 at 02:08)</a>:</h4>
<p>rather than the propositional truncation thereof</p>

<a name="135757320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757320" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135757320">David Michael Roberts (Oct 14 2018 at 02:09)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  but what if A=B as subobjects of X? (here I'm using Remark 4.2 again)</p>

<a name="135757324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757324" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135757324">Reid Barton (Oct 14 2018 at 02:09)</a>:</h4>
<p>I haven't read the preceding part of the paper so I'm not sure whether the metatheory is intended to be classical or what.</p>

<a name="135757404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757404" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135757404">Mario Carneiro (Oct 14 2018 at 02:10)</a>:</h4>
<p>If A = B then <code>1 = A \cup A</code>, and then by pushing the unique element of 1 around you find A = 1 and hence 1 has two distinct elements, which is false</p>

<a name="135757433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757433" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135757433">Mario Carneiro (Oct 14 2018 at 02:11)</a>:</h4>
<p>Actually I'm not even sure why that is an axiom, seems like it should be true in the base theory</p>

<a name="135757503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757503" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135757503">Mario Carneiro (Oct 14 2018 at 02:13)</a>:</h4>
<p>If <code>1 = A \cup B</code> then you get a distinguished element of <code>A \cup B</code>, and by following it you find which one is isomorphic to 1</p>

<a name="135757512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757512" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135757512">Mario Carneiro (Oct 14 2018 at 02:13)</a>:</h4>
<p>then again that relies on elementwise reasoning so it probably isn't true in the base theory</p>

<a name="135757578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757578" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135757578">David Michael Roberts (Oct 14 2018 at 02:14)</a>:</h4>
<p>Fair enough. Gotta run now, though</p>

<a name="135757675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757675" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135757675">Reid Barton (Oct 14 2018 at 02:16)</a>:</h4>
<p>BTW, are you allowing <code>funext</code>?</p>

<a name="135757688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757688" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135757688">Mario Carneiro (Oct 14 2018 at 02:17)</a>:</h4>
<p>I was assuming the other two axioms</p>

<a name="135757704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757704" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135757704">Mario Carneiro (Oct 14 2018 at 02:17)</a>:</h4>
<p>It is true that without quot.sound you have to worry about funext</p>

<a name="135757705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757705" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135757705">Reid Barton (Oct 14 2018 at 02:17)</a>:</h4>
<p>Okay good, otherwise I was confused about some earlier stuff.</p>

<a name="135757754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757754" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135757754">Mario Carneiro (Oct 14 2018 at 02:18)</a>:</h4>
<p>and in that case I'm not sure there is a good theory at all, since the category is all about equalities of morphisms which are functions</p>

<a name="135771585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135771585" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135771585">Kevin Buzzard (Oct 14 2018 at 10:15)</a>:</h4>
<p>I love that #new users has all these questions about how <code>@</code> works etc  and then a huge thread about topos theory :-)</p>

<a name="135772669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135772669" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135772669">David Michael Roberts (Oct 14 2018 at 10:45)</a>:</h4>
<p>Tbh I barely know how <code>@</code> works, too, but I am coming at this top-down, which is probably the wrong way to do it.</p>

<a name="135777652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135777652" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135777652">Kevin Buzzard (Oct 14 2018 at 13:23)</a>:</h4>
<p>I don't think there are right and wrong ways to do it. I think we're still figuring out the best ways to learn and to direct growth of Lean. I think the best way to do it is to try all the ways we can think of.</p>

<a name="135787077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135787077" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html#135787077">Jesse Michael Han (Oct 14 2018 at 17:55)</a>:</h4>
<p>Re: the preceding discussion, I think one again needs unique choice to show (besides ruling out things like uninvertible bijections) that any epimorphism satisfies the universal property with respect to its kernel relation on its domain (i.e. is regular).</p>


{% endraw %}
