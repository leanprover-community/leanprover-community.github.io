---
layout: archive
title: Lean Prover Zulip Chat Archive 
permalink: archive/113489newmembers/31330mathlibconstructivity.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html">mathlib & constructivity</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="134574550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134574550" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134574550">Scott Olson (Sep 25 2018 at 04:57)</a>:</h4>
<p>is there a standard library structure for isomorphisms, like this type in Idris? <a href="https://github.com/idris-lang/Idris-dev/blob/bae730a7ffaeae09a835a35bac132c141f3b50b3/libs/base/Control/Isomorphism.idr#L10-L16" target="_blank" title="https://github.com/idris-lang/Idris-dev/blob/bae730a7ffaeae09a835a35bac132c141f3b50b3/libs/base/Control/Isomorphism.idr#L10-L16">https://github.com/idris-lang/Idris-dev/blob/bae730a7ffaeae09a835a35bac132c141f3b50b3/libs/base/Control/Isomorphism.idr#L10-L16</a></p>
<p>i'm not sure what name to search for</p>

<a name="134574597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134574597" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134574597">Simon Hudon (Sep 25 2018 at 04:58)</a>:</h4>
<p>In mathlib, you may want <code>data.equiv.basic</code></p>

<a name="134574603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134574603" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134574603">Simon Hudon (Sep 25 2018 at 04:58)</a>:</h4>
<p><a href="https://github.com/leanprover/mathlib/blob/master/data/equiv/basic.lean" target="_blank" title="https://github.com/leanprover/mathlib/blob/master/data/equiv/basic.lean">https://github.com/leanprover/mathlib/blob/master/data/equiv/basic.lean</a></p>

<a name="134575168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134575168" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134575168">Scott Olson (Sep 25 2018 at 05:15)</a>:</h4>
<p>thanks, that looks like what i want</p>
<p>that brings me to another question, though... should i be using mathlib, in general? is it basically just expected that most people will be using it?</p>

<a name="134575317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134575317" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134575317">Simon Hudon (Sep 25 2018 at 05:19)</a>:</h4>
<p>Most people use mathlib because it's the largest repository of definitions and theorems in Lean and it keeps growing. Most importantly it has a lot of useful stuff</p>

<a name="134575318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134575318" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134575318">Mario Carneiro (Sep 25 2018 at 05:19)</a>:</h4>
<p>That is certainly the intent... it is like the standard library of most programming languages</p>

<a name="134578662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134578662" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134578662">Scott Olson (Sep 25 2018 at 06:59)</a>:</h4>
<p>is mathlib generally constructive or classical? or at least, does it clearly delimit which things depend on classical axioms? curious if i'll have to "wary" and check with <code>#print axioms</code></p>

<a name="134578810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134578810" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134578810">Simon Hudon (Sep 25 2018 at 07:02)</a>:</h4>
<p>You'll have to be wary. An effort is made to label classical theorems but people still use them pretty loosely</p>

<a name="134578812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134578812" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134578812">Mario Carneiro (Sep 25 2018 at 07:02)</a>:</h4>
<p>mathlib is mostly classical. In particular, we only worry about constructivity in so far as it avoids the <code>noncomputable</code> marking. In any props or theorems we use AC freely</p>

<a name="134578903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134578903" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134578903">Mario Carneiro (Sep 25 2018 at 07:04)</a>:</h4>
<p>There really isn't any point in being "wary" with <code>#print axioms</code>, because all you will achieve by doing that is get yourself in a tizzy about the many unnecessary uses of AC. Suffice it to say it is used in many difficult to avoid places in the foundation, some of which are in lean core and so are not even accessible to mathlib</p>

<a name="134578908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134578908" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134578908">Scott Olson (Sep 25 2018 at 07:04)</a>:</h4>
<p>is there a discussion somewhere on the pros and cons of being classical for something like mathlib or just Props in general?</p>

<a name="134578921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134578921" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134578921">Scott Olson (Sep 25 2018 at 07:05)</a>:</h4>
<p>the mathlib docs i've found so far just don't mention it</p>

<a name="134578929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134578929" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134578929">Mario Carneiro (Sep 25 2018 at 07:05)</a>:</h4>
<p>We've had the discussion off and on for a while. Lean 2 made a concerted effort to be both constructive and classical</p>

<a name="134578977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134578977" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134578977">Mario Carneiro (Sep 25 2018 at 07:06)</a>:</h4>
<p>At the beginning I held out hope that we could avoid AC when unnecessary, but at this point it's clear this isn't going to happen</p>

<a name="134579016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134579016" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134579016">Simon Hudon (Sep 25 2018 at 07:07)</a>:</h4>
<p>I wonder if that's part of why mathlib was able to move quickly too</p>

<a name="134579079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134579079" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134579079">Scott Olson (Sep 25 2018 at 07:08)</a>:</h4>
<p>i don't have much understanding of the implications of using such axioms in a system like Lean. i understand <code>noncomputable</code> prevents even bytecode, but any axioms at all prevent the term from evaluating to a normal form, and i'm curious if that can cause problems in practice</p>

<a name="134579097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134579097" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134579097">Mario Carneiro (Sep 25 2018 at 07:09)</a>:</h4>
<p>We don't evaluate proofs at all in practice</p>

<a name="134579099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134579099" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134579099">Mario Carneiro (Sep 25 2018 at 07:09)</a>:</h4>
<p>it doesn't matter if they are classical or not because they aren't programs</p>

<a name="134579154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134579154" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134579154">Scott Olson (Sep 25 2018 at 07:10)</a>:</h4>
<p>that was my thinking for Prop, but i haven't been able to find much documentation talking about this point</p>

<a name="134579155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134579155" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134579155">Mario Carneiro (Sep 25 2018 at 07:10)</a>:</h4>
<p>The only mechanism we have for evaluating proofs is <code>#reduce</code> and it falls over on all but the most trivial examples</p>

<a name="134579169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134579169" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134579169">Mario Carneiro (Sep 25 2018 at 07:10)</a>:</h4>
<p>I guess there isn't much docs on this</p>

<a name="134579187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134579187" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134579187">Mario Carneiro (Sep 25 2018 at 07:11)</a>:</h4>
<p>The VM evaluates anything that is not a Prop and is not <code>noncomputable</code></p>

<a name="134579193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134579193" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134579193">Simon Hudon (Sep 25 2018 at 07:11)</a>:</h4>
<p>When computation is involved, you really need to look at defs that are in <code>Type 0</code> and over. Then an effort is often made to be efficient</p>

<a name="134579239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134579239" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134579239">Scott Olson (Sep 25 2018 at 07:13)</a>:</h4>
<p>that makes sense, thanks for all the responses</p>

<a name="134579246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134579246" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134579246">Simon Hudon (Sep 25 2018 at 07:13)</a>:</h4>
<p><span class="emoji emoji-1f44d" title="+1">:+1:</span></p>

<a name="134579260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134579260" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134579260">Scott Olson (Sep 25 2018 at 07:14)</a>:</h4>
<p>i realized while talking to a friend just now that an interesting argument in favor of using fewer axioms is that it makes the proof potentially more "portable" to different formalisms, but that's somewhat aspirational and lacking it doesn't block anything in mathlib in the meantime</p>

<a name="134579308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134579308" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134579308">Mario Carneiro (Sep 25 2018 at 07:14)</a>:</h4>
<p>Unfortunately, the axioms that really prevent portability of lean proofs aren't turn-off-able</p>

<a name="134579319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134579319" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134579319">Mario Carneiro (Sep 25 2018 at 07:15)</a>:</h4>
<p>Most systems have some equivalent of the axiom of choice, but few have inductive types and a hierarchy of universes</p>

<a name="134579850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134579850" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134579850">Kevin Buzzard (Sep 25 2018 at 07:27)</a>:</h4>
<blockquote>
<p>i realized while talking to a friend just now that an interesting argument in favor of using fewer axioms is that it makes the proof potentially more "portable" to different formalisms, but that's somewhat aspirational and lacking it doesn't block anything in mathlib in the meantime</p>
</blockquote>
<p>I'm a pure mathematician (as are several other people here) and one of the things that attracted me to Lean is precisely the attitude that "we will do maths like regular pure mathematicians do" (i.e. assume things like the axiom of choice, which in my circles is regarded as "just another axiom, with no particular reason to fuss about it".)</p>

<a name="134579993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134579993" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134579993">Sean Leather (Sep 25 2018 at 07:30)</a>:</h4>
<blockquote>
<p>I'm a pure mathematician (as are several other people here) and one of the things that attracted me to Lean is precisely the attitude that "we will do maths like regular pure mathematicians do" (i.e. assume things like the axiom of choice, which in my circles is regarded as "just another axiom, with no particular reason to fuss about it".)</p>
</blockquote>
<p>On the other hand, some of the things that attracted me to Lean included the ability to do constructive mathematics, the nice syntax, a fast theorem prover, and a comprehensive library. <span class="emoji emoji-1f642" title="slight smile">:slight_smile:</span></p>

<a name="134580185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134580185" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134580185">Scott Olson (Sep 25 2018 at 07:36)</a>:</h4>
<p>i figured some of what i said might have given away my friend's and my bias towards constructive type theories :P</p>
<p>i can see why Lean attracted pure mathematicians who might have otherwise used Coq or similar, though. the experience out of the box with Lean in VSCode is the best i've seen from any theorem prover</p>

<a name="134580336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134580336" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134580336">Mario Carneiro (Sep 25 2018 at 07:41)</a>:</h4>
<p>I am also attracted to constructive mathematics generally, but the pure mathematicians have worn me down. :) I realize now that lean is not remotely geared towards limiting its axiom strength, and if you want a system for playing with axioms you should look elsewhere. "Having few axioms" only means having few interesting subsystems, and none of the available subsystems are recognizable to traditional mathematicians except possibly intuitionistic type theory</p>

<a name="134580385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134580385" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134580385">Simon Hudon (Sep 25 2018 at 07:42)</a>:</h4>
<p><span class="user-mention" data-user-id="110045">@Sean Leather</span> how inconvenient is it for you that mathlib makes such liberal use of classical axioms?</p>

<a name="134580400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134580400" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134580400">Mario Carneiro (Sep 25 2018 at 07:42)</a>:</h4>
<p>Instead, it seems much more likely that lean will be able to support doing logic at the meta level, which is something that few systems can currently do well. This approach is much more flexible, of course, with regards to its axioms and with the permissible methods of proof</p>

<a name="134580402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134580402" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134580402">Sean Leather (Sep 25 2018 at 07:42)</a>:</h4>
<p>I haven't had any issues so far. I'm not even sure where I would run into any.</p>

<a name="134580417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134580417" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134580417">Scott Olson (Sep 25 2018 at 07:43)</a>:</h4>
<p>i figure i'll just adjust my expectations of what exactly i will play with in lean, but it will still be suitable for a lot of the stuff i want to experiment with</p>

<a name="134580423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134580423" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134580423">Sean Leather (Sep 25 2018 at 07:43)</a>:</h4>
<p>The only thing is this output:</p>
<div class="codehilite"><pre><span></span><span class="bp">#</span><span class="kn">print</span> <span class="n">axioms</span>
</pre></div>


<div class="codehilite"><pre><span></span><span class="n">quot</span><span class="bp">.</span><span class="n">sound</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">},</span> <span class="n">r</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">quot</span><span class="bp">.</span><span class="n">mk</span> <span class="n">r</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">quot</span><span class="bp">.</span><span class="n">mk</span> <span class="n">r</span> <span class="n">b</span>
<span class="n">classical</span><span class="bp">.</span><span class="n">choice</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">},</span> <span class="n">nonempty</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span>
<span class="n">propext</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">},</span> <span class="o">(</span><span class="n">a</span> <span class="bp">↔</span> <span class="n">b</span><span class="o">)</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span>
</pre></div>

<a name="134580424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134580424" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134580424">Simon Hudon (Sep 25 2018 at 07:43)</a>:</h4>
<p>Is your requirement that functions be computable or actually to avoid the axioms?</p>

<a name="134580482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134580482" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134580482">Sean Leather (Sep 25 2018 at 07:44)</a>:</h4>
<p>Computable, I suppose. I don't do anything actively to avoid axioms, but I don't think I use anything that does use the axiom of choice.</p>

<a name="134580506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134580506" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134580506">Scott Olson (Sep 25 2018 at 07:45)</a>:</h4>
<p><code>#print axioms &lt;name&gt;</code> will list the axioms used (transitively) for the given thing</p>

<a name="134580515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134580515" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134580515">Scott Olson (Sep 25 2018 at 07:45)</a>:</h4>
<p>but as we discussed, this shouldn't be a problem in the bodies of proofs that will never need to be evaluated or examined by other proofs</p>

<a name="134580569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134580569" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134580569">Sean Leather (Sep 25 2018 at 07:46)</a>:</h4>
<blockquote>
<p><code>#print axioms &lt;name&gt;</code> will list the axioms used (transitively) for the given thing</p>
</blockquote>
<p>When I create an empty file, <code>#print axioms</code> shows what I wrote above. <span class="emoji emoji-263a" title="smile">:smile:</span></p>

<a name="134580583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134580583" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134580583">Scott Olson (Sep 25 2018 at 07:47)</a>:</h4>
<p>yeah, <code>#print axioms</code> just prints the axioms that are currently in scope</p>

<a name="134580592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134580592" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134580592">Mario Carneiro (Sep 25 2018 at 07:47)</a>:</h4>
<p>Can anyone come up with a reasonable (not completely contrived) example of a computable function that uses AC/LEM in its definition?</p>

<a name="134580884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134580884" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134580884">Mario Carneiro (Sep 25 2018 at 07:55)</a>:</h4>
<p>I will amend "not completely contrived" to not eliminable, in the sense that there isn't a way to write the same function without the axiom, or at least it's not easy to do so</p>

<a name="134580946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134580946" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134580946">Kevin Buzzard (Sep 25 2018 at 07:56)</a>:</h4>
<p>on nat?</p>

<a name="134580963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134580963" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134580963">Mario Carneiro (Sep 25 2018 at 07:57)</a>:</h4>
<p>sure, I doubt it makes a difference but <code>nat -&gt; nat</code> is a fine target</p>

<a name="134580976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134580976" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134580976">Kevin Buzzard (Sep 25 2018 at 07:57)</a>:</h4>
<p>I'm sure you're right but I'm such a noob at this sort of thing. A year ago I wouldn't even have been able to formalise the question rigorously.</p>

<a name="134581031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134581031" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134581031">Mario Carneiro (Sep 25 2018 at 07:58)</a>:</h4>
<p>To give a hint on why it's even possible: <code>nat.find</code> will calculate the smallest value satisfying a predicate, given only a proof that there is such a value (in Prop). This proof can rely on any axioms, and the function will still be computable</p>

<a name="134581033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134581033" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134581033">Kevin Buzzard (Sep 25 2018 at 07:58)</a>:</h4>
<p>What about f(n)=1 if Fermat's Last Theorem is true and 0 otherwise? It's completely contrived but I'm trying to get the hang of the question. All known proofs of FLT use AC.</p>

<a name="134581117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134581117" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134581117">Mario Carneiro (Sep 25 2018 at 08:00)</a>:</h4>
<p>That won't work because <code>f</code> is just the constant function <code>1</code>, it doesn't need any axioms for its definition</p>

<a name="134581166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134581166" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134581166">Mario Carneiro (Sep 25 2018 at 08:01)</a>:</h4>
<p>But I think you are on the right track. Can you think of any forall exists theorem on nat that relies on AC?</p>

<a name="134581211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134581211" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134581211">Simon Hudon (Sep 25 2018 at 08:02)</a>:</h4>
<p>I don't know how to formalize that statement but it seems like a computable function like you described cannot be constructed</p>

<a name="134581378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134581378" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134581378">Mario Carneiro (Sep 25 2018 at 08:07)</a>:</h4>
<p>Here is an example that relies on the input being in a nonoptimal form: if the input is a function <code>f : nat -&gt; nat</code> which is not the constant zero function, then you can computably find a nonzero <code>nat</code> in the range of <code>f</code></p>

<a name="134581503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134581503" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134581503">Simon Hudon (Sep 25 2018 at 08:10)</a>:</h4>
<p>That's true. I stand corrected</p>

<a name="134581579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134581579" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134581579">Kevin Buzzard (Sep 25 2018 at 08:12)</a>:</h4>
<blockquote>
<p>What about f(n)=1 if Fermat's Last Theorem is true and 0 otherwise? It's completely contrived but I'm trying to get the hang of the question. All known proofs of FLT use AC.</p>
</blockquote>
<p>So by "computable" you mean "externally provable to be equal to a certain given fixed computable function", rather than "provable in Lean with/without AC to be equal to a certain given fixed computable function"</p>

<a name="134581594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134581594" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134581594">Kevin Buzzard (Sep 25 2018 at 08:13)</a>:</h4>
<p>What about f(n)=1 if RH is true and 0 otherwise? Don't I need LEM to define this?</p>

<a name="134581599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134581599" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134581599">Kevin Buzzard (Sep 25 2018 at 08:13)</a>:</h4>
<p>I'm still struggling to move away from the "contrived" part, as you can see ;-)</p>

<a name="134581758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134581758" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134581758">Mario Carneiro (Sep 25 2018 at 08:17)</a>:</h4>
<p>If you pick something which is definitely not decidable, or not known to be decidable like RH, then the function won't be computable either. By "computable" I mean "passes lean's <code>noncomputable</code> check"; you can't write <code>def f := if RH then 1 else 0</code> because <code>RH</code> is not decidable</p>

<a name="134581831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134581831" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134581831">Scott Olson (Sep 25 2018 at 08:18)</a>:</h4>
<p>yeah, that would specifically require the classical instance for <code>decidable</code> that uses LEM internally, which is <code>noncomputable</code>, which forces <code>f</code> to be <code>noncomputable</code></p>

<a name="134581840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134581840" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134581840">Kevin Buzzard (Sep 25 2018 at 08:18)</a>:</h4>
<p>Here is something much less contrived but I am much less clear about whether it fits into the scope of this question. Let's say a pure mathematician proves that for every g&gt;=2 there is a computable upper bound <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mo>(</mo><mi>g</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">B(g)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mclose">)</span></span></span></span> for the number of rational points on a smooth projective curve of genus g over the rationals, and their proof uses a bunch of algebraic geometry and AC / LEM everywhere. I suspect I could find arithmetic geometers who were prepared to conjecture that this mathematical statement was true. If this result got proved, and it turned out that a deep theorem implied that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mo>(</mo><mi>g</mi><mo>)</mo><mo>=</mo><mn>1</mn><mn>0</mn><mn>0</mn><mn>0</mn><mn>0</mn><mo>∗</mo><mi>g</mi></mrow><annotation encoding="application/x-tex">B(g)=10000*g</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span><span class="mbin">∗</span><span class="mord mathit" style="margin-right:0.03588em;">g</span></span></span></span>, this would <em>not</em> be an example, right? :-/</p>

<a name="134581848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134581848" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134581848">Mario Carneiro (Sep 25 2018 at 08:19)</a>:</h4>
<p>You can write <code>def f := if FLT then 1 else 0</code> only if you have already provided a computable proof of <code>decidable FLT</code>, which will involve a proof of FLT. This falls afoul of the second restriction because then you could just replace the definition of <code>f</code> with <code>1</code></p>

<a name="134581943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134581943" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134581943">Mario Carneiro (Sep 25 2018 at 08:20)</a>:</h4>
<p>You are right, this is an interesting situation. If we know a bound on the function then we can skip the clever maths and just use the bound</p>

<a name="134581957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134581957" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134581957">Mario Carneiro (Sep 25 2018 at 08:21)</a>:</h4>
<p>Somehow it has to be an existence theorem with no bound</p>

<a name="134582212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134582212" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134582212">Edward Ayers (Sep 25 2018 at 08:26)</a>:</h4>
<p>How about <code>f(n)</code> is 1 if the nth turing machine halts and 0 otherwise? If I'm not mistaken the proof that <code>f</code> is total requires LEM.</p>

<a name="134582251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134582251" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134582251">Mario Carneiro (Sep 25 2018 at 08:27)</a>:</h4>
<p>I have been thinking about examples like that, but again it needs to be computable</p>

<a name="134582254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134582254" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134582254">Edward Ayers (Sep 25 2018 at 08:27)</a>:</h4>
<p>But that might be because I've never seen a constructive proof of halting problem</p>

<a name="134582319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134582319" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134582319">Mario Carneiro (Sep 25 2018 at 08:28)</a>:</h4>
<p>To define that function you have to know whether the nth turing machine halts</p>

<a name="134582433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134582433" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134582433">Edward Ayers (Sep 25 2018 at 08:30)</a>:</h4>
<p>Ah in that case I think that it's impossible.</p>

<a name="134582569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134582569" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134582569">Edward Ayers (Sep 25 2018 at 08:33)</a>:</h4>
<p>As in you can always rewrite the function to not use AC</p>

<a name="134582624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134582624" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134582624">Mario Carneiro (Sep 25 2018 at 08:34)</a>:</h4>
<p>Here's another way to put it: Find computable predicates <code>p(n), q(m,n)</code> such that if <code>p(n)</code> is true then there exists an <code>m</code> such that <code>q(m,n)</code>, but there is no computable upper bound on the least satisfying instance</p>

<a name="134582743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134582743" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134582743">Scott Olson (Sep 25 2018 at 08:37)</a>:</h4>
<p>so with <code>nat.find</code> we could find the least <code>nat</code> satisfying some predicate while only proving this search will actually terminate with, for example, a proof by contradiction (the kind that requires classical double negation elimination)?</p>

<a name="134582749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134582749" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134582749">Edward Ayers (Sep 25 2018 at 08:37)</a>:</h4>
<p>I can just run the <code>q</code> machine on each value of <code>m = 0,1,2,...</code> in turn. Since there exists an <code>m</code> where <code>q(m,n)</code> works, that program will halt. Right?</p>

<a name="134582818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134582818" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134582818">Mario Carneiro (Sep 25 2018 at 08:38)</a>:</h4>
<p>yes, that's the idea</p>

<a name="134582819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134582819" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134582819">Edward Ayers (Sep 25 2018 at 08:38)</a>:</h4>
<p>So it's impossible (to find such computable predicates)</p>

<a name="134582821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134582821" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134582821">Mario Carneiro (Sep 25 2018 at 08:38)</a>:</h4>
<p>that's the computable function</p>

<a name="134582980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134582980" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134582980">Mario Carneiro (Sep 25 2018 at 08:42)</a>:</h4>
<p>hm, you may be right. The very constraint that makes it lean-computable will also produce a computable upper bound, namely this function</p>

<a name="134583041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134583041" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134583041">Mario Carneiro (Sep 25 2018 at 08:44)</a>:</h4>
<p>but I think maybe "computable upper bound" isn't what I want either; it needs to be an upper bound that you can't prove using lean without AC</p>

<a name="134583046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134583046" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134583046">Mario Carneiro (Sep 25 2018 at 08:44)</a>:</h4>
<p>you can't use this function as a proof because it requires a proof that it will halt to run</p>

<a name="134583092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134583092" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134583092">Mario Carneiro (Sep 25 2018 at 08:46)</a>:</h4>
<p>If we use something weaker than DTT, it should be possible to use some Ackermann-like function here</p>

<a name="134583167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134583167" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134583167">Edward Ayers (Sep 25 2018 at 08:47)</a>:</h4>
<p>Ok I think I see what you mean now. You want a pair <code>p(n), q(m,n)</code> where the existence of  a satisfying <code>m</code>is proved using AC or LEM.</p>

<a name="134583218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134583218" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134583218">Mario Carneiro (Sep 25 2018 at 08:48)</a>:</h4>
<p>exactly</p>

<a name="134583321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134583321" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134583321">Johan Commelin (Sep 25 2018 at 08:51)</a>:</h4>
<p>Can you prove that such a function exists using AC?</p>

<a name="134583382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134583382" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134583382">Mario Carneiro (Sep 25 2018 at 08:52)</a>:</h4>
<p>You can use whatever methods you like to prove the existence of such p and q, but they have to be computable functions</p>

<a name="134583448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134583448" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134583448">Johan Commelin (Sep 25 2018 at 08:54)</a>:</h4>
<p>Ok, I should have put more emphasis on <em>you</em> in my last post (-;</p>

<a name="134583453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134583453" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134583453">Johan Commelin (Sep 25 2018 at 08:54)</a>:</h4>
<p>I have no clue at all about all this computability stuff.</p>

<a name="134583461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134583461" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134583461">Mario Carneiro (Sep 25 2018 at 08:55)</a>:</h4>
<p>I don't have a solution to this puzzle</p>

<a name="134583474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134583474" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134583474">Mario Carneiro (Sep 25 2018 at 08:55)</a>:</h4>
<p>but I believe it is possible</p>

<a name="134583532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134583532" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134583532">Edward Ayers (Sep 25 2018 at 08:56)</a>:</h4>
<p>I am still not satisfied that the question is well posed. If I found a <code>p</code> and <code>q</code> with that property. I could take the AC proof, throw it away and replace it with a machine that just tries all <code>m</code>. Eventually it would find the <code>m</code> (which I know but Lean doesn't) and Lean would use that. But then I guess my new program would have to run in unsafe mode.</p>

<a name="134583545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134583545" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134583545">Mario Carneiro (Sep 25 2018 at 08:57)</a>:</h4>
<p>For a fixed <code>n</code> you can do that, but I don't think you can do that for all <code>n</code></p>

<a name="134583553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134583553" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134583553">Mario Carneiro (Sep 25 2018 at 08:57)</a>:</h4>
<p>i.e. if <code>p(5)</code> is true and it turns out that <code>q(100,5)</code> is the satisfying instance, then you can use an upper bound of 100 in the construction</p>

<a name="134583554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134583554" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134583554">Johan Commelin (Sep 25 2018 at 08:57)</a>:</h4>
<p>Mario, do you want a proof that can only prove the upper bound under the assumption of LEM/AC?</p>

<a name="134583555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134583555" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134583555">Mario Carneiro (Sep 25 2018 at 08:57)</a>:</h4>
<p>right</p>

<a name="134583557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134583557" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134583557">Johan Commelin (Sep 25 2018 at 08:58)</a>:</h4>
<p>Or is it enough that we know no such proof.</p>

<a name="134583599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134583599" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134583599">Mario Carneiro (Sep 25 2018 at 08:58)</a>:</h4>
<p>Even that would be nice</p>

<a name="134583615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134583615" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134583615">Mario Carneiro (Sep 25 2018 at 08:58)</a>:</h4>
<p>I'm worried that since no axioms lean has the same consistency strength as lean + AC, it will not be able to prove any new turing machines halt</p>

<a name="134583617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134583617" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134583617">Johan Commelin (Sep 25 2018 at 08:59)</a>:</h4>
<p>So, there are only finitely many abelian varieties of dimension <code>g</code> over <code>rat</code> with good reduction outside <code>{favourite finite list of primes}</code>.</p>

<a name="134583631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134583631" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134583631">Johan Commelin (Sep 25 2018 at 08:59)</a>:</h4>
<p>I don't think we know any upper bounds on this. The proof is a celebrated theorem of Faltings and uses classical maths all over the place.</p>

<a name="134583668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134583668" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134583668">Johan Commelin (Sep 25 2018 at 09:00)</a>:</h4>
<p>If your favourite finite list of primes is not empty, then this function is extremely hard to compute.</p>

<a name="134583691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134583691" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134583691">Johan Commelin (Sep 25 2018 at 09:00)</a>:</h4>
<p>(Otherwise it is <code>if g = 0 then 1 else 0</code>.)</p>

<a name="134583717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134583717" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134583717">Johan Commelin (Sep 25 2018 at 09:01)</a>:</h4>
<p>Does this mean that <code>f g = card (abelian varieties of dim g with good reduction outside blah)</code> is not computable?</p>

<a name="134583767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134583767" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134583767">Johan Commelin (Sep 25 2018 at 09:02)</a>:</h4>
<p>Hmmm.... I'm too much of a newbie when it comes to such questions.</p>

<a name="134583893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134583893" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134583893">Mario Carneiro (Sep 25 2018 at 09:05)</a>:</h4>
<p>hm, this theorem has AEA quantifier complexity, which is a bit hard to use</p>

<a name="134583936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134583936" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134583936">Johan Commelin (Sep 25 2018 at 09:06)</a>:</h4>
<p>AEA?</p>

<a name="134583941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134583941" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134583941">Johan Commelin (Sep 25 2018 at 09:06)</a>:</h4>
<p><code>\forall \exists \forall</code>?</p>

<a name="134583954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134583954" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134583954">Mario Carneiro (Sep 25 2018 at 09:06)</a>:</h4>
<p>"for all g, there exists an n such that all variety things don't have good reduction above n"</p>

<a name="134583971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134583971" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134583971">Johan Commelin (Sep 25 2018 at 09:07)</a>:</h4>
<p>No, I don't think that's what it says.</p>

<a name="134583978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134583978" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134583978">Mario Carneiro (Sep 25 2018 at 09:07)</a>:</h4>
<p>I assume there is a way to enumerate abelian varieties?</p>

<a name="134584022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134584022" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134584022">Mario Carneiro (Sep 25 2018 at 09:08)</a>:</h4>
<p>and the theorem says this enumeration runs dry after a certain point</p>

<a name="134584026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134584026" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134584026">Johan Commelin (Sep 25 2018 at 09:08)</a>:</h4>
<p>For all <code>P : finset primes</code> and for all <code>g</code> there exists <code>n</code> such that <code>card { abvar of dim g and good reduction outside P }</code> is less than <code>n</code>.</p>

<a name="134584031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134584031" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134584031">Johan Commelin (Sep 25 2018 at 09:09)</a>:</h4>
<p>Well, an abelian variety is defined by a finite number of polynomials</p>

<a name="134584040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134584040" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134584040">Mario Carneiro (Sep 25 2018 at 09:09)</a>:</h4>
<p>right, so we enumerate all such things</p>

<a name="134584042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134584042" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134584042">Mario Carneiro (Sep 25 2018 at 09:09)</a>:</h4>
<p>and only a finite number of them will have good reduction</p>

<a name="134584046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134584046" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134584046">Johan Commelin (Sep 25 2018 at 09:09)</a>:</h4>
<p>Right (the polys are over Q), so we could do that.</p>

<a name="134584054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134584054" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134584054">Mario Carneiro (Sep 25 2018 at 09:09)</a>:</h4>
<p>so there is an upper bound on the last one with good reduction</p>

<a name="134584057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134584057" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134584057">Mario Carneiro (Sep 25 2018 at 09:09)</a>:</h4>
<p>thus AEA</p>

<a name="134584061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134584061" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134584061">Johan Commelin (Sep 25 2018 at 09:09)</a>:</h4>
<p>Right, but testing the good reduction has to happen at all primes outside <code>P</code></p>

<a name="134584107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134584107" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134584107">Johan Commelin (Sep 25 2018 at 09:10)</a>:</h4>
<p>So you can't enumerate that.</p>

<a name="134584120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134584120" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134584120">Mario Carneiro (Sep 25 2018 at 09:10)</a>:</h4>
<p>oh, I see</p>

<a name="134584123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134584123" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134584123">Johan Commelin (Sep 25 2018 at 09:10)</a>:</h4>
<p>But I guess you can compute some discriminant in terms of the polynomials</p>

<a name="134584125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134584125" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134584125">Mario Carneiro (Sep 25 2018 at 09:10)</a>:</h4>
<p>the property of having good reduction depends on all p?</p>

<a name="134584132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134584132" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134584132">Johan Commelin (Sep 25 2018 at 09:10)</a>:</h4>
<p>and then bad reduction at <code>p</code> implies that <code>p</code> divides the discriminant.</p>

<a name="134584139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134584139" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134584139">Johan Commelin (Sep 25 2018 at 09:11)</a>:</h4>
<p>This works for elliptic curves (the case <code>g = 1</code>)</p>

<a name="134584145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134584145" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134584145">Mario Carneiro (Sep 25 2018 at 09:11)</a>:</h4>
<p>then it is AEAE</p>

<a name="134584146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134584146" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134584146">Johan Commelin (Sep 25 2018 at 09:11)</a>:</h4>
<p>Lol</p>

<a name="134584154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134584154" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134584154">Mario Carneiro (Sep 25 2018 at 09:11)</a>:</h4>
<p>for all g/P, there exists n, such that for all abvars above n, there is a p such that the var has bad reduction at p</p>

<a name="134584195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134584195" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134584195">Johan Commelin (Sep 25 2018 at 09:12)</a>:</h4>
<p>No, it isn't about abvars above <code>n</code>, I think.</p>

<a name="134584196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134584196" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134584196">Johan Commelin (Sep 25 2018 at 09:12)</a>:</h4>
<p>At least I can't parse that.</p>

<a name="134584200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134584200" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134584200">Johan Commelin (Sep 25 2018 at 09:12)</a>:</h4>
<p>Ooh, wait, you enumerated them</p>

<a name="134584204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134584204" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134584204">Mario Carneiro (Sep 25 2018 at 09:12)</a>:</h4>
<p>that is to exclude the finite number of things with good reduction</p>

<a name="134584212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134584212" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134584212">Johan Commelin (Sep 25 2018 at 09:13)</a>:</h4>
<p>Hmmm.... but we still need a decision procedure to determine if a bunch of polynomials defines an AV</p>

<a name="134584213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134584213" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134584213">Mario Carneiro (Sep 25 2018 at 09:13)</a>:</h4>
<p>that's surely decidable</p>

<a name="134584220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134584220" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134584220">Johan Commelin (Sep 25 2018 at 09:13)</a>:</h4>
<p>Ok, if you say so... I have no idea how to do that...</p>

<a name="134584232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134584232" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134584232">Mario Carneiro (Sep 25 2018 at 09:13)</a>:</h4>
<p>I have no idea what an AV is, so there</p>

<a name="134584277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134584277" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134584277">Mario Carneiro (Sep 25 2018 at 09:14)</a>:</h4>
<p>but it surely can't be more than AE complexity</p>

<a name="134584296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134584296" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134584296">Johan Commelin (Sep 25 2018 at 09:14)</a>:</h4>
<p>It means that there exists a group structure on the solution set defined by the polynomials, and the solution set must be compact (in the algebro-geometric sense of compact)</p>

<a name="134584330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134584330" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134584330">Johan Commelin (Sep 25 2018 at 09:15)</a>:</h4>
<p>Both seem hard to check at first sight.</p>

<a name="134584389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134584389" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134584389">Edward Ayers (Sep 25 2018 at 09:16)</a>:</h4>
<blockquote>
<p>For a fixed <code>n</code> you can do that, but I don't think you can do that for all <code>n</code></p>
</blockquote>
<p>Is this argument on the right lines?<br>
If <code>p</code> and <code>q</code> are computable and we know that  for all <code>n</code>, if <code>p(n)</code> then there exists a <code>m</code> such that <code>q(m,n)</code>. Then there exists a computable function <code>n -&gt; m</code> using AC. So I can find the code which runs that function, and put that in Lean. So <code>n</code> doesn't have to be fixed.</p>

<a name="134584411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134584411" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134584411">Mario Carneiro (Sep 25 2018 at 09:17)</a>:</h4>
<p>but the code that runs that function uses AC</p>

<a name="134584419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134584419" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134584419">Mario Carneiro (Sep 25 2018 at 09:17)</a>:</h4>
<p>oh you mean the code of a computable function</p>

<a name="134584420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134584420" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134584420">Edward Ayers (Sep 25 2018 at 09:17)</a>:</h4>
<p>Right but I can find the code outside Lean and just put the code in</p>

<a name="134584427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134584427" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134584427">Mario Carneiro (Sep 25 2018 at 09:17)</a>:</h4>
<p>but then you need to know it codes a (total) computable function</p>

<a name="134584429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134584429" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134584429">Mario Carneiro (Sep 25 2018 at 09:17)</a>:</h4>
<p>and the proof of that uses AC</p>

<a name="134584479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134584479" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134584479">Mario Carneiro (Sep 25 2018 at 09:18)</a>:</h4>
<p>lean won't just let you run whatever function you like</p>

<a name="134584498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134584498" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134584498">Edward Ayers (Sep 25 2018 at 09:19)</a>:</h4>
<p>I can run the n-&gt;m in unsafe mode because it's not part of the proof. I just need to get the <code>m</code></p>

<a name="134584554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134584554" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134584554">Mario Carneiro (Sep 25 2018 at 09:20)</a>:</h4>
<p>the idea with this reduction is to build a computable function in no axioms lean, right? You can't run in unsafe mode since then you don't have a well defined term</p>

<a name="134584582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134584582" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134584582">Mario Carneiro (Sep 25 2018 at 09:21)</a>:</h4>
<p>i.e. the <code>m</code> that you pick depends on <code>n</code>, so there is no closed term you can give for the function without unsafe lean stepping in to provide the <code>m</code></p>

<a name="134618450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134618450" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134618450">Jared Corduan (Sep 25 2018 at 18:44)</a>:</h4>
<p>how about this:<br>
let <code>A(n)</code> be some computable predicate that requires either <code>AC</code> or <code>LEM</code> to show that either <code>{n | A(n)}</code> or <code>{n | ~A(n)}</code>is infinite.  (in other words, <code>A</code> witnesses the nonconstructive nature of the infinite pigeon hole principle).</p>
<p>then let <code>q1(m, n)</code> be the statement that there is an <code>n &lt; x &lt; m</code> such that <code>A(x)</code> holds. and similarly define <code>q2(m, n)</code> with <code>~A(x)</code>.  both of these are computable since <code>A</code> is computable.  since either <code>{n | A(n)}</code> or <code>{n | ~A(n)}</code>is infinite, then for at least one of <code>q1</code> or <code>q2</code>we can show the existence of such an <code>m</code> for any given <code>n</code>.  but we need <code>AC</code> or <code>LEM</code> for the existence of the <code>m</code>s.</p>

<a name="134618503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134618503" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134618503">Kenny Lau (Sep 25 2018 at 18:45)</a>:</h4>
<p>is there a tl;dr for this thread?</p>

<a name="134618569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134618569" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134618569">Patrick Massot (Sep 25 2018 at 18:46)</a>:</h4>
<p>Do you really want me to write it?</p>

<a name="134618618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134618618" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134618618">Kenny Lau (Sep 25 2018 at 18:46)</a>:</h4>
<p>well this thread is way too long, a tl;dr would be good, I don't see why not</p>

<a name="134618657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134618657" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134618657">Patrick Massot (Sep 25 2018 at 18:47)</a>:</h4>
<p>Ok, let me try: constructivity questions are pointless.</p>

<a name="134618804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134618804" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134618804">Kenny Lau (Sep 25 2018 at 18:49)</a>:</h4>
<p>I don't think that's a very faithful summary, nor is it contributing to the discussion at hand</p>

<a name="134618832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134618832" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134618832">Patrick Massot (Sep 25 2018 at 18:50)</a>:</h4>
<p>I'm sorry, but you explicitly asked for it!</p>

<a name="134618922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134618922" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134618922">Patrick Massot (Sep 25 2018 at 18:50)</a>:</h4>
<p>Anyway, I should work instead of trolling</p>

<a name="134618948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134618948" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134618948">Mario Carneiro (Sep 25 2018 at 18:51)</a>:</h4>
<p>I don't think that works, although it's so close I can taste it. What is the computable function that we are defining?</p>

<a name="134619027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134619027" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134619027">Mario Carneiro (Sep 25 2018 at 18:52)</a>:</h4>
<p>(Kenny, the gist is I posed a puzzle <a href="#narrow/stream/113489-new-members/subject/mathlib.20.26.20constructivity/near/134580592" title="#narrow/stream/113489-new-members/subject/mathlib.20.26.20constructivity/near/134580592">here</a> and people are trying to solve it.)</p>

<a name="134619086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134619086" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134619086">Jared Corduan (Sep 25 2018 at 18:53)</a>:</h4>
<p>well, it's one of two functions.  either 1) it is <code>f(n)</code> is the least <code>m&gt;n</code>such that <code>A(n)</code> or 2) it is <code>f(n)</code> is the least <code>m&gt;n</code>such that <code>~A(n)</code>.</p>

<a name="134619105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134619105" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134619105">Jared Corduan (Sep 25 2018 at 18:53)</a>:</h4>
<p>but I punted on giving you an actual <code>A</code>...</p>

<a name="134619126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134619126" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134619126">Mario Carneiro (Sep 25 2018 at 18:53)</a>:</h4>
<p>But we can't define either of those functions unless we have a proof (possibly using AC) that A(n) is infinite (resp. co-infinite)</p>

<a name="134619199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134619199" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134619199">Jared Corduan (Sep 25 2018 at 18:54)</a>:</h4>
<p>you can prove the infinite pigeon hole with <code>AC</code> and <code>LEM</code>, so all I'm missing is a good <code>A</code>, right?</p>

<a name="134619312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134619312" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134619312">Mario Carneiro (Sep 25 2018 at 18:56)</a>:</h4>
<p>right, but if we assume <code>A</code> is something about which we can prove very little, then we can't prove <code>A(n)</code> is infinite, so 1) can't be defined, and we can't prove <code>~A(n)</code> is infinite either, so 2) can't be defined</p>

<a name="134619345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134619345" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134619345">Chris Hughes (Sep 25 2018 at 18:56)</a>:</h4>
<p>What's the constructive proof that there exists a natural such that a^n=1 in a finite group?</p>

<a name="134619367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134619367" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134619367">Mario Carneiro (Sep 25 2018 at 18:57)</a>:</h4>
<p>If it is finite, then there is an upper bound on the cardinality, enumerate them all and test for equality</p>

<a name="134619409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134619409" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134619409">Mario Carneiro (Sep 25 2018 at 18:57)</a>:</h4>
<p>(you need decidable equality)</p>

<a name="134619454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134619454" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134619454">Jared Corduan (Sep 25 2018 at 18:58)</a>:</h4>
<p>ok, I might have misunderstood the problem!  I thought we wanted an <code>f</code> that needed <code>AC</code> and/or <code>LEM</code> in order to be defined, though it was built from these computable predicates.</p>

<a name="134619495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134619495" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134619495">Mario Carneiro (Sep 25 2018 at 18:59)</a>:</h4>
<p>That is what we want, but it also needs to be a term that represents a lean-computable function</p>

<a name="134619527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134619527" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134619527">Mario Carneiro (Sep 25 2018 at 18:59)</a>:</h4>
<p>It is okay if the proof of existence of the term is nonconstructive, like you tried, but the term itself must contain a proof that it halts since lean expects as much</p>

<a name="134619598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134619598" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134619598">Jared Corduan (Sep 25 2018 at 19:00)</a>:</h4>
<p>ah ok, I'll have to think about that some more!</p>

<a name="134620571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134620571" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134620571">Reid Barton (Sep 25 2018 at 19:14)</a>:</h4>
<p>Could we do something like this? Inside Lean, build a language for programs in STLC or another system which Lean can prove is strongly normalizing, but incorporating the type <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><mi mathvariant="double-struck">N</mi></mrow><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat \mathbb{N}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.9523299999999999em;"></span><span class="strut bottom" style="height:0.9523299999999999em;vertical-align:0em;"></span><span class="base"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9523299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathbb">N</span></span></span><span style="top:-3.25789em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="margin-left:0.16668em;"><span>^</span></span></span></span></span></span></span></span></span></span> = nondecreasing functions nat -&gt; bool. Then the input to our function is a code for a function <code>f</code> from <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><mi mathvariant="double-struck">N</mi></mrow><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat \mathbb{N}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.9523299999999999em;"></span><span class="strut bottom" style="height:0.9523299999999999em;vertical-align:0em;"></span><span class="base"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9523299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathbb">N</span></span></span><span style="top:-3.25789em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="margin-left:0.16668em;"><span>^</span></span></span></span></span></span></span></span></span></span> to <code>bool</code> together with a proof that <code>f inf = tt</code> (where <code>inf</code> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo><mover accent="true"><mrow><mi mathvariant="double-struck">N</mi></mrow><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\in \hat \mathbb{N}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.9523299999999999em;"></span><span class="strut bottom" style="height:0.9914299999999999em;vertical-align:-0.0391em;"></span><span class="base"><span class="mrel">∈</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9523299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathbb">N</span></span></span><span style="top:-3.25789em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="margin-left:0.16668em;"><span>^</span></span></span></span></span></span></span></span></span></span> is the constant function <code>ff</code>); we can enumerate such programs because the system is strongly terminating. In Lean+LEM, we can prove that every such function satisfies <code>f n = tt</code> for some finite <code>n</code>, and we ask that our function return the smallest such <code>n</code>.</p>

<a name="134620748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134620748" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134620748">Reid Barton (Sep 25 2018 at 19:16)</a>:</h4>
<p>Actually we don't even need the type <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><mi mathvariant="double-struck">N</mi></mrow><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat \mathbb{N}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.9523299999999999em;"></span><span class="strut bottom" style="height:0.9523299999999999em;vertical-align:0em;"></span><span class="base"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9523299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathbb">N</span></span></span><span style="top:-3.25789em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="margin-left:0.16668em;"><span>^</span></span></span></span></span></span></span></span></span></span>, we can just use the whole type <code>nat -&gt; bool</code>, but with the same idea.</p>

<a name="134620778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134620778" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134620778">Reid Barton (Sep 25 2018 at 19:17)</a>:</h4>
<p>If <code>f (const ff) = tt</code>, then there must be some finite <code>n</code> such that <code>f (\lam x, x &gt; n) = tt</code>.</p>

<a name="134620813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134620813" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134620813">Reid Barton (Sep 25 2018 at 19:17)</a>:</h4>
<p>Then we seek <code>g f = </code> the least <code>n</code> for which the above holds, provided that <code>f (const ff) = tt</code>, otherwise 37</p>

<a name="134620905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134620905" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134620905">Reid Barton (Sep 25 2018 at 19:19)</a>:</h4>
<p>(Compare <a href="http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/" target="_blank" title="http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/">http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/</a>)</p>

<a name="134620946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134620946" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134620946">Reid Barton (Sep 25 2018 at 19:19)</a>:</h4>
<p>Maybe this is actually still computable without LEM though</p>

<a name="134621676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134621676" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134621676">Reid Barton (Sep 25 2018 at 19:30)</a>:</h4>
<p>Yeah, I doubt this can be made to work. If you can constructively define a normalizer for your language, then you can presumably modify it to keep track of the invocations of the argument, and return the largest number on which it is invoked, then search up to there. If you can't constructively define a normalizer for your language, then you should just use a normalizer for your language as the function we're looking for.</p>

<a name="134622225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134622225" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134622225">Mario Carneiro (Sep 25 2018 at 19:37)</a>:</h4>
<p>Note that one way to "cheat" here is to have as input a nondecidable proposition, which you then use in the construction. I did something similar with my example of a function that takes as input a function that is not constant zero and returns a value in the range</p>

<a name="134622939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134622939" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134622939">Mario Carneiro (Sep 25 2018 at 19:46)</a>:</h4>
<p>Here again we seem to be stuck: if we use STLC or something provably normalizing, then we won't need LEM to prove the compactness property, and if we use DTT functions then even AC won't help since compactness isn't provable (though true)</p>

<a name="134623070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134623070" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134623070">Reid Barton (Sep 25 2018 at 19:47)</a>:</h4>
<p>Yes. We would need a language whose power is just right so that the proof of normalization requires LEM, which I have no idea how to go about (or whether it is even plausible that such a language could exist).</p>

<a name="134623309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134623309" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134623309">Reid Barton (Sep 25 2018 at 19:50)</a>:</h4>
<p>Can we prove that Lean-with-N-universes is normalizing inside Lean-with-N+1-universes? What do we know about the relative consistency of AC?</p>

<a name="134623359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134623359" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134623359">Reid Barton (Sep 25 2018 at 19:51)</a>:</h4>
<p>Any term of type <code>nat -&gt; nat</code> is equal (in a meta sense) to one defined without using universe variables right?</p>

<a name="134623378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134623378" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134623378">Mario Carneiro (Sep 25 2018 at 19:51)</a>:</h4>
<p>I believe that Con(CIC+AC) = Con(CIC) for the same reasons as Con(ZF) = Con(ZFC)</p>

<a name="134623467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134623467" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134623467">Reid Barton (Sep 25 2018 at 19:52)</a>:</h4>
<p>I wonder whether we can just describe a meta-level procedure for taking a function defined in Lean+AC and producing an equal one defined in Lean (using one more universe) explicitly</p>

<a name="134623469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134623469" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134623469">Mario Carneiro (Sep 25 2018 at 19:52)</a>:</h4>
<p>I believe that lean-with-n-universes is normalizing in n+1 universes</p>

<a name="134623492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134623492" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134623492">Mario Carneiro (Sep 25 2018 at 19:52)</a>:</h4>
<p>I have to prove that lean is normalizing first though :)</p>

<a name="134623545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134623545" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134623545">Mario Carneiro (Sep 25 2018 at 19:53)</a>:</h4>
<p>any term of type nat -&gt; nat may contain universe variables but is parametric in them, so you get the same result no matter what they are set to</p>

<a name="134623572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134623572" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134623572">Kenny Lau (Sep 25 2018 at 19:53)</a>:</h4>
<blockquote>
<p>Any term of type <code>nat -&gt; nat</code> is equal (in a meta sense) to one defined without using universe variables right?</p>
</blockquote>
<p>I heard FLT uses universes</p>

<a name="134623574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134623574" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134623574">Kenny Lau (Sep 25 2018 at 19:54)</a>:</h4>
<p>Fermat's Last Theorem</p>

<a name="134623625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134623625" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134623625">Reid Barton (Sep 25 2018 at 19:54)</a>:</h4>
<p>by writing an evaluator for Lean+AC-in-N-universes in Lean-in-N+1-universes, and then at the meta level looking to see how many universes are actually used, picking N to be bigger than that and writing down a term in the model that corresponds to the given function</p>

<a name="134623652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134623652" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134623652">Mario Carneiro (Sep 25 2018 at 19:54)</a>:</h4>
<p>It may be that even without any universe variables you still need type 3 or something in the term</p>

<a name="134623655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134623655" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134623655">Mario Carneiro (Sep 25 2018 at 19:54)</a>:</h4>
<p>(re: kenny)</p>

<a name="134623688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134623688" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134623688">Kenny Lau (Sep 25 2018 at 19:55)</a>:</h4>
<p>but is it just because nobody has cleaned up the proof yet?</p>

<a name="134623694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134623694" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134623694">Kenny Lau (Sep 25 2018 at 19:55)</a>:</h4>
<p>do we really need type 3?</p>

<a name="134623702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134623702" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134623702">Reid Barton (Sep 25 2018 at 19:55)</a>:</h4>
<p>Kenny is taking over for Patrick on trolling duty</p>

<a name="134623811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134623811" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134623811">Kenny Lau (Sep 25 2018 at 19:56)</a>:</h4>
<p>i'm serious</p>

<a name="134623831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134623831" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134623831">Mario Carneiro (Sep 25 2018 at 19:56)</a>:</h4>
<p>We know that ZFC is equiconsistent with ZF, but I think that may include a double negation translation</p>

<a name="134623845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134623845" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134623845">Mario Carneiro (Sep 25 2018 at 19:56)</a>:</h4>
<p>(if you use IZF in place of ZF)</p>

<a name="134623878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134623878" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134623878">Reid Barton (Sep 25 2018 at 19:57)</a>:</h4>
<blockquote>
<p>I believe that Con(CIC+AC) = Con(CIC) for the same reasons as Con(ZF) = Con(ZFC)</p>
</blockquote>
<p>This is unclear to me because, in the case of ZF, we start from classical logic, at least in the version I know. But that's not to say that LEM is required for the relative consistency, only that I don't know whether it is.</p>

<a name="134623955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134623955" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134623955">Mario Carneiro (Sep 25 2018 at 19:58)</a>:</h4>
<p>I also know that classical prop calc is equiconsistent with intuitionistic</p>

<a name="134624102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134624102" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134624102">Reid Barton (Sep 25 2018 at 20:00)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> <a href="https://mathoverflow.net/questions/35746/inaccessible-cardinals-and-andrew-wiless-proof" target="_blank" title="https://mathoverflow.net/questions/35746/inaccessible-cardinals-and-andrew-wiless-proof">https://mathoverflow.net/questions/35746/inaccessible-cardinals-and-andrew-wiless-proof</a> (See the first few answers.)</p>

<a name="134624631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134624631" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134624631">Reid Barton (Sep 25 2018 at 20:07)</a>:</h4>
<p>Mario, right, that seems plausible then.</p>

<a name="134652603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134652603" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134652603">Kevin Buzzard (Sep 26 2018 at 07:42)</a>:</h4>
<blockquote>
<p>What's the constructive proof that there exists a natural such that a^n=1 in a finite group?</p>
</blockquote>
<p>Let n be the order of the group ;-)</p>

<a name="134652674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mathlib%20%26%20constructivity/near/134652674" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/31330mathlibconstructivity.html#134652674">Kevin Buzzard (Sep 26 2018 at 07:44)</a>:</h4>
<blockquote>
<blockquote>
<p>Any term of type <code>nat -&gt; nat</code> is equal (in a meta sense) to one defined without using universe variables right?</p>
</blockquote>
<p>I heard FLT uses universes</p>
</blockquote>
<p>Kenny that is fake news, but the rumour seems hard to kill. Some people might argue that "the proof is written using universes" (because at some point Wiles says the word "representable functor" and at some other point uses etale cohomology) but they can easily be expunged using standard tricks.</p>


{% endraw %}
