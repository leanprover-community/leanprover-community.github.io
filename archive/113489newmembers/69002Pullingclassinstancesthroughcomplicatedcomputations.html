---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html">Pulling class instances through "complicated" computations</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="172748298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172748298" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172748298">Robert Spencer (Aug 08 2019 at 08:43)</a>:</h4>
<p>Good morning all.</p>
<p>I wonder if anyone could help me understand how best to tackle the following.  In a nutshell, I am performing some computations on types (taking quotients of submodules) and lean is struggling to find an instance I need for the result (that a quotient of a submodule is indeed a module).</p>
<p>Here is my minimal code.  Mathematically I am defining a filtration of a module, and then finding its subquotients.</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">list</span>

<span class="n">universes</span> <span class="n">U₁</span> <span class="n">U₂</span>

<span class="kn">namespace</span> <span class="n">list</span>
  <span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">U₁</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">U₂</span><span class="o">}</span>
  <span class="kn">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">L</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span>

  <span class="c1">-- Much like head,</span>
  <span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">def</span> <span class="n">head&#39;&#39;</span><span class="o">:</span> <span class="bp">Π</span>  <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">),</span> <span class="n">L</span> <span class="bp">≠</span> <span class="o">[]</span> <span class="bp">→</span> <span class="n">α</span>
  <span class="bp">|</span> <span class="o">[]</span>        <span class="n">h</span> <span class="o">:=</span> <span class="n">absurd</span> <span class="n">rfl</span> <span class="n">h</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">x</span> <span class="bp">::</span> <span class="n">xs</span><span class="o">)</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">x</span>

  <span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span>
  <span class="kn">lemma</span> <span class="n">chain&#39;_desc_left</span> <span class="o">:</span> <span class="n">chain&#39;</span> <span class="n">R</span> <span class="o">(</span><span class="n">x</span> <span class="bp">::</span> <span class="n">L</span><span class="o">)</span> <span class="bp">→</span> <span class="n">chain&#39;</span> <span class="n">R</span> <span class="n">L</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">cases</span> <span class="n">L</span><span class="bp">;</span> <span class="n">simp</span><span class="o">[</span><span class="n">chain&#39;</span><span class="o">]</span>

  <span class="n">def</span> <span class="n">chain&#39;_apply_between</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">Π</span><span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="o">(</span><span class="n">R</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">),</span> <span class="n">list</span><span class="bp">.</span><span class="n">chain&#39;</span> <span class="n">R</span> <span class="n">L</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">β</span>
  <span class="bp">|</span> <span class="o">[]</span> <span class="n">h</span> <span class="o">:=</span> <span class="o">[]</span>
  <span class="bp">|</span> <span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="n">h</span> <span class="o">:=</span> <span class="o">[]</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">x</span> <span class="bp">::</span> <span class="n">y</span> <span class="bp">::</span> <span class="n">xs</span><span class="o">)</span> <span class="n">h</span> <span class="o">:=</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span> <span class="n">y</span> <span class="o">(</span><span class="n">rel_of_chain_cons</span> <span class="n">h</span><span class="o">))</span> <span class="bp">::</span>
                       <span class="o">(</span><span class="n">chain&#39;_apply_between</span> <span class="o">(</span><span class="n">y</span> <span class="bp">::</span> <span class="n">xs</span><span class="o">)</span> <span class="o">(</span><span class="n">chain&#39;_desc_left</span> <span class="n">h</span><span class="o">)</span> <span class="o">)</span>

<span class="kn">end</span> <span class="n">list</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>

<span class="n">class</span> <span class="n">filtration</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">mods</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">))</span>
  <span class="o">(</span><span class="n">is_fil</span> <span class="o">:</span> <span class="n">list</span><span class="bp">.</span><span class="n">chain&#39;</span> <span class="o">(</span><span class="n">has_le</span><span class="bp">.</span><span class="n">le</span><span class="o">)</span> <span class="n">mods</span><span class="o">)</span>

<span class="n">def</span> <span class="n">mk_quotient</span> <span class="o">(</span><span class="n">U</span> <span class="n">V</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">))</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">U</span> <span class="bp">≤</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
  <span class="n">submodule</span><span class="bp">.</span><span class="n">quotient</span> <span class="o">((</span><span class="n">submodule</span><span class="bp">.</span><span class="n">map_subtype</span><span class="bp">.</span><span class="n">order_iso</span> <span class="n">V</span><span class="o">)</span><span class="bp">.</span><span class="n">inv_fun</span> <span class="bp">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">l</span><span class="bp">⟩</span><span class="o">)</span>


<span class="n">def</span> <span class="n">factors</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">filtration</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="kt">Type</span> <span class="o">:=</span>
  <span class="n">list</span><span class="bp">.</span><span class="n">chain&#39;_apply_between</span> <span class="o">(</span><span class="n">mk_quotient</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="n">F</span><span class="bp">.</span><span class="n">mods</span> <span class="n">F</span><span class="bp">.</span><span class="n">is_fil</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">filtration</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">factors</span> <span class="n">R</span> <span class="n">M</span> <span class="n">F</span> <span class="bp">≠</span> <span class="o">[])</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">M</span>                                          <span class="c">/-</span><span class="cm"> M : Type -/</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">((</span><span class="n">factors</span> <span class="n">R</span> <span class="n">M</span> <span class="n">F</span><span class="o">)</span><span class="bp">.</span><span class="n">head&#39;&#39;</span> <span class="n">h</span><span class="o">)</span>                 <span class="c">/-</span><span class="cm"> list.head&#39;&#39; (factors R M F) h : Type -/</span>
<span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="n">neg_smul</span> <span class="n">R</span> <span class="n">M</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span>                        <span class="c">/-</span><span class="cm"> neg_smul : ∀ (r : R) (x : M), -r • x = -(r • x) -/</span>
<span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="n">neg_smul</span> <span class="n">R</span> <span class="o">((</span><span class="n">factors</span> <span class="n">R</span> <span class="n">M</span> <span class="n">F</span><span class="o">)</span><span class="bp">.</span><span class="n">head&#39;&#39;</span> <span class="n">h</span><span class="o">)</span> <span class="bp">_</span> <span class="bp">_</span>
</pre></div>


<p>The last line fails, </p>
<div class="codehilite"><pre><span></span>failed to synthesize type class instance for
R : Type,
_inst_1 : ring R,
M : Type,
_inst_2 : add_comm_group M,
_inst_3 : module R M,
F : filtration R M,
h : factors R M F ≠ list.nil
⊢ add_comm_group (list.head&#39;&#39; (factors R M F) h)
</pre></div>


<p>Now, there is an instance defined in mathlib for <code>instance : add_comm_group (quotient p) </code>, which, once you unpack <code>head''</code> and <code>chain'_apply_between</code> is really what we are looking at.</p>
<p>How would be the best way to help lean find this instance?  I have two ideas: either a bunch of lemmas that carry the instances over each step or bundling the type with its instance data (in a similar manner to <code>submodule</code>) so that it is all in one place.  Are either of these good lean practice?</p>
<p>Hope I am not missing something obvious and stupid!</p>

<a name="172749428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172749428" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172749428">Mario Carneiro (Aug 08 2019 at 09:03)</a>:</h4>
<p>I would first point out that your use of <code>list Type</code> is rather unidiomatic and can lead to this kind of issues</p>

<a name="172749499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172749499" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172749499">Mario Carneiro (Aug 08 2019 at 09:04)</a>:</h4>
<p>It's almost useless to have a <code>list Type</code> because you don't know where the types came from so you don't know what structure they carry (like add_comm_group structure here)</p>

<a name="172749538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172749538" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172749538">Mario Carneiro (Aug 08 2019 at 09:05)</a>:</h4>
<p>and you can't use the usual list lemmas because that leads to an equality of types which is problematic (aka "evil")</p>

<a name="172750025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172750025" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172750025">Mario Carneiro (Aug 08 2019 at 09:14)</a>:</h4>
<p>One possibility is to use <code>fin n -&gt; Type</code> instead, which has better characteristics. But you need to know <code>n</code>, which here is something like <code>mods.length - 1</code> which is not so nice, especially in a rigid position like the <code>n</code> in <code>fin n</code>. You can remove the dependency by extending the list by some suitable default value past the end, for example if <code>modn n := if h : n &lt; mods.length then mods.nth_le n h else \top</code>, then you can prove <code>is_filn n : modn n &lt;= modn (n+1)</code> and then write <code>factors n := mk_quotient (is_filn n)</code> and now everything unfolds nicely.</p>

<a name="172751046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172751046" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172751046">Robert Spencer (Aug 08 2019 at 09:36)</a>:</h4>
<p>I understand that <code>list Type</code> is a problem, exactly for the reasons stated.</p>
<p>I had thought that <code>fin n -&gt; A</code> was almost interchangeable with <code>list A</code>, as there are suitable coercions between them (I think).  As you say, though, <code>fin n</code> requires you to know <code>n</code>.  This is not the end of the world for me I don't think.  I'd much rather not extend the filtration past the top, as I would like to distinguish between <code>0 &lt; U_1 &lt; U_2 &lt; M</code> and <code>0 &lt; U_1 &lt; U_2 &lt; M &lt; M</code> as filtrations.</p>
<p>This problem completely goes away if we have a <code>list (submodule R M)</code> for example because <code>submodule R M</code> is itself a structure and carries instances associated to that structure.  In an earlier draft of this I redefined a <code>modules</code> structure along the lines of</p>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">modules</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">carrier</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
  <span class="o">(</span><span class="n">add_comm_group</span> <span class="o">:</span> <span class="n">add_comm_group</span> <span class="n">carrier</span><span class="o">)</span>
  <span class="o">(</span><span class="n">module</span> <span class="o">:</span> <span class="n">module</span> <span class="n">R</span> <span class="n">carrier</span><span class="o">)</span>
</pre></div>


<p>and then defined suitable coercions to <code>Type</code>, and instances of <code>add_comm_group</code> on that coercion etc. etc.  This felt very dirty though, and not at all in the spirit of lean, but did let me have a <code>list (modules R)</code> very easily.</p>

<a name="172751056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172751056" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172751056">Kevin Buzzard (Aug 08 2019 at 09:36)</a>:</h4>
<p>The problem seems to be that each of the subquotients has type <code>Type</code>, but type class inference isn't smart enough to spot that it can put a module structure on the subquotients. I suspect this problem could be solved by bundling. If you had a type whose terms were R-modules, rather than the current set-up where M is a parameter for the R-module set-up, then perhaps things would go better.</p>

<a name="172751218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172751218" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172751218">Robert Spencer (Aug 08 2019 at 09:39)</a>:</h4>
<p>"Bundling" such as the above <code>structure</code>?</p>

<a name="172751295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172751295" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172751295">Kevin Buzzard (Aug 08 2019 at 09:41)</a>:</h4>
<p>At the minute you have terms of type <code>Type</code> and it's not generally true that a random term of this type is a module, so Lean's typeclass system can't deal with what you are trying to do. I guess another possibility would be to make your own structure consisting of a list and an R-module structure of each element of the list, and then work with these structures.</p>

<a name="172751402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172751402" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172751402">Kevin Buzzard (Aug 08 2019 at 09:43)</a>:</h4>
<p>Sorry, I'm on the London underground and I only have sporadic reception [messages are being sent before I see earlier messages you sent]. Yes, you're making the bundled category of R-modules. I am sure <span class="user-mention" data-user-id="110087">@Scott Morrison</span> would thoroughly approve and would argue that it was, or perhaps should be, in the spirit of Lean. Different people seem to have different opinions on the matter.</p>

<a name="172751651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172751651" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172751651">Kevin Buzzard (Aug 08 2019 at 09:49)</a>:</h4>
<p>Currently people believe that submodules of a given module should be a type, but that rings should not be a type (R should be a type and then the ring structure should be handled by the typeclass systems). Modules over a given ring are somewhere in the middle. Currently we're letting the typeclass system try and handle them -- but it's not clear to me whether this is "right" -- there will be advantages and disadvantages to each approach I guess. I will remark that we had real problems trying to make the typeclass system work with modules, there were a couple of failed attempts. The mathlib code</p>
<div class="codehilite"><pre><span></span><span class="n">class</span> <span class="n">module</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">β</span><span class="o">]</span> <span class="kn">extends</span> <span class="n">semimodule</span> <span class="n">α</span> <span class="n">β</span>

<span class="kn">structure</span> <span class="n">module</span><span class="bp">.</span><span class="n">core</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">β</span><span class="o">]</span> <span class="kn">extends</span> <span class="n">has_scalar</span> <span class="n">α</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">smul_add</span> <span class="o">:</span> <span class="bp">∀</span><span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">β</span><span class="o">),</span> <span class="n">r</span> <span class="err">•</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">r</span> <span class="err">•</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">r</span> <span class="err">•</span> <span class="n">y</span><span class="o">)</span>
<span class="o">(</span><span class="n">add_smul</span> <span class="o">:</span> <span class="bp">∀</span><span class="o">(</span><span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">β</span><span class="o">),</span> <span class="o">(</span><span class="n">r</span> <span class="bp">+</span> <span class="n">s</span><span class="o">)</span> <span class="err">•</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">r</span> <span class="err">•</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">s</span> <span class="err">•</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul_smul</span> <span class="o">:</span> <span class="bp">∀</span><span class="o">(</span><span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">β</span><span class="o">),</span> <span class="o">(</span><span class="n">r</span> <span class="bp">*</span> <span class="n">s</span><span class="o">)</span> <span class="err">•</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">r</span> <span class="err">•</span> <span class="n">s</span> <span class="err">•</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">one_smul</span> <span class="o">:</span> <span class="bp">∀</span><span class="n">x</span> <span class="o">:</span> <span class="n">β</span><span class="o">,</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="err">•</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>

<span class="n">def</span> <span class="n">module</span><span class="bp">.</span><span class="n">of_core</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">module</span><span class="bp">.</span><span class="n">core</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">module</span> <span class="n">α</span> <span class="n">β</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">letI</span> <span class="o">:=</span> <span class="n">M</span><span class="bp">.</span><span class="n">to_has_scalar</span><span class="bp">;</span> <span class="n">exact</span>
<span class="o">{</span> <span class="n">zero_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="err">•</span> <span class="n">x</span> <span class="bp">+</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="err">•</span> <span class="n">x</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="err">•</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">0</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="err">←</span> <span class="n">M</span><span class="bp">.</span><span class="n">add_smul</span><span class="bp">;</span> <span class="n">simp</span><span class="o">,</span>
    <span class="n">add_left_cancel</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">smul_zero</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">r</span> <span class="err">•</span> <span class="o">(</span><span class="mi">0</span><span class="o">:</span><span class="n">β</span><span class="o">)</span> <span class="bp">+</span> <span class="n">r</span> <span class="err">•</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">r</span> <span class="err">•</span> <span class="mi">0</span> <span class="bp">+</span> <span class="mi">0</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="err">←</span> <span class="n">M</span><span class="bp">.</span><span class="n">smul_add</span><span class="bp">;</span> <span class="n">simp</span><span class="o">,</span>
    <span class="n">add_left_cancel</span> <span class="n">this</span><span class="o">,</span>
  <span class="bp">..</span><span class="n">M</span> <span class="o">}</span>
</pre></div>


<p>already seems to indicate that something funny is going on.</p>

<a name="172752428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172752428" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172752428">Chris Hughes (Aug 08 2019 at 10:06)</a>:</h4>
<p>The best way would be to stick to submodules in your list, and then only quotient by them at the end. A <code>fin n -&gt; Type</code> would also be better, because you can easily get the instance, by just unfolding the function, and you will have the right definitional equalities.</p>

<a name="172753704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172753704" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172753704">Kevin Buzzard (Aug 08 2019 at 10:34)</a>:</h4>
<p>But if the entire R-module structure is bundled then he can just use lists, right? There is a category of R-modules. Was this ever created? Do these help to solve the problem?</p>

<a name="172755365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172755365" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172755365">Robert Spencer (Aug 08 2019 at 11:07)</a>:</h4>
<p><span class="user-mention" data-user-id="110044">@Chris Hughes</span>  Not quite understanding what you mean by "only quotient by them at the end".  If you mean that <code>(U : submodule R M)</code> encodes the same information as <code>M / U</code>, then this is true, but I'd have to have a list where each member is a submodule of the next, which seems messy.</p>

<a name="172756279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172756279" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172756279">Chris Hughes (Aug 08 2019 at 11:24)</a>:</h4>
<p>Something like this (not sure if this Type checks, but hopefully you get the idea)</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">mk_quotient</span> <span class="o">(</span><span class="n">U</span> <span class="n">V</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">))</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">U</span> <span class="bp">≤</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">submodule</span><span class="bp">.</span><span class="n">map_subtype</span><span class="bp">.</span><span class="n">order_iso</span> <span class="n">V</span><span class="o">)</span><span class="bp">.</span><span class="n">inv_fun</span> <span class="bp">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">l</span><span class="bp">⟩</span>

<span class="n">def</span> <span class="n">factors</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">filtration</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">list</span><span class="bp">.</span><span class="n">chain&#39;_apply_between</span> <span class="o">(</span><span class="n">mk_quotient</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="n">F</span><span class="bp">.</span><span class="n">mods</span> <span class="n">F</span><span class="bp">.</span><span class="n">is_fil</span>

<span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="n">neg_smul</span> <span class="n">R</span> <span class="o">(</span><span class="n">submodule</span><span class="bp">.</span><span class="n">quotient</span> <span class="o">((</span><span class="n">factors</span> <span class="n">R</span> <span class="n">M</span> <span class="n">F</span><span class="o">)</span><span class="bp">.</span><span class="n">head&#39;&#39;</span> <span class="n">h</span><span class="o">))</span> <span class="bp">_</span> <span class="bp">_</span>
</pre></div>

<a name="172757374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172757374" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172757374">Robert Spencer (Aug 08 2019 at 11:44)</a>:</h4>
<p>Hmm.  So if, for example, I wanted to check some filtration were a composition series I'd have to do</p>
<div class="codehilite"><pre><span></span><span class="bp">∀</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">list</span><span class="bp">.</span><span class="n">map</span> <span class="n">submodule</span><span class="bp">.</span><span class="n">quotient</span> <span class="o">(</span><span class="n">factors</span> <span class="n">R</span> <span class="n">M</span> <span class="n">F</span><span class="o">)),</span> <span class="n">is_simple</span> <span class="n">N</span>
</pre></div>


<p>I feel like it would be neater if I could write</p>
<div class="codehilite"><pre><span></span><span class="o">(</span><span class="n">factors</span> <span class="n">R</span> <span class="n">M</span> <span class="n">F</span><span class="o">)</span> <span class="err">⊆</span> <span class="o">{</span> <span class="n">N</span> <span class="bp">//</span> <span class="n">is_simple</span> <span class="n">N</span> <span class="o">}</span>
</pre></div>


<p>which I think I could get with a bundled object.</p>
<p>Is the consensus that this is currently a stylistic choice: bundle or not?</p>

<a name="172757990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172757990" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172757990">Kevin Buzzard (Aug 08 2019 at 11:57)</a>:</h4>
<p>Chris and Mario have suggested sticking with unbundled modules, and they have written a lot more Lean code than I have. But submodules are bundled and subgroups are not bundled, which in my mind is evidence that the community is still learning what the best way to go about things is. I don't see anything wrong with bundling modules. Perhaps if you try it you'll see the problems which I cannot.</p>

<a name="172758044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172758044" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172758044">Chris Hughes (Aug 08 2019 at 11:58)</a>:</h4>
<p>You can still write</p>
<div class="codehilite"><pre><span></span><span class="o">(</span><span class="n">factors</span> <span class="n">R</span> <span class="n">M</span> <span class="n">F</span><span class="o">)</span> <span class="err">⊆</span> <span class="o">{</span> <span class="n">N</span> <span class="bp">|</span> <span class="n">is_simple</span> <span class="o">(</span><span class="n">submodule</span><span class="bp">.</span><span class="n">quotient</span> <span class="n">N</span><span class="o">)</span> <span class="o">}</span>
</pre></div>


<p>(you'd have to coerce the list into a set for this to work)</p>

<a name="172758170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172758170" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172758170">Chris Hughes (Aug 08 2019 at 12:00)</a>:</h4>
<p>This is nicer from a category theoretic perspective, because if your objects are submodules, your category is small. This might be useful at some point.</p>

<a name="172758288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172758288" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172758288">Kevin Buzzard (Aug 08 2019 at 12:02)</a>:</h4>
<p>The problem with using <code>submodule</code> is that if you are taking subquotients of a chain of submodules then everything is a submodule of everything above it and there is not one canonical module for which the submodules are the answer.</p>
<p>Perhaps another approach is bundled subquotients of a module. I think this would be a very interesting way of going about things. You carry around A and B, submodules of some fixed module M, with A a subset of B, and this represents the quotient module B/A. You'd have to write an API for this but if the community think that submodules are worth bundling, surely bundling subquotients is also a natural idea.</p>

<a name="172758336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172758336" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172758336">Kevin Buzzard (Aug 08 2019 at 12:03)</a>:</h4>
<p>Assia Mahboubi wrote a paper called "the rooster and the butterfly" where she talks about subquotients of groups in Coq. This might have some relevant ideas. The more CS-minded people in this conversation seem to be against the idea of bundling modules, but perhaps they would be more open to the idea of bundling subquotients of a given module.</p>

<a name="172760072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172760072" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172760072">Mario Carneiro (Aug 08 2019 at 12:32)</a>:</h4>
<p>I'm open to the idea of bundling subquotients, but first I would like to know what that is exactly. It doesn't quite line up with our current definitions; is there a single set of all subquotients of a module?</p>

<a name="172760092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172760092" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172760092">Kevin Buzzard (Aug 08 2019 at 12:32)</a>:</h4>
<p>Yes. A subquotient of a module <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span> is just <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi mathvariant="normal">/</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">B/A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord">/</span><span class="mord mathdefault">A</span></span></span></span>, where <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>⊆</mo><mi>B</mi><mo>⊆</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">A\subseteq B\subseteq M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span> are submodules.</p>

<a name="172760112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172760112" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172760112">Kevin Buzzard (Aug 08 2019 at 12:33)</a>:</h4>
<p>A subquotient of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span> is equivalently a subset of a quotient of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>, or a quotient of a subset of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>.</p>

<a name="172760114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172760114" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172760114">Mario Carneiro (Aug 08 2019 at 12:33)</a>:</h4>
<p>but you have to equate isomorphic subquotients I assume?</p>

<a name="172760118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172760118" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172760118">Kevin Buzzard (Aug 08 2019 at 12:33)</a>:</h4>
<p>I think it's better than that.</p>

<a name="172760131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172760131" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172760131">Kevin Buzzard (Aug 08 2019 at 12:34)</a>:</h4>
<p>If you're dealing with subquotients then you can literally keep track of just the two submodules.</p>

<a name="172760177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172760177" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172760177">Mario Carneiro (Aug 08 2019 at 12:34)</a>:</h4>
<p>Is the set simply a subset of the product of subquotients then?</p>

<a name="172760181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172760181" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172760181">Kevin Buzzard (Aug 08 2019 at 12:34)</a>:</h4>
<p>Quotienting <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi mathvariant="normal">/</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">B/A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord">/</span><span class="mord mathdefault">A</span></span></span></span> is just making <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> bigger, and submoduling it is making <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> smaller.</p>

<a name="172760186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172760186" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172760186">Kevin Buzzard (Aug 08 2019 at 12:34)</a>:</h4>
<p>You mean a product of submodules I suspect. Yes.</p>

<a name="172760195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172760195" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172760195">Mario Carneiro (Aug 08 2019 at 12:34)</a>:</h4>
<p>I mean a subquotient is encoded as a pair of submodules</p>

<a name="172760200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172760200" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172760200">Kevin Buzzard (Aug 08 2019 at 12:34)</a>:</h4>
<p>Right.</p>

<a name="172760215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172760215" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172760215">Mario Carneiro (Aug 08 2019 at 12:35)</a>:</h4>
<p>It's not obvious to me that this has nice algebraic properties like submodules do though</p>

<a name="172760239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172760239" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172760239">Mario Carneiro (Aug 08 2019 at 12:35)</a>:</h4>
<p>That is, the collection of submodules is a "space", not just a "set"</p>

<a name="172760243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172760243" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172760243">Kevin Buzzard (Aug 08 2019 at 12:35)</a>:</h4>
<p>There is such a thing as a simple subquotient -- a subquotient which is simple as a module. A simple module is a module which has precisely two submoules, bot and top.</p>

<a name="172760348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172760348" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172760348">Mario Carneiro (Aug 08 2019 at 12:37)</a>:</h4>
<p>That, to me, is the compelling justification for bundling. If we are only claiming that subquotients are determined by this data (a pair A &lt;= B), then you could just as well do that with a function <code>mk_quotient (A B) (h: A &lt;= B): Type</code></p>

<a name="172760357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172760357" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172760357">Kevin Buzzard (Aug 08 2019 at 12:37)</a>:</h4>
<p>Simple modules are the analogue of prime numbers. Every positive integer is a uniquely a product of primes. For modules life isn't so simple. Recall that a <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span>-module is just the same as an abelian group. The <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span>-module <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="double-struck">Z</mi><mi mathvariant="normal">/</mi><mn>4</mn><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}/4\mathbb{Z}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbb">Z</span></span><span class="mord">/</span><span class="mord">4</span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span> is not simple, and even worse, it's not even isomorphic to a product of simple modules.</p>

<a name="172760458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172760458" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172760458">Kevin Buzzard (Aug 08 2019 at 12:38)</a>:</h4>
<p>However given a module with certain finiteness properties (e.g. a finite abelian group) one can produce a "saturated chain" of submodules <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>=</mo><msub><mi>M</mi><mn>0</mn></msub><mo>⊂</mo><msub><mi>M</mi><mn>1</mn></msub><mo>⊂</mo><msub><mi>M</mi><mn>2</mn></msub><mo>⊂</mo><mo>⋯</mo><mo>⊂</mo><msub><mi>M</mi><mi>n</mi></msub><mo>=</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">0=M_0\subset M_1\subset M_2\subset\cdots\subset M_n=M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>, with each subquotient <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mi mathvariant="normal">/</mi><msub><mi>M</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">M_{i+1}/M_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> simple.</p>

<a name="172760472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172760472" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172760472">Kevin Buzzard (Aug 08 2019 at 12:38)</a>:</h4>
<p>And the theorem is that the multiset of isomorphism classes of simple factors is an invariant of the module.</p>

<a name="172760494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172760494" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172760494">Mario Carneiro (Aug 08 2019 at 12:39)</a>:</h4>
<blockquote>
<p>I understand that <code>list Type</code> is a problem, exactly for the reasons stated.</p>
<p>I had thought that <code>fin n -&gt; A</code> was almost interchangeable with <code>list A</code>, as there are suitable coercions between them (I think).  As you say, though, <code>fin n</code> requires you to know <code>n</code>.  This is not the end of the world for me I don't think.  I'd much rather not extend the filtration past the top, as I would like to distinguish between <code>0 &lt; U_1 &lt; U_2 &lt; M</code> and <code>0 &lt; U_1 &lt; U_2 &lt; M &lt; M</code> as filtrations.</p>
</blockquote>
<p>To be clear, I'm not saying that the filtration actually extends past the top. This is only an encoding trick - the <code>list (submodule R M)</code> is still just as it was</p>

<a name="172760592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172760592" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172760592">Kevin Buzzard (Aug 08 2019 at 12:40)</a>:</h4>
<p>For example, for the cyclic groups <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">C_4</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mn>2</mn></msub><mo>×</mo><msub><mi>C</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">C_2\times C_2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> the multisets are <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">C_2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> with multiplicity 2 (in both cases), so you can't reconstruct a module from its irreducible subquotients. However the multiset is still useful -- for example in algebraic geometry one often does induction on the size of the multiset (with the inductive step typically being straightforward and the base case being the interesting one).</p>

<a name="172760761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172760761" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172760761">Mario Carneiro (Aug 08 2019 at 12:42)</a>:</h4>
<p>That is, the filtrations <code>0 &lt; U_1 &lt; U_2 &lt; M</code> and <code>0 &lt; U_1 &lt; U_2 &lt; M &lt; M</code> are distinct, but the function <code>factors F : nat -&gt; Type</code> is the same for both filtrations. You just remember that they have different lengths and the function is "garbage" past the end</p>

<a name="172760890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172760890" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172760890">Kevin Buzzard (Aug 08 2019 at 12:44)</a>:</h4>
<blockquote>
<p>That is, the collection of submodules is a "space", not just a "set"</p>
</blockquote>
<p>I find it hard to imagine a definition of "space" where the submodules form a space and the subquotients do not. The subquotients are a subspace of the product of two copies of the space of submodules.</p>

<a name="172760951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172760951" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172760951">Mario Carneiro (Aug 08 2019 at 12:45)</a>:</h4>
<p>My question is mostly directed at whether that encoding is reflecting some real structure that we care about or if it's just the usual "a group is a 4-tuple" business</p>

<a name="172761007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172761007" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172761007">Kevin Buzzard (Aug 08 2019 at 12:46)</a>:</h4>
<p>In some cases (for example subspaces of a finite-dimensional real vector space) the "space" of submodules really do naturally form a topological space, with one connected component for each dimension. But similarly the subquotients do too, they're a topological space with one connected component for each pair (dim A, dim B).</p>

<a name="172761060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172761060" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172761060">Mario Carneiro (Aug 08 2019 at 12:47)</a>:</h4>
<p>Are they a lattice?</p>

<a name="172761121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172761121" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172761121">Mario Carneiro (Aug 08 2019 at 12:48)</a>:</h4>
<p>Or at least, is there an ordering</p>

<a name="172761195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172761195" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172761195">Kevin Buzzard (Aug 08 2019 at 12:49)</a>:</h4>
<p>You can visualise the space of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>-dimensional submodules of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi mathvariant="double-struck">R</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\mathbb{R}^n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span> as a quotient <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><msub><mi>L</mi><mi>n</mi></msub><mo stretchy="false">(</mo><mi mathvariant="double-struck">R</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">GL_n(\mathbb{R})/P</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">G</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathbb">R</span></span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span> where <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span> is a subgroup of "block upper triangular matrices" consisting of a <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>×</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">d\times d</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span> block at the top and an <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>d</mi><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n-d)\times (n-d)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mclose">)</span></span></span></span> block at the bottom. You can get more general subquotients (or even chains of submodules) by using other choices of "parabolic subgroup" P with more blocks on the diagonal.</p>

<a name="172761270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172761270" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172761270">Kevin Buzzard (Aug 08 2019 at 12:50)</a>:</h4>
<p>I don't think I can intersect two subquotients, but I am more confident about an ordering. I think I would suggest that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi mathvariant="normal">/</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">B/A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord">/</span><span class="mord mathdefault">A</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>B</mi><mo mathvariant="normal">′</mo></msup><mi mathvariant="normal">/</mi><msup><mi>A</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">B'/A'</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> were incomparable unless <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>=</mo><msup><mi>A</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">A=A'</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> in which case it goes on the subset ordering on the $$B$$s.</p>

<a name="172761307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172761307" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172761307">Kevin Buzzard (Aug 08 2019 at 12:51)</a>:</h4>
<p>One could risk <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>B</mi><mo>∩</mo><msup><mi>B</mi><mo mathvariant="normal">′</mo></msup><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>A</mi><mo>∩</mo><msup><mi>A</mi><mo mathvariant="normal">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(B\cap B')/(A\cap A')</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> but it might not be a great idea. It looks a bit odd to me in the sense that I've not seen it before.</p>

<a name="172761344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172761344" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172761344">Mario Carneiro (Aug 08 2019 at 12:51)</a>:</h4>
<p>Oh, I was going to guess <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mn>1</mn></msub><mi mathvariant="normal">/</mi><msub><mi>A</mi><mn>1</mn></msub><mo>≤</mo><msub><mi>B</mi><mn>2</mn></msub><mi mathvariant="normal">/</mi><msub><mi>A</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">B_1/A_1 \le B_2/A_2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> iff <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mn>1</mn></msub><mo>≤</mo><msub><mi>B</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">B_1\le B_2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mn>2</mn></msub><mo>≤</mo><msub><mi>A</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">A_2\le A_1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>

<a name="172761345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172761345" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172761345">Kevin Buzzard (Aug 08 2019 at 12:51)</a>:</h4>
<p>It might work but not be useful, or it might work and be a really cool way of thinking about things, or it might just not work.</p>

<a name="172761442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172761442" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172761442">Kevin Buzzard (Aug 08 2019 at 12:52)</a>:</h4>
<p>One could I guess also say <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mn>1</mn></msub><mi mathvariant="normal">/</mi><msub><mi>A</mi><mn>1</mn></msub><mo>≤</mo><msub><mi>B</mi><mn>2</mn></msub><mi mathvariant="normal">/</mi><msub><mi>A</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">B_1/A_1\leq B_2/A_2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> iff there was a "natural map" from one to the other, like for submodules.</p>

<a name="172761503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172761503" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172761503">Kevin Buzzard (Aug 08 2019 at 12:53)</a>:</h4>
<p>If you did that you'd get <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mn>1</mn></msub><mo>⊆</mo><msub><mi>A</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">A_1\subseteq A_2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mn>1</mn></msub><mo>⊆</mo><msub><mi>B</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">B_1\subseteq B_2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>

<a name="172761537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172761537" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172761537">Mario Carneiro (Aug 08 2019 at 12:53)</a>:</h4>
<p>Your point about considering subquotients as generalizations of submodules by inserting an additional block, and filtrations as a further generalization to multiple blocks, suggests a way to encode this as an inductive type, which might work out nicer</p>

<a name="172761633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172761633" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172761633">Kevin Buzzard (Aug 08 2019 at 12:54)</a>:</h4>
<p>Grassmannians are the topological spaces which one gets by considering filtrations on a finite-dimensional vector space. Because they can be computed as quotients of general linear groups by subgroups there is also a purely algebraic way of thinking about them, where your base field is now arbitrary and the quotients are (non-affine) schemes.</p>

<a name="172761868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172761868" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172761868">Kevin Buzzard (Aug 08 2019 at 12:58)</a>:</h4>
<p>Projective 1-space is the space of 1-dimensional subspaces of a 2-dimensional vector space. These are the first natural examples of non-affine schemes. <span class="user-mention" data-user-id="110064">@Kenny Lau</span> how is gluing?</p>

<a name="172761879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172761879" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172761879">Kevin Buzzard (Aug 08 2019 at 12:59)</a>:</h4>
<p>Do we have Grassmannians yet? ;-)</p>

<a name="172762157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172762157" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172762157">Mario Carneiro (Aug 08 2019 at 13:03)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">universe</span> <span class="n">u</span>
<span class="kn">open</span> <span class="n">lattice</span>
<span class="kn">inductive</span> <span class="n">transit</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="bp">|</span> <span class="n">one</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">transit</span> <span class="n">a</span> <span class="n">b</span>
<span class="bp">|</span> <span class="n">trans</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="n">transit</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">transit</span> <span class="n">b</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">transit</span> <span class="n">a</span> <span class="n">c</span>

<span class="n">def</span> <span class="n">filtration</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">bounded_lattice</span> <span class="n">α</span><span class="o">]</span> <span class="o">:=</span> <span class="n">transit</span> <span class="o">(</span><span class="err">⊥</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="err">⊤</span>
</pre></div>


<p>The downside of this encoding is that it distinguishes reassociated sequences, i.e. <code>0 &lt; (A &lt; (B &lt; M))</code> vs <code>(0 &lt; A) &lt; (B &lt; M)</code></p>

<a name="172764341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172764341" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172764341">Mario Carneiro (Aug 08 2019 at 13:28)</a>:</h4>
<p>Here's how you can say that a filtration is simple:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">universe</span> <span class="n">u</span>
<span class="kn">open</span> <span class="n">lattice</span>
<span class="kn">inductive</span> <span class="n">transit</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="bp">|</span> <span class="n">one</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">transit</span> <span class="n">a</span> <span class="n">b</span>
<span class="bp">|</span> <span class="n">trans</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="n">transit</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">transit</span> <span class="n">b</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">transit</span> <span class="n">a</span> <span class="n">c</span>

<span class="n">def</span> <span class="n">filtration</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">bounded_lattice</span> <span class="n">α</span><span class="o">]</span> <span class="o">:=</span> <span class="n">transit</span> <span class="o">(</span><span class="err">⊥</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="err">⊤</span>

<span class="kn">structure</span> <span class="n">le_pair</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">:=</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">a_le_b</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span>

<span class="n">def</span> <span class="n">transit</span><span class="bp">.</span><span class="n">factors</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">},</span> <span class="n">transit</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">list</span> <span class="o">(</span><span class="n">le_pair</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="n">transit</span><span class="bp">.</span><span class="n">one</span> <span class="n">a</span> <span class="n">b</span> <span class="n">h</span><span class="o">)</span> <span class="o">:=</span> <span class="o">[</span><span class="bp">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">h</span><span class="bp">⟩</span><span class="o">]</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="n">transit</span><span class="bp">.</span><span class="n">trans</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">t1</span> <span class="n">t2</span><span class="o">)</span> <span class="o">:=</span> <span class="n">t1</span><span class="bp">.</span><span class="n">factors</span> <span class="bp">++</span> <span class="n">t2</span><span class="bp">.</span><span class="n">factors</span>

<span class="n">def</span> <span class="n">subquotient</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">α</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">le_pair</span> <span class="o">(</span><span class="n">submodule</span> <span class="n">α</span> <span class="n">β</span><span class="o">))</span> <span class="o">:=</span> <span class="o">(</span><span class="n">submodule</span><span class="bp">.</span><span class="n">comap</span> <span class="n">p</span><span class="bp">.</span><span class="n">b</span><span class="bp">.</span><span class="n">subtype</span> <span class="n">p</span><span class="bp">.</span><span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">quotient</span>

<span class="kn">instance</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">α</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">le_pair</span> <span class="o">(</span><span class="n">submodule</span> <span class="n">α</span> <span class="n">β</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">add_comm_group</span> <span class="o">(</span><span class="n">subquotient</span> <span class="n">p</span><span class="o">)</span> <span class="o">:=</span> <span class="n">submodule</span><span class="bp">.</span><span class="n">quotient</span><span class="bp">.</span><span class="n">add_comm_group</span> <span class="bp">_</span>
<span class="kn">instance</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">α</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">le_pair</span> <span class="o">(</span><span class="n">submodule</span> <span class="n">α</span> <span class="n">β</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">module</span> <span class="n">α</span> <span class="o">(</span><span class="n">subquotient</span> <span class="n">p</span><span class="o">)</span> <span class="o">:=</span> <span class="n">submodule</span><span class="bp">.</span><span class="n">quotient</span><span class="bp">.</span><span class="n">module</span> <span class="bp">_</span>

<span class="n">def</span> <span class="n">module</span><span class="bp">.</span><span class="n">is_simple</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">α</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="n">def</span> <span class="n">filtration</span><span class="bp">.</span><span class="n">is_simple</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">α</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">filtration</span> <span class="o">(</span><span class="n">submodule</span> <span class="n">α</span> <span class="n">β</span><span class="o">))</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">F</span><span class="bp">.</span><span class="n">factors</span><span class="o">,</span> <span class="n">module</span><span class="bp">.</span><span class="n">is_simple</span> <span class="n">α</span> <span class="o">(</span><span class="n">subquotient</span> <span class="n">p</span><span class="o">)</span>
</pre></div>

<a name="172774026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172774026" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172774026">Robert Spencer (Aug 08 2019 at 15:14)</a>:</h4>
<p>I'll have to take some time to look at that solution and wrap my head around it, and how <code>transit</code> is really different from a <code>list</code> with a <code>chain'</code> (in particular, I think one could replace <code>transit.factors</code> with some sort of <code>chain'_factors (l : list \a) [chain' &lt;= l] : list (le_pair \a)</code> and get a similar result.</p>

<a name="172774041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172774041" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172774041">Robert Spencer (Aug 08 2019 at 15:14)</a>:</h4>
<p>Thanks for the pointers though</p>

<a name="172774122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172774122" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172774122">Robert Spencer (Aug 08 2019 at 15:15)</a>:</h4>
<p>I think for now I'll just treat sub quotients as these <code>le_pairs</code> until something better comes around</p>

<a name="172776682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172776682" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172776682">Mario Carneiro (Aug 08 2019 at 15:46)</a>:</h4>
<p>You can still use list and chain; the key point here is that you don't put types in a list, you put the data from which you generate the types</p>

<a name="172776791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172776791" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172776791">Mario Carneiro (Aug 08 2019 at 15:47)</a>:</h4>
<p>But I think it would be better to use structures that encode the relevant invariants, so that for example it's not possible to have an empty factors list, rather than having a predicate on the side to assert this</p>

<a name="172776951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172776951" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172776951">Mario Carneiro (Aug 08 2019 at 15:49)</a>:</h4>
<p>You can also avoid the reassociation problem by structuring the inductive type a little differently so that it's all associated one way (this is basically what the <code>list</code> representation gives you), but this has different defeq simplifications and introduces a bias for one kind of association over the other. Whether this matters one way or another depends on details of the application</p>


{% endraw %}

{% include archive_update.html %}