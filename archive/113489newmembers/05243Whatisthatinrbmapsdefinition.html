---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113489newmembers/05243Whatisthatinrbmapsdefinition.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/05243Whatisthatinrbmapsdefinition.html">What is that `.` in `rbmap`'s definition?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="178534982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20is%20that%20%60.%60%20in%20%60rbmap%60%27s%20definition%3F/near/178534982" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/05243Whatisthatinrbmapsdefinition.html#178534982">Marko Grdinić (Oct 19 2019 at 08:02)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">rbmap</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">lt</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="bp">.</span> <span class="n">rbtree</span><span class="bp">.</span><span class="n">default_lt</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">rbtree</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">rbmap_lt</span> <span class="n">lt</span><span class="o">)</span>
</pre></div>


<p>I am wondering what <code>Prop . rbtree.default_lt</code> is supposed to be. The <code>.</code> operator here does not seem to be a function so it is probably some kind of built in, but I am not sure what it does.</p>
<p>It is too bad that <code>β</code> here is not dependent on <code>α</code>. I have a use case where that would be useful and am going to try to redesign the <code>rbmap</code>. It is good there is not much there.</p>

<a name="178535184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20is%20that%20%60.%60%20in%20%60rbmap%60%27s%20definition%3F/near/178535184" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/05243Whatisthatinrbmapsdefinition.html#178535184">Kenny Lau (Oct 19 2019 at 08:08)</a>:</h4>
<p>it's <code>\a \to \a \to Prop</code> defaulting to <code>rbtree.default_lt</code></p>

<a name="178535481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20is%20that%20%60.%60%20in%20%60rbmap%60%27s%20definition%3F/near/178535481" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/05243Whatisthatinrbmapsdefinition.html#178535481">Marko Grdinić (Oct 19 2019 at 08:19)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> </p>
<p>I see. Does it get printed like <code>lt : auto_param (α → α → Prop) (name.mk_string "default_lt" (name.mk_string "rbtree" name.anonymous))</code> for you? </p>
<p>Also...</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">rbmap_lt</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">(</span><span class="n">lt</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="err">Σ</span> <span class="n">α</span><span class="o">,</span> <span class="n">β</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">lt</span> <span class="n">a</span><span class="bp">.</span><span class="mi">1</span> <span class="n">b</span><span class="bp">.</span><span class="mi">1</span>

<span class="kn">set_option</span> <span class="n">auto_param</span><span class="bp">.</span><span class="n">check_exists</span> <span class="n">false</span>

<span class="n">def</span> <span class="n">rbmap</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">lt</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="bp">.</span> <span class="n">rbtree</span><span class="bp">.</span><span class="n">default_lt</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">rbtree</span> <span class="o">(</span><span class="err">Σ</span> <span class="n">α</span><span class="o">,</span> <span class="n">β</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">rbmap_lt</span> <span class="n">lt</span><span class="o">)</span>
</pre></div>


<div class="codehilite"><pre><span></span>type mismatch at application
  lt (a.fst)
term
  a.fst
has type
  Type u : Type (u+1)
but is expected to have type
  α : Type u
</pre></div>


<p>I am getting some type errors in both functions when trying to make a dependent map that I am not sure how to deal with. What is wrong here?</p>

<a name="178535651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20is%20that%20%60.%60%20in%20%60rbmap%60%27s%20definition%3F/near/178535651" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/05243Whatisthatinrbmapsdefinition.html#178535651">Marko Grdinić (Oct 19 2019 at 08:24)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">rbmap_lt</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">lt</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="err">Σ</span> <span class="n">α</span><span class="o">,</span> <span class="n">β</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">lt</span> <span class="n">a</span><span class="bp">.</span><span class="mi">1</span> <span class="n">b</span><span class="bp">.</span><span class="mi">1</span>

<span class="kn">set_option</span> <span class="n">auto_param</span><span class="bp">.</span><span class="n">check_exists</span> <span class="n">false</span>

<span class="n">def</span> <span class="n">rbmap</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">lt</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="bp">.</span> <span class="n">rbtree</span><span class="bp">.</span><span class="n">default_lt</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">rbtree</span> <span class="o">(</span><span class="err">Σ</span> <span class="n">α</span><span class="o">,</span> <span class="n">β</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">rbmap_lt</span> <span class="n">lt</span><span class="o">)</span>
</pre></div>


<div class="codehilite"><pre><span></span>type mismatch at application
  rbmap_lt lt
term
  lt
has type
  auto_param (α → α → Prop) (name.mk_string &quot;default_lt&quot; (name.mk_string &quot;rbtree&quot; name.anonymous)) : Type u
but is expected to have type
  ?m_1 → ?m_1 → Prop : Type
</pre></div>


<p>I've managed to figure out the first part. Now what is this?</p>

<a name="178535728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20is%20that%20%60.%60%20in%20%60rbmap%60%27s%20definition%3F/near/178535728" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/05243Whatisthatinrbmapsdefinition.html#178535728">Mario Carneiro (Oct 19 2019 at 08:26)</a>:</h4>
<p>Notice that the type is <code>Type</code> instead of <code>Type u</code></p>

<a name="178535737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20is%20that%20%60.%60%20in%20%60rbmap%60%27s%20definition%3F/near/178535737" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/05243Whatisthatinrbmapsdefinition.html#178535737">Mario Carneiro (Oct 19 2019 at 08:27)</a>:</h4>
<p>the auto_param thing is not the problem</p>

<a name="178535780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20is%20that%20%60.%60%20in%20%60rbmap%60%27s%20definition%3F/near/178535780" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/05243Whatisthatinrbmapsdefinition.html#178535780">Mario Carneiro (Oct 19 2019 at 08:28)</a>:</h4>
<p>When you defined <code>rbmap_lt</code>, you used <code>Type</code> for the type of alpha and beta (i.e. non universe polymorphic), but then you apply it in <code>rbmap</code> where alpha and beta now live in arbitrary universes</p>

<a name="178535933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20is%20that%20%60.%60%20in%20%60rbmap%60%27s%20definition%3F/near/178535933" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/05243Whatisthatinrbmapsdefinition.html#178535933">Marko Grdinić (Oct 19 2019 at 08:33)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">rbmap_lt</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">(</span><span class="n">lt</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="err">Σ</span> <span class="n">α</span><span class="o">,</span> <span class="n">β</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">lt</span> <span class="n">a</span><span class="bp">.</span><span class="mi">1</span> <span class="n">b</span><span class="bp">.</span><span class="mi">1</span>

<span class="kn">set_option</span> <span class="n">auto_param</span><span class="bp">.</span><span class="n">check_exists</span> <span class="n">false</span>

<span class="n">def</span> <span class="n">rbmap</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">lt</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="bp">.</span> <span class="n">rbtree</span><span class="bp">.</span><span class="n">default_lt</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">rbtree</span> <span class="o">(</span><span class="err">Σ</span> <span class="n">α</span><span class="o">,</span> <span class="n">β</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">rbmap_lt</span> <span class="n">lt</span><span class="o">)</span>
</pre></div>


<p>So like this then. If I omit the universe levels in the type will it get inferred like so or will it be non-universe polymorphic? I can't check this easily because <code>#check</code> seems to fail with an error when I pass it this function.</p>

<a name="178535976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20is%20that%20%60.%60%20in%20%60rbmap%60%27s%20definition%3F/near/178535976" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/05243Whatisthatinrbmapsdefinition.html#178535976">Marko Grdinić (Oct 19 2019 at 08:34)</a>:</h4>
<p>The error is <code>invalid auto_param, unknown tactic 'rbtree.default_lt'</code>.</p>

<a name="178536028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20is%20that%20%60.%60%20in%20%60rbmap%60%27s%20definition%3F/near/178536028" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/05243Whatisthatinrbmapsdefinition.html#178536028">Scott Morrison (Oct 19 2019 at 08:36)</a>:</h4>
<p>Yeah, I was running into the same problem: <code>rbtree.default_lt</code> doesn't seem to actually exist...</p>

<a name="178536038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20is%20that%20%60.%60%20in%20%60rbmap%60%27s%20definition%3F/near/178536038" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/05243Whatisthatinrbmapsdefinition.html#178536038">Mario Carneiro (Oct 19 2019 at 08:36)</a>:</h4>
<p>it's in <code>init.data.rbtree.default</code></p>

<a name="178536050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20is%20that%20%60.%60%20in%20%60rbmap%60%27s%20definition%3F/near/178536050" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/05243Whatisthatinrbmapsdefinition.html#178536050">Mario Carneiro (Oct 19 2019 at 08:37)</a>:</h4>
<p>this checks for me:</p>
<div class="codehilite"><pre><span></span><span class="n">prelude</span>
<span class="kn">import</span> <span class="n">init</span><span class="bp">.</span><span class="n">data</span><span class="bp">.</span><span class="n">rbtree</span><span class="bp">.</span><span class="n">basic</span>
<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="n">def</span> <span class="n">rbmap_lt</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">(</span><span class="n">lt</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="err">Σ</span> <span class="n">α</span><span class="o">,</span> <span class="n">β</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">lt</span> <span class="n">a</span><span class="bp">.</span><span class="mi">1</span> <span class="n">b</span><span class="bp">.</span><span class="mi">1</span>

<span class="kn">set_option</span> <span class="n">auto_param</span><span class="bp">.</span><span class="n">check_exists</span> <span class="n">false</span>

<span class="n">def</span> <span class="n">rbmap</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">lt</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="bp">.</span> <span class="n">rbtree</span><span class="bp">.</span><span class="n">default_lt</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">rbtree</span> <span class="o">(</span><span class="err">Σ</span> <span class="n">α</span><span class="o">,</span> <span class="n">β</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">rbmap_lt</span> <span class="n">lt</span><span class="o">)</span>
</pre></div>

<a name="178536105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20is%20that%20%60.%60%20in%20%60rbmap%60%27s%20definition%3F/near/178536105" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/05243Whatisthatinrbmapsdefinition.html#178536105">Mario Carneiro (Oct 19 2019 at 08:38)</a>:</h4>
<p>If I don't use <code>prelude</code> then I get a duplicate definition error because this is all defined in <code>init</code></p>

<a name="178536183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20is%20that%20%60.%60%20in%20%60rbmap%60%27s%20definition%3F/near/178536183" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/05243Whatisthatinrbmapsdefinition.html#178536183">Mario Carneiro (Oct 19 2019 at 08:41)</a>:</h4>
<blockquote>
<p>So like this then. If I omit the universe levels in the type will it get inferred like so or will it be non-universe polymorphic?</p>
</blockquote>
<p>If you want to omit the universe level but keep it polymorphic, use <code>Type*</code> (or <code>Type _</code> which is equivalent). The core library deliberately uses universe variables everywhere, but in mathlib the preference is for <code>Type*</code> unless universe inference fails</p>

<a name="178536227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20is%20that%20%60.%60%20in%20%60rbmap%60%27s%20definition%3F/near/178536227" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/05243Whatisthatinrbmapsdefinition.html#178536227">Marko Grdinić (Oct 19 2019 at 08:42)</a>:</h4>
<blockquote>
<p>If I don't use prelude then I get a duplicate definition error because this is all defined in init</p>
</blockquote>
<p>Actually, I am using that as well as I just copy pasted the <code>rbmap.basic</code> into my own project. But even if I insert that <code>#check rbmap</code> in the original file, I get the same error.</p>

<a name="178536244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20is%20that%20%60.%60%20in%20%60rbmap%60%27s%20definition%3F/near/178536244" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/05243Whatisthatinrbmapsdefinition.html#178536244">Mario Carneiro (Oct 19 2019 at 08:43)</a>:</h4>
<p>right, <code>#check rbmap</code> fails if you put it right after my code snippet</p>

<a name="178536291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20is%20that%20%60.%60%20in%20%60rbmap%60%27s%20definition%3F/near/178536291" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/05243Whatisthatinrbmapsdefinition.html#178536291">Mario Carneiro (Oct 19 2019 at 08:44)</a>:</h4>
<p>If you <code>import init.data.rbtree</code> instead, then it calls the tactic (which fails)</p>

<a name="178536309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20is%20that%20%60.%60%20in%20%60rbmap%60%27s%20definition%3F/near/178536309" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/05243Whatisthatinrbmapsdefinition.html#178536309">Mario Carneiro (Oct 19 2019 at 08:45)</a>:</h4>
<p>This is only a problem if you use the auto_param feature: that is, you leave implicit the <code>lt</code> argument</p>

<a name="178536312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20is%20that%20%60.%60%20in%20%60rbmap%60%27s%20definition%3F/near/178536312" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/05243Whatisthatinrbmapsdefinition.html#178536312">Mario Carneiro (Oct 19 2019 at 08:45)</a>:</h4>
<p><code>#check @rbmap</code> works fine</p>

<a name="178536361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20is%20that%20%60.%60%20in%20%60rbmap%60%27s%20definition%3F/near/178536361" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/05243Whatisthatinrbmapsdefinition.html#178536361">Mario Carneiro (Oct 19 2019 at 08:46)</a>:</h4>
<p>obviously it can't call the tactic if it doesn't exist. Normally it errors when the auto_param is defined, but as you can see from the code snippet this check was explicitly disabled</p>

<a name="178536381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20is%20that%20%60.%60%20in%20%60rbmap%60%27s%20definition%3F/near/178536381" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/05243Whatisthatinrbmapsdefinition.html#178536381">Mario Carneiro (Oct 19 2019 at 08:47)</a>:</h4>
<p>I'm not exactly sure why the definition was delayed, but I would guess it's because of bootstrapping the tactic framework</p>

<a name="178536546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20is%20that%20%60.%60%20in%20%60rbmap%60%27s%20definition%3F/near/178536546" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/05243Whatisthatinrbmapsdefinition.html#178536546">Marko Grdinić (Oct 19 2019 at 08:51)</a>:</h4>
<p>Ok, I see. Just a bit more...</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">drbmap_lt</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">(</span><span class="n">lt</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="err">Σ</span> <span class="n">α</span><span class="o">,</span> <span class="n">β</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">lt</span> <span class="n">a</span><span class="bp">.</span><span class="mi">1</span> <span class="n">b</span><span class="bp">.</span><span class="mi">1</span>
</pre></div>


<p>I am a bit confused here. Why is this type definition right?</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">drbmap_lt</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">(</span><span class="n">lt</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="err">Σ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">β</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">lt</span> <span class="n">a</span><span class="bp">.</span><span class="mi">1</span> <span class="n">b</span><span class="bp">.</span><span class="mi">1</span>
</pre></div>


<p>Shouldn't I have written it like this?</p>

<a name="178536608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20is%20that%20%60.%60%20in%20%60rbmap%60%27s%20definition%3F/near/178536608" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/05243Whatisthatinrbmapsdefinition.html#178536608">Marko Grdinić (Oct 19 2019 at 08:53)</a>:</h4>
<div class="codehilite"><pre><span></span>drbmap :
  Π (α : Type u_1),
    (α → Type u_2) →
    auto_param (α → α → Prop) (name.mk_string &quot;default_lt&quot; (name.mk_string &quot;rbtree&quot; name.anonymous)) →
    Type (max u_1 u_2)
</pre></div>


<p>Also were you saying that the printing of the <code>auto_param</code> is not an error?</p>

<a name="178536791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20is%20that%20%60.%60%20in%20%60rbmap%60%27s%20definition%3F/near/178536791" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/05243Whatisthatinrbmapsdefinition.html#178536791">Mario Carneiro (Oct 19 2019 at 08:58)</a>:</h4>
<p>The only difference between your two definitions is the name of the bound variable</p>

<a name="178536798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20is%20that%20%60.%60%20in%20%60rbmap%60%27s%20definition%3F/near/178536798" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/05243Whatisthatinrbmapsdefinition.html#178536798">Mario Carneiro (Oct 19 2019 at 08:58)</a>:</h4>
<p>the first one is confusing because the bound variable <code>α</code> shadows the <code>α</code> earlier in the definition</p>

<a name="178536874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20is%20that%20%60.%60%20in%20%60rbmap%60%27s%20definition%3F/near/178536874" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/05243Whatisthatinrbmapsdefinition.html#178536874">Mario Carneiro (Oct 19 2019 at 09:00)</a>:</h4>
<p>The auto_param thing is supposed to be there. A <code>(x : foo . tac)</code> binder is elaborated to <code>(x : auto_param foo `tac)</code>. If you look at the definition, you will see that <code>auto_param α tac := α</code>, so this doesn't affect type correctness of anything. It just acts as a marker for the elaborator so it can remember what tactic you wanted to call in case the value is not provided</p>

<a name="178536904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20is%20that%20%60.%60%20in%20%60rbmap%60%27s%20definition%3F/near/178536904" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/05243Whatisthatinrbmapsdefinition.html#178536904">Mario Carneiro (Oct 19 2019 at 09:01)</a>:</h4>
<p>A similar thing happens with <code>opt_param</code>, if you write <code>(x : foo := val)</code></p>

<a name="178537288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20is%20that%20%60.%60%20in%20%60rbmap%60%27s%20definition%3F/near/178537288" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/05243Whatisthatinrbmapsdefinition.html#178537288">Marko Grdinić (Oct 19 2019 at 09:12)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">mem</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">rbnode</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">a</span> <span class="n">leaf</span>               <span class="o">:=</span> <span class="n">false</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">(</span><span class="n">red_node</span> <span class="n">l</span> <span class="n">v</span> <span class="n">r</span><span class="o">)</span>   <span class="o">:=</span> <span class="n">mem</span> <span class="n">a</span> <span class="n">l</span> <span class="bp">∨</span> <span class="o">(</span><span class="bp">¬</span> <span class="n">lt</span> <span class="n">a</span> <span class="n">v</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">lt</span> <span class="n">v</span> <span class="n">a</span><span class="o">)</span> <span class="bp">∨</span> <span class="n">mem</span> <span class="n">a</span> <span class="n">r</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">(</span><span class="n">black_node</span> <span class="n">l</span> <span class="n">v</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span> <span class="n">mem</span> <span class="n">a</span> <span class="n">l</span> <span class="bp">∨</span> <span class="o">(</span><span class="bp">¬</span> <span class="n">lt</span> <span class="n">a</span> <span class="n">v</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">lt</span> <span class="n">v</span> <span class="n">a</span><span class="o">)</span> <span class="bp">∨</span> <span class="n">mem</span> <span class="n">a</span> <span class="n">r</span>
</pre></div>


<p>Would it be worth it to change the above implementation of <code>mem</code> to the following one?</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">mem</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">rbnode</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">a</span> <span class="n">leaf</span>               <span class="o">:=</span> <span class="n">false</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">(</span><span class="n">red_node</span> <span class="n">l</span> <span class="n">v</span> <span class="n">r</span><span class="o">)</span>   <span class="o">:=</span> <span class="o">(</span><span class="bp">¬</span> <span class="n">lt</span> <span class="n">a</span> <span class="n">v</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">lt</span> <span class="n">v</span> <span class="n">a</span><span class="o">)</span> <span class="bp">∨</span> <span class="n">mem</span> <span class="n">a</span> <span class="n">l</span> <span class="bp">∨</span> <span class="n">mem</span> <span class="n">a</span> <span class="n">r</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">(</span><span class="n">black_node</span> <span class="n">l</span> <span class="n">v</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">¬</span> <span class="n">lt</span> <span class="n">a</span> <span class="n">v</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">lt</span> <span class="n">v</span> <span class="n">a</span><span class="o">)</span> <span class="bp">∨</span> <span class="n">mem</span> <span class="n">a</span> <span class="n">l</span> <span class="bp">∨</span> <span class="n">mem</span> <span class="n">a</span> <span class="n">r</span>
</pre></div>


<p>I am surprised it has not been done like this originally. Rather than traversing the left side of the tree first, it would be better to check immediately whether the element is a match and shortcut the search if it is.</p>

<a name="178552539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20is%20that%20%60.%60%20in%20%60rbmap%60%27s%20definition%3F/near/178552539" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/05243Whatisthatinrbmapsdefinition.html#178552539">Kenny Lau (Oct 19 2019 at 16:13)</a>:</h4>
<p><code>or</code> does not short circuit in Lean</p>

<a name="178552674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20is%20that%20%60.%60%20in%20%60rbmap%60%27s%20definition%3F/near/178552674" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/05243Whatisthatinrbmapsdefinition.html#178552674">Mario Carneiro (Oct 19 2019 at 16:17)</a>:</h4>
<p>The implementation of rbmaps in core is... not good. You should probably not literally reuse it, but adapt it to your purposes if you like. There is an <code>ordmap</code> branch on mathlib with a faster implementation, but it's not completely proven correct yet</p>

<a name="178552716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20is%20that%20%60.%60%20in%20%60rbmap%60%27s%20definition%3F/near/178552716" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/05243Whatisthatinrbmapsdefinition.html#178552716">Mario Carneiro (Oct 19 2019 at 16:18)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> , <code>or</code> does short circuit because of the decidable instance</p>

<a name="178555560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20is%20that%20%60.%60%20in%20%60rbmap%60%27s%20definition%3F/near/178555560" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/05243Whatisthatinrbmapsdefinition.html#178555560">Floris van Doorn (Oct 19 2019 at 17:36)</a>:</h4>
<p>here is an example that shows <code>or</code> does short circuit:</p>
<div class="codehilite"><pre><span></span><span class="bp">#</span><span class="n">reduce</span> <span class="k">if</span> <span class="n">true</span> <span class="bp">∨</span> <span class="o">(</span><span class="bp">@</span><span class="n">to_bool</span> <span class="n">false</span> <span class="err">$</span> <span class="n">classical</span><span class="bp">.</span><span class="n">prop_decidable</span> <span class="bp">_</span><span class="o">)</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span>
</pre></div>

<a name="178594535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20is%20that%20%60.%60%20in%20%60rbmap%60%27s%20definition%3F/near/178594535" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/05243Whatisthatinrbmapsdefinition.html#178594535">Marko Grdinić (Oct 20 2019 at 13:57)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">prelude</span>
<span class="kn">import</span> <span class="n">init</span><span class="bp">.</span><span class="n">data</span><span class="bp">.</span><span class="n">rbtree</span>
<span class="kn">import</span> <span class="n">init</span><span class="bp">.</span><span class="n">data</span><span class="bp">.</span><span class="n">rbtree</span><span class="bp">.</span><span class="n">basic</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">library_search</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span>

<span class="n">def</span> <span class="n">drbmap_lt</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">(</span><span class="n">lt</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="err">Σ</span> <span class="n">α</span><span class="o">,</span> <span class="n">β</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">lt</span> <span class="n">a</span><span class="bp">.</span><span class="mi">1</span> <span class="n">b</span><span class="bp">.</span><span class="mi">1</span>

<span class="kn">set_option</span> <span class="n">auto_param</span><span class="bp">.</span><span class="n">check_exists</span> <span class="n">false</span>

<span class="n">def</span> <span class="n">drbmap</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">lt</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="bp">.</span> <span class="n">rbtree</span><span class="bp">.</span><span class="n">default_lt</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">rbtree</span> <span class="o">(</span><span class="err">Σ</span> <span class="n">α</span><span class="o">,</span> <span class="n">β</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">drbmap_lt</span> <span class="n">lt</span><span class="o">)</span>

<span class="n">def</span> <span class="n">mk_drbmap</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">lt</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="bp">.</span> <span class="n">rbtree</span><span class="bp">.</span><span class="n">default_lt</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">rbtree</span> <span class="o">(</span><span class="err">Σ</span> <span class="n">α</span><span class="o">,</span> <span class="n">β</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">drbmap_lt</span> <span class="n">lt</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">drbmap</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">δ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">}</span> <span class="o">{</span><span class="n">lt</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>

<span class="n">def</span> <span class="n">empty</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">drbmap</span> <span class="n">α</span> <span class="n">β</span> <span class="n">lt</span><span class="o">)</span> <span class="o">:</span> <span class="n">bool</span> <span class="o">:=</span>
<span class="n">m</span><span class="bp">.</span><span class="n">empty</span>

<span class="n">def</span> <span class="n">to_list</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">drbmap</span> <span class="n">α</span> <span class="n">β</span> <span class="n">lt</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="err">Σ</span> <span class="n">α</span><span class="o">,</span> <span class="n">β</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">m</span><span class="bp">.</span><span class="n">to_list</span>

<span class="n">def</span> <span class="n">min</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">drbmap</span> <span class="n">α</span> <span class="n">β</span> <span class="n">lt</span><span class="o">)</span> <span class="o">:</span> <span class="n">option</span> <span class="o">(</span><span class="err">Σ</span> <span class="n">α</span><span class="o">,</span> <span class="n">β</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">m</span><span class="bp">.</span><span class="n">min</span>

<span class="n">def</span> <span class="n">max</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">drbmap</span> <span class="n">α</span> <span class="n">β</span> <span class="n">lt</span><span class="o">)</span> <span class="o">:</span> <span class="n">option</span> <span class="o">(</span><span class="err">Σ</span> <span class="n">α</span><span class="o">,</span> <span class="n">β</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">m</span><span class="bp">.</span><span class="n">max</span>

<span class="n">def</span> <span class="n">fold</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">β</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">δ</span> <span class="bp">→</span> <span class="n">δ</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">drbmap</span> <span class="n">α</span> <span class="n">β</span> <span class="n">lt</span><span class="o">)</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">δ</span><span class="o">)</span> <span class="o">:</span> <span class="n">δ</span> <span class="o">:=</span>
<span class="n">m</span><span class="bp">.</span><span class="n">fold</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="n">f</span> <span class="n">e</span><span class="bp">.</span><span class="mi">1</span> <span class="n">e</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span> <span class="n">d</span>

<span class="n">def</span> <span class="n">rev_fold</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">β</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">δ</span> <span class="bp">→</span> <span class="n">δ</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">drbmap</span> <span class="n">α</span> <span class="n">β</span> <span class="n">lt</span><span class="o">)</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">δ</span><span class="o">)</span> <span class="o">:</span> <span class="n">δ</span> <span class="o">:=</span>
<span class="n">m</span><span class="bp">.</span><span class="n">rev_fold</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="n">f</span> <span class="n">e</span><span class="bp">.</span><span class="mi">1</span> <span class="n">e</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span> <span class="n">d</span>

<span class="kn">private</span> <span class="n">def</span> <span class="n">mem&#39;</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">rbnode</span> <span class="o">(</span><span class="err">Σ</span> <span class="n">α</span><span class="o">,</span> <span class="n">β</span> <span class="n">α</span><span class="o">)),</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">rbnode</span><span class="bp">.</span><span class="n">leaf</span>           <span class="o">:=</span> <span class="n">false</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">rbnode</span><span class="bp">.</span><span class="n">red_node</span> <span class="n">l</span> <span class="bp">⟨</span> <span class="n">v</span><span class="o">,</span> <span class="bp">_</span> <span class="bp">⟩</span>  <span class="n">r</span><span class="o">)</span>  <span class="o">:=</span> <span class="o">(</span><span class="bp">¬</span> <span class="n">lt</span> <span class="n">a</span> <span class="n">v</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">lt</span> <span class="n">v</span> <span class="n">a</span><span class="o">)</span> <span class="bp">∨</span> <span class="n">mem&#39;</span> <span class="n">l</span> <span class="bp">∨</span> <span class="n">mem&#39;</span> <span class="n">r</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">rbnode</span><span class="bp">.</span><span class="n">black_node</span> <span class="n">l</span> <span class="bp">⟨</span> <span class="n">v</span><span class="o">,</span> <span class="bp">_</span> <span class="bp">⟩</span>  <span class="n">r</span><span class="o">)</span>  <span class="o">:=</span> <span class="o">(</span><span class="bp">¬</span> <span class="n">lt</span> <span class="n">a</span> <span class="n">v</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">lt</span> <span class="n">v</span> <span class="n">a</span><span class="o">)</span> <span class="bp">∨</span> <span class="n">mem&#39;</span> <span class="n">l</span> <span class="bp">∨</span> <span class="n">mem&#39;</span> <span class="n">r</span>

<span class="n">def</span> <span class="n">mem</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">drbmap</span> <span class="n">α</span> <span class="n">β</span> <span class="n">lt</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">mem&#39;</span> <span class="n">α</span> <span class="n">β</span> <span class="n">lt</span> <span class="n">k</span> <span class="n">m</span><span class="bp">.</span><span class="n">val</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_mem</span> <span class="n">α</span> <span class="o">(</span><span class="n">drbmap</span> <span class="n">α</span> <span class="n">β</span> <span class="n">lt</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">mem</span><span class="bp">⟩</span>

<span class="kn">instance</span> <span class="o">[</span><span class="n">has_repr</span> <span class="o">(</span><span class="err">Σ</span> <span class="n">α</span><span class="o">,</span> <span class="n">β</span> <span class="n">α</span><span class="o">)]</span> <span class="o">:</span> <span class="n">has_repr</span> <span class="o">(</span><span class="n">drbmap</span> <span class="n">α</span> <span class="n">β</span> <span class="n">lt</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">t</span><span class="o">,</span> <span class="s2">&quot;drbmap_of &quot;</span> <span class="bp">++</span> <span class="n">repr</span> <span class="n">t</span><span class="bp">.</span><span class="n">to_list</span><span class="bp">⟩</span>

<span class="n">def</span> <span class="n">drbmap_lt_dec</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">decidable_rel</span> <span class="n">lt</span><span class="o">]</span> <span class="o">:</span> <span class="n">decidable_rel</span> <span class="o">(</span><span class="bp">@</span><span class="n">drbmap_lt</span> <span class="n">α</span> <span class="n">β</span> <span class="n">lt</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">h</span> <span class="n">a</span><span class="bp">.</span><span class="mi">1</span> <span class="n">b</span><span class="bp">.</span><span class="mi">1</span>

<span class="kn">variable</span> <span class="o">[</span><span class="n">decidable_rel</span> <span class="n">lt</span><span class="o">]</span>

<span class="n">def</span> <span class="n">insert</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">drbmap</span> <span class="n">α</span> <span class="n">β</span> <span class="n">lt</span><span class="o">)</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">β</span> <span class="n">k</span><span class="o">)</span> <span class="o">:</span> <span class="n">drbmap</span> <span class="n">α</span> <span class="n">β</span> <span class="n">lt</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">rbtree</span><span class="bp">.</span><span class="n">insert</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">drbmap_lt_dec</span> <span class="n">m</span> <span class="bp">⟨</span> <span class="n">k</span><span class="o">,</span> <span class="n">v</span> <span class="bp">⟩</span>
</pre></div>


<p>Here is what I did so far. However the <code>find</code> function is giving me some trouble.</p>
<div class="codehilite"><pre><span></span><span class="kn">private</span> <span class="n">def</span> <span class="n">find</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">rbnode</span> <span class="o">(</span><span class="err">Σ</span> <span class="n">α</span><span class="o">,</span> <span class="n">β</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">option</span> <span class="o">(</span><span class="n">β</span> <span class="n">k</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">rbnode</span><span class="bp">.</span><span class="n">leaf</span>             <span class="o">:=</span> <span class="n">none</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">rbnode</span><span class="bp">.</span><span class="n">red_node</span> <span class="n">a</span> <span class="n">k&#39;</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">if</span> <span class="n">h_lt</span> <span class="o">:</span> <span class="n">lt</span> <span class="n">k</span> <span class="n">k&#39;</span><span class="bp">.</span><span class="mi">1</span> <span class="k">then</span> <span class="n">find</span> <span class="n">a</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">h_gt</span> <span class="o">:</span> <span class="n">lt</span> <span class="n">k&#39;</span><span class="bp">.</span><span class="mi">1</span> <span class="n">k</span> <span class="k">then</span> <span class="n">find</span> <span class="n">b</span>
    <span class="k">else</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">some</span> <span class="n">k&#39;</span><span class="bp">.</span><span class="mi">2</span> <span class="k">in</span>
        <span class="k">have</span> <span class="n">h_eq</span> <span class="o">:</span> <span class="n">k&#39;</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">=</span> <span class="n">k</span><span class="o">,</span> <span class="k">by</span> <span class="n">sorry</span><span class="o">,</span>
        <span class="k">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">h_eq</span> <span class="n">at</span> <span class="n">x</span><span class="o">,</span> <span class="k">from</span> <span class="n">x</span> <span class="o">}</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">rbnode</span><span class="bp">.</span><span class="n">black_node</span> <span class="n">a</span> <span class="n">k&#39;</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">if</span> <span class="n">h_lt</span> <span class="o">:</span> <span class="n">lt</span> <span class="n">k</span> <span class="n">k&#39;</span><span class="bp">.</span><span class="mi">1</span> <span class="k">then</span> <span class="n">find</span> <span class="n">a</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">h_gt</span> <span class="o">:</span> <span class="n">lt</span> <span class="n">k&#39;</span><span class="bp">.</span><span class="mi">1</span> <span class="n">k</span> <span class="k">then</span> <span class="n">find</span> <span class="n">b</span>
    <span class="k">else</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">some</span> <span class="n">k&#39;</span><span class="bp">.</span><span class="mi">2</span> <span class="k">in</span>
        <span class="k">have</span> <span class="n">h_eq</span> <span class="o">:</span> <span class="n">k&#39;</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">=</span> <span class="n">k</span><span class="o">,</span> <span class="k">by</span> <span class="n">sorry</span><span class="o">,</span>
        <span class="k">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">h_eq</span> <span class="n">at</span> <span class="n">x</span><span class="o">,</span> <span class="k">from</span> <span class="n">x</span> <span class="o">}</span>
</pre></div>


<p>I have that <code>~ k &lt; k'.1 /\ ~ k'.1 &lt; k</code>, so I should be able to prove that <code>k = k'.1</code>, but I am not sure how to do that. Any idea of how I should approach this?</p>

<a name="178595417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20is%20that%20%60.%60%20in%20%60rbmap%60%27s%20definition%3F/near/178595417" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/05243Whatisthatinrbmapsdefinition.html#178595417">Marko Grdinić (Oct 20 2019 at 14:27)</a>:</h4>
<hr>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">to_value</span> <span class="o">:</span> <span class="n">option</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">β</span>
<span class="bp">|</span> <span class="n">none</span>     <span class="o">:=</span> <span class="n">none</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">some</span> <span class="n">e</span><span class="o">)</span> <span class="o">:=</span> <span class="n">some</span> <span class="n">e</span><span class="bp">.</span><span class="mi">2</span>
</pre></div>


<p>The last issue that I have before I am done with generalizing the <code>rbmap</code> is to figure out what to do with <code>to_value</code>. Here is how it was originally. If the tuple is replaced by a sigma type then the definition should be something like the following...</p>
<p><code>def to_value : option (Σ α, β α) → option _</code></p>
<p>What should that wildcard be here? Is it even possible to do anything here? I think there probably isn't as the type of the value depends on the key now, but I am not completely sure so I'll ask here.</p>

<a name="178636345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20is%20that%20%60.%60%20in%20%60rbmap%60%27s%20definition%3F/near/178636345" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/05243Whatisthatinrbmapsdefinition.html#178636345">Marko Grdinić (Oct 21 2019 at 08:46)</a>:</h4>
<p>With regard to my <code>find</code> questions, after some thinking I've come to the conclusion that there is no way that both sides of <code>lt</code> being false would mean that propositional equality must be true. <code>lt</code> can be anything and can for example compare only part of a key. So with that in mind, the right implementation would be...</p>
<div class="codehilite"><pre><span></span><span class="kn">private</span> <span class="n">def</span> <span class="n">find</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">rbnode</span> <span class="o">(</span><span class="err">Σ</span> <span class="n">α</span><span class="o">,</span> <span class="n">β</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">option</span> <span class="o">(</span><span class="err">Σ</span> <span class="n">α</span><span class="o">,</span> <span class="n">β</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">rbnode</span><span class="bp">.</span><span class="n">leaf</span>             <span class="o">:=</span> <span class="n">none</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">rbnode</span><span class="bp">.</span><span class="n">red_node</span> <span class="n">a</span> <span class="n">k&#39;</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">if</span> <span class="n">lt</span> <span class="n">k</span> <span class="n">k&#39;</span><span class="bp">.</span><span class="mi">1</span> <span class="k">then</span> <span class="n">find</span> <span class="n">a</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">lt</span> <span class="n">k&#39;</span><span class="bp">.</span><span class="mi">1</span> <span class="n">k</span> <span class="k">then</span> <span class="n">find</span> <span class="n">b</span>
    <span class="k">else</span> <span class="n">k&#39;</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">rbnode</span><span class="bp">.</span><span class="n">black_node</span> <span class="n">a</span> <span class="n">k&#39;</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">if</span> <span class="n">lt</span> <span class="n">k</span> <span class="n">k&#39;</span><span class="bp">.</span><span class="mi">1</span> <span class="k">then</span> <span class="n">find</span> <span class="n">a</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">lt</span> <span class="n">k&#39;</span><span class="bp">.</span><span class="mi">1</span> <span class="n">k</span> <span class="k">then</span> <span class="n">find</span> <span class="n">b</span>
    <span class="k">else</span> <span class="n">k&#39;</span>

<span class="n">def</span> <span class="n">find_entry</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">drbmap</span> <span class="n">α</span> <span class="n">β</span> <span class="n">lt</span><span class="o">)</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">option</span> <span class="o">(</span><span class="err">Σ</span> <span class="n">α</span><span class="o">,</span> <span class="n">β</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">find</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">lt</span> <span class="bp">_</span> <span class="n">k</span> <span class="n">m</span><span class="bp">.</span><span class="n">val</span>
</pre></div>


<p>With this finishing the rest of the module is easy.</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">contains</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">drbmap</span> <span class="n">α</span> <span class="n">β</span> <span class="n">lt</span><span class="o">)</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">bool</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">find_entry</span> <span class="n">m</span> <span class="n">k</span><span class="o">)</span><span class="bp">.</span><span class="n">is_some</span>

<span class="n">def</span> <span class="n">from_list</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="err">Σ</span> <span class="n">α</span><span class="o">,</span> <span class="n">β</span> <span class="n">α</span><span class="o">))</span> <span class="o">(</span><span class="n">lt</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="bp">.</span> <span class="n">rbtree</span><span class="bp">.</span><span class="n">default_lt</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_rel</span> <span class="n">lt</span><span class="o">]</span> <span class="o">:</span> <span class="n">drbmap</span> <span class="n">α</span> <span class="n">β</span> <span class="n">lt</span> <span class="o">:=</span>
<span class="n">l</span><span class="bp">.</span><span class="n">foldl</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">m</span> <span class="n">p</span><span class="o">,</span> <span class="n">insert</span> <span class="n">m</span> <span class="n">p</span><span class="bp">.</span><span class="mi">1</span> <span class="n">p</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span>  <span class="o">(</span><span class="n">mk_drbmap</span> <span class="n">α</span> <span class="n">β</span> <span class="n">lt</span><span class="o">)</span>

<span class="kn">end</span> <span class="n">drbmap</span>

<span class="n">def</span> <span class="n">drbmap_of</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="err">Σ</span> <span class="n">α</span><span class="o">,</span> <span class="n">β</span> <span class="n">α</span><span class="o">))</span> <span class="o">(</span><span class="n">lt</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="bp">.</span> <span class="n">rbtree</span><span class="bp">.</span><span class="n">default_lt</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_rel</span> <span class="n">lt</span><span class="o">]</span> <span class="o">:</span> <span class="n">drbmap</span> <span class="n">α</span> <span class="n">β</span> <span class="n">lt</span> <span class="o">:=</span>
<span class="n">drbmap</span><span class="bp">.</span><span class="n">from_list</span> <span class="n">l</span> <span class="n">lt</span>
</pre></div>

<a name="179116754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20is%20that%20%60.%60%20in%20%60rbmap%60%27s%20definition%3F/near/179116754" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/05243Whatisthatinrbmapsdefinition.html#179116754">Marko Grdinić (Oct 26 2019 at 08:54)</a>:</h4>
<p>As it turns out,  these red black trees not being able to understand that the key being put in is the same as the one being taken out when doing indexing into them is a lot bigger problem than I thought at first. With dependent types, that means that it can no longer reduce based on the key and it is causing me all sorts of issues downstream.</p>
<p>These trees are useless as they are now. I'd recommend avoiding them in favor of something that uses direct equality.</p>

<a name="179118367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20is%20that%20%60.%60%20in%20%60rbmap%60%27s%20definition%3F/near/179118367" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/05243Whatisthatinrbmapsdefinition.html#179118367">Marko Grdinić (Oct 26 2019 at 09:45)</a>:</h4>
<p>Alternatively, it might be worth rewriting the above to use some kind of decidable trichotomy.</p>


{% endraw %}

{% include archive_update.html %}