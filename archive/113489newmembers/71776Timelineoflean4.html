---
layout: archive
title: Lean Prover Zulip Chat Archive 
permalink: archive/113489newmembers/71776Timelineoflean4.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html">Timeline of lean 4?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="128716259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128716259" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128716259">HT (Jun 27 2018 at 13:41)</a>:</h4>
<p>Hi, when would lean 4 's repo be public?</p>

<a name="128716334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128716334" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128716334">Patrick Massot (Jun 27 2018 at 13:42)</a>:</h4>
<p>I don't think anyone on earth has an answer to that question.</p>

<a name="128716345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128716345" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128716345">Patrick Massot (Jun 27 2018 at 13:43)</a>:</h4>
<p>Leo and Sebastian are working, and they need time and peace.</p>

<a name="128716360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128716360" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128716360">Patrick Massot (Jun 27 2018 at 13:43)</a>:</h4>
<p>We enjoy Lean 3 in the meantime.</p>

<a name="128716416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128716416" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128716416">Patrick Massot (Jun 27 2018 at 13:44)</a>:</h4>
<p>And Sean plays with emojis</p>

<a name="128716447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128716447" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128716447">Patrick Massot (Jun 27 2018 at 13:45)</a>:</h4>
<p>I can see this question wakes up many more people than inverting a partially injective function</p>

<a name="128716928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128716928" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128716928">HT (Jun 27 2018 at 13:54)</a>:</h4>
<p>From programmer's aspect, C++ code generator and FFI is a bigger deal. I could see potential.</p>

<a name="128717060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128717060" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128717060">Simon Hudon (Jun 27 2018 at 13:57)</a>:</h4>
<p>In the mean time, how comfortable are you with Lean?</p>

<a name="128717111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128717111" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128717111">Sean Leather (Jun 27 2018 at 13:58)</a>:</h4>
<p>We're hoping that we can to translate all of the work and knowledge that has gone into Lean 3 code into Lean 4 code, when the latter comes out. So, you could start working with Lean 3 now with that in mind. Otherwise, you may have to wait for an indeterminate time.</p>

<a name="128717168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128717168" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128717168">Simon Hudon (Jun 27 2018 at 13:59)</a>:</h4>
<p>I think it's safe to say that Lean 4 will be based on dependent type theory and make a similar use of functions and type classes so those are certainly worth knowing about even if their syntax changes</p>

<a name="128717396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128717396" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128717396">HT (Jun 27 2018 at 14:03)</a>:</h4>
<p><span class="user-mention" data-user-id="110026">@Simon Hudon</span> It's the most clean and flexble one. It has best chance to unify programming and math.</p>

<a name="128717509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128717509" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128717509">Simon Hudon (Jun 27 2018 at 14:06)</a>:</h4>
<p>To be fair, this unification is already happening. Coq has taken us a long way and so has Isabelle. Chances are that Lean will be another stepping stone in that lengthy process</p>

<a name="128718000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128718000" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128718000">HT (Jun 27 2018 at 14:16)</a>:</h4>
<p>Those two looks like lots of math proving steps, it don't make sense to me. Lean and Fstar looks more like functional programming.</p>

<a name="128718026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128718026" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128718026">Patrick Massot (Jun 27 2018 at 14:17)</a>:</h4>
<p>Lean looks like math much more than Coq (simply thanks to unicode use and less esoteric notations)</p>

<a name="128718083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128718083" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128718083">Sean Leather (Jun 27 2018 at 14:18)</a>:</h4>
<p>In Lean, using tactics is, as in Coq, like proving steps in math.</p>

<a name="128718097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128718097" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128718097">Reid Barton (Jun 27 2018 at 14:18)</a>:</h4>
<p>My impression is that people don't really use term mode in Coq, is that right?</p>

<a name="128718175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128718175" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128718175">Sean Leather (Jun 27 2018 at 14:20)</a>:</h4>
<p>I've never seen it in any Coq tutorial.</p>

<a name="128718179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128718179" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128718179">Simon Hudon (Jun 27 2018 at 14:20)</a>:</h4>
<blockquote>
<p>My impression is that people don't really use term mode in Coq, is that right?</p>
</blockquote>
<p>It's also my impression. The syntax of term mode is not geared for writing proofs</p>

<a name="128718442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128718442" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128718442">HT (Jun 27 2018 at 14:26)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> Lean also looks like programming more than Coq at the same time.</p>

<a name="128719177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128719177" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128719177">HT (Jun 27 2018 at 14:41)</a>:</h4>
<p>On the other hand, Coq makes no sense to low level programming. Lean has potential to prevent flaming chips and overflows.</p>

<a name="128719268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128719268" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128719268">Simon Hudon (Jun 27 2018 at 14:43)</a>:</h4>
<p>Why do you say that Coq makes no sense to low level programming?</p>

<a name="128719380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128719380" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128719380">Reid Barton (Jun 27 2018 at 14:45)</a>:</h4>
<blockquote>
<blockquote>
<p>My impression is that people don't really use term mode in Coq, is that right?</p>
</blockquote>
<p>It's also my impression. The syntax of term mode is not geared for writing proofs</p>
</blockquote>
<p>Oh I see, I had a hidden assumption in my mind "for doing math".</p>

<a name="128719561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128719561" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128719561">HT (Jun 27 2018 at 14:49)</a>:</h4>
<p>Coq don't generates C which POSIX is defined by, and had a huge irreducible runtime with gc that could fulfill memory.</p>

<a name="128719610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128719610" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128719610">Simon Hudon (Jun 27 2018 at 14:50)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span>  I don't understand what your addition changes</p>

<a name="128719721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128719721" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128719721">Simon Hudon (Jun 27 2018 at 14:52)</a>:</h4>
<p><span class="user-mention" data-user-id="120163">@HT</span>  Coq has most of the major low-level verification frameworks that I know of.  I don't know if they prefer parsing C or generating C but a lot of low-level verification is done with Coq. See Iris, Bedrock and VST</p>

<a name="128719984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128719984" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128719984">HT (Jun 27 2018 at 14:59)</a>:</h4>
<p><span class="user-mention" data-user-id="110026">@Simon Hudon</span> They actually make developers less productive because of extra barriers. At least four languages involved in, EDSL to generate C , C, Coq, OCaml.</p>

<a name="128720069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128720069" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128720069">Reid Barton (Jun 27 2018 at 15:00)</a>:</h4>
<p>I assume people do use term mode for programming (e.g., for program extraction)?</p>

<a name="128720102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128720102" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128720102">HT (Jun 27 2018 at 15:01)</a>:</h4>
<p>When bugs wasn't catched by types, debugging must includes huge runtime with gc, edsl, coq, ocaml.</p>

<a name="128720187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128720187" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128720187">Simon Hudon (Jun 27 2018 at 15:03)</a>:</h4>
<p>If I understand you correctly, what your getting at is better tools. It's not about low-level programming. It's about being productive as programmers</p>

<a name="128720302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128720302" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128720302">HT (Jun 27 2018 at 15:05)</a>:</h4>
<p><span class="user-mention" data-user-id="110026">@Simon Hudon</span> Yes, Coq costs too much. I'm not sure why it's not about low-level programming, high level programming seldom encounters problems caused by runtime.</p>

<a name="128720726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128720726" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128720726">Simon Hudon (Jun 27 2018 at 15:13)</a>:</h4>
<p>Your initial statement was "[it] doesn't make sense to low level programming". Is that still what you're arguing? If so, I argue that the frameworks I mentioned help understand low level programming.</p>

<a name="128720823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128720823" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128720823">Simon Hudon (Jun 27 2018 at 15:15)</a>:</h4>
<p>Or maybe I should understand your point as being "it is difficult to use in low-level settings because of its awkward tools". In that case, I should agree. I haven't tried the frameworks in that context but it is consistent with my (small) experience with Coq</p>

<a name="128721112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128721112" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128721112">HT (Jun 27 2018 at 15:19)</a>:</h4>
<p>To be more clear, I mean it doesn't make sense for programmers to cost so much barriers to correct code.</p>

<a name="128721403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128721403" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128721403">Simon Hudon (Jun 27 2018 at 15:25)</a>:</h4>
<p>To be honest, that does not clarify your statement for me. It sounds like you're saying that a heavy run-time is one too many hurdles towards obtaining correct code.</p>

<a name="128721496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128721496" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128721496">HT (Jun 27 2018 at 15:27)</a>:</h4>
<p>That's one point. And the other is there's too many concepts compounded in a inconsistent way.</p>

<a name="128721558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128721558" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128721558">Simon Hudon (Jun 27 2018 at 15:28)</a>:</h4>
<p>Do you have an example to illustrate that point?</p>

<a name="128722051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128722051" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128722051">HT (Jun 27 2018 at 15:39)</a>:</h4>
<p>I got an example. <a href="https://gitlab.mpi-sws.org/FP/iris-coq/blob/master/theories/program_logic/hoare.v" target="_blank" title="https://gitlab.mpi-sws.org/FP/iris-coq/blob/master/theories/program_logic/hoare.v">https://gitlab.mpi-sws.org/FP/iris-coq/blob/master/theories/program_logic/hoare.v</a></p>

<a name="128722108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128722108" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128722108">HT (Jun 27 2018 at 15:40)</a>:</h4>
<p>Why do we need hoare logic if everything could be proved in dependent type?</p>

<a name="128722327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128722327" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128722327">HT (Jun 27 2018 at 15:44)</a>:</h4>
<p>I can not imagine I can convince any low level programmers costs so much time to learn several different theories nested in dependent types and three kinds of syntax, ocaml, coq, edsl, to start programming correct code.</p>

<a name="128722390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128722390" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128722390">Simon Hudon (Jun 27 2018 at 15:45)</a>:</h4>
<p>Those are separate things. Hoare logic is formulated in dependent types. And dependent types by themselves are not sufficient, you need program semantics and verification rules. Particularly in the case of low-level code, the most effective tool around is separation logic which is formulated as a Hoare logic. The whole thing is still couched on a dependent type theory. The same way you wouldn't use a programming language without libraries, you can't use a logic without a certain number of basic theory</p>

<a name="128722454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128722454" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128722454">Simon Hudon (Jun 27 2018 at 15:46)</a>:</h4>
<p>If you have something better than separation logic for low-level pointer reasoning, you should publish it. It's going to be worth a lot</p>

<a name="128722855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128722855" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128722855">Simon Hudon (Jun 27 2018 at 15:54)</a>:</h4>
<p>As for convincing people, it doesn't have to be all or nothing, there are middle grounds, gateway drugs if you want, where very little effort yields a great benefit. TLA+ for example is tremendous if you want to learn formal specifications and use them in a project. With its model checker, you get a great benefit from any degree of formalization that you care to go through. In some cases, that can be enough. In others,  you want a full functional proof of correctness. Then you have to invest time. Lean is not going to be a magic bullet any more than Coq is. With a wider community in the industry and in academia using formal proof, with can decrease the burden of writing formal proofs for sure but it's an ongoing process. Most importantly, it happens with people trying the tools, finding them lacking and adding their two cents</p>

<a name="128722868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128722868" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128722868">Patrick Massot (Jun 27 2018 at 15:54)</a>:</h4>
<p>I have good news for the Lean 4 timeline. It seems Sebastian will not waste time watching his country playing in the world cup.</p>

<a name="128722890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128722890" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128722890">HT (Jun 27 2018 at 15:55)</a>:</h4>
<p><span class="user-mention" data-user-id="110026">@Simon Hudon</span> I may be wrong, I though linear type reduce the use of pointers like rust does. We just need to seperate different kind of resources in types.</p>

<a name="128722996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128722996" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128722996">Patrick Massot (Jun 27 2018 at 15:57)</a>:</h4>
<p>Brazil is still in though.</p>

<a name="128723118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128723118" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128723118">Simon Hudon (Jun 27 2018 at 15:59)</a>:</h4>
<p>That's true and linear types are one of the tools that I'm mentioning. But the operating word here is "reduce". Reducing the use of separation logic is a great achievement. But with Iris project, we see that as long as you use unsafe code in libraries, you will need to use a least a little bit of separation logic to verify them.</p>

<a name="128723182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128723182" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128723182">Sebastian Ullrich (Jun 27 2018 at 16:00)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> Today's events did not change anything in that regard :P</p>

<a name="128724356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128724356" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128724356">HT (Jun 27 2018 at 16:20)</a>:</h4>
<p>I hope my point is clear, to write code fast and correct. Lean looks so handy to make most of the logic proved without much barriers. If I still needs something not covered by types, I'd write tests rather than involving additional layers of theories.</p>

<a name="128724490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128724490" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128724490">Simon Hudon (Jun 27 2018 at 16:23)</a>:</h4>
<p>I agree in parts with your point. Lean and its tools are looking more and more like an IDE. You can use them to write programs without proofs, you can import various packages with varying levels of verification. You can be deterred by adding new logics to your system but making them available means that, when you decide that they're worth it, you can just reach for them.</p>

<a name="128724899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128724899" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128724899">HT (Jun 27 2018 at 16:31)</a>:</h4>
<p><span class="user-mention" data-user-id="110026">@Simon Hudon</span> Yes, that's what I expect, a programming language.</p>

<a name="128724971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128724971" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128724971">Simon Hudon (Jun 27 2018 at 16:32)</a>:</h4>
<p>Glad we found a common ground. I think compared to Idris (which might also fit your criteria), Lean is a better prover</p>

<a name="128725149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128725149" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128725149">HT (Jun 27 2018 at 16:36)</a>:</h4>
<p>I also think Lean is better in a consistent way. I feel something wrong with Idris but I'm not sure what it is.</p>

<a name="128725744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128725744" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128725744">HT (Jun 27 2018 at 16:48)</a>:</h4>
<p>It makes me feel that Idris is a variant of Haskell injected with extra type ability inconsistently which actually causes bugs rather than an actual type theory like Lean.</p>

<a name="128759773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128759773" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128759773">Sean Leather (Jun 28 2018 at 07:48)</a>:</h4>
<p>I previously <a href="#narrow/stream/113489-new-members/subject/Timeline.20of.20lean.204.3F/near/128717111" title="#narrow/stream/113489-new-members/subject/Timeline.20of.20lean.204.3F/near/128717111">wrote</a>:</p>
<blockquote>
<p>We're hoping that we can to translate all of the work and knowledge that has gone into Lean 3 code into Lean 4 code, when the latter comes out. So, you could start working with Lean 3 now with that in mind. Otherwise, you may have to wait for an indeterminate time.</p>
</blockquote>
<p>Simon <a href="#narrow/stream/113489-new-members/subject/Timeline.20of.20lean.204.3F/near/128717168" title="#narrow/stream/113489-new-members/subject/Timeline.20of.20lean.204.3F/near/128717168">responded</a>:</p>
<blockquote>
<p>I think it's safe to say that Lean 4 will be based on dependent type theory and make a similar use of functions and type classes so those are certainly worth knowing about even if their syntax changes</p>
</blockquote>
<p>I agree with Simon, but I think there's a big difference between translating knowledge of basic concepts into an implementation (of which there are many: Coq, Agda, and Idris to name some popular ones) and translating an existing codebase and deep knowledge of one language into another.</p>
<p>The <a href="https://github.com/leanprover/lean/blob/ceacfa7445953cbc8860ddabc55407430a9ca5c3/doc/lean4.md" target="_blank" title="https://github.com/leanprover/lean/blob/ceacfa7445953cbc8860ddabc55407430a9ca5c3/doc/lean4.md">only public document</a> reflecting the Lean 4 plan (at least for when it was written) states:</p>
<blockquote>
<p>Users should not expect Lean 4 will be backward compatible with Lean 3.</p>
</blockquote>
<p>This is why I conservatively referred to “hope.” I think there is some risk of working in Lean 3 now if you wish to move to Lean 4 later. But I also think there is some confidence that Lean 4 will not be as radically different from Lean 3 as, say, Coq is from any version of Lean.</p>

<a name="128759878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Timeline%20of%20lean%204%3F/near/128759878" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/71776Timelineoflean4.html#128759878">Mario Carneiro (Jun 28 2018 at 07:52)</a>:</h4>
<p>I think considerably more than Simon's list of concepts will carry over to lean 4. I know that "the syntax will stay more or less the same" modulo some easy regex fixes, but the elaborator may also change (semi by accident, because it will be re-implemented in lean), and this may cause more subtle breakage</p>


{% endraw %}
