---
layout: archive
title: Lean Prover Zulip Chat Archive 
permalink: archive/113489newmembers/80390somethingisweird.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/80390somethingisweird.html">`some`thing is weird</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="148117675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60some%60thing%20is%20weird/near/148117675" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/80390somethingisweird.html#148117675">Abhimanyu Pallavi Sudhir (Nov 21 2018 at 15:35)</a>:</h4>
<p>I've been looking at the <code>classical.lean</code> file, and <code>p_implies_uv</code> strikes me as a very odd theorem. You have a proposition <code>p</code>, and you have two propositions, <code>u</code> which is <code>some</code> proposition such that it is true or <code>p</code> is true, and <code>v</code> which is <code>some</code> proposition such that it is false or <code>p</code> is true.  </p>
<p>But now you have <code>p_implies_uv</code>, which proves, apparently, that if <code>p</code> is true, <code>u = v</code>. I have no idea how this can be true. <code>u</code> and <code>v</code> can be <code>true</code> and <code>false</code>, for example -- having <code>p</code> be true does nothing to change this fact.</p>
<p>What's wrong with this? I'm guessing there's something wrong with my understanding of how <code>some</code> works.</p>

<a name="148118042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60some%60thing%20is%20weird/near/148118042" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/80390somethingisweird.html#148118042">Abhimanyu Pallavi Sudhir (Nov 21 2018 at 15:41)</a>:</h4>
<p>I'm reading the proof on <a href="https://en.wikipedia.org/wiki/Diaconescu%27s_theorem" target="_blank" title="https://en.wikipedia.org/wiki/Diaconescu%27s_theorem">wikipedia</a> -- and I can understand the set theoretic version.</p>

<a name="148118122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60some%60thing%20is%20weird/near/148118122" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/80390somethingisweird.html#148118122">Abhimanyu Pallavi Sudhir (Nov 21 2018 at 15:42)</a>:</h4>
<p>Or well, I can understand their version -- since U and V are sets in their version, all this means is that if P is true then <code>u</code> and <code>v</code> have the same range of possible values (<code>true</code>, <code>false</code>).</p>

<a name="148118128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60some%60thing%20is%20weird/near/148118128" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/80390somethingisweird.html#148118128">Jeremy Avigad (Nov 21 2018 at 15:42)</a>:</h4>
<p>The proof is described in detail here: <a href="https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html#the-law-of-the-excluded-middle" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html#the-law-of-the-excluded-middle">https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html#the-law-of-the-excluded-middle</a>. You are right that it is a weird proof, a clever trick rather than something deep.</p>
<p><code>some</code> works as follows: given <code>h : ∃ x : α, p x</code>, <code>some h</code> returns an <code>x</code> satisfying <code>p</code>.</p>

<a name="148118190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60some%60thing%20is%20weird/near/148118190" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/80390somethingisweird.html#148118190">Abhimanyu Pallavi Sudhir (Nov 21 2018 at 15:43)</a>:</h4>
<p>Yeah, I get that -- but if it just returns _an_ <code>x</code> satisfying <code>p</code>, does it really make sense to say two the two <code>some</code>s are equal?</p>

<a name="148118194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60some%60thing%20is%20weird/near/148118194" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/80390somethingisweird.html#148118194">Abhimanyu Pallavi Sudhir (Nov 21 2018 at 15:43)</a>:</h4>
<p>Oh wait, <code>some h = some h</code>.</p>

<a name="148118199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60some%60thing%20is%20weird/near/148118199" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/80390somethingisweird.html#148118199">Abhimanyu Pallavi Sudhir (Nov 21 2018 at 15:43)</a>:</h4>
<p>That's all that's going on.</p>

<a name="148118268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60some%60thing%20is%20weird/near/148118268" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/80390somethingisweird.html#148118268">Abhimanyu Pallavi Sudhir (Nov 21 2018 at 15:44)</a>:</h4>
<p>It doesn't mean that anything in <code>h</code> is equal to anything else in <code>h</code>, it just means a generic element in <code>h</code> is equal to a generic element in <code>h</code>.</p>

<a name="148118274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60some%60thing%20is%20weird/near/148118274" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/80390somethingisweird.html#148118274">Abhimanyu Pallavi Sudhir (Nov 21 2018 at 15:44)</a>:</h4>
<p>I see. Very weird, but I think I understand.</p>

<a name="148118750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60some%60thing%20is%20weird/near/148118750" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/80390somethingisweird.html#148118750">Jeremy Avigad (Nov 21 2018 at 15:51)</a>:</h4>
<p>Yes, <code>some</code> choose a particular though unspecified element with the given property. If <code>h₀ : ∃ x, odd x</code>, <code>some h₀</code> returns an odd number. If <code>h₁ : ∃ x, prime x</code>, <code>some h₁</code> returns a prime number. We can ask whether <code>some h₀ = some h₁</code>. In this case, Lean's axioms don't allow us to prove or refute this statement. But as you note, sometimes we can prove things about <code>some</code>. For example, if <code>h₂ : ∃ x, even x ∧ prime x</code>, we can prove <code>some h₂ = 2</code>, because <code>some h₂</code> has to be both even and prime. For another example, we can prove <code>even (some h₀ + 1)</code>, because we know <code>some h₀</code> is odd.</p>

<a name="148125215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60some%60thing%20is%20weird/near/148125215" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/80390somethingisweird.html#148125215">Abhimanyu Pallavi Sudhir (Nov 21 2018 at 17:29)</a>:</h4>
<blockquote>
<p>Yes, <code>some</code> choose a particular though unspecified element with the given property. If <code>h₀ : ∃ x, odd x</code>, <code>some h₀</code> returns an odd number. If <code>h₁ : ∃ x, prime x</code>, <code>some h₁</code> returns a prime number. We can ask whether <code>some h₀ = some h₁</code>. In this case, Lean's axioms don't allow us to prove or refute this statement. But as you note, sometimes we can prove things about <code>some</code>. For example, if <code>h₂ : ∃ x, even x ∧ prime x</code>, we can prove <code>some h₂ = 2</code>, because <code>some h₂</code> has to be both even and prime. For another example, we can prove <code>even (some h₀ + 1)</code>, because we know <code>some h₀</code> is odd.</p>
</blockquote>
<p>Those make sense. What wasn't making sense to me -- and is used in the Diaconescu proof -- is the fact that <code>some h = some h</code>, i.e.</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∨</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">2</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="mi">1</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="n">rfl</span><span class="bp">⟩</span>

<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">h1</span> <span class="o">:=</span> <span class="n">classical</span><span class="bp">.</span><span class="n">some</span> <span class="n">h</span>
<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">h2</span> <span class="o">:=</span> <span class="n">classical</span><span class="bp">.</span><span class="n">some</span> <span class="n">h</span>

<span class="kn">theorem</span> <span class="n">something</span> <span class="o">:</span> <span class="n">h1</span> <span class="bp">=</span> <span class="n">h2</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>


<p>Which is weird, because in my mind, <code>h1</code> and <code>h2</code> can still be either 1 or 2 -- all we know about them is that they satisfy "it's either 1 or 2", and not all things that are "either 1 or 2" are equal. </p>
<p>But I guess choice allows Lean to just have some concept of  "a general <code>some</code>" so that saying <code>h1 = h2</code> is really just extensionality on <code>some</code>.</p>

<a name="148135819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60some%60thing%20is%20weird/near/148135819" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/80390somethingisweird.html#148135819">Johannes Hölzl (Nov 21 2018 at 20:36)</a>:</h4>
<p>this is completely unrelated to <code>some</code>, it is just reflexivity of <code>=</code> in Lean (internally <code>h1</code> and <code>h2</code> are unfolded). It is not possible to have a <code>some</code> operator where this doesn't hold. With some tricks it is possible to hide this fact. By marking <code>h1</code> and/or <code>h2</code> as <code>@[irreducible]</code>. Then at least one cannot prove it <code>by refl</code> anymore (but it is still true in the logic)</p>

<a name="148136060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60some%60thing%20is%20weird/near/148136060" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/80390somethingisweird.html#148136060">Kevin Buzzard (Nov 21 2018 at 20:40)</a>:</h4>
<p>A function always produces the same output when presented with the same input.</p>


{% endraw %}
