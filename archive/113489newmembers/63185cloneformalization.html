---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/113489newmembers/63185cloneformalization.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/63185cloneformalization.html">clone formalization</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="136329846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/clone%20formalization/near/136329846" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/63185cloneformalization.html#136329846">Miroslav Olšák (Oct 23 2018 at 21:57)</a>:</h4>
<p>Hello everybody, we tried a testing formalization of a simple proposition about clones in several ITP's for comparison. LEAN seems pretty nice so far. However, I believe that there should be a better approach to certain parts the proof (if we just knew LEAN better).<br>
You can see the task description,  together with my complains (/ TODO) under the link.<br>
<a href="http://atrey.karlin.mff.cuni.cz/~mirecek/formal-math/clones.lean" target="_blank" title="http://atrey.karlin.mff.cuni.cz/~mirecek/formal-math/clones.lean">http://atrey.karlin.mff.cuni.cz/~mirecek/formal-math/clones.lean</a></p>

<a name="136331045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/clone%20formalization/near/136331045" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/63185cloneformalization.html#136331045">Johan Commelin (Oct 23 2018 at 22:28)</a>:</h4>
<p><span class="user-mention" data-user-id="133339">@Miroslav Olšák</span> I'm having trouble with certain symbols. I think unicode is being messed up or something. Could you post your code again with correct encoding? Maybe as a Github Gist, or something... (Don't know if you use github...)</p>

<a name="136334848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/clone%20formalization/near/136334848" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/63185cloneformalization.html#136334848">Bryan Gin-ge Chen (Oct 23 2018 at 23:53)</a>:</h4>
<p>In Firefox you can set the text encoding manually to unicode (View... Text Encoding...) and then the page displays properly. Apparently that feature no longer exists in Chrome.</p>

<a name="136357974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/clone%20formalization/near/136357974" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/63185cloneformalization.html#136357974">Miroslav Olšák (Oct 24 2018 at 05:43)</a>:</h4>
<p>All right, there it is on GitHub:<br>
<a href="https://github.com/mirefek/clones-lean/blob/master/clones.lean" target="_blank" title="https://github.com/mirefek/clones-lean/blob/master/clones.lean">https://github.com/mirefek/clones-lean/blob/master/clones.lean</a><br>
Any suggestions to the code? Is there a better way for case analysis through fin 3? Or a tactic that can do  all the rewrite at the end of the code?</p>

<a name="136358074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/clone%20formalization/near/136358074" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/63185cloneformalization.html#136358074">Mario Carneiro (Oct 24 2018 at 05:45)</a>:</h4>
<p>I think you should use ternary functions rather than arrays</p>

<a name="136358153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/clone%20formalization/near/136358153" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/63185cloneformalization.html#136358153">Mario Carneiro (Oct 24 2018 at 05:46)</a>:</h4>
<p>or products, but curried will be nicer</p>

<a name="136360087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/clone%20formalization/near/136360087" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/63185cloneformalization.html#136360087">Miroslav Olšák (Oct 24 2018 at 06:15)</a>:</h4>
<blockquote>
<p>I think you should use ternary functions rather than arrays</p>
</blockquote>
<p>Definitely not. Sure, it suffices for this simple example but it does not correspond to the definition of clone at all.</p>

<a name="136360141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/clone%20formalization/near/136360141" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/63185cloneformalization.html#136360141">Miroslav Olšák (Oct 24 2018 at 06:16)</a>:</h4>
<blockquote>
<p>or products, but curried will be nicer</p>
</blockquote>
<p>Show me.</p>

<a name="136360748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/clone%20formalization/near/136360748" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/63185cloneformalization.html#136360748">Miroslav Olšák (Oct 24 2018 at 06:27)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> What do you mean by curried products?</p>

<a name="136360856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/clone%20formalization/near/136360856" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/63185cloneformalization.html#136360856">Johan Commelin (Oct 24 2018 at 06:29)</a>:</h4>
<p>You can write a function <code>X × Y → Z</code> as <code>X → Y → Z</code>.</p>

<a name="136360866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/clone%20formalization/near/136360866" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/63185cloneformalization.html#136360866">Johan Commelin (Oct 24 2018 at 06:29)</a>:</h4>
<p>This is known as "currying"</p>

<a name="136360871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/clone%20formalization/near/136360871" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/63185cloneformalization.html#136360871">Kenny Lau (Oct 24 2018 at 06:29)</a>:</h4>
<p>aka product is left-adjoint of hom</p>

<a name="136360917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/clone%20formalization/near/136360917" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/63185cloneformalization.html#136360917">Kenny Lau (Oct 24 2018 at 06:30)</a>:</h4>
<p>(sorry)</p>

<a name="136361131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/clone%20formalization/near/136361131" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/63185cloneformalization.html#136361131">Miroslav Olšák (Oct 24 2018 at 06:33)</a>:</h4>
<p>I see.<br>
But how to define the general composition for operations written like this?<br>
I really think it is better to interpret them as functions A^n -&gt; A, in the case of clones, as mathematicians usually do.</p>

<a name="136361197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/clone%20formalization/near/136361197" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/63185cloneformalization.html#136361197">Johan Commelin (Oct 24 2018 at 06:34)</a>:</h4>
<p>I tend to agree (I'm also a mathematician). But these CS people have really crazy operators that will do what you want.</p>

<a name="136361225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/clone%20formalization/near/136361225" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/63185cloneformalization.html#136361225">Johan Commelin (Oct 24 2018 at 06:35)</a>:</h4>
<p>And they can explain the benefits. (The disadvantage is that it no longer looks like what you are used to, although you can prove it is the same thing.)</p>

<a name="136361233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/clone%20formalization/near/136361233" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/63185cloneformalization.html#136361233">Abhimanyu Pallavi Sudhir (Oct 24 2018 at 06:35)</a>:</h4>
<p>I guess the advantage of the CS approach is that you can just give a single input and get a function.</p>

<a name="136361300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/clone%20formalization/near/136361300" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/63185cloneformalization.html#136361300">Johan Commelin (Oct 24 2018 at 06:36)</a>:</h4>
<p>I don't know what a clone is exactly, but what I saw on wiki looks like it is related operads. <span class="user-mention" data-user-id="133339">@Miroslav Olšák</span> Is that right?</p>

<a name="136361938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/clone%20formalization/near/136361938" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/63185cloneformalization.html#136361938">Reid Barton (Oct 24 2018 at 06:46)</a>:</h4>
<p>nlab claims clones are analogous to operads but I think the relationship is less obvious than it looks at first glance</p>

<a name="136361968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/clone%20formalization/near/136361968" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/63185cloneformalization.html#136361968">Reid Barton (Oct 24 2018 at 06:46)</a>:</h4>
<p>The composition operation for operads takes a <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span>-ary operation and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span> operations of arity <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">n_1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span>, ..., <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">n_k</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> and gives you an operation of arity <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><mo>⋯</mo><mo>+</mo><msub><mi>n</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">n_1 + \cdots + n_k</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.58333em;"></span><span class="strut bottom" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mbin">+</span><span class="minner">⋯</span><span class="mbin">+</span><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span></p>

<a name="136362014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/clone%20formalization/near/136362014" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/63185cloneformalization.html#136362014">Reid Barton (Oct 24 2018 at 06:47)</a>:</h4>
<p>where the picture is that the <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span> operations each have access to disjoint subsets of the input variables</p>

<a name="136362084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/clone%20formalization/near/136362084" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/63185cloneformalization.html#136362084">Reid Barton (Oct 24 2018 at 06:48)</a>:</h4>
<p>here, each of the composed operations has access to all the input variables. I guess maybe it is the same thing as saying that you have the power to duplicate variables.</p>

<a name="136362172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/clone%20formalization/near/136362172" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/63185cloneformalization.html#136362172">Miroslav Olšák (Oct 24 2018 at 06:49)</a>:</h4>
<p>I understand the advantages of functional programming, but not in this case. If anybody feels that defining a clone by curried functions would be better, it would be nice to see such an approach.</p>
<p>Concerning to operads, I don't know them very well. From what I see on Wiki right now, operads are more general than abstract clones since they does not have projections (and also, operads don't glue variables). I think Reid Barton is right, just faster than me :-)</p>

<a name="136384717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/clone%20formalization/near/136384717" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/63185cloneformalization.html#136384717">Mario Carneiro (Oct 24 2018 at 14:44)</a>:</h4>
<p>The fact that you can partially apply a curried function is not actually that important in this case, it's just the way lean naturally deals with n-ary functions</p>

<a name="136385067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/clone%20formalization/near/136385067" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/63185cloneformalization.html#136385067">Mario Carneiro (Oct 24 2018 at 14:57)</a>:</h4>
<p><span class="user-mention" data-user-id="133339">@Miroslav Olšák</span> Okay, I see now. I thought that you only had to deal with ternary functions, but now I see that the statement involves membership in a clone, which involves arbitrary arity functions</p>

<a name="136385128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/clone%20formalization/near/136385128" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/63185cloneformalization.html#136385128">Mario Carneiro (Oct 24 2018 at 14:59)</a>:</h4>
<p>In this case, I will point you to <a href="https://github.com/leanprover/mathlib/blob/master/computability/primrec.lean#L1132-L1141" target="_blank" title="https://github.com/leanprover/mathlib/blob/master/computability/primrec.lean#L1132-L1141"><code>nat.primrec'</code></a>, which is somewhat similar in needing to deal with collections of n-ary functions and n-ary composition. I use functions of type <code>vector n A -&gt; A</code>, and n-ary composition is <code>λ a, f (of_fn (λ i, g i a))</code></p>

<a name="136396537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/clone%20formalization/near/136396537" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/63185cloneformalization.html#136396537">Miroslav Olšák (Oct 24 2018 at 20:14)</a>:</h4>
<p>Interesting. Do you think that vectors behave in Lean better than arrays in general? (even though they are mathematically the same).</p>


{% endraw %}
