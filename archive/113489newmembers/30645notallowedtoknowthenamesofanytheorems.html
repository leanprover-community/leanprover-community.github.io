---
layout: archive
title: Lean Prover Zulip Chat Archive 
permalink: archive/113489newmembers/30645notallowedtoknowthenamesofanytheorems.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/30645notallowedtoknowthenamesofanytheorems.html">not allowed to know the names of any theorems</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="159486245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/not%20allowed%20to%20know%20the%20names%20of%20any%20theorems/near/159486245" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30645notallowedtoknowthenamesofanytheorems.html#159486245">Scott Morrison (Feb 27 2019 at 06:25)</a>:</h4>
<p>Without knowing the names of any lemmas (tactics are allowed), prove</p>
<div class="codehilite"><pre><span></span>lemma qux (n : ℕ) (h₁ : n &lt; 3) (h₂ : n ≥ 2) : n = 2 :=
</pre></div>

<a name="159487443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/not%20allowed%20to%20know%20the%20names%20of%20any%20theorems/near/159487443" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30645notallowedtoknowthenamesofanytheorems.html#159487443">Kevin Buzzard (Feb 27 2019 at 06:57)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">linarith</span>

<span class="kn">lemma</span> <span class="n">qux</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">3</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">≥</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">2</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">change</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="mi">3</span> <span class="n">at</span> <span class="n">h₁</span><span class="o">,</span>
  <span class="n">linarith</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>

<a name="159487504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/not%20allowed%20to%20know%20the%20names%20of%20any%20theorems/near/159487504" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30645notallowedtoknowthenamesofanytheorems.html#159487504">Patrick Massot (Feb 27 2019 at 06:58)</a>:</h4>
<p>We should resume work on the nat case bashing tactic</p>

<a name="159487592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/not%20allowed%20to%20know%20the%20names%20of%20any%20theorems/near/159487592" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30645notallowedtoknowthenamesofanytheorems.html#159487592">Kevin Buzzard (Feb 27 2019 at 07:01)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">qux</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">3</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">≥</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">2</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">cases</span> <span class="n">n</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">h₂</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">n</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">h₂</span> <span class="k">with</span> <span class="n">h₂</span> <span class="n">h₃</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">h₃</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h₁</span> <span class="k">with</span> <span class="n">h₁</span> <span class="n">h₃</span><span class="o">,</span>
    <span class="n">refl</span><span class="o">,</span> <span class="c1">-- the proof</span>
  <span class="n">cases</span> <span class="n">h₃</span> <span class="k">with</span> <span class="n">h₁</span> <span class="n">h₃</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h₃</span> <span class="k">with</span> <span class="n">h₁</span> <span class="n">h₃</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h₃</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>

<a name="159487632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/not%20allowed%20to%20know%20the%20names%20of%20any%20theorems/near/159487632" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30645notallowedtoknowthenamesofanytheorems.html#159487632">Patrick Massot (Feb 27 2019 at 07:01)</a>:</h4>
<p>The current state was:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span>

<span class="kn">open</span> <span class="n">tactic</span>
<span class="n">meta</span> <span class="n">def</span> <span class="n">get_nat_ineq</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="o">(</span><span class="n">expr</span> <span class="bp">×</span> <span class="n">expr</span> <span class="bp">×</span> <span class="bp">ℕ</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="err">%%</span><span class="n">val</span> <span class="bp">&lt;</span> <span class="err">%%</span><span class="n">ebound</span><span class="o">)</span> <span class="o">:=</span> <span class="n">prod</span><span class="bp">.</span><span class="n">mk</span> <span class="n">val</span> <span class="bp">&lt;</span><span class="err">$</span><span class="bp">&gt;</span> <span class="o">(</span><span class="n">prod</span><span class="bp">.</span><span class="n">mk</span> <span class="n">ebound</span> <span class="bp">&lt;</span><span class="err">$</span><span class="bp">&gt;</span> <span class="n">eval_expr</span> <span class="bp">ℕ</span> <span class="n">ebound</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="err">%%</span><span class="n">val</span> <span class="bp">≤</span> <span class="err">%%</span><span class="n">ebound</span><span class="o">)</span> <span class="o">:=</span> <span class="n">prod</span><span class="bp">.</span><span class="n">mk</span> <span class="n">val</span> <span class="bp">&lt;</span><span class="err">$</span><span class="bp">&gt;</span> <span class="o">(</span><span class="n">prod</span><span class="bp">.</span><span class="n">mk</span> <span class="n">ebound</span> <span class="bp">&lt;</span><span class="err">$</span><span class="bp">&gt;</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">&lt;</span><span class="err">$</span><span class="bp">&gt;</span> <span class="n">eval_expr</span> <span class="bp">ℕ</span> <span class="n">ebound</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">failed</span>

<span class="kn">namespace</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span>
<span class="kn">open</span> <span class="n">lean</span><span class="bp">.</span><span class="n">parser</span> <span class="n">interactive</span>
<span class="n">meta</span> <span class="n">def</span> <span class="n">nat_cases</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">parse</span> <span class="n">ident</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">focus1</span> <span class="err">$</span> <span class="n">do</span>
  <span class="n">e</span> <span class="err">←</span> <span class="n">get_local</span> <span class="n">h</span><span class="o">,</span>
  <span class="bp">⟨</span><span class="n">val</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">ebound</span><span class="o">,</span> <span class="n">bound</span><span class="bp">⟩⟩</span> <span class="err">←</span> <span class="n">infer_type</span> <span class="n">e</span> <span class="bp">&gt;&gt;=</span> <span class="n">get_nat_ineq</span><span class="o">,</span>
  <span class="n">expr</span><span class="bp">.</span><span class="n">local_const</span> <span class="bp">_</span> <span class="n">nval</span> <span class="bp">_</span> <span class="bp">_</span> <span class="err">←</span> <span class="n">return</span> <span class="n">val</span><span class="o">,</span>
  <span class="n">iterate_at_most</span> <span class="n">bound</span> <span class="err">$</span> <span class="n">do</span> <span class="o">{</span>
      <span class="n">val</span> <span class="err">←</span> <span class="n">get_local</span> <span class="n">nval</span><span class="o">,</span>
      <span class="n">cases_core</span> <span class="n">val</span><span class="o">,</span>
      <span class="n">clear_lst</span> <span class="o">[</span><span class="n">h</span><span class="o">],</span>
      <span class="n">swap</span> <span class="o">},</span>
  <span class="n">e</span> <span class="err">←</span> <span class="n">get_local</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">val</span> <span class="err">←</span> <span class="n">get_local</span> <span class="n">nval</span><span class="o">,</span>
  <span class="k">proof</span> <span class="err">←</span> <span class="n">to_expr</span> <span class="bp">```</span><span class="o">(</span><span class="n">absurd</span> <span class="err">%%</span><span class="n">e</span> <span class="o">(</span><span class="n">not_lt_of_ge</span> <span class="err">$</span> <span class="n">nat</span><span class="bp">.</span><span class="n">le_add_left</span> <span class="err">%%</span><span class="n">ebound</span> <span class="err">%%</span><span class="n">val</span><span class="o">)),</span>
  <span class="n">tactic</span><span class="bp">.</span><span class="n">exact</span> <span class="k">proof</span><span class="o">,</span>
  <span class="n">goals</span> <span class="err">←</span> <span class="n">get_goals</span><span class="o">,</span>
  <span class="n">set_goals</span> <span class="n">goals</span><span class="bp">.</span><span class="n">reverse</span>

<span class="kn">end</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">≤</span> <span class="mi">4</span><span class="o">)</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">≤</span> <span class="mi">10</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">nat_cases</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">do</span> <span class="o">{</span> <span class="n">goals</span> <span class="err">←</span> <span class="n">get_goals</span><span class="o">,</span> <span class="n">guard</span> <span class="o">(</span><span class="n">goals</span><span class="bp">.</span><span class="n">length</span> <span class="bp">=</span> <span class="mi">5</span><span class="o">)</span> <span class="o">},</span>
  <span class="n">all_goals</span> <span class="o">{</span> <span class="n">exact</span> <span class="n">dec_trivial</span><span class="o">},</span>
<span class="kn">end</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">4</span><span class="o">)</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">≤</span> <span class="mi">10</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">nat_cases</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">do</span> <span class="o">{</span> <span class="n">goals</span> <span class="err">←</span> <span class="n">get_goals</span><span class="o">,</span> <span class="n">guard</span> <span class="o">(</span><span class="n">goals</span><span class="bp">.</span><span class="n">length</span> <span class="bp">=</span> <span class="mi">4</span><span class="o">)</span> <span class="o">},</span>
  <span class="n">all_goals</span> <span class="o">{</span> <span class="n">exact</span> <span class="n">dec_trivial</span><span class="o">},</span>
<span class="kn">end</span>
</pre></div>


<p>but it needed to be extended to handle also  lower bounds</p>

<a name="159487700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/not%20allowed%20to%20know%20the%20names%20of%20any%20theorems/near/159487700" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30645notallowedtoknowthenamesofanytheorems.html#159487700">Patrick Massot (Feb 27 2019 at 07:03)</a>:</h4>
<p>Remember this is based on code by Kenny</p>

<a name="159490467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/not%20allowed%20to%20know%20the%20names%20of%20any%20theorems/near/159490467" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30645notallowedtoknowthenamesofanytheorems.html#159490467">Kevin Buzzard (Feb 27 2019 at 08:11)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">qux</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">3</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">≥</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">2</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">cases</span> <span class="n">h₁</span> <span class="k">with</span> <span class="bp">_</span> <span class="n">h₁</span><span class="o">,</span>
    <span class="n">refl</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h₁</span> <span class="k">with</span> <span class="bp">_</span> <span class="n">h₁</span><span class="o">,</span>
    <span class="n">revert</span> <span class="n">h₂</span><span class="o">,</span> <span class="n">exact</span> <span class="n">dec_trivial</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h₁</span> <span class="k">with</span> <span class="bp">_</span> <span class="n">h₁</span><span class="o">,</span>
    <span class="n">revert</span> <span class="n">h₂</span><span class="o">,</span> <span class="n">exact</span> <span class="n">dec_trivial</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h₁</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p>Casing on the inequality is quicker than casing on <code>n</code>.</p>

<a name="159490603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/not%20allowed%20to%20know%20the%20names%20of%20any%20theorems/near/159490603" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30645notallowedtoknowthenamesofanytheorems.html#159490603">Kenny Lau (Feb 27 2019 at 08:16)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">nat</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">lemma</span> <span class="n">qux</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">3</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">≥</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">2</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">revert</span> <span class="n">n</span><span class="bp">;</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">exact_dec_trivial</span>
</pre></div>

<a name="159490688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/not%20allowed%20to%20know%20the%20names%20of%20any%20theorems/near/159490688" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30645notallowedtoknowthenamesofanytheorems.html#159490688">Johan Commelin (Feb 27 2019 at 08:17)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> Your challenge was Kenny'd.</p>

<a name="159490742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/not%20allowed%20to%20know%20the%20names%20of%20any%20theorems/near/159490742" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30645notallowedtoknowthenamesofanytheorems.html#159490742">Kevin Buzzard (Feb 27 2019 at 08:18)</a>:</h4>
<p>Why is the import necessary?</p>

<a name="159490746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/not%20allowed%20to%20know%20the%20names%20of%20any%20theorems/near/159490746" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30645notallowedtoknowthenamesofanytheorems.html#159490746">Mario Carneiro (Feb 27 2019 at 08:18)</a>:</h4>
<p>I assume that's where the decidable instance is</p>

<a name="159490758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/not%20allowed%20to%20know%20the%20names%20of%20any%20theorems/near/159490758" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30645notallowedtoknowthenamesofanytheorems.html#159490758">Mario Carneiro (Feb 27 2019 at 08:19)</a>:</h4>
<p>I think <code>tactic.exact_dec_trivial</code> can just be <code>exact dec_trivial</code></p>

<a name="159490771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/not%20allowed%20to%20know%20the%20names%20of%20any%20theorems/near/159490771" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30645notallowedtoknowthenamesofanytheorems.html#159490771">Mario Carneiro (Feb 27 2019 at 08:19)</a>:</h4>
<p>unless that counts as "the name of a theorem"</p>

<a name="159490775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/not%20allowed%20to%20know%20the%20names%20of%20any%20theorems/near/159490775" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30645notallowedtoknowthenamesofanytheorems.html#159490775">Kevin Buzzard (Feb 27 2019 at 08:19)</a>:</h4>
<p>Well he'd better make some improvements because my first solution is shorter than his :P</p>

<a name="159490780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/not%20allowed%20to%20know%20the%20names%20of%20any%20theorems/near/159490780" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30645notallowedtoknowthenamesofanytheorems.html#159490780">Kevin Buzzard (Feb 27 2019 at 08:19)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">nat</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">linarith</span>

<span class="kn">lemma</span> <span class="n">qux</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">3</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">≥</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">2</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">change</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="mi">3</span> <span class="n">at</span> <span class="n">h₁</span><span class="bp">;</span> <span class="n">linarith</span>

<span class="kn">lemma</span> <span class="n">qux&#39;</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">3</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">≥</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">2</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">revert</span> <span class="n">n</span><span class="bp">;</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">exact_dec_trivial</span>
</pre></div>

<a name="159490837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/not%20allowed%20to%20know%20the%20names%20of%20any%20theorems/near/159490837" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30645notallowedtoknowthenamesofanytheorems.html#159490837">Kenny Lau (Feb 27 2019 at 08:20)</a>:</h4>
<p>but mine is faster</p>

<a name="159490850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/not%20allowed%20to%20know%20the%20names%20of%20any%20theorems/near/159490850" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30645notallowedtoknowthenamesofanytheorems.html#159490850">Kevin Buzzard (Feb 27 2019 at 08:20)</a>:</h4>
<p>however my longer solution is faster than yours so I'm beating you all ends up ;-)</p>

<a name="159490873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/not%20allowed%20to%20know%20the%20names%20of%20any%20theorems/near/159490873" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30645notallowedtoknowthenamesofanytheorems.html#159490873">Kevin Buzzard (Feb 27 2019 at 08:21)</a>:</h4>
<p>Mario is right though, and now yours is the shortest</p>

<a name="159490973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/not%20allowed%20to%20know%20the%20names%20of%20any%20theorems/near/159490973" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30645notallowedtoknowthenamesofanytheorems.html#159490973">Mario Carneiro (Feb 27 2019 at 08:23)</a>:</h4>
<p>these proofs make me weep though, compared to just using <code>le_antisymm</code></p>

<a name="159490985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/not%20allowed%20to%20know%20the%20names%20of%20any%20theorems/near/159490985" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30645notallowedtoknowthenamesofanytheorems.html#159490985">Kenny Lau (Feb 27 2019 at 08:24)</a>:</h4>
<p>you can make that a tactic!</p>

<a name="159491035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/not%20allowed%20to%20know%20the%20names%20of%20any%20theorems/near/159491035" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30645notallowedtoknowthenamesofanytheorems.html#159491035">Mario Carneiro (Feb 27 2019 at 08:24)</a>:</h4>
<p><code>by exact</code></p>

<a name="159491758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/not%20allowed%20to%20know%20the%20names%20of%20any%20theorems/near/159491758" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30645notallowedtoknowthenamesofanytheorems.html#159491758">Patrick Massot (Feb 27 2019 at 08:38)</a>:</h4>
<p>Again, we should have a complete <code>nat_cases</code> tactic (and <code>int_cases</code>)</p>

<a name="159496126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/not%20allowed%20to%20know%20the%20names%20of%20any%20theorems/near/159496126" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30645notallowedtoknowthenamesofanytheorems.html#159496126">Scott Morrison (Feb 27 2019 at 10:03)</a>:</h4>
<p>Okay, I've added the "missing trick" to linarith, PR to follow once I've tested a bit more.</p>

<a name="159496150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/not%20allowed%20to%20know%20the%20names%20of%20any%20theorems/near/159496150" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30645notallowedtoknowthenamesofanytheorems.html#159496150">Scott Morrison (Feb 27 2019 at 10:03)</a>:</h4>
<p>I'll see if I can do something with nat_cases, too.</p>

<a name="159496809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/not%20allowed%20to%20know%20the%20names%20of%20any%20theorems/near/159496809" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30645notallowedtoknowthenamesofanytheorems.html#159496809">Scott Morrison (Feb 27 2019 at 10:12)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/769" target="_blank" title="https://github.com/leanprover-community/mathlib/pull/769">https://github.com/leanprover-community/mathlib/pull/769</a></p>

<a name="159498502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/not%20allowed%20to%20know%20the%20names%20of%20any%20theorems/near/159498502" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30645notallowedtoknowthenamesofanytheorems.html#159498502">Sebastien Gouezel (Feb 27 2019 at 10:42)</a>:</h4>
<p>Nice! If you're in a linarith mood, I would like to know if it is easy to add to the context used by linarith the inequalities <code>lfloor x rfloor &lt;= x</code> and <code>x &lt; lfloor x rfloor + 1</code> when <code>lfloor x rfloor</code> appears in the context (or maybe I should do the exercise myself!)</p>

<a name="159499038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/not%20allowed%20to%20know%20the%20names%20of%20any%20theorems/near/159499038" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30645notallowedtoknowthenamesofanytheorems.html#159499038">Scott Morrison (Feb 27 2019 at 10:51)</a>:</h4>
<p>I'd guess this isn't too bad. (One could do max and min, too.)</p>

<a name="159499104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/not%20allowed%20to%20know%20the%20names%20of%20any%20theorems/near/159499104" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30645notallowedtoknowthenamesofanytheorems.html#159499104">Scott Morrison (Feb 27 2019 at 10:52)</a>:</h4>
<p>My preference would be to basically have a preprocessing step, that inspects hypotheses for these sorts of things appearing inside linear inequalities, and add all the extra lemmas. Then we could add a parsing flag to linarith to ask it to run the preprocessor (or do it by default anyway).</p>

<a name="159499132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/not%20allowed%20to%20know%20the%20names%20of%20any%20theorems/near/159499132" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30645notallowedtoknowthenamesofanytheorems.html#159499132">Scott Morrison (Feb 27 2019 at 10:53)</a>:</h4>
<p>I'll add it to my list (I have a whole lot of students just getting started... maybe one of them will be trying it soon) :-) I'd like to think about a nice <code>nat_cases</code> first.</p>

<a name="159500052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/not%20allowed%20to%20know%20the%20names%20of%20any%20theorems/near/159500052" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30645notallowedtoknowthenamesofanytheorems.html#159500052">Rob Lewis (Feb 27 2019 at 11:10)</a>:</h4>
<p>I don't want the core <code>linarith</code> tactic to do heuristic instantiation. There's no end to the lemmas that could be applicable. Same deal with unfolding constants, splitting conditionals, etc. A separate tactic that preprocesses for <code>linarith</code> would be fine. But throwing lots of random features into the core tactic makes it unpredictable, slower, and harder to maintain.</p>

<a name="159524483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/not%20allowed%20to%20know%20the%20names%20of%20any%20theorems/near/159524483" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30645notallowedtoknowthenamesofanytheorems.html#159524483">Sebastien Gouezel (Feb 27 2019 at 15:34)</a>:</h4>
<p>What about <code>linarith_ext</code> (or something like that) for the tactic extended by a preparser massaging suitably the assumptions (maybe the nat and int preprocessing just commited by Scott would fit in this preprocessing step, for instance), and <code>linarith</code> for the original unchanged robust tactic? And maybe later if one realizes that everyone uses the extended version and that the speed difference is not huge, rename them to <code>linarith</code> and <code>linarith_core</code> respectively?</p>

<a name="159531594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/not%20allowed%20to%20know%20the%20names%20of%20any%20theorems/near/159531594" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30645notallowedtoknowthenamesofanytheorems.html#159531594">Andrew Ashworth (Feb 27 2019 at 16:51)</a>:</h4>
<p>hmm, wasn't this sort of thing what simp sets were for? I wonder what happened to that project</p>

<a name="159549019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/not%20allowed%20to%20know%20the%20names%20of%20any%20theorems/near/159549019" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30645notallowedtoknowthenamesofanytheorems.html#159549019">Rob Lewis (Feb 27 2019 at 20:21)</a>:</h4>
<p>I want to keep the behavior of <code>linarith</code> predictable. There's a very well-defined problem that it solves: <code>linarith</code> will (or should) prove all provable statements in the theory of linear arithmetic over the rationals. The tactic is finished when it does this. It happens that some problems over <code>int</code> and <code>nat</code> can be solved by the same method with minimal preprocessing, and it doesn't hurt to try the very simple and obvious stuff, like what Scott added. But the step up from rational arithmetic to actual integer arithmetic is huge, it's a much harder problem. Adding more and more gadgets to the current one to make it do more on integers will lead to pain. The gadgets will have bugs, they'll interact in unexpected ways, people will keep wondering why a works but b doesn't. I've already fixed bad interactions in the nat/int preprocessing and there's not much there. And in the end, it will never be a replacement for an actual integer arithmetic tool.</p>
<p>Making it aware of certain constants is the same deal. Yeah, there are natural inequalities about floor that we all know. And ceiling, and abs, and max and min, and log and exp, and sin.... This is all a special case of heuristic lemma instantiation. You have terms, you have a library of universally quantified facts, which facts do you instantiate with which terms to get something useful? You can hardcode a few things into a preprocessing loop and call it a day. But there's a systematic way to do this kind of thing (that's partially implemented in Lean's SMT mode, actually), and it really has nothing to do with linear arithmetic. Trying to approximate it will lead to infinite feature requests, so prepare yourself.</p>

<a name="159549115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/not%20allowed%20to%20know%20the%20names%20of%20any%20theorems/near/159549115" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30645notallowedtoknowthenamesofanytheorems.html#159549115">Rob Lewis (Feb 27 2019 at 20:22)</a>:</h4>
<p>Andrew, Sebastien's question has nothing to do with simplifying, he wants to add extra inequalities to the context based on the constants that appear there already.</p>

<a name="159550071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/not%20allowed%20to%20know%20the%20names%20of%20any%20theorems/near/159550071" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30645notallowedtoknowthenamesofanytheorems.html#159550071">Patrick Massot (Feb 27 2019 at 20:34)</a>:</h4>
<p>We need a mathlib FAQ where Rob can paste this answer once and for all (I'm sure he wrote it at least five times already, although I'm clearly among people who would like linarith to close all their goals).</p>

<a name="159554208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/not%20allowed%20to%20know%20the%20names%20of%20any%20theorems/near/159554208" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30645notallowedtoknowthenamesofanytheorems.html#159554208">Bryan Gin-ge Chen (Feb 27 2019 at 21:28)</a>:</h4>
<p>Maybe some portion of this can be added to the <a href="https://github.com/leanprover-community/mathlib/blob/master/docs/tactics.md#linarith" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/docs/tactics.md#linarith">tactic docs</a>.</p>


{% endraw %}
