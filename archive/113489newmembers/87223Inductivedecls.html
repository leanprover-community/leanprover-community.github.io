---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113489newmembers/87223Inductivedecls.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/87223Inductivedecls.html">Inductive decls</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="166976460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20decls/near/166976460" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/87223Inductivedecls.html#166976460">Keeley Hoek (May 31 2019 at 08:00)</a>:</h4>
<p>Why is it illegal to declare</p>
<div class="codehilite"><pre><span></span>inductive foo
| mk (f : foo → ℕ)
</pre></div>

<a name="166976486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20decls/near/166976486" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/87223Inductivedecls.html#166976486">Keeley Hoek (May 31 2019 at 08:01)</a>:</h4>
<p>whereas</p>
<div class="codehilite"><pre><span></span>inductive foo&#39;
| mk (f : ℕ → foo&#39;)
</pre></div>


<p>is fine?</p>

<a name="166976494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20decls/near/166976494" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/87223Inductivedecls.html#166976494">Keeley Hoek (May 31 2019 at 08:01)</a>:</h4>
<p>Is there an (easy?) proof of false?</p>

<a name="166977904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20decls/near/166977904" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/87223Inductivedecls.html#166977904">Edward Ayers (May 31 2019 at 08:23)</a>:</h4>
<p>I think the first problem is that it's not clear what the recursor should be.</p>

<a name="166977973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20decls/near/166977973" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/87223Inductivedecls.html#166977973">Kenny Lau (May 31 2019 at 08:24)</a>:</h4>
<p>yeah I was thinking about that.</p>

<a name="166978033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20decls/near/166978033" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/87223Inductivedecls.html#166978033">Edward Ayers (May 31 2019 at 08:25)</a>:</h4>
<p>And then all of the sensible definitions of <code>rec</code>  let you make infinite descending terms. edit: or derive false or something.</p>

<a name="166978206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20decls/near/166978206" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/87223Inductivedecls.html#166978206">Edward Ayers (May 31 2019 at 08:27)</a>:</h4>
<p>The thing to look up is called "strict positivity"</p>

<a name="166978486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20decls/near/166978486" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/87223Inductivedecls.html#166978486">Rob Lewis (May 31 2019 at 08:32)</a>:</h4>
<p>It's easy enough to adapt examples like this one: <a href="https://cstheory.stackexchange.com/questions/14415/guarded-negative-occurrences-in-definition-of-inductive-types-always-bad" target="_blank" title="https://cstheory.stackexchange.com/questions/14415/guarded-negative-occurrences-in-definition-of-inductive-types-always-bad">https://cstheory.stackexchange.com/questions/14415/guarded-negative-occurrences-in-definition-of-inductive-types-always-bad</a></p>
<div class="codehilite"><pre><span></span><span class="kn">constant</span> <span class="n">foo</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="kn">constant</span> <span class="n">mk</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">foo</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">foo</span>
<span class="kn">constant</span> <span class="n">inj</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">x</span> <span class="o">:</span> <span class="n">foo</span><span class="o">,</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">foo</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">mk</span> <span class="n">f</span><span class="o">}</span>

<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">self_app</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">foo</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
<span class="k">let</span> <span class="bp">⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">hf</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">inj</span> <span class="n">a</span> <span class="k">in</span> <span class="n">f</span> <span class="n">a</span>

<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">ta</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">nf</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">self_app</span> <span class="err">$</span> <span class="n">mk</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">nf</span> <span class="err">$</span> <span class="n">self_app</span> <span class="n">a</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span> <span class="n">ta</span> <span class="n">id</span>
</pre></div>

<a name="166979022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20decls/near/166979022" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/87223Inductivedecls.html#166979022">Keeley Hoek (May 31 2019 at 08:42)</a>:</h4>
<p>Awesome! Thanks for the demo.<br>
If I make <code>mk</code> increase universe level by one the demo fails;</p>
<div class="codehilite"><pre><span></span><span class="kn">universe</span> <span class="n">u</span>

<span class="kn">constant</span> <span class="n">foo</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="kn">constant</span> <span class="n">mk</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">foo</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">foo</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">}</span>
<span class="kn">constant</span> <span class="n">inj</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">x</span> <span class="o">:</span> <span class="n">foo</span><span class="o">,</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">foo</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">mk</span> <span class="n">f</span><span class="o">}</span>

<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">self_app</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">foo</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
<span class="k">let</span> <span class="bp">⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">hf</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">inj</span> <span class="n">a</span> <span class="k">in</span> <span class="n">f</span> <span class="n">a</span>

<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">ta</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">nf</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">self_app</span> <span class="err">$</span> <span class="n">mk</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">nf</span> <span class="err">$</span> <span class="n">self_app</span> <span class="n">a</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span> <span class="n">ta</span> <span class="n">id</span>
</pre></div>


<p>Am I safe now? If so, is there any way to make lean build this?</p>

<a name="166980017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20decls/near/166980017" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/87223Inductivedecls.html#166980017">Rob Lewis (May 31 2019 at 08:58)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">universe</span> <span class="n">u</span>

<span class="kn">constant</span> <span class="n">foo</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="kn">constant</span> <span class="n">mk</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">foo</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">foo</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">}</span>
<span class="kn">constant</span> <span class="n">inj</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">x</span> <span class="o">:</span> <span class="n">foo</span><span class="o">,</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">foo</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">mk</span> <span class="n">f</span><span class="o">}</span>

<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">self_app</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">foo</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
<span class="k">let</span> <span class="bp">⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">hf</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">inj</span> <span class="o">(</span><span class="n">mk</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">trivial</span><span class="o">)</span> <span class="k">in</span> <span class="n">f</span> <span class="n">a</span>

<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">ta</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">nf</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">self_app</span> <span class="err">$</span> <span class="n">mk</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">nf</span> <span class="err">$</span> <span class="n">self_app</span> <span class="n">a</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span> <span class="n">ta</span> <span class="n">id</span>
</pre></div>

<a name="166981834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20decls/near/166981834" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/87223Inductivedecls.html#166981834">Keeley Hoek (May 31 2019 at 09:27)</a>:</h4>
<p>Actually, I'm not quite sure I understand---why is <code>\alpha</code> free to vary in those axioms? If I force <code>\alpha</code> to be <code>\nat</code>, can it work?</p>

<a name="166982028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20decls/near/166982028" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/87223Inductivedecls.html#166982028">Mario Carneiro (May 31 2019 at 09:30)</a>:</h4>
<p>the short answer is "no, this type violates cantor's theorem"</p>

<a name="166982314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20decls/near/166982314" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/87223Inductivedecls.html#166982314">Mario Carneiro (May 31 2019 at 09:35)</a>:</h4>
<p>I agree that something is funny in Rob's example. We don't need <code>ta</code>, it's already a contradiction in <code>self_app</code> if we instantiate <code>alpha</code> as <code>false</code></p>

<a name="166982378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20decls/near/166982378" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/87223Inductivedecls.html#166982378">Mario Carneiro (May 31 2019 at 09:36)</a>:</h4>
<p>and also <code>self_app</code> isn't diagonalizing in the second version</p>

<a name="166982445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20decls/near/166982445" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/87223Inductivedecls.html#166982445">Rob Lewis (May 31 2019 at 09:37)</a>:</h4>
<p>Yeah, I just copied it from the StackOverflow answer, I'm sure there are shorter ways.</p>

<a name="166982495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20decls/near/166982495" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/87223Inductivedecls.html#166982495">Mario Carneiro (May 31 2019 at 09:38)</a>:</h4>
<p>I would guess that you are actually safe if <code>mk</code> bumps the universe, but this is not the sort of definition lean can handle. It's recursive in a weird way - <code>foo.{n+1}</code> is defined in terms of <code>foo.{n}</code></p>

<a name="166982685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20decls/near/166982685" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/87223Inductivedecls.html#166982685">Mario Carneiro (May 31 2019 at 09:41)</a>:</h4>
<p>Rob, I think that <code>inj</code> is not a reasonable axiom - if you just look at <code>inj</code> it says <code>foo -&gt; foo -&gt; A</code> for all <code>A</code></p>

<a name="166982687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20decls/near/166982687" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/87223Inductivedecls.html#166982687">Rob Lewis (May 31 2019 at 09:41)</a>:</h4>
<p>Oh, wait, I see what you're saying.</p>

<a name="166982696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20decls/near/166982696" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/87223Inductivedecls.html#166982696">Rob Lewis (May 31 2019 at 09:41)</a>:</h4>
<p>Heh, we just had our coffee break and it's kicking in now.</p>

<a name="166982818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20decls/near/166982818" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/87223Inductivedecls.html#166982818">Rob Lewis (May 31 2019 at 09:43)</a>:</h4>
<p>You're right, that's too strong. But I'm not convinced that bumping the universe saves you, could you explain?</p>

<a name="166982875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20decls/near/166982875" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/87223Inductivedecls.html#166982875">Mario Carneiro (May 31 2019 at 09:44)</a>:</h4>
<p>you have to have a fixed alpha, like Keeley says</p>

<a name="166982895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20decls/near/166982895" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/87223Inductivedecls.html#166982895">Mario Carneiro (May 31 2019 at 09:44)</a>:</h4>
<p>right now you can use <code>mk</code> with one <code>alpha</code> and <code>inj</code> with another - and that's actually what you are doing in the proof, you use <code>mk</code> with <code>true</code> and <code>inj</code> with <code>false</code></p>

<a name="166982943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20decls/near/166982943" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/87223Inductivedecls.html#166982943">Mario Carneiro (May 31 2019 at 09:45)</a>:</h4>
<p>Imagine you could just define <code>foo.{u+1} := foo.{u} -&gt; nat</code>, that would satisfy all the axioms</p>

<a name="166982996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20decls/near/166982996" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/87223Inductivedecls.html#166982996">Mario Carneiro (May 31 2019 at 09:46)</a>:</h4>
<p>it's not really recursive, since for each fixed u it's a finite number of arrows</p>

<a name="166983026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20decls/near/166983026" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/87223Inductivedecls.html#166983026">Mario Carneiro (May 31 2019 at 09:47)</a>:</h4>
<p>in fact such a type probably even exists, since <code>Set.{u}</code> grows faster than <code>foo.{u}</code></p>

<a name="166983397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20decls/near/166983397" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/87223Inductivedecls.html#166983397">Mario Carneiro (May 31 2019 at 09:54)</a>:</h4>
<p>Thinking about it more carefully, I think this is not definable. If it was, then we could define <code>level.{u} : nat</code> which is equal to <code>u</code> as a nat</p>

<a name="166983526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20decls/near/166983526" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/87223Inductivedecls.html#166983526">Mario Carneiro (May 31 2019 at 09:56)</a>:</h4>
<p><code>Set.{u}</code> <em>almost</em> lets you define <code>level</code>, but you can only guarantee <code>u</code> <em>or more</em> inaccessible cardinals in it. There is a sort of cardinal collapsing property here - the theory can't tell if you just take one of the <code>Type u</code> universes out and shift the indexes of everything else down</p>

<a name="166983556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20decls/near/166983556" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/87223Inductivedecls.html#166983556">Keeley Hoek (May 31 2019 at 09:57)</a>:</h4>
<p>Looking at <code>Set</code> more than I have before, it seems like the way to get around having a <code>foo -&gt; Prop</code> is choosing an indexing type <code>\alpha</code> and looking at maps <code>\alpha -&gt; foo</code> instead. Since you can choose the indexing type as large as you want, isn't there some sort of bijection between these two pieces of data?</p>

<a name="166983569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20decls/near/166983569" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/87223Inductivedecls.html#166983569">Mario Carneiro (May 31 2019 at 09:58)</a>:</h4>
<p>that's why <code>Set</code> lives in a higher universe</p>

<a name="166983616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20decls/near/166983616" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/87223Inductivedecls.html#166983616">Keeley Hoek (May 31 2019 at 09:58)</a>:</h4>
<p>(modulo a quotient of such maps by permutations of the indexing type and change of indexing type)</p>

<a name="166983620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20decls/near/166983620" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/87223Inductivedecls.html#166983620">Mario Carneiro (May 31 2019 at 09:58)</a>:</h4>
<p>you can't instantiate <code>Set.{u}</code> with <code>Set.{u}</code> as the index type</p>

<a name="166983729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20decls/near/166983729" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/87223Inductivedecls.html#166983729">Keeley Hoek (May 31 2019 at 10:00)</a>:</h4>
<p>For sure</p>

<a name="166983774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20decls/near/166983774" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/87223Inductivedecls.html#166983774">Mario Carneiro (May 31 2019 at 10:01)</a>:</h4>
<p>so you don't get a cantor contradiction, instead you just end up proving that <code>Set.{u}</code> is (a lot) smaller than <code>Set.{u+1}</code></p>

<a name="166991843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20decls/near/166991843" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/87223Inductivedecls.html#166991843">Keeley Hoek (May 31 2019 at 12:21)</a>:</h4>
<p>Regarding your comments on <code>level</code>, why would it be bad if <code>level.{u} : nat</code> existed?</p>

<a name="166991860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20decls/near/166991860" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/87223Inductivedecls.html#166991860">Keeley Hoek (May 31 2019 at 12:21)</a>:</h4>
<p>(Sorry for using you to learn about type theory)</p>

<a name="167024486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20decls/near/167024486" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/87223Inductivedecls.html#167024486">Floris van Doorn (May 31 2019 at 19:05)</a>:</h4>
<p>(deleted)</p>

<a name="167024791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20decls/near/167024791" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/87223Inductivedecls.html#167024791">Mario Carneiro (May 31 2019 at 19:09)</a>:</h4>
<p><span class="user-mention" data-user-id="110111">@Keeley Hoek</span> It wouldn't necessarily be bad if <code>level.{u}</code> existed, but I'm pretty sure it's independent</p>

<a name="167024889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20decls/near/167024889" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/87223Inductivedecls.html#167024889">Floris van Doorn (May 31 2019 at 19:10)</a>:</h4>
<p>(oops, I replied to the wrong thread)</p>


{% endraw %}

{% include archive_update.html %}