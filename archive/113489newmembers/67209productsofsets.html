---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113489newmembers/67209productsofsets.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/67209productsofsets.html">products of sets</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="168201756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/products%20of%20sets/near/168201756" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/67209productsofsets.html#168201756">Simon Pepin Lehalleur (Jun 15 2019 at 10:02)</a>:</h4>
<p>I have just started playing around with lean and I have a very basic question. From what I understand, the easy way to work with types in Lean (without universes) is to write s : set Type. But then when I form s \times s, it is of type Type \times Type. How can I make s \times s into a term of type Type ? Naively, I want the product of sets to be a set! Same question with finset.</p>

<a name="168201815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/products%20of%20sets/near/168201815" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/67209productsofsets.html#168201815">Sebastien Gouezel (Jun 15 2019 at 10:04)</a>:</h4>
<p>are you looking for <code>set.prod</code>?</p>

<a name="168201865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/products%20of%20sets/near/168201865" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/67209productsofsets.html#168201865">Chris Hughes (Jun 15 2019 at 10:06)</a>:</h4>
<p>Using <code>set Type</code> is quite unusual. It's probably not the best way to do what you want to do.</p>

<a name="168201869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/products%20of%20sets/near/168201869" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/67209productsofsets.html#168201869">Sebastien Gouezel (Jun 15 2019 at 10:06)</a>:</h4>
<p>Reading your question again, I think you are confused. If you want to define a Type <code>α</code>, you just write <code>α : Type</code>. If you want to define a set inside <code>α</code>, write <code>s : set α</code>.</p>

<a name="168201945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/products%20of%20sets/near/168201945" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/67209productsofsets.html#168201945">Simon Pepin Lehalleur (Jun 15 2019 at 10:09)</a>:</h4>
<p>Thanks! How can I  insert lean code in a reply? I want to work with a (finite) set s and define a directed graph on it by specifying an adjacency function s \times s -&gt; Prop.</p>

<a name="168202045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/products%20of%20sets/near/168202045" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/67209productsofsets.html#168202045">Chris Hughes (Jun 15 2019 at 10:12)</a>:</h4>
<p>Using </p>
<div class="codehilite"><pre><span></span>```lean
my code
```
</pre></div>

<a name="168202046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/products%20of%20sets/near/168202046" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/67209productsofsets.html#168202046">Andrew Ashworth (Jun 15 2019 at 10:12)</a>:</h4>
<p>you will see an explanation of all formatting commands by clicking the "A" at the bottom of the screen, next to the smiley face</p>

<a name="168202223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/products%20of%20sets/near/168202223" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/67209productsofsets.html#168202223">Simon Pepin Lehalleur (Jun 15 2019 at 10:18)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">Thanks</span><span class="bp">!</span>
</pre></div>

<a name="168204193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/products%20of%20sets/near/168204193" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/67209productsofsets.html#168204193">Kevin Buzzard (Jun 15 2019 at 11:24)</a>:</h4>
<p>Lean works with type theory, not set theory. Mathematicians like us have this background where we think everything is a set. If we were in mathematician-land and you said to me "I want a set s and an adjacency function on it, can you do that in Lean for me?" I would not use <code>set</code> at all -- I would let s be a type.</p>

<a name="168204251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/products%20of%20sets/near/168204251" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/67209productsofsets.html#168204251">Kevin Buzzard (Jun 15 2019 at 11:26)</a>:</h4>
<p>Lean does have this <code>set</code> thing, but it really means "subset". So if you write <code>s: set alpha</code> then you are really thinking of s as a subset of alpha or a subtype of alpha or whatever you want to call it. Types in Lean are pretty much the same as what normal mathematicians think of as sets, with the following weird different: two types can never have any elements in common. This sounds a bit shocking at first, but my guess is that in your case you can let s be a type.</p>

<a name="168204383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/products%20of%20sets/near/168204383" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/67209productsofsets.html#168204383">Mario Carneiro (Jun 15 2019 at 11:31)</a>:</h4>
<p>Technically that statement is not well formed</p>

<a name="168204428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/products%20of%20sets/near/168204428" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/67209productsofsets.html#168204428">Mario Carneiro (Jun 15 2019 at 11:32)</a>:</h4>
<p>The statement "types A and B are disjoint" does not typecheck</p>

<a name="168205709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/products%20of%20sets/near/168205709" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/67209productsofsets.html#168205709">Simon Pepin Lehalleur (Jun 15 2019 at 12:14)</a>:</h4>
<p>Do you have nice examples of combinatorics of finite sets in lean which I could learn from?</p>

<a name="168205721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/products%20of%20sets/near/168205721" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/67209productsofsets.html#168205721">Johan Commelin (Jun 15 2019 at 12:15)</a>:</h4>
<p><span class="user-mention" data-user-id="224267">@Simon Pepin Lehalleur</span> It might come as a bit of a surprise, but finite sets are actually quite hard to manage for a theorem prover.</p>

<a name="168205769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/products%20of%20sets/near/168205769" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/67209productsofsets.html#168205769">Johan Commelin (Jun 15 2019 at 12:16)</a>:</h4>
<p>And there are different ways to "impose" finiteness.</p>

<a name="168205772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/products%20of%20sets/near/168205772" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/67209productsofsets.html#168205772">Johan Commelin (Jun 15 2019 at 12:16)</a>:</h4>
<p>If you have a type <code>X : Type</code>, you can tell Lean that it is finite by adding <code>[fintype X]</code> as hypothesis.</p>

<a name="168205781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/products%20of%20sets/near/168205781" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/67209productsofsets.html#168205781">Kevin Buzzard (Jun 15 2019 at 12:17)</a>:</h4>
<p>All of the "different" ways are of course the same, but in constructive maths they're probably different.</p>

<a name="168205788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/products%20of%20sets/near/168205788" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/67209productsofsets.html#168205788">Johan Commelin (Jun 15 2019 at 12:17)</a>:</h4>
<p>So you could try to define arbitrary graphs, using some type <code>G</code>. And then if you add <code>[fintype G]</code> in some theorem then it will automatically be a finite graph.</p>

<a name="168205955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/products%20of%20sets/near/168205955" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/67209productsofsets.html#168205955">Simon Pepin Lehalleur (Jun 15 2019 at 12:22)</a>:</h4>
<p>Such a type then has a cardinality in nat? And is fintype inherited by subsets?</p>

<a name="168205961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/products%20of%20sets/near/168205961" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/67209productsofsets.html#168205961">Kevin Buzzard (Jun 15 2019 at 12:22)</a>:</h4>
<p>by subtypes? ;-) Yes, I should think so.</p>

<a name="168205964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/products%20of%20sets/near/168205964" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/67209productsofsets.html#168205964">Kevin Buzzard (Jun 15 2019 at 12:22)</a>:</h4>
<p>And yes, the cardinality would be in nat.</p>

<a name="168206070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/products%20of%20sets/near/168206070" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/67209productsofsets.html#168206070">Kevin Buzzard (Jun 15 2019 at 12:26)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">fintype</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">fintype</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">//</span> <span class="n">P</span> <span class="n">g</span><span class="o">}</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span> <span class="c1">-- fails</span>
</pre></div>


<p>ha ha it fails. </p>
<div class="codehilite"><pre><span></span><span class="bp">#</span><span class="kn">check</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">card</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">fintype.card : Π (α : Type u_1) [_inst_1 : fintype α], ℕ</span>
<span class="cm">-/</span>
</pre></div>


<p>At least that part worked.</p>
<p>The reason finite stuff is hard to work with in type theory is that a <code>finset X</code> (a finite subset of X) is defined to be a list of elements of X, plus a proof that the elements in the list are all different to each other, modulo the equivalence relation given by permutation of elements of the list (a list is ordered).</p>

<a name="168206184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/products%20of%20sets/near/168206184" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/67209productsofsets.html#168206184">Kevin Buzzard (Jun 15 2019 at 12:30)</a>:</h4>
<p>If your basic object is a type, and your basic ways of building types are inductive types and function types (which is what we have in Lean), then you have to readjust a little. Finite sets are not hard to work with, but that is only because computer scientists wrote thousands of lines of code to enable mathematicians to work with them: </p>
<p><a href="https://github.com/leanprover-community/mathlib/blob/master/src/data/fintype.lean" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/src/data/fintype.lean">https://github.com/leanprover-community/mathlib/blob/master/src/data/fintype.lean</a></p>
<p>which relies on</p>
<p><a href="https://github.com/leanprover-community/mathlib/blob/master/src/data/finset.lean" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/src/data/finset.lean">https://github.com/leanprover-community/mathlib/blob/master/src/data/finset.lean</a></p>
<p>which relies on</p>
<p><a href="https://github.com/leanprover-community/mathlib/blob/master/src/data/multiset.lean" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/src/data/multiset.lean">https://github.com/leanprover-community/mathlib/blob/master/src/data/multiset.lean</a></p>
<p>and that is already about 6000 lines.</p>
<p>A subtype of a finite type should be finite -- I'm sure that will be in there somewhere; I just failed to prove it myself.</p>

<a name="168206198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/products%20of%20sets/near/168206198" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/67209productsofsets.html#168206198">Kevin Buzzard (Jun 15 2019 at 12:31)</a>:</h4>
<p>The issue is that finiteness turns out to be a subtle business, apparently, in type theory.</p>

<a name="168206256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/products%20of%20sets/near/168206256" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/67209productsofsets.html#168206256">Johan Commelin (Jun 15 2019 at 12:33)</a>:</h4>
<p><span class="user-mention" data-user-id="224267">@Simon Pepin Lehalleur</span> Here is a little catalogue:</p>
<ul>
<li>There is <code>finset</code>. If you write <code>s : finset X</code> for some arbitrary type <code>X</code>, then you express that you have a finite set of elements of type <code>X</code>. Kevin just told you how it is implemented.</li>
<li>There is <code>finite</code>. If you hae <code>s : set X</code>, then <code>finite s</code> expresses that the arbitrary set <code>s</code> is actually finite. There are functions that turn <code>s</code> into a <code>finset X</code> given a proof of <code>finite s</code>, and vice versa: if you have <code>s : finset X</code>, then you can view <code>s</code> as a <code>set X</code> (by coercion, so it's quite transparent) and you there will be a lemma that says that this <code>s</code> is <code>finite</code>.</li>
<li>There is <code>fintype</code>. This expresses that a certain type is finite. This uses the type class system, which in theory means that lots of things inherite <code>fintype</code> (e.g. a product of fintypes is a fintype). I think that Kevin's example above should work, I'm not sure why it fails.</li>
</ul>

<a name="168206257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/products%20of%20sets/near/168206257" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/67209productsofsets.html#168206257">Marc Huisinga (Jun 15 2019 at 12:33)</a>:</h4>
<p>iirc the statement "subsets of finite sets are finite" is also equivalent to LEM (<a href="http://math.andrej.com/2009/09/07/constructive-stone-finite-sets/" target="_blank" title="http://math.andrej.com/2009/09/07/constructive-stone-finite-sets/">http://math.andrej.com/2009/09/07/constructive-stone-finite-sets/</a>)</p>

<a name="168206368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/products%20of%20sets/near/168206368" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/67209productsofsets.html#168206368">Johan Commelin (Jun 15 2019 at 12:36)</a>:</h4>
<p>I wouldn't be surprised if Simon is not interested in that at all... <span aria-label="stuck out tongue wink" class="emoji emoji-1f61c" role="img" title="stuck out tongue wink">:stuck_out_tongue_wink:</span></p>

<a name="168206649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/products%20of%20sets/near/168206649" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/67209productsofsets.html#168206649">Johan Commelin (Jun 15 2019 at 12:46)</a>:</h4>
<p><span class="user-mention" data-user-id="224267">@Simon Pepin Lehalleur</span>  Do you have a particular goal in mind?</p>

<a name="168207059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/products%20of%20sets/near/168207059" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/67209productsofsets.html#168207059">Bryan Gin-ge Chen (Jun 15 2019 at 13:01)</a>:</h4>
<blockquote>
<p>Do you have nice examples of combinatorics of finite sets in lean which I could learn from?</p>
</blockquote>
<p>A while back I wrote <a href="https://github.com/leanprover-fork/mathlib-backup/blob/tutorials/tutorials/partitions.lean" target="_blank" title="https://github.com/leanprover-fork/mathlib-backup/blob/tutorials/tutorials/partitions.lean">this file on partitions of finite sets</a> (with lots of help from Zulip!). It was meant to address <a href="https://mathoverflow.net/a/311159/" target="_blank" title="https://mathoverflow.net/a/311159/">a challenge</a> of <span class="user-mention" data-user-id="130308">@Neil Strickland</span>'s. Since then Neil has shared quite a few Lean files of his own <a href="https://github.com/NeilStrickland/lean_lib/tree/master/src/combinatorics" target="_blank" title="https://github.com/NeilStrickland/lean_lib/tree/master/src/combinatorics">in a combinatorics directory here</a> (including, among lots of other things, an alternative and probably nicer version of partitions).</p>

<a name="168207161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/products%20of%20sets/near/168207161" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/67209productsofsets.html#168207161">Simon Pepin Lehalleur (Jun 15 2019 at 13:04)</a>:</h4>
<p>I want to work my way towards stating Ramsey's theorem.</p>

<a name="168207235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/products%20of%20sets/near/168207235" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/67209productsofsets.html#168207235">Johan Commelin (Jun 15 2019 at 13:07)</a>:</h4>
<p>Aha, that seems like a nice challenge</p>

<a name="168207272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/products%20of%20sets/near/168207272" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/67209productsofsets.html#168207272">Johan Commelin (Jun 15 2019 at 13:08)</a>:</h4>
<p>We haven't done any graph theory so far...</p>

<a name="168207290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/products%20of%20sets/near/168207290" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/67209productsofsets.html#168207290">Simon Pepin Lehalleur (Jun 15 2019 at 13:09)</a>:</h4>
<p>My first idea was to look at category theory, but that looked very tricky... I thought finite sets would be easier!</p>

<a name="168207716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/products%20of%20sets/near/168207716" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/67209productsofsets.html#168207716">Johan Commelin (Jun 15 2019 at 13:24)</a>:</h4>
<p>The foundations of category theory are there. <span class="user-mention" data-user-id="110087">@Scott Morrison</span> is working on monoidal categories. We have the basic framework of limits/colimits.</p>

<a name="168207773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/products%20of%20sets/near/168207773" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/67209productsofsets.html#168207773">Johan Commelin (Jun 15 2019 at 13:26)</a>:</h4>
<p><span class="user-mention" data-user-id="224267">@Simon Pepin Lehalleur</span> I just remember that Jeremy recently talked about some graph-theoretic things in Lean: <a href="#narrow/stream/113488-general/topic/Type.20classes.20again/near/167340123" title="#narrow/stream/113488-general/topic/Type.20classes.20again/near/167340123">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type.20classes.20again/near/167340123</a></p>

<a name="168207780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/products%20of%20sets/near/168207780" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/67209productsofsets.html#168207780">Johan Commelin (Jun 15 2019 at 13:26)</a>:</h4>
<p>You might find some useful things there.</p>

<a name="168207892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/products%20of%20sets/near/168207892" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/67209productsofsets.html#168207892">Kevin Buzzard (Jun 15 2019 at 13:30)</a>:</h4>
<blockquote>
<p>My first idea was to look at category theory, but that looked very tricky... I thought finite sets would be easier!</p>
</blockquote>
<p>I think that stating Ramsey's theorem is a very nice first project. Here is what will happen: you will try to write down mathematics, but in many cases to get from one step to the next (e.g. A and B are finite, hence A union B is finite) -- steps which a mathematician would say "it's obvious" -- you will need to apply a function. The thousands of lines of code which I linked to above are the community's attempt to write down every function you would ever need. So the main difficulty you will face (when you have learned the basic syntax etc) is that you don't know the names of any functions. There are four ways to deal with this problem. First, you can just ask here. Second, you can learn how to use the tactic which searches the library for the function you need. Third, you can begin to learn the logic which computer scientists use when naming these functions, and then fourth, when it is all beginning to make enough sense for this not to be a terrifying option -- you can just read the library code yourself. This is exactly how I learnt to use Lean (apart from the fact that the tactic which searches through the library didn't exist 2 years ago :-) )</p>

<a name="168208445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/products%20of%20sets/near/168208445" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/67209productsofsets.html#168208445">Mario Carneiro (Jun 15 2019 at 13:47)</a>:</h4>
<p>the reason kevin's example failed is because he didn't say <code>P</code> is decidable or use classical magic</p>

<a name="168208525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/products%20of%20sets/near/168208525" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/67209productsofsets.html#168208525">Kevin Buzzard (Jun 15 2019 at 13:49)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">fintype</span>

<span class="n">local</span> <span class="n">attribute</span> <span class="o">[</span><span class="kn">instance</span><span class="o">,</span> <span class="n">priority</span> <span class="mi">0</span><span class="o">]</span> <span class="n">classical</span><span class="bp">.</span><span class="n">prop_decidable</span>

<span class="n">noncomputable</span> <span class="n">theory</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">fintype</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">//</span> <span class="n">P</span> <span class="n">g</span><span class="o">}</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span> <span class="c1">-- works</span>
</pre></div>


<p>This file now says: (1) import the file which does finite types. (2) and (3): switch on mathematician mode. (4) a subtype of a finite type is finite.</p>

<a name="168208583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/products%20of%20sets/near/168208583" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/67209productsofsets.html#168208583">Kevin Buzzard (Jun 15 2019 at 13:50)</a>:</h4>
<p>The computer scientists still believe in the Curry-Howard correspondence, so instead of a proof that a subset of a finite set is finite, they want an algorithm.</p>

<a name="168208593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/products%20of%20sets/near/168208593" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/67209productsofsets.html#168208593">Kevin Buzzard (Jun 15 2019 at 13:51)</a>:</h4>
<p>You can tell them not to be so demanding with those lines 2 and 3.</p>

<a name="168209341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/products%20of%20sets/near/168209341" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/67209productsofsets.html#168209341">Patrick Massot (Jun 15 2019 at 14:14)</a>:</h4>
<blockquote>
<p>Lean does have this <code>set</code> thing, but it really means "subset". So if you write <code>s: set alpha</code> then you are really thinking of s as a subset of alpha or a subtype of alpha or whatever you want to call it. </p>
</blockquote>
<p>I think this is a misleading way of explaining this difference, which is biased by our set theoretic foundations background. It's some kind of accident that set theoretic foundations make no difference at all between sets that come up in real life and weird collections like <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>{</mo><mn>1</mn><mo separator="true">,</mo><mrow><mi mathvariant="double-struck">R</mi></mrow><mo separator="true">,</mo><mi>sin</mi><mo>}</mo></mrow><annotation encoding="application/x-tex">\{1, \mathbb{R}, \sin\}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">{</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord"><span class="mord mathbb">R</span></span><span class="mpunct">,</span><span class="mop">sin</span><span class="mclose">}</span></span></span></span>. It's because everything is a set and almost everything can be put inside a set. In type theory you can talk about such sets but you'll have to struggle a bit, which I think is fair. However you won't have to struggle to discuss sets whose elements are real numbers, or sets whose elements are functions from real numbers to real numbers. And you shouldn't think of them as subsets of anythings. They are homogeneous collections of things of the same type.</p>


{% endraw %}

{% include archive_update.html %}