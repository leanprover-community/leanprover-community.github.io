---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113489newmembers/96840residueclass.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/96840residueclass.html">residue class</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="191278733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/residue%20class/near/191278733" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/96840residueclass.html#191278733">Brian Jiang (Mar 20 2020 at 17:54)</a>:</h4>
<p>How would you define a reduced residue class module n in lean? After defining it I also want to be able to multiply the generic elements of the residue class together (part of a proof for Euler's theorem)</p>

<a name="191279378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/residue%20class/near/191279378" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/96840residueclass.html#191279378">Johan Commelin (Mar 20 2020 at 17:59)</a>:</h4>
<p><code>k % n</code>?</p>

<a name="191279400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/residue%20class/near/191279400" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/96840residueclass.html#191279400">Johan Commelin (Mar 20 2020 at 17:59)</a>:</h4>
<p>Or <code>(k : zmod n)</code></p>

<a name="191279437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/residue%20class/near/191279437" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/96840residueclass.html#191279437">Johan Commelin (Mar 20 2020 at 17:59)</a>:</h4>
<p>Note that Euler's theorem was just added to mathlib this week</p>

<a name="191279556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/residue%20class/near/191279556" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/96840residueclass.html#191279556">orlando (Mar 20 2020 at 18:00)</a>:</h4>
<p>In mathlib, zmod is in the file " data " !</p>

<a name="191280337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/residue%20class/near/191280337" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/96840residueclass.html#191280337">Brian Jiang (Mar 20 2020 at 18:05)</a>:</h4>
<p>thanks! I'm just trying to prove it myself as an exercise.  <span class="user-mention silent" data-user-id="112680">Johan Commelin</span>  can you please clarify how what you wrote gets the desired result? I want a set of numbers that are congruent to all values &lt; n that don't share a common factor with n. Thanks!</p>

<a name="191281171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/residue%20class/near/191281171" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/96840residueclass.html#191281171">Johan Commelin (Mar 20 2020 at 18:11)</a>:</h4>
<p>There are various ways to approach this.</p>
<ol>
<li><code>units (zmod n)</code></li>
<li><code>{ k : nat | k &lt; n \and k.coprime n }</code></li>
<li><code>(finset.range n).filter $ assume k, k.coprime n</code></li>
<li>...</li>
</ol>

<a name="191281766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/residue%20class/near/191281766" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/96840residueclass.html#191281766">Kevin Buzzard (Mar 20 2020 at 18:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="269735">Brian Jiang</span> <a href="#narrow/stream/113489-new-members/topic/residue.20class/near/191280337" title="#narrow/stream/113489-new-members/topic/residue.20class/near/191280337">said</a>:</p>
<blockquote>
<p>I want a set of numbers that are congruent to all values &lt; n that don't share a common factor with n. Thanks!</p>
</blockquote>
<p>The issue is that in Lean there are multiple ways to construct such a collection, and the best way will probably depend on what you want to do with it. It's like asking the best way to write a computer program which stores a graph -- there are many ways, and the best way depends on what you want to do with the graphs you store.</p>

<a name="191407437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/residue%20class/near/191407437" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/96840residueclass.html#191407437">Brian Jiang (Mar 22 2020 at 17:47)</a>:</h4>
<p>if I define the residue class as follows: <br>
<code>def reduced_residue_class (n: nat):={ k : nat | k &lt; n \and k.coprime n }</code></p>

<a name="191407479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/residue%20class/near/191407479" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/96840residueclass.html#191407479">Brian Jiang (Mar 22 2020 at 17:48)</a>:</h4>
<p>is there a way I can write a theorem regarding the number of elements in this set?</p>

<a name="191407503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/residue%20class/near/191407503" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/96840residueclass.html#191407503">Brian Jiang (Mar 22 2020 at 17:48)</a>:</h4>
<p>I would also like to take out elements from this set and multiply them together</p>

<a name="191417399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/residue%20class/near/191417399" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/96840residueclass.html#191417399">Kevin Buzzard (Mar 22 2020 at 21:35)</a>:</h4>
<p>Your definition is a slightly artificial way to think about this concept. The naturals already have a multiplication on them, and you are proposing defining another one. Mathematically a more natural way to do this would be to define your set to be the units of the ring <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi><mi mathvariant="normal">/</mi><mi>n</mi><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}/n\mathbb{Z}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbb">Z</span></span><span class="mord">/</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span>, and this would automatically inherit a group structure.</p>

<a name="191417414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/residue%20class/near/191417414" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/96840residueclass.html#191417414">Kevin Buzzard (Mar 22 2020 at 21:36)</a>:</h4>
<p>If you want to roll your own then you will have to prove that if a and b are coprime to n then so is their product.</p>

<a name="191417914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/residue%20class/near/191417914" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/96840residueclass.html#191417914">Kevin Buzzard (Mar 22 2020 at 21:47)</a>:</h4>
<p>If you want to use mathlib's pre-rolled repesentation of this type then you have access to theorems like this:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">zmod</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ+</span><span class="o">)</span> <span class="o">:</span> <span class="n">units</span> <span class="o">(</span><span class="n">zmod</span> <span class="n">n</span><span class="o">)</span> <span class="err">≃</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">n</span> <span class="bp">//</span> <span class="n">nat</span><span class="bp">.</span><span class="n">coprime</span> <span class="n">x</span><span class="bp">.</span><span class="n">val</span> <span class="n">n</span><span class="o">}</span> <span class="o">:=</span>
<span class="n">zmod</span><span class="bp">.</span><span class="n">units_equiv_coprime</span>
</pre></div>

<a name="191418065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/residue%20class/near/191418065" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/96840residueclass.html#191418065">Brian Jiang (Mar 22 2020 at 21:50)</a>:</h4>
<p>is there a way with my definition to set a variable equal to the product of all the elements in the set?</p>

<a name="191418079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/residue%20class/near/191418079" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/96840residueclass.html#191418079">Brian Jiang (Mar 22 2020 at 21:51)</a>:</h4>
<p>that is what I meant earlier by multiplication, not to show if the product of two elements is still inside the set; sorry if that wasn't clear</p>

<a name="191418094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/residue%20class/near/191418094" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/96840residueclass.html#191418094">Kevin Buzzard (Mar 22 2020 at 21:51)</a>:</h4>
<p>Are you going to roll your own, or are you going to use the inbuilt one?</p>

<a name="191418137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/residue%20class/near/191418137" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/96840residueclass.html#191418137">Brian Jiang (Mar 22 2020 at 21:52)</a>:</h4>
<p>on my own, if possible</p>

<a name="191418236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/residue%20class/near/191418236" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/96840residueclass.html#191418236">Brian Jiang (Mar 22 2020 at 21:55)</a>:</h4>
<p>also, is there a way to get the size of a set?</p>

<a name="191418242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/residue%20class/near/191418242" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/96840residueclass.html#191418242">Brian Jiang (Mar 22 2020 at 21:55)</a>:</h4>
<p>also, is there a way to get the size of a set?</p>

<a name="191418629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/residue%20class/near/191418629" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/96840residueclass.html#191418629">Brian Jiang (Mar 22 2020 at 22:05)</a>:</h4>
<p>my current intention is to take a reduced residue class made up of (r1, r2, ...rn)</p>

<a name="191418636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/residue%20class/near/191418636" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/96840residueclass.html#191418636">Ryan Lahfa (Mar 22 2020 at 22:05)</a>:</h4>
<p>If you prove it's finite, you can have a finite cardinal: <a href="https://leanprover-community.github.io/mathlib_docs/data/set/finite.html" target="_blank" title="https://leanprover-community.github.io/mathlib_docs/data/set/finite.html">https://leanprover-community.github.io/mathlib_docs/data/set/finite.html</a></p>

<a name="191418645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/residue%20class/near/191418645" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/96840residueclass.html#191418645">Brian Jiang (Mar 22 2020 at 22:05)</a>:</h4>
<p>and show that the product r1r2...rn is congruent to (ar1)(ar2)...(arn)</p>

<a name="191418760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/residue%20class/near/191418760" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/96840residueclass.html#191418760">Brian Jiang (Mar 22 2020 at 22:08)</a>:</h4>
<p>@Ryan Lahfa : what does the finite cardinal do?</p>


{% endraw %}

{% include archive_update.html %}