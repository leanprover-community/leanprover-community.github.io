---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/113489newmembers/51886Induction.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html">Induction</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="134579977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/134579977" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#134579977">Alistair Tucker (Sep 25 2018 at 07:30)</a>:</h4>
<p>Hello again! I'm still having a little trouble with my induction. In the example below the second dite gives me</p>
<div class="codehilite"><pre><span></span><span class="n">term</span>
  <span class="bp">λ</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">card</span> <span class="n">s</span> <span class="bp">≠</span> <span class="n">n</span><span class="o">),</span> <span class="n">sol</span><span class="bp">.</span><span class="n">v</span> <span class="n">s</span> <span class="bp">_</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="bp">Π</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">card</span> <span class="n">s</span> <span class="bp">≠</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">sol</span><span class="bp">.</span><span class="n">V</span> <span class="n">s</span> <span class="bp">_</span> <span class="bp">→</span> <span class="n">β</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="bp">¬</span><span class="n">card</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">→</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">V</span> <span class="n">s</span> <span class="n">hs</span> <span class="bp">→</span> <span class="n">β</span>
</pre></div>


<p>But by the definition, V s hs should be the same as sol.V s (lt_of_ne s hs h)?</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">finset</span>
<span class="kn">open</span> <span class="n">nat</span> <span class="n">finset</span>

<span class="n">def</span> <span class="n">names</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">string</span> <span class="o">:=</span> <span class="o">{</span><span class="s2">&quot;BARC&quot;</span><span class="o">,</span> <span class="s2">&quot;HSBC&quot;</span><span class="o">,</span> <span class="s2">&quot;LLOY&quot;</span><span class="o">,</span> <span class="s2">&quot;NATW&quot;</span><span class="o">,</span> <span class="s2">&quot;RBSG&quot;</span><span class="o">,</span> <span class="s2">&quot;SANT&quot;</span><span class="o">,</span> <span class="s2">&quot;STDCH&quot;</span><span class="o">}</span>
<span class="n">def</span> <span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">string</span> <span class="bp">//</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">names</span><span class="o">}</span>

<span class="kn">structure</span> <span class="n">soln</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">B</span><span class="o">),</span> <span class="n">card</span> <span class="n">s</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">card</span> <span class="n">s</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">V</span> <span class="n">s</span> <span class="n">hs</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>

<span class="kn">variable</span> <span class="o">{</span><span class="n">find_domain</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">card</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">soln</span> <span class="n">α</span> <span class="n">β</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span>
<span class="kn">variable</span> <span class="o">{</span><span class="n">solve_pde</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">card</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">soln</span> <span class="n">α</span> <span class="n">β</span> <span class="n">n</span> <span class="bp">→</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span>

<span class="n">def</span> <span class="n">solve_system</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="n">soln</span> <span class="n">α</span> <span class="n">β</span> <span class="n">n</span> <span class="o">:=</span>
<span class="n">nat</span><span class="bp">.</span><span class="n">rec</span>
    <span class="o">(</span><span class="k">let</span> <span class="n">V</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">card</span> <span class="n">s</span> <span class="bp">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">false</span><span class="bp">.</span><span class="n">elim</span> <span class="o">(</span><span class="n">not_lt_zero</span> <span class="o">(</span><span class="n">card</span> <span class="n">s</span><span class="o">)</span> <span class="n">hs</span><span class="o">)</span> <span class="k">in</span>
        <span class="k">let</span> <span class="n">v</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">card</span> <span class="n">s</span> <span class="bp">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">V</span> <span class="n">s</span> <span class="n">hs</span> <span class="bp">→</span> <span class="n">β</span> <span class="o">:=</span> <span class="n">false</span><span class="bp">.</span><span class="n">elim</span> <span class="o">(</span><span class="n">not_lt_zero</span> <span class="o">(</span><span class="n">card</span> <span class="n">s</span><span class="o">)</span> <span class="n">hs</span><span class="o">)</span> <span class="k">in</span>
        <span class="bp">@</span><span class="n">soln</span><span class="bp">.</span><span class="n">mk</span> <span class="n">α</span> <span class="n">β</span> <span class="mi">0</span> <span class="n">V</span> <span class="n">v</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">sol</span> <span class="o">:</span> <span class="n">soln</span> <span class="n">α</span> <span class="n">β</span> <span class="n">n</span><span class="o">),</span>
        <span class="k">let</span> <span class="n">lt_of_ne</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">card</span> <span class="n">s</span> <span class="bp">&lt;</span> <span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">card</span> <span class="n">s</span> <span class="bp">≠</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">card</span> <span class="n">s</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="o">:=</span>
            <span class="k">have</span> <span class="n">h1</span> <span class="o">:</span> <span class="n">card</span> <span class="n">s</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">∨</span> <span class="n">card</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">n</span><span class="o">,</span> <span class="k">from</span> <span class="n">lt_succ_iff_lt_or_eq</span><span class="bp">.</span><span class="n">mp</span> <span class="n">hs</span><span class="o">,</span>
            <span class="k">assume</span> <span class="n">h2</span> <span class="o">:</span> <span class="n">card</span> <span class="n">s</span> <span class="bp">≠</span> <span class="n">n</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">elim</span> <span class="n">h1</span> <span class="n">id</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">absurd</span> <span class="n">h</span> <span class="n">h2</span><span class="o">)</span> <span class="k">in</span>
        <span class="k">let</span> <span class="n">V</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">card</span> <span class="n">s</span> <span class="bp">&lt;</span> <span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="o">:=</span>
            <span class="n">dite</span> <span class="o">(</span><span class="n">card</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span>
                <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">card</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">n</span><span class="o">),</span> <span class="n">find_domain</span> <span class="n">α</span> <span class="n">β</span> <span class="n">n</span> <span class="n">s</span> <span class="n">h</span> <span class="n">sol</span><span class="o">)</span>
                <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">card</span> <span class="n">s</span> <span class="bp">≠</span> <span class="n">n</span><span class="o">),</span> <span class="n">sol</span><span class="bp">.</span><span class="n">V</span> <span class="n">s</span> <span class="o">(</span><span class="n">lt_of_ne</span> <span class="n">s</span> <span class="n">hs</span> <span class="n">h</span><span class="o">))</span> <span class="k">in</span>
        <span class="k">let</span> <span class="n">v</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">card</span> <span class="n">s</span> <span class="bp">&lt;</span> <span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">V</span> <span class="n">s</span> <span class="n">hs</span> <span class="bp">→</span> <span class="n">β</span> <span class="o">:=</span>
            <span class="n">dite</span> <span class="o">(</span><span class="n">card</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span>
                <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">card</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">n</span><span class="o">),</span> <span class="n">solve_pde</span> <span class="n">α</span> <span class="n">β</span> <span class="n">n</span> <span class="n">s</span> <span class="n">h</span> <span class="n">sol</span> <span class="o">(</span><span class="n">V</span> <span class="n">s</span> <span class="n">hs</span><span class="o">))</span>
                <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">card</span> <span class="n">s</span> <span class="bp">≠</span> <span class="n">n</span><span class="o">),</span> <span class="n">sol</span><span class="bp">.</span><span class="n">v</span> <span class="n">s</span> <span class="o">(</span><span class="n">lt_of_ne</span> <span class="n">s</span> <span class="n">hs</span> <span class="n">h</span><span class="o">))</span> <span class="k">in</span>
        <span class="bp">@</span><span class="n">soln</span><span class="bp">.</span><span class="n">mk</span> <span class="n">α</span> <span class="n">β</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="n">V</span> <span class="n">v</span><span class="o">)</span>
</pre></div>

<a name="134579994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/134579994" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#134579994">Alistair Tucker (Sep 25 2018 at 07:30)</a>:</h4>
<p>As you can probably tell by the names, I am attempting some applied mathematics :)</p>

<a name="134590793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/134590793" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#134590793">Reid Barton (Sep 25 2018 at 11:49)</a>:</h4>
<p><code>V s hs</code> isn't equal to <code>sol.V s (lt_of_ne s hs h)</code> in general, only when you have the hypothesis <code>¬card s = n</code>, and even then it's not a definitional equality. You have to use <code>dif_neg</code> to simplify the <code>dite</code>.</p>

<a name="134590965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/134590965" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#134590965">Reid Barton (Sep 25 2018 at 11:53)</a>:</h4>
<p>I haven't looked carefully at what's going on here, but I wonder if there might be an easier way--it looks like you're constructing a "solution for all sets of size &lt; n" by induction on n, where we just pass to the inductive hypothesis if the set is not of the new size--then why not just define a "solution for all sets of size = n", and then if you want to reproduce the type of <code>soln</code>, just provide <code>n = card s</code></p>

<a name="134592386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/134592386" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#134592386">Alistair Tucker (Sep 25 2018 at 12:20)</a>:</h4>
<p>Thanks! I have applied dif_neg but the final step eludes me...</p>
<div class="codehilite"><pre><span></span><span class="k">let</span> <span class="n">v</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">card</span> <span class="n">s</span> <span class="bp">&lt;</span> <span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">V</span> <span class="n">s</span> <span class="n">hs</span> <span class="bp">→</span> <span class="n">β</span> <span class="o">:=</span>
    <span class="n">dite</span> <span class="o">(</span><span class="n">card</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span>
        <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">card</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">n</span><span class="o">),</span> <span class="n">solve_pde</span> <span class="n">α</span> <span class="n">β</span> <span class="n">n</span> <span class="n">s</span> <span class="n">h</span> <span class="n">sol</span> <span class="o">(</span><span class="n">V</span> <span class="n">s</span> <span class="n">hs</span><span class="o">))</span>
        <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">card</span> <span class="n">s</span> <span class="bp">≠</span> <span class="n">n</span><span class="o">),</span>
            <span class="k">have</span> <span class="n">V</span> <span class="n">s</span> <span class="n">hs</span> <span class="bp">=</span> <span class="n">sol</span><span class="bp">.</span><span class="n">V</span> <span class="n">s</span> <span class="o">(</span><span class="n">lt_of_ne</span> <span class="n">s</span> <span class="n">hs</span> <span class="n">h</span><span class="o">),</span> <span class="k">from</span> <span class="n">dif_neg</span> <span class="n">h</span><span class="o">,</span>
            <span class="n">sol</span><span class="bp">.</span><span class="n">v</span> <span class="n">s</span> <span class="o">(</span><span class="n">lt_of_ne</span> <span class="n">s</span> <span class="n">hs</span> <span class="n">h</span><span class="o">))</span> <span class="k">in</span>
</pre></div>

<a name="134592520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/134592520" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#134592520">Alistair Tucker (Sep 25 2018 at 12:23)</a>:</h4>
<p>Your description of my intended algorithm is spot on. The reason I am trying to accumulate the Vs and vs in each successive soln is so that I can prove certain relations between them.</p>

<a name="134592759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/134592759" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#134592759">Reid Barton (Sep 25 2018 at 12:27)</a>:</h4>
<p>Now there are two ways to proceed</p>

<a name="134592811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/134592811" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#134592811">Reid Barton (Sep 25 2018 at 12:28)</a>:</h4>
<p>The easier way is to change the last line to something like <code>by rw this; exact sol.v s (lt_of_ne s hs h)</code>, or the term-mode equivalent using <code>eq.rec</code></p>

<a name="134593877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/134593877" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#134593877">Alistair Tucker (Sep 25 2018 at 12:44)</a>:</h4>
<p>Got it! Thank you.</p>

<a name="134594108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/134594108" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#134594108">Reid Barton (Sep 25 2018 at 12:48)</a>:</h4>
<p>The slightly more complicated way is to instead use the equality <code>this</code> to turn the hypothesis <code>y ∈ V s hs</code> into a proof of <code>y ∈ sol.V s _</code>--this will probably make things easier later if you want to prove things about the values of <code>v</code>, because the actual <code>β</code> value won't be wrapped inside a <code>rw</code>/<code>eq.rec</code></p>

<a name="154250457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154250457" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154250457">Patrick Thomas (Jan 03 2019 at 16:40)</a>:</h4>
<p>Suppose I have the following:</p>
<div class="codehilite"><pre><span></span><span class="kn">namespace</span> <span class="n">lambda</span>

<span class="kn">inductive</span> <span class="n">exp</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">:</span> <span class="n">string</span> <span class="bp">→</span> <span class="n">exp</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">:</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span>
<span class="bp">|</span> <span class="n">abs</span> <span class="o">:</span> <span class="n">string</span> <span class="bp">→</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span>

<span class="kn">inductive</span> <span class="n">is_subterm</span> <span class="o">:</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="c1">-- x ∈ Sub (x)</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">string</span><span class="o">),</span> <span class="n">is_subterm</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span>

<span class="c1">-- e1 ∈ Sub ((e1 e2))</span>
<span class="bp">|</span> <span class="n">app_l</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">e1</span> <span class="o">:</span> <span class="n">exp</span><span class="o">)</span> <span class="o">(</span><span class="n">e2</span> <span class="o">:</span> <span class="n">exp</span><span class="o">),</span> <span class="n">is_subterm</span> <span class="n">e1</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">app</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">)</span>

<span class="c1">-- e2 ∈ Sub ((e1 e2))</span>
<span class="bp">|</span> <span class="n">app_r</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">e1</span> <span class="o">:</span> <span class="n">exp</span><span class="o">)</span> <span class="o">(</span><span class="n">e2</span> <span class="o">:</span> <span class="n">exp</span><span class="o">),</span> <span class="n">is_subterm</span> <span class="n">e2</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">app</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">)</span>

<span class="c1">-- (e1 e2) ∈ Sub ((e1 e2))</span>
<span class="bp">|</span> <span class="n">app_self</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">e1</span> <span class="o">:</span> <span class="n">exp</span><span class="o">)</span> <span class="o">(</span><span class="n">e2</span> <span class="o">:</span> <span class="n">exp</span><span class="o">),</span> <span class="n">is_subterm</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">app</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">)</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">app</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">)</span>

<span class="c1">-- e ∈ Sub ((λ x . e))</span>
<span class="bp">|</span> <span class="n">abs</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">exp</span><span class="o">),</span> <span class="n">is_subterm</span> <span class="n">e</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">abs</span> <span class="n">x</span> <span class="n">e</span><span class="o">)</span>

<span class="c1">-- (λ x . e) ∈ Sub ((λ x . e))</span>
<span class="bp">|</span> <span class="n">abs_self</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">exp</span><span class="o">),</span> <span class="n">is_subterm</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">abs</span> <span class="n">x</span> <span class="n">e</span><span class="o">)</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">abs</span> <span class="n">x</span> <span class="n">e</span><span class="o">)</span>
</pre></div>


<p>Is it possible to prove that is_subterm does not hold for something? For example, could one prove that if <code>x</code> is a lambda variable, then the only subterm of <code>x</code> is <code>x</code> itself?</p>

<a name="154250562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154250562" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154250562">Patrick Massot (Jan 03 2019 at 16:42)</a>:</h4>
<p>Doesn't it contradict <code>is_subterm.abs</code>?</p>

<a name="154250752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154250752" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154250752">Patrick Thomas (Jan 03 2019 at 16:46)</a>:</h4>
<p>Are you saying that the statement "if <code>x</code> is a lambda variable, then the only subterm of <code>x</code> is <code>x</code> itself", does not hold because of <code>is_subterm.abs</code>? I'm not sure I see why that would be the case?</p>

<a name="154250754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154250754" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154250754">Gabriel Ebner (Jan 03 2019 at 16:46)</a>:</h4>
<p>This is provable (hint: try the <code>cases</code> tactic):</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">y</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">is_subterm</span> <span class="n">y</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">exp</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span>
</pre></div>

<a name="154250765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154250765" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154250765">Rob Lewis (Jan 03 2019 at 16:46)</a>:</h4>
<p>You may need to be a little careful about how you state it, but this is a good place to take advantage of the equation compiler. It will discharge the structurally impossible cases for you.</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">exp</span><span class="o">),</span> <span class="n">is_subterm</span> <span class="n">e</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">var</span> <span class="n">s</span><span class="o">)</span> <span class="bp">→</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">exp</span><span class="bp">.</span><span class="n">var</span> <span class="n">s</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="n">is_subterm</span><span class="bp">.</span><span class="n">var</span> <span class="bp">_</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>


<p>(As Gabriel points out, <code>cases</code> will do the same thing.)</p>

<a name="154250796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154250796" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154250796">Patrick Massot (Jan 03 2019 at 16:48)</a>:</h4>
<p>oh I missed "variable" in "lambda variable", it's on the next line here</p>

<a name="154251107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154251107" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154251107">Patrick Thomas (Jan 03 2019 at 16:52)</a>:</h4>
<p>Thank you. I will have to do some reading on tactics and the equation compiler.</p>

<a name="154251985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154251985" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154251985">Patrick Thomas (Jan 03 2019 at 17:09)</a>:</h4>
<p>I'm still learning how induction is handled in Lean. Does the inductive definition create theorems related to what is not an object of the defined type?</p>

<a name="154252289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154252289" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154252289">Rob Lewis (Jan 03 2019 at 17:14)</a>:</h4>
<p>The only objects of the defined type are the ones that can be defined using the constructors. This is a "theorem" that's captured by the type's induction principle. In your case, look at <code>#check is_subterm.cases_on </code>.</p>

<a name="154253410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154253410" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154253410">Kenny Lau (Jan 03 2019 at 17:37)</a>:</h4>
<p>should we use <code>nat</code> instead of <code>string</code>?</p>

<a name="154254942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154254942" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154254942">Patrick Thomas (Jan 03 2019 at 18:03)</a>:</h4>
<p>Is the following what Gabriel means by the <code>cases</code> tactic?</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">exp</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">:</span> <span class="n">is_subterm</span> <span class="n">e</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">exp</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span> <span class="o">:=</span>
    <span class="n">exp</span><span class="bp">.</span><span class="n">cases_on</span> <span class="n">e</span>
    <span class="o">(</span><span class="k">show</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">string</span><span class="o">),</span> <span class="n">is_subterm</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span><span class="o">),</span> <span class="k">from</span>
    <span class="k">assume</span> <span class="n">y</span> <span class="o">:</span> <span class="n">string</span><span class="o">,</span>
</pre></div>


<p>I'm not sure how to proceed from here.</p>

<a name="154254968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154254968" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154254968">Kenny Lau (Jan 03 2019 at 18:03)</a>:</h4>
<p>well by the <code>cases</code> tactic he means <code>by cases e</code></p>

<a name="154254973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154254973" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154254973">Kenny Lau (Jan 03 2019 at 18:03)</a>:</h4>
<p>but I don't know if you're familiar with using tactics</p>

<a name="154255034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154255034" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154255034">Patrick Thomas (Jan 03 2019 at 18:04)</a>:</h4>
<p>Oh. No, I'm not.</p>

<a name="154255194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154255194" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154255194">Gabriel Ebner (Jan 03 2019 at 18:06)</a>:</h4>
<p>Actually I mean by cases on the <code>is_subterm</code> proof:<br>
<code>begin intro h, cases h, end</code>  (you can easily solve the remaining goal)</p>

<a name="154265785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154265785" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154265785">Kenny Lau (Jan 03 2019 at 20:55)</a>:</h4>
<p>why bother making <code>is_subterm</code> inductive</p>

<a name="154265902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154265902" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154265902">Patrick Thomas (Jan 03 2019 at 20:57)</a>:</h4>
<p>I thought it would have to be. What is the alternative?</p>

<a name="154266764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154266764" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154266764">Kenny Lau (Jan 03 2019 at 21:13)</a>:</h4>
<p>well it isn't inductive (i.e. recursive) so maybe just make it a def or something</p>

<a name="154267466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154267466" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154267466">Patrick Thomas (Jan 03 2019 at 21:25)</a>:</h4>
<p>Hmm. I was trying to formalize the recursive definition of the set of all subterms of a lambda expression given by definition 1.3.5 here: <a href="https://play.google.com/books/reader?id=orsrBQAAQBAJ&amp;hl=en_US&amp;pg=GBS.PA5.w.4.0.36" target="_blank" title="https://play.google.com/books/reader?id=orsrBQAAQBAJ&amp;hl=en_US&amp;pg=GBS.PA5.w.4.0.36">https://play.google.com/books/reader?id=orsrBQAAQBAJ&amp;hl=en_US&amp;pg=GBS.PA5.w.4.0.36</a><br>
Did I do this wrong?</p>

<a name="154267703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154267703" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154267703">Rob Lewis (Jan 03 2019 at 21:29)</a>:</h4>
<p>You're missing the recursive calls. The set of subterms of (M N) is the union of the subterms of M, the subterms of N, and the singleton set {(M N)}.</p>

<a name="154267747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154267747" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154267747">Rob Lewis (Jan 03 2019 at 21:29)</a>:</h4>
<p>In your definition, (M N) only has three subterms: M, N, and (M N).</p>

<a name="154267858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154267858" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154267858">Rob Lewis (Jan 03 2019 at 21:30)</a>:</h4>
<p>This is a perfectly good situation to use an inductive predicate, but the one you wrote isn't the one you wanted.</p>

<a name="154269430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154269430" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154269430">Patrick Thomas (Jan 03 2019 at 21:56)</a>:</h4>
<p>Does adding the following fix it?</p>
<div class="codehilite"><pre><span></span><span class="bp">|</span> <span class="n">app_l&#39;</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">exp</span><span class="o">)</span> <span class="o">(</span><span class="n">e1</span> <span class="o">:</span> <span class="n">exp</span><span class="o">)</span> <span class="o">(</span><span class="n">e2</span> <span class="o">:</span> <span class="n">exp</span><span class="o">),</span> <span class="o">(</span><span class="n">is_subterm</span> <span class="n">e</span> <span class="n">e1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">is_subterm</span> <span class="n">e</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">app</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">app_r&#39;</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">exp</span><span class="o">)</span> <span class="o">(</span><span class="n">e1</span> <span class="o">:</span> <span class="n">exp</span><span class="o">)</span> <span class="o">(</span><span class="n">e2</span> <span class="o">:</span> <span class="n">exp</span><span class="o">),</span> <span class="o">(</span><span class="n">is_subterm</span> <span class="n">e</span> <span class="n">e2</span><span class="o">)</span> <span class="bp">→</span> <span class="n">is_subterm</span> <span class="n">e</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">app</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">abs&#39;</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">exp</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">(</span><span class="n">e1</span> <span class="o">:</span> <span class="n">exp</span><span class="o">),</span> <span class="o">(</span><span class="n">is_subterm</span> <span class="n">e</span> <span class="n">e1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">is_subterm</span> <span class="n">e</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">abs</span> <span class="n">x</span> <span class="n">e1</span><span class="o">)</span>
</pre></div>


<p>Also, is there a way to formalize this as a set, similar to the definition in the book?</p>

<a name="154269672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154269672" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154269672">Gabriel Ebner (Jan 03 2019 at 22:00)</a>:</h4>
<p>Sure, you can just write a recursive function:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">subterms</span> <span class="o">:</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">multiset</span> <span class="n">exp</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span><span class="n">exp</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span><span class="o">}</span>
<span class="c1">-- ...</span>
</pre></div>


<p>I'm not sure why they use multisets instead of sets though.</p>

<a name="154269810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154269810" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154269810">Rob Lewis (Jan 03 2019 at 22:02)</a>:</h4>
<p>You could add those, and you can also reduce some of the others into one case.</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">is_subterm</span> <span class="o">:</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">self</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">is_subterm</span> <span class="n">x</span> <span class="n">x</span>
<span class="bp">|</span> <span class="n">app_l</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">e₁</span> <span class="n">e₂</span> <span class="n">x</span><span class="o">,</span> <span class="n">is_subterm</span> <span class="n">x</span> <span class="n">e₁</span> <span class="bp">→</span> <span class="n">is_subterm</span> <span class="n">x</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">app</span> <span class="n">e₁</span> <span class="n">e₂</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">app_r</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">e₁</span> <span class="n">e₂</span> <span class="n">x</span><span class="o">,</span> <span class="n">is_subterm</span> <span class="n">x</span> <span class="n">e₂</span> <span class="bp">→</span> <span class="n">is_subterm</span> <span class="n">x</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">app</span> <span class="n">e₁</span> <span class="n">e₂</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">abs</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">e</span> <span class="n">s</span> <span class="n">x</span><span class="o">,</span> <span class="n">is_subterm</span> <span class="n">x</span> <span class="n">e</span> <span class="bp">→</span> <span class="n">is_subterm</span> <span class="n">x</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">abs</span> <span class="n">s</span> <span class="n">e</span><span class="o">)</span>
</pre></div>

<a name="154270313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154270313" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154270313">Kenny Lau (Jan 03 2019 at 22:12)</a>:</h4>
<p>and rename <code>self</code> into <code>refl</code>...</p>

<a name="154270442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154270442" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154270442">Kenny Lau (Jan 03 2019 at 22:15)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">is_subterm</span> <span class="o">:</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="n">e</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">var</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">exp</span><span class="bp">.</span><span class="n">var</span> <span class="n">s</span>
<span class="bp">|</span> <span class="n">e</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">app</span> <span class="n">e₁</span> <span class="n">e₂</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">e</span> <span class="bp">=</span> <span class="n">exp</span><span class="bp">.</span><span class="n">app</span> <span class="n">e₁</span> <span class="n">e₂</span><span class="o">)</span> <span class="bp">||</span> <span class="n">is_subterm</span> <span class="n">e</span> <span class="n">e₁</span> <span class="bp">||</span> <span class="n">is_subterm</span> <span class="n">e</span> <span class="n">e₂</span>
<span class="bp">|</span> <span class="n">e</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">abs</span> <span class="n">s</span> <span class="n">e&#39;</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">e</span> <span class="bp">=</span> <span class="n">exp</span><span class="bp">.</span><span class="n">abs</span> <span class="n">s</span> <span class="n">e&#39;</span><span class="o">)</span> <span class="bp">||</span> <span class="n">is_subterm</span> <span class="n">e</span> <span class="n">e&#39;</span>
</pre></div>

<a name="154270505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154270505" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154270505">Kenny Lau (Jan 03 2019 at 22:16)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">is_subterm</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">exp</span><span class="o">)</span> <span class="o">:</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">var</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">exp</span><span class="bp">.</span><span class="n">var</span> <span class="n">s</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">app</span> <span class="n">e₁</span> <span class="n">e₂</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">e</span> <span class="bp">=</span> <span class="n">exp</span><span class="bp">.</span><span class="n">app</span> <span class="n">e₁</span> <span class="n">e₂</span><span class="o">)</span> <span class="bp">||</span> <span class="n">is_subterm</span> <span class="n">e₁</span> <span class="bp">||</span> <span class="n">is_subterm</span> <span class="n">e₂</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">abs</span> <span class="n">s</span> <span class="n">e&#39;</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">e</span> <span class="bp">=</span> <span class="n">exp</span><span class="bp">.</span><span class="n">abs</span> <span class="n">s</span> <span class="n">e&#39;</span><span class="o">)</span> <span class="bp">||</span> <span class="n">is_subterm</span> <span class="n">e&#39;</span>
</pre></div>

<a name="154270926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154270926" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154270926">Patrick Thomas (Jan 03 2019 at 22:24)</a>:</h4>
<p><span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> Cool. Could something similar be done for the set of all lambda terms?</p>

<a name="160262747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160262747" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160262747">Patrick Thomas (Mar 08 2019 at 04:26)</a>:</h4>
<p>I was wondering what the error "nested occurrence 'and (sub_is_def P x N) (not (has_mem.mem.{0 0} var (set.{0} var) (set.has_mem.{0} var) y (FV N)))' contains variables that are not parameters" means in the last definition of:</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">var</span> <span class="o">:</span> <span class="kt">Type</span>

<span class="kn">inductive</span> <span class="n">pre_term</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">:</span> <span class="n">var</span> <span class="bp">-&gt;</span> <span class="n">pre_term</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">-&gt;</span> <span class="n">pre_term</span> <span class="bp">-&gt;</span> <span class="n">pre_term</span>
<span class="bp">|</span> <span class="n">abs</span> <span class="o">:</span> <span class="n">var</span> <span class="bp">-&gt;</span> <span class="n">pre_term</span> <span class="bp">-&gt;</span> <span class="n">pre_term</span>

<span class="n">def</span> <span class="n">FV</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">-&gt;</span> <span class="n">set</span> <span class="n">var</span>
<span class="bp">|</span> <span class="o">(</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span> <span class="o">)</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">x</span> <span class="o">}</span>
<span class="bp">|</span> <span class="o">(</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span> <span class="o">)</span> <span class="o">:=</span> <span class="n">FV</span> <span class="o">(</span> <span class="n">P</span> <span class="o">)</span> <span class="err">∪</span> <span class="n">FV</span> <span class="o">(</span> <span class="n">Q</span> <span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">x</span> <span class="n">P</span> <span class="o">)</span> <span class="o">:=</span> <span class="n">FV</span> <span class="o">(</span> <span class="n">P</span> <span class="o">)</span> <span class="err">\</span> <span class="o">{</span> <span class="n">x</span> <span class="o">}</span>

<span class="kn">inductive</span> <span class="n">sub_is_def</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">-&gt;</span> <span class="n">var</span> <span class="bp">-&gt;</span> <span class="n">pre_term</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">var_same</span> <span class="o">:</span>
    <span class="k">forall</span> <span class="o">(</span> <span class="n">y</span> <span class="o">:</span> <span class="n">var</span> <span class="o">)</span> <span class="o">(</span> <span class="n">x</span> <span class="o">:</span> <span class="n">var</span> <span class="o">)</span> <span class="o">(</span> <span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="o">),</span>
    <span class="o">(</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">sub_is_def</span> <span class="o">(</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span> <span class="o">)</span> <span class="n">x</span> <span class="n">N</span>
<span class="bp">|</span> <span class="n">var_diff</span> <span class="o">:</span>
    <span class="k">forall</span> <span class="o">(</span> <span class="n">y</span> <span class="o">:</span> <span class="n">var</span> <span class="o">)</span> <span class="o">(</span> <span class="n">x</span> <span class="o">:</span> <span class="n">var</span> <span class="o">)</span> <span class="o">(</span> <span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="o">),</span>
    <span class="n">not</span> <span class="o">(</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">sub_is_def</span> <span class="o">(</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span> <span class="o">)</span> <span class="n">x</span> <span class="n">N</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">:</span>
    <span class="k">forall</span> <span class="o">(</span> <span class="n">P</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="o">)</span> <span class="o">(</span> <span class="n">Q</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="o">)</span> <span class="o">(</span> <span class="n">x</span> <span class="o">:</span> <span class="n">var</span> <span class="o">)</span> <span class="o">(</span> <span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="o">),</span>
    <span class="n">sub_is_def</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">-&gt;</span> <span class="n">sub_is_def</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">-&gt;</span> <span class="n">sub_is_def</span> <span class="o">(</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span> <span class="o">)</span> <span class="n">x</span> <span class="n">N</span>
<span class="bp">|</span> <span class="n">abs_same</span> <span class="o">:</span>
    <span class="k">forall</span> <span class="o">(</span> <span class="n">y</span> <span class="o">:</span> <span class="n">var</span> <span class="o">)</span> <span class="o">(</span> <span class="n">P</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="o">)</span> <span class="o">(</span> <span class="n">x</span> <span class="o">:</span> <span class="n">var</span> <span class="o">)</span> <span class="o">(</span> <span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="o">),</span>
    <span class="o">(</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">sub_is_def</span> <span class="o">(</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span> <span class="o">)</span> <span class="n">x</span> <span class="n">N</span>
<span class="bp">|</span> <span class="n">abs_diff</span> <span class="o">:</span>
    <span class="k">forall</span> <span class="o">(</span> <span class="n">y</span> <span class="o">:</span> <span class="n">var</span> <span class="o">)</span> <span class="o">(</span> <span class="n">P</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="o">)</span> <span class="o">(</span> <span class="n">x</span> <span class="o">:</span> <span class="n">var</span> <span class="o">)</span> <span class="o">(</span> <span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="o">),</span>
    <span class="n">not</span> <span class="o">(</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">FV</span> <span class="o">(</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span> <span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span> <span class="o">(</span> <span class="n">sub_is_def</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span> <span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span> <span class="n">y</span> <span class="err">∉</span> <span class="n">FV</span> <span class="o">(</span> <span class="n">N</span> <span class="o">)</span> <span class="o">)</span> <span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">sub_is_def</span> <span class="o">(</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span> <span class="o">)</span> <span class="n">x</span> <span class="n">N</span>
</pre></div>


<p>It seems to be related to the <code>/\</code> in <code>abs_diff</code>.</p>

<a name="160268512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160268512" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160268512">Mario Carneiro (Mar 08 2019 at 07:00)</a>:</h4>
<p><code>sub_is_def</code> is embedded in a complicated way in the last proposition</p>

<a name="160268710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160268710" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160268710">Mario Carneiro (Mar 08 2019 at 07:06)</a>:</h4>
<p>you have to make it a manifestly positive occurrence:</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">var</span> <span class="o">:</span> <span class="kt">Type</span>

<span class="kn">inductive</span> <span class="n">pre_term</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">:</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span>
<span class="bp">|</span> <span class="n">abs</span> <span class="o">:</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span>

<span class="n">def</span> <span class="n">FV</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">var</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:=</span> <span class="n">FV</span> <span class="n">P</span> <span class="err">∪</span> <span class="n">FV</span> <span class="n">Q</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">x</span> <span class="n">P</span><span class="o">)</span> <span class="o">:=</span> <span class="n">FV</span> <span class="n">P</span> <span class="err">\</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span>

<span class="kn">inductive</span> <span class="n">sub_is_def</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">var_same</span> <span class="o">(</span><span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span>
<span class="bp">|</span> <span class="n">var_diff</span> <span class="o">(</span><span class="n">y</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">{</span><span class="n">P</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span><span class="o">}</span> <span class="o">:</span> <span class="n">sub_is_def</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">P</span><span class="bp">.</span><span class="n">app</span> <span class="n">Q</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span>
<span class="bp">|</span> <span class="n">abs_same</span> <span class="o">(</span><span class="n">P</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">x</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span>
<span class="bp">|</span> <span class="n">abs_diff_nel</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">P</span> <span class="n">N</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">FV</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span>
<span class="bp">|</span> <span class="n">abs_diff</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">P</span> <span class="n">N</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">y</span> <span class="err">∉</span> <span class="n">FV</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span>
</pre></div>

<a name="160349574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160349574" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160349574">Patrick Thomas (Mar 09 2019 at 04:22)</a>:</h4>
<p>Thank you. What does a "manifestly positive occurrence" mean?</p>

<a name="160350668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160350668" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160350668">Mario Carneiro (Mar 09 2019 at 04:52)</a>:</h4>
<p>The definition of an inductive specification in lean requires that all constructors for the inductive type <code>T</code> have the form <code>A1 -&gt; A2 -&gt; ... -&gt; T</code> where each <code>A</code> that mentions <code>T</code> has the form <code>B1 -&gt; B2 -&gt; ... T</code> (ignoring indexes). In other words, the only places the type <code>T</code> is allowed to appear is on the far right hand side (the constructor should produce an element of type <code>T</code>), and on the right of the left hand side (the constructors may take arguments of type <code>T</code> or arguments that are functions producing <code>T</code>). This is called "strict positivity". <code>T</code> is not allowed to appear anywhere else, so <code>mk : (T -&gt; A) -&gt; T</code> is not allowed, nor is <code>mk : ((T -&gt; A) -&gt; A) -&gt; T</code> or <code>foo T -&gt; T</code> or <code>A /\ (T \/ B) -&gt; T</code>. The last two cases are called nested inductive types, and lean can sometimes compile them to primitive inductive types, but they aren't built in.</p>

<a name="160351703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160351703" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160351703">Patrick Thomas (Mar 09 2019 at 05:20)</a>:</h4>
<p>I think I sort of understand. Thank you.</p>

<a name="160352615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160352615" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160352615">Patrick Thomas (Mar 09 2019 at 05:50)</a>:</h4>
<p>Is it possible to have conditions in the constructors for inductively defined functions? For example, how would one define the lambda substitution <code>x [ y := N ]</code>, which depends on whether <code>x = y</code> or <code>x != y</code>?</p>

<a name="160352684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160352684" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160352684">Mario Carneiro (Mar 09 2019 at 05:52)</a>:</h4>
<p>you can use <code>if</code></p>

<a name="160352753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160352753" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160352753">Patrick Thomas (Mar 09 2019 at 05:55)</a>:</h4>
<p>Is there a description of using <code>if</code> in the doc?</p>

<a name="160352800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160352800" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160352800">Mario Carneiro (Mar 09 2019 at 05:56)</a>:</h4>
<p><code>if p then a else b</code> returns <code>a</code> if <code>p</code> is true and <code>b</code> if false</p>

<a name="160352815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160352815" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160352815">Mario Carneiro (Mar 09 2019 at 05:57)</a>:</h4>
<p>In inductive predicates like the above, it's a bit nicer to have separate constructors for the true and false cases, but for recursive functions we usually use <code>if</code></p>

<a name="160353287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160353287" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160353287">Patrick Thomas (Mar 09 2019 at 06:13)</a>:</h4>
<p>For this:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">sub</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="k">if</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="k">then</span> <span class="n">N</span> <span class="k">else</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span>
</pre></div>


<p>I get:<br>
failed to synthesize type class instance for<br>
sub : pre_term → var → pre_term → pre_term,<br>
y x : var,<br>
N : pre_term<br>
⊢ decidable (pre_term.var x = pre_term.var y)</p>

<a name="160353493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160353493" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160353493">Mario Carneiro (Mar 09 2019 at 06:20)</a>:</h4>
<p>you can say <code>if x = y then ...</code></p>

<a name="160353540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160353540" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160353540">Patrick Thomas (Mar 09 2019 at 06:21)</a>:</h4>
<p>I see. I still get the same error.</p>

<a name="160353603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160353603" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160353603">Mario Carneiro (Mar 09 2019 at 06:23)</a>:</h4>
<p>What is <code>var</code>?</p>

<a name="160353647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160353647" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160353647">Patrick Thomas (Mar 09 2019 at 06:24)</a>:</h4>
<p><code>inductive var : Type</code></p>

<a name="160353648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160353648" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160353648">Mario Carneiro (Mar 09 2019 at 06:24)</a>:</h4>
<p>there are no vars?</p>

<a name="160353655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160353655" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160353655">Patrick Thomas (Mar 09 2019 at 06:24)</a>:</h4>
<p>I'm not sure what you mean?</p>

<a name="160353663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160353663" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160353663">Mario Carneiro (Mar 09 2019 at 06:25)</a>:</h4>
<p>that declaration means <code>var</code> is empty</p>

<a name="160353673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160353673" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160353673">Mario Carneiro (Mar 09 2019 at 06:25)</a>:</h4>
<p>you can put <code>@[derive decidable_eq]</code> to automatically derive a decidable instance for <code>var</code></p>

<a name="160353722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160353722" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160353722">Patrick Thomas (Mar 09 2019 at 06:26)</a>:</h4>
<p>Oh. Should I have defined <code>var</code> differently?</p>

<a name="160353727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160353727" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160353727">Mario Carneiro (Mar 09 2019 at 06:26)</a>:</h4>
<p>what do you want it to be? One reasonable choice is <code>def var := nat</code></p>

<a name="160353784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160353784" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160353784">Patrick Thomas (Mar 09 2019 at 06:28)</a>:</h4>
<p>I'm not sure. What would make the most sense for the lambda calculus? Maybe a character or a string?</p>

<a name="160353785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160353785" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160353785">Mario Carneiro (Mar 09 2019 at 06:28)</a>:</h4>
<p>that works too</p>

<a name="160353795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160353795" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160353795">Mario Carneiro (Mar 09 2019 at 06:29)</a>:</h4>
<p>But you have to be careful with how you handle bound variable renaming if you don't use de bruijn indices</p>

<a name="160353800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160353800" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160353800">Mario Carneiro (Mar 09 2019 at 06:29)</a>:</h4>
<p>for example, <code>subst</code> can either rename variables, or it can be partial</p>

<a name="160353866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160353866" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160353866">Mario Carneiro (Mar 09 2019 at 06:31)</a>:</h4>
<p>having it be a char seems like a bad idea because if the set of variables is finite then weird things happen</p>

<a name="160353867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160353867" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160353867">Patrick Thomas (Mar 09 2019 at 06:31)</a>:</h4>
<p>I think it is partial in the book I am following for this. That is, it only defines substitution if it is capture avoiding.</p>

<a name="160353920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160353920" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160353920">Mario Carneiro (Mar 09 2019 at 06:32)</a>:</h4>
<p>if your book uses explicit names then <code>string</code> works</p>

<a name="160353922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160353922" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160353922">Mario Carneiro (Mar 09 2019 at 06:32)</a>:</h4>
<p>but you will need to prove a renaming lemma at some point, which will require you to know that <code>var</code> is infinite</p>

<a name="160353941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160353941" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160353941">Patrick Thomas (Mar 09 2019 at 06:33)</a>:</h4>
<p>Ah. yes.</p>

<a name="160354120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160354120" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160354120">Patrick Thomas (Mar 09 2019 at 06:39)</a>:</h4>
<p>I changed to <code>def var := string</code>.<br>
If I have:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">sub</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="k">then</span> <span class="n">N</span> <span class="k">else</span> <span class="n">y</span>
</pre></div>


<p>Then I get:<br>
type mismatch at application<br>
  ite (x = y) N y<br>
term<br>
  y<br>
has type<br>
  var<br>
but is expected to have type<br>
  pre_term<br>
If I go back to</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">sub</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="k">if</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="k">then</span> <span class="n">N</span> <span class="k">else</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span>
</pre></div>


<p>Then I still get:<br>
failed to synthesize type class instance for<br>
sub : pre_term → var → pre_term → pre_term,<br>
y x : var,<br>
N : pre_term<br>
⊢ decidable (pre_term.var x = pre_term.var y)</p>

<a name="160354192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160354192" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160354192">Patrick Thomas (Mar 09 2019 at 06:41)</a>:</h4>
<p>I see. I still needed <code>@[derive decidable_eq]</code>.</p>

<a name="160354739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160354739" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160354739">Patrick Thomas (Mar 09 2019 at 06:59)</a>:</h4>
<p>Hmm. I'm not sure how the case where substitution is not defined is going to work in this definition. It seems there has to be an <code>else</code> for each <code>if, then</code> and for</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">sub</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="k">if</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="k">then</span> <span class="n">N</span> <span class="k">else</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="n">sub_is_def</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="o">(</span><span class="n">sub</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">sub</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span>
</pre></div>


<p>I get<br>
type expected at<br>
  pre_term.app (sub P x N) (sub Q x N)<br>
term has type<br>
  pre_term</p>

<a name="160355540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160355540" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160355540">Mario Carneiro (Mar 09 2019 at 07:24)</a>:</h4>
<blockquote>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">sub</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="k">then</span> <span class="n">N</span> <span class="k">else</span> <span class="n">y</span>
</pre></div>


</blockquote>
<p>you are getting a type error because of the <code>y</code> at the end</p>

<a name="160355670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160355670" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160355670">Mario Carneiro (Mar 09 2019 at 07:28)</a>:</h4>
<blockquote>
<div class="codehilite"><pre><span></span><span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">sub_is_def</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">∧</span> <span class="n">sub_is_def</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span> <span class="k">then</span> <span class="o">(</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="o">(</span><span class="n">sub</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">sub</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">)</span>
</pre></div>


</blockquote>
<p>Here you don't want to have the <code>if</code> at all. You have already defined the domain of definition of <code>sub</code>, so here you can just do the easy thing - </p>
<div class="codehilite"><pre><span></span>| (pre_term.app P Q) x N := pre_term.app (sub P x N) (sub Q x N)
</pre></div>

<a name="160355685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160355685" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160355685">Mario Carneiro (Mar 09 2019 at 07:29)</a>:</h4>
<p>Alternatively, you can have <code>sub</code> itself be a (partial) functional relation rather than a recursive function</p>

<a name="160355693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160355693" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160355693">Mario Carneiro (Mar 09 2019 at 07:29)</a>:</h4>
<p>that is, define <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>[</mo><mi>x</mi><mo>:</mo><mo>=</mo><mi>N</mi><mo>]</mo><mo>=</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">P[x:=N]=Q</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mopen">[</span><span class="mord mathit">x</span><span class="mrel">:</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mclose">]</span><span class="mrel">=</span><span class="mord mathit">Q</span></span></span></span> as an inductive predicate on four arguments</p>

<a name="160355886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160355886" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160355886">Mario Carneiro (Mar 09 2019 at 07:34)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">is_subst</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">var_same</span> <span class="o">(</span><span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">is_subst</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="n">N</span>
<span class="bp">|</span> <span class="n">var_diff</span> <span class="o">(</span><span class="n">y</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">is_subst</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">{</span><span class="n">P</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span> <span class="n">P&#39;</span> <span class="n">Q&#39;</span><span class="o">}</span> <span class="o">:</span> <span class="n">is_subst</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span> <span class="n">P&#39;</span> <span class="bp">→</span> <span class="n">is_subst</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span> <span class="n">Q&#39;</span>  <span class="bp">→</span> <span class="n">is_subst</span> <span class="o">(</span><span class="n">P</span><span class="bp">.</span><span class="n">app</span> <span class="n">Q</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">(</span><span class="n">P&#39;</span><span class="bp">.</span><span class="n">app</span> <span class="n">Q&#39;</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">abs_same</span> <span class="o">(</span><span class="n">P</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">is_subst</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">x</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">x</span> <span class="n">P</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">abs_diff_nel</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">P</span> <span class="n">N</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">FV</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">is_subst</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">abs_diff</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">P</span> <span class="n">N</span> <span class="n">P&#39;</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">y</span> <span class="err">∉</span> <span class="n">FV</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">is_subst</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span> <span class="n">P&#39;</span> <span class="bp">→</span> <span class="n">is_subst</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P&#39;</span><span class="o">)</span>
</pre></div>

<a name="160355900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160355900" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160355900">Patrick Thomas (Mar 09 2019 at 07:35)</a>:</h4>
<p>Are you saying that whether <code>P x N</code> and <code>Q x N</code> are defined is already somehow part of the definition of <code>sub</code>?</p>

<a name="160355960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160355960" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160355960">Mario Carneiro (Mar 09 2019 at 07:36)</a>:</h4>
<p>I suspect that it will be easier to work with the relation "the substitution of N for x in P is Q" rather than the conjunction of "the substitution is defined" and "the substitution is Q"</p>

<a name="160356021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160356021" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160356021">Patrick Thomas (Mar 09 2019 at 07:38)</a>:</h4>
<p>I have been attempting to follow how the book I am going through does it, so that I can prove the theorems in the same manner. I want to improve the readability of the book for myself and others.</p>

<a name="160356081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160356081" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160356081">Patrick Thomas (Mar 09 2019 at 07:40)</a>:</h4>
<p>It's a little circular. Reading the book to learn about the theory behind Lean, and using Lean to learn the book.</p>

<a name="160356150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160356150" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160356150">Patrick Thomas (Mar 09 2019 at 07:42)</a>:</h4>
<p>In this instance I am formalizing the result of this question: <a href="https://math.stackexchange.com/questions/3109334/formal-definition-of-substitution-being-defined-in-type-free-lambda-calculus?noredirect=1&amp;lq=1" target="_blank" title="https://math.stackexchange.com/questions/3109334/formal-definition-of-substitution-being-defined-in-type-free-lambda-calculus?noredirect=1&amp;lq=1">https://math.stackexchange.com/questions/3109334/formal-definition-of-substitution-being-defined-in-type-free-lambda-calculus?noredirect=1&amp;lq=1</a></p>

<a name="160356479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160356479" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160356479">Patrick Thomas (Mar 09 2019 at 07:53)</a>:</h4>
<p>In the case of</p>
<div class="codehilite"><pre><span></span><span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="o">(</span><span class="n">sub</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">sub</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span>
</pre></div>


<p>what will happen if I pass a pre_term for <code>P</code> or <code>Q</code> to the function for which the substitution is not defined?</p>

<a name="160356646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160356646" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160356646">Mario Carneiro (Mar 09 2019 at 07:58)</a>:</h4>
<p>you get garbage</p>

<a name="160356659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160356659" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160356659">Mario Carneiro (Mar 09 2019 at 07:59)</a>:</h4>
<p>but you get garbage no matter what with the "total function" / "domain of definition" approach</p>

<a name="160356664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160356664" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160356664">Mario Carneiro (Mar 09 2019 at 07:59)</a>:</h4>
<p>The four place relation avoids this</p>

<a name="160356931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160356931" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160356931">Patrick Thomas (Mar 09 2019 at 08:05)</a>:</h4>
<p>I see. I still hate to depart from the book, since many of the proofs involve showing that a given substitution is defined.</p>

<a name="160357096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160357096" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160357096">Patrick Thomas (Mar 09 2019 at 08:08)</a>:</h4>
<p>I think using:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">var</span> <span class="o">:=</span> <span class="n">string</span>
<span class="bp">@</span><span class="o">[</span><span class="n">derive</span> <span class="n">decidable_eq</span><span class="o">]</span>

<span class="kn">inductive</span> <span class="n">pre_term</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">:</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span>
<span class="bp">|</span> <span class="n">abs</span> <span class="o">:</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span>

<span class="n">def</span> <span class="n">FV</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">var</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:=</span> <span class="n">FV</span> <span class="n">P</span> <span class="err">∪</span> <span class="n">FV</span> <span class="n">Q</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">x</span> <span class="n">P</span><span class="o">)</span> <span class="o">:=</span> <span class="n">FV</span> <span class="n">P</span> <span class="err">\</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span>

<span class="kn">inductive</span> <span class="n">sub_is_def</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">var_same</span> <span class="o">(</span><span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span>
<span class="bp">|</span> <span class="n">var_diff</span> <span class="o">(</span><span class="n">y</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">{</span><span class="n">P</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span><span class="o">}</span> <span class="o">:</span> <span class="n">sub_is_def</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">P</span><span class="bp">.</span><span class="n">app</span> <span class="n">Q</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span>
<span class="bp">|</span> <span class="n">abs_same</span> <span class="o">(</span><span class="n">P</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">x</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span>
<span class="bp">|</span> <span class="n">abs_diff_nel</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">P</span> <span class="n">N</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">FV</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span>
<span class="bp">|</span> <span class="n">abs_diff</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">P</span> <span class="n">N</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">y</span> <span class="err">∉</span> <span class="n">FV</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span>

<span class="n">def</span> <span class="n">sub</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="k">then</span> <span class="n">N</span> <span class="k">else</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="o">(</span><span class="n">sub</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">sub</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="k">then</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="k">else</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="o">(</span><span class="n">sub</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span><span class="o">))</span>
</pre></div>


<p>may be closest to what they have.</p>

<a name="160357292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160357292" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160357292">Patrick Thomas (Mar 09 2019 at 08:15)</a>:</h4>
<p>Although, yes, I guess keeping sub_is_def and adding the four place relation is about the same.</p>

<a name="160377957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160377957" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160377957">Patrick Thomas (Mar 09 2019 at 18:21)</a>:</h4>
<p>What does the syntax <code>(P.app Q)</code>mean? Why that and not <code>(pre_term.app P Q)</code>?</p>

<a name="160378143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160378143" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160378143">Bryan Gin-ge Chen (Mar 09 2019 at 18:26)</a>:</h4>
<p>I think this is an example of "dot notation". There's a thread on it here: <a href="#narrow/stream/113488-general/topic/dot.20notation.20confusion" title="#narrow/stream/113488-general/topic/dot.20notation.20confusion">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/dot.20notation.20confusion</a></p>

<a name="160379095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160379095" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160379095">Patrick Thomas (Mar 09 2019 at 18:53)</a>:</h4>
<p>Thank you.</p>

<a name="162901853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/162901853" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#162901853">Patrick Thomas (Apr 09 2019 at 11:39)</a>:</h4>
<p>I was wondering if someone would mind showing me how to set up the form of proof for the last lemma here (lemma_1_2_5_i). I'm pretty sure I want to do induction on <code>M</code>, but I'm having difficulty figuring out the syntax.</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span>
<span class="kn">open</span> <span class="n">set</span>

<span class="n">def</span> <span class="n">var</span> <span class="o">:=</span> <span class="bp">ℕ</span>
<span class="bp">@</span><span class="o">[</span><span class="n">derive</span> <span class="n">decidable_eq</span><span class="o">]</span>

<span class="kn">inductive</span> <span class="n">pre_term</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">:</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span>
<span class="bp">|</span> <span class="n">abs</span> <span class="o">:</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span>

<span class="n">def</span> <span class="n">FV</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">var</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:=</span> <span class="n">FV</span> <span class="n">P</span> <span class="err">∪</span> <span class="n">FV</span> <span class="n">Q</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">x</span> <span class="n">P</span><span class="o">)</span> <span class="o">:=</span> <span class="n">FV</span> <span class="n">P</span> <span class="err">\</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span>


<span class="kn">lemma</span> <span class="n">lemma_1</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">s</span> <span class="err">\</span> <span class="n">t</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">s</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">s</span> <span class="err">\</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">s</span><span class="o">,</span> <span class="k">from</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_of_mem_diff</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">s</span> <span class="err">\</span> <span class="n">t</span><span class="o">,</span> <span class="k">from</span> <span class="n">mt</span> <span class="n">s1</span><span class="o">,</span>
<span class="k">show</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">s</span> <span class="err">\</span> <span class="n">t</span><span class="o">,</span> <span class="k">from</span> <span class="n">s2</span> <span class="n">a1</span>


<span class="kn">lemma</span> <span class="n">lemma_2</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">s</span> <span class="err">\</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">s</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">s</span> <span class="err">\</span> <span class="n">t</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">a2</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">t</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">s</span> <span class="err">\</span> <span class="n">t</span> <span class="bp">↔</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">s</span> <span class="bp">∧</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">t</span><span class="o">,</span> <span class="k">from</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_diff</span> <span class="n">x</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">s</span> <span class="bp">∧</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">s</span> <span class="err">\</span> <span class="n">t</span><span class="o">,</span> <span class="k">from</span> <span class="n">s1</span><span class="bp">.</span><span class="n">elim_left</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s3</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">s</span> <span class="err">\</span> <span class="n">t</span> <span class="bp">→</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="n">s</span> <span class="bp">∧</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">t</span><span class="o">),</span> <span class="k">from</span> <span class="n">mt</span> <span class="n">s2</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s4</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="n">s</span> <span class="bp">∧</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">t</span><span class="o">),</span> <span class="k">from</span> <span class="n">s3</span> <span class="n">a1</span><span class="o">,</span>
<span class="k">show</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">s</span><span class="o">,</span> <span class="k">from</span> <span class="n">not_and&#39;</span><span class="bp">.</span><span class="n">elim_left</span> <span class="n">s4</span> <span class="n">a2</span>


<span class="kn">lemma</span> <span class="n">lemma_3</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span><span class="n">var</span> <span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">FV</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">FV</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">FV</span> <span class="n">P</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">FV</span> <span class="n">P</span> <span class="err">\</span> <span class="o">{</span><span class="n">y</span><span class="o">},</span> <span class="k">from</span> <span class="n">lemma_1</span> <span class="n">a1</span><span class="o">,</span>
<span class="k">show</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">FV</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">),</span> <span class="k">from</span> <span class="n">s1</span>


<span class="kn">lemma</span> <span class="n">lemma_4</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">FV</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">FV</span> <span class="n">P</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">FV</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">),</span>
<span class="k">assume</span> <span class="n">a2</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">FV</span> <span class="n">P</span> <span class="err">\</span> <span class="o">{</span><span class="n">y</span><span class="o">},</span> <span class="k">from</span> <span class="n">a1</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∉</span> <span class="o">{</span><span class="n">y</span><span class="o">},</span> <span class="k">from</span> <span class="n">mt</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_singleton_iff</span><span class="bp">.</span><span class="n">elim_left</span> <span class="n">a2</span><span class="o">,</span>
<span class="k">show</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">FV</span> <span class="n">P</span><span class="o">,</span> <span class="k">from</span> <span class="n">lemma_2</span> <span class="n">s1</span> <span class="n">s2</span>


<span class="c1">-- M [ x := N ]</span>
<span class="kn">inductive</span> <span class="n">sub_is_def</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">var_same</span> <span class="o">(</span><span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span>
<span class="bp">|</span> <span class="n">var_diff</span> <span class="o">(</span><span class="n">y</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">{</span><span class="n">P</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span><span class="o">}</span> <span class="o">:</span> <span class="n">sub_is_def</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span>
<span class="bp">|</span> <span class="n">abs_same</span> <span class="o">(</span><span class="n">P</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">x</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span>
<span class="bp">|</span> <span class="n">abs_diff_nel</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">P</span> <span class="n">N</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">FV</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span>
<span class="bp">|</span> <span class="n">abs_diff</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">P</span> <span class="n">N</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">y</span> <span class="err">∉</span> <span class="n">FV</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span>

<span class="n">def</span> <span class="n">sub</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="k">then</span> <span class="n">N</span> <span class="k">else</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="o">(</span><span class="n">sub</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">sub</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="k">then</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="k">else</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="o">(</span><span class="n">sub</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span><span class="o">))</span>

<span class="kn">inductive</span> <span class="n">is_subst</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">var_same</span> <span class="o">(</span><span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">is_subst</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="n">N</span>
<span class="bp">|</span> <span class="n">var_diff</span> <span class="o">(</span><span class="n">y</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">is_subst</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">{</span><span class="n">P</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span> <span class="n">P&#39;</span> <span class="n">Q&#39;</span><span class="o">}</span> <span class="o">:</span> <span class="n">is_subst</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span> <span class="n">P&#39;</span> <span class="bp">→</span> <span class="n">is_subst</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span> <span class="n">Q&#39;</span> <span class="bp">→</span> <span class="n">is_subst</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P&#39;</span> <span class="n">Q&#39;</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">abs_same</span> <span class="o">(</span><span class="n">P</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">is_subst</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">x</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">x</span> <span class="n">P</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">abs_diff_nel</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">P</span> <span class="n">N</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">FV</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="bp">→</span> <span class="n">is_subst</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">abs_diff</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">P</span> <span class="n">N</span> <span class="n">P&#39;</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">y</span> <span class="err">∉</span> <span class="n">FV</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">is_subst</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span> <span class="n">P&#39;</span> <span class="bp">→</span> <span class="n">is_subst</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P&#39;</span><span class="o">)</span>


<span class="kn">lemma</span> <span class="n">lemma_1_2_5_i</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">FV</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="n">M</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">FV</span> <span class="n">M</span><span class="o">,</span>
<span class="k">show</span> <span class="n">sub_is_def</span> <span class="n">M</span> <span class="n">x</span> <span class="n">N</span><span class="o">,</span> <span class="k">from</span> <span class="n">sorry</span>
</pre></div>

<a name="162902578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/162902578" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#162902578">Chris Hughes (Apr 09 2019 at 11:51)</a>:</h4>
<p>This is one way. Your induction hypothesis will be called <code>lemma_1_2_5_i</code></p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">lemma_1_2_5_i</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">),</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">FV</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="n">M</span> <span class="n">x</span> <span class="n">N</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">N</span> <span class="n">h</span><span class="o">,</span> <span class="n">sorry</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">N</span> <span class="n">h</span><span class="o">,</span> <span class="n">sorry</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">N</span> <span class="n">h</span><span class="o">,</span> <span class="n">sorry</span>
</pre></div>

<a name="162902794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/162902794" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#162902794">Mario Carneiro (Apr 09 2019 at 11:54)</a>:</h4>
<p>Are you familiar with tactic proofs? It's a bit easier to handle these big inductive predicates using <code>induction</code></p>

<a name="162902814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/162902814" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#162902814">Mario Carneiro (Apr 09 2019 at 11:54)</a>:</h4>
<p>something like this:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">lemma_1_2_5_i</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">(</span><span class="n">a1</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">FV</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">sub_is_def</span> <span class="n">M</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">induction</span> <span class="n">M</span><span class="o">,</span>
  <span class="n">case</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="o">{</span>
    <span class="n">by_cases</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">M</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">subst</span> <span class="n">h</span><span class="o">,</span> <span class="n">constructor</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">constructor</span><span class="o">,</span> <span class="n">assumption</span> <span class="o">}</span> <span class="o">},</span>
  <span class="n">case</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="o">:</span> <span class="n">M₁</span> <span class="n">M₂</span> <span class="n">IH₁</span> <span class="n">IH₂</span> <span class="o">{</span>
    <span class="n">constructor</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">apply</span> <span class="n">IH₁</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">FV</span><span class="o">]</span> <span class="n">at</span> <span class="n">a1</span><span class="o">,</span> <span class="n">tauto</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">apply</span> <span class="n">IH₂</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">FV</span><span class="o">]</span> <span class="n">at</span> <span class="n">a1</span><span class="o">,</span> <span class="n">tauto</span> <span class="o">}</span> <span class="o">},</span>
  <span class="n">case</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="o">:</span> <span class="n">y</span> <span class="n">M</span> <span class="n">IH</span> <span class="o">{</span>
    <span class="n">by_cases</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">subst</span> <span class="n">h</span><span class="o">,</span> <span class="n">constructor</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">sub_is_def</span><span class="bp">.</span><span class="n">abs_diff_nel</span> <span class="n">h</span> <span class="n">a1</span> <span class="o">}</span> <span class="o">}</span>
<span class="kn">end</span>
</pre></div>

<a name="162903356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/162903356" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#162903356">Patrick Thomas (Apr 09 2019 at 12:02)</a>:</h4>
<p>Mario: No, not that familiar. I'll have to look these commands up. Thank you.<br>
Chris: What does the <code>h</code> in each case correspond to?</p>

<a name="162903466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/162903466" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#162903466">Johan Commelin (Apr 09 2019 at 12:04)</a>:</h4>
<p><span class="user-mention" data-user-id="139442">@Patrick Thomas</span> A proof that <code>x ∉ FV M</code></p>

<a name="162903486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/162903486" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#162903486">Patrick Thomas (Apr 09 2019 at 12:05)</a>:</h4>
<p>Ahh. Thank you.</p>

<a name="162906492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/162906492" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#162906492">Patrick Thomas (Apr 09 2019 at 12:46)</a>:</h4>
<p>How would I match each case of the inductively defined proposition without tactics? For example:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">FV</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">M</span><span class="o">))</span> <span class="o">:</span> <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">M</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>

<a name="162907575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/162907575" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#162907575">Patrick Thomas (Apr 09 2019 at 13:01)</a>:</h4>
<p>Actually, how are each of the cases in sub_is_def matched in the proof that Mario gave?</p>

<a name="162908849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/162908849" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#162908849">Mario Carneiro (Apr 09 2019 at 13:17)</a>:</h4>
<p>The proof is by induction on <code>M</code>, not <code>sub_is_def</code></p>

<a name="162908877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/162908877" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#162908877">Mario Carneiro (Apr 09 2019 at 13:17)</a>:</h4>
<p>so there is one case for each constructor of <code>pre_term</code></p>

<a name="162908965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/162908965" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#162908965">Mario Carneiro (Apr 09 2019 at 13:18)</a>:</h4>
<p>But it is proving <code>sub_is_def</code>, and in most of the cases I use <code>constructor</code> to pick the appropriate constructor</p>

<a name="162908979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/162908979" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#162908979">Patrick Thomas (Apr 09 2019 at 13:18)</a>:</h4>
<p>What does constructor do?</p>

<a name="162909017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/162909017" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#162909017">Mario Carneiro (Apr 09 2019 at 13:19)</a>:</h4>
<p>it's basically <code>apply sub_is_def.var_same &lt;|&gt; apply sub_is_def.var_diff &lt;|&gt; ...</code></p>

<a name="162910341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/162910341" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#162910341">Patrick Thomas (Apr 09 2019 at 13:34)</a>:</h4>
<p>Interesting. Thank you.</p>

<a name="163067456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/163067456" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#163067456">Patrick Thomas (Apr 11 2019 at 03:47)</a>:</h4>
<p>Does the use of the <code>by_cases</code> tactic mean that the proof requires classical reasoning?</p>

<a name="163189461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/163189461" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#163189461">Fabian Glöckle (Apr 12 2019 at 13:32)</a>:</h4>
<p>The <code>by_cases</code>tactic  needs that the proposition is <code>decidable</code>, and tries to create such an instance by typeclass inference. Decidability can be proven within a theory (like the decidable equality of <code>nat</code>in <code>data/nat/basic.lean</code>: <code>instance : decidable_eq ℕ</code>) or be assumed as a classical axiom. This is the line</p>
<div class="codehilite"><pre><span></span><span class="n">local</span> <span class="n">attribute</span> <span class="o">[</span><span class="kn">instance</span><span class="o">]</span> <span class="n">classical</span><span class="bp">.</span><span class="n">prop_decidable</span>
</pre></div>


<p>you find in certain files.</p>

<a name="163827840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/163827840" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#163827840">Patrick Thomas (Apr 21 2019 at 01:19)</a>:</h4>
<p>How is a function with <code>if...then...else</code> used? For example, how would one prove the example in the following:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">var</span> <span class="o">:=</span> <span class="bp">ℕ</span>

<span class="kn">inductive</span> <span class="n">pre_term</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">:</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span>
<span class="bp">|</span> <span class="n">abs</span> <span class="o">:</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span>

<span class="n">def</span> <span class="n">sub</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="k">then</span> <span class="n">N</span> <span class="k">else</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="o">(</span><span class="n">sub</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">sub</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="k">then</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="k">else</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="o">(</span><span class="n">sub</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span><span class="o">))</span>

<span class="kn">variables</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">var</span>
<span class="kn">variable</span> <span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span>

<span class="kn">example</span> <span class="o">:=</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">sub</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">=</span> <span class="n">N</span>
</pre></div>

<a name="163827897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/163827897" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#163827897">Simon Hudon (Apr 21 2019 at 01:20)</a>:</h4>
<p><code>split_ifs</code> is your friend when you see <code>ite</code> or <code>dite</code> (the functions underneath the <code>if _ then _ else _</code>) in your goal</p>

<a name="163828103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/163828103" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#163828103">Patrick Thomas (Apr 21 2019 at 01:26)</a>:</h4>
<p>I don't think I see <code>ite</code> or <code>dite</code>? Maybe the goal hasn't been broken down enough yet?</p>

<a name="163828187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/163828187" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#163828187">Simon Hudon (Apr 21 2019 at 01:29)</a>:</h4>
<p>First unfold <code>sub</code>, then you'll see it</p>

<a name="163828451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/163828451" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#163828451">Patrick Thomas (Apr 21 2019 at 01:36)</a>:</h4>
<p>I'm sorry, I'm new to tactics. Would you mind giving an example? I'd be curious how to use <code>sub</code> without tactics as well.</p>

<a name="163828508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/163828508" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#163828508">Mario Carneiro (Apr 21 2019 at 01:38)</a>:</h4>
<p>without tactics:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">sub</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">=</span> <span class="n">N</span> <span class="o">:=</span> <span class="n">if_pos</span> <span class="n">h</span>
</pre></div>

<a name="163828523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/163828523" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#163828523">Mario Carneiro (Apr 21 2019 at 01:39)</a>:</h4>
<p>with tactics:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">sub</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">=</span> <span class="n">N</span> <span class="o">:=</span>
<span class="k">by</span> <span class="o">{</span><span class="n">unfold</span> <span class="n">sub</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]}</span>
</pre></div>

<a name="163828654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/163828654" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#163828654">Patrick Thomas (Apr 21 2019 at 01:43)</a>:</h4>
<p>Thank you!</p>

<a name="164353852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/164353852" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#164353852">Patrick Thomas (Apr 27 2019 at 21:13)</a>:</h4>
<p>How does the <code>if_pos</code> example know which constructor of <code>sub</code> to use? Can it be explicitly told?</p>

<a name="164353928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/164353928" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#164353928">Patrick Thomas (Apr 27 2019 at 21:15)</a>:</h4>
<p>When I clicked on the Induction title it showed two threads, one named INduction at the top and the other named  Induction after.</p>

<a name="164354563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/164354563" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#164354563">Kevin Buzzard (Apr 27 2019 at 21:33)</a>:</h4>
<p>What's the <code>if_pos</code> example?</p>

<a name="164355710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/164355710" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#164355710">Kevin Buzzard (Apr 27 2019 at 22:05)</a>:</h4>
<p>I don't understand your question.</p>

<a name="164355755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/164355755" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#164355755">Kevin Buzzard (Apr 27 2019 at 22:06)</a>:</h4>
<p>You know you can hover on terms in VS Code to see their type? Does this sort of technique answer your question?</p>

<a name="164355784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/164355784" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#164355784">Kevin Buzzard (Apr 27 2019 at 22:07)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">:</span> <span class="n">sub</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">=</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="k">then</span> <span class="n">N</span> <span class="k">else</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>


<p>Does that answer your question? The left hand side equals the if statement by definition.</p>

<a name="164398291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/164398291" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#164398291">Patrick Thomas (Apr 28 2019 at 17:40)</a>:</h4>
<p>I guess I mean: What is being substituted for what in the definition of <code>if_pos</code> and how does it decide on those particular substitutions? Is there a way in Visual Studio to see what substitutions are being made?</p>

<a name="164402688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/164402688" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#164402688">Alistair Tucker (Apr 28 2019 at 19:24)</a>:</h4>
<p>You mean the implicit arguments to if_pos? The stuff in curly brackets?</p>

<a name="164402763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/164402763" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#164402763">Alistair Tucker (Apr 28 2019 at 19:26)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">sub</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">=</span> <span class="n">N</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">if_pos</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span> <span class="bp">_</span> <span class="n">h</span> <span class="n">pre_term</span> <span class="n">N</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span>
</pre></div>

<a name="164402862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/164402862" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#164402862">Mario Carneiro (Apr 28 2019 at 19:29)</a>:</h4>
<blockquote>
<p>How does the <code>if_pos</code> example know which constructor of <code>sub</code> to use? Can it be explicitly told?</p>
</blockquote>
<p><code>sub</code> doesn't have constructors - it's a recursive definition. So <code>sub (pre_term.var y) x N</code> and <code>if x = y then N else (pre_term.var y)</code> are the same thing from lean's point of view, there is no constructor application to turn one into the other, just definitional unfolding</p>

<a name="164403801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/164403801" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#164403801">Kevin Buzzard (Apr 28 2019 at 19:51)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">sub</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">=</span> <span class="n">N</span> <span class="o">:=</span> <span class="n">if_pos</span> <span class="n">h</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">if_pos</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">if_pos : ?M_1 → ∀ {α : Sort u_1} {t e : α}, ite ?M_1 t e = t</span>
<span class="cm">-/</span>
<span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="n">if_pos</span> <span class="c1">-- sometimes output is clearer</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">if_pos : ∀ {c : Prop} [h : decidable c],</span>
<span class="cm">  c → ∀ {α : Sort u_1} {t e : α}, ite c t e = t</span>
<span class="cm">-/</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">sub</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">=</span> <span class="n">N</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">if_pos</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">h</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span>
</pre></div>

<a name="164403889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/164403889" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#164403889">Kevin Buzzard (Apr 28 2019 at 19:52)</a>:</h4>
<p>Of the five inputs to <code>if_pos</code> that you didn't give, four were worked out by just thinking about the types of things, and the value of <code>h : decidable c</code> was supplied by the type class inference system.</p>

<a name="164403916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/164403916" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#164403916">Kevin Buzzard (Apr 28 2019 at 19:53)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">sub</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">=</span> <span class="n">N</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">if_pos</span> <span class="bp">_</span> <span class="o">(</span><span class="k">by</span> <span class="n">apply_instance</span><span class="o">)</span> <span class="n">h</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span>
</pre></div>

<a name="164819584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/164819584" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#164819584">Patrick Thomas (May 03 2019 at 18:45)</a>:</h4>
<p>I think I understand now. Thank you!</p>

<a name="165016513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/165016513" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#165016513">Patrick Thomas (May 06 2019 at 20:33)</a>:</h4>
<p>I was wondering if someone might be able to show me how to use the equalities <code>sub P x N = P</code> and <code>sub Q x N = Q</code> to show  that <code>pre_term.app (sub P x N) (sub Q x N) = pre_term.app P Q</code> given</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">pre_term</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">:</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span>
<span class="bp">|</span> <span class="n">abs</span> <span class="o">:</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span>

<span class="n">def</span> <span class="n">sub</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span>
<span class="c1">-- if x = y then y [ x := N ] = N else y [ x := N ] = y</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span> <span class="k">then</span> <span class="n">N</span> <span class="k">else</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span>

<span class="c1">-- (P Q) [ x := N ] = (P [ x := N ] Q [ x := N ])</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="o">(</span><span class="n">sub</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">sub</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span>

<span class="c1">-- if x = y then ( λ y . P ) [ x := N ] = ( λ y . P ) else ( λ y . P ) [ x := N ] = ( λ y . P [ x := N ] )</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="k">then</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="k">else</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="o">(</span><span class="n">sub</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span><span class="o">))</span>
</pre></div>


<p>Thank you.</p>

<a name="165016616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/165016616" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#165016616">Kevin Buzzard (May 06 2019 at 20:34)</a>:</h4>
<p>Can you post fully working code? It makes everyone's life easier.</p>

<a name="165016626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/165016626" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#165016626">Patrick Thomas (May 06 2019 at 20:34)</a>:</h4>
<p>Sure, give me a second.</p>

<a name="165016676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/165016676" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#165016676">Kevin Buzzard (May 06 2019 at 20:35)</a>:</h4>
<p>Can you formalise precisely what you want proved as well, rather than just describing it?</p>

<a name="165017689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/165017689" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#165017689">Patrick Thomas (May 06 2019 at 20:49)</a>:</h4>
<p>I think this is a minimum working example:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">var</span> <span class="o">:=</span> <span class="bp">ℕ</span>

<span class="kn">inductive</span> <span class="n">pre_term</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">:</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span>
<span class="bp">|</span> <span class="n">abs</span> <span class="o">:</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span>

<span class="n">def</span> <span class="n">sub</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span>
<span class="c1">-- if x = y then y [ x := N ] = N else y [ x := N ] = y</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span> <span class="k">then</span> <span class="n">N</span> <span class="k">else</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span>

<span class="c1">-- (P Q) [ x := N ] = (P [ x := N ] Q [ x := N ])</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="o">(</span><span class="n">sub</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">sub</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span>

<span class="c1">-- if x = y then ( λ y . P ) [ x := N ] = ( λ y . P ) else ( λ y . P ) [ x := N ] = ( λ y . P [ x := N ] )</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="k">then</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="k">else</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="o">(</span><span class="n">sub</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span><span class="o">))</span>


<span class="kn">example</span> <span class="o">(</span><span class="n">P</span> <span class="n">Q</span> <span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">sub</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">=</span> <span class="n">P</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">sub</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">=</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="o">(</span><span class="n">sub</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">sub</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="bp">=</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>

<a name="165018444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/165018444" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#165018444">Kevin Buzzard (May 06 2019 at 20:59)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">P</span> <span class="n">Q</span> <span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">sub</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">=</span> <span class="n">P</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">sub</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">=</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="o">(</span><span class="n">sub</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">sub</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="bp">=</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="n">h1</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">h2</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>

<a name="165018592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/165018592" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#165018592">Patrick Thomas (May 06 2019 at 21:01)</a>:</h4>
<p>Thank you. Do you mind showing how it might be done without tactics?</p>

<a name="165018612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/165018612" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#165018612">Kevin Buzzard (May 06 2019 at 21:01)</a>:</h4>
<p><code>#print</code> the proof term? :-/</p>

<a name="165018621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/165018621" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#165018621">Kevin Buzzard (May 06 2019 at 21:01)</a>:</h4>
<p>or you could try the dreaded triangle</p>

<a name="165018629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/165018629" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#165018629">Patrick Thomas (May 06 2019 at 21:01)</a>:</h4>
<p>Triangle?</p>

<a name="165018640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/165018640" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#165018640">Kevin Buzzard (May 06 2019 at 21:02)</a>:</h4>
<p><code>\t</code></p>

<a name="165018686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/165018686" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#165018686">Kevin Buzzard (May 06 2019 at 21:02)</a>:</h4>
<p><code>eq.subst</code></p>

<a name="165018702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/165018702" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#165018702">Patrick Massot (May 06 2019 at 21:02)</a>:</h4>
<p>substituting in what?</p>

<a name="165018706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/165018706" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#165018706">Kevin Buzzard (May 06 2019 at 21:02)</a>:</h4>
<p>it's a version of <code>rw</code> which works in term mode but never works for me.</p>

<a name="165018720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/165018720" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#165018720">Patrick Massot (May 06 2019 at 21:02)</a>:</h4>
<p>in <code>(rlf : pre_term.app P Q = pre_term.app P Q)</code> maybe</p>

<a name="165018722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/165018722" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#165018722">Kevin Buzzard (May 06 2019 at 21:02)</a>:</h4>
<blockquote>
<p>substituting in what?</p>
</blockquote>
<p>I dunno, I can never get it to work</p>

<a name="165018780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/165018780" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#165018780">Patrick Massot (May 06 2019 at 21:03)</a>:</h4>
<p>Anyway, let's not encourage Patrick's masochism here</p>

<a name="165018836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/165018836" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#165018836">Kevin Buzzard (May 06 2019 at 21:04)</a>:</h4>
<p>it won't work, it will change too many P's</p>

<a name="165018843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/165018843" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#165018843">Patrick Massot (May 06 2019 at 21:04)</a>:</h4>
<p><span class="user-mention" data-user-id="139442">@Patrick Thomas</span> you really need to learn tactic mode</p>

<a name="165018905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/165018905" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#165018905">Patrick Thomas (May 06 2019 at 21:05)</a>:</h4>
<p>I think it is more that I like it to be explicit. I guess in this case it is obvious enough.</p>

<a name="165018923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/165018923" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#165018923">Kevin Buzzard (May 06 2019 at 21:05)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">ABC</span> <span class="o">(</span><span class="n">P</span> <span class="n">Q</span> <span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">sub</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">=</span> <span class="n">P</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">sub</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">=</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="o">(</span><span class="n">sub</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">sub</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="bp">=</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="n">h1</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">h2</span><span class="o">,</span>
<span class="kn">end</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">ABC</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">def ABC : ∀ (P Q N : pre_term) (x : var),</span>
<span class="cm">  sub P x N = P → sub Q x N = Q → pre_term.app (sub P x N) (sub Q x N) = pre_term.app P Q :=</span>
<span class="cm">λ (P Q N : pre_term) (x : var) (h1 : sub P x N = P) (h2 : sub Q x N = Q),</span>
<span class="cm">  eq.mpr (id (eq.rec (eq.refl (pre_term.app (sub P x N) (sub Q x N) = pre_term.app P Q)) h1))</span>
<span class="cm">    (eq.mpr (id (eq.rec (eq.refl (pre_term.app P (sub Q x N) = pre_term.app P Q)) h2)) (eq.refl (pre_term.app P Q)))</span>
<span class="cm">    -/</span>
</pre></div>

<a name="165018930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/165018930" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#165018930">Patrick Massot (May 06 2019 at 21:05)</a>:</h4>
<p>How nicely explicit!</p>

<a name="165018989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/165018989" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#165018989">Patrick Thomas (May 06 2019 at 21:06)</a>:</h4>
<p>LOL</p>

<a name="165019001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/165019001" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#165019001">Patrick Massot (May 06 2019 at 21:06)</a>:</h4>
<p>Maybe you can remove a couple of <code>id</code> and still be explicit enough</p>

<a name="165019065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/165019065" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#165019065">Kevin Buzzard (May 06 2019 at 21:07)</a>:</h4>
<p>Take a look at mathlib. They love obfuscated one-line term mode proofs -- when they can get them to work. But there are plenty of times in mathlib when they go into tactic mode precisely for reasons such as this. In mathlib the proof would be <code>by rw [h1, h2]</code>. <code>rw</code> is a powerful tactic. Why try emulating it in term mode?</p>

<a name="165019090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/165019090" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#165019090">Patrick Thomas (May 06 2019 at 21:07)</a>:</h4>
<p>Yeah, I think in this case I'll use the tactic.</p>

<a name="165019105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/165019105" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#165019105">Patrick Massot (May 06 2019 at 21:08)</a>:</h4>
<p>Yes <code>rw</code> is the tactic mode reason number one in mathlib</p>

<a name="165019173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/165019173" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#165019173">Kevin Buzzard (May 06 2019 at 21:08)</a>:</h4>
<p>Many of my tactic mode proofs are <code>rw this, change that, rw this, change that, rwa this</code></p>

<a name="165019187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/165019187" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#165019187">Kevin Buzzard (May 06 2019 at 21:08)</a>:</h4>
<p>As Patrick says, it's the number one reason to go into tactic mode.</p>

<a name="165019213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/165019213" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#165019213">Kevin Buzzard (May 06 2019 at 21:09)</a>:</h4>
<p>At least for me. If I could use <code>simp</code> better then this might not be the case -- I am slowly learning how to use it.</p>

<a name="165019579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/165019579" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#165019579">Kevin Buzzard (May 06 2019 at 21:13)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">ABC</span> <span class="o">(</span><span class="n">P</span> <span class="n">Q</span> <span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">sub</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">=</span> <span class="n">P</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">sub</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">=</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="o">(</span><span class="n">sub</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">sub</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="bp">=</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span> <span class="o">:=</span>
<span class="k">have</span> <span class="n">H</span> <span class="o">:</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="o">(</span><span class="n">sub</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="n">Q</span> <span class="bp">=</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span><span class="o">,</span> <span class="k">from</span> <span class="n">h1</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">▸</span> <span class="n">rfl</span><span class="o">,</span>
<span class="n">h2</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">▸</span> <span class="n">H</span>
</pre></div>


<p>Triangle level up</p>

<a name="165019650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/165019650" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#165019650">Kevin Buzzard (May 06 2019 at 21:14)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">ABC</span> <span class="o">(</span><span class="n">P</span> <span class="n">Q</span> <span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">sub</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">=</span> <span class="n">P</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">sub</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">=</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="o">(</span><span class="n">sub</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">sub</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="bp">=</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span> <span class="o">:=</span>
<span class="n">h2</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">▸</span> <span class="o">(</span><span class="n">h1</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">▸</span> <span class="n">rfl</span><span class="o">)</span>
</pre></div>


<p>Triangle master!</p>

<a name="165019665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/165019665" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#165019665">Patrick Massot (May 06 2019 at 21:14)</a>:</h4>
<p>Hey, that was my proposal!</p>

<a name="165019672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/165019672" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#165019672">Patrick Massot (May 06 2019 at 21:14)</a>:</h4>
<p>Patrick, do you really think this is more explicit than <code>rw</code>?</p>

<a name="165019678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/165019678" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#165019678">Kevin Buzzard (May 06 2019 at 21:14)</a>:</h4>
<p>The symms are for some reason crucial</p>

<a name="165019685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/165019685" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#165019685">Patrick Massot (May 06 2019 at 21:14)</a>:</h4>
<p>Ahh</p>

<a name="165019690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/165019690" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#165019690">Kevin Buzzard (May 06 2019 at 21:14)</a>:</h4>
<p>and the rfl figured out its own type, to my surprise</p>

<a name="165019707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/165019707" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#165019707">Patrick Massot (May 06 2019 at 21:15)</a>:</h4>
<p>I didn't try</p>

<a name="165019760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/165019760" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#165019760">Kevin Buzzard (May 06 2019 at 21:15)</a>:</h4>
<p>but honestly, triangle does not scale :-/</p>

<a name="165019896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/165019896" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#165019896">Kevin Buzzard (May 06 2019 at 21:17)</a>:</h4>
<p>Seems that the triangle by default picks up the first match <em>shrug</em></p>

<a name="165020194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/165020194" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#165020194">Patrick Thomas (May 06 2019 at 21:21)</a>:</h4>
<p>Patrick: I think the rewrite works well here. I haven't used tactics enough for it to have occurred to me.</p>

<a name="165022344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/165022344" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#165022344">Andrew Ashworth (May 06 2019 at 21:53)</a>:</h4>
<p>If you want to get rid of the <code>symms</code>, you could try <code>eq.substr</code></p>

<a name="165022346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/165022346" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#165022346">Andrew Ashworth (May 06 2019 at 21:53)</a>:</h4>
<p>unfortunately it doesn't have the nice triangle notation like <code>eq.subst</code> does</p>

<a name="165431448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/165431448" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#165431448">Patrick Thomas (May 11 2019 at 21:57)</a>:</h4>
<p>Given:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">var</span> <span class="o">:=</span> <span class="bp">ℕ</span>

<span class="kn">inductive</span> <span class="n">pre_term</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">:</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span>
<span class="bp">|</span> <span class="n">abs</span> <span class="o">:</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span>

<span class="n">def</span> <span class="n">FV</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">var</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">FV</span> <span class="n">P</span><span class="o">)</span> <span class="err">∪</span> <span class="o">(</span><span class="n">FV</span> <span class="n">Q</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">x</span> <span class="n">P</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">FV</span> <span class="n">P</span><span class="o">)</span> <span class="err">\</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span>


<span class="c1">-- sub_is_def M x N means M [ x := N ] is defined</span>
<span class="kn">inductive</span> <span class="n">sub_is_def</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="kt">Prop</span>

<span class="c1">-- y [ x := N ] is defined</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span>

<span class="c1">-- P [ x := N ] is defined → Q [ x := N ] is defined → (P Q) [ x := N ] is defined</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">(</span><span class="n">Q</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">sub_is_def</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span>

<span class="c1">-- x = y → ( λ y . P ) [ x := N ] is defined</span>
<span class="bp">|</span> <span class="n">abs_same</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span>

<span class="c1">-- x ≠ y → x ∉ FV ( λ y . P ) → ( λ y . P ) [ x := N ] is defined</span>
<span class="bp">|</span> <span class="n">abs_diff_nel</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">FV</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span>

<span class="c1">-- x ≠ y → y ∉ FV ( N ) → P [ x := N ] is defined → ( λ y . P ) [ x := N ] is defined</span>
<span class="bp">|</span> <span class="n">abs_diff</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">y</span> <span class="err">∉</span> <span class="n">FV</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span>


<span class="c1">-- M [ x := N ]</span>
<span class="n">def</span> <span class="n">sub</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span>
<span class="c1">-- if x = y then y [ x := N ] = N else y [ x := N ] = y</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span> <span class="k">then</span> <span class="n">N</span> <span class="k">else</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span>

<span class="c1">-- (P Q) [ x := N ] = (P [ x := N ] Q [ x := N ])</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="o">(</span><span class="n">sub</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">sub</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span>

<span class="c1">-- if x = y then ( λ y . P ) [ x := N ] = ( λ y . P ) else ( λ y . P ) [ x := N ] = ( λ y . P [ x := N ] )</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="k">then</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="k">else</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="o">(</span><span class="n">sub</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span><span class="o">))</span>
</pre></div>


<p>Is the only way to combine <code>sub_is_def</code> and <code>sub</code> to use:</p>
<div class="codehilite"><pre><span></span><span class="c1">-- is_sub M x N L means M [ x := N ] = L</span>
<span class="kn">inductive</span> <span class="n">is_sub</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="kt">Prop</span>

<span class="c1">-- x = y → y [ x := N ] = N</span>
<span class="bp">|</span> <span class="n">var_same</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">is_sub</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="n">N</span>

<span class="c1">-- x ≠ y → y [ x := N ] = y</span>
<span class="bp">|</span> <span class="n">var_diff</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">is_sub</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span>

<span class="c1">-- P [ x := N ] = P&#39; → Q [ x := N ] = Q&#39; → (P Q) [ x := N ] = (P&#39; Q&#39;)</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">(</span><span class="n">Q</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">(</span><span class="n">P&#39;</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">(</span><span class="n">Q&#39;</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">is_sub</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span> <span class="n">P&#39;</span> <span class="bp">→</span> <span class="n">is_sub</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span> <span class="n">Q&#39;</span> <span class="bp">→</span> <span class="n">is_sub</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P&#39;</span> <span class="n">Q&#39;</span><span class="o">)</span>

<span class="c1">-- x = y → ( λ y . P ) [ x := N ] = ( λ y . P )</span>
<span class="bp">|</span> <span class="n">abs_same</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">is_sub</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span>

<span class="c1">-- x ≠ y → x ∉ FV ( λ y . P ) → ( λ y . P ) [ x := N ] = ( λ y . P )</span>
<span class="bp">|</span> <span class="n">abs_diff_nel</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">FV</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="bp">→</span> <span class="n">is_sub</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span>

<span class="c1">-- x ≠ y → y ∉ FV ( N ) → P [ x := N ] = P&#39; → ( λ y . P ) [ x := N ] = ( λ y . P&#39; )</span>
<span class="bp">|</span> <span class="n">abs_diff</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">(</span><span class="n">P&#39;</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">y</span> <span class="err">∉</span> <span class="n">FV</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">is_sub</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span> <span class="n">P&#39;</span> <span class="bp">→</span> <span class="n">is_sub</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P&#39;</span><span class="o">)</span>
</pre></div>


<p>I can not make <code>sub</code> a function only on the domain for which <code>sub_is_def</code> holds?</p>

<a name="165451853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/165451853" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#165451853">Mario Carneiro (May 12 2019 at 07:01)</a>:</h4>
<p>You can make <code>sub (M : pre_term) (x : var) (N : pre_term) : sub_is_def M x N -&gt; pre_term</code>, but I strongly recommend against it</p>

<a name="165471311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/165471311" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#165471311">Patrick Thomas (May 12 2019 at 16:29)</a>:</h4>
<p>Why the recommendation against it?</p>

<a name="166663803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/166663803" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#166663803">Patrick Thomas (May 27 2019 at 20:59)</a>:</h4>
<p>Should I be able to prove the following?</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">sub_iff</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span><span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">L</span> <span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span> <span class="n">is_sub</span> <span class="n">M</span> <span class="n">x</span> <span class="n">N</span> <span class="n">L</span> <span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span> <span class="n">M</span> <span class="o">[</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">N</span> <span class="o">]</span> <span class="n">is_def</span> <span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span> <span class="n">M</span> <span class="o">[</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">N</span> <span class="o">]</span> <span class="bp">=</span> <span class="n">L</span> <span class="o">)</span>
</pre></div>


<p>Perhaps by induction on <code>M</code>?</p>

<a name="166663823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/166663823" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#166663823">Mario Carneiro (May 27 2019 at 20:59)</a>:</h4>
<p>what does <code>is_def</code> mean in the first conjunct?</p>

<a name="166663917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/166663917" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#166663917">Patrick Thomas (May 27 2019 at 21:01)</a>:</h4>
<p>Sorry, left out the notation:</p>
<div class="codehilite"><pre><span></span><span class="kn">notation</span> <span class="n">M</span> <span class="bp">`</span><span class="o">[</span><span class="bp">`</span> <span class="n">x</span> <span class="bp">`</span><span class="o">:=</span><span class="bp">`</span> <span class="n">N</span> <span class="bp">`</span><span class="o">]</span><span class="bp">`</span> <span class="bp">`</span><span class="n">is_def</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">sub_is_def</span> <span class="n">M</span> <span class="n">x</span> <span class="n">N</span>
<span class="kn">notation</span> <span class="n">M</span> <span class="bp">`</span><span class="o">[</span><span class="bp">`</span> <span class="n">x</span> <span class="bp">`</span><span class="o">:=</span><span class="bp">`</span> <span class="n">N</span> <span class="bp">`</span><span class="o">]</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">sub</span> <span class="n">M</span> <span class="n">x</span> <span class="n">N</span>
</pre></div>

<a name="166663920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/166663920" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#166663920">Mario Carneiro (May 27 2019 at 21:01)</a>:</h4>
<p>wow that's an ambiguous notation</p>

<a name="166663924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/166663924" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#166663924">Kevin Buzzard (May 27 2019 at 21:01)</a>:</h4>
<p>Why not just post your full working code?</p>

<a name="166663975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/166663975" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#166663975">Mario Carneiro (May 27 2019 at 21:02)</a>:</h4>
<p>it's mostly the same as the code in this thread I think</p>

<a name="166664020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/166664020" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#166664020">Patrick Thomas (May 27 2019 at 21:03)</a>:</h4>
<p>Yeah. Here it is</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span>
<span class="kn">open</span> <span class="n">set</span>


<span class="n">def</span> <span class="n">var</span> <span class="o">:=</span> <span class="bp">ℕ</span>

<span class="kn">inductive</span> <span class="n">pre_term</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">:</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span>
<span class="bp">|</span> <span class="n">abs</span> <span class="o">:</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span>


<span class="n">def</span> <span class="n">FV</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">var</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">FV</span> <span class="n">P</span><span class="o">)</span> <span class="err">∪</span> <span class="o">(</span><span class="n">FV</span> <span class="n">Q</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">x</span> <span class="n">P</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">FV</span> <span class="n">P</span><span class="o">)</span> <span class="err">\</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span>


<span class="c1">-- sub_is_def M x N means M [ x := N ] is defined</span>
<span class="kn">inductive</span> <span class="n">sub_is_def</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="kt">Prop</span>

<span class="c1">-- y [ x := N ] is defined</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span>

<span class="c1">-- P [ x := N ] is defined → Q [ x := N ] is defined → (P Q) [ x := N ] is defined</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">(</span><span class="n">Q</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">sub_is_def</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span>

<span class="c1">-- x = y → ( λ y . P ) [ x := N ] is defined</span>
<span class="bp">|</span> <span class="n">abs_same</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span>

<span class="c1">-- x ≠ y → x ∉ FV ( λ y . P ) → ( λ y . P ) [ x := N ] is defined</span>
<span class="bp">|</span> <span class="n">abs_diff_nel</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">FV</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span>

<span class="c1">-- x ≠ y → y ∉ FV ( N ) → P [ x := N ] is defined → ( λ y . P ) [ x := N ] is defined</span>
<span class="bp">|</span> <span class="n">abs_diff</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">y</span> <span class="err">∉</span> <span class="n">FV</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span>

<span class="kn">notation</span> <span class="n">M</span> <span class="bp">`</span><span class="o">[</span><span class="bp">`</span> <span class="n">x</span> <span class="bp">`</span><span class="o">:=</span><span class="bp">`</span> <span class="n">N</span> <span class="bp">`</span><span class="o">]</span><span class="bp">`</span> <span class="bp">`</span><span class="n">is_def</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">sub_is_def</span> <span class="n">M</span> <span class="n">x</span> <span class="n">N</span>


<span class="c1">-- M [ x := N ]</span>
<span class="n">def</span> <span class="n">sub</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span>
<span class="c1">-- if x = y then y [ x := N ] = N else y [ x := N ] = y</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span> <span class="k">then</span> <span class="n">N</span> <span class="k">else</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span>

<span class="c1">-- (P Q) [ x := N ] = (P [ x := N ] Q [ x := N ])</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="o">(</span><span class="n">sub</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">sub</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span>

<span class="c1">-- if x = y then ( λ y . P ) [ x := N ] = ( λ y . P ) else ( λ y . P ) [ x := N ] = ( λ y . P [ x := N ] )</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="k">then</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="k">else</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="o">(</span><span class="n">sub</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span><span class="o">))</span>

<span class="kn">notation</span> <span class="n">M</span> <span class="bp">`</span><span class="o">[</span><span class="bp">`</span> <span class="n">x</span> <span class="bp">`</span><span class="o">:=</span><span class="bp">`</span> <span class="n">N</span> <span class="bp">`</span><span class="o">]</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">sub</span> <span class="n">M</span> <span class="n">x</span> <span class="n">N</span>


<span class="c1">-- is_sub M x N L means M [ x := N ] = L</span>
<span class="kn">inductive</span> <span class="n">is_sub</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="kt">Prop</span>

<span class="c1">-- x = y → y [ x := N ] = N</span>
<span class="bp">|</span> <span class="n">var_same</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">is_sub</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="n">N</span>

<span class="c1">-- x ≠ y → y [ x := N ] = y</span>
<span class="bp">|</span> <span class="n">var_diff</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">is_sub</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span>

<span class="c1">-- P [ x := N ] = P&#39; → Q [ x := N ] = Q&#39; → (P Q) [ x := N ] = (P&#39; Q&#39;)</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">(</span><span class="n">Q</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">(</span><span class="n">P&#39;</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">(</span><span class="n">Q&#39;</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">is_sub</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span> <span class="n">P&#39;</span> <span class="bp">→</span> <span class="n">is_sub</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span> <span class="n">Q&#39;</span> <span class="bp">→</span> <span class="n">is_sub</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P&#39;</span> <span class="n">Q&#39;</span><span class="o">)</span>

<span class="c1">-- x = y → ( λ y . P ) [ x := N ] = ( λ y . P )</span>
<span class="bp">|</span> <span class="n">abs_same</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">is_sub</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span>

<span class="c1">-- x ≠ y → x ∉ FV ( λ y . P ) → ( λ y . P ) [ x := N ] = ( λ y . P )</span>
<span class="bp">|</span> <span class="n">abs_diff_nel</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">FV</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="bp">→</span> <span class="n">is_sub</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span>

<span class="c1">-- x ≠ y → y ∉ FV ( N ) → P [ x := N ] = P&#39; → ( λ y . P ) [ x := N ] = ( λ y . P&#39; )</span>
<span class="bp">|</span> <span class="n">abs_diff</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">(</span><span class="n">P&#39;</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">y</span> <span class="err">∉</span> <span class="n">FV</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">is_sub</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span> <span class="n">P&#39;</span> <span class="bp">→</span> <span class="n">is_sub</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P&#39;</span><span class="o">)</span>


<span class="kn">lemma</span> <span class="n">sub_iff</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span><span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">L</span> <span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span> <span class="n">is_sub</span> <span class="n">M</span> <span class="n">x</span> <span class="n">N</span> <span class="n">L</span> <span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span> <span class="n">M</span> <span class="o">[</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">N</span> <span class="o">]</span> <span class="n">is_def</span> <span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span> <span class="n">M</span> <span class="o">[</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">N</span> <span class="o">]</span> <span class="bp">=</span> <span class="n">L</span> <span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>

<a name="166664119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/166664119" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#166664119">Mario Carneiro (May 27 2019 at 21:05)</a>:</h4>
<p>seems like this is the wrong question. The answer to "is this provable" is either "no you got the math wrong" or "yes this can be formalized"</p>

<a name="166664208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/166664208" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#166664208">Kenny Lau (May 27 2019 at 21:07)</a>:</h4>
<p>what if the provability is independent of the Lean axioms? :P</p>

<a name="166664226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/166664226" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#166664226">Patrick Thomas (May 27 2019 at 21:07)</a>:</h4>
<p>That would be good to know too :)</p>

<a name="166664232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/166664232" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#166664232">Mario Carneiro (May 27 2019 at 21:07)</a>:</h4>
<p>do you bring that up in all your intro classes Kenny?</p>

<a name="166664290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/166664290" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#166664290">Kevin Buzzard (May 27 2019 at 21:08)</a>:</h4>
<p>In maths it's very unlikely that something Kenny saw so far would be even close to being indepedent!</p>

<a name="166664292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/166664292" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#166664292">Kevin Buzzard (May 27 2019 at 21:08)</a>:</h4>
<p>Maybe I mentioned CH but I bet that's it.</p>

<a name="166664301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/166664301" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#166664301">Mario Carneiro (May 27 2019 at 21:08)</a>:</h4>
<p>well, as you know there are several independent statements "close to the surface" in lean because MLTT is underdetermined... but this is off topic</p>

<a name="166664401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/166664401" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#166664401">Patrick Thomas (May 27 2019 at 21:10)</a>:</h4>
<p>I guess my question is, that it was suggested that I use <code>is_sub</code> instead of the other two, and I was wondering if that is equivalent. I thought maybe this lemma would show that it is, if it is true.</p>

<a name="166664492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/166664492" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#166664492">Mario Carneiro (May 27 2019 at 21:12)</a>:</h4>
<p>it is true, unless there is some subtle bug in the inductives</p>

<a name="166664525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/166664525" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#166664525">Patrick Thomas (May 27 2019 at 21:13)</a>:</h4>
<p>Ok, thank you. I will try to prove it. Probably induction on <code>M</code>?</p>

<a name="166664594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/166664594" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#166664594">Mario Carneiro (May 27 2019 at 21:14)</a>:</h4>
<p>induction on the predicates</p>

<a name="166664625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/166664625" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#166664625">Patrick Thomas (May 27 2019 at 21:15)</a>:</h4>
<p>Hmm, I'm not sure I am familiar with that form of induction.</p>

<a name="166665680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/166665680" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#166665680">Patrick Thomas (May 27 2019 at 21:42)</a>:</h4>
<p>How would you set that up? Can you use the induction tactic?</p>

<a name="166666382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/166666382" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#166666382">Kevin Buzzard (May 27 2019 at 21:59)</a>:</h4>
<p>Yes. If you have some hypothesis <code>h</code> whose type is an inductive type, then <code>induction h</code> will do some kind of induction on <code>h</code>.</p>

<a name="166666576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/166666576" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#166666576">Patrick Thomas (May 27 2019 at 22:04)</a>:</h4>
<p>I guess that is not the case here? Mario suggested induction on the predicates. Maybe that means <code>is_sub.rec_on</code>?</p>

<a name="166670155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/166670155" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#166670155">Kevin Buzzard (May 27 2019 at 23:00)</a>:</h4>
<p>If you are in tactic mode and have <code>h : is_sub (pre_term.var M) x N L</code> then <code>cases h</code> or <code>induction h</code> (or, better, <code>cases h with AAA BBB CCC DDD EEE FFF GGG</code> and then look at the types of what you ended up with and rename accordingly) should work just fine. Yes, they're just applying rec under the hood.</p>

<a name="166670532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/166670532" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#166670532">Patrick Thomas (May 27 2019 at 23:11)</a>:</h4>
<p>Thank you!</p>

<a name="166674042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/166674042" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#166674042">Patrick Thomas (May 28 2019 at 00:46)</a>:</h4>
<p>Should there be induction hypotheses, for instance for the <code>is_sub.app</code> case?</p>

<a name="166674054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/166674054" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#166674054">Patrick Thomas (May 28 2019 at 00:47)</a>:</h4>
<p>I don't see any under the goal.</p>

<a name="166678003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/166678003" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#166678003">Patrick Thomas (May 28 2019 at 02:37)</a>:</h4>
<p>Do I need to add an axiom to have <code>( is_sub M x N P ∧ is_sub M x N Q ) → P = Q</code>?</p>

<a name="166692904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/166692904" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#166692904">Kevin Buzzard (May 28 2019 at 08:15)</a>:</h4>
<p>You shouldn't ever have to add axioms.</p>

<a name="166757372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/166757372" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#166757372">Patrick Thomas (May 28 2019 at 20:43)</a>:</h4>
<p>Do you know how I might be able to show this?</p>

<a name="166757513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/166757513" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#166757513">Mario Carneiro (May 28 2019 at 20:45)</a>:</h4>
<p>induction on the first <code>is_sub</code> (generalizing <code>Q</code>), cases on the other</p>

<a name="166758924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/166758924" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#166758924">Patrick Thomas (May 28 2019 at 21:00)</a>:</h4>
<p>Thank you. On the proof of the earlier correspondence between is_sub and sub, sub_is_def, when I use cases, I kind of expected induction hypotheses in the goals, but I don't see any. Am I missing something in my understanding of the proof, or in the use of cases?</p>

<a name="166761422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/166761422" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#166761422">Mario Carneiro (May 28 2019 at 21:30)</a>:</h4>
<p><code>cases</code> is like <code>induction</code> except there are no induction hypotheses</p>

<a name="166761443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/166761443" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#166761443">Mario Carneiro (May 28 2019 at 21:30)</a>:</h4>
<p>if you need an IH (and you will in these proofs) use <code>induction</code></p>

<a name="166761896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/166761896" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#166761896">Patrick Thomas (May 28 2019 at 21:35)</a>:</h4>
<p>I see. That makes sense. Feeling kind of silly. Thank you.</p>

<a name="167444654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/167444654" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#167444654">Patrick Thomas (Jun 06 2019 at 01:42)</a>:</h4>
<p>Nevermind.</p>

<a name="167445233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/167445233" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#167445233">Mario Carneiro (Jun 06 2019 at 01:57)</a>:</h4>
<p>I fixed your formatting</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">open</span> <span class="n">set</span>
<span class="n">local</span> <span class="n">attribute</span> <span class="o">[</span><span class="kn">instance</span><span class="o">,</span> <span class="n">priority</span> <span class="mi">0</span><span class="o">]</span> <span class="n">classical</span><span class="bp">.</span><span class="n">prop_decidable</span>

<span class="n">def</span> <span class="n">var</span> <span class="o">:=</span> <span class="bp">ℕ</span>

<span class="kn">inductive</span> <span class="n">pre_term</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">:</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span>
<span class="bp">|</span> <span class="n">abs</span> <span class="o">:</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span>

<span class="n">def</span> <span class="n">FV</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">var</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:=</span> <span class="n">FV</span> <span class="n">P</span> <span class="err">∪</span> <span class="n">FV</span> <span class="n">Q</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">x</span> <span class="n">P</span><span class="o">)</span> <span class="o">:=</span> <span class="n">FV</span> <span class="n">P</span> <span class="err">\</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span>

<span class="kn">lemma</span> <span class="n">lemma_1</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">var</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span> <span class="n">Q</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">FV</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">FV</span> <span class="n">P</span> <span class="bp">∨</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">FV</span> <span class="n">Q</span> <span class="o">:=</span>
<span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">FV</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span><span class="o">)</span> <span class="bp">=</span> <span class="n">FV</span> <span class="n">P</span> <span class="err">∪</span> <span class="n">FV</span> <span class="n">Q</span><span class="o">,</span> <span class="k">by</span> <span class="n">refl</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">FV</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">FV</span> <span class="n">P</span> <span class="err">∪</span> <span class="n">FV</span> <span class="n">Q</span><span class="o">,</span> <span class="k">from</span> <span class="o">(</span><span class="n">ext_iff</span> <span class="o">(</span><span class="n">FV</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span><span class="o">))</span> <span class="o">(</span><span class="n">FV</span> <span class="n">P</span> <span class="err">∪</span> <span class="n">FV</span> <span class="n">Q</span><span class="o">))</span><span class="bp">.</span><span class="n">elim_left</span> <span class="n">s1</span> <span class="n">x</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s3</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">FV</span> <span class="n">P</span> <span class="err">∪</span> <span class="n">FV</span> <span class="n">Q</span> <span class="bp">↔</span> <span class="o">((</span><span class="n">x</span> <span class="err">∈</span> <span class="n">FV</span> <span class="n">P</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="n">FV</span> <span class="n">Q</span><span class="o">)),</span> <span class="k">from</span> <span class="n">mem_union</span> <span class="n">x</span> <span class="o">(</span><span class="n">FV</span> <span class="n">P</span><span class="o">)</span> <span class="o">(</span><span class="n">FV</span> <span class="n">Q</span><span class="o">),</span>
<span class="n">iff_iff_eq</span><span class="bp">.</span><span class="n">elim_right</span> <span class="o">(</span><span class="n">eq</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">iff_iff_eq</span><span class="bp">.</span><span class="n">elim_left</span> <span class="n">s2</span><span class="o">)</span> <span class="o">(</span><span class="n">iff_iff_eq</span><span class="bp">.</span><span class="n">elim_left</span> <span class="n">s3</span><span class="o">))</span>

<span class="kn">lemma</span> <span class="n">lemma_2</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">var</span><span class="o">}</span> <span class="o">{</span><span class="n">y</span> <span class="o">:</span> <span class="n">var</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">FV</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">FV</span> <span class="n">P</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="k">have</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">FV</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="n">FV</span> <span class="n">P</span> <span class="bp">∧</span> <span class="n">x</span> <span class="err">∉</span> <span class="o">{</span> <span class="n">y</span> <span class="o">}),</span> <span class="k">from</span> <span class="n">mem_diff</span> <span class="n">x</span><span class="o">,</span>
<span class="k">have</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∉</span> <span class="o">{</span> <span class="n">y</span> <span class="o">}</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span><span class="o">,</span> <span class="k">from</span> <span class="n">not_iff_not</span><span class="bp">.</span><span class="n">elim_right</span> <span class="n">mem_singleton_iff</span><span class="o">,</span>
<span class="n">simp</span> <span class="bp">*</span>
<span class="kn">end</span>


<span class="c1">-- M [ x := N ]</span>
<span class="n">def</span> <span class="n">sub</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span>
<span class="c1">-- if x = y then y [ x := N ] = N else y [ x := N ] = y</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span> <span class="k">then</span> <span class="n">N</span> <span class="k">else</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span>

<span class="c1">-- (P Q) [ x := N ] = (P [ x := N ] Q [ x := N ])</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="o">(</span><span class="n">sub</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">sub</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span>

<span class="c1">-- if x = y then (λ y . P) [ x := N ] = (λ y . P) else (λ y . P) [ x := N ] = (λ y . P [ x := N ])</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="k">then</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="k">else</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="o">(</span><span class="n">sub</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span><span class="o">))</span>


<span class="kn">lemma</span> <span class="n">lemma_3</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">t</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">t</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">a2</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">s</span><span class="o">,</span>
<span class="k">show</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">t</span><span class="o">,</span> <span class="k">from</span> <span class="o">((</span><span class="n">ext_iff</span> <span class="n">s</span> <span class="n">t</span><span class="o">)</span><span class="bp">.</span><span class="n">elim_left</span> <span class="n">a1</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">elim_left</span> <span class="n">a2</span>

<span class="kn">lemma</span> <span class="n">lemma_1_2_5_ii</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">var</span><span class="o">}</span> <span class="o">{</span><span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">}</span> <span class="o">{</span><span class="n">z</span> <span class="o">:</span> <span class="n">var</span><span class="o">}</span> <span class="o">:</span>
<span class="n">z</span> <span class="err">∈</span> <span class="n">FV</span> <span class="o">(</span><span class="n">sub</span> <span class="n">M</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">z</span> <span class="err">∈</span> <span class="n">FV</span> <span class="n">M</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">z</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">z</span> <span class="err">∈</span> <span class="n">FV</span> <span class="n">N</span> <span class="bp">∧</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">FV</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">a1</span><span class="o">,</span>
    <span class="k">show</span> <span class="o">(</span><span class="n">z</span> <span class="err">∈</span> <span class="n">FV</span> <span class="n">M</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">z</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">z</span> <span class="err">∈</span> <span class="n">FV</span> <span class="n">N</span> <span class="bp">∧</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">FV</span> <span class="n">M</span><span class="o">),</span> <span class="n">sorry</span> <span class="o">},</span>
  <span class="o">{</span> <span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="o">(</span><span class="n">z</span> <span class="err">∈</span> <span class="n">FV</span> <span class="n">M</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">z</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">z</span> <span class="err">∈</span> <span class="n">FV</span> <span class="n">N</span> <span class="bp">∧</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">FV</span> <span class="n">M</span><span class="o">),</span>
    <span class="k">show</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">FV</span> <span class="o">(</span><span class="n">sub</span> <span class="n">M</span> <span class="n">x</span> <span class="n">N</span><span class="o">),</span>
    <span class="n">induction</span> <span class="n">M</span><span class="o">,</span>
    <span class="n">case</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="o">{</span>
      <span class="n">sorry</span> <span class="o">},</span>
    <span class="n">case</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="o">:</span> <span class="n">P</span> <span class="n">Q</span> <span class="n">IH_1</span> <span class="n">IH_2</span> <span class="o">{</span>
      <span class="n">sorry</span> <span class="o">},</span>
    <span class="n">case</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="o">:</span> <span class="n">y</span> <span class="n">P</span> <span class="n">IH</span> <span class="o">{</span>
      <span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="o">(</span><span class="n">z</span> <span class="err">∈</span> <span class="n">FV</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">z</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">z</span> <span class="err">∈</span> <span class="n">FV</span> <span class="n">N</span> <span class="bp">∧</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">FV</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)),</span> <span class="k">from</span> <span class="n">a1</span><span class="o">,</span>
      <span class="n">refine</span> <span class="n">or</span><span class="bp">.</span><span class="n">elim</span> <span class="n">s1</span> <span class="n">sorry</span> <span class="bp">_</span><span class="o">,</span>
      <span class="k">assume</span> <span class="n">a2</span> <span class="o">:</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">FV</span> <span class="n">N</span> <span class="bp">∧</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">FV</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">),</span>
      <span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">FV</span> <span class="n">N</span> <span class="o">:=</span> <span class="n">and</span><span class="bp">.</span><span class="n">elim_left</span> <span class="n">a2</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">s3</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">FV</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="o">:=</span> <span class="n">and</span><span class="bp">.</span><span class="n">elim_right</span> <span class="n">a2</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">s4</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">FV</span> <span class="n">P</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">lemma_2</span><span class="bp">.</span><span class="n">elim_left</span> <span class="n">s3</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">s5</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">FV</span> <span class="n">P</span> <span class="o">:=</span> <span class="n">and</span><span class="bp">.</span><span class="n">elim_left</span> <span class="n">s4</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">s6</span> <span class="o">:</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">FV</span> <span class="n">N</span> <span class="bp">∧</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">FV</span> <span class="n">P</span> <span class="o">:=</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span> <span class="n">s2</span> <span class="n">s5</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">s7</span> <span class="o">:</span> <span class="o">(</span><span class="n">z</span> <span class="err">∈</span> <span class="n">FV</span> <span class="n">P</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">z</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">z</span> <span class="err">∈</span> <span class="n">FV</span> <span class="n">N</span> <span class="bp">∧</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">FV</span> <span class="n">P</span><span class="o">)</span> <span class="bp">→</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">FV</span> <span class="o">(</span><span class="n">sub</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">:=</span> <span class="n">IH</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">s8</span> <span class="o">:</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">FV</span> <span class="o">(</span><span class="n">sub</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">:=</span> <span class="n">s7</span> <span class="o">(</span><span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="n">s6</span><span class="o">),</span>
      <span class="k">have</span> <span class="n">s9</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">and</span><span class="bp">.</span><span class="n">elim_right</span> <span class="n">s4</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">s5</span> <span class="o">:</span> <span class="n">sub</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">=</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="o">(</span><span class="n">sub</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span><span class="o">))</span> <span class="o">:=</span> <span class="n">if_neg</span> <span class="n">s9</span><span class="o">,</span>
      <span class="k">show</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">FV</span> <span class="o">(</span><span class="n">sub</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span><span class="o">),</span>
      <span class="n">sorry</span> <span class="o">}</span> <span class="o">}</span>
<span class="kn">end</span>
</pre></div>


{% endraw %}
