---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113489newmembers/17610TacticProofnotRespondingOverflow.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html">Tactic Proof not Responding. Overflow?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="188245630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188245630" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188245630">ROCKY KAMEN-RUBIO (Feb 14 2020 at 20:54)</a>:</h4>
<p>Hi everyone! I'm trying to do a tactic proof that ends with a very long proposition that should simplify to false. Rather than going through it manually, I'm trying to use simp, finish, norm_num, etc. The problem is that the window with the goal state just goes to "updating" indefinitely. Have I reached the limit of what these tactics can do, or am I doing something wrong? Thanks!</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">init</span><span class="bp">.</span><span class="n">data</span><span class="bp">.</span><span class="n">nat</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">init</span><span class="bp">.</span><span class="n">algebra</span><span class="bp">.</span><span class="n">ring</span>
<span class="kn">import</span> <span class="n">init</span><span class="bp">.</span><span class="n">algebra</span><span class="bp">.</span><span class="n">norm_num</span>
<span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">set_option</span> <span class="n">class</span><span class="bp">.</span><span class="n">instance_max_depth</span> <span class="mi">15000000</span>

<span class="n">def</span> <span class="n">myIsEven</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">n</span> <span class="bp">=</span> <span class="o">(</span><span class="n">n</span><span class="bp">/</span><span class="mi">2</span><span class="o">)</span><span class="bp">*</span><span class="mi">2</span>
<span class="n">def</span> <span class="n">myIsOdd</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">n</span> <span class="bp">=</span> <span class="o">(</span><span class="n">n</span><span class="bp">/</span><span class="mi">2</span><span class="o">)</span><span class="bp">*</span><span class="mi">2</span><span class="o">)</span>

<span class="c1">--Alice only sees r and Bob only sees c. The strategy isn&#39;t (r,c) → (...) but two maps, r→(r1 r2 r3) and c → (c1 c2 c3)</span>
<span class="c1">--I&#39;m using 0 and 1 instead of Green and Red as the two options to fill squares. This makes checking parity of strategies easier</span>

<span class="n">def</span> <span class="n">checkStrategyrc</span> <span class="o">(</span><span class="n">r</span> <span class="n">c</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">strategy</span> <span class="o">:</span> <span class="o">((</span><span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">×</span> <span class="bp">ℕ</span> <span class="bp">×</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="bp">×</span> <span class="o">(</span><span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">×</span> <span class="bp">ℕ</span> <span class="bp">×</span> <span class="bp">ℕ</span><span class="o">)))</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
        <span class="c1">--functionalize this with lists.</span>
        <span class="k">let</span> <span class="n">r1</span> <span class="o">:=</span> <span class="o">(</span><span class="n">strategy</span><span class="bp">.</span><span class="mi">1</span> <span class="n">r</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span>
        <span class="n">r2</span> <span class="o">:=</span> <span class="o">(</span><span class="n">strategy</span><span class="bp">.</span><span class="mi">1</span> <span class="n">r</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span>
        <span class="n">r3</span> <span class="o">:=</span> <span class="o">(</span><span class="n">strategy</span><span class="bp">.</span><span class="mi">1</span> <span class="n">r</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
        <span class="n">c1</span> <span class="o">:=</span> <span class="o">(</span><span class="n">strategy</span><span class="bp">.</span><span class="mi">2</span> <span class="n">c</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span>
        <span class="n">c2</span> <span class="o">:=</span> <span class="o">(</span><span class="n">strategy</span><span class="bp">.</span><span class="mi">2</span> <span class="n">c</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span>
        <span class="n">c3</span> <span class="o">:=</span> <span class="o">(</span><span class="n">strategy</span><span class="bp">.</span><span class="mi">2</span> <span class="n">c</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">2</span>

        <span class="k">in</span> <span class="n">myIsEven</span><span class="o">(</span><span class="n">r1</span> <span class="bp">+</span> <span class="n">r2</span> <span class="bp">+</span> <span class="n">r3</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">myIsOdd</span><span class="o">(</span><span class="n">c1</span> <span class="bp">+</span> <span class="n">c2</span> <span class="bp">+</span> <span class="n">c3</span><span class="o">)</span> <span class="bp">∧</span>
        <span class="o">((</span><span class="n">r</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∧</span> <span class="n">c</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∧</span> <span class="n">r1</span> <span class="bp">=</span> <span class="n">c1</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">r</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∧</span> <span class="n">c</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">∧</span> <span class="n">r2</span> <span class="bp">=</span> <span class="n">c1</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">r</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∧</span> <span class="n">c</span> <span class="bp">=</span> <span class="mi">3</span> <span class="bp">∧</span> <span class="n">r3</span> <span class="bp">=</span> <span class="n">c1</span><span class="o">)</span>
        <span class="bp">∨</span><span class="o">(</span><span class="n">r</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">∧</span> <span class="n">c</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∧</span> <span class="n">r1</span> <span class="bp">=</span> <span class="n">c2</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">r</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">∧</span> <span class="n">c</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">∧</span> <span class="n">r2</span> <span class="bp">=</span> <span class="n">c2</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">r</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">∧</span> <span class="n">c</span> <span class="bp">=</span> <span class="mi">3</span> <span class="bp">∧</span> <span class="n">r3</span> <span class="bp">=</span> <span class="n">c2</span><span class="o">)</span>
        <span class="bp">∨</span><span class="o">(</span><span class="n">r</span> <span class="bp">=</span> <span class="mi">3</span> <span class="bp">∧</span> <span class="n">c</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∧</span> <span class="n">r1</span> <span class="bp">=</span> <span class="n">c3</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">r</span> <span class="bp">=</span> <span class="mi">3</span> <span class="bp">∧</span> <span class="n">c</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">∧</span> <span class="n">r2</span> <span class="bp">=</span> <span class="n">c3</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">r</span> <span class="bp">=</span> <span class="mi">3</span> <span class="bp">∧</span> <span class="n">c</span> <span class="bp">=</span> <span class="mi">3</span> <span class="bp">∧</span> <span class="n">r3</span> <span class="bp">=</span> <span class="n">c3</span><span class="o">))</span>

<span class="c1">--checks all three conditions are met for the strategy</span>
<span class="n">def</span> <span class="n">checkStrategy</span> <span class="o">(</span><span class="n">strategy</span> <span class="o">:</span> <span class="o">((</span><span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">×</span> <span class="bp">ℕ</span> <span class="bp">×</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="bp">×</span> <span class="o">(</span><span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">×</span> <span class="bp">ℕ</span> <span class="bp">×</span> <span class="bp">ℕ</span><span class="o">)))</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
    <span class="o">(</span><span class="n">checkStrategyrc</span> <span class="mi">1</span> <span class="mi">1</span> <span class="n">strategy</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">checkStrategyrc</span> <span class="mi">1</span> <span class="mi">2</span> <span class="n">strategy</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">checkStrategyrc</span> <span class="mi">1</span> <span class="mi">3</span> <span class="n">strategy</span><span class="o">)</span> <span class="bp">∧</span>
    <span class="o">(</span><span class="n">checkStrategyrc</span> <span class="mi">2</span> <span class="mi">1</span> <span class="n">strategy</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">checkStrategyrc</span> <span class="mi">2</span> <span class="mi">2</span> <span class="n">strategy</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">checkStrategyrc</span> <span class="mi">2</span> <span class="mi">3</span> <span class="n">strategy</span><span class="o">)</span> <span class="bp">∧</span>
    <span class="o">(</span><span class="n">checkStrategyrc</span> <span class="mi">3</span> <span class="mi">1</span> <span class="n">strategy</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">checkStrategyrc</span> <span class="mi">3</span> <span class="mi">2</span> <span class="n">strategy</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">checkStrategyrc</span> <span class="mi">3</span> <span class="mi">3</span> <span class="n">strategy</span><span class="o">)</span>

<span class="c1">--someone on Zulip said to try putting this not directly after the import statements. This seems to have helped</span>
<span class="n">open_locale</span> <span class="n">classical</span>
<span class="c1">--given a strategy, we can&#39;t have it satisfy all the conditions</span>
<span class="kn">theorem</span> <span class="n">noStrategy2</span> <span class="o">(</span><span class="n">strategy</span> <span class="o">:</span> <span class="o">((</span><span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">×</span> <span class="bp">ℕ</span> <span class="bp">×</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="bp">×</span> <span class="o">(</span><span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">×</span> <span class="bp">ℕ</span> <span class="bp">×</span> <span class="bp">ℕ</span><span class="o">)))</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">checkStrategy</span> <span class="o">(</span><span class="n">strategy</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intro</span> <span class="n">s</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">checkStrategy</span> <span class="n">at</span> <span class="n">s</span><span class="o">,</span>
<span class="n">repeat</span> <span class="o">{</span><span class="n">rw</span> <span class="n">checkStrategyrc</span> <span class="n">at</span> <span class="n">s</span><span class="o">},</span>
<span class="n">simp</span> <span class="n">at</span> <span class="n">s</span><span class="o">,</span>
<span class="n">revert</span> <span class="n">s</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>

<a name="188245876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188245876" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188245876">Johan Commelin (Feb 14 2020 at 20:57)</a>:</h4>
<p><span class="user-mention" data-user-id="261068">@ROCKY KAMEN-RUBIO</span> Pro tip: If you wrap your code in</p>
<div class="codehilite"><pre><span></span>```lean
code goes here
```
</pre></div>


<p>then you'll get pretty formatting with syntax highlighting.</p>

<a name="188246030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188246030" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188246030">ROCKY KAMEN-RUBIO (Feb 14 2020 at 20:59)</a>:</h4>
<p>Thank you!!! I was trying to figure out how to do that.</p>

<a name="188246301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188246301" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188246301">Johan Commelin (Feb 14 2020 at 21:02)</a>:</h4>
<p><span class="user-mention" data-user-id="261068">@ROCKY KAMEN-RUBIO</span> Instead of <code>repeat { rw foobar at s }</code>, you could do <code>simp only [foobar] at s</code>.</p>

<a name="188246322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188246322" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188246322">Johan Commelin (Feb 14 2020 at 21:02)</a>:</h4>
<p>I would also simp <code>myIsEven</code> and <code>myIsOdd</code> away.</p>

<a name="188246341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188246341" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188246341">Johan Commelin (Feb 14 2020 at 21:03)</a>:</h4>
<p>Be sure to use <code>simp only</code>, because without the <code>only</code> Lean might try lots of other stuff as well.</p>

<a name="188246360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188246360" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188246360">Johan Commelin (Feb 14 2020 at 21:03)</a>:</h4>
<p>In fact, you could even use <code>dsimp only</code>.</p>

<a name="188246384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188246384" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188246384">Johan Commelin (Feb 14 2020 at 21:03)</a>:</h4>
<p>After that, I would try feeding it to <code>tauto</code>.</p>

<a name="188246479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188246479" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188246479">Johan Commelin (Feb 14 2020 at 21:04)</a>:</h4>
<p>But really, here an external solver would be very helpful. Some people are working on this, but atm it isn't easy to use.</p>

<a name="188247800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188247800" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188247800">ROCKY KAMEN-RUBIO (Feb 14 2020 at 21:17)</a>:</h4>
<p><code>dsimp only </code> is giving me a "failed to simplify state" error, and  <code> tauto </code> is updating forever.</p>

<a name="188248110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188248110" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188248110">Kevin Buzzard (Feb 14 2020 at 21:20)</a>:</h4>
<p>Setting the class instance max depth to such a high value might well cause timeout problems. Why are you changing the max depth at all?</p>

<a name="188248194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188248194" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188248194">Kevin Buzzard (Feb 14 2020 at 21:21)</a>:</h4>
<p>Actually you don't even seem to be using any typeclasses :-)</p>

<a name="188248591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188248591" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188248591">ROCKY KAMEN-RUBIO (Feb 14 2020 at 21:26)</a>:</h4>
<p>I was getting class instance max depth exceeded errors so I increased the max depth. I'm still pretty new to lean so I don't fully understand the best practices. Any suggestions would be very much appreciated!</p>

<a name="188248629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188248629" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188248629">Kevin Buzzard (Feb 14 2020 at 21:26)</a>:</h4>
<p>I'm a bit confused by this because your code doesn't have any typeclasses in.</p>

<a name="188248696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188248696" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188248696">Kevin Buzzard (Feb 14 2020 at 21:27)</a>:</h4>
<p>What's the human-readable argument that proves this theorem?</p>

<a name="188248996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188248996" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188248996">Kevin Buzzard (Feb 14 2020 at 21:31)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">noStrategy2</span> <span class="o">(</span><span class="n">strategy</span> <span class="o">:</span> <span class="o">((</span><span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">×</span> <span class="bp">ℕ</span> <span class="bp">×</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="bp">×</span> <span class="o">(</span><span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">×</span> <span class="bp">ℕ</span> <span class="bp">×</span> <span class="bp">ℕ</span><span class="o">)))</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">checkStrategy</span> <span class="o">(</span><span class="n">strategy</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intro</span> <span class="n">s</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">checkStrategy</span> <span class="n">at</span> <span class="n">s</span><span class="o">,</span>
<span class="n">repeat</span> <span class="o">{</span><span class="n">rw</span> <span class="n">checkStrategyrc</span> <span class="n">at</span> <span class="n">s</span><span class="o">},</span>
<span class="n">simp</span> <span class="n">at</span> <span class="n">s</span><span class="o">,</span>
<span class="n">revert</span> <span class="n">s</span><span class="o">,</span>
<span class="n">unfold</span> <span class="n">myIsEven</span><span class="o">,</span>
<span class="n">unfold</span> <span class="n">myIsOdd</span><span class="o">,</span>
<span class="n">rw</span> <span class="o">(</span><span class="k">show</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">↔</span> <span class="n">false</span><span class="o">,</span> <span class="k">by</span> <span class="n">norm_num</span><span class="o">),</span>
<span class="n">rw</span> <span class="o">(</span><span class="k">show</span> <span class="mi">2</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">↔</span> <span class="n">false</span><span class="o">,</span> <span class="k">by</span> <span class="n">norm_num</span><span class="o">),</span>
<span class="n">rw</span> <span class="o">(</span><span class="k">show</span> <span class="mi">3</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">↔</span> <span class="n">false</span><span class="o">,</span> <span class="k">by</span> <span class="n">norm_num</span><span class="o">),</span>
<span class="n">rw</span> <span class="o">(</span><span class="k">show</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">3</span> <span class="bp">↔</span> <span class="n">false</span><span class="o">,</span> <span class="k">by</span> <span class="n">norm_num</span><span class="o">),</span>
<span class="n">rw</span> <span class="o">(</span><span class="k">show</span> <span class="mi">3</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">↔</span> <span class="n">false</span><span class="o">,</span> <span class="k">by</span> <span class="n">norm_num</span><span class="o">),</span>
<span class="n">rw</span> <span class="o">(</span><span class="k">show</span> <span class="mi">2</span> <span class="bp">=</span> <span class="mi">3</span> <span class="bp">↔</span> <span class="n">false</span><span class="o">,</span> <span class="k">by</span> <span class="n">norm_num</span><span class="o">),</span>
<span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">false_and</span><span class="o">,</span> <span class="n">false_or</span><span class="o">],</span>
<span class="n">tauto</span><span class="bp">!</span><span class="o">,</span> <span class="c1">-- fails</span>
<span class="kn">end</span>
</pre></div>

<a name="188249060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188249060" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188249060">Kevin Buzzard (Feb 14 2020 at 21:32)</a>:</h4>
<div class="codehilite"><pre><span></span>⊢ ((strategy.fst 1).fst + ((strategy.fst 1).snd.fst + (strategy.fst 1).snd.snd) =
         ((strategy.fst 1).fst + ((strategy.fst 1).snd.fst + (strategy.fst 1).snd.snd)) / 2 * 2 ∧
       ¬(strategy.snd 1).fst + ((strategy.snd 1).snd.fst + (strategy.snd 1).snd.snd) =
             ((strategy.snd 1).fst + ((strategy.snd 1).snd.fst + (strategy.snd 1).snd.snd)) / 2 * 2 ∧
         ((strategy.fst 1).fst = (strategy.snd 1).fst ∨ false)) ∧
    ((strategy.fst 1).fst + ((strategy.fst 1).snd.fst + (strategy.fst 1).snd.snd) =
           ((strategy.fst 1).fst + ((strategy.fst 1).snd.fst + (strategy.fst 1).snd.snd)) / 2 * 2 ∧
         ¬(strategy.snd 2).fst + ((strategy.snd 2).snd.fst + (strategy.snd 2).snd.snd) =
               ((strategy.snd 2).fst + ((strategy.snd 2).snd.fst + (strategy.snd 2).snd.snd)) / 2 * 2 ∧
           ((strategy.fst 1).snd.fst = (strategy.snd 2).fst ∨ false)) ∧
      ((strategy.fst 1).fst + ((strategy.fst 1).snd.fst + (strategy.fst 1).snd.snd) =
             ((strategy.fst 1).fst + ((strategy.fst 1).snd.fst + (strategy.fst 1).snd.snd)) / 2 * 2 ∧
           ¬(strategy.snd 3).fst + ((strategy.snd 3).snd.fst + (strategy.snd 3).snd.snd) =
                 ((strategy.snd 3).fst + ((strategy.snd 3).snd.fst + (strategy.snd 3).snd.snd)) / 2 * 2 ∧
             ((strategy.fst 1).snd.snd = (strategy.snd 3).fst ∨ false)) ∧
        ((strategy.fst 2).fst + ((strategy.fst 2).snd.fst + (strategy.fst 2).snd.snd) =
               ((strategy.fst 2).fst + ((strategy.fst 2).snd.fst + (strategy.fst 2).snd.snd)) / 2 * 2 ∧
             ¬(strategy.snd 1).fst + ((strategy.snd 1).snd.fst + (strategy.snd 1).snd.snd) =
                   ((strategy.snd 1).fst + ((strategy.snd 1).snd.fst + (strategy.snd 1).snd.snd)) / 2 * 2 ∧
               ((strategy.fst 2).fst = (strategy.snd 1).snd.fst ∨ false)) ∧
          ((strategy.fst 2).fst + ((strategy.fst 2).snd.fst + (strategy.fst 2).snd.snd) =
                 ((strategy.fst 2).fst + ((strategy.fst 2).snd.fst + (strategy.fst 2).snd.snd)) / 2 * 2 ∧
               ¬(strategy.snd 2).fst + ((strategy.snd 2).snd.fst + (strategy.snd 2).snd.snd) =
                     ((strategy.snd 2).fst + ((strategy.snd 2).snd.fst + (strategy.snd 2).snd.snd)) / 2 * 2 ∧
                 ((strategy.fst 2).snd.fst = (strategy.snd 2).snd.fst ∨ false)) ∧
            ((strategy.fst 2).fst + ((strategy.fst 2).snd.fst + (strategy.fst 2).snd.snd) =
                   ((strategy.fst 2).fst + ((strategy.fst 2).snd.fst + (strategy.fst 2).snd.snd)) / 2 * 2 ∧
                 ¬(strategy.snd 3).fst + ((strategy.snd 3).snd.fst + (strategy.snd 3).snd.snd) =
                       ((strategy.snd 3).fst + ((strategy.snd 3).snd.fst + (strategy.snd 3).snd.snd)) / 2 * 2 ∧
                   ((strategy.fst 2).snd.snd = (strategy.snd 3).snd.fst ∨ false)) ∧
              ((strategy.fst 3).fst + ((strategy.fst 3).snd.fst + (strategy.fst 3).snd.snd) =
                     ((strategy.fst 3).fst + ((strategy.fst 3).snd.fst + (strategy.fst 3).snd.snd)) / 2 * 2 ∧
                   ¬(strategy.snd 1).fst + ((strategy.snd 1).snd.fst + (strategy.snd 1).snd.snd) =
                         ((strategy.snd 1).fst + ((strategy.snd 1).snd.fst + (strategy.snd 1).snd.snd)) / 2 * 2 ∧
                     ((strategy.fst 3).fst = (strategy.snd 1).snd.snd ∨ false)) ∧
                ((strategy.fst 3).fst + ((strategy.fst 3).snd.fst + (strategy.fst 3).snd.snd) =
                       ((strategy.fst 3).fst + ((strategy.fst 3).snd.fst + (strategy.fst 3).snd.snd)) / 2 * 2 ∧
                     ¬(strategy.snd 2).fst + ((strategy.snd 2).snd.fst + (strategy.snd 2).snd.snd) =
                           ((strategy.snd 2).fst + ((strategy.snd 2).snd.fst + (strategy.snd 2).snd.snd)) / 2 * 2 ∧
                       ((strategy.fst 3).snd.fst = (strategy.snd 2).snd.snd ∨ false)) ∧
                  (strategy.fst 3).fst + ((strategy.fst 3).snd.fst + (strategy.fst 3).snd.snd) =
                      ((strategy.fst 3).fst + ((strategy.fst 3).snd.fst + (strategy.fst 3).snd.snd)) / 2 * 2 ∧
                    ¬(strategy.snd 3).fst + ((strategy.snd 3).snd.fst + (strategy.snd 3).snd.snd) =
                          ((strategy.snd 3).fst + ((strategy.snd 3).snd.fst + (strategy.snd 3).snd.snd)) / 2 * 2 ∧
                      (strategy.fst 3).snd.snd = (strategy.snd 3).snd.snd →
  false
</pre></div>

<a name="188249244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188249244" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188249244">ROCKY KAMEN-RUBIO (Feb 14 2020 at 21:34)</a>:</h4>
<p>The argument goes something like: Alice and Bob need both of their strategies to be consistent. This means that we can think of their strategies as sampling from a single coloring of the 3x3 board with Green/Red tiles (represented by 1 and 0). If we impose the condition that each row has an even number of green tiles, and each column has an odd number of tiles, then the total number of green tiles should be even by summing the rows, but odd by summing the columns, which is impossible. </p>
<p>My strategy is more of a brute force approach though. I figured this would be easier to implement in lean and once i got this working I'd go to more complex arguments.</p>

<a name="188249297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188249297" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188249297">Kevin Buzzard (Feb 14 2020 at 21:35)</a>:</h4>
<p>I don't know anything about the board or tiles or strategy that you're talking about so I don't understand your argument.</p>

<a name="188249674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188249674" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188249674">Yury G. Kudryashov (Feb 14 2020 at 21:40)</a>:</h4>
<p>Could you please describe the game in English? I can try to decode Lean but it takes some time.</p>

<a name="188251011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188251011" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188251011">Kevin Buzzard (Feb 14 2020 at 21:56)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">noStrategy2</span> <span class="o">(</span><span class="n">strategy</span> <span class="o">:</span> <span class="o">((</span><span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">×</span> <span class="bp">ℕ</span> <span class="bp">×</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="bp">×</span> <span class="o">(</span><span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">×</span> <span class="bp">ℕ</span> <span class="bp">×</span> <span class="bp">ℕ</span><span class="o">)))</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">checkStrategy</span> <span class="o">(</span><span class="n">strategy</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intro</span> <span class="n">s</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">checkStrategy</span> <span class="n">at</span> <span class="n">s</span><span class="o">,</span>
<span class="n">repeat</span> <span class="o">{</span><span class="n">rw</span> <span class="n">checkStrategyrc</span> <span class="n">at</span> <span class="n">s</span><span class="o">},</span>
<span class="n">simp</span> <span class="n">at</span> <span class="n">s</span><span class="o">,</span>
<span class="n">revert</span> <span class="n">s</span><span class="o">,</span>
<span class="n">rw</span> <span class="o">(</span><span class="k">show</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">↔</span> <span class="n">false</span><span class="o">,</span> <span class="k">by</span> <span class="n">norm_num</span><span class="o">),</span>
<span class="n">rw</span> <span class="o">(</span><span class="k">show</span> <span class="mi">2</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">↔</span> <span class="n">false</span><span class="o">,</span> <span class="k">by</span> <span class="n">norm_num</span><span class="o">),</span>
<span class="n">rw</span> <span class="o">(</span><span class="k">show</span> <span class="mi">3</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">↔</span> <span class="n">false</span><span class="o">,</span> <span class="k">by</span> <span class="n">norm_num</span><span class="o">),</span>
<span class="n">rw</span> <span class="o">(</span><span class="k">show</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">3</span> <span class="bp">↔</span> <span class="n">false</span><span class="o">,</span> <span class="k">by</span> <span class="n">norm_num</span><span class="o">),</span>
<span class="n">rw</span> <span class="o">(</span><span class="k">show</span> <span class="mi">3</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">↔</span> <span class="n">false</span><span class="o">,</span> <span class="k">by</span> <span class="n">norm_num</span><span class="o">),</span>
<span class="n">rw</span> <span class="o">(</span><span class="k">show</span> <span class="mi">2</span> <span class="bp">=</span> <span class="mi">3</span> <span class="bp">↔</span> <span class="n">false</span><span class="o">,</span> <span class="k">by</span> <span class="n">norm_num</span><span class="o">),</span>
<span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">false_and</span><span class="o">,</span> <span class="n">false_or</span><span class="o">,</span> <span class="n">or_false</span><span class="o">],</span>
<span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="n">myIsOdd</span> <span class="bp">=</span> <span class="n">myIsOdd&#39;</span> <span class="o">:=</span> <span class="n">rfl</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">h</span><span class="o">,</span>
<span class="n">unfold</span> <span class="n">myIsOdd&#39;</span><span class="o">,</span>
<span class="n">intro</span> <span class="n">s</span><span class="o">,</span>
<span class="n">rcases</span> <span class="n">s</span> <span class="k">with</span> <span class="bp">⟨⟨</span><span class="n">s1</span><span class="o">,</span> <span class="n">t1</span><span class="o">,</span> <span class="n">u1</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">s2</span><span class="o">,</span> <span class="n">t2</span><span class="o">,</span> <span class="n">u2</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">s3</span><span class="o">,</span> <span class="n">t3</span><span class="o">,</span> <span class="n">u3</span><span class="bp">⟩</span><span class="o">,</span>
               <span class="bp">⟨</span><span class="n">s4</span><span class="o">,</span> <span class="n">t4</span><span class="o">,</span> <span class="n">u4</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">s5</span><span class="o">,</span> <span class="n">t5</span><span class="o">,</span> <span class="n">u5</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">s6</span><span class="o">,</span> <span class="n">t6</span><span class="o">,</span> <span class="n">u6</span><span class="bp">⟩</span><span class="o">,</span>
               <span class="bp">⟨</span><span class="n">s7</span><span class="o">,</span> <span class="n">t7</span><span class="o">,</span> <span class="n">u7</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">s8</span><span class="o">,</span> <span class="n">t8</span><span class="o">,</span> <span class="n">u8</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">s9</span><span class="o">,</span> <span class="n">t9</span><span class="o">,</span> <span class="n">u9</span><span class="bp">⟩⟩</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">u1</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">u2</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">u3</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">u4</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">u5</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">u6</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">u7</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">u8</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">u9</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
<span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>


<p>gets us to</p>
<div class="codehilite"><pre><span></span>1 goal
strategy : (ℕ → ℕ × ℕ × ℕ) × (ℕ → ℕ × ℕ × ℕ),
h : myIsOdd = myIsOdd&#39;,
t1 : ¬myIsEven ((strategy.snd 1).fst + ((strategy.snd 1).snd.fst + (strategy.snd 1).snd.snd)),
u1 : (strategy.fst 1).fst = (strategy.snd 1).fst,
t2 : ¬myIsEven ((strategy.snd 2).fst + ((strategy.snd 2).snd.fst + (strategy.snd 2).snd.snd)),
u2 : (strategy.fst 1).snd.fst = (strategy.snd 2).fst,
t3 : ¬myIsEven ((strategy.snd 3).fst + ((strategy.snd 3).snd.fst + (strategy.snd 3).snd.snd)),
u3 : (strategy.fst 1).snd.snd = (strategy.snd 3).fst,
t4 : ¬myIsEven ((strategy.snd 1).fst + ((strategy.snd 1).snd.fst + (strategy.snd 1).snd.snd)),
u4 : (strategy.fst 2).fst = (strategy.snd 1).snd.fst,
t5 : ¬myIsEven ((strategy.snd 2).fst + ((strategy.snd 2).snd.fst + (strategy.snd 2).snd.snd)),
u5 : (strategy.fst 2).snd.fst = (strategy.snd 2).snd.fst,
t6 : ¬myIsEven ((strategy.snd 3).fst + ((strategy.snd 3).snd.fst + (strategy.snd 3).snd.snd)),
u6 : (strategy.fst 2).snd.snd = (strategy.snd 3).snd.fst,
t7 : ¬myIsEven ((strategy.snd 1).fst + ((strategy.snd 1).snd.fst + (strategy.snd 1).snd.snd)),
u7 : (strategy.fst 3).fst = (strategy.snd 1).snd.snd,
t8 : ¬myIsEven ((strategy.snd 2).fst + ((strategy.snd 2).snd.fst + (strategy.snd 2).snd.snd)),
u8 : (strategy.fst 3).snd.fst = (strategy.snd 2).snd.snd,
t9 : ¬myIsEven ((strategy.snd 3).fst + ((strategy.snd 3).snd.fst + (strategy.snd 3).snd.snd)),
u9 : (strategy.fst 3).snd.snd = (strategy.snd 3).snd.snd,
s1 s2 s3 : myIsEven ((strategy.snd 1).fst + ((strategy.snd 2).fst + (strategy.snd 3).fst)),
s4 s5 s6 : myIsEven ((strategy.snd 1).snd.fst + ((strategy.snd 2).snd.fst + (strategy.snd 3).snd.fst)),
s7 s8 s9 : myIsEven ((strategy.snd 1).snd.snd + ((strategy.snd 2).snd.snd + (strategy.snd 3).snd.snd))
⊢ false
</pre></div>

<a name="188251087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188251087" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188251087">ROCKY KAMEN-RUBIO (Feb 14 2020 at 21:57)</a>:</h4>
<p>Sorry, I don't think I've been very clear. Here is a more detailed explanation:</p>
<p><strong>The Game: </strong>Alice is assigned a row and Bob is assigned a column of a 3x3 board. Neither knows the assignment of the other. The task is for each of them to color their respective row/column with Green and Red tiles (aka 1s and 0s) while meeting the following criteria:</p>
<ol>
<li>Rows must have an even number of Green tiles</li>
<li>Columns must have an odd number of Green tiles</li>
<li>The two colorings must be consistent - they must agree on the color of the shared tile</li>
</ol>
<p>They can plan a strategy beforehand but can't communicate after each gets their respective assignment. </p>
<p><strong>My goal</strong> is to prove that there is no guaranteed successful strategy. </p>
<p><strong>Lean Proof</strong> We can think of a strategy as a pair of maps, one from a row number to a triple of values we use to fill that row, the other from a column number to a triple of values we use to fill that column. <code>checkStrategyrc</code> checks that a given strategy works for a specific row r and column c by showing that the row sum is even, the column sum is odd, and the two agree at the intersection. <code>checkStrategy </code> calls <code>checkStrategy </code> on every combination of r and c in the 3x3 grid. Now we just need to show that no strategy passes checkStrategy.</p>
<p><strong>More Intuitive proof</strong> (This is what I would like to implement next) Since Alice and Bob must agree on the value of the intersection of their respective row/column, and the location of this intersection is arbitrary, we can think of their strategies as sampling from a single tiled 3x3 board. Summing the values in the rows of this single board we get an even number, but summing the values in the columns we get an odd number. The sums of the values in all the tiles should be the same whether we do it by rows or columns, so we get a contradiction.</p>

<a name="188251159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188251159" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188251159">Kevin Buzzard (Feb 14 2020 at 21:58)</a>:</h4>
<p>And now it seems to me that you might be able to prove it by observing that something like t1,t2,t3 (or whatever) together say that the sum of 9 terms is odd, and s1,s4,s7 (or whatever) say that the sum of the same 9 terms is even. But you can't expect Lean to figure this argument out because it knows no properties at all about your <code>myIsEven</code> and <code>myIsOdd</code></p>

<a name="188251264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188251264" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188251264">ROCKY KAMEN-RUBIO (Feb 14 2020 at 21:59)</a>:</h4>
<p>I also want to add that there are probably a number of ways to do what I'm attempting to do in much more efficient ways, both mathematically and in lean. I am open to any/all suggestions.</p>

<a name="188251286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188251286" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188251286">Kevin Buzzard (Feb 14 2020 at 21:59)</a>:</h4>
<p>So this is why it gets stuck, I suspect. Your proof involves summing all nine entries of the board. But no tactic will even prove <code>myIsEven(x) \and myIsEven(y) -&gt; myIsEven(x+y)</code></p>

<a name="188251354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188251354" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188251354">Kevin Buzzard (Feb 14 2020 at 22:00)</a>:</h4>
<p>If you want Lean to reason about your <code>myIsEven</code> you're going to have to train it or guide it.</p>

<a name="188251469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188251469" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188251469">Kevin Buzzard (Feb 14 2020 at 22:01)</a>:</h4>
<p>So the next thing to need to do is to prove things like this. Alternatively you can use Lean's built in predicates, where this stuff might well be proved already.</p>

<a name="188251807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188251807" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188251807">Kevin Buzzard (Feb 14 2020 at 22:05)</a>:</h4>
<div class="codehilite"><pre><span></span>t1 : ¬myIsEven ((strategy.snd 1).fst + ((strategy.snd 1).snd.fst + (strategy.snd 1).snd.snd)),
t2 : ¬myIsEven ((strategy.snd 2).fst + ((strategy.snd 2).snd.fst + (strategy.snd 2).snd.snd)),
t3 : ¬myIsEven ((strategy.snd 3).fst + ((strategy.snd 3).snd.fst + (strategy.snd 3).snd.snd)),
s1 : myIsEven ((strategy.snd 1).fst + ((strategy.snd 2).fst + (strategy.snd 3).fst)),
s4 : myIsEven ((strategy.snd 1).snd.fst + ((strategy.snd 2).snd.fst + (strategy.snd 3).snd.fst)),
s7 : myIsEven ((strategy.snd 1).snd.snd + ((strategy.snd 2).snd.snd + (strategy.snd 3).snd.snd))
</pre></div>


<p>Lean can't get from there to the end (these are facts from my session above). To get from there to the end you'll need <code>¬myIsEven x \and ¬myIsEven y -&gt; myIsEven (x + y)</code>, <code>¬myIsEven x \and myIsEven y -&gt; ¬myIsEven (x + y)</code> and <code>myIsEven x \and myIsEven y -&gt; myIsEven (x + y)</code>. Note that the first of these is not at all obvious, you'll need some argument that says that every integer has remainder 0 or 1 when divided by 2 -- there is some content here. This is why Lean can't solve your problem. Once you have these three lemmas you'll be done modulo the fact that you'll have to prove (a+b+c)+(d+e+f)+(g+h+i)=(a+d+g)+(b+e+h)+(c+f+i) but the <code>ring</code> tactic will do this once you've isolated this as the thing to prove.</p>

<a name="188251952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188251952" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188251952">Yury G. Kudryashov (Feb 14 2020 at 22:07)</a>:</h4>
<p>Are you sure you want to use your own <code>myIsEven</code> instead of <code>nat.even</code> from <code>data/nat/parity</code> in <code>mathlib</code>?</p>

<a name="188252025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188252025" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188252025">Bryan Gin-ge Chen (Feb 14 2020 at 22:08)</a>:</h4>
<p>By the way, you don't need to explicitly import anything that starts with <code>init</code>, all of those files are automatically imported by Lean unless you tell it not to by starting the file with <code>prelude</code>.</p>

<a name="188252149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188252149" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188252149">ROCKY KAMEN-RUBIO (Feb 14 2020 at 22:10)</a>:</h4>
<p>That makes sense. I was having trouble importing mathlib  so I thought I'd just define my own even/odd functions. I finally got it working though so I think you're right and that would be much easier.</p>

<a name="188252261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188252261" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188252261">Kevin Buzzard (Feb 14 2020 at 22:12)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/blob/d36930b25a644250f68129d1aa40c777d2aa3a91/src/data/nat/parity.lean#L88" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/d36930b25a644250f68129d1aa40c777d2aa3a91/src/data/nat/parity.lean#L88">examples in mathlib?</a> o_O</p>

<a name="188252371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188252371" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188252371">Kevin Buzzard (Feb 14 2020 at 22:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="261068">ROCKY KAMEN-RUBIO</span> <a href="#narrow/stream/113489-new-members/topic/Tactic.20Proof.20not.20Responding.2E.20Overflow.3F/near/188252149" title="#narrow/stream/113489-new-members/topic/Tactic.20Proof.20not.20Responding.2E.20Overflow.3F/near/188252149">said</a>:</p>
<blockquote>
<p>I was having trouble importing mathlib  so I thought I'd just define my own even/odd functions.</p>
</blockquote>
<p>That's fine, but you then also have to prove every theorem  about even and odd numbers which you need ;-)</p>

<a name="188252546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188252546" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188252546">Kevin Buzzard (Feb 14 2020 at 22:15)</a>:</h4>
<p><code>not_even_one</code> is currently my favourite mathlib theorem name :-)</p>

<a name="188252567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188252567" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188252567">Yury G. Kudryashov (Feb 14 2020 at 22:15)</a>:</h4>
<p>I'd prove this for any pair of odd numbers <code>(n, m)</code> instead of <code>(3, 3)</code>.  Then strategies will have the types <code>fin m → fin n → nat</code> and <code>fin n → fin m → nat</code>, respectively, and you can use <code>∀ i, (finset.univ.sum (f i)).even</code>.</p>

<a name="188252773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188252773" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188252773">Yury G. Kudryashov (Feb 14 2020 at 22:18)</a>:</h4>
<p>You can also make your functions take the values in <code>zmod 2</code>, then it will be <code>∀ i, finset.univ.sum (f i) = 0</code> and <code>∀ j, finset.univ.sum (g j) = 1</code>.</p>

<a name="188252960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188252960" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188252960">Yury G. Kudryashov (Feb 14 2020 at 22:21)</a>:</h4>
<p><code>zmod 2</code> is defined as <code>fin 2={n : nat | n &lt; 2}</code> with <code>1+1=0</code>.</p>

<a name="188253112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188253112" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188253112">Kevin Buzzard (Feb 14 2020 at 22:23)</a>:</h4>
<p>Here's a proof of your result with your even/odd modulo the standard facts:</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">noStrategy2</span> <span class="o">(</span><span class="n">strategy</span> <span class="o">:</span> <span class="o">((</span><span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">×</span> <span class="bp">ℕ</span> <span class="bp">×</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="bp">×</span> <span class="o">(</span><span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">×</span> <span class="bp">ℕ</span> <span class="bp">×</span> <span class="bp">ℕ</span><span class="o">)))</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">checkStrategy</span> <span class="o">(</span><span class="n">strategy</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intro</span> <span class="n">s</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">checkStrategy</span> <span class="n">at</span> <span class="n">s</span><span class="o">,</span>
<span class="n">repeat</span> <span class="o">{</span><span class="n">rw</span> <span class="n">checkStrategyrc</span> <span class="n">at</span> <span class="n">s</span><span class="o">},</span>
<span class="n">simp</span> <span class="n">at</span> <span class="n">s</span><span class="o">,</span>
<span class="n">revert</span> <span class="n">s</span><span class="o">,</span>
<span class="n">rw</span> <span class="o">(</span><span class="k">show</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">↔</span> <span class="n">false</span><span class="o">,</span> <span class="k">by</span> <span class="n">norm_num</span><span class="o">),</span>
<span class="n">rw</span> <span class="o">(</span><span class="k">show</span> <span class="mi">2</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">↔</span> <span class="n">false</span><span class="o">,</span> <span class="k">by</span> <span class="n">norm_num</span><span class="o">),</span>
<span class="n">rw</span> <span class="o">(</span><span class="k">show</span> <span class="mi">3</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">↔</span> <span class="n">false</span><span class="o">,</span> <span class="k">by</span> <span class="n">norm_num</span><span class="o">),</span>
<span class="n">rw</span> <span class="o">(</span><span class="k">show</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">3</span> <span class="bp">↔</span> <span class="n">false</span><span class="o">,</span> <span class="k">by</span> <span class="n">norm_num</span><span class="o">),</span>
<span class="n">rw</span> <span class="o">(</span><span class="k">show</span> <span class="mi">3</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">↔</span> <span class="n">false</span><span class="o">,</span> <span class="k">by</span> <span class="n">norm_num</span><span class="o">),</span>
<span class="n">rw</span> <span class="o">(</span><span class="k">show</span> <span class="mi">2</span> <span class="bp">=</span> <span class="mi">3</span> <span class="bp">↔</span> <span class="n">false</span><span class="o">,</span> <span class="k">by</span> <span class="n">norm_num</span><span class="o">),</span>
<span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">false_and</span><span class="o">,</span> <span class="n">false_or</span><span class="o">,</span> <span class="n">or_false</span><span class="o">],</span>
<span class="n">intro</span> <span class="n">s</span><span class="o">,</span>
<span class="n">rcases</span> <span class="n">s</span> <span class="k">with</span> <span class="bp">⟨⟨</span><span class="n">s1</span><span class="o">,</span> <span class="n">t1</span><span class="o">,</span> <span class="n">u1</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">s2</span><span class="o">,</span> <span class="n">t2</span><span class="o">,</span> <span class="n">u2</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">s3</span><span class="o">,</span> <span class="n">t3</span><span class="o">,</span> <span class="n">u3</span><span class="bp">⟩</span><span class="o">,</span>
               <span class="bp">⟨</span><span class="n">s4</span><span class="o">,</span> <span class="n">t4</span><span class="o">,</span> <span class="n">u4</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">s5</span><span class="o">,</span> <span class="n">t5</span><span class="o">,</span> <span class="n">u5</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">s6</span><span class="o">,</span> <span class="n">t6</span><span class="o">,</span> <span class="n">u6</span><span class="bp">⟩</span><span class="o">,</span>
               <span class="bp">⟨</span><span class="n">s7</span><span class="o">,</span> <span class="n">t7</span><span class="o">,</span> <span class="n">u7</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">s8</span><span class="o">,</span> <span class="n">t8</span><span class="o">,</span> <span class="n">u8</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">s9</span><span class="o">,</span> <span class="n">t9</span><span class="o">,</span> <span class="n">u9</span><span class="bp">⟩⟩</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">u1</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">u2</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">u3</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">u4</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">u5</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">u6</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">u7</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">u8</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">u9</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">odd_add_even</span> <span class="n">t1</span> <span class="o">(</span><span class="n">odd_add_odd</span> <span class="n">t2</span> <span class="n">t3</span><span class="o">),</span>
<span class="n">convert</span> <span class="n">even_add_even</span> <span class="n">s1</span> <span class="o">(</span><span class="n">even_add_even</span> <span class="n">s4</span> <span class="n">s7</span><span class="o">)</span> <span class="kn">using</span> <span class="mi">1</span><span class="o">,</span>
<span class="n">ring</span><span class="o">,</span>
<span class="n">congr&#39;</span> <span class="mi">2</span><span class="o">,</span>
<span class="n">ring</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p>But I used</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">odd_add_odd</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span><span class="o">}</span> <span class="o">:</span> <span class="n">myIsOdd</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">myIsOdd</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">myIsEven</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kn">theorem</span> <span class="n">odd_add_even</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span><span class="o">}</span> <span class="o">:</span> <span class="n">myIsOdd</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">myIsEven</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">myIsOdd</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kn">theorem</span> <span class="n">even_add_even</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span><span class="o">}</span> <span class="o">:</span> <span class="n">myIsEven</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">myIsEven</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">myIsEven</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>


<p>so now it suffices to prove these.</p>

<a name="188253488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188253488" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188253488">ROCKY KAMEN-RUBIO (Feb 14 2020 at 22:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Tactic.20Proof.20not.20Responding.2E.20Overflow.3F/near/188252371" title="#narrow/stream/113489-new-members/topic/Tactic.20Proof.20not.20Responding.2E.20Overflow.3F/near/188252371">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="261068">ROCKY KAMEN-RUBIO</span> <a href="#narrow/stream/113489-new-members/topic/Tactic.20Proof.20not.20Responding.2E.20Overflow.3F/near/188252149" title="#narrow/stream/113489-new-members/topic/Tactic.20Proof.20not.20Responding.2E.20Overflow.3F/near/188252149">said</a>:</p>
<blockquote>
<p>I was having trouble importing mathlib  so I thought I'd just define my own even/odd functions.</p>
</blockquote>
<p>That's fine, but you then also have to prove every theorem  about even and odd numbers which you need ;-)</p>
</blockquote>
<p>I see that now. Here I was trying to be all clever thinking I could just rewrite basic natural number definitions without importing any subsequent theorems.</p>

<a name="188253721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188253721" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188253721">ROCKY KAMEN-RUBIO (Feb 14 2020 at 22:31)</a>:</h4>
<p><span class="user-mention" data-user-id="214703">@Yury G. Kudryashov</span>  Doing it for a board of size (m,n) for odd m and n was one of my next goals. Can I just use quantifiers like that to iterate over all the elements of fin m? I was looking for some kind of for loop structure but it makes sense that this would be the lean-ier way of doing it.</p>

<a name="188253843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188253843" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188253843">Yury G. Kudryashov (Feb 14 2020 at 22:33)</a>:</h4>
<p><code>∀ i : fin n, ...</code> says exactly "for every element <code>i</code> of type <code>fin n</code> the following proposition holds".</p>

<a name="188332846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188332846" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188332846">Rocky Kamen-Rubio (Feb 16 2020 at 17:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="214703">Yury G. Kudryashov</span> <a href="#narrow/stream/113489-new-members/topic/Tactic.20Proof.20not.20Responding.2E.20Overflow.3F/near/188252567" title="#narrow/stream/113489-new-members/topic/Tactic.20Proof.20not.20Responding.2E.20Overflow.3F/near/188252567">said</a>:</p>
<blockquote>
<p>I'd prove this for any pair of odd numbers <code>(n, m)</code> instead of <code>(3, 3)</code>.  Then strategies will have the types <code>fin m → fin n → nat</code> and <code>fin n → fin m → nat</code>, respectively, and you can use <code>∀ i, (finset.univ.sum (f i)).even</code>.</p>
</blockquote>
<p><span class="user-mention" data-user-id="214703">@Yury G. Kudryashov</span>  I'm trying to implement this and I'm getting errors on finset.univ.sum. I've imported data.finset. Do I need to convert the function (StrategyA r) into a set, or tell lean to map it first? <a href="/user_uploads/3121/rwOy4RoV_YPc9xKFxrc0Fuct/Screen-Shot-2020-02-16-at-12.39.09-PM.png" target="_blank" title="Screen-Shot-2020-02-16-at-12.39.09-PM.png">Screen-Shot-2020-02-16-at-12.39.09-PM.png</a> <a href="/user_uploads/3121/_fqNAKz-ginWvakFiVJKOLLj/Screen-Shot-2020-02-16-at-12.39.04-PM.png" target="_blank" title="Screen-Shot-2020-02-16-at-12.39.04-PM.png">Screen-Shot-2020-02-16-at-12.39.04-PM.png</a> <a href="/user_uploads/3121/e86Ww34ryBeqVZiF6N8HuA3A/Screen-Shot-2020-02-16-at-12.38.56-PM.png" target="_blank" title="Screen-Shot-2020-02-16-at-12.38.56-PM.png">Screen-Shot-2020-02-16-at-12.38.56-PM.png</a> <a href="/user_uploads/3121/EJ29G9q0BpzOe7qWv8ha67CR/Screen-Shot-2020-02-16-at-12.38.49-PM.png" target="_blank" title="Screen-Shot-2020-02-16-at-12.38.49-PM.png">Screen-Shot-2020-02-16-at-12.38.49-PM.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/rwOy4RoV_YPc9xKFxrc0Fuct/Screen-Shot-2020-02-16-at-12.39.09-PM.png" target="_blank" title="Screen-Shot-2020-02-16-at-12.39.09-PM.png"><img src="/user_uploads/3121/rwOy4RoV_YPc9xKFxrc0Fuct/Screen-Shot-2020-02-16-at-12.39.09-PM.png"></a></div><div class="message_inline_image"><a href="/user_uploads/3121/_fqNAKz-ginWvakFiVJKOLLj/Screen-Shot-2020-02-16-at-12.39.04-PM.png" target="_blank" title="Screen-Shot-2020-02-16-at-12.39.04-PM.png"><img src="/user_uploads/3121/_fqNAKz-ginWvakFiVJKOLLj/Screen-Shot-2020-02-16-at-12.39.04-PM.png"></a></div><div class="message_inline_image"><a href="/user_uploads/3121/e86Ww34ryBeqVZiF6N8HuA3A/Screen-Shot-2020-02-16-at-12.38.56-PM.png" target="_blank" title="Screen-Shot-2020-02-16-at-12.38.56-PM.png"><img src="/user_uploads/3121/e86Ww34ryBeqVZiF6N8HuA3A/Screen-Shot-2020-02-16-at-12.38.56-PM.png"></a></div><div class="message_inline_image"><a href="/user_uploads/3121/EJ29G9q0BpzOe7qWv8ha67CR/Screen-Shot-2020-02-16-at-12.38.49-PM.png" target="_blank" title="Screen-Shot-2020-02-16-at-12.38.49-PM.png"><img src="/user_uploads/3121/EJ29G9q0BpzOe7qWv8ha67CR/Screen-Shot-2020-02-16-at-12.38.49-PM.png"></a></div>

<a name="188332953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188332953" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188332953">Bryan Gin-ge Chen (Feb 16 2020 at 17:44)</a>:</h4>
<p>Could you post copy+pastable code (or a link to a github gist containing such) so that we can reproduce your errors?</p>

<a name="188333263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188333263" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188333263">Yury G. Kudryashov (Feb 16 2020 at 17:55)</a>:</h4>
<p>Did you <code>import algebra.big_operators</code>?</p>

<a name="188333504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188333504" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188333504">Rocky Kamen-Rubio (Feb 16 2020 at 18:03)</a>:</h4>
<p>Just added that and I'm still getting the same errors.</p>

<a name="188334064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188334064" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188334064">Yury G. Kudryashov (Feb 16 2020 at 18:20)</a>:</h4>
<p>Please copy+paste the file from start to the first error.</p>

<a name="188334085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188334085" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188334085">Rocky Kamen-Rubio (Feb 16 2020 at 18:21)</a>:</h4>
<div class="codehilite"><pre><span></span>import init.data.nat.basic
import init.algebra.ring
import init.algebra.norm_num
import init
import tactic
import data.nat.parity
import data.finset
import algebra.big_operators
set_option class.instance_max_depth 15000000




def checkStrategymn {m n : nat} (strategyA : fin m → fin n → nat) (strategy B: fin n → fin m → nat) : Prop :=
∀ r : fin m, (finset.univ.sum (strategyA r)).even
</pre></div>

<a name="188334597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188334597" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188334597">Yury G. Kudryashov (Feb 16 2020 at 18:36)</a>:</h4>
<p>Compiles with no errors here.</p>

<a name="188334739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188334739" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188334739">Rocky Kamen-Rubio (Feb 16 2020 at 18:41)</a>:</h4>
<p>Weird... Any ideas?</p>

<a name="188334744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188334744" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188334744">Bryan Gin-ge Chen (Feb 16 2020 at 18:41)</a>:</h4>
<p>What version of mathlib are you using?</p>

<a name="188334872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188334872" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188334872">Bryan Gin-ge Chen (Feb 16 2020 at 18:45)</a>:</h4>
<p>I just tried with an older version of mathlib and you might need to try adding <code>import data.fintype</code>. By the way, I think I said this before, but you can delete everything that starts with <code>import init</code> since all of that is imported automatically by Lean.</p>

<a name="188334994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188334994" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188334994">Rocky Kamen-Rubio (Feb 16 2020 at 18:49)</a>:</h4>
<p>Ok I added <code>import data.fintype</code> and that seems to have resolved the issue. That's interesting the issue would be mathlib being out of date because I only downloaded it about two weeks ago. Was there an update since then? Maybe I downloaded it from the wrong source by mistake...</p>

<a name="188335054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188335054" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188335054">Bryan Gin-ge Chen (Feb 16 2020 at 18:51)</a>:</h4>
<p>From playing around with commenting / uncommenting imports, it looks like something in <code>import tactic</code> now has <code>data.fintype</code> as a dependency, whereas it didn't previously.</p>

<a name="188335126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188335126" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188335126">Bryan Gin-ge Chen (Feb 16 2020 at 18:53)</a>:</h4>
<p>Hah, I guess I was the culprit: see <a href="https://github.com/leanprover-community/mathlib/pull/1962/files#diff-73f60479a7373d7694e4543439a5cb5fR36" target="_blank" title="https://github.com/leanprover-community/mathlib/pull/1962/files#diff-73f60479a7373d7694e4543439a5cb5fR36">PR #1962</a>. I added <code>fin_cases</code> to the imports in <code>tactic.default</code>, and that <a href="https://github.com/leanprover-community/mathlib/blob/master/src/tactic/fin_cases.lean#L10" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/src/tactic/fin_cases.lean#L10">indeed depends on <code>data.fintype</code></a>.</p>

<a name="188335131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188335131" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188335131">Bryan Gin-ge Chen (Feb 16 2020 at 18:53)</a>:</h4>
<p>mathlib is a continuously moving target, for better or worse...</p>

<a name="188338108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188338108" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188338108">Kevin Buzzard (Feb 16 2020 at 20:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260106">Rocky Kamen-Rubio</span> <a href="#narrow/stream/113489-new-members/topic/Tactic.20Proof.20not.20Responding.2E.20Overflow.3F/near/188334994" title="#narrow/stream/113489-new-members/topic/Tactic.20Proof.20not.20Responding.2E.20Overflow.3F/near/188334994">said</a>:</p>
<blockquote>
<p>Was there an update since then?</p>
</blockquote>
<p>There are updates most days! You can follow <a class="stream" data-stream-id="116290" href="/#narrow/stream/116290-rss">#rss</a> if you want to see the progression of the library.</p>

<a name="188338532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188338532" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188338532">Kevin Buzzard (Feb 16 2020 at 20:40)</a>:</h4>
<p>In fact you might want to check you're on Lean version 3.5.1 or you'll be missing the new goodies</p>

<a name="188339354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188339354" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188339354">Rocky Kamen-Rubio (Feb 16 2020 at 21:04)</a>:</h4>
<p>Fascinating. This actually explains a lot...</p>

<a name="188353379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188353379" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188353379">Rocky Kamen-Rubio (Feb 17 2020 at 05:14)</a>:</h4>
<p>Thank you all for you amazing support! Another potentially basic question. How do I get rid of a universal quantifier when there is a negation in front of it? It seems like generally one would use <code>intro</code> and then just prove the statement generally. If there's a negation though, this seems to not work, and I get stuck with a proposition with a quantifier that I can't use with <code>rw</code> or other common tactics.</p>

<a name="188353527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188353527" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188353527">Bryan Gin-ge Chen (Feb 17 2020 at 05:19)</a>:</h4>
<p>Try <code>rw</code> or <code>simp</code> with <code>not_forall</code>. You might need to <code>open_locale classical</code> before to work with classical logic if you aren't already.</p>

<a name="188353532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188353532" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188353532">Scott Morrison (Feb 17 2020 at 05:19)</a>:</h4>
<p>(we really need <code>rw_hint</code>... it shouldn't be hard)</p>

<a name="188353741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188353741" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188353741">Mario Carneiro (Feb 17 2020 at 05:27)</a>:</h4>
<p>You probably don't need to use classical for this. Just prove a contradiction from the forall assumption, presumably by constructing a counterexample</p>

<a name="188353839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188353839" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188353839">Rocky Kamen-Rubio (Feb 17 2020 at 05:30)</a>:</h4>
<p>I tried doing both <code>rw not_forall at h,</code> and <code>simp only [not_forall] at h,</code> but neither was successful. Here's a more specific minimal example of the type of situation I'm struggling with.  </p>
<div class="codehilite"><pre><span></span>theorem myTheorem : ¬ (∀ x : nat, x = 2) :=
begin
intro h,
end
</pre></div>


<p>Edit: I've already done <code>open_locale classical</code> earlier in the file, so I assume that's not the issue. I feel like there's something about the way lean handles quantifiers that I'm not understanding (I remember the book talking about them being somehow equivalent to Pi functions, but the example they gave was pretty different from this)</p>

<a name="188353963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188353963" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188353963">Yury G. Kudryashov (Feb 17 2020 at 05:34)</a>:</h4>
<p>After <code>intro h</code> you no longer have a negation in front of <code>∀</code>. You can try <code>replace h := h 1, norm_num at h</code>.</p>

<a name="188354589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188354589" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188354589">Scott Morrison (Feb 17 2020 at 05:56)</a>:</h4>
<p>Note that <code>intro h</code> here is doing exactly what <code>by_contradiction h</code> would do, which may help understand what's happening.</p>

<a name="188360229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188360229" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188360229">Kevin Buzzard (Feb 17 2020 at 08:31)</a>:</h4>
<p>I don't really understand the question. Does <code>push_neg</code> help? This moves negations inside quantifiers</p>

<a name="188360281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188360281" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188360281">Kevin Buzzard (Feb 17 2020 at 08:32)</a>:</h4>
<p>So it will turn not forall into exists not</p>

<a name="188363730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188363730" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188363730">Patrick Massot (Feb 17 2020 at 09:34)</a>:</h4>
<p>Rocky, your question is a bit hard to answer without knowing whether you want a low-level answer or learn how to crush such a goal. You can still have a look at the following variations.</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">example</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ_ne_zero</span> <span class="mi">1</span> <span class="o">(</span><span class="n">h</span> <span class="mi">0</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>

<span class="kn">example</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ_ne_zero</span> <span class="mi">1</span> <span class="o">(</span><span class="n">h</span> <span class="mi">0</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">example</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">specialize</span> <span class="n">h</span> <span class="mi">0</span><span class="o">,</span>
  <span class="n">tauto</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">example</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">push_neg</span><span class="o">,</span>
  <span class="n">use</span> <span class="mi">0</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>

<a name="188399196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188399196" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188399196">Rocky Kamen-Rubio (Feb 17 2020 at 18:41)</a>:</h4>
<p>Thank you all for your replies! This has been very useful. Here are the two more complex cases I've been working with where I have trouble negotiating the universal quantifiers. I copied my previous post explaining what I'm trying to prove below.  I'm having trouble producing a counterexample, and feel like it would be easier to use predicate logic to reduce the expression to something false, though I'm not totally sure how to best handle expressions like <code>finset.univ.sum</code> in cases like this. Any thoughts would be appreciate! </p>
<div class="codehilite"><pre><span></span><span class="n">open_locale</span> <span class="n">classical</span>
<span class="n">def</span> <span class="n">checkStrategyMN</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">strategyA</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">strategyB</span><span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">c</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="o">((</span><span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="n">strategyA</span> <span class="n">r</span><span class="o">))</span><span class="bp">.</span><span class="n">even</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">¬</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="n">strategyB</span> <span class="n">c</span><span class="o">))</span><span class="bp">.</span><span class="n">even</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">((</span><span class="n">strategyA</span> <span class="n">r</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">strategyB</span> <span class="n">c</span> <span class="n">r</span><span class="o">))))</span>

<span class="kn">theorem</span> <span class="n">noStrategyMN</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">strategyA</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">strategyB</span><span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="o">((</span><span class="bp">¬</span> <span class="n">m</span><span class="bp">.</span><span class="n">even</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">¬</span> <span class="n">n</span><span class="bp">.</span><span class="n">even</span><span class="o">))</span> <span class="bp">→</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">checkStrategyMN</span> <span class="n">strategyA</span> <span class="n">strategyB</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">rw</span> <span class="n">checkStrategyMN</span><span class="o">,</span>
<span class="n">intros</span> <span class="n">h1</span><span class="o">,</span>
<span class="n">finish</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">board</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">strategyA</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">strategyB</span><span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span> <span class="o">:=</span> <span class="n">strategyA</span> <span class="c1">--woah man...these representations are THE SAME!!!! (function that returns a vector and a matrix)</span>

<span class="n">def</span> <span class="n">consistent</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">strategyA</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">strategyB</span><span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="o">:=</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="o">(</span><span class="n">strategyA</span> <span class="n">r</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">strategyB</span> <span class="n">c</span> <span class="n">r</span><span class="o">)</span>

<span class="n">def</span> <span class="n">sampleA</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">board</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span> <span class="o">:=</span> <span class="n">board</span>

<span class="n">def</span> <span class="n">sampleB</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">board</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">nat</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span><span class="o">),</span> <span class="n">board</span> <span class="n">m</span> <span class="n">n</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">sampleA</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">sampleB</span>

<span class="kn">lemma</span> <span class="n">board_equiv_strategy</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">strategyA</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">strategyB</span><span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span>
<span class="o">(</span><span class="n">consistent</span> <span class="n">strategyA</span> <span class="n">strategyB</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">strategyA</span> <span class="bp">=</span> <span class="o">((</span><span class="n">sampleA</span> <span class="o">(</span><span class="n">board</span> <span class="n">strategyA</span> <span class="n">strategyB</span><span class="o">)))</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">strategyB</span> <span class="bp">=</span> <span class="o">(</span><span class="n">sampleB</span> <span class="o">(</span><span class="n">board</span> <span class="n">strategyA</span> <span class="n">strategyB</span><span class="o">))))</span>
<span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
<span class="n">split</span><span class="o">,</span>

<span class="n">rw</span> <span class="n">sampleA</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">board</span><span class="o">,</span>

<span class="n">rw</span> <span class="n">consistent</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">sampleB</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">board</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">h</span><span class="o">,</span>
<span class="kn">end</span>

<span class="n">def</span> <span class="n">each_row_sum_even</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">board</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span><span class="o">),</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="n">sampleA</span> <span class="n">board</span> <span class="n">r</span><span class="o">))</span><span class="bp">.</span><span class="n">even</span>

<span class="n">def</span> <span class="n">each_col_sum_odd</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">board</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="bp">¬</span><span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="n">sampleB</span> <span class="n">board</span> <span class="n">c</span><span class="o">))</span><span class="bp">.</span><span class="n">even</span>

<span class="n">def</span> <span class="n">even_strategy</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">strategyA</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">c</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="o">((</span><span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="n">strategyA</span> <span class="n">r</span><span class="o">))</span><span class="bp">.</span><span class="n">even</span><span class="o">)))</span>

<span class="n">def</span> <span class="n">odd_strategy</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">strategyB</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">c</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="bp">¬</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="n">strategyB</span> <span class="n">c</span><span class="o">))</span><span class="bp">.</span><span class="n">even</span><span class="o">)))</span>

<span class="kn">lemma</span> <span class="n">even_strategy_implies_even_rows</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">strategyA</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">strategyB</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span>
<span class="o">:</span> <span class="o">(</span><span class="n">even_strategy</span> <span class="n">strategyA</span><span class="o">)</span> <span class="bp">→</span> <span class="n">each_row_sum_even</span> <span class="o">(</span><span class="n">board</span> <span class="n">strategyA</span> <span class="n">strategyB</span><span class="o">)</span>
<span class="o">:=</span>
<span class="k">begin</span>
<span class="n">sorry</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">odd_strategy_implies_odd_cols</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">strategyA</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">strategyB</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span>
<span class="o">:</span> <span class="o">(</span><span class="n">odd_strategy</span> <span class="n">strategyB</span><span class="o">)</span> <span class="bp">→</span> <span class="n">each_col_sum_odd</span> <span class="o">(</span><span class="n">board</span> <span class="n">strategyA</span> <span class="n">strategyB</span><span class="o">)</span>
<span class="o">:=</span>
<span class="k">begin</span>
<span class="n">sorry</span>
<span class="kn">end</span>

<span class="n">def</span> <span class="n">row_sum</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">board</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">:=</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="n">sampleA</span> <span class="n">board</span><span class="o">))</span>

<span class="n">def</span> <span class="n">col_sum</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">board</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">:=</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="n">sampleB</span> <span class="n">board</span><span class="o">))</span>

<span class="kn">lemma</span> <span class="n">row_sum_eq_col_sum</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">board</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">row_sum</span> <span class="n">board</span> <span class="bp">=</span> <span class="n">col_sum</span> <span class="n">board</span>
<span class="o">:=</span>
<span class="k">begin</span>
<span class="n">sorry</span>
<span class="kn">end</span>

<span class="kn">theorem</span> <span class="n">noStrategyMN2</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">strategyA</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">strategyB</span><span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">((</span><span class="n">consistent</span> <span class="n">strategyA</span> <span class="n">strategyB</span><span class="o">)</span> <span class="bp">∧</span>  <span class="o">(</span><span class="n">even_strategy</span> <span class="n">strategyA</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">odd_strategy</span> <span class="n">strategyB</span><span class="o">))</span>
<span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">c</span> <span class="n">y</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">y</span> <span class="k">with</span> <span class="n">even</span> <span class="n">odd</span><span class="o">,</span>
<span class="k">have</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">even_strategy_implies_even_rows</span> <span class="n">strategyA</span> <span class="n">strategyB</span> <span class="n">even</span><span class="o">,</span>
<span class="k">have</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">odd_strategy_implies_odd_cols</span> <span class="n">strategyA</span> <span class="n">strategyB</span> <span class="n">odd</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p><strong>The Game:</strong> Alice is assigned a row and Bob is assigned a column of a <del>3x3</del> mxn board for odd m and n. Neither knows the assignment of the other. The task is for each of them to color their respective row/column with Green and Red tiles (aka 1s and 0s) while meeting the following criteria:</p>
<ol>
<li>Rows must have an even number of Green tiles</li>
<li>Columns must have an odd number of Green tiles</li>
<li>The two colorings must be consistent - they must agree on the color of the shared tile</li>
<li>They can plan a strategy beforehand but can't communicate after each gets their respective assignment.</li>
</ol>
<p>My goal is to prove that there is no guaranteed successful strategy.</p>
<p><strong>Lean Proof 1</strong>:  We can think of a strategy as two maps (<code>strategyA</code> and <code>strategyB</code>) one from a row number to a map from column number to element of that row, the other from a column number to a map from row number to element in that column. <code>checkStrategy</code> checks that a given strategy satisfies the conditions listed.</p>
<p><strong>Lean Proof 2</strong>:  Since Alice and Bob must agree on the value of the intersection of their respective row/column, and the location of this intersection is arbitrary, we can think of their strategies as sampling from a single tiled <del>3x3</del> m x n board. Summing the values in the rows of this single board we get an even number, but summing the values in the columns we get an odd number. The sums of the values in all the tiles should be the same whether we do it by rows or columns, so we get a contradiction. To do this in lean, I start by defining the equivalent board, and what sampleA and sampleB would be from that board. Next, I am trying to prove board_equiv: the statement that sampling from this board is equivalent to both strategies if all the conditions are met. Next I show that the rows of the board must have even sums and the cols have odd sums, if the original strategies have even and odd sums. From here, I'm hoping showing the contradiction shouldn't be too hard, but I haven't gotten that far yet.</p>

<a name="188402742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188402742" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188402742">Yury G. Kudryashov (Feb 17 2020 at 19:47)</a>:</h4>
<p>Please add "lean" after each opening of a code block. This way you'll have syntax highlighting.</p>

<a name="188403961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactic%20Proof%20not%20Responding.%20Overflow%3F/near/188403961" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17610TacticProofnotRespondingOverflow.html#188403961">Rocky Kamen-Rubio (Feb 17 2020 at 20:09)</a>:</h4>
<p>Forgot about that, thanks for the reminder!</p>


{% endraw %}

{% include archive_update.html %}