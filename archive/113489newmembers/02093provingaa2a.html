---
layout: archive
title: Lean Prover Zulip Chat Archive 
permalink: archive/113489newmembers/02093provingaa2a.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/02093provingaa2a.html">proving a + a = 2* a</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="154909221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/proving%20a%20%2B%20a%20%3D%202%2A%20a/near/154909221" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/02093provingaa2a.html#154909221">Atze van der Ploeg (Jan 11 2019 at 10:53)</a>:</h4>
<p>I'm trying to prove the shocking lemma ∀ n : ℕ, n + n = 2*n , how do i tell lean to unfold the definition of *?</p>

<a name="154909512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/proving%20a%20%2B%20a%20%3D%202%2A%20a/near/154909512" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/02093provingaa2a.html#154909512">Kenny Lau (Jan 11 2019 at 10:59)</a>:</h4>
<p>you don't; you just tell Lean what you want it to unfold to</p>

<a name="154909517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/proving%20a%20%2B%20a%20%3D%202%2A%20a/near/154909517" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/02093provingaa2a.html#154909517">Chris Hughes (Jan 11 2019 at 10:59)</a>:</h4>
<p>There's a lemma <code>nat.mul_succ</code></p>

<a name="154909526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/proving%20a%20%2B%20a%20%3D%202%2A%20a/near/154909526" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/02093provingaa2a.html#154909526">Rob Lewis (Jan 11 2019 at 11:00)</a>:</h4>
<p>You can use <code>simp only [(*)]</code>. This will unfold the notation, then you'll have to deal with the definition <code>nat.mul</code>.</p>

<a name="154909570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/proving%20a%20%2B%20a%20%3D%202%2A%20a/near/154909570" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/02093provingaa2a.html#154909570">Chris Hughes (Jan 11 2019 at 11:00)</a>:</h4>
<p>Sorry, <code>nat.succ_mul</code></p>

<a name="154909583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/proving%20a%20%2B%20a%20%3D%202%2A%20a/near/154909583" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/02093provingaa2a.html#154909583">Rob Lewis (Jan 11 2019 at 11:00)</a>:</h4>
<p>You can unfold that with the same method, or <code>unfold nat.mul</code>, but since it's defined by recursion on <code>n</code>, you'll have to use induction first.</p>

<a name="154909621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/proving%20a%20%2B%20a%20%3D%202%2A%20a/near/154909621" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/02093provingaa2a.html#154909621">Chris Hughes (Jan 11 2019 at 11:01)</a>:</h4>
<p>You can't actually unfold multiplication in this scenario, since it's defined by recursion on the second argument.</p>

<a name="154909625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/proving%20a%20%2B%20a%20%3D%202%2A%20a/near/154909625" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/02093provingaa2a.html#154909625">Kenny Lau (Jan 11 2019 at 11:01)</a>:</h4>
<p>well I imagined he would do induction on <code>n</code></p>

<a name="154912689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/proving%20a%20%2B%20a%20%3D%202%2A%20a/near/154912689" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/02093provingaa2a.html#154912689">Atze van der Ploeg (Jan 11 2019 at 12:05)</a>:</h4>
<p>Thanks, nat.succ_mul works fine, or using mul_comm but this requires me to know that nat.mul is defined by recursively on the second argument.</p>

<a name="154913474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/proving%20a%20%2B%20a%20%3D%202%2A%20a/near/154913474" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/02093provingaa2a.html#154913474">Kevin Buzzard (Jan 11 2019 at 12:23)</a>:</h4>
<p>You can just use the 'ring' tactic if you don't care about what the low level proof looks like</p>

<a name="154936758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/proving%20a%20%2B%20a%20%3D%202%2A%20a/near/154936758" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/02093provingaa2a.html#154936758">Mark Dickinson (Jan 11 2019 at 18:40)</a>:</h4>
<p>There's also <code>two_mul</code> in the standard library:</p>
<div class="codehilite"><pre><span></span><span class="n">two_mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">}</span> <span class="o">[</span><span class="bp">_</span><span class="n">inst_1</span> <span class="o">:</span> <span class="n">semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">n</span>
</pre></div>


{% endraw %}
