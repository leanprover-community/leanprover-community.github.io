---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html">Simplifying Prop with Known False Statements</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="187848002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/187848002" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#187848002">Rocky Kamen-Rubio (Feb 10 2020 at 19:11)</a>:</h4>
<p>I have a very long Prop that consists mostly of AND/OR statements and false equalities like 1 = 2. Is there a faster way to simplify it than going through it with cases, split, left/right? Is there a built-in function that can scan through a long Prop and replace false equalities with ff, and another than can recognize that A AND ff is equivalent to ff, or that A OR ff is equivalent to A?</p>

<a name="187848098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/187848098" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#187848098">Chris Hughes (Feb 10 2020 at 19:12)</a>:</h4>
<p><code>norm_num</code> would probably solve that goal.</p>

<a name="187849336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/187849336" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#187849336">Cerek Hillen (he) (W2'20) (Feb 10 2020 at 19:24)</a>:</h4>
<p>And for context, if I'm not mistaken, <code>norm_num</code> means the tactic <code>norm_num</code> provided by <a href="https://github.com/leanprover-community/mathlib/" target="_blank" title="https://github.com/leanprover-community/mathlib/">mathlib</a></p>

<a name="188423065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188423065" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188423065">Rocky Kamen-Rubio (Feb 18 2020 at 04:30)</a>:</h4>
<p>I'm implementing matricies as types <code>fin m →  fin n →  nat </code> and want to sum all the elements in each row, and then sum all those values. Is there an easy way to do this using <code>finset.univ.sum</code>? I've been able to do it with 1D arrays of type <code>fin m →  nat</code> so I feel like there should be a clever lambda solution for the 2D case. I committed to this implementation before I realized mathlib has a matrix type, but it's implemented the same way, so it might not be worth the hassle of switching.</p>

<a name="188433115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188433115" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188433115">Kevin Buzzard (Feb 18 2020 at 08:57)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">matrix_sum</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="err">$</span> <span class="n">M</span> <span class="n">i</span>
</pre></div>


<p>Of course if you find yourself asking five more questions like this, and for some of them the answer is "we did it already with matrices in mathlib", then you might want to take that as an indication that you should switch. Remember -- if you define it yourself, you've got to prove all the lemmas about it yourself.</p>

<a name="188433175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188433175" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188433175">Kevin Buzzard (Feb 18 2020 at 08:58)</a>:</h4>
<p>PS I can't guarantee that I summed the elements in the rows rather than the columns -- this depends on your mental model.</p>

<a name="188462495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188462495" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188462495">Rocky Kamen-Rubio (Feb 18 2020 at 15:54)</a>:</h4>
<p>Thank you! That's a good point that maybe this is a sign that I should switch to the mathlib representation. My other motivation for not switching was that eventually I want to start putting noncommutative elements (specifically entangled quantum states) into the matrix, so it would matter whether I'm ordering it by rows or columns. If we have <code>(M : fin m → fin n → ℕ )</code>, I guess I could also just transpose it and do <code>matrix_sum </code> on the transpose. This way we get both cases, and all I need is to show whether they're equal or not.</p>

<a name="188465633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188465633" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188465633">Rocky Kamen-Rubio (Feb 18 2020 at 16:26)</a>:</h4>
<p>Ok I tried doing this and got to this point. I feel like again there's probably an easy tactic to finish this off that I'm not seeing. Maybe switching to mathlib's matrix representation would make this easier, but part of me still wants to hold out on switching because I'm not going to be multiplying or adding  these matrices, just summing their elements in specific ways, and I want as much control over that as possible.</p>
<div class="codehilite"><pre><span></span><span class="n">board</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="err">⊢</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span><span class="o">),</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span> <span class="o">(</span><span class="n">board</span> <span class="n">i</span><span class="o">))</span> <span class="bp">=</span>
    <span class="n">finset</span><span class="bp">.</span><span class="n">sum</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span><span class="o">),</span> <span class="n">board</span> <span class="n">m</span> <span class="n">i</span><span class="o">))</span>
</pre></div>

<a name="188465682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188465682" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188465682">Reid Barton (Feb 18 2020 at 16:27)</a>:</h4>
<p>This is "reverse the order of summation"?</p>

<a name="188465694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188465694" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188465694">Kevin Buzzard (Feb 18 2020 at 16:27)</a>:</h4>
<p>Right</p>

<a name="188465745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188465745" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188465745">Reid Barton (Feb 18 2020 at 16:27)</a>:</h4>
<p>It definitely won't be a tactic, it probably is a theorem that already exists.</p>

<a name="188465819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188465819" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188465819">Reid Barton (Feb 18 2020 at 16:28)</a>:</h4>
<p>I think it's whatever the to_additive of <code>prod_product</code> is</p>

<a name="188465972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188465972" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188465972">Reid Barton (Feb 18 2020 at 16:29)</a>:</h4>
<p>well, combined with more stuff. How can this not exist already?</p>

<a name="188465975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188465975" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188465975">Kevin Buzzard (Feb 18 2020 at 16:29)</a>:</h4>
<p>aah, remember the old days before automation where you could just read off the additive name in the library...</p>

<a name="188466069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188466069" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188466069">Kevin Buzzard (Feb 18 2020 at 16:30)</a>:</h4>
<p>Oh yeah so we're in exactly the same situation as in the other thread.</p>

<a name="188466072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188466072" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188466072">Reid Barton (Feb 18 2020 at 16:30)</a>:</h4>
<p>oh, <code>prod_comm</code></p>

<a name="188466119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188466119" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188466119">Reid Barton (Feb 18 2020 at 16:30)</a>:</h4>
<p>this should probably have a comment with things like "fubini" and maybe "prod_prod"</p>

<a name="188466164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188466164" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188466164">Kevin Buzzard (Feb 18 2020 at 16:31)</a>:</h4>
<p><a href="#narrow/stream/113489-new-members/topic/spheres/near/188451346" title="#narrow/stream/113489-new-members/topic/spheres/near/188451346">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/spheres/near/188451346</a> also ideally needs to switch from <code>finset.sum finset.univ (fin n)</code> to <code>finset.sum finset.range n</code></p>

<a name="188466293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188466293" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188466293">Kevin Buzzard (Feb 18 2020 at 16:32)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">sum_univ_fin_eq_sum_range</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">finset</span><span class="bp">.</span><span class="n">sum</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span> <span class="n">f</span> <span class="bp">=</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">range</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="k">if</span> <span class="n">hi</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="k">then</span> <span class="n">f</span> <span class="bp">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hi</span><span class="bp">⟩</span> <span class="k">else</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>

<a name="188466328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188466328" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188466328">Kevin Buzzard (Feb 18 2020 at 16:32)</a>:</h4>
<p>I don't like the look of induction on n</p>

<a name="188467516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188467516" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188467516">Kevin Buzzard (Feb 18 2020 at 16:44)</a>:</h4>
<p>What I'm saying is that <code>fin n</code> doesn't have type <code>finset ℕ</code></p>

<a name="188471000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188471000" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188471000">Kevin Buzzard (Feb 18 2020 at 17:20)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">sum_univ_fin_eq_sum_range</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">finset</span><span class="bp">.</span><span class="n">sum</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span> <span class="n">f</span> <span class="bp">=</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">range</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="k">if</span> <span class="n">hi</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="k">then</span> <span class="n">f</span> <span class="bp">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hi</span><span class="bp">⟩</span> <span class="k">else</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">set</span> <span class="n">F</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="k">if</span> <span class="n">hi</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="k">then</span> <span class="n">f</span> <span class="bp">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hi</span><span class="bp">⟩</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">with</span> <span class="n">hF</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="n">F</span> <span class="o">(</span><span class="n">i</span><span class="bp">.</span><span class="n">val</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">ext</span> <span class="n">i</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">hF</span><span class="o">,</span>
    <span class="k">show</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">dite</span> <span class="o">(</span><span class="n">i</span><span class="bp">.</span><span class="n">val</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">hi</span> <span class="o">:</span> <span class="n">i</span><span class="bp">.</span><span class="n">val</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">),</span> <span class="n">f</span> <span class="bp">⟨</span><span class="n">i</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span> <span class="n">hi</span><span class="bp">⟩</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">hi</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">i</span><span class="bp">.</span><span class="n">val</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">),</span> <span class="mi">0</span><span class="o">),</span>
    <span class="n">rw</span> <span class="n">dif_pos</span> <span class="n">i</span><span class="bp">.</span><span class="n">is_lt</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">i</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="n">rw</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">rw</span> <span class="err">←</span><span class="n">finset</span><span class="bp">.</span><span class="n">sum_image</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">congr&#39;</span><span class="o">,</span>
    <span class="c1">-- ⊢ finset.image (λ (x : fin n), x.val) finset.univ = finset.range n</span>
    <span class="n">ext</span> <span class="n">j</span><span class="o">,</span> <span class="c1">-- sigh</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">finset</span><span class="bp">.</span><span class="n">mem_range</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">mem_image</span><span class="o">],</span>
    <span class="n">split</span><span class="o">,</span>
      <span class="n">rintro</span> <span class="bp">⟨⟨</span><span class="n">j</span><span class="o">,</span><span class="n">hj</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">hj</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">hj</span><span class="o">,</span>
    <span class="n">use</span> <span class="bp">⟨</span><span class="n">j</span><span class="o">,</span> <span class="n">hj</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span> <span class="n">apply</span> <span class="n">finset</span><span class="bp">.</span><span class="n">mem_univ</span><span class="o">,</span> <span class="n">refl</span>
  <span class="o">},</span>
  <span class="n">intros</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">fin</span><span class="bp">.</span><span class="n">eq_of_veq</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>

<a name="188477897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188477897" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188477897">Rocky Kamen-Rubio (Feb 18 2020 at 18:33)</a>:</h4>
<p>Amazing, thank you! I'm having trouble getting this into a form that I can use to finish my goal state though. I understand conceptually why it works, but the usual tactics like <code>rw</code>  <code>apply</code> etc don't seem to be working here (even though mathematically it seems like that's what I'm doing). I've had a similar issue come up as well when I got to the following tactic and goals states. I feel like I'm missing something potentially simple and obvious.</p>
<div class="codehilite"><pre><span></span><span class="mi">1</span> <span class="n">goal</span>
<span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span>
<span class="n">strategyA</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">,</span>
<span class="n">strategyB</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="n">strategyA</span> <span class="n">r</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">strategyB</span> <span class="n">c</span> <span class="n">r</span>
<span class="err">⊢</span> <span class="n">strategyB</span> <span class="bp">=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span><span class="o">),</span> <span class="n">strategyA</span> <span class="n">m</span> <span class="n">n</span>
</pre></div>

<a name="188477990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188477990" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188477990">Kevin Buzzard (Feb 18 2020 at 18:34)</a>:</h4>
<p><code>ext</code></p>

<a name="188478041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188478041" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188478041">Kevin Buzzard (Feb 18 2020 at 18:34)</a>:</h4>
<p>You need to check that two functions are equal iff they agree everywhere. In term mode this is <code>funext</code> and in tactic mode it's <code>ext i</code> (or perhaps <code>ext c r</code> in your case)</p>

<a name="188478099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188478099" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188478099">Kevin Buzzard (Feb 18 2020 at 18:35)</a>:</h4>
<p>"Extensionality" is the general principle that two objects are equal if and only if they're made from equal things. I think it's one of those things which computer scientists sometimes make a fuss about, it might be an axiom or something.</p>

<a name="188478178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188478178" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188478178">Kevin Buzzard (Feb 18 2020 at 18:36)</a>:</h4>
<p>It results from a lack of understanding of mathematical equality ;-)</p>

<a name="188479304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188479304" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188479304">Rocky Kamen-Rubio (Feb 18 2020 at 18:48)</a>:</h4>
<p>Fascinating. So lean doesn't automatically know that two objects made of equal parts are equal? I guess that makes sense but something feels a little absurd about that... Like I'm telling lean that instead of this equality holding for every element of a set, I'm telling it that it holds for a general element of a set, and it recognizes that as an equality but not the former?</p>
<p>Either way, it worked for the more recent goal state I posted but it doesn't seem to be working for the "reverse order of summation" goal state. I'm getting the following error</p>
<p><a href="/user_uploads/3121/6PRB-IbCr_wcTevp4USNqaTe/Screen-Shot-2020-02-18-at-1.44.34-PM.png" target="_blank" title="Screen-Shot-2020-02-18-at-1.44.34-PM.png">Screen-Shot-2020-02-18-at-1.44.34-PM.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/6PRB-IbCr_wcTevp4USNqaTe/Screen-Shot-2020-02-18-at-1.44.34-PM.png" target="_blank" title="Screen-Shot-2020-02-18-at-1.44.34-PM.png"><img src="/user_uploads/3121/6PRB-IbCr_wcTevp4USNqaTe/Screen-Shot-2020-02-18-at-1.44.34-PM.png"></a></div>

<a name="188479385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188479385" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188479385">Bryan Gin-ge Chen (Feb 18 2020 at 18:49)</a>:</h4>
<p>There are a lot errors like that in the docstrings; I'm not sure what the precise cause is but they shouldn't affect the validity of the actual Lean code.</p>

<a name="188479508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188479508" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188479508">Patrick Massot (Feb 18 2020 at 18:51)</a>:</h4>
<p>Rocky: saying that two functions are equal if they take the same value when evaluated on the same input is absurd from a computer science point of view. For instance it completely disregard execution time or memory consumption for functions that can be actually run.</p>

<a name="188479517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188479517" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188479517">Kevin Buzzard (Feb 18 2020 at 18:51)</a>:</h4>
<p>The error in the docstring is irrelevant, that's just some parser issue.</p>

<a name="188479656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188479656" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188479656">Kevin Buzzard (Feb 18 2020 at 18:53)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">strategyA</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">strategyB</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="n">strategyA</span> <span class="n">r</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">strategyB</span> <span class="n">c</span> <span class="n">r</span><span class="o">)</span>
<span class="o">:</span> <span class="n">strategyB</span> <span class="bp">=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span><span class="o">),</span> <span class="n">strategyA</span> <span class="n">m</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">ext</span> <span class="n">c</span> <span class="n">r</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">h</span>
<span class="kn">end</span>
</pre></div>


<p>Oh -- this is the one you can do? <code>ext</code> only works if the goal is of the form <code>f = g</code> where <code>f</code> and <code>g</code> are, say, functions or sets.</p>

<a name="188480326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188480326" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188480326">Rocky Kamen-Rubio (Feb 18 2020 at 19:00)</a>:</h4>
<p>Yeah I got that one working fine. It's this one that's been difficult for me. Here's my attempt so far that gives me the error message I linked to in my previous post.</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">row_sum_eq_col_sum</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">board</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">row_sum</span> <span class="n">board</span> <span class="bp">=</span> <span class="n">col_sum</span> <span class="n">board</span>
<span class="o">:=</span>
<span class="k">begin</span>
<span class="n">rw</span> <span class="n">row_sum</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">col_sum</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">matrix_sum</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">matrix_sum</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">sampleB</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">sampleA</span><span class="o">,</span>
<span class="n">simp</span><span class="o">,</span>
<span class="n">ext</span> <span class="n">c</span> <span class="n">r</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p>Edit: sorry, forgot I haven't linked to how row_sum or col_sum are defined. Might be easier just to look at my final tactic state. <a href="user_uploads/3121/ICOpPkjP80M7HYreUnjxRAHq/Screen-Shot-2020-02-18-at-2.03.20-PM.png" target="_blank" title="user_uploads/3121/ICOpPkjP80M7HYreUnjxRAHq/Screen-Shot-2020-02-18-at-2.03.20-PM.png">Screen-Shot-2020-02-18-at-2.03.20-PM.png</a></p>
<div class="message_inline_image"><a href="user_uploads/3121/ICOpPkjP80M7HYreUnjxRAHq/Screen-Shot-2020-02-18-at-2.03.20-PM.png" target="_blank" title="Screen-Shot-2020-02-18-at-2.03.20-PM.png"><img src="user_uploads/3121/ICOpPkjP80M7HYreUnjxRAHq/Screen-Shot-2020-02-18-at-2.03.20-PM.png"></a></div>

<a name="188480420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188480420" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188480420">Rocky Kamen-Rubio (Feb 18 2020 at 19:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/113489-new-members/topic/(no.20topic)/near/188479508" title="#narrow/stream/113489-new-members/topic/(no.20topic)/near/188479508">said</a>:</p>
<blockquote>
<p>Rocky: saying that two functions are equal if they take the same value when evaluated on the same input is absurd from a computer science point of view. For instance it completely disregard execution time or memory consumption for functions that can be actually run.</p>
</blockquote>
<p>That's a good point - I hadn't though about functions different in memory use or runtime. I guess I still haven't developed a good intuition for how lean thinks about mathematical objects.</p>

<a name="188481027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188481027" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188481027">Patrick Massot (Feb 18 2020 at 19:08)</a>:</h4>
<p>Lean supports both ways of thinking about function, without making a fuss. It simply records whether you used mathematics way or not.</p>

<a name="188481275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188481275" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188481275">Kevin Buzzard (Feb 18 2020 at 19:11)</a>:</h4>
<p>you need to rewrite <code>h</code> a lot and then use <code>finset.sum_comm</code></p>

<a name="188481351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188481351" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188481351">Kevin Buzzard (Feb 18 2020 at 19:12)</a>:</h4>
<p>Your goal is the equality of two natural numbers so you can't use <code>ext</code> here.</p>

<a name="188481404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188481404" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188481404">Kevin Buzzard (Feb 18 2020 at 19:12)</a>:</h4>
<p>actually maybe just <code>finset.sum_comm</code> will work directly</p>

<a name="188481740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188481740" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188481740">Kevin Buzzard (Feb 18 2020 at 19:16)</a>:</h4>
<p>BTW it's bad style to put <code>simp</code> in the middle of a proof; it should only be used to close a goal. There are ways to work around uses of <code>simp</code> in the middle of a proof.</p>

<a name="188879309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188879309" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188879309">Rocky Kamen-Rubio (Feb 23 2020 at 18:47)</a>:</h4>
<p>I've been chewing on this for a few days and can't seem to figure out how to rewrite <code>h</code> in this case. Could I get a hint? :-)</p>

<a name="188879808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188879808" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188879808">Bryan Gin-ge Chen (Feb 23 2020 at 19:01)</a>:</h4>
<p><span class="user-mention" data-user-id="260106">@Rocky Kamen-Rubio</span> I scrolled up a bit in the thread but I didn't see any self-contained code that I could copy / paste to try out. Could you provide that in a post or a link to a github gist?</p>

<a name="188880242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188880242" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188880242">Rocky Kamen-Rubio (Feb 23 2020 at 19:11)</a>:</h4>
<p><span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span>  Here's the full proof in its current state. The part I'm struggling with is towards the end. Let me know if you have any questions since it's a bit long.</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">init</span>
<span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">nat</span><span class="bp">.</span><span class="n">parity</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">finset</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">fintype</span>
<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">big_operators</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">set_option</span> <span class="n">class</span><span class="bp">.</span><span class="n">instance_max_depth</span> <span class="mi">15000000</span>


<span class="bp">#</span><span class="kn">eval</span> <span class="mi">2</span> <span class="c1">--You can&#39;t put open_locale classical after an import statement for some reason so that&#39;s why this is here</span>

<span class="n">open_locale</span> <span class="n">classical</span>
<span class="n">def</span> <span class="n">board</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">strategyA</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">strategyB</span><span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span> <span class="o">:=</span> <span class="n">strategyA</span>

<span class="n">def</span> <span class="n">consistent</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">strategyA</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">strategyB</span><span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="o">:=</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="o">(</span><span class="n">strategyA</span> <span class="n">r</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">strategyB</span> <span class="n">c</span> <span class="n">r</span><span class="o">)</span>

<span class="n">def</span> <span class="n">sampleA</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">board</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span> <span class="o">:=</span> <span class="n">board</span>

<span class="n">def</span> <span class="n">sampleB</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">board</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">nat</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span><span class="o">),</span> <span class="n">board</span> <span class="n">m</span> <span class="n">n</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">sampleA</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">sampleB</span>

<span class="kn">lemma</span> <span class="n">board_equiv_strategy</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">strategyA</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">strategyB</span><span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span>
<span class="o">(</span><span class="n">consistent</span> <span class="n">strategyA</span> <span class="n">strategyB</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">strategyA</span> <span class="bp">=</span> <span class="o">((</span><span class="n">sampleA</span> <span class="o">(</span><span class="n">board</span> <span class="n">strategyA</span> <span class="n">strategyB</span><span class="o">)))</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">strategyB</span> <span class="bp">=</span> <span class="o">(</span><span class="n">sampleB</span> <span class="o">(</span><span class="n">board</span> <span class="n">strategyA</span> <span class="n">strategyB</span><span class="o">))))</span>
<span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
<span class="n">split</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">sampleA</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">board</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">board</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">sampleB</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">consistent</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
<span class="n">ext</span> <span class="n">i</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">h</span><span class="o">,</span>
<span class="kn">end</span>

<span class="n">def</span> <span class="n">each_row_sum_even</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">board</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span><span class="o">),</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="n">sampleA</span> <span class="n">board</span> <span class="n">r</span><span class="o">))</span><span class="bp">.</span><span class="n">even</span>

<span class="n">def</span> <span class="n">each_col_sum_odd</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">board</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="bp">¬</span><span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="n">sampleB</span> <span class="n">board</span> <span class="n">c</span><span class="o">))</span><span class="bp">.</span><span class="n">even</span>

<span class="n">def</span> <span class="n">even_strategy</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">strategyA</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span><span class="o">,</span> <span class="o">((</span><span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="n">strategyA</span> <span class="n">r</span><span class="o">))</span><span class="bp">.</span><span class="n">even</span><span class="o">))</span>

<span class="n">def</span> <span class="n">odd_strategy</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">strategyB</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="n">strategyB</span> <span class="n">c</span><span class="o">))</span><span class="bp">.</span><span class="n">even</span><span class="o">)</span>

<span class="kn">lemma</span> <span class="n">even_strategy_implies_even_rows</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">strategyA</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">strategyB</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span>
<span class="o">:</span> <span class="o">((</span><span class="n">consistent</span> <span class="n">strategyA</span> <span class="n">strategyB</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">even_strategy</span> <span class="n">strategyA</span><span class="o">)</span> <span class="bp">→</span> <span class="n">each_row_sum_even</span> <span class="o">(</span><span class="n">board</span> <span class="n">strategyA</span> <span class="n">strategyB</span><span class="o">)</span>
<span class="o">:=</span>
<span class="k">begin</span>
<span class="n">rw</span> <span class="n">even_strategy</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">each_row_sum_even</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">sampleA</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">board</span><span class="o">,</span>
<span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
<span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">h</span><span class="bp">.</span><span class="n">right</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">h</span><span class="o">,</span>
<span class="kn">end</span>

<span class="c1">--In order to talk about a board we need to assume the two strategies are consistent. Or else we need to define the board differently to allowfor this</span>
<span class="kn">lemma</span> <span class="n">odd_strategy_implies_odd_cols</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">strategyA</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">strategyB</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span>
<span class="o">:</span> <span class="o">((</span><span class="n">consistent</span> <span class="n">strategyA</span> <span class="n">strategyB</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">odd_strategy</span> <span class="n">strategyB</span><span class="o">)</span> <span class="bp">→</span> <span class="n">each_col_sum_odd</span> <span class="o">(</span><span class="n">board</span> <span class="n">strategyA</span> <span class="n">strategyB</span><span class="o">)</span>
<span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span>
<span class="k">have</span> <span class="n">h3</span> <span class="o">:=</span> <span class="n">board_equiv_strategy</span> <span class="n">strategyA</span> <span class="n">strategyB</span> <span class="n">h1</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">h3</span> <span class="k">with</span> <span class="n">h4</span> <span class="n">h5</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">each_col_sum_odd</span><span class="o">,</span>
<span class="n">rw</span> <span class="err">←</span> <span class="n">h5</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">odd_strategy</span> <span class="n">at</span> <span class="n">h2</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">h2</span><span class="o">,</span>
<span class="kn">end</span>

<span class="n">def</span> <span class="n">matrix_sum</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="err">$</span> <span class="n">M</span> <span class="n">i</span>

<span class="n">def</span> <span class="n">row_sum</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">board</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">:=</span> <span class="n">matrix_sum</span> <span class="o">(</span><span class="n">sampleA</span> <span class="n">board</span><span class="o">)</span>

<span class="n">def</span> <span class="n">col_sum</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">board</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">:=</span> <span class="n">matrix_sum</span> <span class="o">(</span><span class="n">sampleB</span> <span class="n">board</span><span class="o">)</span>

<span class="c1">--sometimes I get an error here that this theorem is using sorry. Doesn&#39;t look like it is to me, so idk what&#39;s going on</span>
<span class="kn">theorem</span> <span class="n">sum_univ_fin_eq_sum_range</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">finset</span><span class="bp">.</span><span class="n">sum</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span> <span class="n">f</span> <span class="bp">=</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">range</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="k">if</span> <span class="n">hi</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="k">then</span> <span class="n">f</span> <span class="bp">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hi</span><span class="bp">⟩</span> <span class="k">else</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">set</span> <span class="n">F</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="k">if</span> <span class="n">hi</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="k">then</span> <span class="n">f</span> <span class="bp">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hi</span><span class="bp">⟩</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">with</span> <span class="n">hF</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="n">F</span> <span class="o">(</span><span class="n">i</span><span class="bp">.</span><span class="n">val</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">ext</span> <span class="n">i</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">hF</span><span class="o">,</span>
    <span class="k">show</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">dite</span> <span class="o">(</span><span class="n">i</span><span class="bp">.</span><span class="n">val</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">hi</span> <span class="o">:</span> <span class="n">i</span><span class="bp">.</span><span class="n">val</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">),</span> <span class="n">f</span> <span class="bp">⟨</span><span class="n">i</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span> <span class="n">hi</span><span class="bp">⟩</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">hi</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">i</span><span class="bp">.</span><span class="n">val</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">),</span> <span class="mi">0</span><span class="o">),</span>
    <span class="n">rw</span> <span class="n">dif_pos</span> <span class="n">i</span><span class="bp">.</span><span class="n">is_lt</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">i</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="n">rw</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">rw</span> <span class="err">←</span><span class="n">finset</span><span class="bp">.</span><span class="n">sum_image</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">congr&#39;</span><span class="o">,</span>
    <span class="c1">-- ⊢ finset.image (λ (x : fin n), x.val) finset.univ = finset.range n</span>
    <span class="n">ext</span> <span class="n">j</span><span class="o">,</span> <span class="c1">-- sigh</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">finset</span><span class="bp">.</span><span class="n">mem_range</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">mem_image</span><span class="o">],</span>
    <span class="n">split</span><span class="o">,</span>
      <span class="n">rintro</span> <span class="bp">⟨⟨</span><span class="n">j</span><span class="o">,</span><span class="n">hj</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">hj</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">hj</span><span class="o">,</span>
    <span class="n">use</span> <span class="bp">⟨</span><span class="n">j</span><span class="o">,</span> <span class="n">hj</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span> <span class="n">apply</span> <span class="n">finset</span><span class="bp">.</span><span class="n">mem_univ</span><span class="o">,</span> <span class="n">refl</span>
  <span class="o">},</span>
  <span class="n">intros</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">fin</span><span class="bp">.</span><span class="n">eq_of_veq</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">row_sum_eq_col_sum</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">board</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">row_sum</span> <span class="n">board</span> <span class="bp">=</span> <span class="n">col_sum</span> <span class="n">board</span>
<span class="o">:=</span>
<span class="k">begin</span>
<span class="n">rw</span> <span class="n">row_sum</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">col_sum</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">matrix_sum</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">matrix_sum</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">sampleB</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">sampleA</span><span class="o">,</span>
<span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">sum_univ_fin_eq_sum_range</span><span class="o">,</span>
<span class="n">sorry</span><span class="o">,</span>
<span class="c1">-- finset.sum_comm,</span>
<span class="kn">end</span>

<span class="kn">theorem</span> <span class="n">noStrategyMN2</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">strategyA</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">strategyB</span><span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span>
<span class="bp">¬</span> <span class="o">((</span><span class="n">consistent</span> <span class="n">strategyA</span> <span class="n">strategyB</span><span class="o">)</span> <span class="bp">∧</span>  <span class="o">(</span><span class="n">even_strategy</span> <span class="n">strategyA</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">odd_strategy</span> <span class="n">strategyB</span><span class="o">))</span>
<span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">c</span> <span class="n">y</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">y</span> <span class="k">with</span> <span class="n">even</span> <span class="n">odd</span><span class="o">,</span>
<span class="k">have</span> <span class="n">cEven</span> <span class="o">:=</span> <span class="n">even</span><span class="o">,</span>
<span class="k">have</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">even_strategy_implies_even_rows</span> <span class="n">strategyA</span> <span class="n">strategyB</span> <span class="o">(</span><span class="n">c</span> <span class="bp">∧</span> <span class="n">even</span><span class="o">),</span>  <span class="c1">--why is this not ok???????</span>
<span class="k">have</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">odd_strategy_implies_odd_cols</span> <span class="n">strategyA</span> <span class="n">strategyB</span> <span class="o">(</span><span class="n">c</span> <span class="bp">∧</span> <span class="n">even</span><span class="o">),</span>
<span class="n">sorry</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>

<a name="188881049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188881049" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188881049">Kevin Buzzard (Feb 23 2020 at 19:32)</a>:</h4>
<p>Re: "sometimes I get an error here that this theorem is using sorry." I think this might be some kind of a bug in <code>use</code>. If you replace <code>use ⟨j, hj⟩,</code> near the end by <code>existsi (⟨j, hj⟩ : fin n),</code> is it any better?</p>

<a name="188881338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188881338" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188881338">Kevin Buzzard (Feb 23 2020 at 19:38)</a>:</h4>
<p>The <code>rw h</code> fails (correctly), and to debug this you can try filling in some of the gaps. The more precise <code>rw h m (λ (i : fin m), finset.sum finset.univ (board i))</code> fails and here the error is much clearer -- <code>sum_univ_fin_eq_sum_range</code> (which IIRC I wrote) is about functions from <code>fin n</code> to the reals, and you have a function from <code>fin n</code> to the naturals. The correct thing to prove is for a map to an arbitrary additive commutative monoid or something -- something which includes both the naturals and the reals. You can replace the first few lines with</p>
<div class="codehilite"><pre><span></span>theorem sum_univ_fin_eq_sum_range {A : Type*} [add_comm_monoid A] (n : ℕ) (f : fin n → A) :
  finset.sum finset.univ f = (finset.range n).sum (λ i, if hi : i &lt; n then f ⟨i, hi⟩ else 0) :=
begin
  set F : ℕ → A := λ i, if hi : i &lt; n then f ⟨i, hi⟩ else 0 with hF,
</pre></div>

<a name="188881384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188881384" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188881384">Kevin Buzzard (Feb 23 2020 at 19:39)</a>:</h4>
<p>but even after the rewrites there is work to do. At least this is a step forward.</p>

<a name="188881583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188881583" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188881583">Kevin Buzzard (Feb 23 2020 at 19:44)</a>:</h4>
<p>oh no no what am I talking about? You don't use h at all, I've misremembered the idea. You can just finish the proof with <code>sum_comm</code>:</p>
<div class="codehilite"><pre><span></span>rw matrix_sum,
rw sampleB,
rw sampleA,
rw finset.sum_comm,
</pre></div>

<a name="188881724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188881724" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188881724">Kevin Buzzard (Feb 23 2020 at 19:47)</a>:</h4>
<p>So that gets <code>row_sum_eq_col_sum</code> compiling and now there's just an error  at <code>c ∧ even</code> -- you ask why this is not OK, and this has an easy answer: <code>P ∧ Q</code> works for propositions, which means <em>true-false statements</em>. For example <code>x = 2 ∧ y &lt; 4</code> is fine. Now <code>x = 2</code> has type <code>Prop</code>. Your term <code>c</code> has type <code>consistent strategyA strategyB</code> (not <code>Prop</code> -- it's a <em>proof</em> not a <em>statement</em>) so <code>c ∧ ...</code> makes no sense.</p>

<a name="188882833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188882833" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188882833">Rocky Kamen-Rubio (Feb 23 2020 at 20:17)</a>:</h4>
<ol>
<li>
<p>Yes, replacing <code>use (j,hj)</code> with <code>existsi ((j,hj) : fin n),</code> resolved the issue, thank you!</p>
</li>
<li>
<p>I had a feeling there was an easy way to do that in Lean.  I'm a little confused what the purpose of defining h was then? I remember <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>  and <span class="user-mention" data-user-id="110032">@Reid Barton</span> talking about how this proof wouldn't be possible with tactics, but maybe that was for a more general idea?</p>
</li>
<li>
<p>I defined <code>consistent</code> <code>even</code> and <code>odd</code>as <code>Prop</code>s though, not as theorems. Do I still need to treat them differently?</p>
</li>
</ol>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">consistent</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">strategyA</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">strategyB</span><span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="o">:=</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="o">(</span><span class="n">strategyA</span> <span class="n">r</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">strategyB</span> <span class="n">c</span> <span class="n">r</span><span class="o">)</span>

<span class="n">def</span> <span class="n">even_strategy</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">strategyA</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span><span class="o">,</span> <span class="o">((</span><span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="n">strategyA</span> <span class="n">r</span><span class="o">))</span><span class="bp">.</span><span class="n">even</span><span class="o">))</span>

<span class="n">def</span> <span class="n">odd_strategy</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">strategyB</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="n">strategyB</span> <span class="n">c</span><span class="o">))</span><span class="bp">.</span><span class="n">even</span><span class="o">)</span>
</pre></div>

<a name="188884617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188884617" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188884617">Bryan Gin-ge Chen (Feb 23 2020 at 21:10)</a>:</h4>
<p>For your last question mark, maybe this helps:</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">noStrategyMN2</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">strategyA</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">strategyB</span><span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span>
<span class="bp">¬</span> <span class="o">((</span><span class="n">consistent</span> <span class="n">strategyA</span> <span class="n">strategyB</span><span class="o">)</span> <span class="bp">∧</span>  <span class="o">(</span><span class="n">even_strategy</span> <span class="n">strategyA</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">odd_strategy</span> <span class="n">strategyB</span><span class="o">))</span>
<span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">c</span> <span class="n">y</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">y</span> <span class="k">with</span> <span class="n">even</span> <span class="n">odd</span><span class="o">,</span>
<span class="k">have</span> <span class="n">cEven</span> <span class="o">:=</span> <span class="n">even</span><span class="o">,</span>
<span class="k">have</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">even_strategy_implies_even_rows</span> <span class="n">strategyA</span> <span class="n">strategyB</span> <span class="bp">⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">even</span><span class="bp">⟩</span><span class="o">,</span>
<span class="c1">-- to give something of type A ∧ B, you need hA : A and hB : B,</span>
<span class="c1">-- and you put them together in angle brackets like this: ⟨hA, hB⟩,</span>
<span class="k">have</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">odd_strategy_implies_odd_cols</span> <span class="n">strategyA</span> <span class="n">strategyB</span> <span class="bp">⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">odd</span><span class="bp">⟩</span><span class="o">,</span>
<span class="n">sorry</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>

<a name="188885872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188885872" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188885872">Kevin Buzzard (Feb 23 2020 at 21:49)</a>:</h4>
<p>You defined <code>consistent</code> as a Prop, and <code>and</code> expects a Prop. So why did you give it a <em>proof</em> and not a Prop? You gave it a term of type P, not P itself.</p>

<a name="188885975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188885975" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188885975">Bryan Gin-ge Chen (Feb 23 2020 at 21:52)</a>:</h4>
<p>Wanting to put an <code>and</code> there was the problem, since <code>even_strategy_implies_even_rows</code> looks like this:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">even_strategy_implies_even_rows</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">strategyA</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">strategyB</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span>
<span class="o">:</span> <span class="o">((</span><span class="n">consistent</span> <span class="n">strategyA</span> <span class="n">strategyB</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">even_strategy</span> <span class="n">strategyA</span><span class="o">)</span> <span class="bp">→</span> <span class="n">each_row_sum_even</span> <span class="o">(</span><span class="n">board</span> <span class="n">strategyA</span> <span class="n">strategyB</span><span class="o">)</span>
</pre></div>

<a name="188886296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188886296" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188886296">Kevin Buzzard (Feb 23 2020 at 22:02)</a>:</h4>
<p>PS your <code>import init</code> is bad -- remove it. Your <code>set_option class.instance_max_depth 15000000</code> is also bad -- remove it. I think the reasons were already explained above but you don't want either of these two lines.</p>

<a name="188963082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188963082" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188963082">Rocky Kamen-Rubio (Feb 24 2020 at 20:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/188885872" title="#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/188885872">said</a>:</p>
<blockquote>
<p>You defined <code>consistent</code> as a Prop, and <code>and</code> expects a Prop. So why did you give it a <em>proof</em> and not a Prop? You gave it a term of type P, not P itself.</p>
</blockquote>
<p>Ok, I think I'm getting this. It's working fine with the modification. Thank you!</p>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/188886296" title="#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/188886296">said</a>:</p>
<blockquote>
<p>PS your <code>import init</code> is bad -- remove it. Your <code>set_option class.instance_max_depth 15000000</code> is also bad -- remove it. I think the reasons were already explained above but you don't want either of these two lines.</p>
</blockquote>
<p>You're right. I had forgotten to take those out since they weren't actively stopping my code from compiling... Thanks for the reminder!</p>

<a name="188963797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188963797" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188963797">Rocky Kamen-Rubio (Feb 24 2020 at 20:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260106">Rocky Kamen-Rubio</span> <a href="#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/188462495" title="#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/188462495">said</a>:</p>
<blockquote>
<p>Thank you! That's a good point that maybe this is a sign that I should switch to the mathlib representation. My other motivation for not switching was that eventually I want to start putting noncommutative elements (specifically entangled quantum states) into the matrix, so it would matter whether I'm ordering it by rows or columns. If we have <code>(M : fin m → fin n → ℕ )</code>, I guess I could also just transpose it and do <code>matrix_sum </code> on the transpose. This way we get both cases, and all I need is to show whether they're equal or not.</p>
</blockquote>
<p>I'm now wanting to repeat this procedure but with matrices in each column instead of integers, and taking the matrix product of all the matrices in each row. <code>finset.univ.prod</code> (understandably) doesn't use <code>matrix.mul</code> automatically when its input is a matrix. Is there a way to feed it an arbitrary function (à la MapReduce) , or should I be thinking about this differently? I could see a benefit to implementing this matrix data structure differently, maybe as a 2D linked list, to facilitate recursive matrix multiplication of its elements over a given row or column, but I feel like that shouldn't be necessary.</p>

<a name="188967088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188967088" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188967088">Kevin Buzzard (Feb 24 2020 at 21:19)</a>:</h4>
<p><code>finset.univ.prod</code> should work fine. If the function is taking values in anything which Lean knows is a monoid then it will use the monoid multiplication....oh wait. It's not commutative. Then yes you're right, you'll have to use something like <code>list.prod</code></p>

<a name="188993063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188993063" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188993063">Rocky Kamen-Rubio (Feb 25 2020 at 05:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/188967088" title="#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/188967088">said</a>:</p>
<blockquote>
<p><code>finset.univ.prod</code> should work fine. If the function is taking values in anything which Lean knows is a monoid then it will use the monoid multiplication....oh wait. It's not commutative. Then yes you're right, you'll have to use something like <code>list.prod</code></p>
</blockquote>
<p><code>list.prod</code> works, thank you! That's a shame though because now I'm going to have to choose between keeping my matrix type or using this easier product method (unless there's a snazzy way to get the rows and columns from a matrix as a list instead of as vectors, but it seems like that's not possible). I tried implementing this recursive algorithm on my matrix in the meantime too, but keep getting that the recursive call is an "unknown identifier". Is there an import statement or something I'm missing that tells Lean it's ok to use variables that haven't been fully defined yet?</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">finset</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">fintype</span>
<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">big_operators</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">matrix</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">matrix</span><span class="bp">.</span><span class="n">pequiv</span>

<span class="n">def</span> <span class="n">row_product</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">mat</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">ℤ</span> <span class="o">))</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">):</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">ℤ</span> <span class="o">:=</span> <span class="n">row_product_helper</span> <span class="n">mat</span> <span class="n">r</span> <span class="mi">1</span>

<span class="n">def</span> <span class="n">row_product_helper</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">mat</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">ℤ</span> <span class="o">))</span> <span class="o">(</span><span class="n">r</span> <span class="n">c</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">ℤ</span> <span class="o">:=</span>
<span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span> <span class="k">then</span> <span class="n">mat</span> <span class="n">r</span> <span class="n">c</span> <span class="k">else</span> <span class="n">matrix</span><span class="bp">.</span><span class="n">mul</span> <span class="o">(</span><span class="n">mat</span> <span class="n">r</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">row_product_helper</span> <span class="n">mat</span> <span class="n">r</span> <span class="o">(</span><span class="n">c</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span>
</pre></div>

<a name="189003202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/189003202" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#189003202">Kevin Buzzard (Feb 25 2020 at 09:27)</a>:</h4>
<blockquote>
<p>(unless there's a snazzy way to get the rows and columns from a matrix as a list instead of as vectors, but it seems like that's not possible). </p>
</blockquote>
<p>I don't really know what you mean. Anything is possible. Just write the function.</p>
<blockquote>
<p>I tried implementing this recursive algorithm on my matrix in the meantime too, but keep getting that the recursive call is an "unknown identifier". Is there an import statement or something I'm missing</p>
</blockquote>
<p>I can't help you unless you post complete fully working code.</p>

<a name="189003309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/189003309" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#189003309">Mario Carneiro (Feb 25 2020 at 09:28)</a>:</h4>
<p>You have to use the equation compiler if you want to write a recursive function like that, i.e.</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">type</span>
<span class="bp">|</span> <span class="n">case1</span> <span class="o">:=</span> <span class="n">bla</span>
<span class="bp">|</span> <span class="n">case2</span> <span class="o">:=</span> <span class="n">foo</span> <span class="n">bar</span>
</pre></div>

<a name="189003449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/189003449" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#189003449">Kevin Buzzard (Feb 25 2020 at 09:31)</a>:</h4>
<p>Is the issue simply that <code>row_product_helper</code> is defined after you use it in <code>row_product</code>? No import will help you there, you have to define things before you use them.</p>

<a name="189012124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/189012124" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#189012124">Kevin Buzzard (Feb 25 2020 at 11:43)</a>:</h4>
<p>PS I found <a href="http://learnyouahaskell.com/" target="_blank" title="http://learnyouahaskell.com/">learn you a haskell</a> really helpful when I was trying to figure out what functional languages looked like in general.</p>

<a name="189057294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/189057294" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#189057294">Rocky Kamen-Rubio (Feb 25 2020 at 20:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/189003202" title="#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/189003202">said</a>:</p>
<blockquote>
<blockquote>
<p>(unless there's a snazzy way to get the rows and columns from a matrix as a list instead of as vectors, but it seems like that's not possible). </p>
</blockquote>
<p>I don't really know what you mean. Anything is possible. Just write the function.</p>
</blockquote>
<p>Looking at the documentation for <code>row</code> it looks like it returns a vector not a list. You're right though that I could just convert it to a list and then product. Maybe this is an indication that a more functional approach would be preferred/more in line with how Lean is built?</p>
<blockquote>
<blockquote>
<p>I tried implementing this recursive algorithm on my matrix in the meantime too, but keep getting that the recursive call is an "unknown identifier". Is there an import statement or something I'm missing</p>
</blockquote>
<p>I can't help you unless you post complete fully working code.</p>
</blockquote>
<p>I posted the code I have below the text. Is it not visible to you? Do you mean that I need to include all my import statements as well?</p>

<a name="189057456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/189057456" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#189057456">Rocky Kamen-Rubio (Feb 25 2020 at 20:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/189003449" title="#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/189003449">said</a>:</p>
<blockquote>
<p>Is the issue simply that <code>row_product_helper</code> is defined after you use it in <code>row_product</code>? No import will help you there, you have to define things before you use them.</p>
</blockquote>
<p>Even reversing the order of the two definitions, the recursive call in <code>row_product_helper</code> gives me an error. I'll check out learn you a haskell and see if that gives me more clarity. Thank you!</p>

<a name="189057510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/189057510" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#189057510">Kevin Buzzard (Feb 25 2020 at 20:26)</a>:</h4>
<p>I cut and pasted the code you posted and it didn't work. Yes, include everything which makes it work!</p>

<a name="189057549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/189057549" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#189057549">Rocky Kamen-Rubio (Feb 25 2020 at 20:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/189003309" title="#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/189003309">said</a>:</p>
<blockquote>
<p>You have to use the equation compiler if you want to write a recursive function like that, i.e.</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">type</span>
<span class="bp">|</span> <span class="n">case1</span> <span class="o">:=</span> <span class="n">bla</span>
<span class="bp">|</span> <span class="n">case2</span> <span class="o">:=</span> <span class="n">foo</span> <span class="n">bar</span>
</pre></div>


</blockquote>
<p>Interesting. I'll try rewriting my function like this and see if it helps. Thank you!</p>

<a name="189057995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/189057995" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#189057995">Rocky Kamen-Rubio (Feb 25 2020 at 20:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/189057510" title="#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/189057510">said</a>:</p>
<blockquote>
<p>I cut and pasted the code you posted and it didn't work. Yes, include everything which makes it work!</p>
</blockquote>
<p>I added the import statements. I'll be sure to include them in future posts.</p>

<a name="189062310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/189062310" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#189062310">Kevin Buzzard (Feb 25 2020 at 21:17)</a>:</h4>
<p>Your code doesn't work because you use <code>row_product_helper</code> before you define it. And if you switch the order of <code>row_product_helper</code> and <code>row_product</code> it doesn't work because <code>mat r c</code> doesn't make sense because <code>r</code> has type <code>nat</code> and not type <code>fin m</code>.  But even if you fix that it won't work because you can't use <code>row_product_helper</code> in the definition of <code>row_product_helper</code>, that doesn't make sense in functional programming.</p>

<a name="189064024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/189064024" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#189064024">Kevin Buzzard (Feb 25 2020 at 21:39)</a>:</h4>
<p>I now understand Mario's reply (I'm much less good than some other people at "guessing what the user meant"). You can use the definition of X when defining X, as long as you only run X on strictly "smaller" things. Here's a less abstract example:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">Fib</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="mi">1</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Fib</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">Fib</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
</pre></div>


<p>You might want to read about how the equation compiler works in <a href="https://leanprover.github.io/theorem_proving_in_lean/induction_and_recursion.html" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/induction_and_recursion.html">Theorem Proving In Lean</a>, although depending on what you know you might have to read a bunch of earlier chapters first.</p>

<a name="189155370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/189155370" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#189155370">Rocky Kamen-Rubio (Feb 26 2020 at 20:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/189064024" title="#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/189064024">said</a>:</p>
<blockquote>
<p>I now understand Mario's reply (I'm much less good than some other people at "guessing what the user meant"). You can use the definition of X when defining X, as long as you only run X on strictly "smaller" things. Here's a less abstract example:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">Fib</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="mi">1</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Fib</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">Fib</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
</pre></div>


<p>You might want to read about how the equation compiler works in <a href="https://leanprover.github.io/theorem_proving_in_lean/induction_and_recursion.html" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/induction_and_recursion.html">Theorem Proving In Lean</a>, although depending on what you know you might have to read a bunch of earlier chapters first.</p>
</blockquote>
<p>That makes sense. I'll take some time to go back and try to fully understand how the equation compiler works as well as matrices, lists, and vectors. Thanks!</p>


{% endraw %}

{% include archive_update.html %}