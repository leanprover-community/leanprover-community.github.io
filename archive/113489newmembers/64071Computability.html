---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113489newmembers/64071Computability.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/64071Computability.html">Computability</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="167460367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability/near/167460367" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/64071Computability.html#167460367">Kenny Lau (Jun 06 2019 at 08:03)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">asdf</span> <span class="o">:</span> <span class="n">subtype</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">true</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨@</span><span class="n">classical</span><span class="bp">.</span><span class="n">epsilon</span> <span class="o">(</span><span class="n">set</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="bp">⟨</span><span class="err">∅</span><span class="bp">⟩</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">s</span><span class="o">,</span> <span class="n">true</span><span class="o">),</span> <span class="n">trivial</span><span class="bp">⟩</span>

<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">ghjk</span> <span class="o">:</span> <span class="n">subtype</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">true</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">classical</span><span class="bp">.</span><span class="n">epsilon</span> <span class="o">(</span><span class="n">subtype</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">true</span><span class="o">))</span> <span class="bp">⟨⟨</span><span class="err">∅</span><span class="o">,</span> <span class="n">trivial</span><span class="bp">⟩⟩</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">s</span><span class="o">,</span> <span class="n">true</span><span class="o">)</span>
</pre></div>


<p>Why is the first one computable but not the second one?</p>

<a name="167460421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability/near/167460421" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/64071Computability.html#167460421">Kenny Lau (Jun 06 2019 at 08:04)</a>:</h4>
<p>"why" as in the mechanism behind</p>

<a name="167464613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability/near/167464613" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/64071Computability.html#167464613">Chris Hughes (Jun 06 2019 at 09:13)</a>:</h4>
<p>Because Sorts are always computable. In the first one you defined a <code>nat - &gt; Prop</code> using choice, and the second one you defined an element of some subtype with choice.</p>

<a name="167464657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability/near/167464657" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/64071Computability.html#167464657">Chris Hughes (Jun 06 2019 at 09:14)</a>:</h4>
<p>I think.</p>

<a name="193848039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability/near/193848039" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/64071Computability.html#193848039">Brandon B (Apr 14 2020 at 03:54)</a>:</h4>
<p>I have more questions about the computational interpretation of classical logic in type theory. I am making a new topic to separate from the rest. I am reposting my original question and some replies.</p>
<p>Original post: <br>
"I was reading Kevin Buzzard's recent post "Proofs are not programs" &lt; <a href="https://xenaproject.wordpress.com/2019/06/15/proofs-are-not-programs/" title="https://xenaproject.wordpress.com/2019/06/15/proofs-are-not-programs/">https://xenaproject.wordpress.com/2019/06/15/proofs-are-not-programs/</a> &gt; which argues that only in constructive logic is the Curry-Howard correspondence held (proofs are programs) and that in general in ZFC with the axiom of choice and excluded middle etc that Curry-Howard does not apply; which is why is why in lean we label certain things as noncomputable. However, looking at <a href="https://en.wikipedia.org/wiki/Lambda-mu_calculus" title="https://en.wikipedia.org/wiki/Lambda-mu_calculus">https://en.wikipedia.org/wiki/Lambda-mu_calculus</a> it seems to suggest that there are more sophisticated lambda calculi that can model "classical logic" with excluded middle etc and still maintain a form of the curry-howard correspondence. Is lean's type system CoC just not rich enough to model classical deductions with computational content?"</p>

<a name="193848083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability/near/193848083" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/64071Computability.html#193848083">Brandon B (Apr 14 2020 at 03:54)</a>:</h4>
<p>reply: "Andrew Ashworth5:05 PM<br>
urgh, if you really want to go into gory detail, you could try chapter 8 of <a href="http://disi.unitn.it/~bernardi/RSISE11/Papers/curry-howard.pdf" title="http://disi.unitn.it/~bernardi/RSISE11/Papers/curry-howard.pdf">http://disi.unitn.it/~bernardi/RSISE11/Papers/curry-howard.pdf</a> "</p>

<a name="193848090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability/near/193848090" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/64071Computability.html#193848090">Brandon B (Apr 14 2020 at 03:54)</a>:</h4>
<p>reply: "Mario Carneiro6:06 PM<br>
The basic idea behind computational semantics for EM (or more simply, double negation elimination) is that you put everything in continuation passing style, the logical equivalent being putting double negations on everything, and then all the classical theorems become intuitionistically provable, and the computational semantics are that of call/cc or exception handling.</p>
<p>If you wanted to do something similar with full choice, I think you could do it like so: Suppose you want to produce an element of type A satisfying p. Save the current continuation, and then start enumerating well formed terms of type A. Return the first one you find (whether or not it satisfies p). Later, the program may later discover that you lied to it and will prove that the element does not in fact satisfy p, deriving a contradiction. When you call false.elim on this proof of false, the eliminator goes back to the original continuation, "rewinding the universe" to the original state, whereupon it tries the next term it finds.</p>
<p>This should satisfy type correctness, but it is not strongly normalizing as you might be enumerating terms forever looking for one that satisfies p."</p>

<a name="193848238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability/near/193848238" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/64071Computability.html#193848238">Brandon B (Apr 14 2020 at 03:59)</a>:</h4>
<p>My sense so far is that a type theory that models constructive logic yields a programming language where all programs are guaranteed to terminate, which comes at the expense of certain classes programs not being definable at all (namely those that cannot be proven to terminate). Whereas, classical logic with LEM allows non-terminating programs, expanding the universe of definable programs at the expense of not being able to verify if a defined program will ever finish a computation.  Is that on the right track?</p>

<a name="193851223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability/near/193851223" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/64071Computability.html#193851223">Nam (Apr 14 2020 at 05:15)</a>:</h4>
<p>on this note, is it possible to extract / compile Lean code into executable code that can be linked with, say, C/C++? the last i found on this subject was in 2018 and someone mentioned Lean 4 would have this feature. is that still on? is there any sample extraction?</p>

<a name="193852036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability/near/193852036" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/64071Computability.html#193852036">Mario Carneiro (Apr 14 2020 at 05:36)</a>:</h4>
<blockquote>
<p>My sense so far is that a type theory that models constructive logic yields a programming language where all programs are guaranteed to terminate, which comes at the expense of certain classes programs not being definable at all (namely those that cannot be proven to terminate).</p>
</blockquote>
<p>Well, any type theory models a constructive logic. The ones that have nonterminating programs just have an inconsistent constructive logic</p>

<a name="193852166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability/near/193852166" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/64071Computability.html#193852166">Mario Carneiro (Apr 14 2020 at 05:38)</a>:</h4>
<blockquote>
<p>Whereas, classical logic with LEM allows non-terminating programs, expanding the universe of definable programs at the expense of not being able to verify if a defined program will ever finish a computation.</p>
</blockquote>
<p>LEM doesn't give you nonterminating programs. The double negation elimination method mentioned in the books still yields a strongly normalizing system. The one I mentioned for full choice doesn't, but I'm also not 100% sure it even works in the first place, it's more of a sketch.</p>

<a name="193852204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability/near/193852204" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/64071Computability.html#193852204">Mario Carneiro (Apr 14 2020 at 05:39)</a>:</h4>
<blockquote>
<p>on this note, is it possible to extract / compile Lean code into executable code that can be linked with, say, C/C++? the last i found on this subject was in 2018 and someone mentioned Lean 4 would have this feature. is that still on? is there any sample extraction?</p>
</blockquote>
<p>Lean 3 doesn't have this feature, Lean 4 is basically built around it. Lean 4 itself is being mostly written in lean and compiled to C++</p>

<a name="193852269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability/near/193852269" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/64071Computability.html#193852269">Mario Carneiro (Apr 14 2020 at 05:40)</a>:</h4>
<p>I think there are some experiments with FFI in lean 3 though</p>

<a name="194525664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability/near/194525664" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/64071Computability.html#194525664">Jalex Stark (Apr 18 2020 at 04:37)</a>:</h4>
<p>is there a lean 4 paper or similar where one can learn more?</p>

<a name="194534358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability/near/194534358" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/64071Computability.html#194534358">Kevin Buzzard (Apr 18 2020 at 09:01)</a>:</h4>
<p>There's not even a Lean 4 release yet. Leo was due to give a talk about it a few weeks ago but it got cancelled</p>

<a name="194534687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability/near/194534687" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/64071Computability.html#194534687">Marc Huisinga (Apr 18 2020 at 09:10)</a>:</h4>
<p><span class="user-mention" data-user-id="252300">@Jalex Stark</span> <br>
i don't think that there's a paper on the FFI.<br>
papers on lean4 from <a href="https://leanprover.github.io/publications/" title="https://leanprover.github.io/publications/">https://leanprover.github.io/publications/</a>:</p>
<ul>
<li>type class resolution: <a href="https://arxiv.org/pdf/2001.04301.pdf" title="https://arxiv.org/pdf/2001.04301.pdf">https://arxiv.org/pdf/2001.04301.pdf</a></li>
<li>notation: <a href="https://arxiv.org/pdf/2001.10490.pdf" title="https://arxiv.org/pdf/2001.10490.pdf">https://arxiv.org/pdf/2001.10490.pdf</a></li>
<li>garbage collection and IR: <a href="https://arxiv.org/pdf/1908.05647.pdf" title="https://arxiv.org/pdf/1908.05647.pdf">https://arxiv.org/pdf/1908.05647.pdf</a></li>
</ul>

<a name="194534703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability/near/194534703" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/64071Computability.html#194534703">Marc Huisinga (Apr 18 2020 at 09:11)</a>:</h4>
<p>the more recent slides in the first link might also be of interest to you.</p>


{% endraw %}

{% include archive_update.html %}