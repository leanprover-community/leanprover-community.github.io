---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113489newmembers/08613Sumtypecancellation.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/08613Sumtypecancellation.html">Sum type cancellation</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="189456757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sum%20type%20cancellation/near/189456757" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/08613Sumtypecancellation.html#189456757">Grayson Burton (Mar 02 2020 at 01:28)</a>:</h4>
<p>Hello. This is my first time posting here (or on Zulip at all) so if I should've put this somewhere else or done this differently, my bad.<br>
I've been fairly stuck trying to prove this theorem that I <em>believe</em> is correct. I really want to stick to computable proofs as well, but I'm happy to bend that if need be.</p>
<div class="codehilite"><pre><span></span><span class="c1">-- Type isomorphism. Classically is equivalent to bijection but this allows me to use the inverse function `g` while staying computable.</span>
<span class="n">def</span> <span class="n">type_iso</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">),</span>
  <span class="n">function</span><span class="bp">.</span><span class="n">left_inverse</span> <span class="n">f</span> <span class="n">g</span> <span class="bp">∧</span> <span class="n">function</span><span class="bp">.</span><span class="n">right_inverse</span> <span class="n">f</span> <span class="n">g</span>

<span class="kn">theorem</span> <span class="n">sum_cancel</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">hsum</span> <span class="o">:</span> <span class="n">type_iso</span> <span class="o">(</span><span class="n">α</span> <span class="err">⊕</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="err">⊕</span> <span class="n">γ</span><span class="o">))</span> <span class="o">:</span> <span class="n">type_iso</span> <span class="n">β</span> <span class="n">γ</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">cases</span> <span class="n">hsum</span> <span class="k">with</span> <span class="n">fs</span> <span class="n">gshfs</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">gshfs</span> <span class="k">with</span> <span class="n">gs</span> <span class="n">hfs</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">sum</span><span class="bp">.</span><span class="n">cases_on</span> <span class="o">(</span><span class="n">fs</span> <span class="err">$</span> <span class="n">sum</span><span class="bp">.</span><span class="n">inr</span> <span class="n">x</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">sorry</span><span class="o">)</span>
    <span class="n">id</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">g</span> <span class="o">:</span> <span class="n">γ</span> <span class="bp">→</span> <span class="n">β</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">sum</span><span class="bp">.</span><span class="n">cases_on</span> <span class="o">(</span><span class="n">gs</span> <span class="err">$</span> <span class="n">sum</span><span class="bp">.</span><span class="n">inr</span> <span class="n">x</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">sorry</span><span class="o">)</span>
    <span class="n">id</span><span class="o">,</span>
  <span class="n">existsi</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">existsi</span> <span class="n">g</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="k">begin</span>
    <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">sorry</span>
  <span class="kn">end</span><span class="o">,</span>
  <span class="k">begin</span>
    <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">sorry</span>
  <span class="kn">end</span>
<span class="kn">end</span>
</pre></div>


<p>(I could've used <code>rintros</code> for <code>sum_cancel</code> but am using the Lean web editor to draft this)<br>
Can someone point me in the right direction? Thanks!</p>

<a name="189457413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sum%20type%20cancellation/near/189457413" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/08613Sumtypecancellation.html#189457413">Mario Carneiro (Mar 02 2020 at 01:51)</a>:</h4>
<p>The theorem is false. <code>nat ⊕ empty</code> is isomorphic to <code>nat ⊕ nat</code></p>

<a name="189457457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sum%20type%20cancellation/near/189457457" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/08613Sumtypecancellation.html#189457457">Mario Carneiro (Mar 02 2020 at 01:52)</a>:</h4>
<p>By the way, the computable version of <code>bijection</code> is called <code>equiv</code> and there is a sizeable mathlib file about it</p>

<a name="189457514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sum%20type%20cancellation/near/189457514" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/08613Sumtypecancellation.html#189457514">Bryan Gin-ge Chen (Mar 02 2020 at 01:54)</a>:</h4>
<p>(You can use <code>rintros</code> in the <a href="https://leanprover-community.github.io/lean-web-editor" target="_blank" title="https://leanprover-community.github.io/lean-web-editor">community web editor</a> if you <code>import tactic</code>.)</p>

<a name="189457726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sum%20type%20cancellation/near/189457726" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/08613Sumtypecancellation.html#189457726">Grayson Burton (Mar 02 2020 at 02:01)</a>:</h4>
<p>Oh cool. Thanks! <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> <span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span></p>

<a name="189457783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sum%20type%20cancellation/near/189457783" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/08613Sumtypecancellation.html#189457783">Mario Carneiro (Mar 02 2020 at 02:02)</a>:</h4>
<p>The theorem is true for cancelling <code>option</code>, or more generally if <code>α</code> is finite, but I don't think it is computable</p>

<a name="189457911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sum%20type%20cancellation/near/189457911" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/08613Sumtypecancellation.html#189457911">Mario Carneiro (Mar 02 2020 at 02:06)</a>:</h4>
<p>Actually, I think it might be computable. If <code>f : option A -&gt; option B</code> has an inverse <code>g</code>, and you want to construct a function <code>A -&gt; B</code>, you check if <code>f (some a) = some b</code> so you are done, or <code>f (some a) = none</code> in which case <code>f none = some b</code>. (<code>f none</code> cannot be <code>none</code> in this case since <code>f</code> is injective.)</p>

<a name="189458034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sum%20type%20cancellation/near/189458034" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/08613Sumtypecancellation.html#189458034">Grayson Burton (Mar 02 2020 at 02:11)</a>:</h4>
<p>I'll have to see about using <code>data.equiv</code>, it seems to have gotten most of the boilerplate out of the way (like proving type isomorphism an equivalence relation).</p>

<a name="189467210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sum%20type%20cancellation/near/189467210" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/08613Sumtypecancellation.html#189467210">Grayson Burton (Mar 02 2020 at 06:49)</a>:</h4>
<p>Product types aren't cancellative either. :( There go my dreams of embedding the commutative semiring of types in a signed type commutative ring</p>

<a name="189507263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sum%20type%20cancellation/near/189507263" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/08613Sumtypecancellation.html#189507263">Reid Barton (Mar 02 2020 at 16:21)</a>:</h4>
<p><a href="https://ncatlab.org/nlab/show/Eilenberg+swindle" target="_blank" title="https://ncatlab.org/nlab/show/Eilenberg+swindle">https://ncatlab.org/nlab/show/Eilenberg+swindle</a></p>


{% endraw %}

{% include archive_update.html %}