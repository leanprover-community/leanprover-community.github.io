---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113489newmembers/84630trivialordering.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html">trivial ordering</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="187777508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187777508" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187777508">Cerek Hillen (he) (W2'20) (Feb 09 2020 at 23:05)</a>:</h4>
<p>Hey, quick question. I was wondering if there was a canonical way to show that <code>i &lt; j</code> for two naturals <code>i</code> and <code>j</code> where their value is known.</p>
<p>I know I can repeatedly apply <code>nat.le_of_succ_le_succ</code> and then use <code>nat.zero_le</code>, but that feels very cumbersome for proving something that's trivially true</p>

<a name="187777615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187777615" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187777615">Cerek Hillen (he) (W2'20) (Feb 09 2020 at 23:06)</a>:</h4>
<p>Or rather the inverse of <code>le_of_succ_le_succ</code>, <code>succ_le_succ</code> I think?</p>

<a name="187777702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187777702" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187777702">Kevin Buzzard (Feb 09 2020 at 23:09)</a>:</h4>
<p><code>norm_num</code></p>

<a name="187777714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187777714" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187777714">Kevin Buzzard (Feb 09 2020 at 23:10)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">example</span> <span class="o">:</span> <span class="mi">12345</span> <span class="bp">&lt;</span> <span class="mi">67890</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">norm_num</span>
</pre></div>

<a name="187777780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187777780" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187777780">Kevin Buzzard (Feb 09 2020 at 23:10)</a>:</h4>
<p>NB it only works if i is actually less than j.</p>

<a name="187777782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187777782" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187777782">Cerek Hillen (he) (W2'20) (Feb 09 2020 at 23:10)</a>:</h4>
<p><span aria-label="pray" class="emoji emoji-1f64f" role="img" title="pray">:pray:</span></p>
<p>I knew there had to be a better way</p>

<a name="187777810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187777810" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187777810">Kevin Buzzard (Feb 09 2020 at 23:10)</a>:</h4>
<p>When I asked that question a couple of years ago, there wasn't ;-)</p>

<a name="187777823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187777823" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187777823">Cerek Hillen (he) (W2'20) (Feb 09 2020 at 23:11)</a>:</h4>
<p>Hahahaha, glad to be here at Lean 3</p>

<a name="187777859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187777859" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187777859">Kevin Buzzard (Feb 09 2020 at 23:11)</a>:</h4>
<p>I had Lean 3, it was just that <code>import tactic</code> imported far fewer tactics.</p>

<a name="187777871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187777871" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187777871">Cerek Hillen (he) (W2'20) (Feb 09 2020 at 23:11)</a>:</h4>
<p>Ah gotcha</p>

<a name="187777883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187777883" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187777883">Cerek Hillen (he) (W2'20) (Feb 09 2020 at 23:12)</a>:</h4>
<p>Also I finished Natural Number Game recently, I really like what you and Mohammed put together</p>

<a name="187777922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187777922" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187777922">Kevin Buzzard (Feb 09 2020 at 23:12)</a>:</h4>
<p>Mathlib is a misnomer. It contains a whole bunch of other useful things too.</p>

<a name="187777943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187777943" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187777943">Kevin Buzzard (Feb 09 2020 at 23:12)</a>:</h4>
<p>I'm sorry NNG looks so amateurish. We're both mathematicians ;-)</p>

<a name="187777960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187777960" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187777960">Kevin Buzzard (Feb 09 2020 at 23:13)</a>:</h4>
<p><code>example : 5 &lt; 23 := dec_trivial </code></p>
<p>The problem with that is it doesn't scale, because it does exactly what you were suggesting to do, so with 5-digit numbers things get a bit horrible.</p>

<a name="187777962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187777962" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187777962">Cerek Hillen (he) (W2'20) (Feb 09 2020 at 23:13)</a>:</h4>
<p>I'm only looking to use it on small numbers</p>

<a name="187778006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187778006" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187778006">Kevin Buzzard (Feb 09 2020 at 23:14)</a>:</h4>
<p><code>dec_trivial</code> is a cool tactic. It says "If this statement is decidable in the sense of logic, then decide it!"</p>

<a name="187778010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187778010" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187778010">Cerek Hillen (he) (W2'20) (Feb 09 2020 at 23:14)</a>:</h4>
<div class="codehilite"><pre><span></span>  <span class="c1">-- We define a score to be a vector of natural numbers of length n. Each value</span>
  <span class="c1">-- score_i corresponds to the number of violations that occurred in the ith</span>
  <span class="c1">-- constraint.</span>
  <span class="n">def</span> <span class="n">score</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">vector</span> <span class="bp">ℕ</span> <span class="n">n</span>

  <span class="c1">-- We define an ordering on scores such that s₁ ≤ s₂ iff they are equal up to</span>
  <span class="c1">-- some index i, wherein s₁[i] ≤ s₂[i].</span>
  <span class="n">def</span> <span class="n">score_le</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">s1</span> <span class="o">:</span> <span class="n">score</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">s2</span> <span class="o">:</span> <span class="n">score</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
    <span class="bp">∃</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">),</span>
      <span class="n">nth</span> <span class="n">s1</span> <span class="bp">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">h</span><span class="bp">⟩</span> <span class="bp">≤</span> <span class="n">nth</span> <span class="n">s2</span> <span class="bp">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">h</span><span class="bp">⟩</span> <span class="bp">∧</span>
      <span class="bp">∀</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h&#39;</span> <span class="o">:</span> <span class="n">j</span> <span class="bp">&lt;</span> <span class="n">i</span><span class="o">),</span>
        <span class="n">nth</span> <span class="n">s1</span> <span class="bp">⟨</span><span class="n">j</span><span class="o">,</span> <span class="n">lt</span><span class="bp">.</span><span class="n">trans</span> <span class="n">h&#39;</span> <span class="n">h</span><span class="bp">⟩</span> <span class="bp">=</span> <span class="n">nth</span> <span class="n">s2</span> <span class="bp">⟨</span><span class="n">j</span><span class="o">,</span> <span class="n">lt</span><span class="bp">.</span><span class="n">trans</span> <span class="n">h&#39;</span> <span class="n">h</span><span class="bp">⟩</span>
</pre></div>


<p>so long as score vectors stay small at least</p>

<a name="187778014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187778014" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187778014">Kevin Buzzard (Feb 09 2020 at 23:14)</a>:</h4>
<p>And there's a proof that <code>i&lt;j</code> is decidable, and indeed you sketched the proof above. So <code>dec_trivial</code> runs through that proof.</p>

<a name="187778031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187778031" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187778031">Kevin Buzzard (Feb 09 2020 at 23:15)</a>:</h4>
<p><code>score</code>! Are you making a game? Lean pong would be cool.</p>

<a name="187778045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187778045" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187778045">Cerek Hillen (he) (W2'20) (Feb 09 2020 at 23:15)</a>:</h4>
<p>Reducing from PCP into a model of representing phonology</p>

<a name="187778062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187778062" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187778062">Kevin Buzzard (Feb 09 2020 at 23:15)</a>:</h4>
<p>Maybe that's what kids want these days.</p>

<a name="187778071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187778071" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187778071">Cerek Hillen (he) (W2'20) (Feb 09 2020 at 23:15)</a>:</h4>
<p>I'll pitch it to publishers</p>

<a name="187778129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187778129" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187778129">Cerek Hillen (he) (W2'20) (Feb 09 2020 at 23:16)</a>:</h4>
<p>"It's a game where you do computability theory proofs"</p>

<a name="187778148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187778148" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187778148">Kevin Buzzard (Feb 09 2020 at 23:16)</a>:</h4>
<p>Get CS undergrads to play it.</p>

<a name="187778186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187778186" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187778186">Kevin Buzzard (Feb 09 2020 at 23:17)</a>:</h4>
<p><code>norm_num</code> does the more sensible thing of converting everything to binary and then working with it using more sensible (but still formally verified) algorithms.</p>

<a name="187778240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187778240" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187778240">Kevin Buzzard (Feb 09 2020 at 23:19)</a>:</h4>
<p>When I asked the question you asked, there was <code>tactic.norm_num</code> but not <code>tactic.interactive.norm_num</code>, which meant that the guts were there but you couldn't use it in tactic mode. Within about a week Mario Carneiro had got it working in tactic mode and I could then do all the inequalities I wanted. There have been countless cases like this, where someone needs something technical, mentions it on the chat, and then someone else knocks it up. The whole thing is quite an amazing project.</p>

<a name="187778287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187778287" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187778287">Cerek Hillen (he) (W2'20) (Feb 09 2020 at 23:20)</a>:</h4>
<p>Yeah, I've actually been getting in trying to contribute to Lean. I'm about to start work so I'll probably hold off until I become more situated therein but don't be surprised if you find my name on some commits <span aria-label="slight smile" class="emoji emoji-1f642" role="img" title="slight smile">:slight_smile:</span></p>

<a name="187778297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187778297" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187778297">Cerek Hillen (he) (W2'20) (Feb 09 2020 at 23:21)</a>:</h4>
<p>Also I don't know enough to ask the question right, but I'll try my best: is the <code>norm_num</code> / <code>dec_trivial</code> contrast at all related to the provably correct Lean kernel(?) I've heard about?</p>

<a name="187778301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187778301" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187778301">Cerek Hillen (he) (W2'20) (Feb 09 2020 at 23:21)</a>:</h4>
<p>or since <code>norm_num</code> is formally verified is it still considered to be a provably correct member of that kernel</p>

<a name="187778343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187778343" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187778343">Kevin Buzzard (Feb 09 2020 at 23:22)</a>:</h4>
<p><code>dec_trivial</code> is just using the stupidest algorithm. <code>norm_num</code> is doing a whole lot more work -- but it is still formally verified.</p>

<a name="187778347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187778347" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187778347">Kevin Buzzard (Feb 09 2020 at 23:22)</a>:</h4>
<p>You would be able to tell if it were not formally verified -- the kernel would not let the proof go through.</p>

<a name="187778359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187778359" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187778359">Cerek Hillen (he) (W2'20) (Feb 09 2020 at 23:23)</a>:</h4>
<p>Gotcha, very cool!</p>

<a name="187778403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187778403" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187778403">Kevin Buzzard (Feb 09 2020 at 23:24)</a>:</h4>
<p>So it's doing basic integer arithmetic but with a more optimised representation (Lean's definition of a natural is just some unwieldy linked list, so the first trick is to move to the <code>num</code> class which is naturals but stored in binary)</p>

<a name="187778415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187778415" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187778415">Cerek Hillen (he) (W2'20) (Feb 09 2020 at 23:24)</a>:</h4>
<p>I vaguely remember a proof in my Formal Language Theory about how an n-ary representation with <code>n &gt; 1</code> is exponentially more efficient than unary</p>

<a name="187778416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187778416" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187778416">Cerek Hillen (he) (W2'20) (Feb 09 2020 at 23:24)</a>:</h4>
<p>so that makes sense</p>

<a name="187778420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187778420" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187778420">Kevin Buzzard (Feb 09 2020 at 23:24)</a>:</h4>
<p>It uses something which might be called reflection to construct a theorem about nums which is provably equivalent to the theorem about nats, and then proves the theorem about nums using formally verified but fast algorithms</p>

<a name="187778424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187778424" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187778424">Cerek Hillen (he) (W2'20) (Feb 09 2020 at 23:25)</a>:</h4>
<blockquote>
<p>It uses something which might be called reflection to construct a theorem about nums which is provably equivalent to the theorem about nats, and then proves the theorem about nums using formally verified but fast algorithms</p>
</blockquote>
<p>That's very cool</p>

<a name="187778436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187778436" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187778436">Kevin Buzzard (Feb 09 2020 at 23:25)</a>:</h4>
<p>1,000,000 : nat is stored as <code>succ (succ (succ (succ ...</code> so it's horrible. But in num it's just essentially the binary string.</p>

<a name="187778489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187778489" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187778489">Kevin Buzzard (Feb 09 2020 at 23:26)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">nat</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">num</span>
<span class="bp">#</span><span class="kn">print</span> <span class="n">pos_num</span>
</pre></div>


<p>to see how it actually does it.</p>

<a name="187778788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187778788" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187778788">Cerek Hillen (he) (W2'20) (Feb 09 2020 at 23:35)</a>:</h4>
<p>Hm. Looks like <code>lean-mode</code> is angry about <code>import tactic</code>. Time to try it in vscode and maybe spend my evening debugging elisp instead of writing proofs</p>

<a name="187779040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187779040" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187779040">Rob Lewis (Feb 09 2020 at 23:43)</a>:</h4>
<p>I'm about to go to bed, but to avoid a misunderstanding: <code>norm_num</code> has nothing to do with the <code>num</code> type and isn't proof by reflection. It works on terms of type <code>nat</code> that have the structure of binary numerals. I'm happy to write more tomorrow if you're really curious (and I'm sure others could explain too).</p>

<a name="187779319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187779319" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187779319">Mario Carneiro (Feb 09 2020 at 23:53)</a>:</h4>
<blockquote>
<p>Also I don't know enough to ask the question right, but I'll try my best: is the <code>norm_num</code> / <code>dec_trivial</code> contrast at all related to the provably correct Lean kernel(?) I've heard about?</p>
</blockquote>
<p>This is probably needless pedantry, but: the lean kernel is not provably correct, nor is it proven correct. It is rather the "source of truth" for all derivations done in lean, meaning that any tactics or terms that are created must pass through the kernel before being certified by it, so that as long as the kernel is correct and consistent then everything else is too. That's the "small trusted kernel" idea. (This does not mean that the kernel is bug-free, but we haven't found any soundness-critical issues in the history of lean AFAIK.)</p>

<a name="187779364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187779364" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187779364">Cerek Hillen (he) (W2'20) (Feb 09 2020 at 23:54)</a>:</h4>
<p>Definitely not needless pedantry, that's quite a big difference</p>

<a name="187779428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187779428" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187779428">Cerek Hillen (he) (W2'20) (Feb 09 2020 at 23:55)</a>:</h4>
<p>were it proven correct then all proofs validated by lean would necessarily be valid vs. their validity being motivated, right?</p>

<a name="187779437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187779437" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187779437">Mario Carneiro (Feb 09 2020 at 23:55)</a>:</h4>
<p>the question is: valid with respect to what?</p>

<a name="187779514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187779514" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187779514">Mario Carneiro (Feb 09 2020 at 23:56)</a>:</h4>
<p>Even if you prove the correctness of lean in some other formal prover, you are still trusting <em>that</em> prover as the source of truth. You can't eliminate this any more than you can do mathematics without any axioms</p>

<a name="187779526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187779526" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187779526">Cerek Hillen (he) (W2'20) (Feb 09 2020 at 23:56)</a>:</h4>
<p>Fair point. Are you getting after the fact that proofs in Lean are necessarily valid with respect to the Lean kernel? And discrepancies between the kernel and--</p>

<a name="187779537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187779537" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187779537">Cerek Hillen (he) (W2'20) (Feb 09 2020 at 23:57)</a>:</h4>
<p>yeah I suppose that encapsulates it better than I could <span aria-label="slight smile" class="emoji emoji-1f642" role="img" title="slight smile">:slight_smile:</span></p>

<a name="187779560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187779560" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187779560">Cerek Hillen (he) (W2'20) (Feb 09 2020 at 23:57)</a>:</h4>
<p>And even in constructing a proof outside of a formal prover, it's a motivation towards its correctness because of space for error?</p>

<a name="187779609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187779609" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187779609">Mario Carneiro (Feb 09 2020 at 23:59)</a>:</h4>
<p>You can also do a "paper proof" of correctness/consistency, and in fact I have done so for lean (see <a href="https://github.com/digama0/lean-type-theory/releases/tag/v1.0" target="_blank" title="https://github.com/digama0/lean-type-theory/releases/tag/v1.0">https://github.com/digama0/lean-type-theory/releases/tag/v1.0</a>). But that doesn't cover implementation correctness, only correctness of the underlying type theory</p>

<a name="187779615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187779615" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187779615">Mario Carneiro (Feb 09 2020 at 23:59)</a>:</h4>
<p>And it is still subject to general issues with paper proofs, namely gaps in mathematical presentation and human error</p>

<a name="187779869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187779869" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187779869">Cerek Hillen (he) (W2'20) (Feb 10 2020 at 00:02)</a>:</h4>
<p>I'll take a look at the proof. And that all makes sense</p>

<a name="187779903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187779903" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187779903">Mario Carneiro (Feb 10 2020 at 00:03)</a>:</h4>
<p>The proof shows that lean is consistent relative to ZFC with omega inaccessible cardinals (which are needed for the universe hierarchy)</p>

<a name="187779943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187779943" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187779943">Cerek Hillen (he) (W2'20) (Feb 10 2020 at 00:04)</a>:</h4>
<p>I don't have a great mathematical maturity--I'm familiar with ZFC, but not with omega inaccessible carindals</p>

<a name="187779961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187779961" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187779961">Cerek Hillen (he) (W2'20) (Feb 10 2020 at 00:05)</a>:</h4>
<p>What are they?</p>

<a name="187779962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187779962" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187779962">Mario Carneiro (Feb 10 2020 at 00:05)</a>:</h4>
<p>That's omega many (i.e. indexed by natural numbers) inaccessible cardinals, in an increasing sequence</p>

<a name="187779971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187779971" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187779971">Cerek Hillen (he) (W2'20) (Feb 10 2020 at 00:05)</a>:</h4>
<p>Gotcha!</p>

<a name="187779987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187779987" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187779987">Mario Carneiro (Feb 10 2020 at 00:05)</a>:</h4>
<p>an inaccessible cardinal is basically a set which is large enough to model ZFC</p>

<a name="187779998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187779998" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187779998">Mario Carneiro (Feb 10 2020 at 00:05)</a>:</h4>
<p>so you have a whole sequence of nested models of ZFC</p>

<a name="187780050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187780050" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187780050">Mario Carneiro (Feb 10 2020 at 00:06)</a>:</h4>
<p>It's a pretty weak condition as far as large cardinal assumptions go</p>

<a name="187780068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187780068" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187780068">Mario Carneiro (Feb 10 2020 at 00:07)</a>:</h4>
<p>But ZFC itself doesn't cut it because lean can prove ZFC is consistent</p>

<a name="187780135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187780135" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187780135">Cerek Hillen (he) (W2'20) (Feb 10 2020 at 00:08)</a>:</h4>
<p>Ah interesting, I wasn't aware that you could prove ZFC's consistency in Lean. That's very cool</p>

<a name="187780150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187780150" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187780150">Mario Carneiro (Feb 10 2020 at 00:09)</a>:</h4>
<p>See the file <code>set_theory.zfc</code> in mathlib, which explicitly constructs a model</p>

<a name="187780168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/trivial%20ordering/near/187780168" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/84630trivialordering.html#187780168">Cerek Hillen (he) (W2'20) (Feb 10 2020 at 00:09)</a>:</h4>
<p>found it, will review later</p>


{% endraw %}

{% include archive_update.html %}