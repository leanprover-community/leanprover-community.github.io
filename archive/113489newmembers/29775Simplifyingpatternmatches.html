---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113489newmembers/29775Simplifyingpatternmatches.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/29775Simplifyingpatternmatches.html">Simplifying pattern matches</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="160005959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20pattern%20matches/near/160005959" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/29775Simplifyingpatternmatches.html#160005959">Plam (Mar 05 2019 at 14:17)</a>:</h4>
<p>I observe different behaviour in the simplifier that depends on if I use my own <code>add</code> or Lean's native <code>add</code>. I've done my best to make my add match Lean's (found here: <a href="https://github.com/leanprover/lean/blob/ceacfa7445953cbc8860ddabc55407430a9ca5c3/library/init/core.lean#L399-L405" target="_blank" title="https://github.com/leanprover/lean/blob/ceacfa7445953cbc8860ddabc55407430a9ca5c3/library/init/core.lean#L399-L405">https://github.com/leanprover/lean/blob/ceacfa7445953cbc8860ddabc55407430a9ca5c3/library/init/core.lean#L399-L405</a>)</p>
<p>In particular,  the simplify tactic fails to simplify with my own <code>add</code>. Here's code using my <code>add</code>:</p>
<div class="codehilite"><pre><span></span><span class="kn">namespace</span> <span class="n">hidden</span>
<span class="n">def</span> <span class="n">add</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="n">m</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">m</span>
<span class="bp">|</span> <span class="n">m</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="o">(</span><span class="n">add</span> <span class="n">m</span> <span class="n">n</span><span class="o">)</span>

<span class="n">local</span> <span class="kn">infix</span> <span class="bp">`</span> <span class="bp">+</span> <span class="bp">`</span> <span class="o">:=</span> <span class="n">add</span>
<span class="n">local</span> <span class="n">attribute</span> <span class="o">[</span><span class="n">pattern</span><span class="o">]</span> <span class="n">add</span>

<span class="n">def</span> <span class="n">mult</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">mult</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span>

<span class="n">local</span> <span class="kn">infix</span> <span class="bp">`*`</span> <span class="o">:=</span> <span class="n">mult</span>

<span class="n">def</span> <span class="n">exp</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">m</span> <span class="bp">*</span> <span class="n">exp</span> <span class="n">n</span>

<span class="n">local</span> <span class="kn">infix</span> <span class="bp">`</span><span class="err">^</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">exp</span>

<span class="kn">theorem</span> <span class="n">exp_zero_one</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span><span class="o">,</span> <span class="n">m</span> <span class="err">^</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">intros</span><span class="o">,</span> <span class="n">refl</span><span class="o">}</span>

<span class="kn">theorem</span> <span class="n">exp_one_self</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span><span class="o">,</span> <span class="n">m</span> <span class="err">^</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">m</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">exp</span><span class="o">]</span>
  <span class="kn">end</span>
<span class="kn">end</span> <span class="n">hidden</span>
</pre></div>


<p>From this I get <code>simplify tactic failed to simplify</code>. Simply removing my definition of <code>add</code> (code below) lets the simplifier advance to <code>(n + 1)*1 = n + 1</code></p>
<div class="codehilite"><pre><span></span><span class="kn">namespace</span> <span class="n">hidden</span>
<span class="n">def</span> <span class="n">mult</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">mult</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span>

<span class="n">local</span> <span class="kn">infix</span> <span class="bp">`*`</span> <span class="o">:=</span> <span class="n">mult</span>

<span class="n">def</span> <span class="n">exp</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">m</span> <span class="bp">*</span> <span class="n">exp</span> <span class="n">n</span>

<span class="n">local</span> <span class="kn">infix</span> <span class="bp">`</span><span class="err">^</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">exp</span>

<span class="kn">theorem</span> <span class="n">exp_zero_one</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span><span class="o">,</span> <span class="n">m</span> <span class="err">^</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">intros</span><span class="o">,</span> <span class="n">refl</span><span class="o">}</span>

<span class="kn">theorem</span> <span class="n">exp_one_self</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span><span class="o">,</span> <span class="n">m</span> <span class="err">^</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">m</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">exp</span><span class="o">]</span>
  <span class="kn">end</span>
<span class="kn">end</span> <span class="n">hidden</span>
</pre></div>

<a name="160009446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20pattern%20matches/near/160009446" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/29775Simplifyingpatternmatches.html#160009446">Johan Commelin (Mar 05 2019 at 14:58)</a>:</h4>
<p><span class="user-mention" data-user-id="209413">@Plam</span> The simplifier doesn't use magic. It simplifies expressions using lemmas that are tagged with <code>@[simp]</code> in front of them. Since you didn't write any such lemmas for your own <code>add</code>, the simplifier doesn't help you...</p>

<a name="160009515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20pattern%20matches/near/160009515" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/29775Simplifyingpatternmatches.html#160009515">Plam (Mar 05 2019 at 14:58)</a>:</h4>
<p>Hm. I thought using <code>simp only</code> would avoid those lemmas being used. Is that not the case?</p>

<a name="160010782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20pattern%20matches/near/160010782" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/29775Simplifyingpatternmatches.html#160010782">Wojciech Nawrocki (Mar 05 2019 at 15:12)</a>:</h4>
<p>By default, <code>simp</code> will try to simplify the goal using all available lemmas marked with <code>@[simp]</code>. <code>simp only [h1, h2, ..]</code> will not use any of those, but only the lemmas <code>h1, h2, ..</code> that you provide. However, <code>exp</code> does not seem to be a simplification lemma, as those are usually of the form <code>complicated_expression = simplified_expression</code> (the ordering matters - the left side should be the more complicated one). In your case, <code>exp</code> is the definition of exponentiation and I'm not sure if <code>simp</code> can use that. You could try using <code>unfold exp</code> to expand the definition of <code>exp</code>. <em>EDIT</em>: Oh, it seems it can use that, fair enough. Still, you will need to provide more lemmas so that the whole expression can be simplified, as just <code>exp</code> is not enough. Marking some lemmas with <code>@[simp]</code> is the preferred way of doing this.</p>

<a name="160011456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20pattern%20matches/near/160011456" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/29775Simplifyingpatternmatches.html#160011456">Plam (Mar 05 2019 at 15:21)</a>:</h4>
<p>Thanks for the guidance! Yep, <code>exp</code> is not enough. What I'm confused about is what I need to add to <code>add</code> to make it behave like the Lean add when simplifying. In particular, changing <code>exp</code> to pattern match on <code>(nat.succ n) rather than </code>(n + 1)` makes the two cases behave the same.</p>
<p>(In both below proofs I am using  <code>simp only</code>)</p>
<p>Here is a working proof:</p>
<div class="codehilite"><pre><span></span><span class="kn">namespace</span> <span class="n">hidden</span>
<span class="n">def</span> <span class="n">add</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="n">m</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">m</span>
<span class="bp">|</span> <span class="n">m</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="o">(</span><span class="n">add</span> <span class="n">m</span> <span class="n">n</span><span class="o">)</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_add</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">add</span><span class="bp">⟩</span>
<span class="n">attribute</span> <span class="o">[</span><span class="n">pattern</span><span class="o">]</span> <span class="n">add</span>

<span class="n">def</span> <span class="n">mult</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">mult</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span>

<span class="n">local</span> <span class="kn">infix</span> <span class="bp">`*`</span> <span class="o">:=</span> <span class="n">mult</span>

<span class="n">def</span> <span class="n">exp</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">m</span> <span class="bp">*</span> <span class="n">exp</span> <span class="n">n</span>

<span class="n">local</span> <span class="kn">infix</span> <span class="bp">`</span><span class="err">^</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">exp</span>

<span class="kn">theorem</span> <span class="n">mult_one</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span> <span class="bp">*</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">theorem</span> <span class="n">exp_one_self</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span><span class="o">,</span> <span class="n">m</span> <span class="err">^</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">m</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">exp</span><span class="o">,</span> <span class="n">mult_one</span><span class="o">]</span>
  <span class="kn">end</span>
<span class="kn">end</span> <span class="n">hidden</span>
</pre></div>


<p>Here is a failed proof:</p>
<div class="codehilite"><pre><span></span><span class="kn">namespace</span> <span class="n">hidden</span>
<span class="n">def</span> <span class="n">add</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="n">m</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">m</span>
<span class="bp">|</span> <span class="n">m</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="o">(</span><span class="n">add</span> <span class="n">m</span> <span class="n">n</span><span class="o">)</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_add</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">add</span><span class="bp">⟩</span>
<span class="n">attribute</span> <span class="o">[</span><span class="n">pattern</span><span class="o">]</span> <span class="n">add</span>

<span class="n">def</span> <span class="n">mult</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">mult</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span>

<span class="n">local</span> <span class="kn">infix</span> <span class="bp">`*`</span> <span class="o">:=</span> <span class="n">mult</span>

<span class="n">def</span> <span class="n">exp</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">m</span> <span class="bp">*</span> <span class="n">exp</span> <span class="n">n</span>

<span class="n">local</span> <span class="kn">infix</span> <span class="bp">`</span><span class="err">^</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">exp</span>

<span class="kn">theorem</span> <span class="n">mult_one</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span> <span class="bp">*</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">theorem</span> <span class="n">exp_one_self</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span><span class="o">,</span> <span class="n">m</span> <span class="err">^</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">m</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">exp</span><span class="o">,</span> <span class="n">mult_one</span><span class="o">]</span>
  <span class="kn">end</span>
<span class="kn">end</span> <span class="n">hidden</span>
</pre></div>


<p>The only difference is defining the inductive case of <code>exp</code> on <code>(nat.succ n)</code> vs <code>(n + 1)</code></p>

<a name="160011631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20pattern%20matches/near/160011631" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/29775Simplifyingpatternmatches.html#160011631">Plam (Mar 05 2019 at 15:23)</a>:</h4>
<p>BTW, on the being able to use <code>exp</code> in the simplifier, I believe this is because of magical trickery on the part of the equation compiler: "The example above shows that [some defining equations] hold definitionally [...].<br>
The equation compiler tries to ensure that this holds whenever possible, as is the case with straightforward structural induction. In other situations, however, reductions hold only propositionally, which is to say, they are equational theorems that must be applied explicitly. The equation compiler generates such theorems internally. They are not meant to be used directly by the user; rather, the simp and rewrite tactics are configured to use them when necessary."</p>

<a name="160022025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20pattern%20matches/near/160022025" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/29775Simplifyingpatternmatches.html#160022025">Kevin Buzzard (Mar 05 2019 at 17:27)</a>:</h4>
<p>This is hellish to work with because Lean already has an instance of <code>has_add nat</code></p>

<a name="160022417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20pattern%20matches/near/160022417" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/29775Simplifyingpatternmatches.html#160022417">Kevin Buzzard (Mar 05 2019 at 17:31)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">mult</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">mult</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span>
</pre></div>


<p>I think the <code>(n + 1)</code> is Lean's add, and the <code>mult n + m</code> is your add. This is madness!</p>

<a name="160022480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20pattern%20matches/near/160022480" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/29775Simplifyingpatternmatches.html#160022480">Kevin Buzzard (Mar 05 2019 at 17:32)</a>:</h4>
<p>I think I would recommend rolling your own nat.</p>

<a name="160022666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20pattern%20matches/near/160022666" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/29775Simplifyingpatternmatches.html#160022666">Plam (Mar 05 2019 at 17:34)</a>:</h4>
<p>OK. Happy to avoid rolling my own nat, but just to check: if there weren't already duplicate definitions floating around, using <code>pattern</code> on add would let me pattern match in that way?</p>

<a name="160022812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20pattern%20matches/near/160022812" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/29775Simplifyingpatternmatches.html#160022812">Kevin Buzzard (Mar 05 2019 at 17:36)</a>:</h4>
<p>The equation compiler wants to use Lean's inductive definition of nat. So it wants you to define things for zero and succ. If there weren't duplicate definitions then yes you can use <code>pattern</code> to make the equation compiler look nicer.</p>

<a name="160022825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20pattern%20matches/near/160022825" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/29775Simplifyingpatternmatches.html#160022825">Kevin Buzzard (Mar 05 2019 at 17:36)</a>:</h4>
<p>But for your failed proof it's really hard to make any progress</p>

<a name="160023058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20pattern%20matches/near/160023058" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/29775Simplifyingpatternmatches.html#160023058">Kevin Buzzard (Mar 05 2019 at 17:39)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">exp</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">m</span> <span class="bp">*</span> <span class="n">exp</span> <span class="n">n</span>

<span class="bp">#</span><span class="kn">print</span> <span class="kn">prefix</span> <span class="n">hidden</span><span class="bp">.</span><span class="n">exp</span>
</pre></div>


<p>Insert that after your definition of <code>exp</code>.</p>

<a name="160023078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20pattern%20matches/near/160023078" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/29775Simplifyingpatternmatches.html#160023078">Kevin Buzzard (Mar 05 2019 at 17:39)</a>:</h4>
<p>There you can see the secret equations which Lean will use when you write <code>simp only [exp]</code>.</p>

<a name="160023194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20pattern%20matches/near/160023194" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/29775Simplifyingpatternmatches.html#160023194">Kevin Buzzard (Mar 05 2019 at 17:40)</a>:</h4>
<p>But <code>rw hidden.exp.equations._eqn_2</code> fails, because it is looking for <code>exp m (n + 1) = m*exp m n</code> where that <code>+</code> is, I believe, Lean's <code>+</code> on nat.</p>

<a name="160023258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20pattern%20matches/near/160023258" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/29775Simplifyingpatternmatches.html#160023258">Kevin Buzzard (Mar 05 2019 at 17:41)</a>:</h4>
<p>Oh no I'm wrong</p>

<a name="160023325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20pattern%20matches/near/160023325" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/29775Simplifyingpatternmatches.html#160023325">Kevin Buzzard (Mar 05 2019 at 17:42)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">exp</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">m</span> <span class="bp">*</span> <span class="n">exp</span> <span class="n">n</span>

<span class="kn">set_option</span> <span class="n">pp</span><span class="bp">.</span><span class="n">all</span> <span class="n">true</span>
<span class="bp">#</span><span class="kn">print</span> <span class="kn">prefix</span> <span class="n">hidden</span><span class="bp">.</span><span class="n">exp</span>
</pre></div>

<a name="160023338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20pattern%20matches/near/160023338" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/29775Simplifyingpatternmatches.html#160023338">Kevin Buzzard (Mar 05 2019 at 17:42)</a>:</h4>
<p><code>hidden.exp.equations._eqn_2</code> is using your add.</p>

<a name="160023525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20pattern%20matches/near/160023525" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/29775Simplifyingpatternmatches.html#160023525">Kevin Buzzard (Mar 05 2019 at 17:45)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">exp_one_self</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span><span class="o">,</span> <span class="n">m</span> <span class="err">^</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">m</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">begin</span>
  <span class="c1">-- goal (n + 1)^1 = n + 1</span>
  <span class="k">show</span> <span class="n">hidden</span><span class="bp">.</span><span class="n">exp</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_add</span><span class="bp">.</span><span class="n">add</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">hidden</span><span class="bp">.</span><span class="n">has_add</span> <span class="n">n</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_one</span><span class="bp">.</span><span class="n">one</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat</span><span class="bp">.</span><span class="n">has_one</span><span class="o">))</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">has_add</span><span class="bp">.</span><span class="n">add</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">hidden</span><span class="bp">.</span><span class="n">has_add</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_zero</span><span class="bp">.</span><span class="n">zero</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat</span><span class="bp">.</span><span class="n">has_zero</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_one</span><span class="bp">.</span><span class="n">one</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat</span><span class="bp">.</span><span class="n">has_one</span><span class="o">))</span>
    <span class="bp">=</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">hidden</span><span class="bp">.</span><span class="n">exp</span><span class="bp">.</span><span class="n">equations</span><span class="bp">._</span><span class="n">eqn_2</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="mi">0</span><span class="o">,</span>
  <span class="c1">-- progress!</span>
  <span class="n">sorry</span>
  <span class="kn">end</span>
<span class="kn">end</span> <span class="n">hidden</span>
</pre></div>

<a name="160023591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20pattern%20matches/near/160023591" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/29775Simplifyingpatternmatches.html#160023591">Plam (Mar 05 2019 at 17:46)</a>:</h4>
<p>It even doesn't work with lots of renaming:</p>
<div class="codehilite"><pre><span></span><span class="kn">namespace</span> <span class="n">hidden</span>
<span class="n">def</span> <span class="n">my_add</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="n">m</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">m</span>
<span class="bp">|</span> <span class="n">m</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="o">(</span><span class="n">my_add</span> <span class="n">m</span> <span class="n">n</span><span class="o">)</span>

<span class="kn">precedence</span> <span class="bp">`&amp;`</span> <span class="o">:</span> <span class="mi">1</span>
<span class="kn">infix</span> <span class="bp">`&amp;`</span> <span class="o">:=</span> <span class="n">my_add</span>
<span class="n">attribute</span> <span class="o">[</span><span class="n">pattern</span><span class="o">]</span> <span class="n">my_add</span>

<span class="n">def</span> <span class="n">mult</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">&amp;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">mult</span> <span class="n">n</span> <span class="bp">&amp;</span> <span class="n">m</span>

<span class="n">local</span> <span class="kn">infix</span> <span class="bp">`*`</span> <span class="o">:=</span> <span class="n">mult</span>

<span class="n">def</span> <span class="n">exp</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">&amp;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">m</span> <span class="bp">*</span> <span class="n">exp</span> <span class="n">n</span>

<span class="n">local</span> <span class="kn">infix</span> <span class="bp">`</span><span class="err">^</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">exp</span>

<span class="kn">theorem</span> <span class="n">mult_one</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span> <span class="bp">*</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">theorem</span> <span class="n">exp_one_self</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span><span class="o">,</span> <span class="n">m</span> <span class="err">^</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">m</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">&amp;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">exp</span><span class="o">,</span> <span class="n">mult_one</span><span class="o">]</span>
  <span class="kn">end</span>
<span class="kn">end</span> <span class="n">hidden</span>
</pre></div>

<a name="160023592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20pattern%20matches/near/160023592" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/29775Simplifyingpatternmatches.html#160023592">Kevin Buzzard (Mar 05 2019 at 17:46)</a>:</h4>
<p>I managed to convert the goal into <code>(n + 1)*(n + 1)^0 = n + 1</code>.</p>

<a name="160023608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20pattern%20matches/near/160023608" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/29775Simplifyingpatternmatches.html#160023608">Plam (Mar 05 2019 at 17:46)</a>:</h4>
<p>Oh, cool! Lemme have a look</p>

<a name="160023783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20pattern%20matches/near/160023783" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/29775Simplifyingpatternmatches.html#160023783">Kevin Buzzard (Mar 05 2019 at 17:49)</a>:</h4>
<p><code>instance : has_add ℕ := ⟨add⟩</code>. This is not using Lean correctly, really. Lean already has an instance of <code>has_add nat</code> and you've defined a second one. Now you don't really know which one Lean will use. The problem is that nat has a bunch of structure and you are attempting to over-ride parts of that structure, but you have not done it cleverly enough to over-ride Lean's underlying trust that you're using structures and instances sensibly. This might be possible, but you'll probably have to talk to a computer scientist about how to make it work. By far the easiest fix is to roll your own nat, it seems to me.</p>

<a name="160023933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20pattern%20matches/near/160023933" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/29775Simplifyingpatternmatches.html#160023933">Plam (Mar 05 2019 at 17:51)</a>:</h4>
<p>Good to know. I hadn't got to the sections on type classes yet -- thought there might be clever ways not to have them be unique in Lean. Still curious why my version above with <code>&amp;</code> doesn't work!</p>

<a name="160024218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20pattern%20matches/near/160024218" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/29775Simplifyingpatternmatches.html#160024218">Kevin Buzzard (Mar 05 2019 at 17:55)</a>:</h4>
<p>Your simp fails because this already fails:</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">exp_one_self</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span><span class="o">,</span> <span class="n">m</span> <span class="err">^</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">m</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">&amp;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">begin</span>
  <span class="n">rw</span> <span class="n">hidden</span><span class="bp">.</span><span class="n">exp</span><span class="bp">.</span><span class="n">equations</span><span class="bp">._</span><span class="n">eqn_2</span> <span class="o">(</span><span class="n">n</span><span class="bp">&amp;</span><span class="mi">1</span><span class="o">)</span> <span class="mi">0</span><span class="o">,</span>
  <span class="kn">end</span>
</pre></div>

<a name="160024359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20pattern%20matches/near/160024359" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/29775Simplifyingpatternmatches.html#160024359">Kevin Buzzard (Mar 05 2019 at 17:57)</a>:</h4>
<p>I think.</p>

<a name="160024660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20pattern%20matches/near/160024660" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/29775Simplifyingpatternmatches.html#160024660">Plam (Mar 05 2019 at 18:00)</a>:</h4>
<p>Hm. Looks like I maybe misunderstood pattern matching -- it's not picking apart the exponent in terms of <code>&amp;</code> like I'd expected. This works:</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">exp_one_self</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span><span class="o">,</span> <span class="n">m</span> <span class="err">^</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">m</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">&amp;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">begin</span>
  <span class="k">have</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">0</span><span class="bp">&amp;</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">hidden</span><span class="bp">.</span><span class="n">exp</span><span class="bp">.</span><span class="n">equations</span><span class="bp">._</span><span class="n">eqn_2</span> <span class="o">(</span><span class="n">n</span><span class="bp">&amp;</span><span class="o">(</span><span class="mi">0</span><span class="bp">&amp;</span><span class="mi">1</span><span class="o">))</span> <span class="mi">0</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">exp</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">mult_one</span>
  <span class="kn">end</span>
</pre></div>

<a name="160024703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20pattern%20matches/near/160024703" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/29775Simplifyingpatternmatches.html#160024703">Kevin Buzzard (Mar 05 2019 at 18:01)</a>:</h4>
<p>I think that what <code>simp only [exp]</code> does under the hood is that it thinks "OK so I have these two equation lemmas, let's try and get one of them to work. Let's take a look at what we have here". Your equation lemmas tell us what <code>m^0</code> and what <code>m^(n&amp;1)</code> evaluate to. But Lean sees <code>m^1</code>, so it thinks "OK, so what is this 1? OK so I know it's a nat, so it's either 0 or succ of something. Aah, in fact I know what 1 is, it's succ 0, so this is great, hopefully there's an equation lemma mentioning <code>m^(nat.succ n)</code>...aww crap, the user has done something really weird with making <code>&amp;</code> a pattern and I am completely confused. Why didn't he use normal pattern matching with 0 and succ like the equation compiler does by default? I give up"</p>

<a name="160024808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20pattern%20matches/near/160024808" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/29775Simplifyingpatternmatches.html#160024808">Kevin Buzzard (Mar 05 2019 at 18:02)</a>:</h4>
<p>The equation compiler knows that nats are built using 0 and succ, but you have managed to persuade the equation compiler to build something using 0 and <code>&amp;</code>, and then its inbuilt algorithms in <code>simp</code> get confused.</p>

<a name="160024839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20pattern%20matches/near/160024839" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/29775Simplifyingpatternmatches.html#160024839">Kevin Buzzard (Mar 05 2019 at 18:03)</a>:</h4>
<p>All of this can be fixed if you roll your own nat, because then the equation compiler will be expecting what you will give it by default.</p>

<a name="160025228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20pattern%20matches/near/160025228" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/29775Simplifyingpatternmatches.html#160025228">Plam (Mar 05 2019 at 18:08)</a>:</h4>
<p>Doesn't your model predict that if I defined my own nats and then define a my_add and a pattern for them and then defined exp in terms of that pattern, it would still get confused? And if that's true, why doesn't it get confused when I define exp in terms of _normal_ (+), which is, after all, a pattern?</p>

<a name="160026303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20pattern%20matches/near/160026303" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/29775Simplifyingpatternmatches.html#160026303">Kevin Buzzard (Mar 05 2019 at 18:21)</a>:</h4>
<p>My understanding is certainly partially confused yes, but I know for sure that if you define your own nat then it works like a dream, because I wrote that blog post I cited earlier, and it's not working for you, and you're definitely doing something unexpected because you have made the equation compiler generate unhelpful lemmas as opposed to helpful ones.</p>

<a name="160026573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20pattern%20matches/near/160026573" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/29775Simplifyingpatternmatches.html#160026573">Plam (Mar 05 2019 at 18:24)</a>:</h4>
<p>Gotcha. I guess the lesson is to steer clear of stomping on the builtins. Thanks for the help btw!</p>

<a name="160026648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20pattern%20matches/near/160026648" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/29775Simplifyingpatternmatches.html#160026648">Kevin Buzzard (Mar 05 2019 at 18:25)</a>:</h4>
<p>Your patterns managed to get the equation compiler to generate some funky equation lemmas, and that seemed to be your downfall.</p>

<a name="160027369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20pattern%20matches/near/160027369" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/29775Simplifyingpatternmatches.html#160027369">Kevin Buzzard (Mar 05 2019 at 18:33)</a>:</h4>
<p>So looking back, at least some of what I'm saying makes some sense. I should say that I have no idea how the equation compiler works and I've never looked at the Lean source code. But when you defined <code>exp</code> using (nat.succ) you get the right equation lemmas:</p>
<div class="codehilite"><pre><span></span><span class="kn">namespace</span> <span class="n">hidden</span>
<span class="n">def</span> <span class="n">add</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="n">m</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">m</span>
<span class="bp">|</span> <span class="n">m</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="o">(</span><span class="n">add</span> <span class="n">m</span> <span class="n">n</span><span class="o">)</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_add</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">add</span><span class="bp">⟩</span>
<span class="n">attribute</span> <span class="o">[</span><span class="n">pattern</span><span class="o">]</span> <span class="n">add</span>

<span class="n">def</span> <span class="n">mult</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">mult</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span>

<span class="n">local</span> <span class="kn">infix</span> <span class="bp">`*`</span> <span class="o">:=</span> <span class="n">mult</span>

<span class="n">def</span> <span class="n">exp</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">m</span> <span class="bp">*</span> <span class="n">exp</span> <span class="n">n</span>

<span class="bp">#</span><span class="kn">print</span> <span class="kn">prefix</span> <span class="n">hidden</span><span class="bp">.</span><span class="n">exp</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">hidden.exp.equations._eqn_1 : ∀ (m : ℕ), exp m 0 = 1</span>
<span class="cm">hidden.exp.equations._eqn_2 : ∀ (m n : ℕ), exp m (nat.succ n) = m*exp m n</span>
<span class="cm">-/</span>


<span class="n">def</span> <span class="n">exp&#39;</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">m</span> <span class="bp">*</span> <span class="n">exp&#39;</span> <span class="n">n</span>

<span class="bp">#</span><span class="kn">print</span> <span class="kn">prefix</span> <span class="n">hidden</span><span class="bp">.</span><span class="n">exp&#39;</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">hidden.exp&#39;.equations._eqn_1 : ∀ (m : ℕ), exp&#39; m 0 = 1</span>
<span class="cm">hidden.exp&#39;.equations._eqn_2 : ∀ (m n : ℕ), exp&#39; m (n + 1) = m*exp&#39; m n</span>
<span class="cm">-/</span>

<span class="c1">-- and what is that `n + 1` exactly?</span>

<span class="kn">set_option</span> <span class="n">pp</span><span class="bp">.</span><span class="kn">notation</span> <span class="n">false</span>
<span class="kn">set_option</span> <span class="n">pp</span><span class="bp">.</span><span class="n">implicit</span> <span class="n">true</span>
<span class="bp">#</span><span class="kn">print</span> <span class="kn">prefix</span> <span class="n">hidden</span><span class="bp">.</span><span class="n">exp&#39;</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">hidden.exp&#39;.equations._eqn_1 : ∀ (m : nat), @eq nat (exp&#39; m 0) 1</span>
<span class="cm">hidden.exp&#39;.equations._eqn_2 : ∀ (m n : nat), @eq nat (exp&#39; m (@has_add.add nat hidden.has_add n 1)) (mult m (exp&#39; m n))</span>
<span class="cm">-/</span>

<span class="c1">-- it&#39;s `hidden.add n 1`</span>
<span class="kn">end</span> <span class="n">hidden</span>
</pre></div>


<p>Using your hidden add as a pattern you can over-ride the choice Lean wants to make, and it seems that the upshot is that you get equation lemmas which the simplifier can't use, for some reason I do not fully understand because I do not really know how the simplifier works other than the fact that I know <code>simp [exp]</code> tries to use the equation lemmas.</p>

<a name="160028163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20pattern%20matches/near/160028163" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/29775Simplifyingpatternmatches.html#160028163">Plam (Mar 05 2019 at 18:40)</a>:</h4>
<p>Fiddling with this is in the <code>&amp;</code> case I suspect the issue could be desugaring of numerals. Maybe <code>1</code> gets converted straight to <code>nat.succ n</code> and so never goes through <code>my_add</code>. Not sure though</p>

<a name="160032112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20pattern%20matches/near/160032112" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/29775Simplifyingpatternmatches.html#160032112">Kevin Buzzard (Mar 05 2019 at 19:23)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">set_option</span> <span class="n">pp</span><span class="bp">.</span><span class="n">numerals</span> <span class="n">false</span>
<span class="bp">#</span><span class="kn">check</span> <span class="mi">1</span> <span class="c1">-- has_one.one ℕ : ℕ</span>
<span class="kn">definition</span> <span class="n">X</span> <span class="o">:</span> <span class="n">has_one</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span>
<span class="bp">#</span><span class="kn">print</span> <span class="n">X</span> <span class="c1">-- nat.has_one</span>
<span class="bp">#</span><span class="kn">print</span> <span class="n">nat</span><span class="bp">.</span><span class="n">has_one</span> <span class="c1">-- one := nat.succ nat.zero</span>
</pre></div>

<a name="160033479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20pattern%20matches/near/160033479" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/29775Simplifyingpatternmatches.html#160033479">Kevin Buzzard (Mar 05 2019 at 19:41)</a>:</h4>
<p>1 is indeed succ zero</p>


{% endraw %}

{% include archive_update.html %}