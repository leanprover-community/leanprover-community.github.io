---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113489newmembers/06213termhastypepybutisexpectedtohavetypepm1.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/06213termhastypepybutisexpectedtohavetypepm1.html">term has type p y but is expected to have type p ?m_1[_]</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="150728969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/term%20has%20type%20p%20y%20but%20is%20expected%20to%20have%20type%20p%20%3Fm_1%5B_%5D/near/150728969" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/06213termhastypepybutisexpectedtohavetypepm1.html#150728969">Alistair Tucker (Dec 02 2018 at 16:48)</a>:</h4>
<p>Am I trying to do something impossible?</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">mwe</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">apply</span> <span class="n">exists</span><span class="bp">.</span><span class="n">intro</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">hy</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>

<a name="150729021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/term%20has%20type%20p%20y%20but%20is%20expected%20to%20have%20type%20p%20%3Fm_1%5B_%5D/near/150729021" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/06213termhastypepybutisexpectedtohavetypepm1.html#150729021">Kevin Buzzard (Dec 02 2018 at 16:50)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">mwe</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">h</span>
</pre></div>


<p>So the theorem is true, at least :-)</p>

<a name="150729038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/term%20has%20type%20p%20y%20but%20is%20expected%20to%20have%20type%20p%20%3Fm_1%5B_%5D/near/150729038" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/06213termhastypepybutisexpectedtohavetypepm1.html#150729038">Kevin Buzzard (Dec 02 2018 at 16:51)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">mwe</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">exists</span><span class="bp">.</span><span class="n">intro</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">hy</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>

<a name="150729091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/term%20has%20type%20p%20y%20but%20is%20expected%20to%20have%20type%20p%20%3Fm_1%5B_%5D/near/150729091" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/06213termhastypepybutisexpectedtohavetypepm1.html#150729091">Kenny Lau (Dec 02 2018 at 16:52)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">meta</span> <span class="n">def</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span><span class="bp">.</span><span class="n">result</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">tactic</span><span class="bp">.</span><span class="n">result</span> <span class="bp">&gt;&gt;=</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">trace</span>

<span class="kn">theorem</span> <span class="n">mwe</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">apply</span> <span class="n">exists</span><span class="bp">.</span><span class="n">intro</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span>
  <span class="n">result</span><span class="o">,</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">exists.intro ?m_1 (Exists.dcases_on h (λ (y : α) (hy : p y), ?m_2[h, y, hy]))</span>
<span class="cm">-/</span>
  <span class="n">exact</span> <span class="n">hy</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>

<a name="150729095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/term%20has%20type%20p%20y%20but%20is%20expected%20to%20have%20type%20p%20%3Fm_1%5B_%5D/near/150729095" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/06213termhastypepybutisexpectedtohavetypepm1.html#150729095">Alistair Tucker (Dec 02 2018 at 16:52)</a>:</h4>
<p>Yes :)  But there is some reason it's in that order. I think...</p>

<a name="150729096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/term%20has%20type%20p%20y%20but%20is%20expected%20to%20have%20type%20p%20%3Fm_1%5B_%5D/near/150729096" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/06213termhastypepybutisexpectedtohavetypepm1.html#150729096">Kenny Lau (Dec 02 2018 at 16:52)</a>:</h4>
<p>(<code>result</code> is the proof term constructed at that particular moment)</p>

<a name="150729099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/term%20has%20type%20p%20y%20but%20is%20expected%20to%20have%20type%20p%20%3Fm_1%5B_%5D/near/150729099" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/06213termhastypepybutisexpectedtohavetypepm1.html#150729099">Kenny Lau (Dec 02 2018 at 16:52)</a>:</h4>
<p>and you can see why this is impossible</p>

<a name="150729154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/term%20has%20type%20p%20y%20but%20is%20expected%20to%20have%20type%20p%20%3Fm_1%5B_%5D/near/150729154" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/06213termhastypepybutisexpectedtohavetypepm1.html#150729154">Kevin Buzzard (Dec 02 2018 at 16:54)</a>:</h4>
<p>After your application of <code>exists.intro</code> one of your goals has a metavariable, which is not at all ideal. I would recommend not using <code>apply exists.intro</code> for this sort of reason.</p>

<a name="150729224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/term%20has%20type%20p%20y%20but%20is%20expected%20to%20have%20type%20p%20%3Fm_1%5B_%5D/near/150729224" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/06213termhastypepybutisexpectedtohavetypepm1.html#150729224">Kevin Buzzard (Dec 02 2018 at 16:56)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">mwe</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">apply</span> <span class="n">exists</span><span class="bp">.</span><span class="n">intro</span><span class="o">,</span>
  <span class="c1">-- you now have two goals, and one contains a metavariable.</span>
  <span class="c1">-- this is not recommended.</span>
  <span class="c1">-- Your next line only applies to the first goal.</span>
    <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span>
    <span class="c1">-- your metavariable just got uglier.</span>
    <span class="c1">-- This is even less recommended.</span>
    <span class="n">tactic</span><span class="bp">.</span><span class="n">swap</span><span class="o">,</span>
    <span class="c1">-- we are now working with a sensible goal</span>
    <span class="c1">-- but now we need to get data from a proposition.</span>
    <span class="n">exact</span> <span class="n">classical</span><span class="bp">.</span><span class="n">some</span> <span class="n">h</span><span class="o">,</span> <span class="c1">-- I just used a noncomputable axiom</span>
  <span class="c1">-- one goal now</span>
  <span class="n">exact</span> <span class="n">classical</span><span class="bp">.</span><span class="n">some_spec</span> <span class="bp">⟨</span><span class="n">y</span><span class="o">,</span><span class="n">hy</span><span class="bp">⟩</span><span class="o">,</span> <span class="c1">-- I just undid your &quot;cases h&quot; line.</span>
<span class="kn">end</span>
</pre></div>


<p>That's a way to dig yourself out of the hole.</p>

<a name="150729230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/term%20has%20type%20p%20y%20but%20is%20expected%20to%20have%20type%20p%20%3Fm_1%5B_%5D/near/150729230" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/06213termhastypepybutisexpectedtohavetypepm1.html#150729230">Kevin Buzzard (Dec 02 2018 at 16:57)</a>:</h4>
<p><code>#print axioms mwe -- classical.choice</code></p>

<a name="150729285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/term%20has%20type%20p%20y%20but%20is%20expected%20to%20have%20type%20p%20%3Fm_1%5B_%5D/near/150729285" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/06213termhastypepybutisexpectedtohavetypepm1.html#150729285">Kenny Lau (Dec 02 2018 at 16:59)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">mwe</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">apply</span> <span class="n">exists</span><span class="bp">.</span><span class="n">intro</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">classical</span><span class="bp">.</span><span class="n">some_spec</span> <span class="bp">_</span>
<span class="kn">end</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">mwe</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">exists.intro (classical.some h) (Exists.dcases_on h (λ (y : α) (hy : p y), classical.some_spec (Exists.intro y hy)))</span>
<span class="cm">-/</span>
</pre></div>

<a name="150729286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/term%20has%20type%20p%20y%20but%20is%20expected%20to%20have%20type%20p%20%3Fm_1%5B_%5D/near/150729286" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/06213termhastypepybutisexpectedtohavetypepm1.html#150729286">Alistair Tucker (Dec 02 2018 at 16:59)</a>:</h4>
<p>Ha!  it turns out there was no good reason for putting it in that order :)<br>
What do you recommend instead of apply exists.intro?</p>

<a name="150729289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/term%20has%20type%20p%20y%20but%20is%20expected%20to%20have%20type%20p%20%3Fm_1%5B_%5D/near/150729289" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/06213termhastypepybutisexpectedtohavetypepm1.html#150729289">Kevin Buzzard (Dec 02 2018 at 16:59)</a>:</h4>
<p><code>use</code></p>

<a name="150729290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/term%20has%20type%20p%20y%20but%20is%20expected%20to%20have%20type%20p%20%3Fm_1%5B_%5D/near/150729290" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/06213termhastypepybutisexpectedtohavetypepm1.html#150729290">Reid Barton (Dec 02 2018 at 16:59)</a>:</h4>
<p>It would probably be better to do the <code>cases</code> first</p>

<a name="150729347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/term%20has%20type%20p%20y%20but%20is%20expected%20to%20have%20type%20p%20%3Fm_1%5B_%5D/near/150729347" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/06213termhastypepybutisexpectedtohavetypepm1.html#150729347">Rob Lewis (Dec 02 2018 at 17:00)</a>:</h4>
<p>It's not always bad to <code>apply exists.intro</code> and have a metavar for one goal. Sometimes you want to just show the body of the exists, and let Lean figure out what the witness was by unification. (Like in Kenny's example.)</p>

<a name="150729348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/term%20has%20type%20p%20y%20but%20is%20expected%20to%20have%20type%20p%20%3Fm_1%5B_%5D/near/150729348" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/06213termhastypepybutisexpectedtohavetypepm1.html#150729348">Kenny Lau (Dec 02 2018 at 17:00)</a>:</h4>
<p>I'm surprised the <code>_</code> worked</p>

<a name="150729351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/term%20has%20type%20p%20y%20but%20is%20expected%20to%20have%20type%20p%20%3Fm_1%5B_%5D/near/150729351" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/06213termhastypepybutisexpectedtohavetypepm1.html#150729351">Kevin Buzzard (Dec 02 2018 at 17:00)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span>

<span class="kn">theorem</span> <span class="n">mwe</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">y</span><span class="o">,</span>
  <span class="n">assumption</span>
<span class="kn">end</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">axioms</span> <span class="n">mwe</span> <span class="c1">-- no axioms</span>
</pre></div>

<a name="150729362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/term%20has%20type%20p%20y%20but%20is%20expected%20to%20have%20type%20p%20%3Fm_1%5B_%5D/near/150729362" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/06213termhastypepybutisexpectedtohavetypepm1.html#150729362">Alistair Tucker (Dec 02 2018 at 17:01)</a>:</h4>
<p>"use" is a tactic?</p>

<a name="150729365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/term%20has%20type%20p%20y%20but%20is%20expected%20to%20have%20type%20p%20%3Fm_1%5B_%5D/near/150729365" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/06213termhastypepybutisexpectedtohavetypepm1.html#150729365">Kevin Buzzard (Dec 02 2018 at 17:01)</a>:</h4>
<p>As of about a week ago</p>

<a name="150729375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/term%20has%20type%20p%20y%20but%20is%20expected%20to%20have%20type%20p%20%3Fm_1%5B_%5D/near/150729375" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/06213termhastypepybutisexpectedtohavetypepm1.html#150729375">Kevin Buzzard (Dec 02 2018 at 17:01)</a>:</h4>
<p><code>existsi</code> is an older one, it's a bit less robust but it would work here</p>

<a name="150729418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/term%20has%20type%20p%20y%20but%20is%20expected%20to%20have%20type%20p%20%3Fm_1%5B_%5D/near/150729418" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/06213termhastypepybutisexpectedtohavetypepm1.html#150729418">Kevin Buzzard (Dec 02 2018 at 17:02)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">mwe</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span>
  <span class="n">existsi</span> <span class="n">y</span><span class="o">,</span>
  <span class="n">assumption</span>
<span class="kn">end</span>
</pre></div>

<a name="150729420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/term%20has%20type%20p%20y%20but%20is%20expected%20to%20have%20type%20p%20%3Fm_1%5B_%5D/near/150729420" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/06213termhastypepybutisexpectedtohavetypepm1.html#150729420">Kevin Buzzard (Dec 02 2018 at 17:02)</a>:</h4>
<p>no import needed</p>

<a name="150729424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/term%20has%20type%20p%20y%20but%20is%20expected%20to%20have%20type%20p%20%3Fm_1%5B_%5D/near/150729424" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/06213termhastypepybutisexpectedtohavetypepm1.html#150729424">Alistair Tucker (Dec 02 2018 at 17:02)</a>:</h4>
<p>Thank you all</p>

<a name="150729433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/term%20has%20type%20p%20y%20but%20is%20expected%20to%20have%20type%20p%20%3Fm_1%5B_%5D/near/150729433" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/06213termhastypepybutisexpectedtohavetypepm1.html#150729433">Reid Barton (Dec 02 2018 at 17:03)</a>:</h4>
<p>Your original one didn't work because you wanted <code>exact hy</code> to also solve the other goal with <code>y</code>, but <code>y</code> was not in scope for the other goal!</p>

<a name="150729480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/term%20has%20type%20p%20y%20but%20is%20expected%20to%20have%20type%20p%20%3Fm_1%5B_%5D/near/150729480" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/06213termhastypepybutisexpectedtohavetypepm1.html#150729480">Kevin Buzzard (Dec 02 2018 at 17:04)</a>:</h4>
<p>Yes! And it's hard to get access to it too, because <code>\exists</code> only eliminates to <code>Prop</code>.</p>

<a name="150729501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/term%20has%20type%20p%20y%20but%20is%20expected%20to%20have%20type%20p%20%3Fm_1%5B_%5D/near/150729501" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/06213termhastypepybutisexpectedtohavetypepm1.html#150729501">Kenny Lau (Dec 02 2018 at 17:05)</a>:</h4>
<p>again, you can see it using this:</p>
<div class="codehilite"><pre><span></span><span class="n">meta</span> <span class="n">def</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span><span class="bp">.</span><span class="n">result</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">tactic</span><span class="bp">.</span><span class="n">result</span> <span class="bp">&gt;&gt;=</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">trace</span>

<span class="kn">theorem</span> <span class="n">mwe</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">apply</span> <span class="n">exists</span><span class="bp">.</span><span class="n">intro</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span>
  <span class="n">result</span><span class="o">,</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">exists.intro ?m_1 (Exists.dcases_on h (λ (y : α) (hy : p y), ?m_2[h, y, hy]))</span>
<span class="cm">-/</span>
  <span class="n">exact</span> <span class="n">hy</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>

<a name="150729503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/term%20has%20type%20p%20y%20but%20is%20expected%20to%20have%20type%20p%20%3Fm_1%5B_%5D/near/150729503" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/06213termhastypepybutisexpectedtohavetypepm1.html#150729503">Kenny Lau (Dec 02 2018 at 17:05)</a>:</h4>
<p>there's no way to unify <code>?m_1</code> with <code>y</code> because <code>y</code> doesn't even exist in the scope of <code>?m_1</code></p>

<a name="150729543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/term%20has%20type%20p%20y%20but%20is%20expected%20to%20have%20type%20p%20%3Fm_1%5B_%5D/near/150729543" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/06213termhastypepybutisexpectedtohavetypepm1.html#150729543">Kevin Buzzard (Dec 02 2018 at 17:06)</a>:</h4>
<p>[just to be clear -- Kenny's code doesn't run]</p>


{% endraw %}

{% include archive_update.html %}