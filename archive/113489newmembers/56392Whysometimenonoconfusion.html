---
layout: archive
title: Lean Prover Zulip Chat Archive 
permalink: archive/113489newmembers/56392Whysometimenonoconfusion.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/56392Whysometimenonoconfusion.html">Why sometime no no_confusion?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="159944289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20sometime%20no%20no_confusion%3F/near/159944289" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56392Whysometimenonoconfusion.html#159944289">Andre Kuhlenschmidt (Mar 04 2019 at 19:52)</a>:</h4>
<p>Is there a limitation to the derivation of <code>no_confusion</code> theorems?<br>
The following inductive <code>type</code> doesn't generate one:</p>
<div class="codehilite"><pre><span></span>inductive type
| TVar  : nat → type
| Bool  : type
| Arrow : type → type → type
| TDef  : nat → list type → type

#print prefix type
</pre></div>

<a name="159945419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20sometime%20no%20no_confusion%3F/near/159945419" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56392Whysometimenonoconfusion.html#159945419">Mario Carneiro (Mar 04 2019 at 20:03)</a>:</h4>
<p>It's a nested inductive</p>

<a name="159945521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20sometime%20no%20no_confusion%3F/near/159945521" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56392Whysometimenonoconfusion.html#159945521">Mario Carneiro (Mar 04 2019 at 20:04)</a>:</h4>
<p>This is not built in to lean but is compiled, so it has a different set of autogenerated theorems</p>

<a name="159945563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20sometime%20no%20no_confusion%3F/near/159945563" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56392Whysometimenonoconfusion.html#159945563">Mario Carneiro (Mar 04 2019 at 20:05)</a>:</h4>
<p>I generally recommend against using nested inductives at all because the lean support is spotty</p>

<a name="159945697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20sometime%20no%20no_confusion%3F/near/159945697" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56392Whysometimenonoconfusion.html#159945697">Mario Carneiro (Mar 04 2019 at 20:06)</a>:</h4>
<p>(The reason it is a nested inductive is because the last constructor mentions <code>list type</code>, where <code>type</code> is the inductive type under construction)</p>

<a name="159946467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20sometime%20no%20no_confusion%3F/near/159946467" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56392Whysometimenonoconfusion.html#159946467">Andre Kuhlenschmidt (Mar 04 2019 at 20:14)</a>:</h4>
<p>Is the standard way of avoiding <code>list type</code> to make a mutually inductive definition?</p>
<div class="codehilite"><pre><span></span>mutual inductive type, list_type
with type : Type
| TVar  : nat → type
| Bool  : type
| Arrow : type → type → type
| TDef  : nat → list_type → type
with list_type : Type
| nil : list_type
| cons : type -&gt; list_type -&gt; list_type

#print prefix type
</pre></div>


<p>This seems to work.</p>


{% endraw %}
