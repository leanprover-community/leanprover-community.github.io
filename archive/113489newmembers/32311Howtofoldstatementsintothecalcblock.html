---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html">How to fold statements into the calc block?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="123008970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/123008970" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#123008970">Sean Leather (Feb 26 2018 at 19:11)</a>:</h4>
<p>Ah, so <a class="stream" data-stream-id="113489" href="/#narrow/stream/113489-new-members">#new members</a> is a “stream,” and it has multiple “topics.” Now the terminology is coming together in my head.</p>

<a name="123009044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/123009044" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#123009044">Sean Leather (Feb 26 2018 at 19:13)</a>:</h4>
<p>And I'm too tired to fully comprehend anything else about Zulip right now. I'm sure I'll find lots of messages in the morning. Good night!</p>

<a name="123011348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/123011348" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#123011348">Chris Hughes (Feb 26 2018 at 20:15)</a>:</h4>
<p>I like the generated profile pictures here.</p>

<a name="123011404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/123011404" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#123011404">Patrick Massot (Feb 26 2018 at 20:16)</a>:</h4>
<p>You can still use the opportunity to brighten your previous profile picture before uploading</p>

<a name="165591474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/165591474" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#165591474">Mario Carneiro (May 14 2019 at 04:10)</a>:</h4>
<p>usually this is achieved by constructing the set in a way so that it's obvious that it's a finset. How is <code>isCanonicalPartition</code> defined?</p>

<a name="165591475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/165591475" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#165591475">Johan Commelin (May 14 2019 at 04:10)</a>:</h4>
<p><span class="user-mention" data-user-id="118987">@Huyen Chau Nguyen</span> to format code on this chat (you can still edit your message) use</p>
<div class="codehilite"><pre><span></span>```lean
put your code here
```
</pre></div>


<p>That way it is formatted as a code block with syntax highlighting.</p>

<a name="167292319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/167292319" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#167292319">hpxmd (Jun 04 2019 at 13:24)</a>:</h4>
<p>Hello, newb in functional languages here! Im stuck on excercise at "2.4. Introducing Definitions"</p>
<div class="codehilite"><pre><span></span><span class="c">/-</span><span class="cm"> Above, we discussed the process of “currying” a function, that is, taking a function f (a, b) that takes an ordered pair as an argument, and recasting it as a function f&#39; a b that takes two arguments successively. As another exercise, we encourage you to complete the following definitions, which “curry” and “uncurry” a function.</span>
<span class="cm">def curry (α β γ : Type) (f : α × β → γ) : α → β → γ := sorry</span>
<span class="cm">def uncurry (α β γ : Type) (f : α → β → γ) : α × β → γ := sorry</span>
<span class="cm">-/</span>
<span class="n">def</span> <span class="n">curry</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span> <span class="o">:=</span>
</pre></div>


<p>the closest solution i came up with is</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">curry</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span><span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span><span class="o">:</span> <span class="n">γ</span><span class="o">),</span> <span class="n">c</span>
</pre></div>


<p>returns error:</p>
<div class="codehilite"><pre><span></span><span class="bp">/</span><span class="n">home</span><span class="bp">/</span><span class="n">runner</span><span class="bp">/.</span><span class="n">code</span><span class="bp">.</span><span class="n">tio</span><span class="o">:</span><span class="mi">2</span><span class="o">:</span><span class="mi">56</span><span class="o">:</span> <span class="n">error</span><span class="o">:</span> <span class="n">type</span> <span class="n">mismatch</span><span class="o">,</span> <span class="n">term</span>
  <span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">γ</span><span class="o">),</span> <span class="n">c</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span> <span class="bp">→</span> <span class="n">γ</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span>
</pre></div>


<p>i don't understand how i should return this λ itself. As is can't just leave it like "λ (a: α) (b: β) (c: γ)"</p>

<a name="167292425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/167292425" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#167292425">Mario Carneiro (Jun 04 2019 at 13:25)</a>:</h4>
<p>you need to use <code>f</code> at some point</p>

<a name="167292828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/167292828" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#167292828">hpxmd (Jun 04 2019 at 13:30)</a>:</h4>
<p>I tried for like whole day and a half. Im no mathematitian also. Should i just continue reading then?</p>

<a name="167292871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/167292871" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#167292871">Marc Huisinga (Jun 04 2019 at 13:30)</a>:</h4>
<p>the type signature of curry states that given a value of type alpha and a value of type beta, you get a value of type gamma. <br>
the function you defined with your lambda however takes a value of type alpha, a value of type beta and a value of type gamma.<br>
you need to drop the gamma parameter and come up with a way to produce a value of type gamma from values of types alpha and beta, which will involve using f.</p>

<a name="167292909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/167292909" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#167292909">Patrick Massot (Jun 04 2019 at 13:30)</a>:</h4>
<blockquote>
<p>you need to use <code>f</code> at some point</p>
</blockquote>
<p>See, the question was under-specified. No wonder the continuum hypothesis is undecidable.</p>

<a name="167293143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/167293143" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#167293143">Patrick Massot (Jun 04 2019 at 13:32)</a>:</h4>
<p>Seriously, <span class="user-mention" data-user-id="224062">@hpxmd</span> you need to reread the last paragraph of <a href="https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html#simple-type-theory" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html#simple-type-theory">https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html#simple-type-theory</a></p>

<a name="167293173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/167293173" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#167293173">Johan Commelin (Jun 04 2019 at 13:33)</a>:</h4>
<blockquote>
<p>I tried for like whole day and a half. Im no mathematitian also. Should i just continue reading then?</p>
</blockquote>
<p>How many mathematicians do you think know what <code>curry</code> means? I bet that 99% think it is something you put on a sausage.</p>

<a name="167293178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/167293178" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#167293178">Patrick Massot (Jun 04 2019 at 13:33)</a>:</h4>
<p>That's where the specification is explicitly given</p>

<a name="167293221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/167293221" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#167293221">Patrick Massot (Jun 04 2019 at 13:33)</a>:</h4>
<p>Johan, I think you spend <em>way</em> too much time in Germany</p>

<a name="167293295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/167293295" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#167293295">hpxmd (Jun 04 2019 at 13:34)</a>:</h4>
<p>Thanks Patrick, ill try that</p>

<a name="167309231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/167309231" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#167309231">hpxmd (Jun 04 2019 at 16:02)</a>:</h4>
<p>So i had to read wiki to write it:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">curry</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">b</span><span class="o">,</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>
</pre></div>


<p>is this right?</p>

<a name="167309258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/167309258" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#167309258">Kevin Buzzard (Jun 04 2019 at 16:02)</a>:</h4>
<p>Yup!</p>

<a name="167309397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/167309397" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#167309397">hpxmd (Jun 04 2019 at 16:04)</a>:</h4>
<p>then i guess i dont understand this lambda calculus thing</p>

<a name="167309403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/167309403" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#167309403">hpxmd (Jun 04 2019 at 16:04)</a>:</h4>
<p>thank you</p>

<a name="167309612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/167309612" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#167309612">Patrick Massot (Jun 04 2019 at 16:06)</a>:</h4>
<p>This has not much to do with lambda calculus</p>

<a name="167309673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/167309673" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#167309673">Kevin Buzzard (Jun 04 2019 at 16:06)</a>:</h4>
<p>This is exactly completely basic lambda calculus, isn't it?</p>

<a name="167309761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/167309761" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#167309761">Patrick Massot (Jun 04 2019 at 16:07)</a>:</h4>
<p>No, it's about functions of two variable vs function of one variable with values in functions of one variable.</p>

<a name="167309813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/167309813" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#167309813">Patrick Massot (Jun 04 2019 at 16:07)</a>:</h4>
<p>You could write the answer as <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>↦</mo><mo>(</mo><mi>b</mi><mo>↦</mo><mi>f</mi><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">a \mapsto (b \mapsto f (a,b))</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">a</span><span class="mrel">↦</span><span class="mopen">(</span><span class="mord mathit">b</span><span class="mrel">↦</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mpunct">,</span><span class="mord mathit">b</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> and you woudln't see any <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">λ</span></span></span></span></p>

<a name="167309929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/167309929" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#167309929">Patrick Massot (Jun 04 2019 at 16:08)</a>:</h4>
<p>The point of lambda-calculus is not using a stupid notation instead of a legible one (reading: the one <em>we</em> are used to). It's about the reduction rules</p>

<a name="167316162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/167316162" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#167316162">Marc Huisinga (Jun 04 2019 at 17:20)</a>:</h4>
<p>this topic made me curious: when getting started with lean (or a similar language), did the function application syntax without parens feel unnatural or even hard to read to any of you, compared to the syntax with parens?<br>
i'm asking because i've heard this complaint quite a lot over the years from people coming from traditional programming languages, and i've been wondering whether this initial feeling is common for everyone, or whether it's just because i've mostly talked to people that had gotten used to the syntax with parens over the years.</p>

<a name="167319865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/167319865" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#167319865">Kevin Buzzard (Jun 04 2019 at 17:58)</a>:</h4>
<p>I was a mathematician for 25 years before I learnt any functional programming and yes, the lack of brackets looked super-weird to me. I still occasionally put them in by accident.</p>

<a name="167320016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/167320016" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#167320016">Koundinya Vajjha (Jun 04 2019 at 18:00)</a>:</h4>
<p>Yes but use it long enough and you'll start hating brackets. :-)</p>

<a name="167320208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/167320208" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#167320208">Patrick Massot (Jun 04 2019 at 18:02)</a>:</h4>
<p>I've caught myself not writing brackets on paper</p>

<a name="167325388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/167325388" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#167325388">Sebastien Gouezel (Jun 04 2019 at 18:53)</a>:</h4>
<p>In dynamics it is very common to omit the brackets.</p>

<a name="167327636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/167327636" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#167327636">Scott Morrison (Jun 04 2019 at 19:20)</a>:</h4>
<p>Meh. We should be writing function application as <code>x f</code> anyway. Losing the brackets is partial progress. :-)</p>

<a name="167341596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/167341596" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#167341596">Andrew Ashworth (Jun 04 2019 at 22:42)</a>:</h4>
<p>Reverse Polish notation was the best thing in calculators. Maybe I ought to implement it in lean 4, hah.</p>

<a name="167341835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/167341835" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#167341835">Andrew Ashworth (Jun 04 2019 at 22:46)</a>:</h4>
<p>Then you can stare at expressions like 15 7 1 1 + − ÷ 3 × 2 1 1 + + − and truly live the bracket free life</p>

<a name="168785596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/168785596" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#168785596">Robert Solovay (Jun 23 2019 at 08:56)</a>:</h4>
<p>How do I enter the Greek letter lambda (symbol for  functional abstraction) in the Lean javascript window?</p>

<a name="168785599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/168785599" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#168785599">Kevin Buzzard (Jun 23 2019 at 08:56)</a>:</h4>
<p><code>\lam</code></p>

<a name="168785605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/168785605" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#168785605">Kevin Buzzard (Jun 23 2019 at 08:57)</a>:</h4>
<p><code>\la</code> apparently works too</p>

<a name="168785607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/168785607" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#168785607">Robert Solovay (Jun 23 2019 at 08:57)</a>:</h4>
<p>Thanks.</p>

<a name="168785618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/168785618" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#168785618">Kevin Buzzard (Jun 23 2019 at 08:57)</a>:</h4>
<p>Nice to see you here, by the way!</p>

<a name="168791239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/168791239" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#168791239">Jesse Michael Han (Jun 23 2019 at 11:49)</a>:</h4>
<p>welcome!</p>

<a name="168969707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/168969707" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#168969707">jachym simon (Jun 25 2019 at 19:35)</a>:</h4>
<p>Hi! <br>
I am trying to proof completeness theorem for Hilbert style classical propositional system. While working my way through I ran into this lemma below. The lemma is quite important, but i am not able to prove it. I can do that  for n and k particular numbers (1,2,3, ..),  but not for n and k general. Is there some way to prove it?</p>
<div class="codehilite"><pre><span></span>def eval := ℕ → bool
def g(n:ℕ)(f:eval): ℕ → bool := (λ m:ℕ, nat.lt_by_cases (λ h:m&lt;n, f m) (λ h, tt) (λ h, tt))

lemma Lemma1(n:ℕ)(f:eval): ∀ k:ℕ, k &lt; n → g n f k = f k :=
</pre></div>


<p>Thanks :)</p>

<a name="168970125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/168970125" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#168970125">Kenny Lau (Jun 25 2019 at 19:40)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="kn">eval</span> <span class="o">:=</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="n">def</span> <span class="n">g</span><span class="o">(</span><span class="n">n</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">)(</span><span class="n">f</span><span class="o">:</span><span class="kn">eval</span><span class="o">):</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">bool</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">m</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">lt_by_cases</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">:</span><span class="n">m</span><span class="bp">&lt;</span><span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">tt</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">tt</span><span class="o">))</span>

<span class="kn">lemma</span> <span class="n">Lemma1</span><span class="o">(</span><span class="n">n</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">)(</span><span class="n">f</span><span class="o">:</span><span class="kn">eval</span><span class="o">):</span> <span class="bp">∀</span> <span class="n">k</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">,</span> <span class="n">k</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">g</span> <span class="n">n</span> <span class="n">f</span> <span class="n">k</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">k</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">k</span> <span class="n">hk</span><span class="o">,</span> <span class="n">dif_pos</span> <span class="n">hk</span>
</pre></div>

<a name="168973733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/168973733" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#168973733">jachym simon (Jun 25 2019 at 20:24)</a>:</h4>
<blockquote>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="kn">eval</span> <span class="o">:=</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="n">def</span> <span class="n">g</span><span class="o">(</span><span class="n">n</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">)(</span><span class="n">f</span><span class="o">:</span><span class="kn">eval</span><span class="o">):</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">bool</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">m</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">lt_by_cases</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">:</span><span class="n">m</span><span class="bp">&lt;</span><span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">tt</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">tt</span><span class="o">))</span>

<span class="kn">lemma</span> <span class="n">Lemma1</span><span class="o">(</span><span class="n">n</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">)(</span><span class="n">f</span><span class="o">:</span><span class="kn">eval</span><span class="o">):</span> <span class="bp">∀</span> <span class="n">k</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">,</span> <span class="n">k</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">g</span> <span class="n">n</span> <span class="n">f</span> <span class="n">k</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">k</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">k</span> <span class="n">hk</span><span class="o">,</span> <span class="n">dif_pos</span> <span class="n">hk</span>
</pre></div>


</blockquote>
<p>Thank you :)</p>

<a name="169005779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/169005779" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#169005779">jachym simon (Jun 26 2019 at 07:19)</a>:</h4>
<p>HI again,<br>
i have  got one more connected question. How do i prove the two below? Thought it would be the same, but it does not seem to work. </p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="kn">eval</span> <span class="o">:=</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="n">def</span> <span class="n">g</span><span class="o">(</span><span class="n">n</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">)(</span><span class="n">f</span><span class="o">:</span><span class="kn">eval</span><span class="o">):</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">bool</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">m</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">lt_by_cases</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">:</span><span class="n">m</span><span class="bp">&lt;</span><span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">tt</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">tt</span><span class="o">))</span>

<span class="kn">lemma</span> <span class="n">Lemma2</span><span class="o">(</span><span class="n">n</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">)(</span><span class="n">f</span><span class="o">:</span><span class="kn">eval</span><span class="o">):</span> <span class="bp">∀</span> <span class="n">k</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">,</span> <span class="n">k</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">g</span> <span class="n">n</span> <span class="n">f</span> <span class="n">k</span> <span class="bp">=</span> <span class="n">tt</span>  <span class="o">:=</span>
<span class="kn">lemma</span> <span class="n">Lemma3</span><span class="o">(</span><span class="n">n</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">)(</span><span class="n">f</span><span class="o">:</span><span class="kn">eval</span><span class="o">):</span> <span class="bp">∀</span> <span class="n">k</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">,</span> <span class="n">k</span> <span class="bp">&gt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">g</span> <span class="n">n</span> <span class="n">f</span> <span class="n">k</span> <span class="bp">=</span> <span class="n">tt</span>  <span class="o">:=</span>
</pre></div>

<a name="169005987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/169005987" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#169005987">Mario Carneiro (Jun 26 2019 at 07:23)</a>:</h4>
<p>It might be simpler to not use <code>lt_by_cases</code></p>

<a name="169005990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/169005990" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#169005990">Mario Carneiro (Jun 26 2019 at 07:23)</a>:</h4>
<p>and just use <code>if</code></p>

<a name="169006136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/169006136" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#169006136">Mario Carneiro (Jun 26 2019 at 07:26)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="kn">eval</span> <span class="o">:=</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="n">def</span> <span class="n">g</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="kn">eval</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">bool</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="k">then</span> <span class="n">f</span> <span class="n">m</span> <span class="k">else</span> <span class="n">tt</span>

<span class="kn">lemma</span> <span class="n">Lemma2</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="kn">eval</span><span class="o">)</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">k</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">g</span> <span class="n">n</span> <span class="n">f</span> <span class="n">k</span> <span class="bp">=</span> <span class="n">tt</span> <span class="o">:=</span>
<span class="k">have</span> <span class="bp">¬</span> <span class="n">k</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">,</span> <span class="k">from</span> <span class="bp">λ</span> <span class="n">h&#39;</span><span class="o">,</span> <span class="n">ne_of_lt</span> <span class="n">h&#39;</span> <span class="n">h</span><span class="o">,</span>
<span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">g</span><span class="o">,</span> <span class="n">this</span><span class="o">]</span>

<span class="kn">lemma</span> <span class="n">Lemma3</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="kn">eval</span><span class="o">)</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">k</span> <span class="bp">&gt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">g</span> <span class="n">n</span> <span class="n">f</span> <span class="n">k</span> <span class="bp">=</span> <span class="n">tt</span> <span class="o">:=</span>
<span class="k">have</span> <span class="bp">¬</span> <span class="n">k</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">,</span> <span class="k">from</span> <span class="n">not_lt_of_gt</span> <span class="n">h</span><span class="o">,</span>
<span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">g</span><span class="o">,</span> <span class="n">this</span><span class="o">]</span>
</pre></div>

<a name="174031793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/174031793" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#174031793">Daniel Donnelly (Aug 24 2019 at 09:29)</a>:</h4>
<p>Yep, that was it.  It was just updating something in the background</p>

<a name="176214388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/176214388" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#176214388">Juho Kupiainen (Sep 20 2019 at 17:37)</a>:</h4>
<p>How can I browse Lean's mathlib with VS code. Lean works in VS code, but when I open a file in mathlib (I cloned the code) it cannot resolve the imports. I did "leanpkg configure" and "leanpkg build" in the root directory of mathlib</p>

<a name="176216909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/176216909" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#176216909">Bryan Gin-ge Chen (Sep 20 2019 at 18:06)</a>:</h4>
<p>Are you opening the entire mathlib directory in VS Code? Often these issues occur when you just try to open a random file from mathlib without having opened the directory as a workspace.</p>

<a name="176217470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/176217470" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#176217470">Juho Kupiainen (Sep 20 2019 at 18:13)</a>:</h4>
<p>Opening the directory helped after I had created a new project according to the instruction on mathlib github page.</p>

<a name="178083107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/178083107" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#178083107">Marko Grdinić (Oct 14 2019 at 08:25)</a>:</h4>
<div class="codehilite"><pre><span></span>import data.rat

def mean (l : list rat) : rat := list.sum l / l.length
def E (f : rat -&gt; rat) (l : list rat) := mean $ list.map f l

theorem E.const_left (f : rat -&gt; rat) (c : rat) (l : list rat)
    : E (fun x, c * f x) l = c * E f l  := sorry

theorem E.const_right (c : rat) (l : list rat) : E (fun x, x * c) l = E id l * c :=
    have mult_dist : (fun x, x * c) = (fun x, c * x), from funext $ fun x, mul_comm x c,
    have const_left : E (fun x, c * x) l = c * E id l, from E.const_left id c l,
    calc
        E (fun x, x * c) l = E (fun x, c * x) l : by rw mult_dist
        ... = c * E id l : by rw const_left
        ... = E id l * c : by rw mul_comm
</pre></div>


<p>I am trying to rewrite the above so the extraneous names and type annotations are eliminated. Here is what I want to write.</p>
<div class="codehilite"><pre><span></span>import data.rat

def mean (l : list rat) : rat := list.sum l / l.length
def E (f : rat -&gt; rat) (l : list rat) := mean $ list.map f l

theorem E.const_left (f : rat -&gt; rat) (c : rat) (l : list rat)
    : E (fun x, c * f x) l = c * E f l  := sorry

theorem E.const_right (c : rat) (l : list rat) : E (fun x, x * c) l = E id l * c :=
    calc
        E (fun x, x * c) l = E (fun x, c * x) l : by {rw (funext $ fun x, mul_comm x c)}
        ... = c * E id l : by {rw (E.const_left id c l)}
        ... = E id l * c : by rw mul_comm
</pre></div>


<p>It says that the rewrite tactic fails for some reason. At first I thought that it might have been because in the original version some of the arguments were implicit, but that turned out to not be it. I am not sure what to think about this. I am having trouble with similar rewrites in other places. Lean seems to be bad at inferring the right types in the calc block proofs from expressions on the left side.</p>

<a name="178083521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/178083521" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#178083521">Johan Commelin (Oct 14 2019 at 08:31)</a>:</h4>
<p>In the first one, maybe you can try <code>by { funext, ext, rw mul_comm }</code>?</p>

<a name="178083712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/178083712" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#178083712">Mario Carneiro (Oct 14 2019 at 08:34)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">E</span><span class="bp">.</span><span class="n">const_right</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">rat</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">rat</span><span class="o">)</span> <span class="o">:</span> <span class="n">E</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">E</span> <span class="n">id</span> <span class="n">l</span> <span class="bp">*</span> <span class="n">c</span> <span class="o">:=</span>
    <span class="k">calc</span>
        <span class="n">E</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">E</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span><span class="o">,</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">x</span><span class="o">)</span> <span class="n">l</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">mul_comm</span><span class="o">]</span>
        <span class="bp">...</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">E</span> <span class="n">id</span> <span class="n">l</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="err">←</span> <span class="n">E</span><span class="bp">.</span><span class="n">const_left</span><span class="bp">;</span> <span class="n">refl</span>
        <span class="bp">...</span> <span class="bp">=</span> <span class="n">E</span> <span class="n">id</span> <span class="n">l</span> <span class="bp">*</span> <span class="n">c</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">mul_comm</span>
</pre></div>

<a name="178083769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/178083769" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#178083769">Mario Carneiro (Oct 14 2019 at 08:35)</a>:</h4>
<p>If you use <code> ```lean ... ``` </code> then you get syntax highlighting btw</p>

<a name="178083849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/178083849" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#178083849">Mario Carneiro (Oct 14 2019 at 08:36)</a>:</h4>
<p>also:</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">E</span><span class="bp">.</span><span class="n">const_right</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">rat</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">rat</span><span class="o">)</span> <span class="o">:</span> <span class="n">E</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">E</span> <span class="n">id</span> <span class="n">l</span> <span class="bp">*</span> <span class="n">c</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">mul_comm</span><span class="o">,</span> <span class="err">←</span> <span class="n">E</span><span class="bp">.</span><span class="n">const_left</span><span class="o">]</span><span class="bp">;</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">mul_comm</span><span class="o">,</span> <span class="n">id</span><span class="o">]</span>
</pre></div>

<a name="178084361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/178084361" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#178084361">Marko Grdinić (Oct 14 2019 at 08:44)</a>:</h4>
<p>I am surprised by <code>.. = c * E id l : by rw ← E.const_left; refl</code>. Why rewrite to the left? That does not make much sense to me.</p>

<a name="178084507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/178084507" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#178084507">Mario Carneiro (Oct 14 2019 at 08:46)</a>:</h4>
<p><code>rw</code> will rewrite any subterm of the <em>entire goal</em> using the given equation from left to right (or right to left if you give the <code>&lt;-</code>). That means that it can be used to rewrite the right side of the equation as well as the left side, at which point both sides become equal and <code>refl</code> closes the goal</p>

<a name="178084708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/178084708" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#178084708">Marko Grdinić (Oct 14 2019 at 08:49)</a>:</h4>
<p>Ah, I see. I just realized that <code>... = c * E id l : by rw E.const_left; refl</code> works too. The type error does not indicate what the problem is.</p>

<a name="178084919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/178084919" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#178084919">Mario Carneiro (Oct 14 2019 at 08:52)</a>:</h4>
<p>Oh, I guess it was able to match <code>f := \lam x, x</code> even if you write from left to right, I wouldn't have expected that</p>

<a name="178084947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/178084947" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#178084947">Mario Carneiro (Oct 14 2019 at 08:52)</a>:</h4>
<p>The matching problem from right to left is easier, because it doesn't have to do any higher order matching</p>

<a name="178084995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/178084995" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#178084995">Mario Carneiro (Oct 14 2019 at 08:53)</a>:</h4>
<p>That is, it's easy to match <code> c * E id l</code> against the pattern <code>?c * E ?f ?l</code></p>

<a name="178085549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/178085549" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#178085549">Marko Grdinić (Oct 14 2019 at 09:01)</a>:</h4>
<p>Yeah, I think I understand it now.</p>
<div class="codehilite"><pre><span></span>rewrite tactic failed, did not find instance of the pattern in the target expression
  E (λ (x : ℚ), c * id x) l
state:
c : ℚ,
l : list ℚ
⊢ E (λ (x : ℚ), c * x) l = c * E id l
</pre></div>


<p>I should have looked at the type error more carefully. <code>c * id x</code> and <code>c * x</code> are not quite the same thing here.</p>
<p>Is there a way to make <code>... = c * E id l : by {rw (E.const_left id c l)}</code> work by getting it to simplify the expression passed to <code>rw</code> namely the <code>E.const_left id c l</code> ?</p>

<a name="178085662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/178085662" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#178085662">Mario Carneiro (Oct 14 2019 at 09:02)</a>:</h4>
<p>sure, but it would take more than one line to do so</p>

<a name="178085791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/178085791" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#178085791">Mario Carneiro (Oct 14 2019 at 09:03)</a>:</h4>
<div class="codehilite"><pre><span></span>        <span class="bp">...</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">E</span> <span class="n">id</span> <span class="n">l</span> <span class="o">:</span> <span class="k">by</span> <span class="o">{</span>
          <span class="k">have</span> <span class="o">:=</span> <span class="n">E</span><span class="bp">.</span><span class="n">const_left</span> <span class="n">id</span> <span class="n">c</span> <span class="n">l</span><span class="o">,</span>
          <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">id</span><span class="o">]</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
          <span class="n">rw</span> <span class="n">this</span> <span class="o">}</span>
</pre></div>

<a name="178085931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/178085931" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#178085931">Mario Carneiro (Oct 14 2019 at 09:04)</a>:</h4>
<p>it's easier in this case to rewrite backwards so you get <code>E (λ (x : ℚ), c * x) l = E (λ (x : ℚ), c * id x) l</code>, which can then be closed by <code>refl</code></p>

<a name="178085944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/178085944" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#178085944">Mario Carneiro (Oct 14 2019 at 09:05)</a>:</h4>
<p>because <code>id x</code> is defeq to <code>x</code></p>

<a name="178086090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/178086090" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#178086090">Marko Grdinić (Oct 14 2019 at 09:07)</a>:</h4>
<p>Thank you very much. This was definitely instructive for me.</p>

<a name="178101981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/178101981" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#178101981">Reid Barton (Oct 14 2019 at 13:19)</a>:</h4>
<p>You can also use <code>erw (E.const_left id c l)</code>, which unfolds definitions while matching. However, we tend not to use <code>erw</code> much because it can be slow.</p>

<a name="178102034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20fold%20statements%20into%20the%20calc%20block%3F/near/178102034" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/32311Howtofoldstatementsintothecalcblock.html#178102034">Reid Barton (Oct 14 2019 at 13:19)</a>:</h4>
<p>In this case you can also just use the term <code>E.const_left id c l</code> directly, without bothering with <code>by rw </code></p>


{% endraw %}

{% include archive_update.html %}