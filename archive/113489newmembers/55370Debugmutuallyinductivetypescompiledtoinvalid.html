---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html">Debug "mutually inductive types compiled to invalid ..."</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="167726011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Debug%20%22mutually%20inductive%20types%20compiled%20to%20invalid%20...%22/near/167726011" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html#167726011">Kevin Sullivan (Jun 10 2019 at 01:30)</a>:</h4>
<p>In a separate thread I'm discussing the design of an affine space library. That's the context for this question. I need a mutually inductive definition of several types. I'm getting the following error message:</p>
<div class="codehilite"><pre><span></span>mutually inductive types compiled to invalid basic inductive type
nested exception message:
universe level of type_of(arg #4) of &#39;apoint._mut_.mk_0&#39; is too big for the corresponding inductive datatypeLean
</pre></div>


<p>The question is a basic one: how to debug this problem? It looks like I need to look at the compiled definition. Is that right? In that case, how? Or if it's obvious what's going wrong, I'd be happy simply to know the solution to this blocking problem, at least for right now.  I'm not posting the code at this point, hoping for insights without doing that, until the code's in better shape.</p>

<a name="167726084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Debug%20%22mutually%20inductive%20types%20compiled%20to%20invalid%20...%22/near/167726084" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html#167726084">Kenny Lau (Jun 10 2019 at 01:32)</a>:</h4>
<p>use <code>Type*</code> instead of manually calculating the universe</p>

<a name="167726246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Debug%20%22mutually%20inductive%20types%20compiled%20to%20invalid%20...%22/near/167726246" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html#167726246">Mario Carneiro (Jun 10 2019 at 01:37)</a>:</h4>
<p>could you show the definition?</p>

<a name="167726299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Debug%20%22mutually%20inductive%20types%20compiled%20to%20invalid%20...%22/near/167726299" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html#167726299">Mario Carneiro (Jun 10 2019 at 01:38)</a>:</h4>
<p>or at least the inductive itself, MWE not required</p>

<a name="167727591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Debug%20%22mutually%20inductive%20types%20compiled%20to%20invalid%20...%22/near/167727591" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html#167727591">Kevin Sullivan (Jun 10 2019 at 02:14)</a>:</h4>
<blockquote>
<p>or at least the inductive itself, MWE not required</p>
</blockquote>
<div class="codehilite"><pre><span></span>mutual inductive apoint, avector, aframe

with apoint :
    Π (s : space), Type
| mk :                      -- any point
    Π {s : space}
      (d : ℕ) [has_zero (fin d)]
      (K: Type) [discrete_field K]
      (coords : { c : tuple (d+1) K // c.nth 0 = 1 }),
      apoint s
| mk_std :
    Π { s : space }         -- std point, (1, 0, 0, ..., 0)
      (d : ℕ) [has_zero (fin d)]
      (K: Type) [discrete_field K],
      apoint s

with avector :
    Π (s : space), Type
| mk :
    Π {s : space}
      (d : ℕ) [has_zero (fin d)]
      (K: Type) [discrete_field K]
      (coords : { c : tuple (d+1) K // c.nth 0 = 1 }),
      avector s     -- was: aframe s → scalar → avector s
| mk_std :
    Π { s : space }         -- std vector(0, 0, 0, ..., 0)
      (d : ℕ) [has_zero (fin d)]
      (K: Type) [discrete_field K],
      avector s

with aframe :
    Π (s : space), Type
| mk : Π { s : space }, apoint s → avector s → aframe s
| mk_std : Π { s : space }, aframe s -- not yet complete
</pre></div>


<p>If I use Type*, I get an error at the end about inductive types having to live in the same universe.</p>

<a name="167727972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Debug%20%22mutually%20inductive%20types%20compiled%20to%20invalid%20...%22/near/167727972" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html#167727972">Kevin Sullivan (Jun 10 2019 at 02:25)</a>:</h4>
<p>It has a few things that need fixing, but this should give the idea.</p>

<a name="167728689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Debug%20%22mutually%20inductive%20types%20compiled%20to%20invalid%20...%22/near/167728689" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html#167728689">Floris van Doorn (Jun 10 2019 at 02:44)</a>:</h4>
<p>Change the types of <code>apoint</code>, <code>avector</code> and <code>aframe</code> to <code>space → Type (u+1)</code>(this is the same as <code>Π (s : space), Type (u+1)</code>), and change the types of all <code>K</code>s to <code>Type u</code>. If you don't like to worry about universe levels, you can set <code>u</code> to <code>0</code> (so only use <code>Type</code> - which is <code>Type 0</code> - and <code>Type 1</code>).</p>

<a name="167728693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Debug%20%22mutually%20inductive%20types%20compiled%20to%20invalid%20...%22/near/167728693" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html#167728693">Floris van Doorn (Jun 10 2019 at 02:44)</a>:</h4>
<p>Here is a simplified version of your MWE:</p>
<div class="codehilite"><pre><span></span>universe variable u
constant space : Type

mutual inductive apoint, avector, aframe

with apoint :
    Π (s : space), Type (u+1)
| mk :                      -- any point
    Π {s : space}
      (d : ℕ) [has_zero (fin d)]
      (K: Type u) [discrete_field K],
      apoint s
| mk_std :
    Π { s : space }         -- std point, (1, 0, 0, ..., 0)
      (d : ℕ) [has_zero (fin d)]
      (K: Type u) [discrete_field K],
      apoint s

with avector :
    Π (s : space), Type (u+1)
| mk :
    Π {s : space}
      (d : ℕ) [has_zero (fin d)]
      (K: Type u) [discrete_field K],
      avector s     -- was: aframe s → scalar → avector s
| mk_std :
    Π { s : space }         -- std vector(0, 0, 0, ..., 0)
      (d : ℕ) [has_zero (fin d)]
      (K: Type u) [discrete_field K],
      avector s

with aframe :
    Π (s : space), Type (u+1)
| mk : Π { s : space }, apoint s → avector s → aframe s
| mk_std : Π { s : space }, aframe s -- not yet complete
</pre></div>

<a name="167728708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Debug%20%22mutually%20inductive%20types%20compiled%20to%20invalid%20...%22/near/167728708" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html#167728708">Kenny Lau (Jun 10 2019 at 02:45)</a>:</h4>
<p>here is a simplified simplified version:</p>
<div class="codehilite"><pre><span></span><span class="kn">universe</span> <span class="n">u</span>

<span class="n">mutual</span> <span class="kn">inductive</span> <span class="n">apoint</span><span class="o">,</span> <span class="n">aframe</span>
<span class="k">with</span> <span class="n">apoint</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="n">apoint</span>
<span class="k">with</span> <span class="n">aframe</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="n">apoint</span> <span class="bp">→</span> <span class="n">aframe</span>
</pre></div>

<a name="168450627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Debug%20%22mutually%20inductive%20types%20compiled%20to%20invalid%20...%22/near/168450627" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html#168450627">Kevin Sullivan (Jun 18 2019 at 20:07)</a>:</h4>
<blockquote>
<p>here is a simplified simplified version:</p>
<div class="codehilite"><pre><span></span><span class="kn">universe</span> <span class="n">u</span>

<span class="n">mutual</span> <span class="kn">inductive</span> <span class="n">apoint</span><span class="o">,</span> <span class="n">aframe</span>
<span class="k">with</span> <span class="n">apoint</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="n">apoint</span>
<span class="k">with</span> <span class="n">aframe</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="n">apoint</span> <span class="bp">→</span> <span class="n">aframe</span>
</pre></div>


</blockquote>
<p>I'm coming back to this.  I'm having another problem knowing what an error message means around mutually defined types. The context is that I'm defining an affine space. An affine space has points, vectors, frames. A point or a vector have coordinates and a frame in terms of which  coordinates have meaning. A frame in turn comprises a point (origin) and a set of vectors (a basis for the vector space). The problem that I'm having is that if I change the signature of the frame constructor from taking a point and a single vector to taking a point and a list of vectors, I get the following error at the top of the inductive definition: </p>
<div class="codehilite"><pre><span></span>nested occurrence &#39;list.{1} (affine_vector s)&#39; contains variables that are not parameters
</pre></div>


<p>Here's the self-contained code (which I'll be putting in an open GitHub repo once it works).</p>
<div class="codehilite"><pre><span></span>import algebra.module
import data.vector

-- for testing
import data.real.basic
set_option pp.notation false


-- UNDERLYING REPRESENTATION

--universe u

/-
Background: the &quot;vector&quot; type in the Lean standard library
is a type whose values are really just tuples. We define
a &quot;tuple&quot; type polymorphic as the type of tuples of length
n over values of a type, K.
-/
def tuple
    (n : ℕ)
    (K : Type) :=
        vector K n

-- testing
def aTuple : tuple 3 ℝ := ⟨[2,1,-1], rfl⟩
def aTuple&#39; : tuple 1 ℝ := ⟨[2], rfl⟩

/-
With K a discrete field with zero and one values,
we define a function to return tuples of length n
over K with all elements equal to the field&#39;s zero
element.
-/
def mk_zero_tuple :
    ∀ (n : ℕ)
    (K : Type)
    [f : discrete_field K]
    [z : has_zero K],
        vector K n
| 0 K f z := vector.nil
| (nat.succ n&#39;) K f z := vector.cons (z.zero) (@mk_zero_tuple n&#39; K f z)

-- testing
def aReal3ZeroTuple : tuple 3 ℝ :=
    subtype.mk [0,0,0] rfl
def aReal4ZeroTuple : tuple 4 ℝ :=
    subtype.mk [0,0,0,0] rfl


structure space : Type 1 :=
mk ::
(name : string)
(dim : ℕ)
(field: Type)
[isField : discrete_field field]
[the_zero : has_zero field]
[the_one : has_one field]

-- testing

def time : space :=         -- non-computable
    space.mk &quot;time&quot; 1 ℝ

def geometry : space :=
    space.mk &quot;geometry&quot; 3 ℝ

/-
We define affine point, vector, and frame types.
The space to which each such object belongs is a
part of its type. The definitions are mutually
recursive, because point and a vector are defined
partly in terms of a frame (in terms of which its
coordinates are interpreted), and a frame in turn
is defined by a point (its origin) and a tuple of
vectors (comprising a basis for its vector space).
-/

mutual inductive affine_point, affine_vector, affine_frame
with affine_point : space → Type 1
    | mk :
        Π { s : space },
        affine_frame s →
        tuple s.dim s.field  → affine_point s
    | mk_std :
        Π { s : space },         -- std point, (1, 0, 0, ..., 0) wrt std_frame
        affine_point s
with affine_vector : space → Type 1
    | mk :
        Π {s : space},
        affine_frame s →
        tuple s.dim s.field →
        affine_vector s
    | mk_std :
        Π { s : space },        -- std vector(0, 0, 0, ..., 0) wrt std_frame
        affine_vector s
with affine_frame : space → Type 1
    | mk : Π { s : space }, affine_point s → list (affine_vector s) → affine_frame s -- stub
    | mk_std : Π { s : space },  affine_frame s  -- std frame
</pre></div>


<p>I've tried with a universe variable, u, substituting Type (u+1), and also Type (u+2), for Type 1 where it appears in the mutual definition, to no avail. Thanks, all, for your ongoing help with this stuff.</p>
<p>Kevin</p>

<a name="168492943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Debug%20%22mutually%20inductive%20types%20compiled%20to%20invalid%20...%22/near/168492943" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html#168492943">Kevin Buzzard (Jun 19 2019 at 09:59)</a>:</h4>
<p>I've done a bunch of maths in Lean and I have never once had to use a mutually inductive type. I know nothing about them and this is why I can't help. Is there any way of just taking things apart and defining some normal inductive types?</p>

<a name="168495636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Debug%20%22mutually%20inductive%20types%20compiled%20to%20invalid%20...%22/near/168495636" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html#168495636">Scott Morrison (Jun 19 2019 at 10:52)</a>:</h4>
<p><span class="user-mention" data-user-id="209463">@Ben Leedom</span> and I were faced with a mutual inductive definition when trying to define the product of CW complexes. Lean couldn't cope, so we unrolled it into a single inductive definition of a complicated structure (something like "product of CW complexes along with inclusions of products of the k- and l- skeleta of the factors")</p>

<a name="168496613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Debug%20%22mutually%20inductive%20types%20compiled%20to%20invalid%20...%22/near/168496613" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html#168496613">Chris Hughes (Jun 19 2019 at 11:10)</a>:</h4>
<blockquote>
<p>I've done a bunch of maths in Lean and I have never once had to use a mutually inductive type. I know nothing about them and this is why I can't help. Is there any way of just taking things apart and defining some normal inductive types?</p>
</blockquote>
<p>Yes. That is how Lean does it underneath, but it doesn't do it very well. There is a good way of doing it.</p>

<a name="168499414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Debug%20%22mutually%20inductive%20types%20compiled%20to%20invalid%20...%22/near/168499414" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html#168499414">Andrew Ashworth (Jun 19 2019 at 11:58)</a>:</h4>
<p>This looks difficult to debug, since you are using mutually inductive types with nested inductive types in <code>affine_frame</code>. I am no expert in these things - the only way I would know how to get to the bottom of the error is to unroll the definition into non-mutual/nested inductive types. Someone had a similar problem awhile back, here is the link to the conversation: <a href="#narrow/stream/113489-new-members/topic/Induction/near/160350668" title="#narrow/stream/113489-new-members/topic/Induction/near/160350668">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/Induction/near/160350668</a>.</p>

<a name="168508750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Debug%20%22mutually%20inductive%20types%20compiled%20to%20invalid%20...%22/near/168508750" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html#168508750">Kevin Sullivan (Jun 19 2019 at 13:57)</a>:</h4>
<blockquote>
<blockquote>
<p>I've done a bunch of maths in Lean and I have never once had to use a mutually inductive type. I know nothing about them and this is why I can't help. Is there any way of just taking things apart and defining some normal inductive types?</p>
</blockquote>
<p>Yes. That is how Lean does it underneath, but it doesn't do it very well. There is a good way of doing it.</p>
</blockquote>
<p>I guess my first question is whether my definition violates a fundamental constraint (e.g., positivity), or whether what I'm seeing is the just that Lean isn't yet capable of  dealing with such a definition. My second question is, where do I go for a complete definition of the unrolling method?</p>

<a name="168512572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Debug%20%22mutually%20inductive%20types%20compiled%20to%20invalid%20...%22/near/168512572" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html#168512572">Kevin Sullivan (Jun 19 2019 at 14:39)</a>:</h4>
<p>To help, I've abstracted from the affine space details and have reduced the problem instance to a very short piece of code. I give three versions here of almost the same definition. The first two work; the third is borked and isolates the problem.</p>
<p>(1) Works: Two <em>non-polymorphic</em> mutually inductive types, the second taking a list of the first as an argument.<br>
(2) Works: Two polymorphic mutually inductive types, the second taking only a single instance of the first as an argument.<br>
(3) Borked: Two polymorphic mutually inductive types, the second taking a <em>list</em> of the first as an argument.</p>
<div class="codehilite"><pre><span></span>-- a type argument
axiom S : Type

-- #1 [WORKS] (Note: s arguments are ignored)
mutual inductive X, Y
with X : Type
    | mk : Π (s : S), Y → X
with Y : Type
    | mk&#39; : Π (s : S), list X  → Y

-- #2 [WORKS]
mutual inductive A, B
with A : S → Type
    | mk : Π (s : S), B s → A s
with B : S → Type
    | mk&#39; : Π (s : S), A s → B s

-- #3 [BORKED]
mutual inductive P, Q
with P : S → Type
    | mk : Π (s : S), Q s → P s
with Q : S → Type
    | mk&#39; : Π (s : S), list (P s) → Q s    -- putting list in front of (P s) breaks it
</pre></div>


<p>I should know the answer to this but I don't: Will Lean print out the unrolled definitions of P, Q?</p>

<a name="168513922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Debug%20%22mutually%20inductive%20types%20compiled%20to%20invalid%20...%22/near/168513922" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html#168513922">Kevin Sullivan (Jun 19 2019 at 14:55)</a>:</h4>
<div class="codehilite"><pre><span></span>-- #3 [BORKED]
mutual inductive P, Q
with P : S → Type
    | mk : Π (s : S), Q s → P s
with Q : S → Type
    | mk&#39; : Π (s : S), list (P s) → Q s    -- putting list in front of (P s) breaks it
</pre></div>


<p>Works in Coq.</p>
<div class="codehilite"><pre><span></span>Axiom S : Set.
Inductive P : S -&gt; Set :=
| mk : forall (s : S), Q s -&gt; P s
with Q : S -&gt; Set :=
| mk&#39; : forall (s : S), list (P s) -&gt; Q s.
</pre></div>

<a name="168515045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Debug%20%22mutually%20inductive%20types%20compiled%20to%20invalid%20...%22/near/168515045" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html#168515045">Chris Hughes (Jun 19 2019 at 15:07)</a>:</h4>
<p>You can see what your inductive type actually is with<code> #print affine_point</code></p>

<a name="168515070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Debug%20%22mutually%20inductive%20types%20compiled%20to%20invalid%20...%22/near/168515070" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html#168515070">Kevin Sullivan (Jun 19 2019 at 15:07)</a>:</h4>
<blockquote>
<p>I've done a bunch of maths in Lean and I have never once had to use a mutually inductive type.</p>
</blockquote>
<p>Kevin B: Thanks. This is a good place for mutual inductive definitions. A point in an affine space can be given coordinates in terms of a frame. A vector can be given coordinates in the same way. A frame, in turn, comprises a point and a set of vectors constituting a basis for the vector space. These points and vectors, being points and vectors, in turn have coordinates in terms of some (possibly other) frame. It all bottoms out with the concept of a standard frame with a standard origin point and standard basis vectors. What this structure naturally supports is the situation where you have chains of changes in basis/coordinate-systems. This kind of situation arises frequently in domains like computer graphics and robotics.</p>

<a name="168515257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Debug%20%22mutually%20inductive%20types%20compiled%20to%20invalid%20...%22/near/168515257" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html#168515257">Kevin Sullivan (Jun 19 2019 at 15:08)</a>:</h4>
<blockquote>
<p>You can see what your inductive type actually is with<code> #print affine_point</code></p>
</blockquote>
<p>Ok, that's easy. Thank you.</p>

<a name="168515436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Debug%20%22mutually%20inductive%20types%20compiled%20to%20invalid%20...%22/near/168515436" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html#168515436">Kevin Sullivan (Jun 19 2019 at 15:09)</a>:</h4>
<blockquote>
<blockquote>
<p>You can see what your inductive type actually is with<code> #print affine_point</code></p>
</blockquote>
<p>Ok, that's easy. Thank you.</p>
</blockquote>
<p>Except that the definition isn't accepted, so affine_point isn't defined. Any way to see what Lean is trying to reduce the definition to?</p>

<a name="168515804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Debug%20%22mutually%20inductive%20types%20compiled%20to%20invalid%20...%22/near/168515804" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html#168515804">Chris Hughes (Jun 19 2019 at 15:13)</a>:</h4>
<p>This is mutual and nested, because you have <code>list (affine_vector s) </code> as a constructor. That might be the problem.</p>

<a name="168516106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Debug%20%22mutually%20inductive%20types%20compiled%20to%20invalid%20...%22/near/168516106" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html#168516106">Andrew Ashworth (Jun 19 2019 at 15:17)</a>:</h4>
<p>this example is given in  <a href="https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html#mutual-and-nested-inductive-types" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html#mutual-and-nested-inductive-types">https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html#mutual-and-nested-inductive-types</a></p>

<a name="168516123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Debug%20%22mutually%20inductive%20types%20compiled%20to%20invalid%20...%22/near/168516123" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html#168516123">Kevin Sullivan (Jun 19 2019 at 15:17)</a>:</h4>
<blockquote>
<p>This is mutual and nested, because you have <code>list (affine_vector s) </code> as a constructor. That might be the problem.</p>
</blockquote>
<p>Example <a href="https://github.com/leanprover-community/mathlib/issues/1" target="_blank" title="https://github.com/leanprover-community/mathlib/issues/1">#1</a> is mutual and nested but not polymorphic, and it works. Example <a href="https://github.com/leanprover-community/mathlib/issues/2" target="_blank" title="https://github.com/leanprover-community/mathlib/issues/2">#2</a> is mutual and polymorphic but not nested, and it works. Example <a href="https://github.com/leanprover-community/mathlib/issues/3" target="_blank" title="https://github.com/leanprover-community/mathlib/issues/3">#3</a> is mutual, polymorphic, and nested. That's where it breaks. Yet it works in Coq.</p>

<a name="168516203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Debug%20%22mutually%20inductive%20types%20compiled%20to%20invalid%20...%22/near/168516203" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html#168516203">Andrew Ashworth (Jun 19 2019 at 15:18)</a>:</h4>
<p>as a quick fix, you could try to redo it giving the specialization of <code>list</code> explicitly as another type</p>

<a name="168516318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Debug%20%22mutually%20inductive%20types%20compiled%20to%20invalid%20...%22/near/168516318" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html#168516318">Andrew Ashworth (Jun 19 2019 at 15:19)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">mutual</span> <span class="kn">inductive</span> <span class="n">P</span><span class="o">,</span> <span class="n">Q</span><span class="o">,</span> <span class="n">Q_list</span>  <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">S</span><span class="o">)</span>
<span class="k">with</span> <span class="n">P</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">:</span> <span class="n">Q</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">s</span>
<span class="k">with</span> <span class="n">Q</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="bp">|</span> <span class="n">mk&#39;</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">P</span> <span class="n">s</span><span class="o">)</span> <span class="bp">→</span> <span class="n">Q</span> <span class="n">s</span>
<span class="k">with</span> <span class="n">Q_list</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">{}</span> <span class="o">:</span>  <span class="n">Q_list</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">:</span> <span class="n">Q</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">Q_list</span> <span class="bp">→</span> <span class="n">Q_list</span>
</pre></div>

<a name="168516346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Debug%20%22mutually%20inductive%20types%20compiled%20to%20invalid%20...%22/near/168516346" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html#168516346">Andrew Ashworth (Jun 19 2019 at 15:19)</a>:</h4>
<p>I have no idea if this translates exactly to the semantics of what you want, though</p>

<a name="168516630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Debug%20%22mutually%20inductive%20types%20compiled%20to%20invalid%20...%22/near/168516630" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html#168516630">Andrew Ashworth (Jun 19 2019 at 15:23)</a>:</h4>
<p>interesting, your original example doesn't even need that </p>
<div class="codehilite"><pre><span></span><span class="kn">variable</span> <span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="n">mutual</span> <span class="kn">inductive</span> <span class="n">P</span><span class="o">,</span> <span class="n">Q</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">S</span><span class="o">)</span>
<span class="k">with</span> <span class="n">P</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">:</span> <span class="n">Q</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">s</span>
<span class="k">with</span> <span class="n">Q</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">mk&#39;</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">P</span> <span class="n">s</span><span class="o">)</span> <span class="bp">→</span> <span class="n">Q</span> <span class="n">s</span>
</pre></div>

<a name="168527040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Debug%20%22mutually%20inductive%20types%20compiled%20to%20invalid%20...%22/near/168527040" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html#168527040">Kevin Sullivan (Jun 19 2019 at 17:25)</a>:</h4>
<blockquote>
<p>this example is given in  <a href="https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html#mutual-and-nested-inductive-types" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html#mutual-and-nested-inductive-types">https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html#mutual-and-nested-inductive-types</a></p>
</blockquote>
<p>Andrew, thank you. Your pointer set me off in a direction that seems to be working. The problem appears to be (thus this thread being in the beginners section) that I had the type arguments in the wrong place.</p>
<p>Here are type definitions that at least so far seem good. I have yet to prove that instances are actually affine spaces, formalized as torsors over vector spaces. I might run into problems when I try to do that, but at least I now have a path to try. </p>
<p>Here are type definitions, followed in the second code block by working "test code".</p>
<div class="codehilite"><pre><span></span>import algebra.module
import data.vector

universe u

/-
Tuples of length n over a type, K
-/
def tuple
    (n : ℕ)
    (K : Type u) : Type u :=
        vector K n

/-
A type, space, values of which we will use to
uniquely identify a given affine space, while
characterizing its key attributes, namely its
dimension and the field over in terms of which
scalars and coordinate tuples are defined. Such
a space has a name, allowing us to distinguish
spaces with the same field and dimensionality.
-/
structure space
(dim : ℕ)
(K: Type)
[isField : discrete_field K]
[theZero : has_zero K]
[theOne : has_one K]
: Type :=
mk :: (name : string)

/-
A mutual inductive definition of affine point,
vector, and frame types. A point in an affine space
is given coordinates in terms of a frame. A vector
can be given coordinates in the same way. A frame,
in turn, has a point, its origin, and a sequence of
vectors, constituting a basis for the vector space.
We are not yet specifying or enforcing the linear
independence of the vectors. The points and vectors
that make up a frame, being points and vectors, in
turn have coordinates expressed in terms of some
(possible other) frame. The recursion bottoms out
with at a standard frame with a standard origin and
standard basis vectors. This structure naturally
supports situation where you have chains of changes
in basis/coordinate-systems. This kind of situation
arises frequently in domains like computer graphics
and robotics.
-/
mutual inductive affine_point, affine_vector, affine_frame
    { d : ℕ }
    { K: Type }
    { f : discrete_field K }
    { z : has_zero K }
    { o : has_one K }
    (s : space d K)
with affine_point : Type 1
| mk_std : affine_point
| mk : affine_frame → tuple d K → affine_point
with affine_vector : Type 1
| mk_std : affine_vector
| mk : affine_frame → tuple d K → affine_vector
with affine_frame : Type 1
| mk_std : affine_frame
| mk : affine_point → (list affine_vector) → affine_frame
</pre></div>


<p>Here's code giving the types a little test run.</p>
<div class="codehilite"><pre><span></span>import .affine_space_new
import data.real.basic


-- Test tuple type
def oneTuple : tuple 1 ℝ := ⟨ [2], rfl ⟩
def aTuple : tuple 3 ℝ := ⟨[2,1,-1], rfl⟩
def aTuple&#39; : tuple 1 ℝ := ⟨[2], rfl⟩
def aReal3ZeroTuple : tuple 3 ℝ :=
    subtype.mk [0,0,0] rfl
def aReal4ZeroTuple : tuple 4 ℝ :=
    ⟨ [0,0,0,0], rfl⟩


-- Test space type
def time : space 1 ℝ :=      -- non-computable
    space.mk 1 ℝ &quot;time&quot;
def geometry : space 3 ℝ :=  -- non-computable
    space.mk 3 ℝ &quot;geometry&quot;
#check time
#check space 1 real


/-
Test affine point, vector, frame types.
Time as an affine space.
-/

-- standard frame
def timeFrame1 : affine_frame time :=
    affine_frame.mk_std time

-- standard point (t = 0)
def timePoint1 : affine_point time :=
    affine_point.mk_std time

-- standard vector (interpret as 1 minute duration)
def timeVector1 : affine_vector time :=
    affine_vector.mk_std time

-- point at 60 min (1 hr) wrt to std frame
def timePoint2 : affine_point time :=
    affine_point.mk timeFrame1 ⟨ [60], rfl ⟩

-- a vector of length 1hr wrt std frame
def timeVector2 : affine_vector time :=
    affine_vector.mk timeFrame1 ⟨ [60], rfl ⟩

-- new frame, origin at 1 hour and unit 1 hr, wrt std frame
def timeFrame2 : affine_frame time :=
    affine_frame.mk timePoint2 [timeVector2]

-- Point @ 24 hours from (t = one hour) wrt std frame
def timePoint3 := affine_point.mk timeFrame2 ⟨ [24], rfl ⟩

/-
Test affine point, vector, frame types.
3D geometry as an affine space.
-/

-- std frame
def geomFrame1 : affine_frame geometry :=
    affine_frame.mk_std geometry

-- std origin
def geomPoint1 : affine_point geometry :=
    affine_point.mk_std geometry

-- std vector [one of them, anyway, need to enhance type]
def geomVector1 : affine_vector geometry :=
    affine_vector.mk_std geometry

-- new point at [1,1,1] wrt std frame
def geomPoint2 : affine_point geometry :=
    affine_point.mk geomFrame1 ⟨ [1,1,1], rfl ⟩

-- new vector at [-1,1,2] wrt std frame
def geomVector2 : affine_vector geometry :=
    affine_vector.mk geomFrame1 ⟨ [-1,1,2], rfl ⟩

-- new frame with new basis vectors (need to add constraints here)
def geomFrame2 : affine_frame geometry :=
    affine_frame.mk geomPoint2 [geomVector1, geomVector2, geomVector1]
</pre></div>

<a name="168554127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Debug%20%22mutually%20inductive%20types%20compiled%20to%20invalid%20...%22/near/168554127" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html#168554127">Mario Carneiro (Jun 19 2019 at 23:25)</a>:</h4>
<p>These work in Coq because the Coq kernel is crazy permissive</p>

<a name="168554143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Debug%20%22mutually%20inductive%20types%20compiled%20to%20invalid%20...%22/near/168554143" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html#168554143">Mario Carneiro (Jun 19 2019 at 23:26)</a>:</h4>
<p>You can achieve a similar behavior in lean by putting <code>meta</code> in front of the definition</p>

<a name="168556170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Debug%20%22mutually%20inductive%20types%20compiled%20to%20invalid%20...%22/near/168556170" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html#168556170">Scott Morrison (Jun 20 2019 at 00:11)</a>:</h4>
<p>How close does "crazy permissive" come to "I worry that we'll have another proof of <code>false</code> someday"?</p>

<a name="168565313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Debug%20%22mutually%20inductive%20types%20compiled%20to%20invalid%20...%22/near/168565313" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html#168565313">Mario Carneiro (Jun 20 2019 at 04:10)</a>:</h4>
<p>There is no paper proof that we can't prove false</p>


{% endraw %}
