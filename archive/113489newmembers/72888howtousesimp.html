---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113489newmembers/72888howtousesimp.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html">how to use simp</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="179406132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179406132" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179406132">Jason Gross (Oct 30 2019 at 06:30)</a>:</h4>
<p>I have</p>
<div class="codehilite"><pre><span></span><span class="c1">-- set_option pp.numerals false</span>
<span class="kn">example</span> <span class="o">:</span> <span class="o">(</span><span class="mi">3</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">6</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">int</span><span class="bp">.</span><span class="n">mul</span><span class="o">,</span><span class="n">bit0</span><span class="o">,</span><span class="n">bit1</span><span class="o">,</span><span class="n">has_one</span><span class="bp">.</span><span class="n">one</span><span class="o">,</span><span class="n">int</span><span class="bp">.</span><span class="n">one</span><span class="o">,</span><span class="n">int</span><span class="bp">.</span><span class="n">add</span><span class="o">,</span><span class="n">nat</span><span class="bp">.</span><span class="n">add</span><span class="o">,</span><span class="n">has_add</span><span class="bp">.</span><span class="n">add</span><span class="o">,</span><span class="n">has_mul</span><span class="bp">.</span><span class="n">mul</span><span class="o">,</span><span class="n">int</span><span class="bp">.</span><span class="n">mul</span><span class="o">,</span><span class="n">coe</span><span class="o">,</span><span class="n">lift_t</span><span class="o">,</span><span class="n">has_lift_t</span><span class="bp">.</span><span class="n">lift</span><span class="o">,</span><span class="n">coe_t</span><span class="o">,</span><span class="n">has_coe_t</span><span class="bp">.</span><span class="n">coe</span><span class="o">,</span><span class="n">coe_b</span><span class="o">,</span><span class="n">has_coe</span><span class="bp">.</span><span class="n">coe</span><span class="o">]</span>
<span class="kn">end</span>
</pre></div>


<p>I want to simplify the goal until it is <code>6 = 6</code> or <code>nat.succ (nat.succ (nat.succ (nat.succ (nat.succ (nat.succ nat.zero)))) = nat.succ (nat.succ (nat.succ (nat.succ (nat.succ (nat.succ nat.zero))))</code>.  (I know that I can prove it by reflexivity, but I am using this as a test case for a more complicated goal involving arithmetic expressions that I need to simplify to numerals, where I don't know what the final result is going to be (or where there are too many different possibilities to list out).)  If I add either <code>nat.mul</code> or <code>has_zero.zero</code> to this list, then lean times out.  How do I finish this simplification?</p>

<a name="179406848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179406848" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179406848">Jason Gross (Oct 30 2019 at 06:50)</a>:</h4>
<p>Also, how do I unfold <code>list.partition._match_1</code>?  <code>simp only [list.partition._match_1]</code> seems to just always fail with <code>simplify tactic failed to simplify</code></p>

<a name="179408556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179408556" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179408556">Mario Carneiro (Oct 30 2019 at 07:34)</a>:</h4>
<p>Use <code>norm_num</code> for goals like this</p>

<a name="179408576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179408576" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179408576">Mario Carneiro (Oct 30 2019 at 07:35)</a>:</h4>
<p><code>norm_num</code> does arithmetic with numerals; <code>simp</code> doesn't understand numerals and their normal forms</p>

<a name="179408671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179408671" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179408671">Mario Carneiro (Oct 30 2019 at 07:37)</a>:</h4>
<p>Unfolding everything in sight is 99% of the time the wrong thing to do. Lemmas should exist to unfold one definition at a time, and theorems should not have to break through more than two layers of abstraction or so</p>

<a name="179408717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179408717" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179408717">Mario Carneiro (Oct 30 2019 at 07:38)</a>:</h4>
<p>What is the more complex goal you are trying to solve? This looks like an XY problem to me</p>

<a name="179430648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179430648" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179430648">Kenny Lau (Oct 30 2019 at 13:25)</a>:</h4>
<p>can we write a meta-tactic that will use the correct tactic in each situation? :P</p>

<a name="179440591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179440591" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179440591">Kevin Buzzard (Oct 30 2019 at 15:00)</a>:</h4>
<p>It's really hard for an outsider to know the correct tactic. You have some stupid question which involves multiplication by 2 on the naturals and everyone says" Oh, it's Presburger, use <code>omega</code>" or something -- and then you have some other question which involves multiplication too and <code>omega</code> doesn't work and then they say "oh that's not Presburger, but <code>ring</code> will do that one obviously and you say "but the naturals aren't a ring" and they say "yeah but it's shorter than <code>semiring</code>", and then there's another one but neither <code>omega</code> or <code>ring</code> work and it turns out you need <code>linarith</code>. The mathematician proof of all of these is "it's now obvious", and we have difficulty expressing this exasperation in the language of tactics because for you it's several different kinds of obvious.</p>

<a name="179443136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179443136" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179443136">Reid Barton (Oct 30 2019 at 15:22)</a>:</h4>
<p><code>tidy</code> already basically works like this. We could easily make a differently-configured <code>tidy</code> that just tries <code>norm_num</code>, <code>linarith</code>, <code>ring</code>, <code>omega</code> and shows you what worked (which <code>tidy</code> already knows how to do).</p>

<a name="179452103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179452103" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179452103">Scott Morrison (Oct 30 2019 at 16:48)</a>:</h4>
<p>This is a good idea. It's probably best to call a version of <code>ring</code> that doesn't attempt to rewrite if it fails to close the goal. It may be worth thinking a little about which of these tactics "fail fast", and perhaps improve this.</p>

<a name="179452181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179452181" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179452181">Scott Morrison (Oct 30 2019 at 16:48)</a>:</h4>
<p>But doing this on top of <code>tidy</code> will just be a few lines.</p>

<a name="179452276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179452276" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179452276">Scott Morrison (Oct 30 2019 at 16:49)</a>:</h4>
<p>(On a related note, I have written a few proofs recently leaving the line <code>suggest</code> at the bottom of my <code>begin ... end</code> block as I work, and it can be pretty awesome... "Oh, you're done! That goal too!")</p>

<a name="179454737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179454737" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179454737">Kevin Buzzard (Oct 30 2019 at 17:16)</a>:</h4>
<p>I don't like errors in my code so I often leave <code>sorry</code> at the end of every branch I've not filled in (say I'm in the middle of a big tactic mode proof). Do I just stop using <code>sorry</code> and start using <code>suggest</code>?</p>

<a name="179455184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179455184" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179455184">Jason Gross (Oct 30 2019 at 17:20)</a>:</h4>
<p>I get <code>unknown identifier 'norm_num'</code>(I'm using lean installed from <a href="https://github.com/leanprover/lean/releases/download/v3.4.2/lean-3.4.2-linux.tar.gz" target="_blank" title="https://github.com/leanprover/lean/releases/download/v3.4.2/lean-3.4.2-linux.tar.gz">https://github.com/leanprover/lean/releases/download/v3.4.2/lean-3.4.2-linux.tar.gz</a>)</p>

<a name="179455242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179455242" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179455242">Kevin Buzzard (Oct 30 2019 at 17:21)</a>:</h4>
<p><code>norm_num</code> is a mathlib tactic. Try <code>import tactic.norm_num</code> at the top of your file.</p>

<a name="179455833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179455833" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179455833">Jason Gross (Oct 30 2019 at 17:26)</a>:</h4>
<blockquote>
<p>What is the more complex goal you are trying to solve? This looks like an XY problem to me</p>
</blockquote>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> I'm trying to perf-test lean's tactics for rewriting/partial evaluation on a goal for generating straightline-code for big integer field arithmetic for a fixed prime modulus on a fixed-width platform.  In particular, I'm trying to rewrite in <a href="https://github.com/mit-plv/fiat-crypto/blob/d801192d534a0c80eab74ef7874c38b7c84a0134/fiat_crypto.lean#L367" target="_blank" title="https://github.com/mit-plv/fiat-crypto/blob/d801192d534a0c80eab74ef7874c38b7c84a0134/fiat_crypto.lean#L367">this goal</a> until everything except <code>let_in</code> and arithmetic definitions on non-numerals is unfolded, and I will also need to rewrite with <a href="https://github.com/mit-plv/fiat-crypto/blob/d801192d534a0c80eab74ef7874c38b7c84a0134/fiat_crypto.lean#L351" target="_blank" title="https://github.com/mit-plv/fiat-crypto/blob/d801192d534a0c80eab74ef7874c38b7c84a0134/fiat_crypto.lean#L351"><code>this lemma</code></a> to lift binders so they don't block rewriting/reduction.  Additionally, there are a number of places where I'm doing a test on equality of <code>int</code>s which are numerals, and I need to reduce/rewrite/compute the test so that the <code>if</code> statement goes away.</p>

<a name="179455857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179455857" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179455857">Rob Lewis (Oct 30 2019 at 17:26)</a>:</h4>
<blockquote>
<p>(On a related note, I have written a few proofs recently leaving the line <code>suggest</code> at the bottom of my <code>begin ... end</code> block as I work, and it can be pretty awesome... "Oh, you're done! That goal too!")</p>
</blockquote>
<p>Isn't this super laggy? That's folding over the environment a lot.</p>

<a name="179456657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179456657" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179456657">Scott Morrison (Oct 30 2019 at 17:35)</a>:</h4>
<p>Yes, it's slow, but not as slow as me, so sometimes it has time to say something helpful. :-)</p>

<a name="179456828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179456828" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179456828">Scott Morrison (Oct 30 2019 at 17:37)</a>:</h4>
<p>(This slowness also prompted me to wonder if I could parallelise <code>suggest</code>. Keeley says "maybe".)</p>

<a name="179467376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179467376" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179467376">Jason Gross (Oct 30 2019 at 19:19)</a>:</h4>
<p>I've now installed <code>mathlib</code>, <code>norm_num</code> seems to take forever to finish?  (Also, <code>Warning (flycheck): Syntax checker lean-checker reported too many errors (774) and is disabled.</code>)</p>

<a name="179467530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179467530" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179467530">Jason Gross (Oct 30 2019 at 19:20)</a>:</h4>
<p>Also <code>excessive memory consumption detected at 'replace' (potential solution: increase memory consumption threshold)</code>  (Edit: or maybe this was left over from a different file)</p>

<a name="179467573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179467573" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179467573">Scott Morrison (Oct 30 2019 at 19:21)</a>:</h4>
<p>Do you know if you've got compiled <code>olean</code> files for mathlib?</p>

<a name="179467605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179467605" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179467605">Scott Morrison (Oct 30 2019 at 19:21)</a>:</h4>
<p>Perhaps can you show us your <code>leanpkg.toml</code> file, and tell us what happens when you run <code>leanpkg build</code> on the command line in the root directory of your project?</p>

<a name="179467731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179467731" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179467731">Kevin Buzzard (Oct 30 2019 at 19:22)</a>:</h4>
<p>Did you install Lean and mathlib and then open a project directory in VS Code with mathlib as a dependency all following the instructions on the mathlib readme?</p>

<a name="179468134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179468134" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179468134">Jason Gross (Oct 30 2019 at 19:27)</a>:</h4>
<p>Ah, it does in fact finish, it just takes 3 minutes to run</p>

<a name="179468208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179468208" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179468208">Jason Gross (Oct 30 2019 at 19:28)</a>:</h4>
<p>I don't seem to have olean files, but am trying <code>leanpkg build</code> now (it seems to be compiling mathlib)</p>

<a name="179468235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179468235" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179468235">Jason Gross (Oct 30 2019 at 19:28)</a>:</h4>
<p>The leanpkg.toml file:</p>
<div class="codehilite"><pre><span></span>$ leanpkg dump
[package]
name = &quot;fiat-crypto&quot;
version = &quot;0.1&quot;
lean_version = &quot;3.4.2&quot;
path = &quot;src-lean&quot;

[dependencies]
mathlib = {git = &quot;https://github.com/leanprover-community/mathlib.git&quot;, rev = &quot;ca9008153aaa6f16c7e2f691231b889dbb05a576&quot;}
</pre></div>

<a name="179468256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179468256" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179468256">Jason Gross (Oct 30 2019 at 19:29)</a>:</h4>
<p>(And I'm using emacs, not vscode)</p>

<a name="179468305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179468305" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179468305">Jason Gross (Oct 30 2019 at 19:29)</a>:</h4>
<p>Ah, and now it's much faster, on the order of a couple of seconds</p>

<a name="179468373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179468373" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179468373">Jason Gross (Oct 30 2019 at 19:30)</a>:</h4>
<p>Is there a way to tell <code>norm_num</code> to not unfold some things?</p>

<a name="179468924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179468924" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179468924">Kevin Buzzard (Oct 30 2019 at 19:37)</a>:</h4>
<p>I think <code>norm_num</code> is usually used as a finishing tactic, i.e. you tell it to kill the goal, you don't use it to get half way there. Or do you mean you want it to only work on one goal and it's working on all of them? That happens for some tactics (but I can't remember if <code>norm_num</code> is one of them). Fix with <code>{norm_num}</code> if this is the issue?</p>

<a name="179469225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179469225" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179469225">Jason Gross (Oct 30 2019 at 19:41)</a>:</h4>
<p>No, I want to use something that doesn't finish the goal.  Here's a toy example: suppose I have something like <code>if &lt;complicated expression of int&gt; = &lt;other complicated expression of int&gt; then term1 else term2</code> and I want to reduce this to either <code>term1</code> or <code>term2</code>, what should I use to reduce the arithmetic on numerals, the decidable equality, and the if-then-else, but leave <code>term1</code> and <code>term2</code> mostly untouched (except for where they contain decidable equality / arithmetic as subterms)?</p>

<a name="179469391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179469391" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179469391">Kevin Buzzard (Oct 30 2019 at 19:43)</a>:</h4>
<p>Start with <code>split_ifs</code>?</p>

<a name="179469500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179469500" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179469500">Floris van Doorn (Oct 30 2019 at 19:45)</a>:</h4>
<p>You can probably do something like <code>rw [if_pos], norm_num</code> (unless you also have other <code>if</code> expressions)</p>

<a name="179469708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179469708" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179469708">Jason Gross (Oct 30 2019 at 19:47)</a>:</h4>
<p><code>split_ifs</code> gives me multiple goals; each decidable equality computes to either true or false.  I have multiple <code>if</code>s, some are true, and others are <code>false</code>.  How do I say "rewrite with whichever of <code>if_pos</code> and <code>if_neg</code> can be solved by computing the decidable instance?</p>

<a name="179469869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179469869" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179469869">Kevin Buzzard (Oct 30 2019 at 19:49)</a>:</h4>
<p>can you do <code>split_ifs</code> and then run <code>cases h</code> on the hypotheses <code>h</code> which are false? Or do you want something slicker?</p>

<a name="179469985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179469985" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179469985">Jason Gross (Oct 30 2019 at 19:50)</a>:</h4>
<p>I expect there to be a couple hundred if statements, I don't want a couple thousand goals, especially not if I have to handle them manually...</p>

<a name="179470000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179470000" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179470000">Kevin Buzzard (Oct 30 2019 at 19:50)</a>:</h4>
<p>Oh I see. You need a computer scientist, sorry ;-)</p>

<a name="179471538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179471538" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179471538">Jason Gross (Oct 30 2019 at 20:05)</a>:</h4>
<p>Another question: How do I get <code>norm_num</code> to simplify my new definitions?  I noticed there is no <code>int.pow</code>, so I wrote </p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span>
<span class="n">def</span> <span class="n">int</span><span class="bp">.</span><span class="n">pow_nat</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℤ</span> <span class="o">:=</span>
  <span class="n">nat</span><span class="bp">.</span><span class="n">rec</span>
    <span class="mi">1</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span> <span class="n">acc</span><span class="o">,</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">acc</span><span class="o">)</span>
    <span class="n">e</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span>
<span class="kn">instance</span> <span class="n">int_has_pow_nat</span> <span class="o">:</span> <span class="n">has_pow</span> <span class="n">int</span> <span class="n">nat</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">int</span><span class="bp">.</span><span class="n">pow_nat</span><span class="bp">⟩</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span>
<span class="n">def</span> <span class="n">int</span><span class="bp">.</span><span class="n">pow</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℤ</span> <span class="bp">→</span> <span class="bp">ℤ</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">int</span><span class="bp">.</span><span class="n">of_nat</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">b</span> <span class="err">^</span> <span class="n">n</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">int</span><span class="bp">.</span><span class="n">neg_succ_of_nat</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">0</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span>
<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_pow</span> <span class="n">int</span> <span class="n">int</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">int</span><span class="bp">.</span><span class="n">pow</span><span class="bp">⟩</span>
</pre></div>


<p>but <code>norm_num</code> doesn't simplify it.</p>

<a name="179472277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179472277" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179472277">Rob Lewis (Oct 30 2019 at 20:13)</a>:</h4>
<p>I'll take a look at your earlier questions in a bit and see if I have any hints. For the latest: you can tell <code>norm_num</code> to reduce definitions with square brackets, e.g. <code>norm_num [int.pow]</code>. For your example, that definition of <code>pow_nat</code> will get in the way.</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">int</span><span class="bp">.</span><span class="n">pow_nat</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℤ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">int</span><span class="bp">.</span><span class="n">pow_nat</span> <span class="n">k</span>

<span class="kn">instance</span> <span class="n">int_has_pow_nat</span> <span class="o">:</span> <span class="n">has_pow</span> <span class="n">int</span> <span class="n">nat</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">int</span><span class="bp">.</span><span class="n">pow_nat</span><span class="bp">⟩</span>

<span class="n">def</span> <span class="n">int</span><span class="bp">.</span><span class="n">pow</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℤ</span> <span class="bp">→</span> <span class="bp">ℤ</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">int</span><span class="bp">.</span><span class="n">of_nat</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">b</span> <span class="err">^</span> <span class="n">n</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">int</span><span class="bp">.</span><span class="n">neg_succ_of_nat</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">0</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_pow</span> <span class="n">int</span> <span class="n">int</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">int</span><span class="bp">.</span><span class="n">pow</span><span class="bp">⟩</span>

<span class="kn">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">-</span><span class="mi">2</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span><span class="err">^</span><span class="mi">4</span> <span class="bp">=</span> <span class="mi">16</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">norm_num</span> <span class="o">[(</span><span class="err">^</span><span class="o">),</span> <span class="n">int</span><span class="bp">.</span><span class="n">pow</span><span class="o">,</span> <span class="n">int</span><span class="bp">.</span><span class="n">pow_nat</span><span class="o">]</span>
</pre></div>

<a name="179472410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179472410" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179472410">Rob Lewis (Oct 30 2019 at 20:15)</a>:</h4>
<p>I don't think the <code>simp</code> attributes you had on the instances will work, will they?</p>

<a name="179472737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179472737" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179472737">Jason Gross (Oct 30 2019 at 20:19)</a>:</h4>
<p>Why is it that <code>norm_num [(^), int.pow, int.pow_nat]</code> works for <code>(-2 : ℤ) ^ 0</code> but fails to reduce for <code>int.pow (-2 : ℤ) 0</code>?</p>

<a name="179472756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179472756" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179472756">Jason Gross (Oct 30 2019 at 20:19)</a>:</h4>
<p>(re <code>simp</code> on instances: idk, I'm still at the cargo-culting stage in learning lean)</p>

<a name="179478580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179478580" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179478580">Jason Gross (Oct 30 2019 at 21:19)</a>:</h4>
<p>Why is it that neither <code>norm_num</code> nor <code>simp</code> can deal with these definitions?</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">norm_num</span>

<span class="n">def</span> <span class="n">int</span><span class="bp">.</span><span class="n">pow_nat&#39;</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℤ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">int</span><span class="bp">.</span><span class="n">pow_nat&#39;</span> <span class="n">k</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span>
<span class="n">def</span> <span class="n">int</span><span class="bp">.</span><span class="n">pow_nat_rev</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℤ</span> <span class="bp">→</span> <span class="bp">ℤ</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">int</span><span class="bp">.</span><span class="n">of_nat</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">int</span><span class="bp">.</span><span class="n">of_nat</span> <span class="o">(</span><span class="n">b</span> <span class="err">^</span> <span class="n">e</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">int</span><span class="bp">.</span><span class="n">neg_succ_of_nat</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">int</span><span class="bp">.</span><span class="n">pow_nat&#39;</span> <span class="o">(</span><span class="n">int</span><span class="bp">.</span><span class="n">neg_succ_of_nat</span> <span class="n">b</span><span class="o">)</span> <span class="n">e</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span>
<span class="n">def</span> <span class="n">int</span><span class="bp">.</span><span class="n">pow_nat</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℤ</span> <span class="o">:=</span> <span class="n">int</span><span class="bp">.</span><span class="n">pow_nat_rev</span> <span class="n">e</span> <span class="n">b</span>

<span class="kn">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">int</span><span class="bp">.</span><span class="n">mod</span> <span class="mi">1</span> <span class="o">(</span><span class="n">int</span><span class="bp">.</span><span class="n">pow_nat</span> <span class="mi">2</span> <span class="mi">16</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">int</span><span class="bp">.</span><span class="n">mod</span><span class="o">,</span><span class="n">int</span><span class="bp">.</span><span class="n">pow_nat</span><span class="o">,(</span><span class="err">^</span><span class="o">),</span><span class="n">int</span><span class="bp">.</span><span class="n">pow_nat_rev</span><span class="o">]</span>
<span class="kn">end</span>
<span class="c1">-- 18:1: tactic failed, there are unsolved goals</span>
<span class="c1">-- state:</span>
<span class="c1">-- ⊢ int.mod 1 (int.pow_nat_rev 16 2) = 0</span>
</pre></div>

<a name="179478880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179478880" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179478880">Jason Gross (Oct 30 2019 at 21:22)</a>:</h4>
<p>Hm, and apparently <code>import tactic.norm_num</code> is enough to make <code>simp [(+)]</code> loop</p>

<a name="179479199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179479199" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179479199">Jason Gross (Oct 30 2019 at 21:25)</a>:</h4>
<p>Reported as <a href="https://github.com/leanprover-community/mathlib/issues/1637" target="_blank" title="https://github.com/leanprover-community/mathlib/issues/1637">https://github.com/leanprover-community/mathlib/issues/1637</a></p>

<a name="179485871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20to%20use%20simp/near/179485871" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/72888howtousesimp.html#179485871">Mario Carneiro (Oct 30 2019 at 22:57)</a>:</h4>
<blockquote>
<p>This is a good idea. It's probably best to call a version of <code>ring</code> that doesn't attempt to rewrite if it fails to close the goal.</p>
</blockquote>
<p>That would be the <code>ring1</code> tactic</p>


{% endraw %}

{% include archive_update.html %}