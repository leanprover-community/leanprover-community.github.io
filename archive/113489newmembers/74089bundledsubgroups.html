---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113489newmembers/74089bundledsubgroups.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/74089bundledsubgroups.html">bundled subgroups</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="193200998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bundled%20subgroups/near/193200998" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74089bundledsubgroups.html#193200998">Jason KY. (Apr 07 2020 at 15:03)</a>:</h4>
<p>I'm trying to create a coercion and I'm not sure why one of my definition is working and the other is not</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">group_theory</span><span class="bp">.</span><span class="n">subgroup</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span>

<span class="kn">structure</span> <span class="n">subgroup</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="kn">extends</span> <span class="n">submonoid</span> <span class="n">G</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">inv_mem&#39;</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">carrier</span> <span class="bp">→</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="err">∈</span> <span class="n">carrier</span><span class="o">)</span>

<span class="kn">instance</span> <span class="n">has_coe</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">set</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">coe</span> <span class="o">:=</span> <span class="n">subgroup</span><span class="bp">.</span><span class="n">carrier</span> <span class="o">}</span> <span class="c1">-- unknown identifier &#39;subgroup.carrier&#39;</span>

<span class="kn">structure</span> <span class="n">subgroup&#39;</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">carrier</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">one_mem&#39;</span> <span class="o">:</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="err">∈</span> <span class="n">carrier</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul_mem&#39;</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">carrier</span> <span class="bp">→</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">carrier</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">carrier</span><span class="o">)</span>
<span class="o">(</span><span class="n">inv_mem&#39;</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">carrier</span> <span class="bp">→</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="err">∈</span> <span class="n">carrier</span><span class="o">)</span>

<span class="kn">instance</span> <span class="n">has_coe&#39;</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">subgroup&#39;</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">set</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">coe</span> <span class="o">:=</span> <span class="n">subgroup&#39;</span><span class="bp">.</span><span class="n">carrier</span> <span class="o">}</span>
</pre></div>


<p>As you can see, LEAN is not recognizing that my first subgroup has a carrrier in my first coercion. Why might this be the case?</p>

<a name="193203318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bundled%20subgroups/near/193203318" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74089bundledsubgroups.html#193203318">Kevin Buzzard (Apr 07 2020 at 15:18)</a>:</h4>
<p>If you <code>extend</code> then it's probably now called something like <code>subgroup.to_submonoid.carrier</code></p>

<a name="193203408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bundled%20subgroups/near/193203408" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74089bundledsubgroups.html#193203408">Kevin Buzzard (Apr 07 2020 at 15:18)</a>:</h4>
<p>Try <code>#print prefix subgroup</code> directly after the definition</p>

<a name="193204052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bundled%20subgroups/near/193204052" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74089bundledsubgroups.html#193204052">Jason KY. (Apr 07 2020 at 15:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/bundled.20subgroups/near/193203408" title="#narrow/stream/113489-new-members/topic/bundled.20subgroups/near/193203408">said</a>:</p>
<blockquote>
<p>Try <code>#print prefix subgroup</code> directly after the definition</p>
</blockquote>
<p>This is what I get</p>
<div class="codehilite"><pre><span></span>subgroup : Π (G : Type u_2) [_inst_2 : group G], Type u_2
subgroup.cases_on : Π {G : Type u_2} [_inst_2 : group G] {C : subgroup G → Sort l} (n : subgroup G),
  (Π (_to_submonoid : submonoid G)
   (inv_mem&#39; : ∀ {x : G}, x ∈ _to_submonoid.carrier → x⁻¹ ∈ _to_submonoid.carrier),
     C {to_submonoid := _to_submonoid, inv_mem&#39; := inv_mem&#39;}) →
  C n
subgroup.has_sizeof_inst : Π (G : Type u_2) [_inst_2 : group G], has_sizeof (subgroup G)
subgroup.inv_mem&#39; : ∀ {G : Type u_2} [_inst_2 : group G] (c : subgroup G) {x : G},
  x ∈ c.to_submonoid.carrier → x⁻¹ ∈ c.to_submonoid.carrier
subgroup.mk : Π {G : Type u_2} [_inst_2 : group G] (_to_submonoid : submonoid G),
  (∀ {x : G}, x ∈ _to_submonoid.carrier → x⁻¹ ∈ _to_submonoid.carrier) → subgroup G
subgroup.mk.inj : ∀ {G : Type u_2} {_inst_2 : group G} {_to_submonoid : submonoid G}
{inv_mem&#39; : ∀ {x : G}, x ∈ _to_submonoid.carrier → x⁻¹ ∈ _to_submonoid.carrier}
{_to_submonoid_1 : submonoid G}
{inv_mem&#39;_1 : ∀ {x : G}, x ∈ _to_submonoid_1.carrier → x⁻¹ ∈ _to_submonoid_1.carrier},
  {to_submonoid := _to_submonoid, inv_mem&#39; := inv_mem&#39;} = {to_submonoid := _to_submonoid_1, inv_mem&#39; := inv_mem&#39;_1} →
  _to_submonoid = _to_submonoid_1
subgroup.mk.inj_arrow : Π {G : Type u_2} {_inst_2 : group G} {_to_submonoid : submonoid G}
{inv_mem&#39; : ∀ {x : G}, x ∈ _to_submonoid.carrier → x⁻¹ ∈ _to_submonoid.carrier}
{_to_submonoid_1 : submonoid G}
{inv_mem&#39;_1 : ∀ {x : G}, x ∈ _to_submonoid_1.carrier → x⁻¹ ∈ _to_submonoid_1.carrier},
  {to_submonoid := _to_submonoid, inv_mem&#39; := inv_mem&#39;} = {to_submonoid := _to_submonoid_1, inv_mem&#39; := inv_mem&#39;_1} →
  Π ⦃P : Sort l⦄, (_to_submonoid = _to_submonoid_1 → P) → P
subgroup.mk.inj_eq : ∀ {G : Type u_2} {_inst_2 : group G} {_to_submonoid : submonoid G}
{inv_mem&#39; : ∀ {x : G}, x ∈ _to_submonoid.carrier → x⁻¹ ∈ _to_submonoid.carrier}
{_to_submonoid_1 : submonoid G}
{inv_mem&#39;_1 : ∀ {x : G}, x ∈ _to_submonoid_1.carrier → x⁻¹ ∈ _to_submonoid_1.carrier},
  {to_submonoid := _to_submonoid, inv_mem&#39; := inv_mem&#39;} = {to_submonoid := _to_submonoid_1, inv_mem&#39; := inv_mem&#39;_1} =
    (_to_submonoid = _to_submonoid_1)
subgroup.mk.sizeof_spec : ∀ (G : Type u_2) [_inst_2 : group G] (_to_submonoid : submonoid G)
(inv_mem&#39; : ∀ {x : G}, x ∈ _to_submonoid.carrier → x⁻¹ ∈ _to_submonoid.carrier),
  subgroup.sizeof G {to_submonoid := _to_submonoid, inv_mem&#39; := inv_mem&#39;} = 1 + sizeof _to_submonoid
subgroup.no_confusion : Π {G : Type u_2} {_inst_2 : group G} {P : Sort l} {v1 v2 : subgroup G}, v1 = v2 → subgroup.no_confusion_type P v1 v2
subgroup.no_confusion_type : Π {G : Type u_2} {_inst_2 : group G}, Sort l → subgroup G → subgroup G → Sort l
subgroup.rec : Π {G : Type u_2} [_inst_2 : group G] {C : subgroup G → Sort l},
  (Π (_to_submonoid : submonoid G)
   (inv_mem&#39; : ∀ {x : G}, x ∈ _to_submonoid.carrier → x⁻¹ ∈ _to_submonoid.carrier),
     C {to_submonoid := _to_submonoid, inv_mem&#39; := inv_mem&#39;}) →
  Π (n : subgroup G), C n
subgroup.rec_on : Π {G : Type u_2} [_inst_2 : group G] {C : subgroup G → Sort l} (n : subgroup G),
  (Π (_to_submonoid : submonoid G)
   (inv_mem&#39; : ∀ {x : G}, x ∈ _to_submonoid.carrier → x⁻¹ ∈ _to_submonoid.carrier),
     C {to_submonoid := _to_submonoid, inv_mem&#39; := inv_mem&#39;}) →
  C n
subgroup.sizeof : Π (G : Type u_2) [_inst_2 : group G], subgroup G → ℕ
subgroup.to_submonoid : Π {G : Type u_2} [_inst_2 : group G], subgroup G → submonoid G
</pre></div>

<a name="193204576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bundled%20subgroups/near/193204576" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74089bundledsubgroups.html#193204576">Jason KY. (Apr 07 2020 at 15:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/bundled.20subgroups/near/193203318" title="#narrow/stream/113489-new-members/topic/bundled.20subgroups/near/193203318">said</a>:</p>
<blockquote>
<p>If you <code>extend</code> then it's probably now called something like <code>subgroup.to_submonoid.carrier</code></p>
</blockquote>
<p>I thought this was it also but apparently not :/</p>
<div class="codehilite"><pre><span></span>invalid field notation, type is not of the form (C ...) where C is a constant
  subgroup.to_submonoid
has type
  subgroup ?m_1 → submonoid ?m_1
</pre></div>


<p>I also tried this <code>(subgroup G).to_submonoid.carrier</code> but then I get</p>
<div class="codehilite"><pre><span></span>invalid field notation, type is not of the form (C ...) where C is a constant
  ⁇
has type
  ?m_1
</pre></div>

<a name="193206073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bundled%20subgroups/near/193206073" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74089bundledsubgroups.html#193206073">Kevin Buzzard (Apr 07 2020 at 15:33)</a>:</h4>
<p>You have <code>subgroup.to_submonoid</code> and <code>submonoid.carrier</code> so now it's just a jigsaw puzzle</p>

<a name="193206534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bundled%20subgroups/near/193206534" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74089bundledsubgroups.html#193206534">Kevin Buzzard (Apr 07 2020 at 15:36)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">instance</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">set</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">coe</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">G</span><span class="o">,</span>  <span class="bp">_</span> <span class="o">}</span>
</pre></div>

<a name="193207853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bundled%20subgroups/near/193207853" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74089bundledsubgroups.html#193207853">Jason KY. (Apr 07 2020 at 15:46)</a>:</h4>
<p>This works!<br>
<code>instance has_coe'' : has_coe (subgroup G) (set G) := { coe := λ G, (subgroup.to_submonoid G).carrier }</code></p>

<a name="193207866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bundled%20subgroups/near/193207866" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74089bundledsubgroups.html#193207866">Jason KY. (Apr 07 2020 at 15:46)</a>:</h4>
<p>Thanks!</p>

<a name="193207901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bundled%20subgroups/near/193207901" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74089bundledsubgroups.html#193207901">Kevin Buzzard (Apr 07 2020 at 15:46)</a>:</h4>
<p>Do you understand dot notation?</p>

<a name="193207950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bundled%20subgroups/near/193207950" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74089bundledsubgroups.html#193207950">Kevin Buzzard (Apr 07 2020 at 15:47)</a>:</h4>
<p>I should say first that my choice of <code>G</code> for the variable was very poor :-/</p>

<a name="193208022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bundled%20subgroups/near/193208022" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74089bundledsubgroups.html#193208022">Kevin Buzzard (Apr 07 2020 at 15:47)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">instance</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">set</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">coe</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">H</span><span class="o">,</span>  <span class="o">(</span><span class="n">subgroup</span><span class="bp">.</span><span class="n">to_submonoid</span> <span class="n">H</span><span class="o">)</span><span class="bp">.</span><span class="n">carrier</span> <span class="o">}</span>
</pre></div>

<a name="193208031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bundled%20subgroups/near/193208031" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74089bundledsubgroups.html#193208031">Jason KY. (Apr 07 2020 at 15:47)</a>:</h4>
<p>I would say I understand it but I feel that whenever I say that I don't really understand it</p>

<a name="193208132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bundled%20subgroups/near/193208132" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74089bundledsubgroups.html#193208132">Kevin Buzzard (Apr 07 2020 at 15:48)</a>:</h4>
<p>So <code>H</code> is a subgroup of <code>G</code>, so it has type <code>subgroup &lt;something&gt;</code></p>

<a name="193208189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bundled%20subgroups/near/193208189" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74089bundledsubgroups.html#193208189">Kevin Buzzard (Apr 07 2020 at 15:48)</a>:</h4>
<p>and that means that if you ever write <code>subgroup.blah H</code> you might have been able to type <code>H.blah</code></p>

<a name="193208259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bundled%20subgroups/near/193208259" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74089bundledsubgroups.html#193208259">Jason KY. (Apr 07 2020 at 15:49)</a>:</h4>
<p>Right, like <code>instance : has_coe (subgroup G) (set G) := { coe := λ K, K.to_submonoid.carrier }</code></p>

<a name="193208495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bundled%20subgroups/near/193208495" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74089bundledsubgroups.html#193208495">Kevin Buzzard (Apr 07 2020 at 15:50)</a>:</h4>
<p>I guess it's because we use dot notation twice here (the other dot is the same as <code>submonoid.carrier (K.to_submonoid)</code> because <code>K.to_submonoid</code> has type <code>submonoid &lt;something&gt;</code>) that you can't get away with <code>subgroup.to_submonoid.carrier</code>.</p>


{% endraw %}

{% include archive_update.html %}