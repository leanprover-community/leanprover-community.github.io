---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113489newmembers/56506BorsukUlamtheorem.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html">Borsuk Ulam theorem</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="157709109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/157709109" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#157709109">Nguyen Duc Hoan (Feb 06 2019 at 17:40)</a>:</h4>
<p>Hello,  I am trying to formulate Borsuk-Ulam theorem (the theorem in this link: <a href="https://en.wikipedia.org/wiki/Borsuk%E2%80%93Ulam_theorem" target="_blank" title="https://en.wikipedia.org/wiki/Borsuk%E2%80%93Ulam_theorem">https://en.wikipedia.org/wiki/Borsuk%E2%80%93Ulam_theorem</a>) but I have some questions. Could you please help me?  <br>
1. In my code, why do I need two properties <code>has_mem ↥(sphere_Sn n r) (set (fin (n + 1) → ℝ))</code> and <code>has_neg ↥(sphere_Sn n r)</code> in the theorem? <br>
2. In my code, I use the theorem <code>mem_sphere_Sn</code>  to define what is member of sphere_Sn. Moreover, the theorem <code>sym_sphere_Sn</code> defines if <code> p ∈ sphere_Sn</code> then <code>(-p) ∈ sphere_Sn</code>. However, LEAN could not use that properties in the <code>Borsuk_Ulam_theorem</code>. So how to use two theorems <code>mem_sphere_Sn</code> and <code>sym_sphere_Sn</code> into <code>Borsuk_Ulam_theorem</code>?<br>
This is my code </p>
<div class="codehilite"><pre><span></span><span class="kn">variable</span> <span class="n">n</span><span class="o">:</span><span class="n">nat</span>
<span class="kn">variable</span> <span class="n">r</span><span class="o">:</span><span class="n">real</span>
<span class="kn">variable</span> <span class="n">p</span><span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span>

<span class="kn">variable</span> <span class="o">[</span><span class="n">metric_space</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)]</span>
<span class="kn">variable</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">ℝ</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)]</span>

<span class="n">def</span> <span class="n">sphere_Sn</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span><span class="o">:</span><span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">y</span> <span class="bp">|</span> <span class="n">dist</span> <span class="n">y</span> <span class="o">(</span><span class="mi">0</span><span class="o">:</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">r</span><span class="o">}</span>


<span class="kn">theorem</span> <span class="n">mem_sphere_Sn</span> <span class="o">:</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">sphere_Sn</span> <span class="n">n</span> <span class="n">r</span> <span class="bp">↔</span> <span class="n">dist</span> <span class="n">p</span> <span class="o">(</span><span class="mi">0</span><span class="o">:</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">iff</span><span class="bp">.</span><span class="n">rfl</span>

<span class="kn">theorem</span> <span class="n">sym_sphere_Sn</span> <span class="o">:</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">sphere_Sn</span> <span class="n">n</span> <span class="n">r</span> <span class="bp">↔</span> <span class="bp">-</span><span class="n">p</span> <span class="err">∈</span> <span class="n">sphere_Sn</span> <span class="n">n</span> <span class="n">r</span> <span class="o">:=</span><span class="n">sorry</span>

<span class="kn">theorem</span> <span class="n">Borsuk_Ulam_theorem</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span><span class="o">:</span><span class="n">ℝ</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mem</span> <span class="err">↥</span><span class="o">(</span><span class="n">sphere_Sn</span> <span class="n">n</span> <span class="n">r</span><span class="o">)</span> <span class="o">(</span><span class="n">set</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">))]</span> <span class="o">[</span><span class="n">has_neg</span> <span class="err">↥</span><span class="o">(</span><span class="n">sphere_Sn</span> <span class="n">n</span> <span class="n">r</span><span class="o">)]</span>
<span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="n">sphere_Sn</span> <span class="n">n</span> <span class="n">r</span> <span class="bp">→</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">))</span> <span class="o">(</span><span class="n">h1</span><span class="o">:</span> <span class="n">continuous</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">sphere_Sn</span> <span class="n">n</span> <span class="n">r</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="bp">-</span><span class="n">p</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">p</span>
<span class="o">:=</span><span class="n">sorry</span>
</pre></div>

<a name="157709463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/157709463" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#157709463">Kevin Buzzard (Feb 06 2019 at 17:45)</a>:</h4>
<p>You have a variable <code>p ∈ sphere_Sn n r</code> and you talk about <code>-p</code>, so Lean wants to know what <code>-p</code> means.</p>

<a name="157709542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/157709542" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#157709542">Kevin Buzzard (Feb 06 2019 at 17:46)</a>:</h4>
<p>Because <code>-p</code> is short for <code>has_neg.neg p</code> Lean comes up with this rather elaborate error about <code>has_neg</code>.</p>

<a name="157709594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/157709594" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#157709594">Kevin Buzzard (Feb 06 2019 at 17:47)</a>:</h4>
<p>But you cannot solve the problem correctly with <code>[has_neg ↥(sphere_Sn n r)]</code>. That line means "let's just assume we have a completely random function <code>has_neg.neg</code> sending <code>p</code> to <code>-p</code>, about which we know absolutely nothing".</p>

<a name="157709644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/157709644" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#157709644">Kevin Buzzard (Feb 06 2019 at 17:48)</a>:</h4>
<p>I would imagine that you have a certain function in mind, and you need to tell Lean to use that function.</p>

<a name="157709815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/157709815" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#157709815">Bryan Gin-ge Chen (Feb 06 2019 at 17:50)</a>:</h4>
<p><a href="https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#inferring-notation" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#inferring-notation">This section on inferring notation</a> in TPiL may help.</p>

<a name="157709821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/157709821" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#157709821">Kevin Buzzard (Feb 06 2019 at 17:50)</a>:</h4>
<p>Every occurrence of <code>[...]</code> in your code is very suspicious to me. They all mean "let's assume we have a random function". For example <code>variable [vector_space ℝ (fin (n+1) → ℝ)]</code> means "Let's assume that the space of functions from <code>fin (n+1)</code> to the reals has a completely arbitrary vector space structure, about which we know nothing at all, other than the fact that it satisfies the axioms of a vector space". We do not even know that the map sending everything to zero will be the zero of the vector space -- we know literally nothing about this structure. What you almost certainly want to do is to tell Lean to use the obvious vector space structure on this type.</p>

<a name="157710025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/157710025" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#157710025">Kevin Buzzard (Feb 06 2019 at 17:53)</a>:</h4>
<p>Let's start at the beginning. I should say now that I have never used vector spaces in Lean, so I don't know the answer to this question: Is the vector space <code>ℝ^n</code> already built in Lean? I suspect it is, and you should use Lean's pre-built one, which will have the correct vector space structure on it, rather than trying to build your own (which is of course possible, you can define addition and scalar multiplication on <code>(fin (n+1) → ℝ)</code> and then prove all the axioms yourself).</p>

<a name="157710102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/157710102" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#157710102">Kevin Buzzard (Feb 06 2019 at 17:54)</a>:</h4>
<p>The theory of modules over a ring (and hence vector spaces over a field) changed only a few weeks ago. Are you completely up to date with Lean 3.4.2 release and the current version of mathlib?</p>

<a name="157710374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/157710374" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#157710374">Nguyen Duc Hoan (Feb 06 2019 at 17:57)</a>:</h4>
<p>yes, I were up to date with Lean 3.4.2 release and the current version mathlib</p>

<a name="157710445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/157710445" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#157710445">Kevin Buzzard (Feb 06 2019 at 17:58)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">pi_instances</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">module</span>

<span class="kn">variable</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span>
<span class="kn">definition</span> <span class="n">is_it_there_already</span> <span class="o">:</span> <span class="n">vector_space</span> <span class="n">ℝ</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">apply_instance</span> <span class="c1">-- fails</span>
</pre></div>


<p>Instead of <code>[vector_space ℝ (fin (n+1) → ℝ)]</code> (which means "put an arbitrary real vector space structure on <code>(fin (n+1) → ℝ)</code>) about which we know nothing"), I am trying to get Lean to guess what vector space structure we want. But I am failing.</p>

<a name="157710488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/157710488" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#157710488">Kevin Buzzard (Feb 06 2019 at 17:58)</a>:</h4>
<p>So I think we need to start there.</p>

<a name="157710535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/157710535" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#157710535">Kevin Buzzard (Feb 06 2019 at 17:59)</a>:</h4>
<p>Once we get this right, Lean will know the correct vector space structure on <code>(fin (n+1) → ℝ)</code>.</p>

<a name="157711245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/157711245" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#157711245">Nguyen Duc Hoan (Feb 06 2019 at 18:06)</a>:</h4>
<p>So I need to build vector space structure on <code>(fin (n+1) \to \R)</code>?</p>

<a name="157711634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/157711634" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#157711634">Rob Lewis (Feb 06 2019 at 18:11)</a>:</h4>
<p>Kevin, either you're missing an import, or this will be added soon. I just tried it in the repo Johannes and I are working on and we have that instance.</p>

<a name="157711770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/157711770" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#157711770">Patrick Massot (Feb 06 2019 at 18:12)</a>:</h4>
<p>He is missing an import, this has been there forever</p>

<a name="157711815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/157711815" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#157711815">Kevin Buzzard (Feb 06 2019 at 18:13)</a>:</h4>
<p>I knew for sure that it was there before the module refactor.</p>

<a name="157711825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/157711825" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#157711825">Kevin Buzzard (Feb 06 2019 at 18:13)</a>:</h4>
<p><span class="user-mention" data-user-id="119054">@Nguyen Duc Hoan</span> it's OK, the vector space structure is there already, I just appear to have mislaid it.</p>

<a name="157711878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/157711878" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#157711878">Rob Lewis (Feb 06 2019 at 18:14)</a>:</h4>
<p>Ah, this is the magic instance.</p>
<div class="codehilite"><pre><span></span><span class="kn">instance</span> <span class="n">discrete_field</span><span class="bp">.</span><span class="n">to_vector_space</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">vector_space</span> <span class="n">α</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="bp">..</span> <span class="n">ring</span><span class="bp">.</span><span class="n">to_module</span> <span class="o">}</span>
</pre></div>

<a name="157711960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/157711960" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#157711960">Kevin Buzzard (Feb 06 2019 at 18:15)</a>:</h4>
<p>Is this in mathlib?</p>

<a name="157712014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/157712014" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#157712014">Kevin Buzzard (Feb 06 2019 at 18:16)</a>:</h4>
<p><span class="user-mention" data-user-id="119054">@Nguyen Duc Hoan</span> we've nearly found it.</p>

<a name="157712015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/157712015" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#157712015">Rob Lewis (Feb 06 2019 at 18:16)</a>:</h4>
<p>Apparently not, but it will be before long.</p>

<a name="157712031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/157712031" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#157712031">Kevin Buzzard (Feb 06 2019 at 18:16)</a>:</h4>
<p>Aah, apparently it's too cutting edge :-)</p>

<a name="157712035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/157712035" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#157712035">Kevin Buzzard (Feb 06 2019 at 18:16)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span>  :P</p>

<a name="157712043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/157712043" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#157712043">Kevin Buzzard (Feb 06 2019 at 18:16)</a>:</h4>
<p>;-)</p>

<a name="157712230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/157712230" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#157712230">Kevin Buzzard (Feb 06 2019 at 18:19)</a>:</h4>
<p>We are finally there!</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">pi_instances</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">module</span>

<span class="kn">instance</span> <span class="n">discrete_field</span><span class="bp">.</span><span class="n">to_vector_space</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">vector_space</span> <span class="n">α</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="bp">..</span> <span class="n">ring</span><span class="bp">.</span><span class="n">to_module</span> <span class="o">}</span>

<span class="kn">variable</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span>
<span class="n">noncomputable</span> <span class="kn">definition</span> <span class="n">is_it_there_already</span> <span class="o">:</span> <span class="n">vector_space</span> <span class="n">ℝ</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">apply_instance</span>
</pre></div>


<p>So you don't need to write the line defining <code>is_it_there_already</code> : this line is just a test to see that Lean can guess that <code>(fin (n+1) → ℝ)</code> is a vector space. But you do need this funny <code>instance</code> line above. I think Patrick is right, this maybe was there before, but there have been a lot of changes to rings and modules recently and maybe this stopped working.</p>

<a name="157712302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/157712302" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#157712302">Kevin Buzzard (Feb 06 2019 at 18:20)</a>:</h4>
<p>But the point is that you can now <em>remove</em> the line <code>[vector_space ℝ (fin (n+1) → ℝ)]</code> because Lean knows the right vector space structure now.</p>

<a name="157712338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/157712338" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#157712338">Kevin Buzzard (Feb 06 2019 at 18:20)</a>:</h4>
<p>[you need to add the funny <code>instance</code> line instead -- and in a few weeks' time mathlib will perhaps give you an error on this line with message "this is defined already" and then you can just remove it]</p>

<a name="157712695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/157712695" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#157712695">Kevin Buzzard (Feb 06 2019 at 18:26)</a>:</h4>
<p>The same story is true with <code>variable [metric_space (fin (n+1) → ℝ)]</code>. This cannot be right, because this means "put a random metric space structure on <code> (fin (n+1) → ℝ)</code>. I might use this in the following setting: <code>variables (X : Type) [metric space X]</code> -- this is how you tell Lean "let <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07847em;">X</span></span></span></span> be a metric space". It means "let <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07847em;">X</span></span></span></span> be a random set, and then put a random metric space structure on <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07847em;">X</span></span></span></span>". In that context you can see it's the right thing to do -- but in your context you have a very concrete set <code>(fin (n+1) → ℝ)</code> and you almost certainly want the "standard" metric space on that. Now actually here is where we do need <span class="user-mention" data-user-id="110031">@Patrick Massot</span>  -- do we have the metric space structure on this set Patrick, or will Nguyen have to build it himself?</p>

<a name="157713729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/157713729" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#157713729">Patrick Massot (Feb 06 2019 at 18:38)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/blob/master/src/topology/metric_space/basic.lean#L915" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/src/topology/metric_space/basic.lean#L915">https://github.com/leanprover-community/mathlib/blob/master/src/topology/metric_space/basic.lean#L915</a></p>

<a name="157717189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/157717189" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#157717189">Kevin Buzzard (Feb 06 2019 at 19:19)</a>:</h4>
<p><em>doh</em> that's there already. So Lean already knows <code>fin (n+1) → ℝ</code> is a metric space. Sorry Patrick, I just assumed that because it had been added as a variable Lean was complaining that it didn't know.</p>

<a name="157717298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/157717298" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#157717298">Sebastien Gouezel (Feb 06 2019 at 19:20)</a>:</h4>
<p>Warning: the default distance is the sup distance, not the euclidean one.</p>

<a name="157717308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/157717308" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#157717308">Kevin Buzzard (Feb 06 2019 at 19:20)</a>:</h4>
<p>Oh dear, so we have instead defined the unit cube or something.</p>

<a name="157717496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/157717496" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#157717496">Kevin Buzzard (Feb 06 2019 at 19:23)</a>:</h4>
<p>OK so <span class="user-mention" data-user-id="119054">@Nguyen Duc Hoan</span> the metric on a product of metric spaces is not the usual Euclidean one, so now you have some decisions to make :-) Will you redefine your sphere, will you use cubes instead (they are homeomorphic to spheres after all) or will you define the usual metric on R^n? Mathlib's inbuilt metric on R^n is not the usual one.</p>

<a name="157717656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/157717656" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#157717656">Kevin Buzzard (Feb 06 2019 at 19:25)</a>:</h4>
<p>It might be an interesting exercise to define the usual Euclidean metric on R^n, but it might be tricky, and you are also faced with the problem that mathlib already has a metric on R^n and some wise guy made <code>metric_space</code> a class not a structure, meaning that every type is supposed to have at most one metric on it.</p>

<a name="157720938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/157720938" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#157720938">Patrick Massot (Feb 06 2019 at 20:02)</a>:</h4>
<p>It doesn't matter for Borsuk-Ulam, which is a topological result</p>

<a name="157844904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/157844904" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#157844904">Nguyen Duc Hoan (Feb 08 2019 at 09:02)</a>:</h4>
<blockquote>
<p>OK so <span class="user-mention silent" data-user-id="119054">@Nguyen Duc Hoan</span> the metric on a product of metric spaces is not the usual Euclidean one, so now you have some decisions to make :-) Will you redefine your sphere, will you use cubes instead (they are homeomorphic to spheres after all) or will you define the usual metric on R^n? Mathlib's inbuilt metric on R^n is not the usual one.</p>
</blockquote>
<p>I think I need to redefine the sphere S^n because Lean understand <code>sphere_Sn</code> in function <code>(f : sphere_Sn n r → (fin n → ℝ))</code> as a Type not as a set. :(</p>

<a name="157845110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/157845110" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#157845110">Kevin Buzzard (Feb 08 2019 at 09:06)</a>:</h4>
<p>Everything is a type in type theory. You can't really work with sets, they are terms. But a set and the corresponding subtype are exactly the same data.</p>
<p>I was thinking about Patrick's comment. I am not sure that this is a valid way of doing things. I mean, Borsuk-Ulam is a theorem about spheres. You could formalise it as a theorem about hollow cubes, because cubes are spheres topologically, but if you don't formalise the proof of this statement as well then one could argue that you have not formalised Borsuk-Ulam in the sense that you have not formalised something which is provably, in Lean, equivalent. The problem with formalising something which "mathematicians can prove is equivalent" is that you could formalise it as <code>true</code>, which is mathematically equivalent to Borsuk-Ulam because mathematicians can prove that Borsuk-Ulam is true.</p>
<p>On the other hand I'm not sure you need to prove that R^n is a metric space. Why not just define S^n to be the points in R^{n+1} such that the sum of the squares of the coefficients is 1?</p>

<a name="157860957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/157860957" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#157860957">Nguyen Duc Hoan (Feb 08 2019 at 14:04)</a>:</h4>
<p>Actually, I don't know how to get the coefficients of a point in R^n?</p>

<a name="157861135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/157861135" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#157861135">Johan Commelin (Feb 08 2019 at 14:07)</a>:</h4>
<p>It is a function... so you evaluate it on <code>i : fin n</code></p>

<a name="157861231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/157861231" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#157861231">Nguyen Duc Hoan (Feb 08 2019 at 14:09)</a>:</h4>
<p>Moreover, I want to read more about <code>fin n → ℝ</code>. could you please suggest me which files I should read?</p>

<a name="157861269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/157861269" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#157861269">Johan Commelin (Feb 08 2019 at 14:09)</a>:</h4>
<p>Hmmm... what would you want to know precisely?</p>

<a name="157861277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/157861277" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#157861277">Johan Commelin (Feb 08 2019 at 14:09)</a>:</h4>
<p>There is <code>data/fin.lean</code>.</p>

<a name="157862068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/157862068" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#157862068">Nguyen Duc Hoan (Feb 08 2019 at 14:20)</a>:</h4>
<blockquote>
<p>It is a function... so you evaluate it on <code>i : fin n</code></p>
</blockquote>
<p>I mean I want to get x(i) with i = 1..n in <code>x : fin n → ℝ</code>.</p>

<a name="157863629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/157863629" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#157863629">Johan Commelin (Feb 08 2019 at 14:40)</a>:</h4>
<p><code>fin n</code> "=" <code>0 .. (n-1)</code>. So you write <code>(i : fin n)</code> in your hypotheses; and then you can just use <code>x(i)</code> later on.</p>

<a name="157866375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/157866375" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#157866375">Nguyen Duc Hoan (Feb 08 2019 at 15:20)</a>:</h4>
<blockquote>
<p><code>fin n</code> "=" <code>0 .. (n-1)</code>. So you write <code>(i : fin n)</code> in your hypotheses; and then you can just use <code>x(i)</code> later on.</p>
</blockquote>
<p>Thank you! I got it! :D</p>

<a name="159975524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/159975524" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#159975524">Nguyen Duc Hoan (Mar 05 2019 at 04:25)</a>:</h4>
<blockquote>
<p>Everything is a type in type theory. You can't really work with sets, they are terms. But a set and the corresponding subtype are exactly the same data.</p>
<p>I was thinking about Patrick's comment. I am not sure that this is a valid way of doing things. I mean, Borsuk-Ulam is a theorem about spheres. You could formalise it as a theorem about hollow cubes, because cubes are spheres topologically, but if you don't formalise the proof of this statement as well then one could argue that you have not formalised Borsuk-Ulam in the sense that you have not formalised something which is provably, in Lean, equivalent. The problem with formalising something which "mathematicians can prove is equivalent" is that you could formalise it as <code>true</code>, which is mathematically equivalent to Borsuk-Ulam because mathematicians can prove that Borsuk-Ulam is true.</p>
<p>On the other hand I'm not sure you need to prove that R^n is a metric space. Why not just define S^n to be the points in R^{n+1} such that the sum of the squares of the coefficients is 1?</p>
</blockquote>
<p>I tried to write the function of sum of squares the coefficients of R^{n+1}. However I got many errors, could you please give me some advice?</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">sum_of_square_coeff</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">{</span><span class="n">x</span><span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">[</span><span class="n">has_zero</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)]</span> <span class="o">:</span> <span class="n">ℝ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">x</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span><span class="bp">*</span><span class="n">x</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">sum_coeff1</span> <span class="o">(</span><span class="n">n</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">))</span><span class="bp">*</span><span class="o">(</span><span class="n">sum_coeff1</span> <span class="o">(</span><span class="n">n</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">))</span>  <span class="bp">+</span> <span class="o">(</span><span class="n">x</span><span class="o">(</span><span class="n">n</span><span class="o">))</span><span class="bp">*</span><span class="n">x</span><span class="o">((</span><span class="n">n</span><span class="o">))</span>
</pre></div>

<a name="159978120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/159978120" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#159978120">Johan Commelin (Mar 05 2019 at 05:27)</a>:</h4>
<p><span class="user-mention" data-user-id="119054">@Nguyen Duc Hoan</span> What exactly do you want to do? In math language, do you want: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msubsup><mi>f</mi><mo>(</mo><mi>i</mi><msup><mo>)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\sum_{i=0}^{n-1} f(i)^2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.954008em;"></span><span class="strut bottom" style="height:1.253718em;vertical-align:-0.29971000000000003em;"></span><span class="base"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.954008em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">i</span><span class="mrel mtight">=</span><span class="mord mathrm mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">n</span><span class="mbin mtight">−</span><span class="mord mathrm mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"></span></span></span></span></span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">i</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">2</span></span></span></span></span></span></span></span></span></span></span>? If so, you can use something like</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">sum_of_square_coeff</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">{</span><span class="n">x</span><span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum</span> <span class="n">univ</span> <span class="o">(</span><span class="err">\</span><span class="n">lam</span> <span class="n">i</span><span class="o">,</span> <span class="n">f</span><span class="o">(</span><span class="n">i</span><span class="o">)</span><span class="err">^</span><span class="mi">2</span><span class="o">)</span>
</pre></div>

<a name="159978300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/159978300" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#159978300">Johan Commelin (Mar 05 2019 at 05:30)</a>:</h4>
<p>Note that you need to fix the <code>\lam</code> into a proper lambda. This code depends on <code>finset.sum</code> which is in mathlib. If you don't want to depend on mathlib, then you can try to roll your own definition using recursion, like you did above. But it will be somewhat ugly, because you have to restrict <code>f</code> to <code>fin (n-1)</code>, but of course this isn't really a restriction, because it doesn't make sense in type theory to say that <code>fin (n-1)</code> is a subset of <code>fin n</code>.</p>

<a name="159980753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/159980753" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#159980753">Nguyen Duc Hoan (Mar 05 2019 at 06:38)</a>:</h4>
<p>I want to compute <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>x</mi><mn>0</mn><mn>2</mn></msubsup><mo>+</mo><msubsup><mi>x</mi><mn>1</mn><mn>2</mn></msubsup><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msubsup><mi>x</mi><mi>n</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">x_0^2 + x_1^2 +...+x_n^2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.0622159999999998em;vertical-align:-0.24810799999999997em;"></span><span class="base"><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4518920000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">0</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"></span></span></span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4518920000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"></span></span></span></span></span><span class="mbin">+</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mbin">+</span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">n</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"></span></span></span></span></span></span></span></span> where <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>∈</mo><msup><mi>R</mi><mi>n</mi></msup><mtext> and </mtext><mi>X</mi><mo>=</mo><mo>(</mo><msub><mi>x</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><msup><mo>)</mo><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">X \in R^n \text{  and  } X = (x_0, x_1,...,x_{n-1})^T</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07847em;">X</span><span class="mrel">∈</span><span class="mord"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">n</span></span></span></span></span></span></span></span><span class="mord text"><span class="mord mathrm"> and </span></span><span class="mord mathit" style="margin-right:0.07847em;">X</span><span class="mrel">=</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mpunct">,</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">n</span><span class="mbin mtight">−</span><span class="mord mathrm mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span></p>

<a name="159981234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/159981234" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#159981234">Kevin Buzzard (Mar 05 2019 at 06:52)</a>:</h4>
<p>You have an undefined <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">x_n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> there :-) Doesn't Johan's code do what you want though?</p>

<a name="159981398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/159981398" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#159981398">Nguyen Duc Hoan (Mar 05 2019 at 06:56)</a>:</h4>
<p>I don't understand the function "finset.sum". Where can I find the function "finset.sum" in mathlib? I couldn't find :(</p>

<a name="159982250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/159982250" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#159982250">Johan Commelin (Mar 05 2019 at 07:19)</a>:</h4>
<p><span class="user-mention" data-user-id="119054">@Nguyen Duc Hoan</span> Voila: <a href="https://github.com/leanprover-community/mathlib/blob/master/src/algebra/big_operators.lean#L28" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/src/algebra/big_operators.lean#L28">https://github.com/leanprover-community/mathlib/blob/master/src/algebra/big_operators.lean#L28</a></p>

<a name="159983472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/159983472" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#159983472">Kevin Buzzard (Mar 05 2019 at 07:49)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">open</span> <span class="n">finset</span>

<span class="n">def</span> <span class="n">sum_of_square_coeff</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">{</span><span class="n">x</span><span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">:=</span>
<span class="n">sum</span> <span class="n">univ</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="n">i</span><span class="o">)</span><span class="err">^</span><span class="mi">2</span><span class="o">)</span>
</pre></div>

<a name="160049911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/160049911" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#160049911">Nguyen Duc Hoan (Mar 05 2019 at 23:08)</a>:</h4>
<p>Yes, that is what I want. Thank you! <span aria-label="grinning face with smiling eyes" class="emoji emoji-1f601" role="img" title="grinning face with smiling eyes">:grinning_face_with_smiling_eyes:</span></p>

<a name="160493300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/160493300" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#160493300">Nguyen Duc Hoan (Mar 11 2019 at 16:22)</a>:</h4>
<p>Hello again, I defined the sphere S^n in Lean. I used the theorem <code>mem_sphere_Sn</code> to define what is member of sphere S^n, and the theorem <code>sym_sphere_Sn</code> to define if <code>x ∈ sphere_Sn</code> then <code>(-x) ∈ sphere_Sn</code>. However, I got some problems with these theorems. Could you please help me?</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">init</span><span class="bp">.</span><span class="n">data</span><span class="bp">.</span><span class="n">nat</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">open</span> <span class="n">finset</span>

<span class="kn">variable</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="n">nat</span><span class="o">)</span>

<span class="n">def</span> <span class="n">sum_of_square_coeff</span> <span class="o">{</span><span class="n">n</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">:=</span>
<span class="n">sum</span> <span class="n">univ</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="n">i</span><span class="o">)</span><span class="err">^</span><span class="mi">2</span><span class="o">)</span>

<span class="n">def</span> <span class="n">sphere_Sn</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span><span class="bp">|</span> <span class="n">sum_of_square_coeff</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">}</span>

<span class="kn">variable</span> <span class="n">x</span><span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span>

<span class="kn">theorem</span> <span class="n">mem_sphere_Sn</span> <span class="o">:</span>  <span class="bp">∀</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">sphere_Sn</span> <span class="n">n</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">sum_of_square_coeff</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">theorem</span> <span class="n">sym_sphere_Sn</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">sphere_Sn</span> <span class="n">n</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">-</span><span class="n">x</span><span class="o">)</span> <span class="err">∈</span>  <span class="n">sphere_Sn</span> <span class="n">n</span> <span class="o">:=</span><span class="n">sorry</span>
</pre></div>

<a name="160493971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/160493971" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#160493971">Rob Lewis (Mar 11 2019 at 16:30)</a>:</h4>
<p>There are a few issues. Luckily they're easy to fix. Instead of writing <code>∀ x ∈ sphere_Sn n ↔ (sum_of_square_coeff x = 1)</code>, you should write <code>∀ x, x ∈ sphere_Sn n ↔ (sum_of_square_coeff x = 1)</code>. (You could also move the <code>x</code> to the left of the <code>:</code>.) Also, with the imports you have, Lean doesn't know what <code>-x</code> means. You need to include something from mathlib that adds the right instance. <code>import algebra.pi_instances</code> will work.</p>

<a name="160494066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/160494066" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#160494066">Rob Lewis (Mar 11 2019 at 16:31)</a>:</h4>
<p>Your first theorem has a very easy proof.</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">mem_sphere_Sn</span> <span class="o">:</span>  <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">sphere_Sn</span> <span class="n">n</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">sum_of_square_coeff</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">iff</span><span class="bp">.</span><span class="n">refl</span> <span class="bp">_</span>
</pre></div>


<p>The second one will take you slightly more work.</p>

<a name="160499990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/160499990" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#160499990">Nguyen Duc Hoan (Mar 11 2019 at 17:34)</a>:</h4>
<p>Thank you! Let me try to prove the second theorem.</p>

<a name="161360602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/161360602" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#161360602">Nguyen Duc Hoan (Mar 21 2019 at 16:10)</a>:</h4>
<p>Hello again,<br>
I tried to prove a theorem that is <code>x : fin n→ ℝ</code> and <code>sum_of_square_coeff x = 1</code> then <code>sum_of_square_coeff (-x) = 1</code>. To prove that I tried to find relationship between <code>x</code> and <code>-x</code> in file <code>data/fintype.lean</code> but I could not find anything. Then I had no ideas for proving. Could you please give some hints?<br>
This is my code</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">analysis</span><span class="bp">.</span><span class="n">exponential</span> <span class="n">topology</span><span class="bp">.</span><span class="n">algebra</span><span class="bp">.</span><span class="n">infinite_sum</span>
<span class="kn">import</span> <span class="n">init</span><span class="bp">.</span><span class="n">data</span><span class="bp">.</span><span class="n">nat</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">pi_instances</span>
<span class="kn">open</span> <span class="n">finset</span>

<span class="kn">variable</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="n">nat</span><span class="o">)</span>

<span class="n">def</span> <span class="n">sum_of_square_coeff</span> <span class="o">{</span><span class="n">n</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">:=</span>
<span class="n">sum</span> <span class="n">univ</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="n">i</span><span class="o">)</span><span class="err">^</span><span class="mi">2</span><span class="o">)</span>


<span class="kn">theorem</span> <span class="n">sum_of_square_coeff_neg_x</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="n">sum_of_square_coeff</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">sum_of_square_coeff</span> <span class="o">(</span><span class="bp">-</span><span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="k">begin</span>

<span class="kn">end</span>
</pre></div>

<a name="161369123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/161369123" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#161369123">Sebastien Gouezel (Mar 21 2019 at 17:42)</a>:</h4>
<p>You need to use the fact that the square of <code>-a</code> is the same as the square of <code>a</code>. I asked <code>library_search</code>, and it told me that this is called <code>neg_square</code>. Then you can do a proof by hand. However, it is much more efficient to let the simplifier do the work for you. Just help it a little by telling it that it should expand <code>sum_of_square_coeff</code>, and then it can do everything.</p>
<div class="codehilite"><pre><span></span><span class="k">by</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">sum_of_square_coeff</span><span class="o">]</span>
</pre></div>


<p>The <code>a</code> in <code>simpa</code> tells it to simplify as much as it can, and then try to use some assumption (i.e., some information that is already available in the context) to prove the theorem.</p>

<a name="161369247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/161369247" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#161369247">Kevin Buzzard (Mar 21 2019 at 17:43)</a>:</h4>
<p>[cue <span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  pointing out that this is is not quite what <code>simpa</code> does, even though it's what people always say it's what it does]</p>

<a name="161369446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/161369446" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#161369446">Patrick Massot (Mar 21 2019 at 17:45)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/blob/master/docs/tactics.md#simpa" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/docs/tactics.md#simpa">https://github.com/leanprover-community/mathlib/blob/master/docs/tactics.md#simpa</a></p>

<a name="161369758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/161369758" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#161369758">Sebastien Gouezel (Mar 21 2019 at 17:49)</a>:</h4>
<p>In the version without <code>using</code> or <code>this</code>, it does just use assumption to close the goal, as I said, if I understand the docs. Otherwise, it is more clever.</p>

<a name="161371189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/161371189" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#161371189">Kevin Buzzard (Mar 21 2019 at 18:05)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">this</span> <span class="o">:</span> <span class="bp">-</span><span class="o">(</span><span class="bp">-</span><span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">5</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">5</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">simpa</span>
<span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">that</span> <span class="o">:</span> <span class="bp">-</span><span class="o">(</span><span class="bp">-</span><span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">5</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">5</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">simpa</span> <span class="c1">-- fails</span>
</pre></div>


<p>Even without mentioning <code>this</code> explicitly, the behaviour of <code>simpa</code> changes if there is a <code>this</code> in the context</p>

<a name="161371328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/161371328" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#161371328">Sebastien Gouezel (Mar 21 2019 at 18:07)</a>:</h4>
<p>You are right. I did not understand the docs. I read "if present" as "if you provide it in the list of things to simplify", not as "in the context".</p>

<a name="161371437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/161371437" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#161371437">Kevin Buzzard (Mar 21 2019 at 18:08)</a>:</h4>
<p>I think it's because Mario got sick of typing <code>suffices : blah, simpa using [this]</code></p>

<a name="161475923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/161475923" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#161475923">Nguyen Duc Hoan (Mar 22 2019 at 19:22)</a>:</h4>
<blockquote>
<p>You need to use the fact that the square of <code>-a</code> is the same as the square of <code>a</code>. I asked <code>library_search</code>, and it told me that this is called <code>neg_square</code>. Then you can do a proof by hand. However, it is much more efficient to let the simplifier do the work for you. Just help it a little by telling it that it should expand <code>sum_of_square_coeff</code>, and then it can do everything.</p>
<div class="codehilite"><pre><span></span><span class="k">by</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">sum_of_square_coeff</span><span class="o">]</span>
</pre></div>


<p>The <code>a</code> in <code>simpa</code> tells it to simplify as much as it can, and then try to use some assumption (i.e., some information that is already available in the context) to prove the theorem.</p>
</blockquote>
<p>Did you mean this? </p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">def</span> <span class="n">sum_of_square_coeff</span> <span class="o">{</span><span class="n">n</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">:=</span>
<span class="n">sum</span> <span class="n">univ</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="n">i</span><span class="o">)</span><span class="err">^</span><span class="mi">2</span><span class="o">)</span>

<span class="kn">theorem</span> <span class="n">sum_of_square_coeff_neg_x</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="n">sum_of_square_coeff</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">sum_of_square_coeff</span> <span class="o">(</span><span class="bp">-</span><span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">sum_of_square_coeff</span><span class="o">]</span>
</pre></div>


<p>I tried but it looks like the problem is not solved. There is no error but lean say that </p>
<div class="codehilite"><pre><span></span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span>
<span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="n">sum_of_square_coeff</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span>
<span class="err">⊢</span> <span class="n">sum_of_square_coeff</span> <span class="o">(</span><span class="bp">-</span><span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span>
</pre></div>

<a name="161478915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/161478915" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#161478915">Johan Commelin (Mar 22 2019 at 20:00)</a>:</h4>
<p>I don't think you want the <code>@[simp]</code> in front of your <code>def</code>. Unless you always want <code>simp</code> to unfold that definition. In that case you don't have to pass it to <code>simpa</code> in the <code>theorem</code>.</p>

<a name="161481397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/161481397" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#161481397">Kevin Buzzard (Mar 22 2019 at 20:34)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">analysis</span><span class="bp">.</span><span class="n">exponential</span> <span class="n">topology</span><span class="bp">.</span><span class="n">algebra</span><span class="bp">.</span><span class="n">infinite_sum</span>
<span class="kn">import</span> <span class="n">init</span><span class="bp">.</span><span class="n">data</span><span class="bp">.</span><span class="n">nat</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">pi_instances</span>
<span class="kn">open</span> <span class="n">finset</span>

<span class="kn">variable</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="n">nat</span><span class="o">)</span>

<span class="n">def</span> <span class="n">sum_of_square_coeff</span> <span class="o">{</span><span class="n">n</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">:=</span>
<span class="n">sum</span> <span class="n">univ</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="n">i</span><span class="o">)</span><span class="err">^</span><span class="mi">2</span><span class="o">)</span>


<span class="kn">theorem</span> <span class="n">sum_of_square_coeff_neg_x</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="n">sum_of_square_coeff</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">sum_of_square_coeff</span> <span class="o">(</span><span class="bp">-</span><span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">sum_of_square_coeff</span><span class="o">]</span>
</pre></div>

<a name="161482328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Borsuk%20Ulam%20theorem/near/161482328" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/56506BorsukUlamtheorem.html#161482328">Kevin Buzzard (Mar 22 2019 at 20:46)</a>:</h4>
<p><span class="user-mention" data-user-id="119054">@Nguyen Duc Hoan</span> What you wrote also works. Are you sure you are understanding Lean correctly? If there is no error then everything has worked. Whatever Lean "says" just depends on where you put the cursor.</p>


{% endraw %}

{% include archive_update.html %}