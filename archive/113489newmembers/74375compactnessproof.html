---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113489newmembers/74375compactnessproof.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/74375compactnessproof.html">compactness proof</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="180151401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/compactness%20proof/near/180151401" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74375compactnessproof.html#180151401">Lambert A'Campo (Nov 07 2019 at 16:55)</a>:</h4>
<p>Could someone give me an example of a compactness proof in Lean?<br>
For example assuming that the closed unit ball is compact, <br>
there are finitely many points a_1, ..., a_n such that every any <br>
point in the unit ball is at most 1/2 from one of the a_i.</p>

<a name="180161675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/compactness%20proof/near/180161675" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74375compactnessproof.html#180161675">Kevin Buzzard (Nov 07 2019 at 18:46)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">topology</span><span class="bp">.</span><span class="n">metric_space</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">metric_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">(</span><span class="n">O</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span>
<span class="o">(</span><span class="n">Hcomp</span> <span class="o">:</span> <span class="n">compact</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">|</span> <span class="n">dist</span> <span class="n">O</span> <span class="n">x</span> <span class="bp">≤</span> <span class="mi">1</span><span class="o">})</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">hr</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">X</span><span class="o">),</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">A</span><span class="o">,</span> <span class="n">dist</span> <span class="n">O</span> <span class="n">x</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="bp">→</span> <span class="n">dist</span> <span class="n">x</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">r</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>


<p>(any <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">r&gt;0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> will do rather than <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">1/2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord">2</span></span></span></span> I guess)</p>

<a name="180182089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/compactness%20proof/near/180182089" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74375compactnessproof.html#180182089">Kevin Buzzard (Nov 07 2019 at 22:11)</a>:</h4>
<p>In discussions with Lambert I realised that <code>compact_iff_finite_subcover</code> is not an ideal first step in this proof.</p>

<a name="180182252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/compactness%20proof/near/180182252" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74375compactnessproof.html#180182252">Kevin Buzzard (Nov 07 2019 at 22:13)</a>:</h4>
<p>Is something like <code>compact (s : set X) iff forall J, forall f : J -&gt; set X, (forall j, is_open f j) -&gt; ... exists J' : finset J, ...</code> in mathlib?</p>

<a name="180182314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/compactness%20proof/near/180182314" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74375compactnessproof.html#180182314">Kevin Buzzard (Nov 07 2019 at 22:14)</a>:</h4>
<p><code>compact_iff_finite_subcover</code> is <code>compact s ↔ (∀c, (∀t∈c, is_open t) → s ⊆ ⋃₀ c → ∃c'⊆c, finite c' ∧ s ⊆ ⋃₀ c')</code></p>

<a name="180182361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/compactness%20proof/near/180182361" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74375compactnessproof.html#180182361">Kevin Buzzard (Nov 07 2019 at 22:14)</a>:</h4>
<p>and here it would be easier to have the version involving an indexed family of opens</p>


{% endraw %}

{% include archive_update.html %}