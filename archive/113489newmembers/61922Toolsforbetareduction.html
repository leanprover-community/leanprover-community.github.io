---
layout: archive
title: Lean Prover Zulip Chat Archive 
permalink: archive/113489newmembers/61922Toolsforbetareduction.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/61922Toolsforbetareduction.html">Tools for beta reduction</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="159222707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tools%20for%20beta%20reduction/near/159222707" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/61922Toolsforbetareduction.html#159222707">Calle Sönne (Feb 23 2019 at 09:49)</a>:</h4>
<p>I have following code:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">limit_start_irrelevant</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">is_limit</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">a</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="n">k</span><span class="o">))</span> <span class="n">l</span><span class="o">)</span> <span class="o">:</span> <span class="n">is_limit</span> <span class="n">a</span> <span class="n">l</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span> <span class="n">ε</span> <span class="n">Hε</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h</span> <span class="n">ε</span> <span class="n">Hε</span> <span class="k">with</span> <span class="n">N</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">N</span> <span class="bp">+</span> <span class="n">k</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">n</span> <span class="n">Hn</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">ineq</span> <span class="o">:</span> <span class="n">k</span> <span class="bp">≤</span> <span class="n">n</span><span class="o">,</span> <span class="n">rw</span> <span class="n">add_comm</span> <span class="n">at</span> <span class="n">Hn</span><span class="o">,</span> <span class="n">exact</span> <span class="o">(</span><span class="n">le_trans</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">le_sub_right_of_add_le</span> <span class="n">Hn</span><span class="o">)</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">sub_le_self</span> <span class="n">n</span> <span class="n">N</span><span class="o">)),</span>
  <span class="n">specialize</span> <span class="n">H</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="n">k</span><span class="o">)</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">le_sub_right_of_add_le</span> <span class="n">Hn</span><span class="o">),</span>  <span class="c1">-- Tactic state 1 here</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="n">at</span> <span class="n">H</span><span class="o">,</span> <span class="c1">-- Tactic state 2 here</span>
  <span class="n">rwa</span> <span class="o">[</span><span class="n">add_comm</span><span class="o">,</span> <span class="err">←</span><span class="n">nat</span><span class="bp">.</span><span class="n">add_sub_assoc</span> <span class="n">ineq</span><span class="o">,</span> <span class="n">add_comm</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">add_sub_cancel</span><span class="o">]</span> <span class="n">at</span> <span class="n">H</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p>Tactic state 1:</p>
<div class="codehilite"><pre><span></span>a : ℕ → ℝ,
k : ℕ,
l : ℝ,
h : is_limit (λ (n : ℕ), a (n + k)) l,
ε : ℝ,
Hε : ε &gt; 0,
N n : ℕ,
Hn : n ≥ N + k,
ineq : k ≤ n,
H : |(λ (n : ℕ), a (n + k)) (n - k) - l| &lt; ε
⊢ |a n - l| &lt; ε
</pre></div>


<p>Tactic state 2:</p>
<div class="codehilite"><pre><span></span>a : ℕ → ℝ,
k : ℕ,
l : ℝ,
h : is_limit (λ (n : ℕ), a (n + k)) l,
ε : ℝ,
Hε : ε &gt; 0,
N n : ℕ,
Hn : n ≥ N + k,
ineq : k ≤ n,
H : |a (n - k + k) - l| &lt; ε
⊢ |a n - l| &lt; ε
</pre></div>


<p>Right now I am forced to use simp only to beta reduce H, because otherwise rw doesnt work. Is there any special tools for beta reduction I could use? Simp only feels unnecessary.</p>

<a name="159222755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tools%20for%20beta%20reduction/near/159222755" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/61922Toolsforbetareduction.html#159222755">Calle Sönne (Feb 23 2019 at 09:50)</a>:</h4>
<p>I see that I can use convert H as well, but this also feels like overkill.</p>

<a name="159223145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tools%20for%20beta%20reduction/near/159223145" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/61922Toolsforbetareduction.html#159223145">Mario Carneiro (Feb 23 2019 at 10:04)</a>:</h4>
<p>you could use <code>dsimp only</code> as well</p>

<a name="159223165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tools%20for%20beta%20reduction/near/159223165" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/61922Toolsforbetareduction.html#159223165">Mario Carneiro (Feb 23 2019 at 10:05)</a>:</h4>
<p>If you play with the options you can get it to simplify almost nothing except beta reduction, but there isn't a dedicated command for it</p>

<a name="159223266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tools%20for%20beta%20reduction/near/159223266" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/61922Toolsforbetareduction.html#159223266">Kevin Buzzard (Feb 23 2019 at 10:08)</a>:</h4>
<p>If you want to change H to something definitionally equal, you can just write "change [thing you want] at H"</p>

<a name="159226619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tools%20for%20beta%20reduction/near/159226619" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/61922Toolsforbetareduction.html#159226619">Patrick Massot (Feb 23 2019 at 11:58)</a>:</h4>
<p>As Kevin wrote, you can use change to force rewriting to something definitionaly equivalent. But in this case you want to use <code>convert</code> anyway, because you also want to make Lean realize you need <code>n-k+k=n</code> or something like that. What is it you don't like in my version:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">limit_start_irrelevant</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">M1P1</span><span class="bp">.</span><span class="n">is_limit</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">a</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="n">n</span><span class="o">))</span> <span class="n">l</span><span class="o">)</span> <span class="o">:</span> <span class="n">M1P1</span><span class="bp">.</span><span class="n">is_limit</span> <span class="n">a</span> <span class="n">l</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span> <span class="n">ε</span> <span class="n">Hε</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h</span> <span class="n">ε</span> <span class="n">Hε</span> <span class="k">with</span> <span class="n">N</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">k</span> <span class="bp">+</span> <span class="n">N</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">n</span> <span class="n">Hn</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">key</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">-</span> <span class="n">k</span> <span class="bp">≥</span> <span class="n">N</span> <span class="o">:=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">le_sub_left_of_add_le</span> <span class="n">Hn</span><span class="o">,</span>
  <span class="n">convert</span> <span class="n">H</span> <span class="o">(</span><span class="n">n</span><span class="bp">-</span><span class="n">k</span><span class="o">)</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">int</span><span class="bp">.</span><span class="n">coe_nat_inj</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">int</span><span class="bp">.</span><span class="n">coe_nat_add</span><span class="o">,</span> <span class="n">int</span><span class="bp">.</span><span class="n">coe_nat_sub</span><span class="o">],</span>
  <span class="n">repeat</span> <span class="o">{</span> <span class="n">linarith</span> <span class="o">},</span>
<span class="kn">end</span>
</pre></div>

<a name="159230282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tools%20for%20beta%20reduction/near/159230282" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/61922Toolsforbetareduction.html#159230282">Calle Sönne (Feb 23 2019 at 13:54)</a>:</h4>
<p>I like your version much better, but I wont learn anything if I just copy-paste it into my file. I was comparing my code to yours and rewriting it in the process.</p>

<a name="159230433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tools%20for%20beta%20reduction/near/159230433" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/61922Toolsforbetareduction.html#159230433">Calle Sönne (Feb 23 2019 at 13:59)</a>:</h4>
<p>Also, speaking about your code, The last line: <code> repeat { linarith }, </code> seems to remove 3 goals. Why is that?</p>

<a name="159230514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tools%20for%20beta%20reduction/near/159230514" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/61922Toolsforbetareduction.html#159230514">Calle Sönne (Feb 23 2019 at 14:01)</a>:</h4>
<p>The last goal is instantly solved by one of the hypothesis, so does linarith (or repeat?) just try the hypothesis on the next goal to see if it works?</p>

<a name="159231931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tools%20for%20beta%20reduction/near/159231931" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/61922Toolsforbetareduction.html#159231931">Johan Commelin (Feb 23 2019 at 14:45)</a>:</h4>
<p><span class="user-mention" data-user-id="132603">@Calle Sönne</span> <code>repeat {linarith},</code> is just the same as</p>
<div class="codehilite"><pre><span></span><span class="n">linarith</span><span class="o">,</span>
<span class="n">linarith</span><span class="o">,</span>
<span class="n">linarith</span><span class="o">,</span>
<span class="n">linarith</span><span class="o">,</span>
<span class="bp">...</span>
<span class="c1">-- until one of them fails</span>
</pre></div>

<a name="159232076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tools%20for%20beta%20reduction/near/159232076" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/61922Toolsforbetareduction.html#159232076">Kenny Lau (Feb 23 2019 at 14:50)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">private</span> <span class="n">meta</span> <span class="n">def</span> <span class="n">repeat_aux</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="n">unit</span>
<span class="bp">|</span> <span class="o">[]</span>      <span class="n">r</span> <span class="o">:=</span> <span class="n">set_goals</span> <span class="n">r</span><span class="bp">.</span><span class="n">reverse</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">g</span><span class="bp">::</span><span class="n">gs</span><span class="o">)</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">do</span>
  <span class="n">ok</span> <span class="err">←</span> <span class="n">try_core</span> <span class="o">(</span><span class="n">set_goals</span> <span class="o">[</span><span class="n">g</span><span class="o">]</span> <span class="bp">&gt;&gt;</span> <span class="n">t</span><span class="o">),</span>
  <span class="k">match</span> <span class="n">ok</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">none</span> <span class="o">:=</span> <span class="n">repeat_aux</span> <span class="n">gs</span> <span class="o">(</span><span class="n">g</span><span class="bp">::</span><span class="n">r</span><span class="o">)</span>
  <span class="bp">|</span> <span class="bp">_</span>    <span class="o">:=</span> <span class="n">do</span>
    <span class="n">gs&#39;</span> <span class="err">←</span> <span class="n">get_goals</span><span class="o">,</span>
    <span class="n">repeat_aux</span> <span class="o">(</span><span class="n">gs&#39;</span> <span class="bp">++</span> <span class="n">gs</span><span class="o">)</span> <span class="n">r</span>
  <span class="kn">end</span>

<span class="c">/-</span><span class="cm">- This tactic is applied to each goal. If the application succeeds,</span>
<span class="cm">    the tactic is applied recursively to all the generated subgoals until it eventually fails.</span>
<span class="cm">    The recursion stops in a subgoal when the tactic has failed to make progress.</span>
<span class="cm">    The tactic `repeat` never fails. -/</span>
<span class="n">meta</span> <span class="n">def</span> <span class="n">repeat</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">do</span> <span class="n">gs</span> <span class="err">←</span> <span class="n">get_goals</span><span class="o">,</span> <span class="n">repeat_aux</span> <span class="n">t</span> <span class="n">gs</span> <span class="o">[]</span>
</pre></div>

<a name="159232668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tools%20for%20beta%20reduction/near/159232668" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/61922Toolsforbetareduction.html#159232668">Calle Sönne (Feb 23 2019 at 15:06)</a>:</h4>
<p>Ah, for some reason I thought it meant reapeat once.</p>

<a name="159232840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tools%20for%20beta%20reduction/near/159232840" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/61922Toolsforbetareduction.html#159232840">Mario Carneiro (Feb 23 2019 at 15:11)</a>:</h4>
<p>that would be <code>iterate 2</code></p>


{% endraw %}
