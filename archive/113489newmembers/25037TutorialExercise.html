---
layout: archive
title: Lean Prover Zulip Chat Archive 
permalink: archive/113489newmembers/25037TutorialExercise.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html">Tutorial Exercise</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="165233857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165233857" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165233857">Lukas (May 09 2019 at 08:30)</a>:</h4>
<p>I am working on the Blog article on constructing the natural numbers <a href="https://xenaproject.wordpress.com/2017/10/31/building-the-non-negative-integers-from-scratch/" target="_blank" title="https://xenaproject.wordpress.com/2017/10/31/building-the-non-negative-integers-from-scratch/">https://xenaproject.wordpress.com/2017/10/31/building-the-non-negative-integers-from-scratch/</a></p>
<p>Now I am stuck in one proof:</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">one_add_eq_succ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">xnat</span><span class="o">)</span> <span class="o">:</span> <span class="n">one</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">succ</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rewrite</span> <span class="n">one</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">t</span> <span class="n">Ht</span><span class="o">,</span>
  <span class="o">{</span>
    <span class="n">rewrite</span> <span class="n">add_zero</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="o">{</span>
    <span class="n">rewrite</span> <span class="n">add</span><span class="o">,</span>
    <span class="n">sorry</span><span class="o">,</span>
  <span class="o">}</span>
<span class="kn">end</span>
</pre></div>


<p>I think this scan be solved via succ.inj, but I do not know how to apply this here.</p>

<a name="165233876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165233876" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165233876">Mario Carneiro (May 09 2019 at 08:31)</a>:</h4>
<p><code>injection</code> is the tactic version of <code>apply succ.inj</code></p>

<a name="165233894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165233894" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165233894">Mario Carneiro (May 09 2019 at 08:31)</a>:</h4>
<p>or <code>cases</code> in some cases</p>

<a name="165234313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165234313" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165234313">Lukas (May 09 2019 at 08:39)</a>:</h4>
<p><code>apply succ.inj</code> turns <code>⊢ succ (succ zero + t) = succ (succ t)</code> goal into <code>⊢ succ (succ (succ zero + t)) = succ (succ (succ t))</code> so it does the inverse of what I want to do.</p>
<p>How can I apply the injection tactic here?</p>

<a name="165234497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165234497" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165234497">Mario Carneiro (May 09 2019 at 08:42)</a>:</h4>
<p>oh, you want <code>congr</code> then</p>

<a name="165234521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165234521" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165234521">Mario Carneiro (May 09 2019 at 08:43)</a>:</h4>
<p>if you have <code>h : succ a = succ b</code> in the context, <code>injection h</code> will turn it into <code>a = b</code></p>

<a name="165234531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165234531" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165234531">Mario Carneiro (May 09 2019 at 08:43)</a>:</h4>
<p>but if <code>succ a = succ b</code> is the goal, then you don't need injectivity, that's just functions respecting equality which is <code>congr</code></p>

<a name="165235045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165235045" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165235045">Kevin Buzzard (May 09 2019 at 08:53)</a>:</h4>
<p>After <code>rewrite add</code> you can use the inductive hypothesis <code>Ht</code> -- just <code>rewrite Ht</code>.</p>

<a name="165235369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165235369" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165235369">Kevin Buzzard (May 09 2019 at 08:58)</a>:</h4>
<p>PS any feedback welcome. Over the summer I fully intend to expand that stuff into a more coherent and far-reaching tutorial for mathematicians, covering the naturals, the complexes, and various other ideas I have lying around.</p>

<a name="165235445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165235445" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165235445">Lukas (May 09 2019 at 08:59)</a>:</h4>
<p>That should have been obvious...</p>

<a name="165235573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165235573" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165235573">Lukas (May 09 2019 at 09:01)</a>:</h4>
<p>The Tutorial for the natural numbers is great, but as there are no solutions to the exercise I have to ask many questions.</p>

<a name="165235636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165235636" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165235636">Johan Commelin (May 09 2019 at 09:02)</a>:</h4>
<p>That's how all of us have learnt Lean</p>

<a name="165235644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165235644" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165235644">Johan Commelin (May 09 2019 at 09:02)</a>:</h4>
<p>Except for some magic wizards, who read the source code</p>

<a name="165235735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165235735" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165235735">Kevin Buzzard (May 09 2019 at 09:04)</a>:</h4>
<p><span class="user-mention" data-user-id="207747">@Lukas</span> I wrote that tutorial and I had no solutions to the exercises either ;-) Some students at Imperial College sent me solutions and I did dump them somewhere on the internet...perhaps in the Xena project github repository (a.k.a. pile of random Lean files which I and some students wrote when we were all complete beginners 18 months ago).</p>

<a name="165327533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165327533" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165327533">Lukas (May 10 2019 at 11:17)</a>:</h4>
<p>I just came across another problem. I defined the predicate for even like this:</p>
<div class="codehilite"><pre><span></span><span class="kn">definition</span> <span class="n">even</span><span class="o">:</span> <span class="n">xnat</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:=</span> <span class="n">true</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">even</span> <span class="n">m</span><span class="o">)</span>
</pre></div>


<p>but I can not figure out a way to test this <code>#check even one</code> does only show the Type prop but not the value. <code>#reduce even zero</code> leads as expected to true, but <code>#reduce even one</code> leads <code>true → false</code> which is false, but this becomes quickly unreadable as <code>#reduce even two</code> is <code>(true → false) → false</code>.</p>

<a name="165328327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165328327" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165328327">Kevin Buzzard (May 10 2019 at 11:30)</a>:</h4>
<p>I think I would be tempted to define <code>beven</code> here, a function from <code>xnat</code> to <code>bool</code>, which is defined in Lean as <code>{ff,tt}</code>, and use <code>bnot</code> instead of <code>not</code>. Then you can define <code>even</code> to mean <code>beven n = tt</code></p>

<a name="165328352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165328352" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165328352">Kevin Buzzard (May 10 2019 at 11:31)</a>:</h4>
<p>PS you might have more luck with <code>#eval</code> than <code>#reduce</code>?</p>

<a name="165329196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165329196" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165329196">Lukas (May 10 2019 at 11:45)</a>:</h4>
<p>The definition as function from <code>xnat</code> to <code>Prop</code> is taken from the blog article. With bool, bnot the definition works. Now my implementation look like this:</p>
<div class="codehilite"><pre><span></span><span class="kn">definition</span> <span class="n">beven</span><span class="o">:</span> <span class="n">xnat</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:=</span> <span class="n">tt</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span>  <span class="n">bnot</span> <span class="o">(</span><span class="n">beven</span> <span class="n">m</span><span class="o">)</span>

<span class="kn">definition</span> <span class="n">even</span> <span class="o">(</span><span class="n">m</span><span class="o">:</span> <span class="n">xnat</span><span class="o">):</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">beven</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">tt</span>
</pre></div>


<p><code>#reduce zero</code> no gives me <code>tt = tt</code> and <code>#reduce one</code> gives <code>tt = ff</code>.</p>
<p>I am not yet clear if this is what I should expect. And why is the version returning a Prop better than to bool version?</p>

<a name="165329267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165329267" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165329267">Kevin Buzzard (May 10 2019 at 11:46)</a>:</h4>
<p>I guess the author of the blog article was quite incompetent at that time.</p>

<a name="165329338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165329338" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165329338">Kevin Buzzard (May 10 2019 at 11:47)</a>:</h4>
<p>To a mathematician, <code>Prop</code> and <code>bool</code> are difficult to tell apart. In Lean the key difference between them is that they sit in different places in the hierarchy. <code>bool</code> is a type, and <code>Prop</code> is a universe.</p>

<a name="165329350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165329350" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165329350">Kevin Buzzard (May 10 2019 at 11:47)</a>:</h4>
<p>So in type theory, <code>Prop</code> is somehow a lot bigger than <code>bool</code>.</p>

<a name="165329423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165329423" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165329423">Kevin Buzzard (May 10 2019 at 11:48)</a>:</h4>
<p>In type theory, there are universes, and then types in those universe, and then terms in those types. I say "in" because that's how I think of it, I guess type theorist would say "t has type T and T has type u" or something</p>

<a name="165329442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165329442" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165329442">Kevin Buzzard (May 10 2019 at 11:48)</a>:</h4>
<p>Because they're quite different in the type theory world, they behave quite differently.</p>

<a name="165329463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165329463" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165329463">Kevin Buzzard (May 10 2019 at 11:49)</a>:</h4>
<p>Both both definitions "work" and "give the right answer". I guess the big question is what you want to do with the definitions.</p>

<a name="165329485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165329485" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165329485">Kevin Buzzard (May 10 2019 at 11:49)</a>:</h4>
<p>Let's stick with the <code>Prop</code> version for now, if the prestigious blog writer thinks that this is a good idea.</p>

<a name="165329490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165329490" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165329490">Kevin Buzzard (May 10 2019 at 11:49)</a>:</h4>
<p>&lt;/sarcasm&gt;</p>

<a name="165329540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165329540" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165329540">Kevin Buzzard (May 10 2019 at 11:50)</a>:</h4>
<p>You can still try and prove that 2 is even</p>

<a name="165329553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165329553" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165329553">Kevin Buzzard (May 10 2019 at 11:50)</a>:</h4>
<p>You've got to prove <code>not not true</code></p>

<a name="165329556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165329556" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165329556">Kevin Buzzard (May 10 2019 at 11:50)</a>:</h4>
<p>and that should be OK, because P implies not not P</p>

<a name="165329582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165329582" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165329582">Kevin Buzzard (May 10 2019 at 11:51)</a>:</h4>
<p>and I can prove <code>true</code>, because that just means constructing a term of type <code>true</code> and I can look at the definition of <code>true</code> to find out what that term is called. Just write <code>#check true</code> and then right click on <code>true</code> and peek at the definition.</p>

<a name="165329597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165329597" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165329597">Kevin Buzzard (May 10 2019 at 11:51)</a>:</h4>
<p>eew that is a rubbish name</p>

<a name="165329602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165329602" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165329602">Kevin Buzzard (May 10 2019 at 11:51)</a>:</h4>
<p>that is a really confusing name</p>

<a name="165329666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165329666" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165329666">Kevin Buzzard (May 10 2019 at 11:52)</a>:</h4>
<p>I think there's a tactic which proves true, called <code>trivial</code> or something</p>

<a name="165413499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165413499" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165413499">Maxim Gerspach (May 11 2019 at 14:13)</a>:</h4>
<p>(deleted)</p>

<a name="165419614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165419614" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165419614">Kevin Buzzard (May 11 2019 at 16:53)</a>:</h4>
<p><span class="user-mention" data-user-id="207747">@Lukas</span> your interest made me go back to <a href="https://xenaproject.wordpress.com/2017/10/31/building-the-non-negative-integers-from-scratch/" target="_blank" title="https://xenaproject.wordpress.com/2017/10/31/building-the-non-negative-integers-from-scratch/">that blog post</a> and think about how I would have done it nowadays. I didn't think about even/odd but I did think about inequalities. Those 4 inequalities at the bottom were <em>terrifically</em> difficult. I didn't really know what I was doing at the time. I just tried various versions of le and lt, and I think that actually this is the best:</p>
<div class="codehilite"><pre><span></span>def le (a b : xnat) : Prop := ∃ c, a + c = b
</pre></div>


<p>Using this definition of <code>le</code>, it is not too hard to prove <code>le</code> versions of all the inequalities. And conversely, this one was by far the hardest to use:</p>
<div class="codehilite"><pre><span></span>inductive le : xnat → xnat → Prop
| refl (a : xnat) : le a a
| succ (a b : xnat) : le a b → le a (succ b)
</pre></div>


<p>Even proving a &lt;= b implies succ a &lt;= succ b was horrible with this; in the end I proved that this inductive le was the same as the easier-to-use le.</p>

<a name="165420360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165420360" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165420360">Kevin Buzzard (May 11 2019 at 17:13)</a>:</h4>
<p>Another thing I noticed was that manipulating xnat is far more tedious than manipulating nat, because you constantly want stuff which is true but which I didn't prove -- stuff like succ a = succ b -&gt; a = b, or a + b = a -&gt; b = 0; the proofs are all easy, but they are not there.</p>

<a name="165420416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165420416" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165420416">Kevin Buzzard (May 11 2019 at 17:14)</a>:</h4>
<p>I distinctly remember in 2017 firmly believing that every question about le on nat should almost by definition be completely trivial, because how can there even be any content?</p>

<a name="165430160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165430160" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165430160">Chris Hughes (May 11 2019 at 21:23)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>  maybe you weren't so stupid <a href="https://github.com/leanprover/lean4/blob/master/library/init/data/nat/basic.lean#L47" target="_blank" title="https://github.com/leanprover/lean4/blob/master/library/init/data/nat/basic.lean#L47">https://github.com/leanprover/lean4/blob/master/library/init/data/nat/basic.lean#L47</a></p>

<a name="165430209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165430209" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165430209">Patrick Massot (May 11 2019 at 21:24)</a>:</h4>
<p>I think this version is good for computation</p>

<a name="165430211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165430211" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165430211">Patrick Massot (May 11 2019 at 21:24)</a>:</h4>
<p>not for proofs</p>

<a name="165430216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165430216" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165430216">Kevin Buzzard (May 11 2019 at 21:24)</a>:</h4>
<p>One thing I learnt today was that my cool inductive predicate idea seems to be the worst of them all</p>

<a name="165431270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165431270" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165431270">Chris Hughes (May 11 2019 at 21:52)</a>:</h4>
<p>My attempt at the proof using the inductive definition. Pretty short, but it took me a while to work it out. I also used <code>pred</code></p>
<div class="codehilite"><pre><span></span><span class="kn">open</span> <span class="n">nat</span>
<span class="kn">namespace</span> <span class="n">xnat</span>
<span class="kn">inductive</span> <span class="n">le</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">refl</span> <span class="o">:</span> <span class="n">le</span> <span class="n">a</span>
<span class="bp">|</span> <span class="n">succ</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">b</span><span class="o">,</span> <span class="n">le</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">le</span> <span class="o">(</span><span class="n">succ</span> <span class="n">b</span><span class="o">)</span>

<span class="kn">infix</span> <span class="bp">`</span> <span class="bp">≤</span><span class="err">&#39;</span> <span class="bp">`</span><span class="o">:</span> <span class="mi">50</span> <span class="o">:=</span> <span class="n">le</span>

<span class="kn">lemma</span> <span class="n">le_succ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span><span class="err">&#39;</span> <span class="n">succ</span> <span class="n">a</span> <span class="o">:=</span>
<span class="n">le</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">_</span> <span class="o">(</span><span class="n">le</span><span class="bp">.</span><span class="n">refl</span> <span class="bp">_</span><span class="o">)</span>

<span class="kn">lemma</span> <span class="n">le_of_succ_le</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">succ</span> <span class="n">a</span> <span class="bp">≤</span><span class="err">&#39;</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span><span class="err">&#39;</span> <span class="n">b</span> <span class="o">:=</span>
<span class="n">le</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">ha</span> <span class="o">(</span><span class="n">le_succ</span> <span class="bp">_</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">le</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">_</span><span class="o">)</span>

<span class="kn">lemma</span> <span class="n">succ_le_succ</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">succ</span> <span class="n">a</span> <span class="bp">≤</span><span class="err">&#39;</span> <span class="n">succ</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span><span class="err">&#39;</span> <span class="n">b</span> <span class="o">:=</span>
<span class="k">show</span> <span class="n">pred</span> <span class="o">(</span><span class="n">succ</span> <span class="n">a</span><span class="o">)</span> <span class="bp">≤</span><span class="err">&#39;</span> <span class="n">pred</span> <span class="o">(</span><span class="n">succ</span> <span class="n">b</span><span class="o">),</span>
<span class="k">from</span> <span class="n">le</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">h</span> <span class="o">(</span><span class="n">le</span><span class="bp">.</span><span class="n">refl</span> <span class="bp">_</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span> <span class="n">h</span> <span class="bp">_</span><span class="o">,</span> <span class="n">le_of_succ_le</span> <span class="n">h</span><span class="o">)</span>

<span class="kn">lemma</span> <span class="n">le_trans</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">hab</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span><span class="err">&#39;</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">hbc</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≤</span><span class="err">&#39;</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span><span class="err">&#39;</span> <span class="n">c</span> <span class="o">:=</span>
<span class="n">le</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">hbc</span> <span class="n">hab</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">le</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">_</span><span class="o">)</span>
</pre></div>

<a name="165431371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165431371" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165431371">Kevin Buzzard (May 11 2019 at 21:54)</a>:</h4>
<p>Nice!</p>

<a name="165431391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165431391" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165431391">Chris Hughes (May 11 2019 at 21:55)</a>:</h4>
<p>This does illustrate a difficulty with inductive predicates. They're hard to use when not applied directly to local constants.</p>

<a name="165431459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165431459" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165431459">Chris Hughes (May 11 2019 at 21:57)</a>:</h4>
<p>When you induct you want the fact that <code>succ b</code> has something to do with <code>b</code>, but the computed motives rarely give you that.</p>

<a name="165431769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165431769" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165431769">Chris Hughes (May 11 2019 at 22:04)</a>:</h4>
<p>If I was recursing on equality, it would be completely obvious to do something like the method I chose. Interesting how my intuition for the equality recursor is so much better than other predicates, yet they're not that different.</p>

<a name="165431796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165431796" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165431796">Chris Hughes (May 11 2019 at 22:05)</a>:</h4>
<p>This has changed the way I think about induction.</p>

<a name="165431940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165431940" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165431940">Kevin Buzzard (May 11 2019 at 22:09)</a>:</h4>
<p>It was my job as your M1F teacher to teach you induction, I'm glad you now understand it better than me ;-)</p>

<a name="165431991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165431991" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165431991">Kevin Buzzard (May 11 2019 at 22:10)</a>:</h4>
<p>After my M1F induction lecture last year, someone came up to me at the end of the lecture and complained that they thought they understood induction when they came into the lecture but now they realised they were completely confused about it ;-)</p>

<a name="165432004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165432004" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165432004">Chris Hughes (May 11 2019 at 22:11)</a>:</h4>
<p>It's so obvious now I think about it. If i had <code>succ a = succ b</code>, it's obviously completely useless to try and recurse on that until I have a <code>succ b</code> in my goal. same applies here.</p>

<a name="165432008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165432008" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165432008">Kevin Buzzard (May 11 2019 at 22:11)</a>:</h4>
<p>What confused them was that I told them that proofs were finite in length by definition but if you think about the proof of P(100) which you get by induction, it looks like "P(0) is true, therefore P(1) is true, therefore P(2) is true...therefore P(100) is true", so maybe "forall n, P(n)" has infinite length and can't be a proof?</p>

<a name="165432076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165432076" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165432076">Chris Hughes (May 11 2019 at 22:13)</a>:</h4>
<p>I guess it does without the axiom of infinity.</p>

<a name="165432148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165432148" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165432148">Chris Hughes (May 11 2019 at 22:15)</a>:</h4>
<p>If you don't say induction is an axiom and instead give that as the explanation, then it is an infinite length proof.</p>

<a name="165432161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165432161" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165432161">Kevin Buzzard (May 11 2019 at 22:15)</a>:</h4>
<p>This was in my introduction to proof lectures -- I guess you can feel like induction is obvious, and then you start thinking about it that way and then you realise that actually there's more to it than meets the eye.</p>

<a name="165432230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165432230" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165432230">Chris Hughes (May 11 2019 at 22:17)</a>:</h4>
<p>There's a lot to it. Have you ever tried to prove <code>eq_of_heq</code> in term mode from axioms? It's really hard.</p>

<a name="165432275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165432275" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165432275">Kevin Buzzard (May 11 2019 at 22:18)</a>:</h4>
<p>I have never tried doing anything with <code>heq</code>, mostly because I remember you going through a period several months ago where you were continually moaning about it!</p>

<a name="165453314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165453314" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165453314">matt rice (May 12 2019 at 07:41)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> <br>
That definition you gave </p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">le</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">xnat</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="n">c</span><span class="o">,</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">b</span>
</pre></div>


<p>Is the exact one used in Logic and Proof, chapter 17/18 i believe</p>

<a name="165453895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/165453895" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#165453895">Kevin Buzzard (May 12 2019 at 08:00)</a>:</h4>
<p>I think that the inductive predicate is used in Lean 3 and the definition by cases is used in Lean 4</p>

<a name="166084131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/166084131" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#166084131">Neil Strickland (May 20 2019 at 13:21)</a>:</h4>
<p>So it seems that Lean 4 defines the order and decidable equality on <code>Nat</code> via maps to <code>Bool</code>, but reverts to using the same kind of framework as Lean 3 for <code>Int</code>, <code>list Nat</code> and so on.  Does anyone know why that is?</p>

<a name="166213197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tutorial%20Exercise/near/166213197" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/25037TutorialExercise.html#166213197">François G. Dorais (May 21 2019 at 21:10)</a>:</h4>
<p><span class="user-mention" data-user-id="130308">@Neil Strickland</span> My best guess is that derived Bool equality hasn't been built into inductive types yet. It's pretty ubiquitous, so I'm pretty sure it will be built in eventually.</p>


{% endraw %}
