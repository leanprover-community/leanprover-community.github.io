---
layout: archive
title: Lean Prover Zulip Chat Archive 
permalink: archive/113489newmembers/17787UnitingDefinitions.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html">Uniting Definitions</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="130457466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130457466" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130457466">Ali Sever (Jul 28 2018 at 08:53)</a>:</h4>
<p>Is there a way I can join perp, perp1 and perp2 into 1 definition? Same thing for perpx.  <code>l : point → point → set point</code></p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">perpx</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">point</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="n">A&#39;</span> <span class="o">:</span> <span class="n">set</span> <span class="n">point</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">line</span> <span class="n">A</span> <span class="bp">∧</span> <span class="n">line</span> <span class="n">A&#39;</span> <span class="bp">∧</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">A</span> <span class="bp">∧</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">A&#39;</span> <span class="bp">∧</span>
<span class="bp">∀</span> <span class="n">u</span> <span class="n">v</span><span class="o">,</span> <span class="n">u</span> <span class="err">∈</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">v</span> <span class="err">∈</span> <span class="n">A&#39;</span> <span class="bp">→</span> <span class="n">R</span> <span class="n">u</span> <span class="n">x</span> <span class="n">v</span>

<span class="n">def</span> <span class="n">perpx1</span> <span class="o">(</span><span class="n">x</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">point</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">point</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">b</span> <span class="bp">∧</span> <span class="n">perpx</span> <span class="n">x</span> <span class="n">A</span> <span class="o">(</span><span class="n">l</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span>

<span class="n">def</span> <span class="n">perpx2</span> <span class="o">(</span><span class="n">x</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">point</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">b</span> <span class="bp">∧</span> <span class="n">c</span> <span class="bp">≠</span> <span class="n">d</span> <span class="bp">∧</span> <span class="n">perpx</span> <span class="n">x</span> <span class="o">(</span><span class="n">l</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="n">c</span> <span class="n">d</span><span class="o">)</span>

<span class="n">def</span> <span class="n">perp</span> <span class="o">(</span><span class="n">A</span> <span class="n">A&#39;</span> <span class="o">:</span> <span class="n">set</span> <span class="n">point</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">perpx</span> <span class="n">x</span> <span class="n">A</span> <span class="n">A&#39;</span>

<span class="n">def</span> <span class="n">perp1</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">point</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">point</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">b</span> <span class="bp">∧</span> <span class="n">perp</span> <span class="n">A</span> <span class="o">(</span><span class="n">l</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span>

<span class="n">def</span> <span class="n">perp2</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">point</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">b</span> <span class="bp">∧</span> <span class="n">c</span> <span class="bp">≠</span> <span class="n">d</span> <span class="bp">∧</span> <span class="n">perp</span> <span class="o">(</span><span class="n">l</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="n">c</span> <span class="n">d</span><span class="o">)</span>

<span class="kn">notation</span> <span class="n">A</span> <span class="err">⊥</span> <span class="n">B</span>  <span class="o">:=</span> <span class="n">perp</span> <span class="n">A</span> <span class="n">B</span>

<span class="kn">notation</span> <span class="n">A</span> <span class="err">⊥</span> <span class="n">B</span> <span class="err">%</span> <span class="n">x</span>  <span class="o">:=</span> <span class="n">perpx</span> <span class="n">x</span> <span class="n">A</span> <span class="n">B</span>
</pre></div>

<a name="130457657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130457657" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130457657">Kevin Buzzard (Jul 28 2018 at 09:00)</a>:</h4>
<p>I don't understand the question. What are you unhappy about with what you have?</p>

<a name="130457768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130457768" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130457768">Ali Sever (Jul 28 2018 at 09:04)</a>:</h4>
<p>If I leave it like this, I'm going to have to prove everything three times.</p>

<a name="130458494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130458494" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130458494">Kevin Buzzard (Jul 28 2018 at 09:27)</a>:</h4>
<p>Are you likely to ever apply <code>perp</code> in a situation where <code>A</code> and <code>A'</code> are not lines?</p>

<a name="130458495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130458495" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130458495">Kevin Buzzard (Jul 28 2018 at 09:27)</a>:</h4>
<p>I mean, where you don't already know that they're lines?</p>

<a name="130458535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130458535" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130458535">Kevin Buzzard (Jul 28 2018 at 09:28)</a>:</h4>
<p>What I'm saying is that it sounds to me like the fact that <code>A</code> is a line should be a hypothesis rather than a conclusion of <code>perp</code></p>

<a name="130458612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130458612" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130458612">Kevin Buzzard (Jul 28 2018 at 09:31)</a>:</h4>
<p>Presumably<code> R</code> is "these three points make a right angle"? Don't you want something like<br>
<code>def perpx (x : point) {A A' : set point} (HLA : line A) (HLA' : line A') (HxA : x ∈ A) (HxA' : x ∈ A') :=
∀ u v, u ∈ A → v ∈ A' → R u x v</code>?</p>

<a name="130458720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130458720" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130458720">Kevin Buzzard (Jul 28 2018 at 09:35)</a>:</h4>
<p><code>def perp {A A' : set point} (HLA : line A) (HLA' : line A') : Prop := ∃ x, perpx x A A'</code></p>

<a name="130458723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130458723" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130458723">Kevin Buzzard (Jul 28 2018 at 09:35)</a>:</h4>
<p>I'm just guessing -- but it sounds like you want <code>perp</code> to be a predicate which applies only to lines, so you should demand only lines as input. Do you want to apply the idea in other situations?</p>

<a name="130459039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130459039" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130459039">Ali Sever (Jul 28 2018 at 09:46)</a>:</h4>
<p>What if I want to prove <code>perp A A' → something</code>? From the assumption I can obtain a proof of <code>line A</code> and <code>line A'</code>, but in your definition,  I have to add those to the hypotheses of every theorem.</p>

<a name="130459044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130459044" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130459044">Kevin Buzzard (Jul 28 2018 at 09:46)</a>:</h4>
<p>So you're telling me that you can envisage a situation where you have no idea that <code>A</code> and <code>A'</code> are lines, but you've managed to prove <code>perp A A'</code> anyway?</p>

<a name="130459059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130459059" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130459059">Johan Commelin (Jul 28 2018 at 09:47)</a>:</h4>
<p>Ali, that is where <code>variables</code> come in handy. Then you don't have to explicitly write them down in the statement of every theorem. You just write them once at the beginning of your section/file.</p>

<a name="130459100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130459100" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130459100">Johan Commelin (Jul 28 2018 at 09:48)</a>:</h4>
<p>Also, I can imagine that <code>line</code> can be a class, and then type class inference will (hopefully) keep track of which things are proven to be lines.</p>

<a name="130459109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130459109" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130459109">Kevin Buzzard (Jul 28 2018 at 09:49)</a>:</h4>
<p>I feel like you're saying the analogue of something like: "I want to define <code>a&lt;b</code> for <code>a</code> and <code>b</code> arbitrary things, and I want it to mean "<code>a</code> and <code>b</code> are numbers, and <code>a&lt;b</code>". And I'm saying "but we already have <code>a&lt;b</code> for numbers -- why would you want to talk about arbitrary things which you don't even know are numbers and then start talking about whether one is less than the other? In all cases where it even makes sense to talk about this, you know <code>a</code> and <code>b</code> are numbers, so that assumption should be an input not an output."</p>

<a name="130459201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130459201" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130459201">Ali Sever (Jul 28 2018 at 09:52)</a>:</h4>
<p>So if I change it, does that mean <code>perp A A'</code> also implies that they are lines?</p>

<a name="130459206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130459206" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130459206">Kevin Buzzard (Jul 28 2018 at 09:52)</a>:</h4>
<p>I'm suggesting that <code>perp A A'</code> <em>doesn't even make sense</em> unless <code>A</code> and <code>A'</code> are lines.</p>

<a name="130459209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130459209" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130459209">Kevin Buzzard (Jul 28 2018 at 09:52)</a>:</h4>
<p>And there are two ways to do this.</p>

<a name="130459223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130459223" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130459223">Kevin Buzzard (Jul 28 2018 at 09:53)</a>:</h4>
<p>One is to ask that <code>perp</code> takes as an input not the <em>sets</em> <code>A</code> and <code>A'</code> but <em>proofs</em> <code>HA : line A</code> and <code>HA' : line A</code></p>

<a name="130459263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130459263" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130459263">Kevin Buzzard (Jul 28 2018 at 09:54)</a>:</h4>
<p>(it would also need <code>A</code> and <code>A'</code> as inputs but they can be guessed from <code>HA</code> and <code>HA'</code>, so you can put them in squiggly brackets <code>{}</code> like I did above)</p>

<a name="130459266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130459266" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130459266">Kevin Buzzard (Jul 28 2018 at 09:54)</a>:</h4>
<p>and the other way is that you use type class inference.</p>

<a name="130459274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130459274" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130459274">Johan Commelin (Jul 28 2018 at 09:55)</a>:</h4>
<p>I would say that type class inference feels more natural, but sometimes comes with unexpected challenges of its own. (I'm sure Kevin can tell you more about that (-; ....)</p>

<a name="130459275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130459275" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130459275">Kevin Buzzard (Jul 28 2018 at 09:55)</a>:</h4>
<p>Then your function looks like <code>def perpx (x : point) (A A' : set point) [HLA : line A] [HLA' : line A'] (HxA : x ∈ A) (HxA' : x ∈ A') := ...</code> or even <code>def perpx (x : point) (A A' : set point) [line A] [line A'] (HxA : x ∈ A) (HxA' : x ∈ A') := ...</code>, and the proofs that <code>A</code> and <code>A'</code> are lines are supplied not by you but by the type class inference machine.</p>

<a name="130459333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130459333" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130459333">Johan Commelin (Jul 28 2018 at 09:57)</a>:</h4>
<p>And you would have to tell Lean that <code>l a b</code> is a line by adding an instance for it to the type class system.</p>

<a name="130459334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130459334" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130459334">Johan Commelin (Jul 28 2018 at 09:57)</a>:</h4>
<p>(If I inferred correctly that <code>l a b</code> is the line through points <code>a</code> and <code>b</code>.)</p>

<a name="130459335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130459335" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130459335">Kevin Buzzard (Jul 28 2018 at 09:57)</a>:</h4>
<p>Right: if you do it with type class inference then you change some of your <code>theorem</code>s and <code>definitions</code> to <code>instance</code>s, which adds them into the system.</p>

<a name="130459376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130459376" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130459376">Kevin Buzzard (Jul 28 2018 at 09:58)</a>:</h4>
<p>and you change your definition of <code>line</code> into a <code>class</code></p>

<a name="130459441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130459441" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130459441">Kevin Buzzard (Jul 28 2018 at 10:00)</a>:</h4>
<p>Then you just feed the sets into your function and Lean checks in every case that it can construct a proof behind the scene that they're lines, typically by looking at the definition of <code>A</code> and noticing that it was defined using a function which it knows produces things which it can prove are lines.</p>

<a name="130459453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130459453" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130459453">Ali Sever (Jul 28 2018 at 10:01)</a>:</h4>
<p>I think this means I have a lot of tidying to do, and even more reading before that.</p>

<a name="130459466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130459466" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130459466">Johan Commelin (Jul 28 2018 at 10:01)</a>:</h4>
<p>But otoh, this creates a bit of a snowball effect. Because now you also want <code>point</code>s to be a type class, so that Lean can figure out itself that the intersection of two lines is a point.... (if the lines are not parallel)</p>

<a name="130459504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130459504" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130459504">Kevin Buzzard (Jul 28 2018 at 10:02)</a>:</h4>
<p>If Lean can't find a proof, then it gives up with a "failed to synthesize type class instance" error:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">complex</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">example</span> <span class="o">:</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>


<p>-&gt;</p>
<div class="codehilite"><pre><span></span>failed to synthesize type class instance for
⊢ has_lt ℂ
</pre></div>

<a name="130459572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130459572" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130459572">Kevin Buzzard (Jul 28 2018 at 10:05)</a>:</h4>
<p>Of course <code>&lt;</code> is just notation. If you type <code>#print notation &lt;</code> you see it just means the function <code>has_lt.lt</code> and if you <code>#check @has_lt.lt</code> you find</p>
<div class="codehilite"><pre><span></span>has_lt.lt : Π {α : Type u_1} [c : has_lt α], α → α → Prop
</pre></div>


<p>which says "if the user asks me to make sense of <code>x&lt;y</code> with <code>x y: α</code> then I'm going to ask the type class inference system to check for me that it makes sense to talk about terms of type alpha being less than each other " -- that's what the square brackets means.</p>

<a name="130459676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130459676" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130459676">Kevin Buzzard (Jul 28 2018 at 10:08)</a>:</h4>
<p>And lo and behold, in <code>data/real/basic.lean</code> we have <code>instance : has_lt ℝ := (some definition)</code> which is where Lean is told not just the definition of what it means for a real to be less than another real, but that this should be an "instance", which means "a definition but one which the type class inference system knows about".</p>

<a name="130459694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130459694" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130459694">Kevin Buzzard (Jul 28 2018 at 10:09)</a>:</h4>
<p>So <code>#check (1 : ℝ) &lt; (2 : ℝ)</code> works fine, but <code>#check (1 : ℂ) &lt; (2 : ℂ)</code> doesn't -- you get the "failed to synthesize type class instance" error.</p>

<a name="130459738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130459738" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130459738">Kevin Buzzard (Jul 28 2018 at 10:10)</a>:</h4>
<p>I guess <code>line A</code> will be a <code>Prop</code> so it sounds like an ideal candidate for type class inference.</p>

<a name="130459748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130459748" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130459748">Ali Sever (Jul 28 2018 at 10:11)</a>:</h4>
<p>So I can get rid of the defintion <code>perp a b c d</code> and use <code>perp (l a b) (l c d)</code>, which automatically knows that  <code>a ≠ b ∧ line (l a b)</code>.</p>

<a name="130459889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130459889" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130459889">Kevin Buzzard (Jul 28 2018 at 10:16)</a>:</h4>
<p>If you define something like <code>instance line_through_two_points_is_a_line (a b : point) (Hne : a \ne b) : is_line (line_through_two_points a b) := (proof it's a line)</code> then...hmm...this somehow doesn't look too good, because how will Lean guess that a isn't equal to b?</p>

<a name="130459890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130459890" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130459890">Johan Commelin (Jul 28 2018 at 10:16)</a>:</h4>
<p>Hmm, the <code>a \ne b</code> bit seems non-trivial.</p>

<a name="130459892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130459892" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130459892">Johan Commelin (Jul 28 2018 at 10:16)</a>:</h4>
<p>That might have to be supplied...</p>

<a name="130459945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130459945" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130459945">Kevin Buzzard (Jul 28 2018 at 10:18)</a>:</h4>
<p>I guess you'll be carrying round a proof of that anyway. But feeding it into the system might be hard. Why don't you adopt the other approach for now? Then at least you'll get the logic straight. Just feed in the proofs that everything is a line. That's what I did with schemes. I couldn't figure out how type class inference worked so several of my functions were taking proofs as inputs.</p>

<a name="130459947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130459947" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130459947">Ali Sever (Jul 28 2018 at 10:18)</a>:</h4>
<p>I mean <code>l a b</code> is only defined for <code>a \ne b</code></p>

<a name="130460105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130460105" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130460105">Kevin Buzzard (Jul 28 2018 at 10:19)</a>:</h4>
<p>Lean doesn't like that kind of idea. You know <code>1/0=0</code> right?</p>

<a name="130460118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130460118" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130460118">Kevin Buzzard (Jul 28 2018 at 10:20)</a>:</h4>
<p>Only defining it for <code>a \ne b</code> is pretty much the same as carrying round a proof of this, in some sense.</p>

<a name="130460192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130460192" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130460192">Kevin Buzzard (Jul 28 2018 at 10:20)</a>:</h4>
<p>Why not go with <code>def perpx (x : point) {A A' : set point} (HLA : line A) (HLA' : line A') (HxA : x ∈ A) (HxA' : x ∈ A') :=
∀ u v, u ∈ A → v ∈ A' → R u x v</code>?</p>

<a name="130460193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130460193" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130460193">Kevin Buzzard (Jul 28 2018 at 10:20)</a>:</h4>
<p>We can worry about type class inference later.</p>

<a name="130460198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130460198" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130460198">Ali Sever (Jul 28 2018 at 10:21)</a>:</h4>
<p>If I adopt the other approach, won't it be harder in the future to switch to the more sophisticated method?</p>

<a name="130460199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130460199" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130460199">Kevin Buzzard (Jul 28 2018 at 10:21)</a>:</h4>
<p>I'm not sure that this is what an expert would do. But this is what I did for schemes, when I wasn't ready to launch into type class inference, and when I decided I wanted to change it was surprisingly easy.</p>

<a name="130460241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130460241" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130460241">Kevin Buzzard (Jul 28 2018 at 10:22)</a>:</h4>
<p>I just had to change a bunch of function inputs from <code>HU</code> to <code>U</code></p>

<a name="130465493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130465493" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130465493">Mario Carneiro (Jul 28 2018 at 12:28)</a>:</h4>
<blockquote>
<p>If you define something like instance line_through_two_points_is_a_line (a b : point) (Hne : a \ne b) : is_line (line_through_two_points a b) := (proof it's a line) then...hmm...this somehow doesn't look too good, because how will Lean guess that a isn't equal to b?</p>
</blockquote>
<p>I often use partial functions for this. My general recommendation against partial functions notwithstanding, when you have typeclasses that depend on it this is usually a good reason to push the assumption into the arguments somehow, either by having an additional proof argument or using a more structured argument space (i.e. a subtype or sigma)</p>

<a name="130465623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130465623" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130465623">Kevin Buzzard (Jul 28 2018 at 12:33)</a>:</h4>
<p><span class="user-mention" data-user-id="120256">@Ali Sever</span> so Mario is suggesting that you could use typeclasses. It might be easier to show you how to do all this on e.g. Monday if you're coming in, where I can explain face to face.</p>

<a name="130472981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130472981" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130472981">Ali Sever (Jul 28 2018 at 15:42)</a>:</h4>
<p>Now that I have VS Code back up, I'll use your suggestion until Monday, and then we can do some CS.</p>

<a name="130493666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Uniting%20Definitions/near/130493666" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17787UnitingDefinitions.html#130493666">Patrick Massot (Jul 28 2018 at 22:53)</a>:</h4>
<p>Seriously, as far as choosing how to represent things, you could really use fifteen years of work gathered at <a href="http://geocoq.github.io/GeoCoq/" target="_blank" title="http://geocoq.github.io/GeoCoq/">http://geocoq.github.io/GeoCoq/</a> Definitions in Coq should be easy to read if you have the maths translation explained in the paper, eg <a href="https://hal.inria.fr/hal-00727117/file/adg2012_braun_narboux_postproc.pdf" target="_blank" title="https://hal.inria.fr/hal-00727117/file/adg2012_braun_narboux_postproc.pdf">https://hal.inria.fr/hal-00727117/file/adg2012_braun_narboux_postproc.pdf</a> You would still have fun I think</p>


{% endraw %}
