---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/113489newmembers/68252Typecheckingahigherorderdefinition.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/68252Typecheckingahigherorderdefinition.html">Type checking a higher order definition</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="129508130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20checking%20a%20higher%20order%20definition/near/129508130" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/68252Typecheckingahigherorderdefinition.html#129508130">Ken Roe (Jul 12 2018 at 10:39)</a>:</h4>
<p>Can someone fix the following definition so that it can be type checked:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">absAll</span> <span class="o">{</span><span class="n">t</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">t</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:=</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">st</span> <span class="o">:</span> <span class="n">t</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">),</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">q</span><span class="o">:</span><span class="n">t</span><span class="o">),</span> <span class="o">(</span><span class="n">st</span> <span class="n">q</span><span class="o">)))</span><span class="bp">.</span>
</pre></div>

<a name="129508344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20checking%20a%20higher%20order%20definition/near/129508344" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/68252Typecheckingahigherorderdefinition.html#129508344">Simon Hudon (Jul 12 2018 at 10:45)</a>:</h4>
<p>What happens if you write this:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">absAll</span> <span class="o">{</span><span class="n">t</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">t</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:=</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">st</span> <span class="o">:</span> <span class="n">t</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">q</span><span class="o">:</span><span class="n">t</span><span class="o">),</span> <span class="o">(</span><span class="n">st</span> <span class="n">q</span> <span class="n">i</span><span class="o">)))</span><span class="bp">.</span>
</pre></div>

<a name="129509851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20checking%20a%20higher%20order%20definition/near/129509851" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/68252Typecheckingahigherorderdefinition.html#129509851">Ken Roe (Jul 12 2018 at 11:29)</a>:</h4>
<p>It works--maybe I should file a bug report.</p>

<a name="129509899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20checking%20a%20higher%20order%20definition/near/129509899" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/68252Typecheckingahigherorderdefinition.html#129509899">Simon Hudon (Jul 12 2018 at 11:30)</a>:</h4>
<p>That's not a bug, you made a mistake</p>

<a name="129509927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20checking%20a%20higher%20order%20definition/near/129509927" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/68252Typecheckingahigherorderdefinition.html#129509927">Simon Hudon (Jul 12 2018 at 11:31)</a>:</h4>
<p>The term of the definition has to be a function that takes two parameters (<code>st : t → ℕ → Prop</code> and <code>i : ℕ</code>) and returns a <code>Prop</code> (<code>∀ (q:t), (st q i)</code>)</p>

<a name="129509976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20checking%20a%20higher%20order%20definition/near/129509976" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/68252Typecheckingahigherorderdefinition.html#129509976">Simon Hudon (Jul 12 2018 at 11:32)</a>:</h4>
<p>You wrote <code>st q</code> which has type <code>ℕ -&gt; Prop</code>. But the body of a <code>∀</code> must be a <code>Prop</code></p>

<a name="129510098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20checking%20a%20higher%20order%20definition/near/129510098" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/68252Typecheckingahigherorderdefinition.html#129510098">Simon Hudon (Jul 12 2018 at 11:36)</a>:</h4>
<p>I encourage you to use typed holes (i.e. <code>_</code>) to explore what are the types expected from you. For instance, look at what Lean tells you when you write the following in your definition:</p>
<ul>
<li><code>(λ (st : t → ℕ → Prop), _)</code></li>
<li><code>(λ (st : t → ℕ → Prop) (i : ℕ), _)</code></li>
<li><code>(λ (st : t → ℕ → Prop) (i : ℕ), (∀ (q:t), _))</code></li>
</ul>

<a name="129510432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20checking%20a%20higher%20order%20definition/near/129510432" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/68252Typecheckingahigherorderdefinition.html#129510432">Simon Hudon (Jul 12 2018 at 11:47)</a>:</h4>
<p>I'm not sure what you're going for but you may prefer this definition:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">absAll</span> <span class="o">{</span><span class="n">t</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">st</span> <span class="o">:</span> <span class="n">t</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="o">(</span><span class="n">q</span><span class="o">:</span><span class="n">t</span><span class="o">),</span> <span class="o">(</span><span class="n">st</span> <span class="n">q</span> <span class="n">i</span><span class="o">)</span>
</pre></div>


<p>It is clearer and its equations are nicer too</p>

<a name="129521382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20checking%20a%20higher%20order%20definition/near/129521382" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/68252Typecheckingahigherorderdefinition.html#129521382">Kevin Buzzard (Jul 12 2018 at 17:21)</a>:</h4>
<p>What does "its equations are nicer" mean in this context?</p>
<p>Edit: I think I've answered my own question using <code>#print prefix absAll</code>. I am surprised! I knew that if you defined a fancy inductive type you got a bunch of generated equations, but I don't think I'd internalised that this was happening for just some random definition of a function.</p>
<p>Simon's version gives</p>
<div class="codehilite"><pre><span></span>absAll : Π {t : Type}, (t → ℕ → Prop) → ℕ → Prop
absAll.equations._eqn_1 : ∀ {t : Type} (st : t → ℕ → Prop) (i : ℕ), absAll st i = ∀ (q : t), st q i
</pre></div>


<p>I guess my revised question is why this equation is there at all! It just seems to be the definition of <code>absAll</code>.</p>

<a name="129521823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20checking%20a%20higher%20order%20definition/near/129521823" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/68252Typecheckingahigherorderdefinition.html#129521823">Sean Leather (Jul 12 2018 at 17:32)</a>:</h4>
<blockquote>
<p>I guess my revised question is why this equation is there at all! It just seems to be the definition of <code>absAll</code>.</p>
</blockquote>
<p>If you use <code>simp [absAll]</code>, I believe it uses that equation in the simplifier.</p>

<a name="129521916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20checking%20a%20higher%20order%20definition/near/129521916" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/68252Typecheckingahigherorderdefinition.html#129521916">Kevin Buzzard (Jul 12 2018 at 17:34)</a>:</h4>
<p>Aah that would make sense. I don't use <code>simp</code> like this usually -- I am only just beginning to get the hang of what <code>simp</code> does, and now I tend to only feed it equalities (I used to feed it arbitrary strings of symbols which I hoped made sense :-) )</p>


{% endraw %}
