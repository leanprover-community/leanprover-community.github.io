---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113489newmembers/49705Directedfilteredcategories.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/49705Directedfilteredcategories.html">Directed/filtered categories</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="168076636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Directed/filtered%20categories/near/168076636" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/49705Directedfilteredcategories.html#168076636">Calle Sönne (Jun 13 2019 at 19:17)</a>:</h4>
<p>Is directed/filtered categories in mathlib? Cant seem to find it in the category theory folder</p>

<a name="168076726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Directed/filtered%20categories/near/168076726" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/49705Directedfilteredcategories.html#168076726">Johan Commelin (Jun 13 2019 at 19:18)</a>:</h4>
<p>Nope, not yet. I think <span class="user-mention" data-user-id="110032">@Reid Barton</span> has some stuff in his homotopy theory repo</p>

<a name="168093006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Directed/filtered%20categories/near/168093006" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/49705Directedfilteredcategories.html#168093006">Scott Morrison (Jun 13 2019 at 23:12)</a>:</h4>
<p>I think this would be a great project!</p>

<a name="168230035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Directed/filtered%20categories/near/168230035" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/49705Directedfilteredcategories.html#168230035">Reid Barton (Jun 16 2019 at 01:12)</a>:</h4>
<p><span class="user-mention" data-user-id="132603">@Calle Sönne</span> what did you want to use them for?</p>

<a name="168411072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Directed/filtered%20categories/near/168411072" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/49705Directedfilteredcategories.html#168411072">Calle Sönne (Jun 18 2019 at 15:18)</a>:</h4>
<p>Nothing much really, I was just curious as to how/if they were defined in lean</p>

<a name="168412915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Directed/filtered%20categories/near/168412915" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/49705Directedfilteredcategories.html#168412915">Reid Barton (Jun 18 2019 at 15:36)</a>:</h4>
<p><span class="user-mention" data-user-id="132603">@Calle Sönne</span>  One definition is at <a href="https://github.com/leanprover-community/mathlib/blob/filtered-colimits-2/src/category_theory/filtered.lean" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/filtered-colimits-2/src/category_theory/filtered.lean">https://github.com/leanprover-community/mathlib/blob/filtered-colimits-2/src/category_theory/filtered.lean</a>. That branch also has some facts about filtered colimits of sets starting at <a href="https://github.com/leanprover-community/mathlib/blob/filtered-colimits-2/src/category_theory/limits/types.lean#L100" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/filtered-colimits-2/src/category_theory/limits/types.lean#L100">https://github.com/leanprover-community/mathlib/blob/filtered-colimits-2/src/category_theory/limits/types.lean#L100</a>.</p>

<a name="168413003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Directed/filtered%20categories/near/168413003" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/49705Directedfilteredcategories.html#168413003">Reid Barton (Jun 18 2019 at 15:37)</a>:</h4>
<p>The main question is whether the notion of being filtered should be a Prop (as I made it there), a subsingleton (to maintain constructivity, while still being faithful to the fact that being filtered is a property in math, not additional structure), or really encode a <em>choice</em> of cocones on each relevant thing, so that the same category could have multiple distinct <code>filtered</code> structures.</p>

<a name="168413024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Directed/filtered%20categories/near/168413024" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/49705Directedfilteredcategories.html#168413024">Reid Barton (Jun 18 2019 at 15:37)</a>:</h4>
<p>Or perhaps more than one of these turns out to be useful</p>

<a name="168417227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Directed/filtered%20categories/near/168417227" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/49705Directedfilteredcategories.html#168417227">Calle Sönne (Jun 18 2019 at 16:24)</a>:</h4>
<p>Thank you!</p>
<div class="codehilite"><pre><span></span><span class="o">(</span><span class="n">cocone_objs</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">),</span> <span class="bp">∃</span> <span class="n">Z</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="err">⟶</span> <span class="n">Z</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">Y</span> <span class="err">⟶</span> <span class="n">Z</span><span class="o">),</span> <span class="n">true</span><span class="o">)</span>
</pre></div>


<p><span class="user-mention" data-user-id="132893">@Ken Lee</span> this is a nice way to do the "filtered" criterion</p>

<a name="168417371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Directed/filtered%20categories/near/168417371" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/49705Directedfilteredcategories.html#168417371">Calle Sönne (Jun 18 2019 at 16:26)</a>:</h4>
<p>Me and <span class="user-mention" data-user-id="132893">@Ken Lee</span> tried to define it ourselves, and ended up defining it as a category with additional structure (not sure if that is what you mean by subsingleton), what would be the main difference between that and prop? To me as a math student they seem to be the "same".</p>

<a name="168417566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Directed/filtered%20categories/near/168417566" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/49705Directedfilteredcategories.html#168417566">Reid Barton (Jun 18 2019 at 16:28)</a>:</h4>
<p>To make it a subsingleton you would use <code>trunc</code> of a sigma type in place of an exists. Or make a structure which contains all the choices and take a <code>trunc</code> of the whole thing.</p>

<a name="168417780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Directed/filtered%20categories/near/168417780" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/49705Directedfilteredcategories.html#168417780">Chris Hughes (Jun 18 2019 at 16:31)</a>:</h4>
<p>A good example of a subsingleton that isn't a prop is <code>fintype</code></p>
<div class="codehilite"><pre><span></span><span class="n">class</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">elems</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">complete</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">elems</span><span class="o">)</span>
</pre></div>


<p>The difference is that with this definition I can compute using the <code>finset</code> in question. For example <code>#eval fintype.elems bool</code> returns <code>{ff, tt}</code>, which I couldn't do with a mere proof that such a <code>finset</code> existed.</p>

<a name="168418048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Directed/filtered%20categories/near/168418048" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/49705Directedfilteredcategories.html#168418048">Reid Barton (Jun 18 2019 at 16:34)</a>:</h4>
<p>Right, and the advantage of a Prop is that you never have to worry about having two different (as in non-definitionally equal) values of the Prop, or something else depending on the proof of that Prop.</p>

<a name="168418181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Directed/filtered%20categories/near/168418181" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/49705Directedfilteredcategories.html#168418181">Calle Sönne (Jun 18 2019 at 16:35)</a>:</h4>
<blockquote>
<p>To make it a subsingleton you would use <code>trunc</code> of a sigma type in place of an exists. Or make a structure which contains all the choices and take a <code>trunc</code> of the whole thing.</p>
</blockquote>
<p>What do you mean by trunc?</p>

<a name="168418353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Directed/filtered%20categories/near/168418353" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/49705Directedfilteredcategories.html#168418353">Chris Hughes (Jun 18 2019 at 16:37)</a>:</h4>
<p><code>trunc</code> is quotient by the always true relation. This is a computable version of <code>nonempty</code>. It maintains some computability since you can turn any constant computable function <code>X -&gt; Y</code> into a function <code>trunc X -&gt; Y</code> computably.</p>

<a name="168418640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Directed/filtered%20categories/near/168418640" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/49705Directedfilteredcategories.html#168418640">Kevin Buzzard (Jun 18 2019 at 16:40)</a>:</h4>
<p><span class="user-mention" data-user-id="132603">@Calle Sönne</span> as you may well know, in Lean all proofs of <code>P</code> are the same. So if <code>P : Prop</code> and then <code>h1 : P</code> and <code>h2 : P</code> then we will have <code>h1 = h2</code> (and the proof will be <code>rfl</code>). However there are other types which have exactly one term, and then it might be a theorem that two terms of that type are equal rather than being true by definition. And furthermore the terms might somehow store data, whereas a proof in Lean is checked by the kernel and then instantly forgotten about (Lean basically just puts a tick by the proposition to say "this has been proved"). A subsingleton is a type T for which you can prove that if <code>a : T</code> and <code>b : T</code> then <code>a = b</code>. Examples are propositions, but there are other examples too.</p>

<a name="168419221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Directed/filtered%20categories/near/168419221" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/49705Directedfilteredcategories.html#168419221">Calle Sönne (Jun 18 2019 at 16:47)</a>:</h4>
<p>So fintype, as <span class="user-mention" data-user-id="110044">@Chris Hughes</span> defined it, is a subsingleton since any two finite sets that contains exactly all terms of alpha are equal?</p>

<a name="168419611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Directed/filtered%20categories/near/168419611" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/49705Directedfilteredcategories.html#168419611">Chris Hughes (Jun 18 2019 at 16:51)</a>:</h4>
<p>Yes.</p>

<a name="168421296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Directed/filtered%20categories/near/168421296" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/49705Directedfilteredcategories.html#168421296">Ken Lee (Jun 18 2019 at 17:11)</a>:</h4>
<p>wow,  the type of cocone_objs... feels like cheating <span aria-label="joy" class="emoji emoji-1f602" role="img" title="joy">:joy:</span></p>

<a name="168423611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Directed/filtered%20categories/near/168423611" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/49705Directedfilteredcategories.html#168423611">Reid Barton (Jun 18 2019 at 17:16)</a>:</h4>
<p>This <code>exists ... ..., true</code> is a bit silly but I find it's often easier and clearer than alternatives</p>

<a name="168458923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Directed/filtered%20categories/near/168458923" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/49705Directedfilteredcategories.html#168458923">Scott Morrison (Jun 18 2019 at 21:55)</a>:</h4>
<p>my feeling is that it's best to have <code>filtered_structure</code>, which unashamedly contains the data of a cone for each pair, etc, and then have a <code>filtered</code> typeclass which is just <code>trunc filtered_structure</code>.</p>

<a name="168458954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Directed/filtered%20categories/near/168458954" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/49705Directedfilteredcategories.html#168458954">Scott Morrison (Jun 18 2019 at 21:55)</a>:</h4>
<p>I'm not so keen on the intermediate solution where each individual field of <code>filtered</code> is either an existential statement or <code>trunc</code>d data.</p>

<a name="168459024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Directed/filtered%20categories/near/168459024" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/49705Directedfilteredcategories.html#168459024">Scott Morrison (Jun 18 2019 at 21:56)</a>:</h4>
<p>It's really a question of where you want to put the proof obligations of showing your construction didn't depend on the filtered structure.</p>

<a name="168459065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Directed/filtered%20categories/near/168459065" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/49705Directedfilteredcategories.html#168459065">Scott Morrison (Jun 18 2019 at 21:56)</a>:</h4>
<p>You either have to do it every time you use a cone or equaliser, or once after a multi-step construction that uses several cones/equalisers.</p>

<a name="168459103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Directed/filtered%20categories/near/168459103" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/49705Directedfilteredcategories.html#168459103">Scott Morrison (Jun 18 2019 at 21:57)</a>:</h4>
<p>(The first alternative is what you get if each field of <code>filtereed</code> is an existential or <code>trunc</code>. The second alternative is what you get if you <code>trunc</code> the entire structure.)</p>

<a name="168459181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Directed/filtered%20categories/near/168459181" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/49705Directedfilteredcategories.html#168459181">Scott Morrison (Jun 18 2019 at 21:58)</a>:</h4>
<p>My limited experience using <code>filtered</code> was that the second alternative was more pleasant to use --- and it's the sort of argument that feels like you should be able to automate away, so it's nice if it's all quarantined in one place.</p>


{% endraw %}

{% include archive_update.html %}