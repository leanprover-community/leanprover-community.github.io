---
layout: archive
title: Lean Prover Zulip Chat Archive 
permalink: archive/113489newmembers/24293MathphysicsinLean.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html">Math physics in Lean</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="165915114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Math%20physics%20in%20Lean/near/165915114" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html#165915114">Kevin Sullivan (May 17 2019 at 16:35)</a>:</h4>
<p>One of the main use cases for abstract math is physics. Suppose I want to do physics formally using Lean. One of the mathematical structures I'd like to work with is that of the real Euclidean space. Can you help me understand how close or far we are from being able to represent real Euclidean spaces in Lean, including objects such as points and vectors, operations such as vector-vector and point-vector addition, and transformations such as rigid body motions and affine transformations more generally? (Beneath this question lies the fact that, for me at least, without many examples, it's hard to know what I can do with the bits and snippets I find out there, e.g., reals as Cauchy sequences, etc.)</p>

<a name="165915237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Math%20physics%20in%20Lean/near/165915237" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html#165915237">Mario Carneiro (May 17 2019 at 16:36)</a>:</h4>
<p>right now we are fairly close, but we are still working in some ridiculous generality</p>

<a name="165915280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Math%20physics%20in%20Lean/near/165915280" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html#165915280">Mario Carneiro (May 17 2019 at 16:37)</a>:</h4>
<p>we have normed vector spaces, but not much about finite dimensional vector spaces and even less about R^n specifically</p>

<a name="165920553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Math%20physics%20in%20Lean/near/165920553" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html#165920553">Kevin Sullivan (May 17 2019 at 17:41)</a>:</h4>
<blockquote>
<p>we have normed vector spaces, but not much about finite dimensional vector spaces and even less about R^n specifically</p>
</blockquote>
<p>Mario, Thanks. Do you have any guidance on how to gain an understanding of (1) what's already done---if only what files to look at, but better yet some applications that use them, or even better yet, papers about them, (2) what would need to be done to get to the point where we could model finite Euclidean spaces, particularly over the reals, even if only as a special case?</p>

<a name="165920647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Math%20physics%20in%20Lean/near/165920647" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html#165920647">Kevin Buzzard (May 17 2019 at 17:42)</a>:</h4>
<p>I would just fire up a new file and start writing. All the infrastructure you need should be there, as far as I know, it's just that nobody really did <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi mathvariant="double-struck">R</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\mathbb{R}^n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68889em;"></span><span class="strut bottom" style="height:0.68889em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">n</span></span></span></span></span></span></span></span></span></span></span> yet.</p>

<a name="165920667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Math%20physics%20in%20Lean/near/165920667" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html#165920667">Kevin Buzzard (May 17 2019 at 17:42)</a>:</h4>
<p>They're not keen on all these concrete examples ;-)</p>

<a name="165920714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Math%20physics%20in%20Lean/near/165920714" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html#165920714">Kevin Buzzard (May 17 2019 at 17:43)</a>:</h4>
<p>You might find that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi mathvariant="double-struck">R</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\mathbb{R}^n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68889em;"></span><span class="strut bottom" style="height:0.68889em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">n</span></span></span></span></span></span></span></span></span></span></span> automatically becomes a real vector space, so a bunch of what you're hoping to find might just magically appear.</p>

<a name="165922591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Math%20physics%20in%20Lean/near/165922591" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html#165922591">Kevin Buzzard (May 17 2019 at 18:05)</a>:</h4>
<p>Feel free to ask questions -- I think this is a very attainable goal.</p>

<a name="165923272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Math%20physics%20in%20Lean/near/165923272" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html#165923272">Kevin Buzzard (May 17 2019 at 18:13)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">pi_instances</span>

<span class="n">def</span> <span class="n">ℝspace</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℝ</span>

<span class="kn">instance</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">):</span> <span class="n">add_comm_group</span> <span class="o">(</span><span class="n">ℝspace</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">unfold</span> <span class="n">ℝspace</span><span class="bp">;</span> <span class="n">apply_instance</span>
<span class="n">noncomputable</span> <span class="kn">instance</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">):</span> <span class="n">vector_space</span> <span class="n">ℝ</span> <span class="o">(</span><span class="n">ℝspace</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">dunfold</span> <span class="n">ℝspace</span><span class="bp">;</span> <span class="n">apply_instance</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">ℝspace</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">v</span> <span class="bp">+</span> <span class="n">w</span> <span class="c1">-- adding vectors</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">r</span> <span class="err">•</span> <span class="n">v</span> <span class="c1">-- scalar times vector</span>
</pre></div>

<a name="165923426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Math%20physics%20in%20Lean/near/165923426" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html#165923426">Johan Commelin (May 17 2019 at 18:15)</a>:</h4>
<p><span class="user-mention" data-user-id="124175">@Kevin Sullivan</span> Further tips: the search function on Github and in VScode can be really useful. If those fail, just ask about a specific concept here, and we'll be able to tell you if it's in the library. You will hit things that are missing quite soon. But it is hard to tell what they are without starting out on a Lean file.</p>

<a name="165923546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Math%20physics%20in%20Lean/near/165923546" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html#165923546">Kevin Buzzard (May 17 2019 at 18:16)</a>:</h4>
<p>And feel free to change the name of Rspace! I just had to write something...</p>

<a name="166416631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Math%20physics%20in%20Lean/near/166416631" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html#166416631">Kevin Sullivan (May 24 2019 at 01:59)</a>:</h4>
<blockquote>
<p>And feel free to change the name of Rspace! I just had to write something...</p>
</blockquote>
<p>Thank you, Kevin, Johan, Mario. I'm working through your suggestions. A question comes up. What is the conceptual difference between field and discrete_field? The latter is a term I perhaps should but don't know from my limited studies of algebra.</p>

<a name="166416758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Math%20physics%20in%20Lean/near/166416758" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html#166416758">Keeley Hoek (May 24 2019 at 02:02)</a>:</h4>
<p>I think the rule is <code>discrete_field</code> is a maths field and we should all pretend <code>field</code> doesn't exist (and we'd change the name if it wasn't in core).</p>

<a name="166417475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Math%20physics%20in%20Lean/near/166417475" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html#166417475">Kevin Sullivan (May 24 2019 at 02:20)</a>:</h4>
<p>Ok, I see.</p>

<a name="166460252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Math%20physics%20in%20Lean/near/166460252" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html#166460252">Kevin Sullivan (May 24 2019 at 14:57)</a>:</h4>
<blockquote>
<p>And feel free to change the name of Rspace! I just had to write something...</p>
</blockquote>
<p>Ok, so I have started typing. The aim is to develop at least a formal sketch of a formalization of affine spaces. Here's how I started, and I immediately ran into a few questions, which I pose here.</p>
<p>You will recall that an affine space comprises a vector space V over a field K and a nonempty set, A, of points, with an addition operation, + : point -&gt; vector -&gt; point, satisfying a few axioms (e.g., \all p, p + 0 = p). My implementation strategy is to build on what's already in the libraries. So here's how I started.</p>
<div class="codehilite"><pre><span></span>class affine_space
    (P : Type)                                                  -- points
    (K: Type) [discrete_field K]               -- scalars
    (G : Type) [add_comm_group G]    -- vectors
    (V : vector_space K G) :=                     -- K vector space over G
(add : P → G → P)
</pre></div>


<p>I initially typed "add : P  → V → P", but of course V isn't s type. So, question <a href="https://github.com/leanprover-community/mathlib/issues/1" target="_blank" title="https://github.com/leanprover-community/mathlib/issues/1">#1</a>: does "add : P → G → P" look right? I'd like to be sure that I start with a sound typeclass specification before building all the rest of it.  Question <a href="https://github.com/leanprover-community/mathlib/issues/2" target="_blank" title="https://github.com/leanprover-community/mathlib/issues/2">#2</a>: I've chosen to use "has-a" relations rather than "is-a", using object-oriented lexicon, by which I mean that I incorporate P, K, G, and V as field values rather than using "extends" to "inherit" these structures. The rational is that an affine space "has a" vector space but not "is a" vector space. Does this look right to those of you who design these kinds of libraries?</p>
<p>Thank you!<br>
Kevin</p>

<a name="166461067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Math%20physics%20in%20Lean/near/166461067" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html#166461067">Mario Carneiro (May 24 2019 at 15:05)</a>:</h4>
<p>Q1: The convention would be to call <code>G</code> <code>V</code>, and call <code>V</code> nothing (put it in square brackets)</p>

<a name="166461270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Math%20physics%20in%20Lean/near/166461270" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html#166461270">Kevin Sullivan (May 24 2019 at 15:07)</a>:</h4>
<blockquote>
<p>Q1: The convention would be to call <code>G</code> <code>V</code>, and call <code>V</code> nothing (put it in square brackets)</p>
</blockquote>
<p>Perfect, thank you.</p>

<a name="166461500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Math%20physics%20in%20Lean/near/166461500" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html#166461500">Reid Barton (May 24 2019 at 15:10)</a>:</h4>
<p>And <code>P</code> would probably go last</p>

<a name="166461986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Math%20physics%20in%20Lean/near/166461986" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html#166461986">Johan Commelin (May 24 2019 at 15:15)</a>:</h4>
<p>Unfortunately we only have <code>mul_action</code>... so you can't use that class (in a clean way).</p>

<a name="166462262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Math%20physics%20in%20Lean/near/166462262" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html#166462262">Johan Commelin (May 24 2019 at 15:18)</a>:</h4>
<p>It would probably make sense to setup a general theory of torsors... and then define an affine space to be a torsor of a vector space.</p>

<a name="166462409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Math%20physics%20in%20Lean/near/166462409" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html#166462409">Johan Commelin (May 24 2019 at 15:20)</a>:</h4>
<p>You would be able to reuse the general setup for things like quantities (mass, length, &amp;c are torsors under <code>units real</code>). I'm far from being a (mathematical) physicist, so I have no idea if that would be useful.</p>

<a name="166462466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Math%20physics%20in%20Lean/near/166462466" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html#166462466">Neil Strickland (May 24 2019 at 15:21)</a>:</h4>
<p>Let's ignore for the moment the fact that you want to use additive notation.  Then the natural thing would be to start with the class <code>mul_action G X</code> from <code>src/group_theory/group_action.lean</code>, and extend it to give a class <code>principal_action</code> involving a "division" map <code>X  →  X →  G</code> such that <code>(y / x) • x = y</code>.  You might need some other axioms, or they might follow automatically, especially in the case where <code>G</code> is a group.  Then you could specialise to the case where <code>G</code> is the additive group of a vector space.</p>
<p>It's also possible to leave <code>G</code> out of the picture and axiomatize everything in terms of the subset of parallelograms in <code>X ^ 4</code>; then you recover <code>G</code> as a quotient of <code>X ^ 2</code>.  </p>
<p>Ideally we should have a class for additive actions that is magically connected to the class for multiplicative actions, so we don't have to prove essentially the same results twice.  We have similar things in some closely related contexts, but not this one.  But it would not be hard for you to define <code>add_action</code> by hand, just following the example of <code>mul_action</code>.</p>

<a name="166462559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Math%20physics%20in%20Lean/near/166462559" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html#166462559">Johan Commelin (May 24 2019 at 15:22)</a>:</h4>
<p>The reason I did not define <code>add_action</code> is notation...</p>

<a name="166462570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Math%20physics%20in%20Lean/near/166462570" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html#166462570">Johan Commelin (May 24 2019 at 15:22)</a>:</h4>
<p>We can't reuse <code>+</code> for these, even though that would be <em>very</em> natural.</p>

<a name="166463084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Math%20physics%20in%20Lean/near/166463084" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html#166463084">Kevin Sullivan (May 24 2019 at 15:29)</a>:</h4>
<p>I'm listening. I've incorporated comments down through Reid Barton's to arrive at the following. But I'm open to reworking it entirely in light of the subsequent comments. Feedback sought on both the current formulation, as well as on the subsequent comments. My overall aim is to develop a formalization in terms of which to express mathematical physics, starting with the classical (Newtonian) case.  </p>
<div class="codehilite"><pre><span></span>class affine_space
    (K: Type) [discrete_field K]
    (V : Type) [add_comm_group V] [vector_space K V] :=
    (P : Type)
(add : P → V → P)
(right_zero : ∀ (p : P), add p 0 = p)
(add_assoc : ∀ (p : P), ∀ (a b : V), add (add p a) b = add p (a + b))
(unique : ∀ (p q : P), ∃ (a : V),
            (q = add p a) ∧
            (∀ (a b : V), (q = add p a) → (q = add p b) → a = b))
</pre></div>

<a name="166463381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Math%20physics%20in%20Lean/near/166463381" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html#166463381">Mario Carneiro (May 24 2019 at 15:32)</a>:</h4>
<p><code>unique</code> has a name clash in the variables</p>

<a name="166463424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Math%20physics%20in%20Lean/near/166463424" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html#166463424">Mario Carneiro (May 24 2019 at 15:33)</a>:</h4>
<p>also don't use <code>/\</code> in an axiom if you can avoid it - use two axioms</p>

<a name="166463450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Math%20physics%20in%20Lean/near/166463450" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html#166463450">Reid Barton (May 24 2019 at 15:33)</a>:</h4>
<p>You probably want to replace <code>unique</code> anyways with a second operation <code>sub : P -&gt; P -&gt; V</code> and whatever axioms are necessary to characterize it uniquely</p>

<a name="166463460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Math%20physics%20in%20Lean/near/166463460" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html#166463460">Mario Carneiro (May 24 2019 at 15:33)</a>:</h4>
<p>^ that</p>

<a name="166463756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Math%20physics%20in%20Lean/near/166463756" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html#166463756">Reid Barton (May 24 2019 at 15:37)</a>:</h4>
<p><code>∀ (p : P), ∀ (a b : V),</code> can be simply <code>∀ (p : P) (a b : V),</code></p>

<a name="166463765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Math%20physics%20in%20Lean/near/166463765" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html#166463765">Reid Barton (May 24 2019 at 15:37)</a>:</h4>
<p>but now this is getting into just style things</p>

<a name="166464423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Math%20physics%20in%20Lean/near/166464423" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html#166464423">Kevin Sullivan (May 24 2019 at 15:45)</a>:</h4>
<blockquote>
<p>but now this is getting into just style things</p>
</blockquote>
<p>So here's where I've gotten to. </p>
<div class="codehilite"><pre><span></span>class affine_space
    (K: Type) [discrete_field K]
    (V : Type) [add_comm_group V] [vector_space K V] :=
    (P : Type)
(add : P → V → P)
(right_zero : ∀ (p : P), add p 0 = p)
(add_assoc : ∀ (p : P) (a b : V), add (add p a) b = add p (a + b))
(sub : P → P → V)
(sub_exists : ∀ (p q : P), ∃ (a : V),  a = sub q p)
(sub_unique : (∀ (p q : P) (a b : V), (q = add p a) → (q = add p b) → a = b))
</pre></div>


<p>I can work the details of the axioms from here. I guess the remaining pending question is whether this is a good start on an affine space library or whether to revert to a more general theory of torsors with the affine space case as a special case. Or to go with the suggestion by Neil Strickland. The torsor direction is intriguing as our aim is to formalize aspects of physics and metrology, and, indeed, things like time, location, and voltage are torsors. I don't have a strong intuition for how hard it'd be to go in this direction given what's already in the libraries, nor what tradeoffs would be involved in eventually using such a formalization as a target for a physical denotational semantics of programming code (which is where we're headed with this work). Comments/thoughts welcome.</p>

<a name="166472144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Math%20physics%20in%20Lean/near/166472144" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html#166472144">Kevin Sullivan (May 24 2019 at 17:21)</a>:</h4>
<blockquote>
<p>It would probably make sense to setup a general theory of torsors... and then define an affine space to be a torsor of a vector space.</p>
</blockquote>
<p>Is something like this what you had in mind?</p>
<div class="codehilite"><pre><span></span>class torsor
    (G : Type) [add_group G]
    (X : Type) [inhabited X] :=
(add : G → X → X)
(left_zero : ∀ (x : X), add 0 x = x)
(add_assoc : ∀ (g1 g2 : G) (x : X), add (g1 + g2) x = add g1 (add g2 x))
(sub : ∀ (x1 x2 : X), ∃ d, x2 = add d x1)
(sub_unique : ∀ (g1 g2 : G) (x1 x2 : X), x2 = add g1 x1 → x2 = add g2 x1 → g1 = g2)

class affine_space
        (K: Type)  [discrete_field K]
        (V : Type) [add_comm_group V] [vector_space K V]
        (P : Type) [inhabited P]
    extends torsor V P
</pre></div>

<a name="166472387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Math%20physics%20in%20Lean/near/166472387" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html#166472387">Mario Carneiro (May 24 2019 at 17:24)</a>:</h4>
<p>sub still isn't a function... are you expecting to be able to define the function after the fact?</p>

<a name="166472436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Math%20physics%20in%20Lean/near/166472436" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html#166472436">Mario Carneiro (May 24 2019 at 17:24)</a>:</h4>
<p>that's how it's done in maths but in lean it doesn't work as well</p>

<a name="166475255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Math%20physics%20in%20Lean/near/166475255" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html#166475255">Reid Barton (May 24 2019 at 17:56)</a>:</h4>
<p>From a math (or a <code>mathlib</code>) perspective it certainly makes sense to define torsors in general and then define affine spaces as torsors over a vector space. But if you're just prototyping for now then there's no need to try to do everything in maximal generality from the start.</p>

<a name="166475733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Math%20physics%20in%20Lean/near/166475733" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html#166475733">Reid Barton (May 24 2019 at 18:01)</a>:</h4>
<p>(Warning: mathematician, not a physicist)<br>
The way I eventually learned to think about units is as independent ways in which we believe physics is scale-invariant. For example in Newtonian physics I guess there are seven independent "dimensions" (not sure what the official term is), one per SI unit: time, length, mass, charge and so on. Each of these corresponds to a separate action of <code>units real</code> (or what a mathematician would call G_m) on physical quantities, so that all together we have actions of <code>units real x ... x units real</code>. For example a length is a vector in the vector space on which the copy of <code>units real</code> corresponding to length acts in the tautological way (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.61508em;"></span><span class="strut bottom" style="height:0.61508em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">t</span></span></span></span> acts by multiplication by <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.61508em;"></span><span class="strut bottom" style="height:0.61508em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">t</span></span></span></span>), and all the other copies act trivially.</p>

<a name="166475903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Math%20physics%20in%20Lean/near/166475903" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html#166475903">Reid Barton (May 24 2019 at 18:03)</a>:</h4>
<p>If we call this representation <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">L</span></span></span></span>, then a "length squared" is a vector in <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mo>⊗</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">L \otimes L</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="base"><span class="mord mathit">L</span><span class="mbin">⊗</span><span class="mord mathit">L</span></span></span></span>, which is again one-dimensional over the reals but has the action of length scaling where <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.61508em;"></span><span class="strut bottom" style="height:0.61508em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">t</span></span></span></span> acts as multiplication as <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>t</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">t^2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">2</span></span></span></span></span></span></span></span></span></span></span>.<br>
In this way time, length, etc. are quantities that belong to non-isomorphic representations of the big group <code>(units real)^7</code>, so there is no way that you can confuse them.</p>

<a name="166477340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Math%20physics%20in%20Lean/near/166477340" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html#166477340">Kevin Sullivan (May 24 2019 at 18:22)</a>:</h4>
<blockquote>
<p>sub still isn't a function... are you expecting to be able to define the function after the fact?</p>
</blockquote>
<p>Oops. How's this?</p>
<div class="codehilite"><pre><span></span>class torsor
    (G : Type) [add_group G]
    (X : Type) [inhabited X] :=
(add : G → X → X)
(left_zero : ∀ (x : X), add 0 x = x)
(add_assoc : ∀ (g1 g2 : G) (x : X), add (g1 + g2) x = add g1 (add g2 x))
(diff_exists : ∀ (x1 x2 : X), ∃ d, x2 = add d x1)
(diff_unique : ∀ (g1 g2 : G) (x1 x2 : X), x2 = add g1 x1 → x2 = add g2 x1 → g1 = g2)
(sub : X → X → G)
(sub_add : ∀ (x1 x2 : X), add (sub x2 x1) x1 = x2)
</pre></div>

<a name="166477453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Math%20physics%20in%20Lean/near/166477453" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html#166477453">Johan Commelin (May 24 2019 at 18:22)</a>:</h4>
<p><code>diff_exists</code> is now redundant. And you can rephrase <code>diff_unique</code> using <code>sub</code>, I guess.</p>

<a name="166477472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Math%20physics%20in%20Lean/near/166477472" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html#166477472">Neil Strickland (May 24 2019 at 18:23)</a>:</h4>
<p>Here's a similar but slightly different perspective.  The special relativity model says that spacetime is an affine space <code>V</code>.  This can be formulated in terms of parallelograms, which are quadruples of events that can be characterised by certain idealised physical properties.  The parallelogram structure gives an equivalence  relation on <code>V × V</code> with quotient <code>T</code> say, and gives a vector space structure on <code>T</code>.  Experimental properties characterise the light cone <code>C ⊂ T</code> and divide <code>T \ C</code> into subsets <code> T₊</code>,  <code>T₋</code> and <code>T₀</code> of future, past and spacelike vectors.  Let <code>L'</code> be the space of homogeneous quadratic functions on <code>T</code> that vanish on the light cone.  This is one-dimensional and has a canonical half-space of forms that are positive on timelike vectors.  This gives us a canonical oriented square root <code>L</code> with <code>L ⊗ L = L'</code>, and measurements of time and distance naturally take values in <code>L</code>.  (In this framework, times and distances are automatically identified via the speed of light.)</p>

<a name="166503400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Math%20physics%20in%20Lean/near/166503400" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html#166503400">Kevin Sullivan (May 25 2019 at 01:28)</a>:</h4>
<blockquote>
<p><code>diff_exists</code> is now redundant. And you can rephrase <code>diff_unique</code> using <code>sub</code>, I guess.</p>
</blockquote>
<p>Edited as follows:</p>
<div class="codehilite"><pre><span></span>class torsor
    (G : Type) [add_group G]
    (X : Type) [inhabited X] :=
(add : G → X → X)
(left_zero : ∀ (x : X), add 0 x = x)
(add_assoc : ∀ (g1 g2 : G) (x : X), add (g1 + g2) x = add g1 (add g2 x))
(sub : X → X → G)
(add_diff : ∀ (x1 x2 : X), add (sub x2 x1) x1 = x2)
(diff_unique : ∀ (g1 g2 : G) (x1 x2 : X), g1 = sub x2 x1 → g2 = sub x2 x1 → g1 = g2)
</pre></div>


<p>Any comments on field names vs prevailing conventions?</p>

<a name="166503610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Math%20physics%20in%20Lean/near/166503610" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html#166503610">Kevin Sullivan (May 25 2019 at 01:34)</a>:</h4>
<blockquote>
<p>Here's a similar but slightly different perspective.  The special relativity model says that spacetime is an affine space <code>V</code>.  This can be formulated in terms of parallelograms, which are quadruples of events that can be characterised by certain idealised physical properties.  The parallelogram structure gives an equivalence  relation on <code>V × V</code> with quotient <code>T</code> say, and gives a vector space structure on <code>T</code>.  Experimental properties characterise the light cone <code>C ⊂ T</code> and divide <code>T \ C</code> into subsets <code> T₊</code>,  <code>T₋</code> and <code>T₀</code> of future, past and spacelike vectors.  Let <code>L'</code> be the space of homogeneous quadratic functions on <code>T</code> that vanish on the light cone.  This is one-dimensional and has a canonical half-space of forms that are positive on timelike vectors.  This gives us a canonical oriented square root <code>L</code> with <code>L ⊗ L = L'</code>, and measurements of time and distance naturally take values in <code>L</code>.  (In this framework, times and distances are automatically identified via the speed of light.)</p>
</blockquote>
<p>Neil,</p>
<p>Thank you for your suggestion. For formalizing basic metrology (units of measure) and classical dynamics, my guess is that the formalization of the ordinary definition of torsors and affine spaces as torsors over vector spaces will suffice. However, we mean to develop a physical semantics of code for cyber-physical systems in general, eventually to include systems that are subject to relativistic effects (satellites, space missions, etc). We might well circle back around to the path you suggest. In the meantime I will try to acquaint myself with the material you highlight. Thank you.</p>

<a name="166503679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Math%20physics%20in%20Lean/near/166503679" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html#166503679">Mario Carneiro (May 25 2019 at 01:36)</a>:</h4>
<p><code>diff_unique</code> is now just transitivity</p>

<a name="166503702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Math%20physics%20in%20Lean/near/166503702" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html#166503702">Mario Carneiro (May 25 2019 at 01:37)</a>:</h4>
<p>I think what you could say is <code>add g x = y &lt;-&gt; sub x y = g</code></p>

<a name="166503749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Math%20physics%20in%20Lean/near/166503749" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24293MathphysicsinLean.html#166503749">Mario Carneiro (May 25 2019 at 01:38)</a>:</h4>
<p>or you could express it as the two cancellation laws <code>add (sub x y) y = x</code> and <code>sub (add g x) x = g</code></p>


{% endraw %}
