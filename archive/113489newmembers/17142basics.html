---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113489newmembers/17142basics.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html">basics</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="185060255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185060255" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185060255">Iocta (Jan 07 2020 at 22:09)</a>:</h4>
<p>Is there a built-in function <code>\lambda h, h</code>?</p>

<a name="185060400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185060400" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185060400">Aria Miuk (Jan 07 2020 at 22:10)</a>:</h4>
<p>That should be <code>id</code>.</p>

<a name="185060417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185060417" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185060417">Iocta (Jan 07 2020 at 22:11)</a>:</h4>
<p>Thanks</p>

<a name="185060600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185060600" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185060600">Iocta (Jan 07 2020 at 22:14)</a>:</h4>
<p>Is it possible to do this without <code>classical</code>? <code>example : ¬(p ↔ ¬p) := sorry</code></p>

<a name="185061003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185061003" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185061003">Simon Hudon (Jan 07 2020 at 22:19)</a>:</h4>
<p>Yes. Do you want to prove it yourself?</p>

<a name="185061088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185061088" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185061088">Aria Miuk (Jan 07 2020 at 22:20)</a>:</h4>
<p>Yes it is provable. Think about  how to get <code>p</code> into context and the definition of <code>not</code>.</p>

<a name="185062439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185062439" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185062439">Iocta (Jan 07 2020 at 22:36)</a>:</h4>
<p>No luck. How do I get <code>p</code> into context?</p>

<a name="185062517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185062517" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185062517">Bryan Gin-ge Chen (Jan 07 2020 at 22:37)</a>:</h4>
<p>Have you been able to get <code>¬p</code> into the goal? Remember that this is actually <code>p → false</code>.</p>

<a name="185063226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185063226" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185063226">Aria Miuk (Jan 07 2020 at 22:46)</a>:</h4>
<p>Strat with <code>intros contra</code> (or <code>\lambda contra, _</code>) and see how one magically conjures hypotheses :).</p>

<a name="185064582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185064582" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185064582">Iocta (Jan 07 2020 at 23:04)</a>:</h4>
<p>I'm missing something. I can't find anything shaped like <code>p</code> or <code>p \to false</code>.</p>

<a name="185064698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185064698" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185064698">Aria Miuk (Jan 07 2020 at 23:06)</a>:</h4>
<p>You're on the right path. You're looking for something <code>p \to false</code>. Can you prove it?</p>

<a name="185066693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185066693" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185066693">Iocta (Jan 07 2020 at 23:37)</a>:</h4>
<p>No I'm back where I started :-)</p>

<a name="185066764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185066764" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185066764">Aria Miuk (Jan 07 2020 at 23:38)</a>:</h4>
<p>Look at your contradictory hypothesis, <code>(p ↔ ¬p)</code>. You "win" once you either know <code>p</code>, or <code>not p</code>. Agreed? (As this then leads to contradiction.)</p>

<a name="185066856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185066856" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185066856">Aria Miuk (Jan 07 2020 at 23:40)</a>:</h4>
<p>So then surely the <em>only</em> way to prove this is to either know <code>p</code> or <code>not p</code>. There is bound to be no other way.</p>

<a name="185066896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185066896" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185066896">Aria Miuk (Jan 07 2020 at 23:41)</a>:</h4>
<p>So choose one, whichever you prefer. And formulate: <code>have h : p, { ... }</code>. (Or the other one.)</p>

<a name="185067013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185067013" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185067013">Aria Miuk (Jan 07 2020 at 23:42)</a>:</h4>
<p>Can you prove either of these? What happens if you attempt?</p>

<a name="185069953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185069953" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185069953">Iocta (Jan 08 2020 at 00:31)</a>:</h4>
<p>I want to do something like <code>or.elim hp</code>, but I can't figure out how to make <code>hp</code>. </p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">↔</span> <span class="bp">¬</span><span class="n">p</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">c</span><span class="o">,</span>
<span class="k">have</span> <span class="n">hp</span><span class="o">:</span> <span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="bp">_</span><span class="o">,</span>
<span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="bp">_</span>
</pre></div>

<a name="185070165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185070165" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185070165">Iocta (Jan 08 2020 at 00:35)</a>:</h4>
<p>If hp then hnp, and absurd hp hnp. And vice versa. But how do I state either of those hypotheses?</p>

<a name="185070268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185070268" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185070268">Aria Miuk (Jan 08 2020 at 00:37)</a>:</h4>
<p>So you need to prove <code>p</code>. Surely your only hypothesis is <code>c</code>. Let's use it. <code>c.2</code> gives us <code>not p -&gt; p</code>, we apply it to get the conclusion <code>not p</code>. So far so good?</p>

<a name="185070320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185070320" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185070320">Bryan Gin-ge Chen (Jan 08 2020 at 00:38)</a>:</h4>
<p>Here's another transcript of my thoughts as I work through the start of this one "automatically" (in the style of <a href="#narrow/stream/113489-new-members/topic/.60or.60.20implication/near/184439048" title="#narrow/stream/113489-new-members/topic/.60or.60.20implication/near/184439048">this previous post</a>). </p>
<p>We start out with a single underscore and let Lean tell us what's missing:</p>
<div class="codehilite"><pre><span></span><span class="c1">-- (1)</span>
<span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">↔</span> <span class="bp">¬</span><span class="n">p</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">_</span>
<span class="c">/-</span><span class="cm"> p : Prop</span>
<span class="cm">⊢ ¬(p ↔ ¬p) -/</span>
</pre></div>


<p>Here and below, I'll just quote the part of the error message(s) that shows the hypotheses in the context and the goal. Since <code>¬(p ↔ ¬p)</code> is the same as <code>(p ↔ ¬p) → false</code>, which is a function type, we should be able to make progress by introducing a lambda:</p>
<div class="codehilite"><pre><span></span><span class="c1">-- (2a)</span>
<span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">↔</span> <span class="bp">¬</span><span class="n">p</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="bp">_</span>
<span class="c">/-</span><span class="cm"> p : Prop,</span>
<span class="cm">h : p ↔ ¬p</span>
<span class="cm">⊢ false -/</span>
</pre></div>


<p>Note that <code>p ↔ ¬p</code> is the same as <code>(p → ¬p) ∧ (¬p → p)</code> so we could proceed by using <code>h.1</code> and <code>h.2</code>. However, I'll redo this step by making use of Lean's pattern-matching syntax to split <code>h</code> into two hypotheses:</p>
<div class="codehilite"><pre><span></span><span class="c1">-- (2b)</span>
<span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">↔</span> <span class="bp">¬</span><span class="n">p</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="bp">⟨</span><span class="n">h1</span><span class="o">,</span> <span class="n">h2</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">_</span>
<span class="c">/-</span><span class="cm"> p : Prop,</span>
<span class="cm">_x : p ↔ ¬p,</span>
<span class="cm">_fun_match : (p ↔ ¬p) → false,</span>
<span class="cm">h1 : p → ¬p,</span>
<span class="cm">h2 : ¬p → p</span>
<span class="cm">⊢ false -/</span>
</pre></div>


<p>Aside from <code>h1</code> and <code>h2</code> there's some other junk in the context related to the pattern-matching; I won't show it again below. Now, how do we make progress towards the goal of <code>false</code>? Now we realize that <code>h1 : p → ¬p</code> is short for <code>h1 : p → p → false</code>. Since passing two parameters to <code>h1</code> will yield <code>false</code>, we should try replacing the underscore with <code>h1 _ _</code>:</p>
<div class="codehilite"><pre><span></span><span class="c1">-- (3)</span>
<span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">↔</span> <span class="bp">¬</span><span class="n">p</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="bp">⟨</span><span class="n">h1</span><span class="o">,</span> <span class="n">h2</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">h1</span> <span class="bp">_</span> <span class="bp">_</span>
<span class="c">/-</span><span class="cm"> h1 : p → ¬p,</span>
<span class="cm">h2 : ¬p → p</span>
<span class="cm">⊢ p -/</span>
<span class="c">/-</span><span class="cm"> h1 : p → ¬p,</span>
<span class="cm">h2 : ¬p → p</span>
<span class="cm">⊢ p -/</span>
</pre></div>


<p>There are now two error messages because there are two underscores. Since I'm only intending to show a few more steps, from here on out I'm only going to show the error message corresponding to the first underscore. How do we make progress towards <code>p</code> there? Well, note that <code>h2 : ¬p → p</code> is a function which takes one parameter and returns <code>p</code>, so let's replace the underscore with <code>h2 _</code>:</p>
<div class="codehilite"><pre><span></span><span class="c1">-- (4)</span>
<span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">↔</span> <span class="bp">¬</span><span class="n">p</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="bp">⟨</span><span class="n">h1</span><span class="o">,</span> <span class="n">h2</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">h1</span> <span class="o">(</span><span class="n">h2</span> <span class="bp">_</span><span class="o">)</span> <span class="bp">_</span>
<span class="c">/-</span><span class="cm"> h1 : p → ¬p,</span>
<span class="cm">h2 : ¬p → p</span>
<span class="cm">⊢ ¬p -/</span>
</pre></div>


<p>Hey, here's the goal of <code>¬p</code> we hinted at! Now what? Well, naïvely, we might apply <code>h1</code> again, since it ends in <code>¬p</code>. However, if you try this, you'll see that continuing this way won't work (try it, what happens?). What should we do instead? Well, if we instead observe that <code>¬p</code> is the same as <code>p → false</code>, we can alternatively introduce another lambda here:</p>
<div class="codehilite"><pre><span></span><span class="c1">-- (5)</span>
<span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">↔</span> <span class="bp">¬</span><span class="n">p</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="bp">⟨</span><span class="n">h1</span><span class="o">,</span> <span class="n">h2</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">h1</span> <span class="o">(</span><span class="n">h2</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h3</span><span class="o">,</span> <span class="bp">_</span><span class="o">))</span> <span class="bp">_</span>
<span class="c">/-</span><span class="cm"> h1 : p → ¬p,</span>
<span class="cm">h2 : ¬p → p,</span>
<span class="cm">h3 : p</span>
<span class="cm">⊢ false -/</span>
</pre></div>


<p>Now we have <code>p</code> in the context, as desired! I'll leave the rest to you, but one final hint. Our goal is <code>false</code> again. Last time we saw this (step (3)), we replaced the underscore with <code>h1 _ _</code>. You should try doing this again. You'll end up in a state with 3 underscores / errors, but there's now something in the context which will let you close two of them right away...</p>
<p>You can fill in the last underscore very similarly.</p>
<p>When you get to the end, you'll notice that in blindly "chasing underscores" we end up with quite a bit of duplication. We could have avoided this by naming some terms with <code>have</code> statements, and it's worth refactoring the proof along those lines. Then you might start again from scratch and try to write a version of the proof with the <code>have</code> statements from the beginning.</p>

<a name="185071145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185071145" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185071145">Iocta (Jan 08 2020 at 00:52)</a>:</h4>
<p>I'll meditate on this. Thanks.</p>

<a name="185073964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185073964" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185073964">Iocta (Jan 08 2020 at 01:51)</a>:</h4>
<p>The basic version looks like </p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">↔</span> <span class="bp">¬</span><span class="n">p</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="o">(</span><span class="bp">|</span><span class="n">h1</span><span class="o">,</span> <span class="n">h2</span><span class="bp">|</span><span class="o">),</span>
<span class="o">(</span><span class="n">h1</span>
  <span class="o">(</span><span class="n">h2</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hp</span><span class="o">,</span> <span class="n">absurd</span> <span class="n">hp</span> <span class="o">(</span><span class="n">h1</span> <span class="n">hp</span><span class="o">)))</span>
  <span class="o">(</span><span class="n">h2</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hp</span><span class="o">,</span> <span class="n">absurd</span> <span class="n">hp</span> <span class="o">(</span><span class="n">h1</span> <span class="n">hp</span><span class="o">)))</span>
<span class="o">)</span>
</pre></div>


<p>Is this less redundant, or is it the same thing?</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">↔</span> <span class="bp">¬</span><span class="n">p</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="o">(</span><span class="bp">|</span><span class="n">h1</span><span class="o">,</span> <span class="n">h2</span><span class="bp">|</span><span class="o">),</span>
<span class="k">have</span> <span class="n">hnp</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hp&#39;</span><span class="o">,</span> <span class="n">absurd</span> <span class="n">hp&#39;</span> <span class="o">(</span><span class="n">h1</span> <span class="n">hp&#39;</span><span class="o">)),</span>
<span class="k">have</span> <span class="n">hp</span><span class="o">:</span> <span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="o">(</span><span class="n">h2</span> <span class="n">hnp</span><span class="o">),</span>
<span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="o">(</span><span class="n">absurd</span> <span class="n">hp</span> <span class="n">hnp</span><span class="o">)</span>
</pre></div>

<a name="185075337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185075337" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185075337">Bryan Gin-ge Chen (Jan 08 2020 at 02:27)</a>:</h4>
<p>Well, <code>absurd</code> itself is short for a certain proof term... do you know how <code>absurd</code> is proved?</p>

<a name="185075875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185075875" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185075875">Kenny Lau (Jan 08 2020 at 02:40)</a>:</h4>
<p><span class="user-mention" data-user-id="253355">@Iocta</span> maybe try this more general theorem:</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">Curry&#39;s_paradox</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">q</span><span class="o">))</span> <span class="bp">→</span> <span class="n">q</span> <span class="o">:=</span>
<span class="bp">_</span>
</pre></div>

<a name="185077413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185077413" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185077413">Iocta (Jan 08 2020 at 03:17)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">↔</span> <span class="bp">¬</span><span class="n">p</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="o">(</span><span class="bp">|</span><span class="n">h1</span><span class="o">,</span> <span class="n">h2</span><span class="bp">|</span><span class="o">),</span>
<span class="k">have</span> <span class="n">hnp</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hp&#39;</span><span class="o">,</span> <span class="o">(</span><span class="n">h1</span> <span class="n">hp&#39;</span><span class="o">)</span>  <span class="n">hp&#39;</span><span class="o">),</span>
<span class="k">have</span> <span class="n">hp</span><span class="o">:</span> <span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="o">(</span><span class="n">h2</span> <span class="n">hnp</span><span class="o">),</span>
<span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="n">hnp</span> <span class="n">hp</span>
</pre></div>

<a name="185077889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185077889" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185077889">Iocta (Jan 08 2020 at 03:27)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">Curry&#39;s_paradox</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">q</span><span class="o">))</span> <span class="bp">→</span> <span class="n">q</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="o">(</span><span class="bp">|</span><span class="n">h1</span><span class="o">,</span> <span class="n">h2</span><span class="bp">|</span><span class="o">),</span>
<span class="k">have</span> <span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="o">(</span><span class="n">h2</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hp&#39;</span><span class="o">,</span> <span class="n">h1</span> <span class="n">hp&#39;</span> <span class="n">hp&#39;</span><span class="o">)),</span>
<span class="k">show</span> <span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="o">(</span><span class="n">h1</span> <span class="n">hp</span> <span class="n">hp</span><span class="o">)</span>
</pre></div>

<a name="185079877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185079877" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185079877">Kevin Buzzard (Jan 08 2020 at 04:17)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">theorem</span> <span class="n">Curry&#39;s_paradox</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">q</span><span class="o">))</span> <span class="bp">→</span> <span class="n">q</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">tauto</span><span class="bp">!</span>
</pre></div>

<a name="185087888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185087888" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185087888">Iocta (Jan 08 2020 at 08:00)</a>:</h4>
<p>Why's this wrong? How to fix it?</p>
<div class="codehilite"><pre><span></span><span class="kn">open</span> <span class="n">classical</span>

<span class="kn">lemma</span> <span class="n">unnotnot</span> <span class="o">:</span> <span class="bp">¬¬</span><span class="n">p</span> <span class="bp">→</span> <span class="n">p</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">hnnp</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">elim</span> <span class="o">(</span><span class="n">em</span> <span class="n">p</span><span class="o">)</span> <span class="n">id</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hnp</span><span class="o">,</span> <span class="n">false</span><span class="bp">.</span><span class="n">elim</span> <span class="o">(</span><span class="n">absurd</span> <span class="n">hnp</span> <span class="n">hnnp</span><span class="o">))</span>


<span class="kn">example</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">¬</span><span class="n">p</span> <span class="bp">∨</span> <span class="bp">¬</span><span class="n">q</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">elim</span> <span class="o">(</span><span class="n">em</span> <span class="n">p</span><span class="o">)</span>
<span class="o">(</span><span class="bp">λ</span> <span class="n">hp</span><span class="o">,</span>
<span class="k">have</span> <span class="n">hnq</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="o">(</span><span class="n">by_contradiction</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hnnq</span><span class="o">,</span> <span class="n">h</span> <span class="o">(</span><span class="n">and</span><span class="bp">.</span><span class="n">intro</span> <span class="n">hp</span> <span class="o">(</span><span class="n">unnotnot</span> <span class="n">hnnq</span><span class="o">)))),</span>
  <span class="k">show</span> <span class="bp">_</span><span class="o">,</span> <span class="k">from</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span>
<span class="o">)</span>
<span class="n">or</span><span class="bp">.</span><span class="n">inl</span>
</pre></div>

<a name="185088007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185088007" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185088007">Kenny Lau (Jan 08 2020 at 08:02)</a>:</h4>
<p><code>or.inr</code> should be <code>or.inr hnq</code>:</p>
<div class="codehilite"><pre><span></span><span class="kn">open</span> <span class="n">classical</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span>

<span class="kn">lemma</span> <span class="n">unnotnot</span> <span class="o">:</span> <span class="bp">¬¬</span><span class="n">p</span> <span class="bp">→</span> <span class="n">p</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">hnnp</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">elim</span> <span class="o">(</span><span class="n">em</span> <span class="n">p</span><span class="o">)</span> <span class="n">id</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hnp</span><span class="o">,</span> <span class="n">false</span><span class="bp">.</span><span class="n">elim</span> <span class="o">(</span><span class="n">absurd</span> <span class="n">hnp</span> <span class="n">hnnp</span><span class="o">))</span>


<span class="kn">example</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">¬</span><span class="n">p</span> <span class="bp">∨</span> <span class="bp">¬</span><span class="n">q</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">elim</span> <span class="o">(</span><span class="n">em</span> <span class="n">p</span><span class="o">)</span>
<span class="o">(</span><span class="bp">λ</span> <span class="n">hp</span><span class="o">,</span>
<span class="k">have</span> <span class="n">hnq</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="o">(</span><span class="n">by_contradiction</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hnnq</span><span class="o">,</span> <span class="n">h</span> <span class="o">(</span><span class="n">and</span><span class="bp">.</span><span class="n">intro</span> <span class="n">hp</span> <span class="o">(</span><span class="n">unnotnot</span> <span class="n">hnnq</span><span class="o">)))),</span>
  <span class="k">show</span> <span class="bp">_</span><span class="o">,</span> <span class="k">from</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="n">hnq</span>
<span class="o">)</span>
<span class="n">or</span><span class="bp">.</span><span class="n">inl</span>
</pre></div>

<a name="185088037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185088037" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185088037">Kenny Lau (Jan 08 2020 at 08:03)</a>:</h4>
<p>the type of <code>or.inr</code> is unified with <code>¬q → ¬p ∨ ¬q</code></p>

<a name="185088366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185088366" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185088366">Iocta (Jan 08 2020 at 08:10)</a>:</h4>
<p>Thanks</p>

<a name="185088591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185088591" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185088591">Iocta (Jan 08 2020 at 08:15)</a>:</h4>
<p>Is it possible to prove <code>unnotnot</code> without <code>classical</code>?</p>

<a name="185088969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185088969" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185088969">Kenny Lau (Jan 08 2020 at 08:24)</a>:</h4>
<p>no</p>

<a name="185088972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185088972" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185088972">Kenny Lau (Jan 08 2020 at 08:24)</a>:</h4>
<p>it's equivalent to <code>em</code></p>

<a name="185194501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185194501" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185194501">Iocta (Jan 09 2020 at 09:07)</a>:</h4>
<p>When I have <code>\not p</code> in context and <code>p</code> in goal, is there something I should be saying to myself?</p>

<a name="185194680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185194680" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185194680">Kenny Lau (Jan 09 2020 at 09:10)</a>:</h4>
<p>if you can prove the goal, then you can prove <code>false</code>; so maybe aim to prove <code>false</code> instead</p>

<a name="185194700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185194700" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185194700">Iocta (Jan 09 2020 at 09:10)</a>:</h4>
<p>Alright</p>

<a name="185447701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185447701" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185447701">Iocta (Jan 12 2020 at 19:54)</a>:</h4>
<p>Can I fill this underscore, or am I down the wrong path? </p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">p</span> <span class="bp">∧</span> <span class="bp">¬</span><span class="n">q</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">h</span><span class="o">,</span>
<span class="k">have</span> <span class="n">notq</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hq&#39;</span><span class="o">,</span> <span class="o">(</span><span class="n">h</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hp</span><span class="o">,</span> <span class="n">hq&#39;</span><span class="o">))),</span>
<span class="n">and</span><span class="bp">.</span><span class="n">intro</span>
<span class="o">(</span><span class="n">or</span><span class="bp">.</span><span class="n">elim</span> <span class="o">(</span><span class="n">em</span> <span class="n">p</span><span class="o">)</span> <span class="n">id</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hnp</span><span class="o">,</span> <span class="bp">_</span><span class="o">))</span>
<span class="n">notq</span>
</pre></div>

<a name="185447788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185447788" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185447788">Chris Hughes (Jan 12 2020 at 19:56)</a>:</h4>
<p>You can fill in the underscore</p>

<a name="185447848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185447848" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185447848">Iocta (Jan 12 2020 at 19:58)</a>:</h4>
<p>ok</p>

<a name="185447863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185447863" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185447863">Iocta (Jan 12 2020 at 19:58)</a>:</h4>
<p>Is it possible to get into situations where I wouldn't be able to fill in the underscore, but where the overall claim is true?</p>

<a name="185447885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185447885" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185447885">Kenny Lau (Jan 12 2020 at 19:59)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span>
<span class="n">false</span><span class="bp">.</span><span class="n">elim</span> <span class="bp">_</span>
</pre></div>

<a name="185447966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185447966" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185447966">Bryan Gin-ge Chen (Jan 12 2020 at 20:00)</a>:</h4>
<p>There was another example at the very end of <a href="#narrow/stream/113489-new-members/topic/.60or.60.20implication/near/184439048" title="#narrow/stream/113489-new-members/topic/.60or.60.20implication/near/184439048">this reply</a> to one of your questions (step 2R).</p>

<a name="185448066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185448066" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185448066">Iocta (Jan 12 2020 at 20:03)</a>:</h4>
<p>how do I find conversations I've been involved in on zulip?</p>

<a name="185448137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185448137" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185448137">Kevin Buzzard (Jan 12 2020 at 20:05)</a>:</h4>
<p>search for yourself using the search bar at the top.</p>

<a name="185448185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185448185" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185448185">Iocta (Jan 12 2020 at 20:06)</a>:</h4>
<p>ah I see</p>

<a name="185458232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185458232" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185458232">Iocta (Jan 13 2020 at 01:06)</a>:</h4>
<p>This <code>example</code> works but it's quite long. Did I miss some opportunity to simplify?</p>
<div class="codehilite"><pre><span></span><span class="kn">variables</span> <span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span>

<span class="kn">theorem</span> <span class="n">contrap</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">¬</span><span class="n">q</span> <span class="bp">→</span> <span class="bp">¬</span><span class="n">p</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">h</span> <span class="n">hnq</span> <span class="n">hp</span><span class="o">,</span> <span class="n">hnq</span> <span class="o">(</span><span class="n">h</span> <span class="n">hp</span><span class="o">)</span>


<span class="kn">open</span> <span class="n">classical</span>

<span class="kn">lemma</span> <span class="n">unnotnot</span> <span class="o">:</span> <span class="bp">¬¬</span><span class="n">p</span> <span class="bp">→</span> <span class="n">p</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">hnnp</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">elim</span> <span class="o">(</span><span class="n">em</span> <span class="n">p</span><span class="o">)</span> <span class="n">id</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hnp</span><span class="o">,</span> <span class="n">false</span><span class="bp">.</span><span class="n">elim</span> <span class="o">(</span><span class="n">absurd</span> <span class="n">hnp</span> <span class="n">hnnp</span><span class="o">))</span>

<span class="kn">lemma</span> <span class="n">notnot</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="bp">¬¬</span><span class="n">p</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">hp</span> <span class="n">hnp</span><span class="o">,</span> <span class="n">hnp</span> <span class="n">hp</span>

<span class="kn">theorem</span> <span class="n">ncontrap</span> <span class="o">:</span> <span class="o">(</span> <span class="bp">¬</span><span class="n">p</span> <span class="bp">→</span> <span class="bp">¬</span><span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">q</span> <span class="bp">→</span> <span class="n">p</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">np2nq</span> <span class="n">hq</span><span class="o">,</span>
<span class="n">or</span><span class="bp">.</span><span class="n">elim</span> <span class="o">(</span><span class="n">em</span> <span class="n">p</span><span class="o">)</span>
<span class="n">id</span>
<span class="o">(</span><span class="bp">λ</span> <span class="n">hnp</span><span class="o">,</span>  <span class="o">(</span><span class="n">absurd</span> <span class="o">(</span><span class="n">np2nq</span> <span class="n">hnp</span><span class="o">)</span>   <span class="o">(</span><span class="n">notnot</span> <span class="bp">_</span> <span class="n">hq</span><span class="o">)))</span>


<span class="kn">lemma</span> <span class="n">contrapositive_not</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">¬</span><span class="o">(</span><span class="bp">¬</span><span class="n">q</span> <span class="bp">→</span> <span class="bp">¬</span><span class="n">p</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span><span class="n">h</span> <span class="n">h&#39;</span><span class="o">,</span>
<span class="n">or</span><span class="bp">.</span><span class="n">elim</span> <span class="o">(</span><span class="n">em</span> <span class="n">q</span><span class="o">)</span>
<span class="o">(</span><span class="bp">λ</span> <span class="n">hq</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">nnp2nnq</span> <span class="o">:</span> <span class="bp">_</span><span class="o">,</span> <span class="k">from</span> <span class="o">(</span><span class="n">contrap</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">h&#39;</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">p2q</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">q</span><span class="o">,</span> <span class="k">from</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">hp</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hq</span><span class="o">:</span> <span class="bp">_</span><span class="o">,</span>
    <span class="k">from</span> <span class="n">unnotnot</span> <span class="bp">_</span> <span class="o">(</span><span class="n">nnp2nnq</span> <span class="o">(</span><span class="n">notnot</span> <span class="bp">_</span> <span class="n">hp</span><span class="o">)),</span> <span class="n">hq</span><span class="o">),</span>
  <span class="n">absurd</span> <span class="n">p2q</span> <span class="n">h</span><span class="o">)</span>
<span class="o">(</span><span class="bp">λ</span> <span class="n">hnq</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hnp</span><span class="o">:</span> <span class="bp">¬</span><span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="n">h&#39;</span> <span class="n">hnq</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">p2q</span><span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="n">ncontrap</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">h&#39;</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">false&#39;</span> <span class="o">:</span> <span class="bp">_</span><span class="o">,</span> <span class="k">from</span> <span class="n">h</span> <span class="n">p2q</span><span class="o">,</span>
  <span class="n">false&#39;</span><span class="o">)</span>


<span class="kn">example</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">p</span> <span class="bp">∧</span> <span class="bp">¬</span><span class="n">q</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">h</span><span class="o">,</span>
<span class="k">have</span> <span class="n">hnq</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hq&#39;</span><span class="o">,</span> <span class="o">(</span><span class="n">h</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hp</span><span class="o">,</span> <span class="n">hq&#39;</span><span class="o">))),</span>
<span class="n">and</span><span class="bp">.</span><span class="n">intro</span>
<span class="o">(</span><span class="n">or</span><span class="bp">.</span><span class="n">elim</span> <span class="o">(</span><span class="n">em</span> <span class="n">p</span><span class="o">)</span> <span class="n">id</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hnp</span><span class="o">,</span>
<span class="k">have</span> <span class="n">h&#39;</span> <span class="o">:</span> <span class="bp">_</span><span class="o">,</span> <span class="k">from</span> <span class="n">contrapositive_not</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">h</span><span class="o">,</span>
<span class="o">(</span><span class="n">false</span><span class="bp">.</span><span class="n">elim</span> <span class="o">(</span><span class="n">h&#39;</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hnq&#39;</span><span class="o">,</span> <span class="n">hnp</span><span class="o">)))))</span>
<span class="n">hnq</span>
</pre></div>

<a name="185458907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185458907" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185458907">Reid Barton (Jan 13 2020 at 01:27)</a>:</h4>
<p>This looks a lot more complicated than necessary. In particular, you shouldn't need to use <code>em</code> again to fill in the underscore.<br>
In the context of the underscore, you know <code>not p</code> and also <code>not (p -&gt; q)</code>. But <code>not p</code> is <code>p -&gt; false</code>, and from <code>false</code> you can prove <code>q</code>, so you get <code>p -&gt; q</code>, which contradicts <code>not (p -&gt; q)</code>.</p>

<a name="185463876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185463876" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185463876">Iocta (Jan 13 2020 at 04:17)</a>:</h4>
<p>Thanks.</p>

<a name="185470188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185470188" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185470188">Kevin Buzzard (Jan 13 2020 at 07:23)</a>:</h4>
<p>Of course you can also prove all of these basic logic statements with one line using tactics, and most if not all of them will already be proved in lean or mathlib already. If you're interested in seeing very short proofs you can read the proofs in the library</p>

<a name="185568038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185568038" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185568038">Iocta (Jan 14 2020 at 06:11)</a>:</h4>
<p>I'm still working through the tutorial, haven't got to tactics yet.</p>

<a name="185981406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185981406" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185981406">Iocta (Jan 18 2020 at 05:48)</a>:</h4>
<p>I'm confused about the forall syntax. How do you fill this? <code>def prime (n : ℕ) : Prop := sorry</code></p>

<a name="185981696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185981696" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185981696">Iocta (Jan 18 2020 at 05:57)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">nondivisible</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
  <span class="k">forall</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="n">and</span><span class="bp">.</span><span class="n">intro</span> <span class="o">(</span><span class="n">m</span> <span class="bp">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">)</span> <span class="bp">→</span> <span class="n">not</span> <span class="o">(</span><span class="n">divides</span> <span class="n">m</span> <span class="n">n</span><span class="o">)</span>
</pre></div>


<p>nope</p>

<a name="185981949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185981949" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185981949">Kenny Lau (Jan 18 2020 at 06:05)</a>:</h4>
<p><code>and.intro (hp : p) (hq : q)</code> is a <strong>proof</strong> of <code>p and q</code></p>

<a name="185982076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185982076" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185982076">Iocta (Jan 18 2020 at 06:09)</a>:</h4>
<p>How do I take an <code>m : \N</code> such that <code>1 &lt; m &lt; n</code>as an argument?</p>

<a name="185982138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185982138" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185982138">Iocta (Jan 18 2020 at 06:11)</a>:</h4>
<p>I guess I could say <code>or.elim (em 1 &lt; m)</code> but that seems roundabout</p>

<a name="185982464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185982464" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185982464">Mario Carneiro (Jan 18 2020 at 06:22)</a>:</h4>
<p>You just write </p>
<div class="codehilite"><pre><span></span>  <span class="k">forall</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="mi">1</span> <span class="bp">&lt;</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">not</span> <span class="o">(</span><span class="n">divides</span> <span class="n">m</span> <span class="n">n</span><span class="o">)</span>
</pre></div>

<a name="185982470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185982470" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185982470">Mario Carneiro (Jan 18 2020 at 06:23)</a>:</h4>
<p>except that doesn't actually work, but this does:</p>
<div class="codehilite"><pre><span></span>  <span class="k">forall</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="n">and</span> <span class="o">(</span><span class="n">m</span> <span class="bp">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">)</span> <span class="bp">→</span> <span class="n">not</span> <span class="o">(</span><span class="n">divides</span> <span class="n">m</span> <span class="n">n</span><span class="o">)</span>
</pre></div>

<a name="185982473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185982473" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185982473">Mario Carneiro (Jan 18 2020 at 06:23)</a>:</h4>
<p>or</p>
<div class="codehilite"><pre><span></span>  <span class="k">forall</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">m</span> <span class="bp">&gt;</span> <span class="mi">1</span> <span class="bp">→</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">not</span> <span class="o">(</span><span class="n">divides</span> <span class="n">m</span> <span class="n">n</span><span class="o">)</span>
</pre></div>

<a name="185983144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185983144" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185983144">Iocta (Jan 18 2020 at 06:46)</a>:</h4>
<p>Oh, easy. Thanks.</p>

<a name="185984792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185984792" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185984792">Iocta (Jan 18 2020 at 07:44)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">prime</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="k">forall</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">and</span> <span class="o">(</span><span class="n">m</span> <span class="bp">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="bp">→</span> <span class="n">not</span> <span class="o">(</span><span class="n">divides</span> <span class="n">m</span> <span class="n">n</span><span class="o">)</span>

<span class="kn">variable</span> <span class="n">m</span><span class="o">:</span> <span class="bp">ℕ</span>

<span class="kn">example</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="k">forall</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="n">n</span> <span class="bp">&gt;</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">k</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span>  <span class="o">(</span><span class="n">and</span> <span class="o">(</span><span class="n">eq</span> <span class="o">(</span><span class="n">k</span> <span class="bp">+</span> <span class="n">m</span><span class="o">)</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">and</span> <span class="o">(</span><span class="n">prime</span> <span class="n">k</span><span class="o">)</span> <span class="o">(</span><span class="n">prime</span> <span class="n">m</span><span class="o">)))</span>
</pre></div>


<p>What's the quantifier on <code>m</code>?</p>

<a name="185984795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185984795" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185984795">Iocta (Jan 18 2020 at 07:44)</a>:</h4>
<p>compared to <code>forall n : ℕ, (n &gt; 2) → ∃ k : ℕ, ∃m : ℕ, (and (eq (k + m) n) (and (prime k) (prime m)))</code></p>

<a name="185984819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185984819" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185984819">Iocta (Jan 18 2020 at 07:45)</a>:</h4>
<p>(<code>m</code> in the <code>example</code>)</p>

<a name="185984923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185984923" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185984923">Iocta (Jan 18 2020 at 07:49)</a>:</h4>
<p>Oh I see, we're taking it as an argument.</p>

<a name="185984928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185984928" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185984928">Iocta (Jan 18 2020 at 07:49)</a>:</h4>
<p>Why doesn't it complain that it doesn't match <code>Prop</code> then?</p>

<a name="185985048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185985048" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185985048">Mario Carneiro (Jan 18 2020 at 07:53)</a>:</h4>
<p>When you refer to a <code>variable</code>, it automatically adds the variable binder to the definition, as if you had written</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="k">forall</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="n">n</span> <span class="bp">&gt;</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">k</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span>  <span class="o">(</span><span class="n">and</span> <span class="o">(</span><span class="n">eq</span> <span class="o">(</span><span class="n">k</span> <span class="bp">+</span> <span class="n">m</span><span class="o">)</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">and</span> <span class="o">(</span><span class="n">prime</span> <span class="n">k</span><span class="o">)</span> <span class="o">(</span><span class="n">prime</span> <span class="n">m</span><span class="o">)))</span>
</pre></div>

<a name="185985317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185985317" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185985317">Iocta (Jan 18 2020 at 08:01)</a>:</h4>
<p>Aha</p>

<a name="185985624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185985624" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185985624">Iocta (Jan 18 2020 at 08:11)</a>:</h4>
<p>Given </p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">divides</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="n">k</span><span class="o">,</span> <span class="n">m</span> <span class="bp">*</span> <span class="n">k</span> <span class="bp">=</span> <span class="n">n</span>
</pre></div>


<p>How do I check whether <code>divides 3 6</code>?</p>

<a name="185985666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185985666" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185985666">Iocta (Jan 18 2020 at 08:12)</a>:</h4>
<p>#check/#eval/#print don't seem to do it</p>

<a name="185985680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185985680" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185985680">Mario Carneiro (Jan 18 2020 at 08:14)</a>:</h4>
<p>You need to prove the predicate is decidable first, which amounts to giving a decision procedure. In most programming languages, for example, you decide <code>m | n</code> by testing if <code>m % n = 0</code></p>

<a name="185985722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185985722" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185985722">Mario Carneiro (Jan 18 2020 at 08:14)</a>:</h4>
<p>Luckily, we've already gone to the trouble to do this, but you have to use the built-in divides relation to get this</p>

<a name="185985781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185985781" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185985781">Alex J. Best (Jan 18 2020 at 08:16)</a>:</h4>
<p>Once you have a decidable proposition <code>#eval to_bool (divides 3 6)</code> will display either <code>tt</code> or <code>ff</code></p>

<a name="185985784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185985784" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185985784">Mario Carneiro (Jan 18 2020 at 08:16)</a>:</h4>
<p>Note that by the syntactic form of the expression (an exists over natural numbers of a basic proposition) it is not obviously decidable. For example Goldbach's conjecture can also be written in this form but it's an open question if this is a decidable proposition</p>

<a name="185989055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185989055" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185989055">Kevin Buzzard (Jan 18 2020 at 10:06)</a>:</h4>
<p>With inbuilt divides, it just works: <code>#eval to_bool (3 ∣ 6) -- tt</code>. Note that this is <code>\|</code> not <code>|</code>.</p>

<a name="185989116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185989116" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185989116">Kevin Buzzard (Jan 18 2020 at 10:08)</a>:</h4>
<p><code>example (a b : ℕ) : decidable (a ∣ b) := by apply_instance -- already inbuilt</code></p>

<a name="185989221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185989221" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185989221">Kevin Buzzard (Jan 18 2020 at 10:12)</a>:</h4>
<blockquote>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">prime</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="k">forall</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">and</span> <span class="o">(</span><span class="n">m</span> <span class="bp">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="bp">→</span> <span class="n">not</span> <span class="o">(</span><span class="n">divides</span> <span class="n">m</span> <span class="n">n</span><span class="o">)</span>
</pre></div>


</blockquote>
<p>There is notation which makes this more readable for mathematicians, right?</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">prime</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">m</span> <span class="bp">&gt;</span> <span class="mi">1</span> <span class="bp">∧</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">divides</span> <span class="n">m</span> <span class="n">n</span><span class="o">)</span>
</pre></div>


<p>But Mario's suggestion of currying it and writing <code>m &gt; 1 → m &lt; n → ¬ (divides m n)</code> is better for functional languages because it's easier to work with; typically m&gt;1 comes from one proof and m&lt;n comes from another, and if you curry it then you don't need to apply the <code>and.intro</code></p>

<a name="186018685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/186018685" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#186018685">Cerek Hillen (he) (W2'20) (Jan 19 2020 at 00:49)</a>:</h4>
<p>sorry if this is out of place (new to lean and to the community <span aria-label="happy" class="emoji emoji-1f600" role="img" title="happy">:happy:</span>) but i've been searching all over the docs and can't find an answer. i'm trying to rewrite with <code>rw mem_empty_eq</code>, and receiving the following error:</p>
<div class="codehilite"><pre><span></span>rewrite tactic failed, did not find instance of the pattern in the target expression
  ?m_2 ∈ ∅
state:
α : Type,
A : set α
⊢ {a : α | a ∈ A ∧ a ∈ ∅} = ∅
</pre></div>

<a name="186018730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/186018730" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#186018730">Kevin Buzzard (Jan 19 2020 at 00:50)</a>:</h4>
<p>ouch</p>

<a name="186018732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/186018732" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#186018732">Cerek Hillen (he) (W2'20) (Jan 19 2020 at 00:50)</a>:</h4>
<p>i would think that <code>a ∈ ∅</code> is sufficient  to rewrite?</p>

<a name="186018733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/186018733" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#186018733">Kevin Buzzard (Jan 19 2020 at 00:50)</a>:</h4>
<p>It's hidden too deep in the term.</p>

<a name="186018738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/186018738" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#186018738">Kevin Buzzard (Jan 19 2020 at 00:50)</a>:</h4>
<p>try <code>ext</code> first</p>

<a name="186018745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/186018745" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#186018745">Kevin Buzzard (Jan 19 2020 at 00:50)</a>:</h4>
<p>You can't rewrite under a lambda.</p>

<a name="186018752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/186018752" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#186018752">Cerek Hillen (he) (W2'20) (Jan 19 2020 at 00:51)</a>:</h4>
<p>ah! that makes sense. is that just to protect against accidentally rewriting already-bound terms?</p>

<a name="186018753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/186018753" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#186018753">Kevin Buzzard (Jan 19 2020 at 00:51)</a>:</h4>
<p>Alternatively you could try <code>simp only [mem_empty_eq]</code></p>

<a name="186018755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/186018755" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#186018755">Kevin Buzzard (Jan 19 2020 at 00:51)</a>:</h4>
<p>I have no idea why it makes sense, I am a mathematician. I just know the workarounds.</p>

<a name="186018797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/186018797" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#186018797">Cerek Hillen (he) (W2'20) (Jan 19 2020 at 00:52)</a>:</h4>
<blockquote>
<p>I am a mathematician</p>
</blockquote>
<p>Hahaha, well thank you all the same <span aria-label="happy" class="emoji emoji-1f600" role="img" title="happy">:happy:</span></p>

<a name="186018801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/186018801" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#186018801">Kevin Buzzard (Jan 19 2020 at 00:52)</a>:</h4>
<p><code>mem_empty_eq</code> is definitionally true, so you could just write <code>show  {a : α | a ∈ A ∧ false} = ∅</code></p>

<a name="186018854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/186018854" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#186018854">Kevin Buzzard (Jan 19 2020 at 00:54)</a>:</h4>
<p>but then you probably won't be able to rewrite <code>and_false</code> on the next line, you'll perhaps have to do <code>ext</code> in the end if you want to prove this by hand. Did you try <code>simp</code>?</p>

<a name="186018857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/186018857" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#186018857">Cerek Hillen (he) (W2'20) (Jan 19 2020 at 00:54)</a>:</h4>
<p>yeah, <code>simp</code> goes through the entire proof for me. i'm trying to get a better handle on lean by doing some introductory exercises on an undergrad abstract algebra textbook i found</p>

<a name="186018865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/186018865" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#186018865">Cerek Hillen (he) (W2'20) (Jan 19 2020 at 00:55)</a>:</h4>
<p>i got it to work with <code>simp only [...]</code> for both the <code>mem_empty_eq</code> and <code>and_false</code> steps. i'm going to try with <code>ext</code> to get more experience with that too</p>

<a name="186018915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/186018915" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#186018915">Kevin Buzzard (Jan 19 2020 at 00:56)</a>:</h4>
<p>After <code>ext</code> the rewrites do work.</p>

<a name="186018928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/186018928" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#186018928">Cerek Hillen (he) (W2'20) (Jan 19 2020 at 00:58)</a>:</h4>
<p>yep, although only on the rhs of the <code>iff</code>, i can show that <code>forall a. a \not \in ...</code> with a <code>iff_false</code>, and then i can map that to the set being <code>\emptyset</code> maybe?</p>

<a name="186018967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/186018967" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#186018967">Cerek Hillen (he) (W2'20) (Jan 19 2020 at 00:58)</a>:</h4>
<p>thank you for your help :)</p>

<a name="186019336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/186019336" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#186019336">Cerek Hillen (he) (W2'20) (Jan 19 2020 at 01:10)</a>:</h4>
<p>after many hours of syntax errors, i'm proud to say i've shown... A ∩ ∅ = ∅ <span aria-label="face palm" class="emoji emoji-1f926" role="img" title="face palm">:face_palm:</span> </p>
<div class="codehilite"><pre><span></span>lemma intersection_empty (α : Type) (A : set α) :
        A ∩ ∅ = ∅ :=
        begin
            rw inter_def,
            ext a,
            rw mem_set_of_eq,
            repeat {rw mem_empty_eq},
            rw and_false,
        end
</pre></div>

<a name="186019342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/186019342" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#186019342">Cerek Hillen (he) (W2'20) (Jan 19 2020 at 01:10)</a>:</h4>
<p>thanks again Kevin!</p>

<a name="186019927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/186019927" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#186019927">Daniel Keys (Jan 19 2020 at 01:30)</a>:</h4>
<p><span class="user-mention" data-user-id="259240">@Cerek Hillen (he) (W2'20)</span>  Hey Cerek, that doesn't work for me, do you need to include or open some stuff?</p>

<a name="186019937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/186019937" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#186019937">Cerek Hillen (he) (W2'20) (Jan 19 2020 at 01:31)</a>:</h4>
<p>yeah! i have the following at the top of my <code>.lean</code> file:</p>
<div class="codehilite"><pre><span></span>import data.set.basic
import data.nat.basic
import logic.basic

open set
open nat
</pre></div>

<a name="186020308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/186020308" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#186020308">Iocta (Jan 19 2020 at 01:44)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span><span class="n">x</span> <span class="o">:</span><span class="n">α</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">exists</span><span class="bp">.</span><span class="n">elim</span> <span class="n">h</span><span class="o">,</span> <span class="bp">_</span>
</pre></div>


<p>How to write this?</p>


{% endraw %}

{% include archive_update.html %}