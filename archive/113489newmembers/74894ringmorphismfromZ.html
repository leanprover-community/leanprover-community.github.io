---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113489newmembers/74894ringmorphismfromZ.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/74894ringmorphismfromZ.html">ring morphism from Z</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="191415188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20morphism%20from%20Z/near/191415188" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74894ringmorphismfromZ.html#191415188">orlando (Mar 22 2020 at 20:44)</a>:</h4>
<p>Hello, </p>
<p>If <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span> is a commutatif ring, there exists an unique morphisme <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi mathvariant="double-struck">Z</mi><mo>→</mo><mi>R</mi></mrow><annotation encoding="application/x-tex"> f : \mathbb{Z} \to R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Z</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>, how   show this fact in lean ?</p>

<a name="191415194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20morphism%20from%20Z/near/191415194" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74894ringmorphismfromZ.html#191415194">orlando (Mar 22 2020 at 20:44)</a>:</h4>
<p>perhaps this is already done !</p>

<a name="191415694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20morphism%20from%20Z/near/191415694" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74894ringmorphismfromZ.html#191415694">Patrick Massot (Mar 22 2020 at 20:57)</a>:</h4>
<p>It's called <code>int.cast</code>.</p>

<a name="191415868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20morphism%20from%20Z/near/191415868" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74894ringmorphismfromZ.html#191415868">orlando (Mar 22 2020 at 21:00)</a>:</h4>
<p>oh nice, there is a theorem  " eq_cast " i thinck it's ok ! Thx !</p>

<a name="191419171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20morphism%20from%20Z/near/191419171" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74894ringmorphismfromZ.html#191419171">orlando (Mar 22 2020 at 22:17)</a>:</h4>
<p>Yeaaaaaaaaaaaah !!!    <span aria-label="grinning face with smiling eyes" class="emoji emoji-1f601" role="img" title="grinning face with smiling eyes">:grinning_face_with_smiling_eyes:</span></p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">category</span><span class="bp">.</span><span class="n">CommRing</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">ring</span>
<span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">polynomial</span>
<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">ring</span>
<span class="kn">import</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">types</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">int</span><span class="bp">.</span><span class="n">basic</span>
<span class="n">universes</span> <span class="n">v</span> <span class="n">u</span>
<span class="kn">open</span> <span class="n">CommRing</span>
<span class="kn">open</span> <span class="n">is_ring_hom</span>
<span class="kn">open</span> <span class="n">polynomial</span>
<span class="kn">open</span> <span class="n">int</span>
<span class="kn">variables</span><span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">](</span><span class="n">P</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="bp">ℤ</span><span class="o">)</span>
<span class="kn">structure</span> <span class="n">V</span>  <span class="o">(</span><span class="n">R</span><span class="o">:</span> <span class="kt">Type</span><span class="o">)[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">:=</span>      <span class="c1">-- set of solution of P(x) = 0  with x in R</span>
<span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span>                                     <span class="c1">-- if φ : R → R&#39; is a ring morphism then we have application</span>
<span class="o">(</span><span class="n">certif</span> <span class="o">:</span> <span class="n">eval₂</span><span class="o">(</span><span class="n">int</span><span class="bp">.</span><span class="n">cast</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">)</span>     <span class="c1">--  φ : V(P)(R) → V(P(R&#39;)</span>
<span class="kn">lemma</span> <span class="n">ext</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">ζ1</span> <span class="n">ζ2</span> <span class="o">:</span> <span class="n">V</span> <span class="n">P</span> <span class="n">R</span><span class="o">},</span> <span class="n">ζ1</span><span class="bp">.</span><span class="n">x</span> <span class="bp">=</span> <span class="n">ζ2</span><span class="bp">.</span><span class="n">x</span> <span class="bp">→</span>  <span class="n">ζ1</span> <span class="bp">=</span> <span class="n">ζ2</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">ζ1</span> <span class="n">ζ2</span><span class="o">,</span>
<span class="k">begin</span>
  <span class="n">cases</span> <span class="n">ζ1</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">ζ2</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">congr</span> <span class="bp">;</span> <span class="n">try</span> <span class="o">{</span> <span class="n">assumption</span> <span class="o">},</span>
<span class="kn">end</span>
<span class="kn">definition</span> <span class="n">map_V</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">R&#39;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)[</span><span class="n">comm_ring</span> <span class="n">R&#39;</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→</span> <span class="n">R&#39;</span><span class="o">)</span> <span class="o">[</span><span class="n">is_ring_hom</span> <span class="n">f</span><span class="o">]</span> <span class="o">:</span> <span class="o">(</span><span class="n">V</span> <span class="n">P</span> <span class="n">R</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">V</span> <span class="n">P</span> <span class="n">R&#39;</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">ζ</span><span class="o">,</span><span class="k">begin</span>
<span class="n">exact</span>  <span class="o">{</span><span class="n">x</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">ζ</span><span class="bp">.</span><span class="n">x</span><span class="o">,</span> <span class="n">certif</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="k">have</span> <span class="n">H</span> <span class="o">:</span> <span class="n">eval₂</span> <span class="o">(</span><span class="n">f</span> <span class="err">∘</span> <span class="n">int</span><span class="bp">.</span><span class="n">cast</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">ζ</span><span class="bp">.</span><span class="n">x</span><span class="o">)</span> <span class="n">P</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">eval₂</span> <span class="n">int</span><span class="bp">.</span><span class="n">cast</span> <span class="o">(</span><span class="n">ζ</span><span class="bp">.</span><span class="n">x</span><span class="o">)</span> <span class="n">P</span><span class="o">),</span>
        <span class="n">rw</span> <span class="err">←</span>  <span class="n">hom_eval₂</span>  <span class="n">P</span>  <span class="n">int</span><span class="bp">.</span><span class="n">cast</span> <span class="n">f</span> <span class="n">ζ</span><span class="bp">.</span><span class="n">x</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">G</span> <span class="o">:</span> <span class="n">f</span> <span class="err">∘</span> <span class="n">int</span><span class="bp">.</span><span class="n">cast</span> <span class="bp">=</span> <span class="n">int</span><span class="bp">.</span><span class="n">cast</span><span class="o">,</span>
        <span class="n">exact</span> <span class="o">(</span><span class="n">int</span><span class="bp">.</span><span class="n">eq_cast&#39;</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="err">∘</span> <span class="n">int</span><span class="bp">.</span><span class="n">cast</span><span class="o">),</span>
    <span class="n">rw</span> <span class="n">G</span> <span class="n">at</span> <span class="n">H</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">H</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">cer</span> <span class="o">:</span> <span class="n">eval₂</span> <span class="n">int</span><span class="bp">.</span><span class="n">cast</span> <span class="n">ζ</span><span class="bp">.</span><span class="n">x</span> <span class="n">P</span> <span class="bp">=</span><span class="mi">0</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">ζ</span><span class="bp">.</span><span class="n">certif</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">cer</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">map_zero</span> <span class="n">f</span><span class="o">,</span>
    <span class="kn">end</span><span class="o">}</span>
<span class="kn">end</span>
</pre></div>

<a name="191419423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20morphism%20from%20Z/near/191419423" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74894ringmorphismfromZ.html#191419423">Kevin Buzzard (Mar 22 2020 at 22:23)</a>:</h4>
<p>When I had just started Lean, <code>polynomial</code> wasn't there! I had to get an undergraduate to make it ;-)</p>

<a name="191419649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20morphism%20from%20Z/near/191419649" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74894ringmorphismfromZ.html#191419649">orlando (Mar 22 2020 at 22:29)</a>:</h4>
<p>Kevin, it's very hard to use :  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>v</mi><mi>a</mi><msub><mi>l</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>i</mi><mi>n</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>c</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> eval_2 (int.cast) (x) (P) </annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord">.</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mclose">)</span></span></span></span> , for us it's just <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex"> P(x) = 0 </annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">x \in R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span> !!!</p>

<a name="191420109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20morphism%20from%20Z/near/191420109" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74894ringmorphismfromZ.html#191420109">Kevin Buzzard (Mar 22 2020 at 22:40)</a>:</h4>
<p>This is called "learning the interface". The most important thing to understand is: "if it is a standard fact, it will be there".</p>

<a name="191420185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20morphism%20from%20Z/near/191420185" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74894ringmorphismfromZ.html#191420185">Kevin Buzzard (Mar 22 2020 at 22:42)</a>:</h4>
<p>I wanted to learn the interface for polynomials in more than one variable recently, because I was formalising <a href="https://github.com/ImperialCollegeLondon/M4P33" target="_blank" title="https://github.com/ImperialCollegeLondon/M4P33">basic algebraic geometry</a> (I just finished teaching an undergraduate alg geom course at my university). So I read <a href="https://github.com/leanprover-community/mathlib/blob/master/src/data/mv_polynomial.lean" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/src/data/mv_polynomial.lean">data.mv_polynomial</a> and then I wrote the docstring which you can see in the first 90 lines. I didn't do that for <code>polynomial.lean</code> yet so it was probably harder work for you to find the theorems.</p>

<a name="191420352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20morphism%20from%20Z/near/191420352" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74894ringmorphismfromZ.html#191420352">Kevin Buzzard (Mar 22 2020 at 22:46)</a>:</h4>
<p>I agree that formalising is much harder work than mathematics on paper. The idea is that if we make a really good interface then it will not be so painful. I would imagine that there is already a coercion from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span> but I don't think that there is a rule that says that if there is a coercion from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> then there is also a coercion from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">A[X]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">]</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">B[X]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">]</span></span></span></span>. If this was added then it might make the code look nicer, but then a computer scientist might come along and say that this is a bad coercion because of some computer science reason involving type class search.</p>

<a name="191420391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20morphism%20from%20Z/near/191420391" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74894ringmorphismfromZ.html#191420391">Kevin Buzzard (Mar 22 2020 at 22:47)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">polynomial</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">R</span> <span class="o">:=</span> <span class="n">n</span>
</pre></div>


<p>This works, so integers can be regarded as elements of a commutative ring. If you look at what happened, it actually defined the term to be <code>↑n</code></p>

<a name="191420447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20morphism%20from%20Z/near/191420447" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74894ringmorphismfromZ.html#191420447">Kevin Buzzard (Mar 22 2020 at 22:48)</a>:</h4>
<p><code>example (R : Type*) [comm_ring R] (p : polynomial ℤ) : polynomial R := p</code> -- this fails, and so does <code>:= ↑p</code></p>

<a name="191420535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20morphism%20from%20Z/near/191420535" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74894ringmorphismfromZ.html#191420535">Kevin Buzzard (Mar 22 2020 at 22:51)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">noncomputable</span> <span class="kn">instance</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">polynomial</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">polynomial</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨</span><span class="n">polynomial</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="bp">ℤ</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span><span class="bp">⟩</span>
</pre></div>

<a name="191420702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20morphism%20from%20Z/near/191420702" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74894ringmorphismfromZ.html#191420702">Kevin Buzzard (Mar 22 2020 at 22:54)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">polynomial</span>

<span class="n">noncomputable</span> <span class="n">theory</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">R</span> <span class="o">:=</span> <span class="err">↑</span><span class="n">n</span>

<span class="kn">instance</span> <span class="n">foo</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_lift_t</span> <span class="bp">ℤ</span> <span class="n">R</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span>

<span class="kn">instance</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">polynomial</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">polynomial</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨</span><span class="n">polynomial</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="bp">ℤ</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span><span class="bp">⟩</span>

<span class="kn">open</span> <span class="n">polynomial</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">R</span> <span class="o">:=</span>
<span class="kn">eval</span> <span class="n">r</span> <span class="n">p</span>
</pre></div>


<p>There -- now it is just <code>eval</code> and you could set up notation for <code>eval</code> so that it becomes some kind of <code>p(r)</code>, although probably you would have to use some funky brackets</p>

<a name="191420705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20morphism%20from%20Z/near/191420705" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74894ringmorphismfromZ.html#191420705">orlando (Mar 22 2020 at 22:54)</a>:</h4>
<p>Yes i use 'map' </p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">R</span> <span class="o">:=</span> <span class="n">map</span> <span class="o">(</span><span class="n">int</span><span class="bp">.</span><span class="n">cast</span><span class="o">)</span> <span class="n">p</span>
</pre></div>


<p>But non computable (i don't know if it's a problem ?)</p>

<a name="191420709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20morphism%20from%20Z/near/191420709" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74894ringmorphismfromZ.html#191420709">Kevin Buzzard (Mar 22 2020 at 22:55)</a>:</h4>
<p>It's not a problem</p>

<a name="191420715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20morphism%20from%20Z/near/191420715" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74894ringmorphismfromZ.html#191420715">Kevin Buzzard (Mar 22 2020 at 22:55)</a>:</h4>
<p>It's a problem for some people, but not for mathematicians</p>

<a name="191420777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20morphism%20from%20Z/near/191420777" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74894ringmorphismfromZ.html#191420777">Kevin Buzzard (Mar 22 2020 at 22:56)</a>:</h4>
<p>It's probably something to do with the fact that you can't tell if a coefficient is zero or not if there is no algorithm for deciding equality between two elements of R or something.</p>

<a name="191420795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20morphism%20from%20Z/near/191420795" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74894ringmorphismfromZ.html#191420795">Kevin Buzzard (Mar 22 2020 at 22:57)</a>:</h4>
<p>For example there is no algorithm which tells you if two real numbers are equal: you cannot just tell a computer to prove <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∑</mo><mrow><mi>n</mi><mo>≥</mo><mn>1</mn></mrow></msub><mn>1</mn><mi mathvariant="normal">/</mi><msup><mi>n</mi><mn>2</mn></msup><mo>=</mo><msup><mi>π</mi><mn>2</mn></msup><mi mathvariant="normal">/</mi><mn>6</mn></mrow><annotation encoding="application/x-tex">\sum_{n\geq1}1/n^2=\pi^2/6</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.208997em;vertical-align:-0.39488900000000005em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139799999999992em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mrel mtight">≥</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.39488900000000005em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord">6</span></span></span></span>. All it can do is to check it to 10000 decimal places</p>

<a name="191420840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20morphism%20from%20Z/near/191420840" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74894ringmorphismfromZ.html#191420840">Kevin Buzzard (Mar 22 2020 at 22:58)</a>:</h4>
<p>And because you don't care about this, you don't care that your example is noncomputable</p>

<a name="191420843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20morphism%20from%20Z/near/191420843" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74894ringmorphismfromZ.html#191420843">orlando (Mar 22 2020 at 22:58)</a>:</h4>
<p>okay !</p>

<a name="191420854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20morphism%20from%20Z/near/191420854" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74894ringmorphismfromZ.html#191420854">Kevin Buzzard (Mar 22 2020 at 22:58)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">notation</span> <span class="n">p</span> <span class="bp">`</span><span class="o">(</span><span class="bp">`</span> <span class="n">r</span> <span class="bp">`</span><span class="o">)</span><span class="bp">`</span> <span class="o">:=</span> <span class="kn">eval</span> <span class="n">r</span> <span class="n">p</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">R</span> <span class="o">:=</span> <span class="n">p</span><span class="o">(</span><span class="n">r</span><span class="o">)</span>
</pre></div>

<a name="191420991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20morphism%20from%20Z/near/191420991" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74894ringmorphismfromZ.html#191420991">Kevin Buzzard (Mar 22 2020 at 23:00)</a>:</h4>
<p>I suspect that this is really bad notation for all sorts of reasons :-)</p>

<a name="191421024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20morphism%20from%20Z/near/191421024" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74894ringmorphismfromZ.html#191421024">Kevin Buzzard (Mar 22 2020 at 23:01)</a>:</h4>
<p>but what I am showing you is that if you don't like the interface then there are always possibilities to make it better, either by adding more theorems or adding more notation.</p>

<a name="191421102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20morphism%20from%20Z/near/191421102" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74894ringmorphismfromZ.html#191421102">Kevin Buzzard (Mar 22 2020 at 23:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="270476">orlando</span> <a href="#narrow/stream/113489-new-members/topic/ring.20morphism.20from.20Z/near/191420705" title="#narrow/stream/113489-new-members/topic/ring.20morphism.20from.20Z/near/191420705">said</a>:</p>
<blockquote>
<p>Yes i use 'map' </p>
</blockquote>
<p>I used <code>map</code> too, but I buried it in <code>instance (R : Type*) [comm_ring R] : has_coe (polynomial ℤ) (polynomial R) :=
⟨polynomial.map (coe : ℤ → R)⟩</code></p>

<a name="191421174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20morphism%20from%20Z/near/191421174" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74894ringmorphismfromZ.html#191421174">Kevin Buzzard (Mar 22 2020 at 23:04)</a>:</h4>
<p>and also</p>
<div class="codehilite"><pre><span></span><span class="kn">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>

<span class="kn">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="bp">ℤ</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">int</span><span class="bp">.</span><span class="n">cast</span> <span class="o">:</span> <span class="bp">ℤ</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>


<p>I used a map which was the same as yours by definition (not just a theorem that they are the same, they are the same by definition). So our definitions of evaluation are the same.</p>

<a name="191421192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20morphism%20from%20Z/near/191421192" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74894ringmorphismfromZ.html#191421192">Kevin Buzzard (Mar 22 2020 at 23:05)</a>:</h4>
<p><code>example : (λ n, ↑n : ℤ → R) = (int.cast : ℤ → R) := rfl</code></p>

<a name="191421280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20morphism%20from%20Z/near/191421280" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74894ringmorphismfromZ.html#191421280">Kevin Buzzard (Mar 22 2020 at 23:08)</a>:</h4>
<p>When you are in this situation, when there are several ways of saying the exact same thing, you have to decide on a "canonical" way! I believe that the canonical way is <code>↑n</code> here (which is just notation for <code>coe</code>). What do I mean by this? I mean that when you prove 100 lemmas about this map, you have to decide exactly how to phrase them (for example you want to prove that this map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi><mo>→</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}\to R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Z</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span> sends products to products, and you have to decide how to say this). The rule is that you state everything using the canonical notation, and then you teach the simplifier all the theorems expressed using the canonical notation, and then the simplifier hopefully works well.</p>

<a name="191421410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20morphism%20from%20Z/near/191421410" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74894ringmorphismfromZ.html#191421410">Kevin Buzzard (Mar 22 2020 at 23:11)</a>:</h4>
<p>You can see in <code>data.int.basic</code> straight after the definition of <code>int.cast</code> they define the coercion:</p>
<div class="codehilite"><pre><span></span><span class="c">/-</span><span class="cm">- Canonical homomorphism from the integers to any ring(-like) structure `α` -/</span>
<span class="kn">protected</span> <span class="n">def</span> <span class="n">cast</span> <span class="o">:</span> <span class="bp">ℤ</span> <span class="bp">→</span> <span class="n">α</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">n</span>
<span class="bp">|</span> <span class="bp">-</span><span class="o">[</span><span class="mi">1</span><span class="bp">+</span> <span class="n">n</span><span class="o">]</span> <span class="o">:=</span> <span class="bp">-</span><span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>

<span class="bp">@</span><span class="o">[</span><span class="n">priority</span> <span class="mi">10</span><span class="o">]</span> <span class="kn">instance</span> <span class="n">cast_coe</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="bp">ℤ</span> <span class="n">α</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">int</span><span class="bp">.</span><span class="n">cast</span><span class="bp">⟩</span>
</pre></div>


<p>and if you import data.int.basic and do stuff like <code>#check int.cast_one</code> or <code>#check int.cast_add</code>, all these results are stated using <code>↑</code> notation.</p>

<a name="191421459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20morphism%20from%20Z/near/191421459" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/74894ringmorphismfromZ.html#191421459">Kevin Buzzard (Mar 22 2020 at 23:12)</a>:</h4>
<p>and if you do things like <code>#print int.cast_add</code> you can see they are all tagged with <code>simp</code>. This is how the simplifier learns to use this stuff. But it means that it's important to stick with the canonical choice if you want to maximise your use of the simplifier.</p>


{% endraw %}

{% include archive_update.html %}