---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html">Feasibility of graph or simplicial complex statement</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="187829752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187829752" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187829752">Tony (Feb 10 2020 at 16:08)</a>:</h4>
<p>I've very new, but I have one very specific question and one general question. (1) Say I had some proposition that came up about graphs (it's currently phrased in the language of Serre and his book on Trees) about paths/geodesics and how they "overlap", would lean be a reasonable place to try to prove it formally? (2) Is there a good source that maps the different proof languages to underlying type systems and compares them - in a way that a math person could read and then decide which is best?</p>

<a name="187829854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187829854" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187829854">Mario Carneiro (Feb 10 2020 at 16:10)</a>:</h4>
<p>The underlying foundation is almost completely irrelevant when it comes to deciding which prover is most suitable for mathematician use</p>

<a name="187829868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187829868" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187829868">Patrick Massot (Feb 10 2020 at 16:10)</a>:</h4>
<p>I don't understand question 2, but the answer to question 1 is yes.</p>

<a name="187829926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187829926" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187829926">Patrick Massot (Feb 10 2020 at 16:10)</a>:</h4>
<p>Mario, you are assuming dependent types here, right?</p>

<a name="187829937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187829937" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187829937">Mario Carneiro (Feb 10 2020 at 16:10)</a>:</h4>
<p>No</p>

<a name="187829960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187829960" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187829960">Mario Carneiro (Feb 10 2020 at 16:11)</a>:</h4>
<p>Although possibly you are hitting on the "almost" in my statement wrt Isabelle limitations</p>

<a name="187830009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187830009" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187830009">Patrick Massot (Feb 10 2020 at 16:11)</a>:</h4>
<p>Then I disagree. Simple types are not good enough for mathematicians</p>

<a name="187830018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187830018" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187830018">Mario Carneiro (Feb 10 2020 at 16:11)</a>:</h4>
<p>It's a problem they could fix if they cared to</p>

<a name="187830090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187830090" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187830090">Patrick Massot (Feb 10 2020 at 16:12)</a>:</h4>
<p>Who is "they" in this message?</p>

<a name="187830095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187830095" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187830095">Mario Carneiro (Feb 10 2020 at 16:12)</a>:</h4>
<p>isabelle community</p>

<a name="187830113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187830113" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187830113">Mario Carneiro (Feb 10 2020 at 16:12)</a>:</h4>
<p>The problem with simple types is not the axiomatic framework itself, but rather the tooling to support "dependent" uses</p>

<a name="187830114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187830114" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187830114">Patrick Massot (Feb 10 2020 at 16:12)</a>:</h4>
<p>You mean they could create Isabelle/DTT?</p>

<a name="187830125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187830125" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187830125">Mario Carneiro (Feb 10 2020 at 16:12)</a>:</h4>
<p>They have ZFC already</p>

<a name="187830159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187830159" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187830159">Mario Carneiro (Feb 10 2020 at 16:13)</a>:</h4>
<p>but as a matter of course, everyone uses Isabelle/HOL and its tactics and they get an impression of the weakness of simple type theory from that</p>

<a name="187830251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187830251" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187830251">Tony (Feb 10 2020 at 16:14)</a>:</h4>
<p>re:Question 2, I'm a non-expert but I would be interested to know if say, system A did dependent types (or your-favorite-thing) and system B didn't. I'd be interested to just have an accurate mapping of which concepts go where even if I didn't understand them - but also interested in which things have practical considerations and which are totally theoretical.</p>

<a name="187830347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187830347" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187830347">Mario Carneiro (Feb 10 2020 at 16:15)</a>:</h4>
<p>Every prover does all math, to a zeroth order approximation</p>

<a name="187830437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187830437" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187830437">Mario Carneiro (Feb 10 2020 at 16:16)</a>:</h4>
<p>the real things to worry about are whether the prover gives you enough sugar to work with it effectively</p>

<a name="187830485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187830485" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187830485">Tony (Feb 10 2020 at 16:17)</a>:</h4>
<p>nCatLab is occasionally abstruse but it's still very useful just because it names concepts and organizes them. Is there a similar thing in this area? <br>
I care about which things formally can do what but I'm also asking about the maturity of the libraries and the real human effectiveness</p>

<a name="187830629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187830629" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187830629">Tony (Feb 10 2020 at 16:18)</a>:</h4>
<p>Thanks for the answers so far :)</p>

<a name="187830764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187830764" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187830764">Mario Carneiro (Feb 10 2020 at 16:20)</a>:</h4>
<p>That said, if you just want to know what axiomatic system the various provers are using: Coq, Lean - CIC (dependent type theory); HOL, HOL4, HOL Light, Isabelle/HOL - HOL (simple type theory); Mizar, Metamath, Isabelle/ZF - ZFC (set theory); Agda, RedPRL, Cubicaltt, UniMath, NuPRL - specialized logics or HoTT variants</p>

<a name="187831037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187831037" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187831037">Mario Carneiro (Feb 10 2020 at 16:22)</a>:</h4>
<p>The most "mature" libraries are Coq, Isabelle, and Mizar; Lean is a newcomer but it has also learned from its predecessors in a lot of ways and is I think pretty nice to use</p>

<a name="187831720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187831720" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187831720">Tony (Feb 10 2020 at 16:29)</a>:</h4>
<p>I suppose there is also Idris? <br>
This list helps!<br>
 I'm sort of hoping for me a 1-dimensional simplicial complex with boundary maps etc. will suffice for the graph (maybe this is even already done in lean) and I'll probably have to do my own work to define what I mean by path and some other data</p>
<p>I'd be interested if there were formal reasons to prefer dependent vs simple types but practically speaking it sounds like dependent+Lean is the way to go.</p>

<a name="187831921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187831921" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187831921">Patrick Massot (Feb 10 2020 at 16:30)</a>:</h4>
<p>My honest opinion is the community is at least as important as the technology. The community here is very mathematician friendly.</p>

<a name="187837288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187837288" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187837288">Kevin Buzzard (Feb 10 2020 at 17:30)</a>:</h4>
<p>As Patrick says, there is nothing in theory to stop one from formalising all of Serre's book on trees in Lean. It would take some time though! I read all the earlier chapters once but I don't recall anything about geodesics.</p>

<a name="187837972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187837972" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187837972">Bryan Gin-ge Chen (Feb 10 2020 at 17:36)</a>:</h4>
<p>I vaguely recall from one of the Lean Together 2020 discussion session streams that someone was going to try to add graph theory to mathlib - is this still work in progress?</p>

<a name="187839899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187839899" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187839899">Kevin Buzzard (Feb 10 2020 at 17:57)</a>:</h4>
<p>With high probability they will use a different definition of "graph". IIRC the Lean Together 2020 talk was about finite graphs, and in Serre's book there are infinite trees all over the place.</p>

<a name="187840503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187840503" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187840503">Tony (Feb 10 2020 at 18:03)</a>:</h4>
<p>In my case I wouldn't need infinite things but I think an infinite path for Serre is implemented as a direct limit.</p>

<a name="187840888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187840888" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187840888">Yury G. Kudryashov (Feb 10 2020 at 18:06)</a>:</h4>
<p>I hope that we'll have a general definition of a graph, then some theorems can assume fintype</p>

<a name="187840928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187840928" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187840928">Kevin Buzzard (Feb 10 2020 at 18:07)</a>:</h4>
<p>You will be able to do it in Lean and Coq and Mizar, you may or may not be able to do it in Isabelle/HOL depending on whether you need dependent types or not (e.g. topological spaces don't need dependent types, sheaves on topological spaces do), and who knows whether you'll be able to do it in HoTT because the moment you ask someone about it they'll start talking about infinity-topoi :-(</p>

<a name="187841048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187841048" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187841048">Yury G. Kudryashov (Feb 10 2020 at 18:08)</a>:</h4>
<p>BTW, who's working on graphs?</p>

<a name="187841720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187841720" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187841720">Kevin Buzzard (Feb 10 2020 at 18:16)</a>:</h4>
<p>Someone gave a talk about it but I can't remember their name :-(</p>

<a name="187842633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187842633" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187842633">Vincent Beffara (Feb 10 2020 at 18:26)</a>:</h4>
<p>I tried to implement a few things in graph theory, here <a href="https://github.com/vbeffara/lean" target="_blank" title="https://github.com/vbeffara/lean">https://github.com/vbeffara/lean</a> and went as far as proving that Cayley graphs of the same group are bilipschitz equivalent, and tried to define graph minors but what I did was very awkward all over. I would love to see what someone who knows what they are doing would write :-)</p>
<p>BTW, is there a canonical way to say "I wrote something that does not quite fit in a chat like here, is definitely PR material, and I would like to get some feedback"?</p>

<a name="187843217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187843217" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187843217">Johan Commelin (Feb 10 2020 at 18:33)</a>:</h4>
<p><span class="user-mention" data-user-id="242586">@Vincent Beffara</span> A pointer to a repository is probably the best thing (-;</p>

<a name="187843223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187843223" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187843223">Tony (Feb 10 2020 at 18:33)</a>:</h4>
<p>That's cool! That's very much in my wheelhouse. Also it looks like you're already using the Serre defn</p>

<a name="187843224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187843224" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187843224">Vaibhav Karve (Feb 10 2020 at 18:33)</a>:</h4>
<p><span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span> <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> I was the one who talked about wanting to add graph theory to lean. I am still working on the basic definitions right now (with the help of an undergraduate here at Univ. of Illinois Urbana-Champaign). I hope to have some code ready to show here in a few weeks. We are only getting started.</p>

<a name="187843226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187843226" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187843226">Johan Commelin (Feb 10 2020 at 18:33)</a>:</h4>
<p>Especially if it works with recent mathlib</p>

<a name="187843257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187843257" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187843257">Johan Commelin (Feb 10 2020 at 18:33)</a>:</h4>
<p><span class="user-mention" data-user-id="242586">@Vincent Beffara</span> You could always take a look at graph libraries in coq. (Disclaimer: I have never actually studied a coq library myself.)</p>

<a name="187844096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187844096" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187844096">Kevin Buzzard (Feb 10 2020 at 18:37)</a>:</h4>
<p>Thanks Vaibhav for reminding me :-)</p>

<a name="187845607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187845607" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187845607">Yury G. Kudryashov (Feb 10 2020 at 18:49)</a>:</h4>
<p><span class="user-mention" data-user-id="241485">@Vaibhav Karve</span> <span class="user-mention" data-user-id="242586">@Vincent Beffara</span> Probably it makes sense for you to collaborate on this. I assume that we don't want to have to choose between two approaches <em>after</em> each of them gets to some advanced stage.</p>

<a name="187845781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187845781" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187845781">Yury G. Kudryashov (Feb 10 2020 at 18:50)</a>:</h4>
<p>Am I right that <code>llist α</code> is the set of nonempty lists?</p>

<a name="187846102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187846102" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187846102">Yury G. Kudryashov (Feb 10 2020 at 18:53)</a>:</h4>
<p>BTW, I wouldn't include <code>symmetric</code> in the basic definition. It makes sense to consider oriented graphs in many cases.</p>

<a name="187846153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187846153" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187846153">Yury G. Kudryashov (Feb 10 2020 at 18:53)</a>:</h4>
<p>You don't have to open <code>section</code> inside a <code>namespace</code>.</p>

<a name="187846171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187846171" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187846171">Kevin Buzzard (Feb 10 2020 at 18:53)</a>:</h4>
<blockquote>
<p>BTW, I wouldn't include <code>symmetric</code> in the basic definition. It makes sense to consider oriented graphs in many cases.</p>
</blockquote>
<p>aah it's started already :-) There are 10 different definitions :-)</p>

<a name="187846354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187846354" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187846354">Tony (Feb 10 2020 at 18:55)</a>:</h4>
<p>Depending on who you talk to, there's a few defn of "graph" out there: (1) subset of V x V (2) Serre (3) specialization of cell-complex (simplicial, delta, CW?) to 1-dim.</p>

<a name="187846476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187846476" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187846476">Yury G. Kudryashov (Feb 10 2020 at 18:56)</a>:</h4>
<p>I don't know Serre's definition. I speak based on my math/programming experience with using graphs in other theories.</p>

<a name="187846680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187846680" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187846680">Vaibhav Karve (Feb 10 2020 at 18:58)</a>:</h4>
<blockquote>
<p><span class="user-mention silent" data-user-id="241485">Vaibhav Karve</span> <span class="user-mention silent" data-user-id="242586">Vincent Beffara</span> Probably it makes sense for you to collaborate on this. I assume that we don't want to have to choose between two approaches <em>after</em> each of them gets to some advanced stage.</p>
</blockquote>
<p>Thanks for the suggestion. I have PM'ed him.</p>

<a name="187846758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187846758" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187846758">Yury G. Kudryashov (Feb 10 2020 at 18:59)</a>:</h4>
<p>I don't know if it makes sense to allow multiple edges between a given pair of vertices. On the one hand, sometimes it makes sense (e.g., interpreting a category as a graph). On the other hand, it probably makes the definition/code harder to read.</p>

<a name="187846821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187846821" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187846821">Tony (Feb 10 2020 at 18:59)</a>:</h4>
<p>It is nice to be able to have them as a specialization of a cell-complex so you can cone off or add things but it depends on what you're doing. (I don't currently need it but having general cell-complex stuff implemented would be really neat)</p>
<p>For Serre a graph is a set of edges and vertices where you think of the edges as being directed. Formally there's a map called *  from E to E such that (e<em>)</em>=e and e* != e and a initial and terminal boundary map from E to V that satisfies b_initial(e)=b_terminal(e*)</p>

<a name="187847013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187847013" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187847013">Tony (Feb 10 2020 at 19:01)</a>:</h4>
<p>( To get from a Serre graph to a combinatorial graph you can take combinatorial edges to be pairs of directed edges {e, e*} )</p>

<a name="187847033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187847033" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187847033">Vaibhav Karve (Feb 10 2020 at 19:01)</a>:</h4>
<p>The results I am interested in in graph theory very much require multi-edges, for example.</p>

<a name="187847520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187847520" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187847520">Yury G. Kudryashov (Feb 10 2020 at 19:06)</a>:</h4>
<p>Then we should have something like</p>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">Graph</span> <span class="o">:=</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">start</span> <span class="kn">end</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">V</span><span class="o">)</span>
</pre></div>


<p>or</p>
<div class="codehilite"><pre><span></span><span class="n">universes</span> <span class="n">v</span> <span class="n">u</span>
<span class="kn">structure</span> <span class="n">Graph</span> <span class="o">:=</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">edges</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">Sort</span> <span class="n">v</span><span class="o">)</span>
</pre></div>


<p>or</p>
<div class="codehilite"><pre><span></span><span class="n">universes</span> <span class="n">v</span> <span class="n">u</span>
<span class="kn">structure</span> <span class="n">graph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">edges</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">Sort</span> <span class="n">v</span><span class="o">)</span>
</pre></div>


<p>Maybe this should be called <code>MultiGraph</code>, then <code>graph</code> can extend it adding the axiom <code>∀ x y, subsingleton (edges x y)</code>.</p>

<a name="187848512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187848512" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187848512">Yury G. Kudryashov (Feb 10 2020 at 19:16)</a>:</h4>
<p>With the <code>(V, E)</code> approach you'll have a lot of equality assumptions here and there, and you'll have to rewrite on them. With the <code>edges : V → V → Sort v</code> approach you'll have troubles whenever you have <code>(x y y' z : V) (e : edges x y) (e' : edges y' z) (h : y = y') (f : Π x y z, edges x y → edges y z → α)</code> and want to write <code>f _ _ _ e e'</code>.</p>

<a name="187849790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187849790" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187849790">Vincent Beffara (Feb 10 2020 at 19:29)</a>:</h4>
<blockquote>
<p>Am I right that <code>llist α</code> is the set of nonempty lists?</p>
</blockquote>
<p>Yes, precisely. I tried with <code>V \times list V</code>, lean had trouble with recursion, so then I tried to define everything in terms of something like fold but in the end a type with explicit constructors was easier to work with</p>

<a name="187849993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187849993" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187849993">Vincent Beffara (Feb 10 2020 at 19:31)</a>:</h4>
<blockquote>
<p>BTW, I wouldn't include <code>symmetric</code> in the basic definition. It makes sense to consider oriented graphs in many cases.</p>
</blockquote>
<p>Sure, and whether <code>v</code> should be adjacent to itself (it makes some definitions easier, and graph minors awful with all the loops ...)</p>

<a name="187850349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187850349" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187850349">Vincent Beffara (Feb 10 2020 at 19:34)</a>:</h4>
<blockquote>
<p>I don't know if it makes sense to allow multiple edges between a given pair of vertices. On the one hand, sometimes it makes sense (e.g., interpreting a category as a graph). On the other hand, it probably makes the definition/code harder to read.</p>
</blockquote>
<p>It makes sense in many contexts to have <code>adj : V -&gt; V -&gt; W</code> for some labelling type <code>W</code> that would be <code>Prop</code> (or <code>bool</code> ? I seem to remember that in Coq it makes a huge difference for some reason, probably due to decidability/proof irrelevance/something) for usual graphs, but <code>W = \nat</code> gives multiplicity, probabilists like <code>W = nnreal</code>, computer scientists like to put a monoid there.</p>
<p>Is it easy to add that after the fact, or would it be better to start in more generality?</p>

<a name="187850464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187850464" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187850464">Vincent Beffara (Feb 10 2020 at 19:36)</a>:</h4>
<blockquote>
<p>It is nice to be able to have them as a specialization of a cell-complex so you can cone off or add things but it depends on what you're doing. (I don't currently need it but having general cell-complex stuff implemented would be really neat)</p>
<p>For Serre a graph is a set of edges and vertices where you think of the edges as being directed. Formally there's a map called *  from E to E such that (e<em>)</em>=e and e* != e and a initial and terminal boundary map from E to V that satisfies b_initial(e)=b_terminal(e*)</p>
</blockquote>
<p>That seems to be what they do in Coq libraries, they have types for both vertices and edges rather than an adjacency relation IIRC</p>

<a name="187850733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187850733" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187850733">Vincent Beffara (Feb 10 2020 at 19:39)</a>:</h4>
<blockquote>
<p>With the <code>(V, E)</code> approach you'll have a lot of equality assumptions here and there, and you'll have to rewrite on them. With the <code>edges : V → V → Sort v</code> approach you'll have troubles whenever you have <code>(x y y' z : V) (e : edges x y) (e' : edges y' z) (h : y = y') (f : Π x y z, edges x y → edges y z → α)</code> and want to write <code>f _ _ _ e e'</code>.</p>
</blockquote>
<p>Path concatenation caused me some trouble with the <code>V -&gt; V -&gt; Prop</code> option (with a <code>Path x y</code> type), indeed. Still felt more manageable to me than the <code>(V,E)</code> version.</p>

<a name="187863020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187863020" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187863020">Vincent Beffara (Feb 10 2020 at 21:59)</a>:</h4>
<blockquote>
<p>You don't have to open <code>section</code> inside a <code>namespace</code>.</p>
</blockquote>
<p>I'm doing that because lean told me I couldn't have <code>parameter</code>s outside a <code>section</code>. Does that mean that it is a bad idea to use <code>parameter</code>?</p>

<a name="187868835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/187868835" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#187868835">Yury G. Kudryashov (Feb 10 2020 at 23:13)</a>:</h4>
<blockquote>
<p>I'm doing that because lean told me I couldn't have <code>parameter</code>s outside a <code>section</code>. Does that mean that it is a bad idea to use <code>parameter</code>?</p>
</blockquote>
<p>AFAIK <code>parameter</code>s will not work in Lean 4. Try <code>variable</code>s.</p>

<a name="188012485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/188012485" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#188012485">Sebastien Gouezel (Feb 12 2020 at 14:09)</a>:</h4>
<blockquote>
<p>BTW, is there a canonical way to say "I wrote something that does not quite fit in a chat like here, is definitely PR material, and I would like to get some feedback"?</p>
</blockquote>
<p><span class="user-mention" data-user-id="242586">@Vincent Beffara</span> , here is some feedback :) </p>
<p>Let me just look at the first line of your file, i.e.,</p>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">Graph</span> <span class="o">:=</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">adj</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">-&gt;</span> <span class="n">V</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">sym</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="n">adj</span><span class="o">)</span>
</pre></div>


<p>because there is a lot to say on this, and it determines everything that follows. What you are doing here is called a fully bundled approach, i.e., a <code>Graph</code> object contains a carrier type, and additional data on this type. This is the way things are typically done in coq. The usual approach in Lean is just a little bit more unbundled: we would start from a type, say <code>V</code>, and then we would tell Lean that this type has a graph structure by registering a graph typeclass. An advantage of this approach is that you work with a single underlying type, and you can put several structures on it (a graph structure, a group structure, and so on), and you can discuss how they relate "from the inside". It would read something like</p>
<div class="codehilite"><pre><span></span><span class="n">class</span> <span class="n">Graph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">adj</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">-&gt;</span> <span class="n">V</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">sym</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="n">adj</span><span class="o">)</span>
</pre></div>


<p>Let me show what the next lines could look like, to show how one uses such typeclasses:</p>
<div class="codehilite"><pre><span></span><span class="kn">namespace</span> <span class="n">Graph</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">V&#39;</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">Graph</span> <span class="n">V</span><span class="o">]</span>  <span class="o">[</span><span class="n">Graph</span> <span class="n">V&#39;</span><span class="o">]</span>

<span class="n">def</span> <span class="n">linked</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span> <span class="n">relation</span><span class="bp">.</span><span class="n">refl_trans_gen</span> <span class="n">adj</span> <span class="n">x</span> <span class="n">y</span>

<span class="n">class</span> <span class="n">connected_graph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">Graph</span> <span class="n">V</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">connected</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="n">y</span><span class="o">,</span> <span class="n">linked</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span>

<span class="bp">@</span><span class="o">[</span><span class="n">ext</span><span class="o">]</span> <span class="kn">structure</span> <span class="n">edge</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">Graph</span> <span class="n">V</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span>
<span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">adj</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span>
</pre></div>


<p>First, I enter a namespace, to make sure that I keep my names separated from other areas where one could use the words <code>edge</code>, for instance, and also to make <code>adj</code> available. Then, I declare some variables and some typeclasses that will be available from this point on, to avoid restating them all the time. The interesting point is when I define <code>linked</code>: there is no explicit reference to the graph structure, but since I am mentioning points on <code>V</code> Lean will try to find the graph structure on <code>V</code> (which is given by the typeclass declared two lines above) and understand by itself that <code>adj</code> refers to this graph structure.</p>
<p>Then in your file you have two definitions of connected, that I have merged in one single definition because I don't see why we would need two. And I have declared it as a type class extending <code>Graph</code>, which means that you will only need to  declare <code>[connected_graph V]</code> if you want to assume that there is a connected graph structure on <code>V</code>, without writing <code>[Graph V]</code> first.</p>
<p>If you have some questions about what I have just written, or if you would be interested in the same kind of "standardification" on some other parts of your files, don't hesitate to ask!</p>

<a name="188014231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/188014231" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#188014231">Yury G. Kudryashov (Feb 12 2020 at 14:28)</a>:</h4>
<p>I'm not sure that I like graphs as typeclasses. I assume that typeclasses are for canonical structures, and I can't think of any canonical graph structure on a type.</p>

<a name="188014278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/188014278" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#188014278">Yury G. Kudryashov (Feb 12 2020 at 14:29)</a>:</h4>
<p>I'd go with <code>structure</code>, though maybe <code>structure Graph V := ...</code>.</p>

<a name="188016043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/188016043" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#188016043">Sebastien Gouezel (Feb 12 2020 at 14:48)</a>:</h4>
<p>For instance, if <code>G</code> is a group and <code>S</code> is a generating set, then its Cayley graph <code>Cay S</code> (which, as a type, is just a copy of <code>G</code>, but it really should be distinguished from <code>G</code>) has a canonical graph structure. I think it is important to do it this way because then you want to deduce a distance on <code>Cay S</code> and do some analysis/geometry, for which you need the metric space typeclass. You can not get the metric space typeclass if you don't have first a graph typeclass to start with.</p>

<a name="188016200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/188016200" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#188016200">Yury G. Kudryashov (Feb 12 2020 at 14:50)</a>:</h4>
<p>You can have a generic type tag <code>graph_dist V G := V</code>.</p>

<a name="188016275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/188016275" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#188016275">Yury G. Kudryashov (Feb 12 2020 at 14:50)</a>:</h4>
<p>(probably with a better name)</p>

<a name="188017279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/188017279" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#188017279">Sebastien Gouezel (Feb 12 2020 at 15:00)</a>:</h4>
<p>Sure, but I don't see the advantage compared to a graph typeclass. If you want to do some finite graph theory, or some automaton theory, you will start with a type with a graph structure, and you will work with this structure, just like you would do with a group structure or with a metric space structure, so typeclasses look like a good choice. Of course, if you start putting several graph structures on the same type, you would need to play the <code>@</code> dance, just like for metric spaces say.</p>

<a name="188017710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/188017710" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#188017710">Yury G. Kudryashov (Feb 12 2020 at 15:04)</a>:</h4>
<p>In my experience dealing with several graphs on the same type is more common than dealing with several distances.</p>

<a name="188017796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/188017796" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#188017796">Yury G. Kudryashov (Feb 12 2020 at 15:05)</a>:</h4>
<p>E.g., I'd prefer to do common operations like adding/removing an edge without introducing new type tags.</p>

<a name="188017919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/188017919" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#188017919">Sebastien Gouezel (Feb 12 2020 at 15:06)</a>:</h4>
<p>OK. We probably need both :)</p>

<a name="188018002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/188018002" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#188018002">Yury G. Kudryashov (Feb 12 2020 at 15:07)</a>:</h4>
<p>Something like <code>structure Graph V := ...</code> + <code>class CanonicalGraph V := (G : Graph V)</code>?</p>

<a name="188018687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/188018687" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#188018687">Sebastien Gouezel (Feb 12 2020 at 15:15)</a>:</h4>
<p>Or just <code>structure Graph V := ...</code> and <code>attribute [class] Graph</code>, but many theorems would be stated with the structure as an explicit argument. It is a little bit like the problem for measure spaces, where one would like to have an implicit measure when building the theory or when doing probability, but an explicit measure when doing analysis.</p>

<a name="188026446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/188026446" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#188026446">Vincent Beffara (Feb 12 2020 at 16:27)</a>:</h4>
<p>I'm trying to understand this whole typeclass thing ... I get the unbundling of the carrier type, but certainly</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">ext</span><span class="o">]</span> <span class="kn">structure</span> <span class="n">edge</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">Graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span>
<span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">adj</span> <span class="n">G</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span>
</pre></div>


<p>feels more natural to me than</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">ext</span><span class="o">]</span> <span class="kn">structure</span> <span class="n">edge</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">Graph</span> <span class="n">V</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span>
<span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">adj</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span>
</pre></div>


<p>I don't see how having the graph structure being implicit would help comparing two graphs on the same carrier?</p>

<a name="188026745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/188026745" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#188026745">Vincent Beffara (Feb 12 2020 at 16:30)</a>:</h4>
<p>(At the beginning I did have <code>Graph V</code>, I tried bundling to also try coercions at the same time)</p>

<a name="188029291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/188029291" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#188029291">Sebastien Gouezel (Feb 12 2020 at 16:54)</a>:</h4>
<blockquote>
<p>I don't see how having the graph structure being implicit would help comparing two graphs on the same carrier?</p>
</blockquote>
<p>The graph structure being implicit is useful when you have one single graph on some type, and you want to talk about it without ever modifying it. If you want to modify a graph, or have several graph structures, then you should go for the structure approach (but still with <code>Graph V</code> instead of having <code>V</code> as a data inside the graph structure, as this is the way everything is done in Lean, so once you want to interface with other parts of the library it will be much easier this way).</p>
<p>One subtely though: metric space structures are implicit type classes in all mathlib, because most of the time you use just one such structure on the space, and you don't want to specify it all the time. This means that if you want to put a metric space structure on a type using the graph distance, then different graphs will give you different distances, and things will become messy. A trick in situations like that (which is in fact more than a trick) is to have copies of the same type, but with different names. For instance, if you have a group <code>G</code> and a generating set <code>S</code>, then you could define <code>Cay S</code> to be a copy of <code>G</code>, and endow it with the graph distance coming from the Cayley graph structure for the generating <code>S</code>. In this way, you get different metric spaces structures on the different <code>Cay S</code>, which to Lean kernel are the same, but to typeclass resolution are different. If the graph structure was a typeclass, then this would also work well here, as you would put different graph structures on different <code>Cay S</code>.</p>

<a name="188034506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/188034506" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#188034506">Tony (Feb 12 2020 at 17:45)</a>:</h4>
<p>I'm not sure if this kind of double induction is more or less amenable to how things are done in Lean but it's yet another way: <a href="/user_uploads/3121/rDpHF6J6d4nMUCTmod96bGse/Capture.PNG" target="_blank" title="Capture.PNG">Capture.PNG</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/rDpHF6J6d4nMUCTmod96bGse/Capture.PNG" target="_blank" title="Capture.PNG"><img src="/user_uploads/3121/rDpHF6J6d4nMUCTmod96bGse/Capture.PNG"></a></div>

<a name="188035744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/188035744" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#188035744">Johan Commelin (Feb 12 2020 at 17:57)</a>:</h4>
<p>I think that something like that is certainly possible, but that exact definition will be really awkward to work with.</p>

<a name="188039120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/188039120" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#188039120">Yury G. Kudryashov (Feb 12 2020 at 18:27)</a>:</h4>
<p>(deleted)</p>

<a name="188043683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/188043683" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#188043683">Vincent Beffara (Feb 12 2020 at 19:14)</a>:</h4>
<blockquote>
<p>One subtely though: metric space structures are implicit type classes in all mathlib, because most of the time you use just one such structure on the space, and you don't want to specify it all the time. This means that if you want to put a metric space structure on a type using the graph distance, then different graphs will give you different distances, and things will become messy. A trick in situations like that (which is in fact more than a trick) is to have copies of the same type, but with different names. For instance, if you have a group <code>G</code> and a generating set <code>S</code>, then you could define <code>Cay S</code> to be a copy of <code>G</code>, and endow it with the graph distance coming from the Cayley graph structure for the generating <code>S</code>. In this way, you get different metric spaces structures on the different <code>Cay S</code>, which to Lean kernel are the same, but to typeclass resolution are different. If the graph structure was a typeclass, then this would also work well here, as you would put different graph structures on different <code>Cay S</code>.</p>
</blockquote>
<p>This seems to have something to do with the fact that a graph structure given a type is not canonical, while a metric structure given a graph is canonical (are there cases where a graph is endowed with a metric that is not the graph distance ?) At least lurking in this chatroom, and reading some of your comments, makes me afraid to use typeclasses here.</p>

<a name="188043831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/188043831" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#188043831">Vincent Beffara (Feb 12 2020 at 19:16)</a>:</h4>
<p>Isn't the case where you have one graph structure that you want to talk about covered by <code>parameter (G : Graph V)</code> or perhaps <code>variable {G : Graph V}</code> ?</p>

<a name="188045312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/188045312" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#188045312">Sebastien Gouezel (Feb 12 2020 at 19:31)</a>:</h4>
<p>I never used parameters. <code>variable</code> is just a shorthand: it means that instead of writing <code>my_beautiful_theorem {V : Type*} {G : Graph V} ...</code> you can just write <code>my_beautiful_theorem ...</code>. The theorems with one syntax or the other are <em>exactly</em> the same.</p>
<p>The summary is: if you will just use one graph structure on your type, go for typeclasses. Otherwise, use a structure, and pass it as one of the arguments of all your theorems, eiter as <code>{G : Graph V}</code> if it can be inferred by some other data in the statement of the theorem, or as <code>(G : Graph V)</code> otherwise. This can be done explicitly in all your statements if needed, or using a <code>variable</code> at the beginning of the section to avoid repetitions.</p>

<a name="188051714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/188051714" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#188051714">Vincent Beffara (Feb 12 2020 at 20:46)</a>:</h4>
<p>So like this ?</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">carrier</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">Graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span> <span class="n">V</span>

<span class="n">noncomputable</span> <span class="kn">instance</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">Graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">[</span><span class="n">Graph</span><span class="bp">.</span><span class="n">connected_graph</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_dist</span> <span class="o">(</span><span class="n">carrier</span> <span class="n">G</span><span class="o">)</span>
    <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">G</span><span class="bp">.</span><span class="n">dist</span> <span class="n">x</span> <span class="n">y</span><span class="bp">⟩</span>

<span class="n">def</span> <span class="n">id_S</span> <span class="o">:</span> <span class="n">carrier</span> <span class="o">(</span><span class="n">Cay</span> <span class="n">S1</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">carrier</span> <span class="o">(</span><span class="n">Cay</span> <span class="n">S2</span><span class="o">)</span> <span class="o">:=</span> <span class="n">id</span>

<span class="kn">theorem</span> <span class="n">bilipschitz</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">K</span><span class="o">,</span> <span class="n">lipschitz_with</span> <span class="n">K</span> <span class="o">(</span><span class="n">id_S</span> <span class="n">S1</span> <span class="n">S2</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>

<a name="188051823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/188051823" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#188051823">Johan Commelin (Feb 12 2020 at 20:48)</a>:</h4>
<p>Aside: wouldn't it be more natural to use <code>vertices</code> instead of <code>carrier</code> (in this context)?</p>

<a name="188052069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/188052069" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#188052069">Vincent Beffara (Feb 12 2020 at 20:51)</a>:</h4>
<blockquote>
<p>Aside: wouldn't it be more natural to use <code>vertices</code> instead of <code>carrier</code> (in this context)?</p>
</blockquote>
<p>It would :-)</p>

<a name="188052391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/188052391" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#188052391">Vincent Beffara (Feb 12 2020 at 20:56)</a>:</h4>
<p>Shouldn't I be afraid that lean will see through what I am trying to do, unfold (Cay S1).vertices and (Cay S2).vertices, see that they are the underlying group, forget about the graphs, and then fail to select the right instance of has_dist?</p>

<a name="188052412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/188052412" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#188052412">Vincent Beffara (Feb 12 2020 at 20:56)</a>:</h4>
<p>(Well probably not, since it seems to work...)</p>

<a name="188056365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/188056365" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#188056365">Sebastien Gouezel (Feb 12 2020 at 21:47)</a>:</h4>
<p>Typeclass search will never unfold anything, unless it is marked reducible. So, the following would work if you had defined graphs as typeclasses (I understand that you don't want to do it, but still I would like to show how it would work :)</p>
<div class="codehilite"><pre><span></span><span class="n">class</span> <span class="n">Graph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">adj</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="kn">instance</span> <span class="n">Graph</span><span class="bp">.</span><span class="n">to_metric_space</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">Graph</span> <span class="n">V</span><span class="o">]</span> <span class="o">:</span> <span class="n">metric_space</span> <span class="n">V</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="n">def</span> <span class="n">Cay</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span> <span class="o">:=</span> <span class="n">G</span>

<span class="kn">instance</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">Graph</span> <span class="o">(</span><span class="n">Cay</span> <span class="n">S</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">instance</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">metric_space</span> <span class="o">(</span><span class="n">Cay</span> <span class="n">S</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span>
</pre></div>


<p>In the first sorry, you would explain to Lean how a graph structure gives a metric space structure. In the second sorry, you would construct the Cayley graph structure on <code>Cay S</code>, which is just <code>G</code> in disguise. And then Lean knows that <code>Cay S</code> is a graph, and therefore a metric space thanks to the first instance. The last line is only there to check that Lean does indeed know this, but it can be safely removed.</p>

<a name="188058040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/188058040" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#188058040">Vincent Beffara (Feb 12 2020 at 22:07)</a>:</h4>
<p>OK, thanks, it is beginning to slowly sink in :-)</p>

<a name="188058162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/188058162" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#188058162">Kevin Buzzard (Feb 12 2020 at 22:09)</a>:</h4>
<p>Do we have any reason to believe that fully bundled structures a la category theory will be easier to work with in Lean 4? One nice thing about partially bundled structures is that morphisms are actually functions -- although when you start dealing with e.g. algebra maps then they become types again.</p>

<a name="188058272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/188058272" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#188058272">Reid Barton (Feb 12 2020 at 22:10)</a>:</h4>
<p>At least coercions to functions should work better in Lean 4, so applying a morphism as a function should work more reliably. But it mostly works fine already in Lean 3, if the morphism is a variable for instance.</p>

<a name="188070615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/188070615" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#188070615">Yury G. Kudryashov (Feb 13 2020 at 01:24)</a>:</h4>
<p>One of the downsides of using <code>structure Graph</code> instead of <code>structure Graph V</code> is that with <code>structure Graph</code> it's much harder to consider two graphs on the same type because you can't rely on <code>G.V = G'.V</code> being a <code>rfl</code> anymore.</p>

<a name="188154554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/188154554" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#188154554">Vincent Beffara (Feb 13 2020 at 21:35)</a>:</h4>
<p>So I tried the type class route, but I'm confused about something:</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">ext</span><span class="o">]</span> <span class="n">class</span> <span class="n">Graph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">adj</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">-&gt;</span> <span class="n">V</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">sym</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="n">adj</span><span class="o">)</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">Graph</span><span class="bp">.</span><span class="n">adj</span> <span class="c1">-- Graph.adj : ?M_1 → ?M_1 → Prop</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">Graph</span><span class="bp">.</span><span class="n">sym</span> <span class="c1">-- Graph.sym : ∀ (V : Type) [c : Graph V], symmetric Graph.adj</span>
</pre></div>


<p>Why is the <code>V</code> parameter implicit (or meta-variable-ish) in <code>adj</code> and not in <code>sym</code>? Is there a way to set things up so that one can use the symmetry assumption as <code>Graph.sym</code> rather than <code>Graph.sym G</code>? In all cases I met, <code>Graph.sym _</code> works just fine ...</p>

<a name="188155333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/188155333" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#188155333">Vincent Beffara (Feb 13 2020 at 21:43)</a>:</h4>
<p>Second question, still following the type class option, how do you say "there is a graph structure on type <code>G</code> that satisfies this and that property"? Is it just <code>∃ C : Graph G</code> and then use all the definitions and theorems with <code>@</code> all over to specify the instance every time?</p>

<a name="188155419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/188155419" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#188155419">Reid Barton (Feb 13 2020 at 21:44)</a>:</h4>
<p>Try adding <code>{}</code> after <code>sym</code> like so: <code>(sym {} : symmetric adj)</code></p>

<a name="188155463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/188155463" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#188155463">Reid Barton (Feb 13 2020 at 21:44)</a>:</h4>
<p>For the second question, usually you should also be able to write <code>∃ C : Graph G, by exactI ...</code></p>

<a name="188155595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/188155595" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#188155595">Reid Barton (Feb 13 2020 at 21:46)</a>:</h4>
<p><code>by exactI ...</code> is a variant of <code>by exact ...</code> (which in turn is more or less the same as just the <code>...</code>) that makes all variables in the context available for instance search.</p>

<a name="188155691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/188155691" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#188155691">Reid Barton (Feb 13 2020 at 21:47)</a>:</h4>
<p>Normally, the rule is that only variables to the left of the <code>:</code> in the def/lemma statement are available. Variables introduced by a pi/exists/etc. are not.</p>

<a name="188155828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/188155828" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#188155828">Vincent Beffara (Feb 13 2020 at 21:48)</a>:</h4>
<blockquote>
<p>Try adding <code>{}</code> after <code>sym</code> like so: <code>(sym {} : symmetric adj)</code></p>
</blockquote>
<p>Ah, thanks, that works! (but the notation is not easy to guess ;-) )</p>

<a name="188156344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/188156344" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#188156344">Yury G. Kudryashov (Feb 13 2020 at 21:54)</a>:</h4>
<p><span class="user-mention" data-user-id="242586">@Vincent Beffara</span> I'd go with <code>@[class] structure Graph V := (adj : V → V → Prop)</code>, then you'll have a normal <code>structure</code> for non-canonical graphs while being able to write <code>instance ... : Graph V</code> for canonical graphs.</p>

<a name="188156776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/188156776" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#188156776">Yury G. Kudryashov (Feb 13 2020 at 21:58)</a>:</h4>
<p>As of now, I see one use case of a canonical graph (auto coercion to a metric space), and I'd do it with</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">graph_space</span> <span class="o">{</span><span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">Graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span> <span class="n">V</span>
<span class="kn">instance</span> <span class="n">graph_space</span><span class="bp">.</span><span class="n">emetric_space</span> <span class="o">{</span><span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">Graph</span> <span class="n">V</span><span class="o">}</span> <span class="o">:</span> <span class="n">emetric_space</span> <span class="o">(</span><span class="n">graph_space</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">edist</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">G</span><span class="bp">.</span><span class="n">edist</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="bp">..</span> <span class="o">}</span>
<span class="kn">instance</span> <span class="n">graph_space</span><span class="bp">.</span><span class="n">metric_space</span> <span class="o">{</span><span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">Graph</span> <span class="n">V</span><span class="o">}</span> <span class="o">[</span><span class="n">connected_graph</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">metric_space</span> <span class="o">(</span><span class="n">graph_space</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">...</span>
</pre></div>

<a name="188159954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/188159954" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#188159954">Sebastien Gouezel (Feb 13 2020 at 22:37)</a>:</h4>
<p>I agree with Yury that this is probably the best approach. For instance, if you want to do percolation at some point, you will have a bunch of different random graphs on <code>Z^d</code>, so registering them as a type class would be a really bad idea. But having a copy of the space associated to the graph makes it possible to use a metric space structure as he explains.</p>

<a name="188160927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/188160927" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#188160927">Vincent Beffara (Feb 13 2020 at 22:49)</a>:</h4>
<p>OK thanks, that feels reasonable. Will it be easy to apply a theorem using <code>[Graph G]</code> to a specific graph <code>(G : Graph V)</code>? Just use lots of <code>@</code> and <code>_</code> and plug <code>G</code> where it expects an instance of <code>[Graph G]</code>? Or would it have to be something weird like</p>
<div class="codehilite"><pre><span></span><span class="kn">instance</span> <span class="o">{</span><span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">Graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">Graph</span> <span class="o">(</span><span class="n">graph_space</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span> <span class="n">G</span>
</pre></div>

<a name="188163946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/188163946" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#188163946">Yury G. Kudryashov (Feb 13 2020 at 23:30)</a>:</h4>
<p>I'd formulate most theorems with <code>(G : Graph V)</code> or <code>{G : Graph V}</code>, then it will be easy to apply them in both scenarios.</p>

<a name="188164066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Feasibility%20of%20graph%20or%20simplicial%20complex%20statement/near/188164066" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/92850Feasibilityofgraphorsimplicialcomplexstatement.html#188164066">Yury G. Kudryashov (Feb 13 2020 at 23:32)</a>:</h4>
<p>And you can have</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">the_graph</span> <span class="o">(</span><span class="n">V</span><span class="o">)</span> <span class="o">[</span><span class="n">G</span> <span class="o">:</span> <span class="n">Graph</span> <span class="n">V</span><span class="o">]</span> <span class="o">:=</span> <span class="n">G</span>
</pre></div>


<p>for those cases when you want to specify explicitly that you're dealing with the canonical graph.</p>


{% endraw %}

{% include archive_update.html %}