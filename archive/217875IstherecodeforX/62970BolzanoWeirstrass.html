---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/217875IstherecodeforX/62970BolzanoWeirstrass.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/index.html">Is there code for X?</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html">Bolzano-Weirstrass</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="192596854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192596854" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192596854">Patrick Massot (Apr 01 2020 at 21:44)</a>:</h4>
<p>I should be the one answering this question, but just to make sure: do we have anything that look like Bolzano-Weirstrass? Specifically, do we know that every sequence with values in <code>Icc a b</code> has a convergent subsequence? <a href="https://github.com/leanprover-community/mathlib/blob/33764abc51cbd699d43976085513444216639670/src/topology/sequences.lean#L21-L22" title="https://github.com/leanprover-community/mathlib/blob/33764abc51cbd699d43976085513444216639670/src/topology/sequences.lean#L21-L22">https://github.com/leanprover-community/mathlib/blob/33764abc51cbd699d43976085513444216639670/src/topology/sequences.lean#L21-L22</a> is not too encouraging, but there may be more elementary places to look at. I didn't find anything in metric spaces.</p>

<a name="192598508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192598508" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192598508">Bhavik Mehta (Apr 01 2020 at 22:03)</a>:</h4>
<p>This might not be what you're looking for but infinite ramsey <a href="https://github.com/b-mehta/combinatorics/blob/extras/src/inf_ramsey.lean" title="https://github.com/b-mehta/combinatorics/blob/extras/src/inf_ramsey.lean">which I proved here</a> implies that any sequence in a linear order has a monotone subsequence which would help with a big part of BW</p>

<a name="192639938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192639938" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192639938">Patrick Massot (Apr 02 2020 at 09:24)</a>:</h4>
<p>Thanks, but I think I'll try a more direct path.</p>

<a name="192640018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192640018" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192640018">Patrick Massot (Apr 02 2020 at 09:25)</a>:</h4>
<p>However I realize I have no idea how to do some very basic proof step in Lean. How do I define a sequence by induction in the middle of a proof? It doesn't seem possible to use the equation compiler in a <code>let</code>.</p>

<a name="192653204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192653204" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192653204">Bhavik Mehta (Apr 02 2020 at 11:51)</a>:</h4>
<p>I had this exact question! For me, the right thing to use was Reid's crec construction</p>

<a name="192654782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192654782" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192654782">Chris Hughes (Apr 02 2020 at 12:04)</a>:</h4>
<p>I think just <code>nat.rec_on</code> should be okay most of the time.</p>

<a name="192679488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192679488" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192679488">Patrick Massot (Apr 02 2020 at 15:11)</a>:</h4>
<p>Thanks Bhavik, this crec looks promising. And <a href="#narrow/stream/116395-maths/topic/Inductive.20construction" title="#narrow/stream/116395-maths/topic/Inductive.20construction">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Inductive.20construction</a> is the thread I should have been looking for. Chris <code>nat.rec_on</code> is not good enough here (or at least it's hugely inconvenient).</p>

<a name="192682293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192682293" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192682293">Mario Carneiro (Apr 02 2020 at 15:25)</a>:</h4>
<p><code>crec</code> is for when the type of the sequence you are constructing requires a partial proof of correctness of earlier parts of the sequence. It's a pretty advanced tool and doesn't sound like what you are describing, which is just how to write recursive functions in a proof</p>

<a name="192682367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192682367" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192682367">Mario Carneiro (Apr 02 2020 at 15:25)</a>:</h4>
<p>do you have an example?</p>

<a name="192682721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192682721" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192682721">Patrick Massot (Apr 02 2020 at 15:28)</a>:</h4>
<p>Ok, maybe this discussion is too abstract.</p>

<a name="192682804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192682804" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192682804">Patrick Massot (Apr 02 2020 at 15:28)</a>:</h4>
<p>Could you please prove:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">ψ</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hψ</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">ψ</span> <span class="n">n</span> <span class="bp">≥</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">n</span> <span class="n">m</span><span class="o">,</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">m</span> <span class="bp">→</span> <span class="o">(</span><span class="n">ψ</span> <span class="err">∘</span> <span class="n">f</span><span class="o">)</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">ψ</span> <span class="err">∘</span> <span class="n">f</span><span class="o">)</span> <span class="n">m</span><span class="o">)</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="n">n</span> <span class="bp">≥</span> <span class="n">n</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>


<p>without using a special trick that would bypass the recursive definition issue.</p>

<a name="192683806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192683806" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192683806">Patrick Massot (Apr 02 2020 at 15:34)</a>:</h4>
<p>The proof I have on paper is: set f(0)=0 and then, assuming f(n-1) is defined, set <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>:</mo><mo>=</mo><mi>ψ</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f(n) := \psi(f(n-1)) + 1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">ψ</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>

<a name="192685679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192685679" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192685679">Mario Carneiro (Apr 02 2020 at 15:46)</a>:</h4>
<p>Option 1: equation compiler hacks</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">ψ</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hψ</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">ψ</span> <span class="n">n</span> <span class="bp">≥</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">n</span> <span class="n">m</span><span class="o">,</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">m</span> <span class="bp">→</span> <span class="o">(</span><span class="n">ψ</span> <span class="err">∘</span> <span class="n">f</span><span class="o">)</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">ψ</span> <span class="err">∘</span> <span class="n">f</span><span class="o">)</span> <span class="n">m</span><span class="o">)</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="n">n</span> <span class="bp">≥</span> <span class="n">n</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">n</span><span class="o">,</span> <span class="k">match</span> <span class="n">n</span> <span class="k">with</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">ψ</span> <span class="o">(</span><span class="k">by</span> <span class="n">exact</span> <span class="bp">_</span><span class="n">match</span> <span class="n">n</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="kn">end</span><span class="o">,</span>
<span class="k">begin</span>
  <span class="n">split</span><span class="bp">;</span> <span class="n">intros</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">induction</span> <span class="n">a</span><span class="bp">;</span> <span class="n">dsimp</span> <span class="o">[(</span><span class="err">∘</span><span class="o">),</span> <span class="bp">_</span><span class="n">example</span><span class="bp">._</span><span class="n">match_1</span><span class="o">],</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">hψ</span> <span class="bp">_</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">lt_trans</span> <span class="n">a_ih</span> <span class="o">(</span><span class="n">hψ</span> <span class="bp">_</span><span class="o">)</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">induction</span> <span class="n">n</span><span class="o">,</span> <span class="o">{</span><span class="n">apply</span> <span class="n">le_refl</span><span class="o">},</span>
    <span class="n">dsimp</span> <span class="o">[</span><span class="bp">_</span><span class="n">example</span><span class="bp">._</span><span class="n">match_1</span><span class="o">],</span>
    <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ_le_succ</span> <span class="o">(</span><span class="n">le_trans</span> <span class="n">n_ih</span> <span class="o">(</span><span class="n">hψ</span> <span class="bp">_</span><span class="o">))</span> <span class="o">}</span>
<span class="kn">end</span><span class="bp">⟩</span>
</pre></div>

<a name="192685846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192685846" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192685846">Mario Carneiro (Apr 02 2020 at 15:47)</a>:</h4>
<p>Option 2: <code>nat.rec_on</code></p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">ψ</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hψ</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">ψ</span> <span class="n">n</span> <span class="bp">≥</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">n</span> <span class="n">m</span><span class="o">,</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">m</span> <span class="bp">→</span> <span class="o">(</span><span class="n">ψ</span> <span class="err">∘</span> <span class="n">f</span><span class="o">)</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">ψ</span> <span class="err">∘</span> <span class="n">f</span><span class="o">)</span> <span class="n">m</span><span class="o">)</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="n">n</span> <span class="bp">≥</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">refine</span> <span class="bp">⟨λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">n</span> <span class="mi">0</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="n">ih</span><span class="o">,</span> <span class="n">ψ</span> <span class="n">ih</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="bp">λ</span> <span class="n">m</span> <span class="n">n</span> <span class="n">h</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">induction</span> <span class="n">h</span><span class="bp">;</span> <span class="n">dsimp</span> <span class="o">[(</span><span class="err">∘</span><span class="o">)],</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">hψ</span> <span class="bp">_</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">lt_trans</span> <span class="n">h_ih</span> <span class="o">(</span><span class="n">hψ</span> <span class="bp">_</span><span class="o">)</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">induction</span> <span class="n">n</span><span class="o">,</span> <span class="o">{</span><span class="n">apply</span> <span class="n">le_refl</span><span class="o">},</span>
    <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ_le_succ</span> <span class="o">(</span><span class="n">le_trans</span> <span class="n">n_ih</span> <span class="o">(</span><span class="n">hψ</span> <span class="bp">_</span><span class="o">))</span> <span class="o">}</span>
<span class="kn">end</span>
</pre></div>

<a name="192686062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192686062" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192686062">Mario Carneiro (Apr 02 2020 at 15:49)</a>:</h4>
<p>Option 3: local def</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">ψ</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">ψ</span> <span class="o">(</span><span class="n">foo</span> <span class="n">n</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">ψ</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hψ</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">ψ</span> <span class="n">n</span> <span class="bp">≥</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">n</span> <span class="n">m</span><span class="o">,</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">m</span> <span class="bp">→</span> <span class="o">(</span><span class="n">ψ</span> <span class="err">∘</span> <span class="n">f</span><span class="o">)</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">ψ</span> <span class="err">∘</span> <span class="n">f</span><span class="o">)</span> <span class="n">m</span><span class="o">)</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="n">n</span> <span class="bp">≥</span> <span class="n">n</span> <span class="o">:=</span>
<span class="bp">⟨</span><span class="n">foo</span> <span class="n">ψ</span><span class="o">,</span> <span class="k">begin</span>
  <span class="n">split</span><span class="bp">;</span> <span class="n">intros</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">induction</span> <span class="n">a</span><span class="bp">;</span> <span class="n">dsimp</span> <span class="o">[(</span><span class="err">∘</span><span class="o">),</span> <span class="n">foo</span><span class="o">],</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">hψ</span> <span class="bp">_</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">lt_trans</span> <span class="n">a_ih</span> <span class="o">(</span><span class="n">hψ</span> <span class="bp">_</span><span class="o">)</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">induction</span> <span class="n">n</span><span class="o">,</span> <span class="o">{</span><span class="n">apply</span> <span class="n">le_refl</span><span class="o">},</span>
    <span class="n">dsimp</span> <span class="o">[</span><span class="n">foo</span><span class="o">],</span>
    <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ_le_succ</span> <span class="o">(</span><span class="n">le_trans</span> <span class="n">n_ih</span> <span class="o">(</span><span class="n">hψ</span> <span class="bp">_</span><span class="o">))</span> <span class="o">}</span>
<span class="kn">end</span><span class="bp">⟩</span>
</pre></div>

<a name="192686083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192686083" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192686083">Patrick Massot (Apr 02 2020 at 15:49)</a>:</h4>
<p>Option 1 says: <code>invalid match/convoy expression, expected type is not known</code>. But this is using an old Lean+mathlib (frozen in early January)</p>

<a name="192686199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192686199" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192686199">Mario Carneiro (Apr 02 2020 at 15:50)</a>:</h4>
<p>It works for me but you can see if this works</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">ψ</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hψ</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">ψ</span> <span class="n">n</span> <span class="bp">≥</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">n</span> <span class="n">m</span><span class="o">,</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">m</span> <span class="bp">→</span> <span class="o">(</span><span class="n">ψ</span> <span class="err">∘</span> <span class="n">f</span><span class="o">)</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">ψ</span> <span class="err">∘</span> <span class="n">f</span><span class="o">)</span> <span class="n">m</span><span class="o">)</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="n">n</span> <span class="bp">≥</span> <span class="n">n</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="k">match</span> <span class="n">n</span> <span class="k">with</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">ψ</span> <span class="o">(</span><span class="k">by</span> <span class="n">exact</span> <span class="bp">_</span><span class="n">match</span> <span class="n">n</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="kn">end</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span>
<span class="k">begin</span>
  <span class="n">split</span><span class="bp">;</span> <span class="n">intros</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">induction</span> <span class="n">a</span><span class="bp">;</span> <span class="n">dsimp</span> <span class="o">[(</span><span class="err">∘</span><span class="o">),</span> <span class="bp">_</span><span class="n">example</span><span class="bp">._</span><span class="n">match_1</span><span class="o">],</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">hψ</span> <span class="bp">_</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">lt_trans</span> <span class="n">a_ih</span> <span class="o">(</span><span class="n">hψ</span> <span class="bp">_</span><span class="o">)</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">induction</span> <span class="n">n</span><span class="o">,</span> <span class="o">{</span><span class="n">apply</span> <span class="n">le_refl</span><span class="o">},</span>
    <span class="n">dsimp</span> <span class="o">[</span><span class="bp">_</span><span class="n">example</span><span class="bp">._</span><span class="n">match_1</span><span class="o">],</span>
    <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ_le_succ</span> <span class="o">(</span><span class="n">le_trans</span> <span class="n">n_ih</span> <span class="o">(</span><span class="n">hψ</span> <span class="bp">_</span><span class="o">))</span> <span class="o">}</span>
<span class="kn">end</span><span class="bp">⟩</span>
</pre></div>

<a name="192686377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192686377" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192686377">Patrick Massot (Apr 02 2020 at 15:50)</a>:</h4>
<p>Same error.</p>

<a name="192686380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192686380" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192686380">Mario Carneiro (Apr 02 2020 at 15:50)</a>:</h4>
<p>This version should always work</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">ψ</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hψ</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">ψ</span> <span class="n">n</span> <span class="bp">≥</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">n</span> <span class="n">m</span><span class="o">,</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">m</span> <span class="bp">→</span> <span class="o">(</span><span class="n">ψ</span> <span class="err">∘</span> <span class="n">f</span><span class="o">)</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">ψ</span> <span class="err">∘</span> <span class="n">f</span><span class="o">)</span> <span class="n">m</span><span class="o">)</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="n">n</span> <span class="bp">≥</span> <span class="n">n</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">n</span><span class="o">,</span> <span class="k">match</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="k">with</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">ψ</span> <span class="o">(</span><span class="k">by</span> <span class="n">exact</span> <span class="bp">_</span><span class="n">match</span> <span class="n">n</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="kn">end</span><span class="o">,</span>
<span class="k">begin</span>
  <span class="n">split</span><span class="bp">;</span> <span class="n">intros</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">induction</span> <span class="n">a</span><span class="bp">;</span> <span class="n">dsimp</span> <span class="o">[(</span><span class="err">∘</span><span class="o">),</span> <span class="bp">_</span><span class="n">example</span><span class="bp">._</span><span class="n">match_1</span><span class="o">],</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">hψ</span> <span class="bp">_</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">lt_trans</span> <span class="n">a_ih</span> <span class="o">(</span><span class="n">hψ</span> <span class="bp">_</span><span class="o">)</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">induction</span> <span class="n">n</span><span class="o">,</span> <span class="o">{</span><span class="n">apply</span> <span class="n">le_refl</span><span class="o">},</span>
    <span class="n">dsimp</span> <span class="o">[</span><span class="bp">_</span><span class="n">example</span><span class="bp">._</span><span class="n">match_1</span><span class="o">],</span>
    <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ_le_succ</span> <span class="o">(</span><span class="n">le_trans</span> <span class="n">n_ih</span> <span class="o">(</span><span class="n">hψ</span> <span class="bp">_</span><span class="o">))</span> <span class="o">}</span>
<span class="kn">end</span><span class="bp">⟩</span>
</pre></div>

<a name="192686616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192686616" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192686616">Patrick Massot (Apr 02 2020 at 15:52)</a>:</h4>
<p>But option 2 works (option 3 is not good, it relies on having everything needed before starting a proof).</p>

<a name="192686632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192686632" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192686632">Patrick Massot (Apr 02 2020 at 15:52)</a>:</h4>
<p>Thank you very much.</p>

<a name="192686658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192686658" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192686658">Patrick Massot (Apr 02 2020 at 15:52)</a>:</h4>
<p>I really really think we should have a tactic helping to setup this.</p>

<a name="192686687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192686687" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192686687">Mario Carneiro (Apr 02 2020 at 15:52)</a>:</h4>
<p>I think the best option is option 3</p>

<a name="192686716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192686716" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192686716">Mario Carneiro (Apr 02 2020 at 15:53)</a>:</h4>
<p>Option 1 is just an obfuscated version of option 3</p>

<a name="192686741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192686741" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192686741">Mario Carneiro (Apr 02 2020 at 15:53)</a>:</h4>
<p>because lean extracts the def into its own function anyway</p>

<a name="192686821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192686821" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192686821">Patrick Massot (Apr 02 2020 at 15:53)</a>:</h4>
<p>Option 3 is not viable in general. We want to be able to build a sequence in the middle of a complicated proof. Extracting the required context for an auxiliary def could be a mess.</p>

<a name="192686886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192686886" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192686886">Mario Carneiro (Apr 02 2020 at 15:54)</a>:</h4>
<p>Even if you are in the middle of the proof, you can just collect the hypotheses that are currently active and put them as parameters to the recursive function. This is what lean does (note that <code>_example._match_1</code> in the first case has a psi argument)</p>

<a name="192686923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192686923" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192686923">Patrick Massot (Apr 02 2020 at 15:54)</a>:</h4>
<p>We need a tactic handling this, and all the cases that Bhavik and Reid were interested in.</p>

<a name="192686938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192686938" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192686938">Mario Carneiro (Apr 02 2020 at 15:54)</a>:</h4>
<p>The <code>abstract</code> tactic does this for you</p>

<a name="192686987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192686987" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192686987">Mario Carneiro (Apr 02 2020 at 15:54)</a>:</h4>
<p>it's not an editor plugin though</p>

<a name="192687064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192687064" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192687064">Patrick Massot (Apr 02 2020 at 15:55)</a>:</h4>
<p>What is the abstract tactic?</p>

<a name="192687857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192687857" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192687857">Mario Carneiro (Apr 02 2020 at 15:58)</a>:</h4>
<p>Here is a version of option 2 which abstracts the definition after constructing it. Note that in the latter two goals the function has the name <code>foo._aux_1</code>, and this name lives on after the def is done</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">ψ</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hψ</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">ψ</span> <span class="n">n</span> <span class="bp">≥</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">n</span> <span class="n">m</span><span class="o">,</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">m</span> <span class="bp">→</span> <span class="o">(</span><span class="n">ψ</span> <span class="err">∘</span> <span class="n">f</span><span class="o">)</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">ψ</span> <span class="err">∘</span> <span class="n">f</span><span class="o">)</span> <span class="n">m</span><span class="o">)</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="n">n</span> <span class="bp">≥</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">refine</span> <span class="bp">⟨λ</span> <span class="n">n</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">m</span> <span class="n">n</span> <span class="n">h</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span>
  <span class="n">abstract</span> <span class="o">{</span> <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">n</span> <span class="mi">0</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="n">ih</span><span class="o">,</span> <span class="n">ψ</span> <span class="n">ih</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">induction</span> <span class="n">h</span><span class="bp">;</span> <span class="n">dsimp</span> <span class="o">[(</span><span class="err">∘</span><span class="o">)],</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">hψ</span> <span class="bp">_</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">lt_trans</span> <span class="n">h_ih</span> <span class="o">(</span><span class="n">hψ</span> <span class="bp">_</span><span class="o">)</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">induction</span> <span class="n">n</span><span class="o">,</span> <span class="o">{</span><span class="n">apply</span> <span class="n">le_refl</span><span class="o">},</span>
    <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ_le_succ</span> <span class="o">(</span><span class="n">le_trans</span> <span class="n">n_ih</span> <span class="o">(</span><span class="n">hψ</span> <span class="bp">_</span><span class="o">))</span> <span class="o">}</span>
<span class="kn">end</span>
<span class="bp">#</span><span class="kn">print</span> <span class="n">foo</span><span class="bp">._</span><span class="n">aux_1</span>
<span class="c1">-- def foo._aux_1 : (ℕ → ℕ) → ℕ → ℕ :=</span>
<span class="c1">-- λ (ψ : ℕ → ℕ) (n : ℕ), nat.rec_on n 0 (λ (n ih : ℕ), ψ ih + 1)</span>
</pre></div>

<a name="192688008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192688008" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192688008">Patrick Massot (Apr 02 2020 at 15:59)</a>:</h4>
<p>I don't see how it helps. Now you have the auxiliary definition when you no longer need it, right?</p>

<a name="192688185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192688185" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192688185">Mario Carneiro (Apr 02 2020 at 16:00)</a>:</h4>
<p>What it doesn't give you is the nice parsing with an equation compiler that <code>def</code> provides</p>

<a name="192688258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192688258" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192688258">Mario Carneiro (Apr 02 2020 at 16:01)</a>:</h4>
<p>What it is accomplishing that other tactics don't usually do is the creation of a definition in the global environment based on a term stuck in a local context</p>

<a name="192688260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192688260" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192688260">Patrick Massot (Apr 02 2020 at 16:01)</a>:</h4>
<p>But we don't want a def at all. We want to construct a sequence during a proof and then throw it away.</p>

<a name="192688360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192688360" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192688360">Mario Carneiro (Apr 02 2020 at 16:02)</a>:</h4>
<p>We do want a def, because a def has equations and stuff that you want recursive functions to have</p>

<a name="192688472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192688472" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192688472">Mario Carneiro (Apr 02 2020 at 16:02)</a>:</h4>
<p>If the recursion is small enough, like in this example, option 2 is tolerable, but the function is this big expression that makes things harder to see</p>

<a name="192688610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192688610" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192688610">Patrick Massot (Apr 02 2020 at 16:03)</a>:</h4>
<p>That's why we need a tactic.</p>

<a name="192688673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192688673" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192688673">Mario Carneiro (Apr 02 2020 at 16:04)</a>:</h4>
<p>For bigger recursive functions the equation compiler packs up the recursor behind a constant and you only unfold it through <code>dsimp</code> or <code>rw</code> and it automatically refolds the recursive call into the constant</p>

<a name="192688724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192688724" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192688724">Patrick Massot (Apr 02 2020 at 16:04)</a>:</h4>
<p>Just like we needed the <code>choose</code> tactic. The tactic will need to both create the function and the correct properties in the context.</p>

<a name="192688807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192688807" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192688807">Mario Carneiro (Apr 02 2020 at 16:05)</a>:</h4>
<p>It can't be in the local context because defeq matters here</p>

<a name="192688860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192688860" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192688860">Mario Carneiro (Apr 02 2020 at 16:05)</a>:</h4>
<p>the function is supposed to definitionally unfold a certain way</p>

<a name="192688999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192688999" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192688999">Patrick Massot (Apr 02 2020 at 16:06)</a>:</h4>
<p>How does <code>abstract</code> help with that?</p>

<a name="192689030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192689030" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192689030">Mario Carneiro (Apr 02 2020 at 16:06)</a>:</h4>
<p>It creates a def for the call to the recursor</p>

<a name="192689075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192689075" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192689075">Mario Carneiro (Apr 02 2020 at 16:06)</a>:</h4>
<p>and then that def now satisfies the requisite defeq lemmas</p>

<a name="192689160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192689160" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192689160">Sebastien Gouezel (Apr 02 2020 at 16:07)</a>:</h4>
<p>Just for the record, I needed to construct a sequence in the middle of the proof of Baire theorem, with complicated assumptions for which it wouldn't make sense to pull them out of the proof, and I used <code>nat.rec_on</code> (see <a href="https://github.com/leanprover-community/mathlib/blob/a88356ff00b46ca1ea498c282e14c245e1424f79/src/topology/metric_space/baire.lean#L129" title="https://github.com/leanprover-community/mathlib/blob/a88356ff00b46ca1ea498c282e14c245e1424f79/src/topology/metric_space/baire.lean#L129">https://github.com/leanprover-community/mathlib/blob/a88356ff00b46ca1ea498c282e14c245e1424f79/src/topology/metric_space/baire.lean#L129</a>). It worked perfectly well, but if you see a better way to refactor it I am interested. I also used it to prove completeness of the set of compact subsets for the Hausdorff distance, see <a href="https://github.com/leanprover-community/mathlib/blob/a88356ff00b46ca1ea498c282e14c245e1424f79/src/topology/metric_space/closeds.lean#L126" title="https://github.com/leanprover-community/mathlib/blob/a88356ff00b46ca1ea498c282e14c245e1424f79/src/topology/metric_space/closeds.lean#L126">https://github.com/leanprover-community/mathlib/blob/a88356ff00b46ca1ea498c282e14c245e1424f79/src/topology/metric_space/closeds.lean#L126</a>. So, this comes up pretty often in analysis, and a nice tactic would definitely be useful.</p>

<a name="192689178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192689178" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192689178">Mario Carneiro (Apr 02 2020 at 16:07)</a>:</h4>
<p>I should mention that <code>abstract</code> is very rarely used and somewhat "raw". Some more work needs to go into it to make it more generally useful</p>

<a name="192689217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192689217" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192689217">Patrick Massot (Apr 02 2020 at 16:07)</a>:</h4>
<p>Mario, why can't you do that in a tactic if <code>abstract</code> can do it?</p>

<a name="192689239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192689239" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192689239">Mario Carneiro (Apr 02 2020 at 16:07)</a>:</h4>
<p>you can, work is needed</p>

<a name="192689336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192689336" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192689336">Mario Carneiro (Apr 02 2020 at 16:08)</a>:</h4>
<p>abstract is doing the equivalent of taking a term and copying it into a new def</p>

<a name="192689398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192689398" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192689398">Patrick Massot (Apr 02 2020 at 16:08)</a>:</h4>
<p>Is <code>abstract</code> written in Lean or C++?</p>

<a name="192689406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192689406" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192689406">Mario Carneiro (Apr 02 2020 at 16:09)</a>:</h4>
<p>the only smarts it has is identifying which variables from the current context need to be in the new def to make it typecheck</p>

<a name="192689435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192689435" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192689435">Mario Carneiro (Apr 02 2020 at 16:09)</a>:</h4>
<p>It's a relatively small lean wrapper around some C++</p>

<a name="192689583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192689583" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192689583">Patrick Massot (Apr 02 2020 at 16:10)</a>:</h4>
<p>So we need to change Lean, right?</p>

<a name="192689635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192689635" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192689635">Mario Carneiro (Apr 02 2020 at 16:10)</a>:</h4>
<p>actually, I stand corrected, almost all of the smarts is in lean</p>
<div class="codehilite"><pre><span></span><span class="n">meta</span> <span class="n">def</span> <span class="n">abstract</span> <span class="o">(</span><span class="n">tac</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span><span class="o">)</span> <span class="o">(</span><span class="n">suffix</span> <span class="o">:</span> <span class="n">option</span> <span class="n">name</span> <span class="o">:=</span> <span class="n">none</span><span class="o">)</span> <span class="o">(</span><span class="n">zeta_reduce</span> <span class="o">:=</span> <span class="n">tt</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">do</span> <span class="n">fail_if_no_goals</span><span class="o">,</span>
   <span class="n">gs</span> <span class="err">←</span> <span class="n">get_goals</span><span class="o">,</span>
   <span class="n">type</span> <span class="err">←</span> <span class="k">if</span> <span class="n">zeta_reduce</span> <span class="k">then</span> <span class="n">target</span> <span class="bp">&gt;&gt;=</span> <span class="n">zeta</span> <span class="k">else</span> <span class="n">target</span><span class="o">,</span>
   <span class="n">is_lemma</span> <span class="err">←</span> <span class="n">is_prop</span> <span class="n">type</span><span class="o">,</span>
   <span class="n">m</span> <span class="err">←</span> <span class="n">mk_meta_var</span> <span class="n">type</span><span class="o">,</span>
   <span class="n">set_goals</span> <span class="o">[</span><span class="n">m</span><span class="o">],</span>
   <span class="n">tac</span><span class="o">,</span>
   <span class="n">n</span> <span class="err">←</span> <span class="n">num_goals</span><span class="o">,</span>
   <span class="n">when</span> <span class="o">(</span><span class="n">n</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">fail</span> <span class="s2">&quot;abstract tactic failed, there are unsolved goals&quot;</span><span class="o">),</span>
   <span class="n">set_goals</span> <span class="n">gs</span><span class="o">,</span>
   <span class="n">val</span> <span class="err">←</span> <span class="n">instantiate_mvars</span> <span class="n">m</span><span class="o">,</span>
   <span class="n">val</span> <span class="err">←</span> <span class="k">if</span> <span class="n">zeta_reduce</span> <span class="k">then</span> <span class="n">zeta</span> <span class="n">val</span> <span class="k">else</span> <span class="n">return</span> <span class="n">val</span><span class="o">,</span>
   <span class="n">c</span>   <span class="err">←</span> <span class="n">mk_aux_decl_name</span> <span class="n">suffix</span><span class="o">,</span>
   <span class="n">e</span>   <span class="err">←</span> <span class="n">add_aux_decl</span> <span class="n">c</span> <span class="n">type</span> <span class="n">val</span> <span class="n">is_lemma</span><span class="o">,</span>
   <span class="n">exact</span> <span class="n">e</span>
</pre></div>

<a name="192689658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192689658" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192689658">Mario Carneiro (Apr 02 2020 at 16:10)</a>:</h4>
<p>the C++ core bit is <code>add_aux_decl</code> at the end</p>

<a name="192689807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192689807" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192689807">Patrick Massot (Apr 02 2020 at 16:11)</a>:</h4>
<p>Is there hope then?</p>

<a name="192689938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192689938" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192689938">Mario Carneiro (Apr 02 2020 at 16:12)</a>:</h4>
<p>This still isn't really what you are after since it does nothing to make writing recursive functions easy. It doesn't call the equation compiler, and it doesn't even generate a regular equation for the term which breaks <code>dsimp [foo._aux_1]</code></p>

<a name="192689979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192689979" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192689979">Mario Carneiro (Apr 02 2020 at 16:12)</a>:</h4>
<p>I think some of the new apis in community lean can help with this</p>

<a name="192690066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192690066" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192690066">Patrick Massot (Apr 02 2020 at 16:13)</a>:</h4>
<p>Ok, this definitely seems to be above my tactic writing skills. Let's say Sébastien, Bhavik and I would be very grateful if some expert could make this dream true.</p>

<a name="192690292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192690292" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192690292">Mario Carneiro (Apr 02 2020 at 16:15)</a>:</h4>
<p>I think the best option is to make option 1 have nicer syntax and skip the hackery, like so</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">ψ</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hψ</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">ψ</span> <span class="n">n</span> <span class="bp">≥</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">n</span> <span class="n">m</span><span class="o">,</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">m</span> <span class="bp">→</span> <span class="o">(</span><span class="n">ψ</span> <span class="err">∘</span> <span class="n">f</span><span class="o">)</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">ψ</span> <span class="err">∘</span> <span class="n">f</span><span class="o">)</span> <span class="n">m</span><span class="o">)</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="n">n</span> <span class="bp">≥</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">foo</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">ψ</span> <span class="o">(</span><span class="n">foo</span> <span class="n">n</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="k">in</span> <span class="k">begin</span>
  <span class="n">split</span><span class="bp">;</span> <span class="n">intros</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">induction</span> <span class="n">a</span><span class="bp">;</span> <span class="n">dsimp</span> <span class="o">[(</span><span class="err">∘</span><span class="o">),</span> <span class="n">foo</span><span class="o">],</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">hψ</span> <span class="bp">_</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">lt_trans</span> <span class="n">a_ih</span> <span class="o">(</span><span class="n">hψ</span> <span class="bp">_</span><span class="o">)</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">induction</span> <span class="n">n</span><span class="o">,</span> <span class="o">{</span><span class="n">apply</span> <span class="n">le_refl</span><span class="o">},</span>
    <span class="n">dsimp</span> <span class="o">[</span><span class="n">foo</span><span class="o">],</span>
    <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ_le_succ</span> <span class="o">(</span><span class="n">le_trans</span> <span class="n">n_ih</span> <span class="o">(</span><span class="n">hψ</span> <span class="bp">_</span><span class="o">))</span> <span class="o">}</span>
<span class="kn">end</span>
</pre></div>

<a name="192690589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192690589" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192690589">Patrick Massot (Apr 02 2020 at 16:17)</a>:</h4>
<p>No, this is still assuming you know everything needed upfront.</p>

<a name="192690616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192690616" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192690616">Mario Carneiro (Apr 02 2020 at 16:17)</a>:</h4>
<p>No, it can be in the middle of a proof too</p>

<a name="192690722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192690722" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192690722">Mario Carneiro (Apr 02 2020 at 16:18)</a>:</h4>
<p>It might be a bit messy to exit and re-enter tactic mode but I do this all the time when I want to use <code>match</code></p>

<a name="192690939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192690939" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192690939">Mario Carneiro (Apr 02 2020 at 16:19)</a>:</h4>
<p>Here's a horrible idea:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">ψ</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hψ</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">ψ</span> <span class="n">n</span> <span class="bp">≥</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">n</span> <span class="n">m</span><span class="o">,</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">m</span> <span class="bp">→</span> <span class="o">(</span><span class="n">ψ</span> <span class="err">∘</span> <span class="n">f</span><span class="o">)</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">ψ</span> <span class="err">∘</span> <span class="n">f</span><span class="o">)</span> <span class="n">m</span><span class="o">)</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="n">n</span> <span class="bp">≥</span> <span class="n">n</span> <span class="o">:=</span>
<span class="bp">⟨</span><span class="k">let</span> <span class="n">foo</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">ψ</span> <span class="o">(</span><span class="n">foo</span> <span class="n">n</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="kn">end</span><span class="o">,</span> <span class="k">begin</span>
  <span class="n">split</span><span class="bp">;</span> <span class="n">intros</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">induction</span> <span class="n">a</span><span class="bp">;</span> <span class="n">dsimp</span> <span class="o">[(</span><span class="err">∘</span><span class="o">),</span> <span class="n">foo</span><span class="o">],</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">hψ</span> <span class="bp">_</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">lt_trans</span> <span class="n">a_ih</span> <span class="o">(</span><span class="n">hψ</span> <span class="bp">_</span><span class="o">)</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">induction</span> <span class="n">n</span><span class="o">,</span> <span class="o">{</span><span class="n">apply</span> <span class="n">le_refl</span><span class="o">},</span>
    <span class="n">dsimp</span> <span class="o">[</span><span class="n">foo</span><span class="o">],</span>
    <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ_le_succ</span> <span class="o">(</span><span class="n">le_trans</span> <span class="n">n_ih</span> <span class="o">(</span><span class="n">hψ</span> <span class="bp">_</span><span class="o">))</span> <span class="o">}</span>
<span class="kn">end</span><span class="bp">⟩</span>
</pre></div>


<p>That <code>let foo ... end</code> is just a named <code>match</code></p>

<a name="192691164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192691164" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192691164">Mario Carneiro (Apr 02 2020 at 16:21)</a>:</h4>
<p>in the middle of a proof:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">ψ</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hψ</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">ψ</span> <span class="n">n</span> <span class="bp">≥</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">n</span> <span class="n">m</span><span class="o">,</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">m</span> <span class="bp">→</span> <span class="o">(</span><span class="n">ψ</span> <span class="err">∘</span> <span class="n">f</span><span class="o">)</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">ψ</span> <span class="err">∘</span> <span class="n">f</span><span class="o">)</span> <span class="n">m</span><span class="o">)</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="n">n</span> <span class="bp">≥</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">use</span> <span class="o">(</span><span class="k">let</span> <span class="n">foo</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
  <span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">0</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">ψ</span> <span class="o">(</span><span class="n">foo</span> <span class="n">n</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span>
  <span class="kn">end</span><span class="o">),</span>
  <span class="n">split</span><span class="bp">;</span> <span class="n">intros</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">induction</span> <span class="n">a</span><span class="bp">;</span> <span class="n">dsimp</span> <span class="o">[(</span><span class="err">∘</span><span class="o">),</span> <span class="n">foo</span><span class="o">],</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">hψ</span> <span class="bp">_</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">lt_trans</span> <span class="n">a_ih</span> <span class="o">(</span><span class="n">hψ</span> <span class="bp">_</span><span class="o">)</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">induction</span> <span class="n">n</span><span class="o">,</span> <span class="o">{</span><span class="n">apply</span> <span class="n">le_refl</span><span class="o">},</span>
    <span class="n">dsimp</span> <span class="o">[</span><span class="n">foo</span><span class="o">],</span>
    <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ_le_succ</span> <span class="o">(</span><span class="n">le_trans</span> <span class="n">n_ih</span> <span class="o">(</span><span class="n">hψ</span> <span class="bp">_</span><span class="o">))</span> <span class="o">}</span>
<span class="kn">end</span>
</pre></div>

<a name="192691429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192691429" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192691429">Mario Carneiro (Apr 02 2020 at 16:23)</a>:</h4>
<p>we could also steal Coq's notation and call it <code>fix</code> instead</p>

<a name="192691600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192691600" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192691600">Patrick Massot (Apr 02 2020 at 16:24)</a>:</h4>
<p>I swear I tried this <code>let</code> + <code>|</code> thing.</p>

<a name="192691623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192691623" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192691623">Mario Carneiro (Apr 02 2020 at 16:24)</a>:</h4>
<p>It doesn't work</p>

<a name="192691634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192691634" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192691634">Mario Carneiro (Apr 02 2020 at 16:24)</a>:</h4>
<p>it's  a proposed syntax</p>

<a name="192691654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192691654" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192691654">Mario Carneiro (Apr 02 2020 at 16:24)</a>:</h4>
<p>conveniently unused as of now</p>

<a name="192691656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192691656" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192691656">Patrick Massot (Apr 02 2020 at 16:24)</a>:</h4>
<p>Oh ok.</p>

<a name="192691754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192691754" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192691754">Mario Carneiro (Apr 02 2020 at 16:25)</a>:</h4>
<p>I'm more interested in whether this solves your problems</p>

<a name="192691925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192691925" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192691925">Patrick Massot (Apr 02 2020 at 16:26)</a>:</h4>
<p>But really this looks too much like programming. My dreamed tactic would open a goal for <code>foo 0</code>, a goal for <code>foo n+1</code>, just like induction does, and then give me all the required lemmas and definitional equalities.</p>

<a name="192691948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192691948" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192691948">Mario Carneiro (Apr 02 2020 at 16:26)</a>:</h4>
<p>You can do that today</p>

<a name="192691972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192691972" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192691972">Mario Carneiro (Apr 02 2020 at 16:26)</a>:</h4>
<p>just define a function by <code>induction</code></p>

<a name="192692123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192692123" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192692123">Mario Carneiro (Apr 02 2020 at 16:27)</a>:</h4>
<p>If you are defining a function and want all the lemmas to look nice, I think there is a decent argument that you should write the function in term mode like this, so that you actually have to write down what the lemmas look like</p>

<a name="192692268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192692268" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192692268">Mario Carneiro (Apr 02 2020 at 16:28)</a>:</h4>
<p>For example, did you know that</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">foo</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">#</span><span class="kn">print</span> <span class="kn">prefix</span> <span class="n">foo</span><span class="bp">.</span><span class="n">equations</span>
<span class="c1">-- foo.equations._eqn_1 : foo 0 = 0</span>
<span class="c1">-- foo.equations._eqn_2 : ∀ (n : ℕ), foo (n + 1) = 1</span>

<span class="n">def</span> <span class="n">foo&#39;</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">#</span><span class="kn">print</span> <span class="kn">prefix</span> <span class="n">foo</span><span class="bp">.</span><span class="n">equations</span>
<span class="c1">-- foo&#39;.equations._eqn_1 : foo&#39; 0 = 0</span>
<span class="c1">-- foo&#39;.equations._eqn_2 : ∀ (n : ℕ), foo&#39; (nat.succ n) = 1</span>
</pre></div>


<p>produce different equation lemmas?</p>

<a name="192692349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192692349" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192692349">Mario Carneiro (Apr 02 2020 at 16:29)</a>:</h4>
<p>the equation compiler uses the way you write the cases as a cue for how to state the lemmas</p>

<a name="192693143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192693143" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192693143">Mario Carneiro (Apr 02 2020 at 16:35)</a>:</h4>
<p>I'm struggling to figure out what the UI for an equation compiler tactic would be. I guess something like:</p>
<div class="codehilite"><pre><span></span><span class="n">equation_compile</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">{</span>
  <span class="o">{</span> <span class="c">/-</span><span class="cm"> P 0 -/</span> <span class="o">},</span>
  <span class="o">{</span> <span class="c">/-</span><span class="cm"> P (n+1) -/</span> <span class="o">}</span> <span class="o">},</span>
</pre></div>


<p>but all the pieces seem to be placed badly</p>

<a name="192693845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/192693845" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#192693845">Patrick Massot (Apr 02 2020 at 16:40)</a>:</h4>
<p>I'm not sure actually.</p>

<a name="193682245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/193682245" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#193682245">Patrick Massot (Apr 11 2020 at 22:11)</a>:</h4>
<p>I have a variation on this question that is also related to handling finite stuff. Here is my new challenge:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">γ</span><span class="o">]</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">γ</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">γ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">t</span><span class="o">,</span>  <span class="n">finite</span> <span class="n">t</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">c</span><span class="o">,</span> <span class="n">P</span> <span class="n">c</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">u</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">P</span> <span class="o">(</span><span class="n">u</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="err">&#39;&#39;</span> <span class="n">Iio</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>

<a name="193682328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/193682328" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#193682328">Patrick Massot (Apr 11 2020 at 22:14)</a>:</h4>
<p>The math proof is an obvious strong induction, apply assumption <code>h</code> to the part of the sequence that is already constructed.</p>

<a name="193702718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/193702718" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#193702718">Patrick Massot (Apr 12 2020 at 09:08)</a>:</h4>
<p>I should have posted that in the new members stream using a pseudonym <span aria-label="sad" class="emoji emoji-2639" role="img" title="sad">:sad:</span></p>

<a name="193703005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/193703005" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#193703005">Mario Carneiro (Apr 12 2020 at 09:16)</a>:</h4>
<p>MWE?</p>

<a name="193703026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/193703026" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#193703026">Mario Carneiro (Apr 12 2020 at 09:17)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">intervals</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">finite</span>
<span class="kn">open</span> <span class="n">set</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">γ</span><span class="o">]</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">γ</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">γ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">t</span><span class="o">,</span>  <span class="n">finite</span> <span class="n">t</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">c</span><span class="o">,</span> <span class="n">P</span> <span class="n">c</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">u</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">P</span> <span class="o">(</span><span class="n">u</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="err">&#39;&#39;</span> <span class="n">Iio</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>

<a name="193703821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/193703821" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#193703821">Kenny Lau (Apr 12 2020 at 09:42)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">intervals</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">finite</span> <span class="n">data</span><span class="bp">.</span><span class="n">nat</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">open</span> <span class="n">set</span>

<span class="kn">instance</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">Iio</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">fintype</span><span class="bp">.</span><span class="n">of_finset</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">range</span> <span class="n">n</span><span class="o">)</span> <span class="err">$</span> <span class="k">by</span> <span class="n">simp</span>

<span class="kn">theorem</span> <span class="n">nat</span><span class="bp">.</span><span class="n">strong_rec_on_beta</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">ih</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">strong_rec_on</span> <span class="n">n</span> <span class="n">ih</span> <span class="o">:</span> <span class="n">P</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">ih</span> <span class="n">n</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">m</span> <span class="n">hmn</span><span class="o">,</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">strong_rec_on</span> <span class="n">m</span> <span class="n">ih</span> <span class="o">:</span> <span class="n">P</span> <span class="n">m</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">sorry</span> <span class="c1">-- I give up</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">γ</span><span class="o">]</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">γ</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">γ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">t</span><span class="o">,</span>  <span class="n">finite</span> <span class="n">t</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">c</span><span class="o">,</span> <span class="n">P</span> <span class="n">c</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">u</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">P</span> <span class="o">(</span><span class="n">u</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="err">&#39;&#39;</span> <span class="n">Iio</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">n</span><span class="o">,</span> <span class="bp">@</span><span class="n">nat</span><span class="bp">.</span><span class="n">strong_rec_on</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">γ</span><span class="o">)</span> <span class="n">n</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">n</span> <span class="n">ih</span><span class="o">,</span> <span class="n">classical</span><span class="bp">.</span><span class="n">some</span> <span class="err">$</span> <span class="n">h</span>
    <span class="o">(</span><span class="n">range</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">m</span> <span class="o">:</span> <span class="n">Iio</span> <span class="n">n</span><span class="o">,</span> <span class="n">ih</span> <span class="n">m</span><span class="bp">.</span><span class="mi">1</span> <span class="n">m</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span>
    <span class="o">(</span><span class="n">finite_range</span> <span class="bp">_</span><span class="o">),</span>
<span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="k">begin</span>
  <span class="n">refine</span> <span class="n">nat</span><span class="bp">.</span><span class="n">strong_induction_on</span> <span class="n">n</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="n">ih</span><span class="o">,</span> <span class="bp">_</span><span class="o">),</span>
  <span class="n">rw</span> <span class="n">nat</span><span class="bp">.</span><span class="n">strong_rec_on_beta</span><span class="o">,</span> <span class="n">convert</span> <span class="n">classical</span><span class="bp">.</span><span class="n">some_spec</span> <span class="o">(</span><span class="n">h</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">),</span>
  <span class="n">ext</span> <span class="n">x</span><span class="o">,</span> <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintros</span> <span class="bp">⟨</span><span class="n">m</span><span class="o">,</span> <span class="n">hmn</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">exact</span> <span class="bp">⟨⟨</span><span class="n">m</span><span class="o">,</span> <span class="n">hmn</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintros</span> <span class="bp">⟨⟨</span><span class="n">m</span><span class="o">,</span> <span class="n">hmn</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">exact</span> <span class="bp">⟨</span><span class="n">m</span><span class="o">,</span> <span class="n">hmn</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span> <span class="o">}</span>
<span class="kn">end</span><span class="bp">⟩</span>
</pre></div>

<a name="193709288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bolzano-Weirstrass/near/193709288" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/217875IstherecodeforX/62970BolzanoWeirstrass.html#193709288">Kevin Buzzard (Apr 12 2020 at 11:33)</a>:</h4>
<p><a href="#narrow/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta/near/193709204" title="#narrow/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta/near/193709204">Sorry filled in here</a></p>


{% endraw %}

{% include archive_update.html %}