---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/116395maths/02913yoneda.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html">yoneda</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="136033284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136033284" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136033284">Johan Commelin (Oct 18 2018 at 10:41)</a>:</h4>
<p><span class="user-mention" data-user-id="110524">@Scott Morrison</span> Is there a reason why <code>yoneda</code> takes the category as explicit argument? Now we have to write <code>yoneda C X</code> instead of just <code>yoneda X</code>.</p>

<a name="136047539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136047539" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136047539">Scott Morrison (Oct 18 2018 at 14:38)</a>:</h4>
<p>Try it: you still wouldn't be able to write <code>yoneda X</code>. The problem is that <code>yoneda C X</code> has a coercion, converting it to <code>(yoneda C).obj X</code>, and the coercion mechanism isn't clever enough to handle <code>yoneda X</code> by filling in <code>C</code> as an implicit argument before using the coercion.</p>

<a name="136047790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136047790" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136047790">Reid Barton (Oct 18 2018 at 14:41)</a>:</h4>
<p>I guess <code>yoneda.obj X</code> would work then, if the category argument was implicit?</p>

<a name="136047957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136047957" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136047957">Reid Barton (Oct 18 2018 at 14:44)</a>:</h4>
<p>This coercion stuff has turned out to be a lot more frustrating than expected--it's lovely when it works but Lean's reluctance to use coercions in the presence of metavariables means that they're often a lot more awkward than just writing <code>F.obj X</code>, but then you have the burden of supporting both <code>F X</code> and <code>F.obj X</code> which are different expressions.</p>

<a name="136047972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136047972" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136047972">Johan Commelin (Oct 18 2018 at 14:44)</a>:</h4>
<p><em>"and the coercion mechanism isn't clever enough"</em> <span class="emoji emoji-2639" title="sad">:sad:</span></p>

<a name="136047999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136047999" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136047999">Johan Commelin (Oct 18 2018 at 14:45)</a>:</h4>
<p>I guess this is why Scott didn't use any coercions a couple of months ago...</p>

<a name="136048072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136048072" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136048072">Reid Barton (Oct 18 2018 at 14:46)</a>:</h4>
<p>If <code>F X</code> and <code>F.obj X</code> were the same expression, one could forgive the elaborator for being picky about where it is willing to insert a coercion</p>

<a name="136048215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136048215" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136048215">Reid Barton (Oct 18 2018 at 14:48)</a>:</h4>
<p>I think this thing with <code>yoneda C</code> is the same issue I ran into whenever I had to deal with cylinders in my homotopy theory library. There I had a functor <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mo>:</mo><mi>C</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">I : C \to C</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07847em;">I</span><span class="mrel">:</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.07153em;">C</span></span></span></span> which was attached to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07153em;">C</span></span></span></span> by a type class, but I think that detail doesn't matter.</p>

<a name="136048220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136048220" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136048220">Johan Commelin (Oct 18 2018 at 14:48)</a>:</h4>
<p>Could we choose a fancy bracket that looks like <code>(</code> and <code>)</code>, and turn that into notation for <code>has_apply</code>?</p>

<a name="136048261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136048261" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136048261">Reid Barton (Oct 18 2018 at 14:49)</a>:</h4>
<p>And then I also had natural transformations <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>i</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">i_0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.65952em;"></span><span class="strut bottom" style="height:0.80952em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>i</mi><mn>1</mn></msub><mo>:</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><mo>→</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">i_1 : \mathrm{id} \to I</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mrel">:</span><span class="mord"><span class="mord mathrm">i</span><span class="mord mathrm">d</span></span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.07847em;">I</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>:</mo><mi>I</mi><mo>→</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow></mrow><annotation encoding="application/x-tex">p : I \to \mathrm{id}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit">p</span><span class="mrel">:</span><span class="mord mathit" style="margin-right:0.07847em;">I</span><span class="mrel">→</span><span class="mord"><span class="mord mathrm">i</span><span class="mord mathrm">d</span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mo>:</mo><mi>I</mi><mo>→</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">v : I \to I</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="mrel">:</span><span class="mord mathit" style="margin-right:0.07847em;">I</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.07847em;">I</span></span></span></span>, all of which had the same issue...</p>

<a name="136048366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136048366" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136048366">Johan Commelin (Oct 18 2018 at 14:50)</a>:</h4>
<p>I think wouldn't mind write <code>F(X)</code> with some fancy <code>()</code>. But maybe this is abusing notation and type classes too much.</p>

<a name="136048387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136048387" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136048387">Johan Commelin (Oct 18 2018 at 14:50)</a>:</h4>
<p>I think this could then replace <code>coe_to_fun</code>.</p>

<a name="136048509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136048509" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136048509">Reid Barton (Oct 18 2018 at 14:52)</a>:</h4>
<p>It's not clear to me that we would not just end up back in the same situation</p>

<a name="136048567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136048567" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136048567">Reid Barton (Oct 18 2018 at 14:53)</a>:</h4>
<p>We would still have two things, <code>F.obj X</code> and <code>apply F X</code>. I guess the question is whether we could avoid ever having to write <code>F.obj X</code>. But it would be so much simpler if there was just one thing in the first place.</p>

<a name="136048684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136048684" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136048684">Johan Commelin (Oct 18 2018 at 14:55)</a>:</h4>
<p><code>apply F X</code> would be <code>F.obj X</code> by definition.</p>

<a name="136048696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136048696" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136048696">Reid Barton (Oct 18 2018 at 14:55)</a>:</h4>
<p>It's possible if I had built my homotopy theory library on top of a category theory version with coercions from the start, I could have found a more convenient way to set things up</p>

<a name="136048781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136048781" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136048781">Reid Barton (Oct 18 2018 at 14:56)</a>:</h4>
<p>But "by definition" is not good enough for <code>simp</code>, <code>rw</code> etc.</p>

<a name="136048801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136048801" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136048801">Reid Barton (Oct 18 2018 at 14:56)</a>:</h4>
<p>I had a hard time porting a lot of proofs over the transition to use coercions in category theory</p>

<a name="136048815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136048815" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136048815">Reid Barton (Oct 18 2018 at 14:56)</a>:</h4>
<p>because I had to be careful about the difference between <code>F X</code> and <code>F.obj X</code></p>

<a name="136048831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136048831" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136048831">Reid Barton (Oct 18 2018 at 14:57)</a>:</h4>
<p>If I could actually write <code>F X</code> consistently then that might be okay, but I couldn't because of the issues with coercions and metavariables</p>

<a name="136048875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136048875" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136048875">Reid Barton (Oct 18 2018 at 14:58)</a>:</h4>
<p>In the end I think I wrote some explicit type ascriptions in the statements of the simp lemmas I had defined, so that they could work on the <code>F X</code> version</p>

<a name="136048943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136048943" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136048943">Scott Morrison (Oct 18 2018 at 14:58)</a>:</h4>
<p>If we can agree that the coercion mechanism is broken, I would very happily rip them back out of the <code>category_theory/</code>.</p>

<a name="136048952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136048952" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136048952">Reid Barton (Oct 18 2018 at 14:59)</a>:</h4>
<p>For example <a href="https://github.com/rwbarton/lean-homotopy-theory/commit/e98dd6f51cd46653bf30c610e60573318443466c#diff-6931c0d6d9d8dda133a6b3ed34b290d5L548" target="_blank" title="https://github.com/rwbarton/lean-homotopy-theory/commit/e98dd6f51cd46653bf30c610e60573318443466c#diff-6931c0d6d9d8dda133a6b3ed34b290d5L548">https://github.com/rwbarton/lean-homotopy-theory/commit/e98dd6f51cd46653bf30c610e60573318443466c#diff-6931c0d6d9d8dda133a6b3ed34b290d5L548</a></p>

<a name="136048993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136048993" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136048993">Scott Morrison (Oct 18 2018 at 14:59)</a>:</h4>
<p>The saving of not having to write <code>.obj</code> most of the time is far outweighed by the confusion of sometimes mysteriously having to do so.</p>

<a name="136049015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136049015" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136049015">Reid Barton (Oct 18 2018 at 14:59)</a>:</h4>
<p><a href="https://github.com/rwbarton/lean-homotopy-theory/commit/e98dd6f51cd46653bf30c610e60573318443466c#diff-f49cdebfeaf5ac27e5bea99a12ad4ca9L129" target="_blank" title="https://github.com/rwbarton/lean-homotopy-theory/commit/e98dd6f51cd46653bf30c610e60573318443466c#diff-f49cdebfeaf5ac27e5bea99a12ad4ca9L129">https://github.com/rwbarton/lean-homotopy-theory/commit/e98dd6f51cd46653bf30c610e60573318443466c#diff-f49cdebfeaf5ac27e5bea99a12ad4ca9L129</a> -- sometimes I needed to help Lean out with the types and other times I didn't; it was hard to predict</p>

<a name="136049175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136049175" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136049175">Scott Morrison (Oct 18 2018 at 15:01)</a>:</h4>
<p>There's also the issue of why <code>category_theory/</code> requires so much use of <code>erw</code> rather than <code>rw</code>. This stinks, and I don't have a clear idea of why it happens, but fear that coercions are sometimes to blame.</p>

<a name="136049245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136049245" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136049245">Reid Barton (Oct 18 2018 at 15:02)</a>:</h4>
<p>I changed a bunch of <code>rw</code> to <code>erw</code> in that commit too, precisely because of the coercion thing. But there are some other situations where you need <code>erw</code> as well.</p>

<a name="136049299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136049299" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136049299">Scott Morrison (Oct 18 2018 at 15:03)</a>:</h4>
<p>Do you think you can explain any of the others? I unfortunately just try <code>erw</code> and get on with it, and haven't invested the time in seeing what was going wrong.</p>

<a name="136049412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136049412" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136049412">Reid Barton (Oct 18 2018 at 15:05)</a>:</h4>
<p>I suspect that most of my cases are because I still use the explicit version (<code>nat_trans.app</code> in this case) in my definitions: <a href="https://github.com/rwbarton/lean-homotopy-theory/blob/lean-3.4.1/src/homotopy_theory/formal/cylinder/homotopy.lean#L17" target="_blank" title="https://github.com/rwbarton/lean-homotopy-theory/blob/lean-3.4.1/src/homotopy_theory/formal/cylinder/homotopy.lean#L17">https://github.com/rwbarton/lean-homotopy-theory/blob/lean-3.4.1/src/homotopy_theory/formal/cylinder/homotopy.lean#L17</a><br>
and I frequently want to rewrite using the conditions Hi\0, Hi\1</p>

<a name="136049503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136049503" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136049503">Reid Barton (Oct 18 2018 at 15:06)</a>:</h4>
<p>It was quite unclear to me at first whether the easiest way forward was to use coercions everywhere or to use coercions nowhere or something in between</p>

<a name="136049546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136049546" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136049546">Reid Barton (Oct 18 2018 at 15:07)</a>:</h4>
<p>Oh you mean the other situations, not related to coercions.</p>

<a name="136049640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136049640" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136049640">Reid Barton (Oct 18 2018 at 15:08)</a>:</h4>
<p>I think for me they come from things like: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>i</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">i_0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.65952em;"></span><span class="strut bottom" style="height:0.80952em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> is a natural transformation <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><mo>→</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">\mathrm{id} \to I</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathrm">i</span><span class="mord mathrm">d</span></span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.07847em;">I</span></span></span></span>. So the naturality law for <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>i</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">i_0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.65952em;"></span><span class="strut bottom" style="height:0.80952em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> contains stuff like <code>(functor.id C) X</code> in the types and I need it to be <code>X</code> to continue with a subsequent rewrite, and that's why I need <code>erw</code>.</p>

<a name="136049645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136049645" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136049645">Reid Barton (Oct 18 2018 at 15:08)</a>:</h4>
<p>I don't remember more details off-hand, sorry</p>

<a name="136049665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136049665" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136049665">Reid Barton (Oct 18 2018 at 15:09)</a>:</h4>
<p>But I know that at least some cases had to do with this specific issue of applying the identity functor</p>

<a name="136049757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136049757" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136049757">Reid Barton (Oct 18 2018 at 15:10)</a>:</h4>
<p>Like I might want to rewrite using associativity where I have three maps <code>A -&gt; B</code>, <code>B -&gt; X</code>, <code>(functor.id C) X -&gt; (functor.id C) Y</code></p>

<a name="136049770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136049770" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136049770">Reid Barton (Oct 18 2018 at 15:10)</a>:</h4>
<p>and then <code>rw</code> says "nope"</p>

<a name="136049818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136049818" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136049818">Reid Barton (Oct 18 2018 at 15:12)</a>:</h4>
<p>I guess my suggestion might be to rip out coercions for now and then suggest as a wishlist item for <span class="emoji emoji-1f340" title="four leaf clover">:four_leaf_clover:</span> to replace <code>has_coe_to_fun</code> by what I was calling in Orsay "type-indexed notation"</p>

<a name="136049869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136049869" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136049869">Mario Carneiro (Oct 18 2018 at 15:12)</a>:</h4>
<p>what is that?</p>

<a name="136049899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136049899" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136049899">Reid Barton (Oct 18 2018 at 15:13)</a>:</h4>
<p>The idea is if <code>F X</code> was actually <strong>notation</strong> for <code>F.obj X</code> then coercion and non-coercion syntax could all live happily forever.</p>

<a name="136049909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136049909" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136049909">Reid Barton (Oct 18 2018 at 15:13)</a>:</h4>
<p>Currently, when Lean tries to elaborate <code>F X</code> it sees that the type of <code>F</code> is not a Pi type and then it maybe inserts a coercion</p>

<a name="136049921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136049921" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136049921">Reid Barton (Oct 18 2018 at 15:13)</a>:</h4>
<p>So I presume this involves reducing the type of <code>F</code> to WHNF at least?</p>

<a name="136049969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136049969" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136049969">Reid Barton (Oct 18 2018 at 15:14)</a>:</h4>
<p>Then the idea is, allow the user to specify another interpretation of <code>F X</code> as <em>notation</em> which depends on the head of the type of <code>F</code>, or something like that.</p>

<a name="136050000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136050000" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136050000">Reid Barton (Oct 18 2018 at 15:15)</a>:</h4>
<p>rather than the rule being "if the type of <code>F</code> is a Pi type then produce an application <code>F X</code>, otherwise produce <code>coe_fun_t F X</code>" or whatever it is today</p>

<a name="136050010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136050010" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136050010">Reid Barton (Oct 18 2018 at 15:15)</a>:</h4>
<p>give the user the chance to add additional rules "if the type of <code>F</code> looks like [...], then produce [...]"</p>

<a name="136050092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136050092" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136050092">Reid Barton (Oct 18 2018 at 15:16)</a>:</h4>
<p>In this case, <code>functor.obj F X</code></p>

<a name="136050430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136050430" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136050430">Reid Barton (Oct 18 2018 at 15:22)</a>:</h4>
<p>By the way, the <code>equiv</code> coercion to fun is another one which has given me a lot of problems, which again is annoying because there are simp rules written in terms of the coercion like <code>e.symm (e x) = x</code></p>

<a name="136050577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136050577" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136050577">Reid Barton (Oct 18 2018 at 15:25)</a>:</h4>
<p>I guess the usability of these coercions depends upon the usage patterns. Once the <code>equiv</code>s you are working with are not ones which were passed as arguments to your lemma, but things like the equivalence Hom(FX, Y) = Hom(X, GY) induced by an adjunction, then I guess more of these metavariables crop up</p>

<a name="136050684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136050684" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136050684">Mario Carneiro (Oct 18 2018 at 15:27)</a>:</h4>
<p>I think this can be solved by a simp lemma like <code>e.to_fun = \u e</code> and <code>e.inv_fun = \u e.symm</code></p>

<a name="136050894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136050894" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136050894">Reid Barton (Oct 18 2018 at 15:30)</a>:</h4>
<p>Yes, probably; then the next problem is that I might want to define my own simp lemmas whose statements involve applying equivs as functions</p>

<a name="136050915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136050915" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136050915">Reid Barton (Oct 18 2018 at 15:30)</a>:</h4>
<p>and then I don't know how to write the statement of the lemma in simp normal form except by writing some bulky type ascriptions</p>

<a name="136050937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136050937" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136050937">Mario Carneiro (Oct 18 2018 at 15:31)</a>:</h4>
<p>I have found that coercions between different function(like) types is a bad idea for this reason</p>

<a name="136051838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136051838" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136051838">Reid Barton (Oct 18 2018 at 15:47)</a>:</h4>
<p>By the way, when bumping dependencies of your project across a substantial change, I can highly recommend having a separate checkout of the project built against the old version of the deps so that you can figure out how the heck any of your proofs used to work <span class="emoji emoji-263a" title="smile">:smile:</span></p>

<a name="136052379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136052379" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136052379">Mario Carneiro (Oct 18 2018 at 15:57)</a>:</h4>
<p>ah, that brings me back to metamath days</p>

<a name="136105758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136105758" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136105758">Johan Commelin (Oct 19 2018 at 11:41)</a>:</h4>
<p>On the topic of coercions in category theory: would it make sense to use coercions to turn specialised shapes (like <code>fork</code> and <code>square</code> and <code>fan</code>) into the general shape <code>cone</code>? Of course we should also prove that have limits means having equalizers, pullbacks, products, etc... Then we might be able to prove a lot of stuff about general limits and use those results on specialised shapes. Or is this wishful thinking?</p>

<a name="136106147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136106147" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136106147">Johan Commelin (Oct 19 2018 at 11:49)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> I really like your idea about type indexed notation! Because then we could also have very clean notation for applying a functor to a morphism.</p>

<a name="136108963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136108963" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136108963">Reid Barton (Oct 19 2018 at 12:53)</a>:</h4>
<p>Yes, I was just thinking of that as well--it would be nice to have both <code>F X</code> for <code>F.obj X</code> and <code>F f</code> for <code>F.map f</code>. I'm not sure that comes for free with the exact setup I had in mind, where the interpretation of juxtaposition depends only on the type of <code>F</code>, but maybe some slightly different design could handle it.</p>

<a name="136109281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136109281" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136109281">Reid Barton (Oct 19 2018 at 12:59)</a>:</h4>
<p>I think we may indeed want to arrange things so that equalizers and so on are actually defined as special cases of limits, and then wrap that in a nicer interface (which doesn't involve manually constructing a diagram/functor). The body of facts we have about limits is just going to keep increasing, and duplicating the results for each special shape of limit doesn't make sense.</p>

<a name="136110360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136110360" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136110360">Johan Commelin (Oct 19 2018 at 13:18)</a>:</h4>
<p>You say "actually defined as". Do you mean defeq? I was suggesting a coercion. But maybe that is not good enough.</p>

<a name="136110402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136110402" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136110402">Johan Commelin (Oct 19 2018 at 13:19)</a>:</h4>
<p>I do think that these are issues that should be sorted out soon. Because otherwise the refactoring will become a big pain if there is already too much code depending on the current setup.</p>

<a name="136112654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136112654" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136112654">Johan Commelin (Oct 19 2018 at 13:52)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> I suppose the parser could also look at the "token" just following <code>F</code> to see whether it is an object or a hom. (And I assume the parser is smart enough to guess the right "token".)</p>

<a name="136112698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136112698" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136112698">Reid Barton (Oct 19 2018 at 13:53)</a>:</h4>
<p>I meant defeq but I haven't thought that much about what exact condition we would want.<br>
Here is an example statement: if I have a limit cone in a diagram category then evaluation on any object yields a limit cone. Now we want the same statement for equalizers. If equalizers are defeq to a special case of limits, then we just apply the original statement. If equalizers are only <code>equiv</code> to a special shape of limit, then we need to transport across the equiv on both sides.</p>

<a name="136112828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136112828" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136112828">Johan Commelin (Oct 19 2018 at 13:54)</a>:</h4>
<p>So all the current machinery should be replaced by constructors yielding a nice API?</p>

<a name="136112977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136112977" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136112977">Johan Commelin (Oct 19 2018 at 13:56)</a>:</h4>
<p>It's really weird that these definitions are so non-trivial. Why are we so good at unifying concepts, and why can't we teach that trick to a computer?</p>

<a name="136120823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136120823" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136120823">Scott Morrison (Oct 19 2018 at 16:01)</a>:</h4>
<p>I’d love to be able to do something like this, but at the moment I really don’t see a good option. We can work on constructing diagrams (with some help from tactics) more easily. As an example, if <code>X Y : C</code>, and <code>f g : X \hom Y</code>, there’s no reason why <code>construct_diagram [f,g]</code> couldn’t return a <code>\Sigma (J : Type) [category J], J \func C</code>, automatically deciding the index category J should be the walking parallel pair.</p>

<a name="136120919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136120919" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136120919">Scott Morrison (Oct 19 2018 at 16:02)</a>:</h4>
<p>If this becomes easy enough, it becomes plausible to start defining “special” limits in terms of general ones. But without a huge improvement in this direction, it’s way too painful to expect a user to talk about equalizers as (defeq) special cases of limits. Just see the hoops I had to jump through to prove that having limits implies having equalizers...</p>

<a name="136121056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136121056" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136121056">Scott Morrison (Oct 19 2018 at 16:05)</a>:</h4>
<p>Also, <span class="user-mention" data-user-id="112680">@Johan Commelin</span>, I’m not sure if you saw it already, but there’s a second pull request (from the <code>limits-constructions</code> branch) that constructs products and equalizers from limits, etc.</p>

<a name="136121069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136121069" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136121069">Johan Commelin (Oct 19 2018 at 16:05)</a>:</h4>
<p>I haven't yet looked in detail.</p>

<a name="136121484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136121484" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136121484">Johan Commelin (Oct 19 2018 at 16:12)</a>:</h4>
<p>I really hope that I will be able to write down a definition of <code>sieve</code> without <code>@</code>s. I must say that my experience with your library has been very positive. Writing things down is really pain-free and automation takes care of a lot of troubles.<br>
Do you have a general guideline for when to add an auto_param in a definition?</p>

<a name="136122297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136122297" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136122297">Reid Barton (Oct 19 2018 at 16:25)</a>:</h4>
<p>Couldn't we have a function <code>construct_equalizer_diagram {a b} (f g : a \hom b) : walking_fork \func C</code>, and then define <code>equalizer f g := limit (construct_equalizer_diagram f g)</code>?</p>

<a name="136126239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136126239" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136126239">Johan Commelin (Oct 19 2018 at 17:24)</a>:</h4>
<p>I like this idea. <span class="user-mention" data-user-id="110087">@Scott Morrison</span> , did you try something like this before you settled on the current approach? Do you see problems with it?</p>

<a name="136126789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136126789" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136126789">Reid Barton (Oct 19 2018 at 17:35)</a>:</h4>
<blockquote>
<p>But without a huge improvement in this direction, it’s way too painful to expect a user to talk about equalizers as (defeq) special cases of limits. Just see the hoops I had to jump through to prove that having limits implies having equalizers...</p>
</blockquote>
<p>I agree that it is more work starting from scratch to set up the basic definitions of things like equalizers as special cases of limits, but now that <em>you</em> have already jumped through those particular hoops, why would a user also need to?</p>

<a name="136127042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136127042" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136127042">Scott Morrison (Oct 19 2018 at 17:40)</a>:</h4>
<p>I guess the problem with <code>equalizer f g := limit (construct_equalizer_diagram f g)</code> is that then the user of equalizers has to know the names of the objects and morphisms in the <code>walking_fork</code>. (Separately, I think <code>walking_fork</code> is the wrong name here; the "handle" of the fork is missing at this point.)</p>

<a name="136127048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136127048" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136127048">Scott Morrison (Oct 19 2018 at 17:40)</a>:</h4>
<p>Maybe this is a small cost.</p>

<a name="136127083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136127083" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136127083">Scott Morrison (Oct 19 2018 at 17:41)</a>:</h4>
<p>What should the objects and morphisms be?</p>

<a name="136127202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136127202" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136127202">Scott Morrison (Oct 19 2018 at 17:43)</a>:</h4>
<p>I guess I'm really not seeing where there would be a simplification of the code, however.</p>

<a name="136127279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136127279" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136127279">Johan Commelin (Oct 19 2018 at 17:44)</a>:</h4>
<p>The simplification would come later, right? For example you have a massive file about deriving products and equalizers from limits. That would simplify.</p>

<a name="136127290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136127290" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136127290">Johan Commelin (Oct 19 2018 at 17:44)</a>:</h4>
<p>And functors preserving limits and such.</p>

<a name="136127302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136127302" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136127302">Scott Morrison (Oct 19 2018 at 17:44)</a>:</h4>
<p>Still for any theorem about limits, you need to restate a special version of it for equalizers/products/etc. None of these things require humans to write the proofs at this point.</p>

<a name="136127348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136127348" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136127348">Johan Commelin (Oct 19 2018 at 17:45)</a>:</h4>
<p>Sorry, maybe I'm dense, but what exactly do you mean?</p>

<a name="136127349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136127349" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136127349">Scott Morrison (Oct 19 2018 at 17:45)</a>:</h4>
<p>Okay, I agree the files that construct equalizers, products, etc from limits would essentially disappear.</p>

<a name="136127444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136127444" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136127444">Scott Morrison (Oct 19 2018 at 17:46)</a>:</h4>
<p>Let's think about the construction <br>
<code>def pi.post (f : β → C) (G : C ⥤ D) : G (limits.pi f) ⟶ (limits.pi (G.obj ∘ f)) := ...</code></p>

<a name="136127488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136127488" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136127488">Reid Barton (Oct 19 2018 at 17:47)</a>:</h4>
<p><code>pi</code> = product of an arbitrary family?</p>

<a name="136127490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136127490" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136127490">Scott Morrison (Oct 19 2018 at 17:47)</a>:</h4>
<p>if <code>limits.pi f</code> is defined as <code>limit (functor.of_function f)</code></p>

<a name="136127493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136127493" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136127493">Scott Morrison (Oct 19 2018 at 17:47)</a>:</h4>
<p>Yes.</p>

<a name="136127589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136127589" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136127589">Scott Morrison (Oct 19 2018 at 17:49)</a>:</h4>
<p>hmm... okay, maybe you guys are right here. :-)</p>

<a name="136127591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136127591" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136127591">Johan Commelin (Oct 19 2018 at 17:49)</a>:</h4>
<p>Wouldn't you just prove this by <code>limit.post</code>...?</p>

<a name="136127656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136127656" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136127656">Johan Commelin (Oct 19 2018 at 17:50)</a>:</h4>
<p>Oohh, I really don't know. You guys have written orders of magnitude more code then I have. I'm just a user...</p>

<a name="136127698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136127698" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136127698">Scott Morrison (Oct 19 2018 at 17:50)</a>:</h4>
<p>So... for now I agree that this is worth exploring.</p>

<a name="136127744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136127744" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136127744">Scott Morrison (Oct 19 2018 at 17:51)</a>:</h4>
<p>However, I'm hoping to pause for a while on Lean, in not too long, as I have a lot of maths I want to work on.</p>

<a name="136127754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136127754" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136127754">Scott Morrison (Oct 19 2018 at 17:51)</a>:</h4>
<p>So I'm not sure what to do with this PR in the meantime.</p>

<a name="136127755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136127755" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136127755">Scott Morrison (Oct 19 2018 at 17:51)</a>:</h4>
<p>Options:</p>

<a name="136127764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136127764" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136127764">Scott Morrison (Oct 19 2018 at 17:51)</a>:</h4>
<p>1. leave it open for others to modify</p>

<a name="136127801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136127801" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136127801">Scott Morrison (Oct 19 2018 at 17:52)</a>:</h4>
<p>2. close it for now</p>

<a name="136127811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136127811" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136127811">Reid Barton (Oct 19 2018 at 17:52)</a>:</h4>
<p>I'm not sure exactly where that "..." was going, but another example to keep in mind is "if D is a complete category then a cone in D^J is a limit cone iff each the value at each j in J is a limit cone"</p>

<a name="136127820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136127820" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136127820">Scott Morrison (Oct 19 2018 at 17:52)</a>:</h4>
<p>3. strip it down to just limits, not the special cases, and leave those for later</p>

<a name="136127834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136127834" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136127834">Reid Barton (Oct 19 2018 at 17:52)</a>:</h4>
<p>I have been meaning to suggest that 3 is a good idea anyways</p>

<a name="136127923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136127923" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136127923">Reid Barton (Oct 19 2018 at 17:54)</a>:</h4>
<p>Because the PR involves a lot of relatively untested design, and I think it's worth it to go and try to prove loads of things about general limits to "kick the tires" and make sure we settle on a design that we want</p>

<a name="136127930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136127930" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136127930">Scott Morrison (Oct 19 2018 at 17:54)</a>:</h4>
<p>Okay. I will strip it down. Maybe someone else can explore if the special cases defined as suggested above are usable.</p>

<a name="136128038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136128038" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136128038">Johan Commelin (Oct 19 2018 at 17:56)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> How hard would it be to test that on your homotopy lib?</p>

<a name="136128100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136128100" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136128100">Johan Commelin (Oct 19 2018 at 17:57)</a>:</h4>
<p>Or should we try this on a fork of Scott's lib?</p>

<a name="136129012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136129012" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136129012">Reid Barton (Oct 19 2018 at 18:09)</a>:</h4>
<p>Probably not that easy since I have some setup of my own to prove a bunch of lemmas about pushouts. Though maybe I could sorry all those proofs and just see how usable it is in the actual homotopy theory part.</p>

<a name="136129599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136129599" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136129599">Johan Commelin (Oct 19 2018 at 18:18)</a>:</h4>
<p>Yeah, I meant that you just create a branch, and maybe break a couple files, but test this idea on the other files.</p>

<a name="136129608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136129608" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136129608">Johan Commelin (Oct 19 2018 at 18:19)</a>:</h4>
<p>I'm not suggesting you uproot your <code>master</code> branch (-;</p>

<a name="136142166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136142166" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136142166">Scott Morrison (Oct 19 2018 at 22:06)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span>, do you have  ideas about how to define all the "walking" categories for limits of special shapes?</p>

<a name="136142173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136142173" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136142173">Scott Morrison (Oct 19 2018 at 22:06)</a>:</h4>
<p>I have reduced my PR to just the plain limits.</p>

<a name="136146298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136146298" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136146298">David Michael Roberts (Oct 19 2018 at 23:59)</a>:</h4>
<p>Just as we have finite sets, why not have a collection of finite categories of the usual special shapes?</p>

<a name="136146369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136146369" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136146369">Scott Morrison (Oct 20 2018 at 00:01)</a>:</h4>
<p>Yes. The point is just to decide the names of the objects and morphisms, because these names will then be fixed forever, and part of the API.</p>

<a name="136146418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136146418" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136146418">Scott Morrison (Oct 20 2018 at 00:02)</a>:</h4>
<blockquote>
<p>Wouldn't you just prove this by <code>limit.post</code>...?</p>
</blockquote>
<p>I've just been trying this, and quickly discovered the reason: <code>limit.post</code> assumes that you're in a complete category. However <code>pi.post</code> only assumes you have all products. Therefore you can't call <code>limit.post</code> from <code>pi.post</code>, and we're stuck proving it again.</p>

<a name="136146426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136146426" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136146426">Scott Morrison (Oct 20 2018 at 00:03)</a>:</h4>
<p>Maybe this is a sign that <code>pi.post</code> is not what we want to provide people anyway.</p>

<a name="136146470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136146470" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136146470">Scott Morrison (Oct 20 2018 at 00:04)</a>:</h4>
<p>Except ... that it is...</p>

<a name="136146475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136146475" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136146475">Scott Morrison (Oct 20 2018 at 00:04)</a>:</h4>
<p>Maybe I will finish off "porting" products to the new setup, and then you guys can have a look to see what can be reduced.</p>

<a name="136146479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136146479" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136146479">Scott Morrison (Oct 20 2018 at 00:05)</a>:</h4>
<p>I'll do products because there no walking categories are required, we just use <code>functor.of_function</code>.</p>

<a name="136146551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136146551" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136146551">Reid Barton (Oct 20 2018 at 00:07)</a>:</h4>
<p>We probably need things like <code>[has_limits_of_shape J]</code> for other purposes anyways</p>

<a name="136146593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136146593" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136146593">Reid Barton (Oct 20 2018 at 00:08)</a>:</h4>
<p>e.g. <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>-accessible categories have all <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>-filtered colimits</p>

<a name="136146599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136146599" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136146599">Reid Barton (Oct 20 2018 at 00:08)</a>:</h4>
<p>("We" = "I", perhaps)</p>

<a name="136146608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136146608" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136146608">Reid Barton (Oct 20 2018 at 00:09)</a>:</h4>
<p>Similarly we want to talk about functors which preserve finite products or whatever</p>

<a name="136146677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136146677" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136146677">Reid Barton (Oct 20 2018 at 00:11)</a>:</h4>
<p>or filtered colimits, etc. This seems to me like more evidence that we need to be able to represent special shapes of (co)limits as special cases of general (co)limits so that we can flexibly mix all these notions, though certainly I have not yet tried to construct a specific design for any of this</p>

<a name="136146882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136146882" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136146882">Scott Morrison (Oct 20 2018 at 00:18)</a>:</h4>
<p>Could we try something like... <code>has_limits_of {A : Type} (Q : A \to \Sigma (J : Type), J \func C)</code></p>

<a name="136146949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136146949" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136146949">Scott Morrison (Oct 20 2018 at 00:20)</a>:</h4>
<p><code>has_limits</code> itself could be defined as <code>has_limits_of id</code></p>

<a name="136146965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136146965" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136146965">Scott Morrison (Oct 20 2018 at 00:21)</a>:</h4>
<p><code>has_products</code> could be defined as <code>has_limits_of A Q</code> with <code>A = \Sigma (b : Type), b \to C</code>, and <code>Q = \lambda p, p.1, functor.of_function p.2</code>.</p>

<a name="136146967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136146967" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136146967">Reid Barton (Oct 20 2018 at 00:21)</a>:</h4>
<p>That's super general but I think even that level of generality could be useful in specific circumstances.</p>

<a name="136147009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136147009" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136147009">Scott Morrison (Oct 20 2018 at 00:22)</a>:</h4>
<p>Maybe there's no need to specify the allowed functors?</p>

<a name="136147015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136147015" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136147015">Scott Morrison (Oct 20 2018 at 00:22)</a>:</h4>
<p>Just the allowed diagrams?</p>

<a name="136147016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136147016" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136147016">Reid Barton (Oct 20 2018 at 00:22)</a>:</h4>
<p>For example cofibration categories or Waldhausen categories have an axiom which says that you can form a pushout if one of the legs is a cofibration (one of the bits of structure)</p>

<a name="136147021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136147021" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136147021">Scott Morrison (Oct 20 2018 at 00:22)</a>:</h4>
<p>I see.</p>

<a name="136147033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136147033" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136147033">Reid Barton (Oct 20 2018 at 00:23)</a>:</h4>
<p>I just hand-crafted this axiom in my project: <a href="https://github.com/rwbarton/lean-homotopy-theory/blob/lean-3.4.1/src/homotopy_theory/formal/cofibrations/precofibration_category.lean#L41" target="_blank" title="https://github.com/rwbarton/lean-homotopy-theory/blob/lean-3.4.1/src/homotopy_theory/formal/cofibrations/precofibration_category.lean#L41">https://github.com/rwbarton/lean-homotopy-theory/blob/lean-3.4.1/src/homotopy_theory/formal/cofibrations/precofibration_category.lean#L41</a></p>

<a name="136147080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136147080" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136147080">Reid Barton (Oct 20 2018 at 00:24)</a>:</h4>
<p>So I know this example off-hand because I already implemented it in Lean. I think this is a pretty rare scenario, but if doesn't make things too much more complicated...? Certainly the common case would be A = (J \func C), or Sigma of that over all J of some form (e.g., J filtered)</p>

<a name="136147151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136147151" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136147151">Reid Barton (Oct 20 2018 at 00:27)</a>:</h4>
<p>i.e., stick <code>has_limits_of_shape J</code> as a specialization of <code>has_limits_of</code> and a generalization of <code>has_products</code></p>

<a name="136147519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136147519" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136147519">Scott Morrison (Oct 20 2018 at 00:38)</a>:</h4>
<p>well, maybe even one more step: <code>has_limits_of</code>, allowing you to specify arbitrary diagrams and arbitrary functors out of those, then <code>has_limits_of_shapes</code> allowing you to specify a class of diagrams, but all functors out of them, then <code>has_limits_of_shape</code> for a single diagram, and then <code>has_binary_products</code> would be a specialisation of that.</p>

<a name="136147522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136147522" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136147522">Scott Morrison (Oct 20 2018 at 00:38)</a>:</h4>
<p>in any case, I'll give this a go, I guess.</p>

<a name="136147525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136147525" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136147525">Reid Barton (Oct 20 2018 at 00:38)</a>:</h4>
<p>Sounds great!</p>

<a name="136147610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136147610" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136147610">Reid Barton (Oct 20 2018 at 00:41)</a>:</h4>
<p>I should really finish up that Grand Plan for formalizing model categories that I started writing a while ago...</p>

<a name="136153288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136153288" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136153288">Johan Commelin (Oct 20 2018 at 04:01)</a>:</h4>
<p>While we are at it: Do people have strong opinions on whether the homs of a category live in <code>Type v</code> or <code>Sort v</code>? I think if we start doing all sorts of diagrams over preorders (or using preorders as categories in other places) it might help in manipulating the homs if they are just in <code>Prop</code> instead of the whole <code>ulift plift</code> dance.<br>
<span class="user-mention" data-user-id="110087">@Scott Morrison</span> Let me stress that I really love what you've done so far <span class="emoji emoji-1f64f" title="thank you">:thank_you:</span>. The only reason that I have these questions is because your code is so good <span class="emoji emoji-1f44d" title="thumbs up">:thumbs_up:</span>  that I can't resist using it <span class="emoji emoji-1f61c" title="stuck out tongue wink">:stuck_out_tongue_wink:</span></p>

<a name="136155058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136155058" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136155058">Scott Morrison (Oct 20 2018 at 05:07)</a>:</h4>
<p>I've tried this before, but it's not possible to use <code>Sort v</code>. Unfortunately at the moment I can't remember why... From memory if you just start at the top and switch it over you run into difficulties quite quickly, if you want to try it yourself. :-)</p>

<a name="136157606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136157606" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136157606">David Michael Roberts (Oct 20 2018 at 06:41)</a>:</h4>
<blockquote>
<p>For example cofibration categories or Waldhausen categories have an axiom which says that you can form a pushout if one of the legs is a cofibration (one of the bits of structure)</p>
</blockquote>
<p>Dually, there are many cases where one has a class of morphisms of which pullbacks along arbitrary maps exist (eg submersions, in smooth manifolds)</p>

<a name="136158656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136158656" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136158656">Johan Commelin (Oct 20 2018 at 07:20)</a>:</h4>
<p>Right. At some point we want to formalise this list: <a href="https://stacks.math.columbia.edu/tag/02WE" target="_blank" title="https://stacks.math.columbia.edu/tag/02WE">https://stacks.math.columbia.edu/tag/02WE</a></p>

<a name="136159177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136159177" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136159177">David Michael Roberts (Oct 20 2018 at 07:41)</a>:</h4>
<p>Well, <code>span</code> and <code>cospan</code> are obvious choices, as is <code>parallel_pair</code>. Then also for each finite set one should have the corresponding discrete category, so as to form products/coproduct. The empty category should be there too, to get terminal/initial objects.</p>

<a name="136173465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173465" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173465">Scott Morrison (Oct 20 2018 at 15:42)</a>:</h4>
<p>No, I want to know what the _objects_ and _morphisms_ inside, for example <code>parallel_pair</code> should be called.</p>

<a name="136173471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173471" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173471">Scott Morrison (Oct 20 2018 at 15:43)</a>:</h4>
<p>Should the objects be <code>source</code> and <code>target</code>, and the morphisms <code>left</code> and <code>right</code>?</p>

<a name="136173472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173472" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173472">Reid Barton (Oct 20 2018 at 15:43)</a>:</h4>
<p>Yeah that's a tough one. <code>top_arrow</code>?</p>

<a name="136173473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173473" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173473">Scott Morrison (Oct 20 2018 at 15:43)</a>:</h4>
<p>Or should <code>parallel_pair := bool</code>??</p>

<a name="136173480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173480" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173480">Mario Carneiro (Oct 20 2018 at 15:43)</a>:</h4>
<p>I like 0 and 1 for the objects</p>

<a name="136173484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173484" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173484">Scott Morrison (Oct 20 2018 at 15:43)</a>:</h4>
<p>As in <code>def parallel_pair := fin 2</code>?</p>

<a name="136173531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173531" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173531">Scott Morrison (Oct 20 2018 at 15:44)</a>:</h4>
<p>Or</p>
<div class="codehilite"><pre><span></span>inductive parallel_pair | _0 | _1
</pre></div>


<p>??</p>

<a name="136173532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173532" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173532">Mario Carneiro (Oct 20 2018 at 15:44)</a>:</h4>
<p>probably not literally</p>

<a name="136173535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173535" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173535">Mario Carneiro (Oct 20 2018 at 15:44)</a>:</h4>
<p>like the second</p>

<a name="136173541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173541" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173541">Mario Carneiro (Oct 20 2018 at 15:44)</a>:</h4>
<p>I just mean as names</p>

<a name="136173543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173543" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173543">Scott Morrison (Oct 20 2018 at 15:45)</a>:</h4>
<p>okay, that's what I've done previously. Is there something better that <code>_0</code> and <code>_1</code> for the names?</p>

<a name="136173551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173551" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173551">Mario Carneiro (Oct 20 2018 at 15:45)</a>:</h4>
<p><code>0</code> and <code>1</code> are achievable</p>

<a name="136173555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173555" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173555">Scott Morrison (Oct 20 2018 at 15:45)</a>:</h4>
<p>Oh, how?</p>

<a name="136173557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173557" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173557">Mario Carneiro (Oct 20 2018 at 15:45)</a>:</h4>
<p>add an instance</p>

<a name="136173560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173560" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173560">Reid Barton (Oct 20 2018 at 15:45)</a>:</h4>
<p><code>has_zero</code> <code>has_one</code></p>

<a name="136173613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173613" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173613">Scott Morrison (Oct 20 2018 at 15:46)</a>:</h4>
<p>ah, I see.</p>

<a name="136173617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173617" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173617">Scott Morrison (Oct 20 2018 at 15:46)</a>:</h4>
<p>Isn't it just more confusing to have an inductive type with terms <code>_0</code>, <code>_1</code>, but then give them second names via instances?</p>

<a name="136173619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173619" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173619">Reid Barton (Oct 20 2018 at 15:46)</a>:</h4>
<p>Probably</p>

<a name="136173627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173627" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173627">Mario Carneiro (Oct 20 2018 at 15:47)</a>:</h4>
<p>I would call them <code>zero</code> and <code>one</code></p>

<a name="136173635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173635" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173635">Mario Carneiro (Oct 20 2018 at 15:47)</a>:</h4>
<p>and then use <code>0</code> and <code>1</code> as notation</p>

<a name="136173640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173640" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173640">Mario Carneiro (Oct 20 2018 at 15:47)</a>:</h4>
<p>we do that for <code>nat</code>, it's not that confusing</p>

<a name="136173643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173643" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173643">Scott Morrison (Oct 20 2018 at 15:47)</a>:</h4>
<p>okay... And using <code>0</code> and <code>1</code> as notation via <code>has_zero</code> and <code>has_one</code> will work in pattern matching, etc, just like for nat.</p>

<a name="136173644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173644" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173644">Scott Morrison (Oct 20 2018 at 15:47)</a>:</h4>
<p>Sounds reasonable.</p>

<a name="136173648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173648" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173648">Scott Morrison (Oct 20 2018 at 15:47)</a>:</h4>
<p>On to the morphisms, then. :-)</p>

<a name="136173667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173667" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173667">Mario Carneiro (Oct 20 2018 at 15:48)</a>:</h4>
<p>yeah...</p>

<a name="136173692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173692" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173692">Scott Morrison (Oct 20 2018 at 15:48)</a>:</h4>
<p>And the names of objects in pullbacks and pushouts...</p>

<a name="136173694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173694" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173694">Mario Carneiro (Oct 20 2018 at 15:48)</a>:</h4>
<p>no bright ideas there. <code>left</code> and <code>right</code> seem reasonable?</p>

<a name="136173706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173706" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173706">Scott Morrison (Oct 20 2018 at 15:49)</a>:</h4>
<p>Except that there's no sense in which the two are actually different...</p>

<a name="136173721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173721" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173721">Reid Barton (Oct 20 2018 at 15:49)</a>:</h4>
<p>surely they're <code>top</code> and <code>bottom</code>?</p>

<a name="136173723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173723" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173723">Mario Carneiro (Oct 20 2018 at 15:49)</a>:</h4>
<p>I don't think <code>left</code> and <code>right</code> imply any other difference</p>

<a name="136173724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173724" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173724">Reid Barton (Oct 20 2018 at 15:49)</a>:</h4>
<p>Which way do you draw your equalizers??</p>

<a name="136173768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173768" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173768">Scott Morrison (Oct 20 2018 at 15:50)</a>:</h4>
<p>Yeah, there's that too. <code>top</code> and <code>bottom</code> are probably better.</p>

<a name="136173769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173769" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173769">Reid Barton (Oct 20 2018 at 15:50)</a>:</h4>
<p>(but maybe <code>top</code> and <code>bottom</code> have too many other connotations, with ordering?)</p>

<a name="136173772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173772" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173772">Mario Carneiro (Oct 20 2018 at 15:50)</a>:</h4>
<p>I know, it's bugging me that the walking pair is always drawn with the arrows above each other</p>

<a name="136173788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173788" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173788">Scott Morrison (Oct 20 2018 at 15:51)</a>:</h4>
<p>oh -- and if <code>walking_pair</code> is the diagram for an equalizer, what is the diagram for a binary product?</p>

<a name="136173789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173789" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173789">Mario Carneiro (Oct 20 2018 at 15:51)</a>:</h4>
<p>but I think that the analogy to posets is important, that's why 0 and 1 are useful</p>

<a name="136173790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173790" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173790">Reid Barton (Oct 20 2018 at 15:51)</a>:</h4>
<p>I was going to bring up binary things next.</p>

<a name="136173796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173796" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173796">Mario Carneiro (Oct 20 2018 at 15:51)</a>:</h4>
<p>which one is that?</p>

<a name="136173799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173799" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173799">Mario Carneiro (Oct 20 2018 at 15:51)</a>:</h4>
<p>A &gt; B &lt; C?</p>

<a name="136173844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173844" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173844">Scott Morrison (Oct 20 2018 at 15:52)</a>:</h4>
<p>binary product is just the diagram with two objects, no arrows at all</p>

<a name="136173849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173849" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173849">Mario Carneiro (Oct 20 2018 at 15:52)</a>:</h4>
<p>left and right, definitely</p>

<a name="136173851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173851" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173851">Reid Barton (Oct 20 2018 at 15:52)</a>:</h4>
<p>In my homotopy theory library I used the convention of naming things like the inclusions of a coproduct with <code>\_0</code> and <code>\_1</code>, and eventually I got annoyed that I hadn't chosen <code>\_1</code> and <code>\_2</code>, but it would be a lot of things to change.</p>

<a name="136173852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173852" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173852">Scott Morrison (Oct 20 2018 at 15:52)</a>:</h4>
<p>... I'd been tempted to call that the <code>walking_pair</code>, and the diagram for an equalizer the <code>walking_parallel_pair</code>, but that is contrary to usual usage, I think.</p>

<a name="136173861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173861" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173861">Reid Barton (Oct 20 2018 at 15:53)</a>:</h4>
<p>I assume you're going to define it as <code>discrete</code> of some type?</p>

<a name="136173870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173870" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173870">Reid Barton (Oct 20 2018 at 15:53)</a>:</h4>
<p>The reason is that <code>\_1</code> and <code>\_2</code> aligns better with Lean's builtin <code>p.1</code> and <code>p.2</code></p>

<a name="136173877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173877" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173877">Scott Morrison (Oct 20 2018 at 15:53)</a>:</h4>
<p>Okay, yeah, I guess that is best, so it's defeq a special case of arbitrarily indexed products.</p>

<a name="136173922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173922" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173922">Reid Barton (Oct 20 2018 at 15:54)</a>:</h4>
<p>Yes, and it should also just be less work overall</p>

<a name="136173923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173923" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173923">Scott Morrison (Oct 20 2018 at 15:54)</a>:</h4>
<p>So is the indexing category for <code>binary_product</code> <code>discrete (fin 2)</code>, <code>discrete bool</code> or <code>discrete side</code>, where <code>side</code> is an inductive type with terms <code>left</code> and <code>right</code>?</p>

<a name="136173927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173927" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173927">Scott Morrison (Oct 20 2018 at 15:54)</a>:</h4>
<p>I maybe prefer the last?</p>

<a name="136173931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173931" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173931">Mario Carneiro (Oct 20 2018 at 15:55)</a>:</h4>
<p>I think I do too</p>

<a name="136173937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173937" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173937">Scott Morrison (Oct 20 2018 at 15:55)</a>:</h4>
<p>or something with terms <code>fst</code> and <code>snd</code>?</p>

<a name="136173942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173942" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173942">Scott Morrison (Oct 20 2018 at 15:55)</a>:</h4>
<p>That fits better with the naming of projection maps in Lean itself.</p>

<a name="136173947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173947" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173947">Mario Carneiro (Oct 20 2018 at 15:55)</a>:</h4>
<p>the problem with that is they aren't maps</p>

<a name="136173992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173992" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173992">Mario Carneiro (Oct 20 2018 at 15:56)</a>:</h4>
<p>I would get the two confused</p>

<a name="136173994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136173994" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136173994">Scott Morrison (Oct 20 2018 at 15:56)</a>:</h4>
<p>yes, but we'll be able to write things like <code>c.\pi fst</code> for the first projection</p>

<a name="136174001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174001" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174001">Reid Barton (Oct 20 2018 at 15:56)</a>:</h4>
<p><code>left</code> and <code>right</code> are nice for <code>inl</code> and <code>inr</code> though</p>

<a name="136174009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174009" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174009">Mario Carneiro (Oct 20 2018 at 15:56)</a>:</h4>
<p>is it the same category being reused?</p>

<a name="136174021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174021" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174021">Scott Morrison (Oct 20 2018 at 15:57)</a>:</h4>
<p>I don't see why not.</p>

<a name="136174023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174023" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174023">Mario Carneiro (Oct 20 2018 at 15:57)</a>:</h4>
<p>ok, then I agree with Reid</p>

<a name="136174025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174025" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174025">Reid Barton (Oct 20 2018 at 15:57)</a>:</h4>
<p>Probably it should be... so that we can relate coproducts in C to products in C^op eventually</p>

<a name="136174029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174029" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174029">Mario Carneiro (Oct 20 2018 at 15:57)</a>:</h4>
<p>although I guess technically one is the op of the other</p>

<a name="136174069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174069" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174069">Reid Barton (Oct 20 2018 at 15:58)</a>:</h4>
<p>Yes, technically it should be the op</p>

<a name="136174072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174072" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174072">Scott Morrison (Oct 20 2018 at 15:58)</a>:</h4>
<p>Great, I will use <code>side</code> with <code>left</code> and <code>right</code>.</p>

<a name="136174074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174074" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174074">Reid Barton (Oct 20 2018 at 15:58)</a>:</h4>
<p>but we're already writing the category as <code>discrete T</code> where <code>T</code> is the type of its objects</p>

<a name="136174075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174075" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174075">Scott Morrison (Oct 20 2018 at 15:58)</a>:</h4>
<p>Finally, pullbacks and pushouts</p>

<a name="136174087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174087" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174087">Mario Carneiro (Oct 20 2018 at 15:59)</a>:</h4>
<p>Can we steal the same names?</p>

<a name="136174088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174088" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174088">Scott Morrison (Oct 20 2018 at 15:59)</a>:</h4>
<p>it would be nice here if everything is consistent...</p>

<a name="136174092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174092" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174092">Reid Barton (Oct 20 2018 at 15:59)</a>:</h4>
<p><code>middle</code>??</p>

<a name="136174095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174095" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174095">Reid Barton (Oct 20 2018 at 15:59)</a>:</h4>
<p>Is anyone going to actually see these names?</p>

<a name="136174152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174152" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174152">Mario Carneiro (Oct 20 2018 at 16:00)</a>:</h4>
<p><code>left - inl &gt; 1 &lt; inr - right</code></p>

<a name="136174158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174158" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174158">Mario Carneiro (Oct 20 2018 at 16:00)</a>:</h4>
<p><code>left &lt; fst - 0 - snd &gt; right</code></p>

<a name="136174262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174262" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174262">Scott Morrison (Oct 20 2018 at 16:02)</a>:</h4>
<p>okay, sounds good to me</p>

<a name="136174278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174278" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174278">Scott Morrison (Oct 20 2018 at 16:03)</a>:</h4>
<p>except...</p>

<a name="136174281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174281" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174281">Reid Barton (Oct 20 2018 at 16:03)</a>:</h4>
<p>I guess those names are technically accurate in some sense, though I find them really confusing</p>

<a name="136174289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174289" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174289">Reid Barton (Oct 20 2018 at 16:03)</a>:</h4>
<p>like, you have <code>fst</code> and <code>snd</code> involved in the diagram for pushouts and vice versa</p>

<a name="136174292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174292" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174292">Scott Morrison (Oct 20 2018 at 16:03)</a>:</h4>
<p>remember the morphisms there are terms of one-element types</p>

<a name="136174303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174303" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174303">Scott Morrison (Oct 20 2018 at 16:03)</a>:</h4>
<p>maybe we should just make all those morphisms types <code>punit</code>.</p>

<a name="136174308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174308" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174308">Scott Morrison (Oct 20 2018 at 16:04)</a>:</h4>
<p>and not have names at all</p>

<a name="136174365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174365" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174365">Scott Morrison (Oct 20 2018 at 16:04)</a>:</h4>
<p>we just have to name the objects here, so we'd have <code>inductive walking_pullback | left | right | one</code></p>

<a name="136174368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174368" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174368">Mario Carneiro (Oct 20 2018 at 16:04)</a>:</h4>
<p>I don't think so... the type is a inductive family with two elements</p>

<a name="136174370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174370" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174370">Reid Barton (Oct 20 2018 at 16:04)</a>:</h4>
<p>As they say, no names is good names</p>

<a name="136174396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174396" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174396">Scott Morrison (Oct 20 2018 at 16:05)</a>:</h4>
<p>why? we need to have a type of morphisms from <code>left</code> to <code>one</code>, and it contains only <code>inl</code>.</p>

<a name="136174400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174400" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174400">Scott Morrison (Oct 20 2018 at 16:05)</a>:</h4>
<p>etc</p>

<a name="136174403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174403" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174403">Reid Barton (Oct 20 2018 at 16:05)</a>:</h4>
<p>It depends on whether you want to define <code>hom</code> as a single inductive family, or a type defined by case analysis</p>

<a name="136174418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174418" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174418">Mario Carneiro (Oct 20 2018 at 16:05)</a>:</h4>
<p>I think types by case analysis is a bad idea</p>

<a name="136174462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174462" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174462">Scott Morrison (Oct 20 2018 at 16:06)</a>:</h4>
<p>remember <code>hom : obj -&gt; obj -&gt; Type</code></p>

<a name="136174474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174474" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174474">Reid Barton (Oct 20 2018 at 16:06)</a>:</h4>
<p>I agree it probably makes the finite amount of work it takes to set up these categories and describe functors from them larger</p>

<a name="136174475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174475" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174475">Scott Morrison (Oct 20 2018 at 16:06)</a>:</h4>
<p>maybe I'm confused here</p>

<a name="136174478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174478" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174478">Reid Barton (Oct 20 2018 at 16:07)</a>:</h4>
<p>I don't know if it has any longer term consequences though</p>

<a name="136174484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174484" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174484">Mario Carneiro (Oct 20 2018 at 16:07)</a>:</h4>
<p><code>inductive hom | inl : hom left 1 | inr : hom right 1</code></p>

<a name="136174486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174486" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174486">Scott Morrison (Oct 20 2018 at 16:07)</a>:</h4>
<p>I see</p>

<a name="136174487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174487" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174487">Scott Morrison (Oct 20 2018 at 16:07)</a>:</h4>
<p>okay, that does sound good</p>

<a name="136174489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174489" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174489">Scott Morrison (Oct 20 2018 at 16:07)</a>:</h4>
<p>but makes it harder to name things. :-)</p>

<a name="136174527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174527" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174527">Reid Barton (Oct 20 2018 at 16:08)</a>:</h4>
<p>what about identities though? I think the truly correct way to do this is to go through the free graph construction</p>

<a name="136174531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174531" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174531">Reid Barton (Oct 20 2018 at 16:08)</a>:</h4>
<p>Er, free category on a graph construction</p>

<a name="136174533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174533" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174533">Mario Carneiro (Oct 20 2018 at 16:08)</a>:</h4>
<p>I was just about to say the same</p>

<a name="136174534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174534" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174534">Mario Carneiro (Oct 20 2018 at 16:08)</a>:</h4>
<p>this is a graph, not a cat</p>

<a name="136174536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174536" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174536">Reid Barton (Oct 20 2018 at 16:08)</a>:</h4>
<p>which I do have written down somewhere</p>

<a name="136174539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174539" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174539">Scott Morrison (Oct 20 2018 at 16:09)</a>:</h4>
<p>yes... I have this as well. It is extraordinarily painful to use, and this is why I hadn't previously pursued this approach.</p>

<a name="136174542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174542" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174542">Reid Barton (Oct 20 2018 at 16:09)</a>:</h4>
<p>but I'm still not sure whether it makes any difference once we're done defining all these little categories</p>

<a name="136174547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174547" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174547">Mario Carneiro (Oct 20 2018 at 16:09)</a>:</h4>
<p>really? I wouldn't have expected that</p>

<a name="136174549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174549" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174549">Scott Morrison (Oct 20 2018 at 16:09)</a>:</h4>
<p>but Reid, isn't your point that "all these little categories" is not a fixed set?</p>

<a name="136174552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174552" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174552">Reid Barton (Oct 20 2018 at 16:09)</a>:</h4>
<p>Specifically, it should be easy enough to change our mind about the definitions of these categories later, right?<br>
As long as we have a usable interface for building functors out of them</p>

<a name="136174619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174619" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174619">Reid Barton (Oct 20 2018 at 16:11)</a>:</h4>
<p>for example: there is some category called <code>parallel_pair</code>, and to define a functor <code>parallel_pair \func C</code> I have to give you two objects (a b : C) and two maps (f g : a \hom b)</p>

<a name="136174627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174627" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174627">Scott Morrison (Oct 20 2018 at 16:11)</a>:</h4>
<p>yes</p>

<a name="136174633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174633" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174633">Scott Morrison (Oct 20 2018 at 16:11)</a>:</h4>
<p>my preference would be on the first cut to define the slightly larger  indexed inductive types for morphisms that include identity morphisms.</p>

<a name="136174634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174634" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174634">Reid Barton (Oct 20 2018 at 16:11)</a>:</h4>
<p>and then... there is some extensionality rule or something... and then it doesn't matter what goes inside. Right?<br>
And nobody really needs to care about the choices of names, since I just renamed everything <code>a b f g</code> anyways</p>

<a name="136174676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174676" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174676">Scott Morrison (Oct 20 2018 at 16:12)</a>:</h4>
<p>and only later to pursue defining these as path categories on graphs (because I don't know how to do this well)</p>

<a name="136174678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174678" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174678">Reid Barton (Oct 20 2018 at 16:12)</a>:</h4>
<p>As long as we can maintain this interface, it shouldn't matter whether we use the free category on a graph, or define hom as an indexed inductive type, or define hom by case analysis</p>

<a name="136174683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174683" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174683">Reid Barton (Oct 20 2018 at 16:13)</a>:</h4>
<p>or define the category as a poset if it happens to be one</p>

<a name="136174688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174688" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174688">Scott Morrison (Oct 20 2018 at 16:13)</a>:</h4>
<p>I can't see to find my previous attempt to construct equalizers, based on a free category, out of limits, which was so unpleasant...</p>

<a name="136174736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174736" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174736">Reid Barton (Oct 20 2018 at 16:14)</a>:</h4>
<p>I admit I never actually used my free category construction to do anything. I was going to use it to prove that Cat has coequalizers... but I didn't.</p>

<a name="136174758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174758" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174758">Mario Carneiro (Oct 20 2018 at 16:15)</a>:</h4>
<p>Oh hey, are graphs an example of <code>has_hom</code>?</p>

<a name="136174780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174780" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174780">Reid Barton (Oct 20 2018 at 16:15)</a>:</h4>
<p>That depends on what <code>has_hom</code> means exactly--this example was in the back of my mind when commenting on that aspect of Simon's PR</p>

<a name="136174823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174823" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174823">Mario Carneiro (Oct 20 2018 at 16:16)</a>:</h4>
<p>assuming categories extend it, it must mean the notation, with hom and objects</p>

<a name="136174824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174824" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174824">Reid Barton (Oct 20 2018 at 16:16)</a>:</h4>
<p>I think Scott convinced me at one point that it was better to not build <code>category</code> on top of <code>graph</code>, but I don't remember why exactly... maybe if we rename <code>graph</code> to <code>has_hom</code> it is more palatable, haha</p>

<a name="136174883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174883" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174883">Mario Carneiro (Oct 20 2018 at 16:18)</a>:</h4>
<p>I kind of want to reserve the name <code>graph</code> for <em>small</em> <code>has_hom</code>s</p>

<a name="136174893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174893" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174893">Reid Barton (Oct 20 2018 at 16:19)</a>:</h4>
<p>Mario I'm glad you agree--there's this discussion about what to rename <code>has_hom</code> to in Simon's PR, which is really "the data of a category without the laws"</p>

<a name="136174900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174900" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174900">Reid Barton (Oct 20 2018 at 16:19)</a>:</h4>
<p>That would just be specializing the universe parameters of <code>has_hom</code> to be equal right?</p>

<a name="136174949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174949" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174949">Mario Carneiro (Oct 20 2018 at 16:20)</a>:</h4>
<p>I think so? I'm not sure that's small enough. Maybe it doesn't make sense</p>

<a name="136174956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174956" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174956">Mario Carneiro (Oct 20 2018 at 16:21)</a>:</h4>
<p>I want <code>graph A : Type u</code> when <code>A : Type u</code></p>

<a name="136174960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174960" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174960">Mario Carneiro (Oct 20 2018 at 16:21)</a>:</h4>
<p>but there's no way I'm going to get that</p>

<a name="136174961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174961" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174961">Reid Barton (Oct 20 2018 at 16:21)</a>:</h4>
<p>A graph is a set of vertices, together with a set of edges from a to b for each a and b</p>

<a name="136174964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136174964" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136174964">Reid Barton (Oct 20 2018 at 16:21)</a>:</h4>
<p>Well, if graph isn't allowed to have multiple edges...</p>

<a name="136175003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136175003" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136175003">Mario Carneiro (Oct 20 2018 at 16:22)</a>:</h4>
<p>yeah, simple graphs solve the problem</p>

<a name="136175008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136175008" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136175008">Reid Barton (Oct 20 2018 at 16:22)</a>:</h4>
<p>I guess actual graph theorists would call this a multigraph</p>

<a name="136175074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136175074" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136175074">Reid Barton (Oct 20 2018 at 16:24)</a>:</h4>
<p>Anyways <code>graph</code>s would also be examples of <code>has_hom</code> in any case</p>

<a name="136175113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136175113" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136175113">Reid Barton (Oct 20 2018 at 16:25)</a>:</h4>
<p>Anyways anyways, my overall claim is that these names don't really matter either, because people should only be using the interface like <code>parallel_pair_functor f g</code>.</p>

<a name="136175312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136175312" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136175312">Reid Barton (Oct 20 2018 at 16:30)</a>:</h4>
<p>Maybe that means the things to do is to pick the variable names which appear in the interface (like <code>f</code> and <code>g</code>?) and then choose the names of generating morphisms based on them in some systematic way (like <code>F</code> and <code>G</code>?)</p>

<a name="136175325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136175325" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136175325">Reid Barton (Oct 20 2018 at 16:31)</a>:</h4>
<p>or whatever naming convention seems least likely to collide with other relevant things, maybe <code>F</code> is a bad name</p>

<a name="136178333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136178333" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136178333">Kevin Buzzard (Oct 20 2018 at 17:51)</a>:</h4>
<blockquote>
<p>The reason is that <code>\_1</code> and <code>\_2</code> aligns better with Lean's builtin <code>p.1</code> and <code>p.2</code></p>
</blockquote>
<p>I was surprised once when I realised that the builtin notation was not <code>p.0</code> and <code>p.1</code> but presumably could have been, given that Lean was written by CS people.</p>

<a name="136199413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136199413" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136199413">Scott Morrison (Oct 21 2018 at 05:02)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span>, <span class="user-mention" data-user-id="112680">@Johan Commelin</span>, I experimented with a new design for "special" shape limits. Now they are all defined as special cases of limits. If you want to have a quick look, see <a href="https://github.com/leanprover-community/mathlib/tree/limits-others-new/category_theory/limits" target="_blank" title="https://github.com/leanprover-community/mathlib/tree/limits-others-new/category_theory/limits">https://github.com/leanprover-community/mathlib/tree/limits-others-new/category_theory/limits</a>.</p>

<a name="136199421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136199421" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136199421">Scott Morrison (Oct 21 2018 at 05:03)</a>:</h4>
<p>I think it looks reasonable. I would like to try proving some things about limits in functor categories, and make sure they immediately imply the corresponding results about pullbacks/products/etc.</p>

<a name="136302717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136302717" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136302717">Scott Morrison (Oct 22 2018 at 23:13)</a>:</h4>
<p>I'm going to make other fundamental changes, I think.</p>

<a name="136302755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136302755" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136302755">Scott Morrison (Oct 22 2018 at 23:14)</a>:</h4>
<p>(deleted)</p>

<a name="136302808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136302808" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136302808">Scott Morrison (Oct 22 2018 at 23:15)</a>:</h4>
<p>I'm going to change <code>cone F</code> at least so that it is an object, bundled with a natural transformation from the constant functor (with value that object) to <code>F</code>. I may go all the way and just define <code>cone F</code> as a special case of a comma category. That had, long ago, been my initial version of limits, but I was having too much trouble with it. Having learnt a few things, I think it's viable again, so will try again. :-)</p>

<a name="136303069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136303069" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136303069">Reid Barton (Oct 22 2018 at 23:19)</a>:</h4>
<p>I wanted exactly this description in order to prove that right adjoints preserve limits</p>

<a name="136319006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136319006" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136319006">Johan Commelin (Oct 23 2018 at 06:42)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> Cool! That sounds like a good generalisation.<br>
Concretely, you had a definition of sheaves, and I have almost generalised it to arbitrary sites. The real test case is probably going to be sheafification, and more generally pushforward and pullbacks of sheaves (and the fact that those are adjoint).</p>

<a name="136324809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/yoneda/near/136324809" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/02913yoneda.html#136324809">Johan Commelin (Oct 23 2018 at 08:57)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> How general are you planning to set up comma categories? Only slices over an object, or the general thing where you start with two functors?</p>


{% endraw %}
