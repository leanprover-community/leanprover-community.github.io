---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/116395maths/58200bundlingmulhoms.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html">bundling mul_homs</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="171137073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137073" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137073">Kevin Buzzard (Jul 18 2019 at 04:21)</a>:</h4>
<p>Mathlib has the unbundled <code>is_mul_hom</code> class (a Prop), and then it has <code>mul_equiv</code> which references this unbundled <code>is_mul_hom</code>. If we were to bundle <code>mul_hom</code>s, how would we define <code>mul_equiv</code>?</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">basic</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">group</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">algebra</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
<span class="o">[</span><span class="n">has_mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">γ</span><span class="o">]</span>
<span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="o">[</span><span class="n">has_mul</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">P</span><span class="o">]</span>

<span class="c">/-</span><span class="cm"> Mathlib:</span>

<span class="cm">class is_mul_hom {α β : Type*} [has_mul α] [has_mul β] (f : α → β) : Prop :=</span>
<span class="cm">(map_mul : ∀ x y, f (x * y) = f x * f y)</span>

<span class="cm">structure mul_equiv (α β : Type*) [has_mul α] [has_mul β] extends α ≃ β :=</span>
<span class="cm">(hom : is_mul_hom to_fun)</span>

<span class="cm">notation ≃* for mul_equiv, proved to be reflexive, symmetric and transitive</span>

<span class="cm">-- not yet found a use for this instance. Should `is_mul_hom` be a structure?</span>
<span class="cm">instance (h : α ≃* β) : is_mul_hom h.to_equiv := h.hom</span>

<span class="cm">-/</span>

<span class="kn">namespace</span> <span class="n">mul</span>

<span class="c">/-</span><span class="cm">- bundled homs FTW -/</span>
<span class="kn">structure</span> <span class="n">hom</span> <span class="o">(</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">N</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">N</span><span class="o">)</span>
<span class="o">(</span><span class="n">map_mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span>

<span class="c1">-- but now if I delete `is_mul_hom`, how do I define `mul_equiv`?</span>
<span class="c1">-- notation for homs</span>
<span class="kn">infix</span> <span class="bp">`</span> <span class="bp">→*</span> <span class="bp">`</span><span class="o">:</span><span class="mi">25</span> <span class="o">:=</span> <span class="n">hom</span>
</pre></div>

<a name="171137127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137127" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137127">Mario Carneiro (Jul 18 2019 at 04:22)</a>:</h4>
<p><code>mul_equiv A B extends equiv A B, mul_hom A B</code></p>

<a name="171137144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137144" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137144">Kevin Buzzard (Jul 18 2019 at 04:23)</a>:</h4>
<p>Should I be using old or new structures for these things?</p>

<a name="171137148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137148" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137148">Mario Carneiro (Jul 18 2019 at 04:23)</a>:</h4>
<p>old structures FTW</p>

<a name="171137150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137150" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137150">Kevin Buzzard (Jul 18 2019 at 04:23)</a>:</h4>
<p>Is what you call <code>mul_hom</code> what I called <code>mul.hom</code>?</p>

<a name="171137154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137154" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137154">Kevin Buzzard (Jul 18 2019 at 04:23)</a>:</h4>
<p>Did I name it wrong?</p>

<a name="171137158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137158" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137158">Mario Carneiro (Jul 18 2019 at 04:23)</a>:</h4>
<p>I don't think so</p>

<a name="171137201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137201" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137201">Mario Carneiro (Jul 18 2019 at 04:24)</a>:</h4>
<p><code>mul_hom A B</code> for me is the type of augmented functions from A to B</p>

<a name="171137203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137203" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137203">Kevin Buzzard (Jul 18 2019 at 04:24)</a>:</h4>
<p>but <code>mul.hom</code> has got a field <code>f</code> and <code>equiv</code> has got a field <code>to_fun</code> and these are supposed to be defeq and have the same name.</p>

<a name="171137204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137204" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137204">Mario Carneiro (Jul 18 2019 at 04:24)</a>:</h4>
<p>I don't see <code>mul.hom</code> in the example</p>

<a name="171137215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137215" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137215">Mario Carneiro (Jul 18 2019 at 04:25)</a>:</h4>
<p>Oh there it is</p>

<a name="171137216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137216" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137216">Kevin Buzzard (Jul 18 2019 at 04:25)</a>:</h4>
<p>I'm talking about my attempt to bundle homs.</p>

<a name="171137218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137218" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137218">Mario Carneiro (Jul 18 2019 at 04:25)</a>:</h4>
<p>I think that should be <code>mul_hom</code></p>

<a name="171137219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137219" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137219">Mario Carneiro (Jul 18 2019 at 04:25)</a>:</h4>
<p><code>mul</code> isn't a namespace</p>

<a name="171137266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137266" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137266">Mario Carneiro (Jul 18 2019 at 04:26)</a>:</h4>
<p><code>mul_hom</code> should have a field called <code>to_fun</code></p>

<a name="171137267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137267" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137267">Mario Carneiro (Jul 18 2019 at 04:26)</a>:</h4>
<p>so that <code>mul_equiv</code> works</p>

<a name="171137396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137396" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137396">Kevin Buzzard (Jul 18 2019 at 04:31)</a>:</h4>
<p><code>to_fun</code> is such a horrible name for a function. I guess its canonical name is the coercion so maybe it doesn't matter. Wait -- the map from <code>mul_equiv X Y</code> to <code>mul_hom X Y</code> -- that is no longer an instance, because <code>mul_hom</code> isn't a class. Is this still done with coercions somehow?</p>

<a name="171137439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137439" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137439">Mario Carneiro (Jul 18 2019 at 04:32)</a>:</h4>
<p>it's a function called <code>to_mul_hom</code></p>

<a name="171137444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137444" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137444">Mario Carneiro (Jul 18 2019 at 04:32)</a>:</h4>
<p>You can try using a coercion but this one tends to trigger rarely</p>

<a name="171137498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137498" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137498">Mario Carneiro (Jul 18 2019 at 04:34)</a>:</h4>
<p>given that the parent functions are always called <code>to_*</code>, <code>to_fun</code> seems to match that naming convention</p>

<a name="171138143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171138143" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171138143">Kevin Buzzard (Jul 18 2019 at 04:55)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">mul_hom</span> <span class="o">(</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">N</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">N</span><span class="o">)</span>
<span class="o">(</span><span class="n">map_mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">to_fun</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">to_fun</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">to_fun</span> <span class="n">y</span><span class="o">)</span>
</pre></div>


<p>Should this have a coercion to fun?</p>

<a name="171138188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171138188" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171138188">Mario Carneiro (Jul 18 2019 at 04:56)</a>:</h4>
<p>yes</p>

<a name="171138401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171138401" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171138401">Kevin Buzzard (Jul 18 2019 at 05:03)</a>:</h4>
<p>My <code>map_mul</code> is crappy:</p>
<div class="codehilite"><pre><span></span><span class="kn">set_option</span> <span class="n">old_structure_cmd</span> <span class="n">true</span>

<span class="c">/-</span><span class="cm">- bundled homs FTW -/</span>
<span class="kn">structure</span> <span class="n">mul_hom</span> <span class="o">(</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">N</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">N</span><span class="o">)</span>
<span class="o">(</span><span class="n">map_mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">to_fun</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">to_fun</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">to_fun</span> <span class="n">y</span><span class="o">)</span>

<span class="c1">-- notation for homs</span>
<span class="kn">infix</span> <span class="bp">`</span> <span class="bp">→*</span> <span class="bp">`</span><span class="o">:</span><span class="mi">25</span> <span class="o">:=</span> <span class="n">mul_hom</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">M</span> <span class="bp">→*</span> <span class="n">N</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">F</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">N</span><span class="o">,</span>
  <span class="n">coe</span> <span class="o">:=</span> <span class="n">mul_hom</span><span class="bp">.</span><span class="n">to_fun</span> <span class="o">}</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">mul_hom</span><span class="bp">.</span><span class="n">map_mul</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">mul_hom.map_mul : ∀ (c : ?M_1 →* ?M_2) (x y : ?M_1), c.to_fun (x * y) = c.to_fun x * c.to_fun y</span>
<span class="cm">-- yeah but I want it to be the coercion, not `c.to_fun`</span>
<span class="cm">-/</span>
</pre></div>


<p>It has come out non-canonically. Am I supposed to be doing this:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">mul_hom</span><span class="bp">.</span><span class="n">map_mul&#39;</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→*</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">M</span><span class="o">),</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">mul_hom</span><span class="bp">.</span><span class="n">map_mul</span>
</pre></div>


<p>?</p>

<a name="171138447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171138447" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171138447">Mario Carneiro (Jul 18 2019 at 05:04)</a>:</h4>
<p>with the primes inverted</p>

<a name="171138449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171138449" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171138449">Kevin Buzzard (Jul 18 2019 at 05:04)</a>:</h4>
<p>So you're saying I need to change mathlib</p>

<a name="171138452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171138452" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171138452">Kevin Buzzard (Jul 18 2019 at 05:04)</a>:</h4>
<p>no</p>

<a name="171138456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171138456" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171138456">Kevin Buzzard (Jul 18 2019 at 05:05)</a>:</h4>
<p>you're saying I need to change my structure field's name.</p>

<a name="171138463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171138463" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171138463">Mario Carneiro (Jul 18 2019 at 05:05)</a>:</h4>
<p>yes</p>

<a name="171139112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171139112" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171139112">Kevin Buzzard (Jul 18 2019 at 05:25)</a>:</h4>
<p>Should this</p>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">mul_equiv&#39;</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">B</span><span class="o">]</span> <span class="kn">extends</span> <span class="n">equiv</span> <span class="n">A</span> <span class="n">B</span><span class="o">,</span> <span class="n">mul_hom</span> <span class="n">A</span> <span class="n">B</span>
</pre></div>


<p>have a coercion to fun?</p>

<a name="171139294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171139294" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171139294">Mario Carneiro (Jul 18 2019 at 05:31)</a>:</h4>
<p>yes</p>

<a name="171140149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171140149" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171140149">Kevin Buzzard (Jul 18 2019 at 05:56)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">basic</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">group</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">algebra</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
<span class="o">[</span><span class="n">has_mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">γ</span><span class="o">]</span>
<span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="o">[</span><span class="n">has_mul</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">P</span><span class="o">]</span>

<span class="c1">-- Recall that the unbundled definition of a mul_hom</span>
<span class="c1">-- and the definition of a mul_equiv, with notation ≃*, are in mathlib.</span>

<span class="c">/-</span><span class="cm"> Mathlib:</span>

<span class="cm">-- in root namespace</span>
<span class="cm">class is_mul_hom {α β : Type*} [has_mul α] [has_mul β] (f : α → β) : Prop :=</span>
<span class="cm">(map_mul : ∀ x y, f (x * y) = f x * f y)</span>

<span class="cm">-- root namespace</span>
<span class="cm">structure mul_equiv (α β : Type*) [has_mul α] [has_mul β] extends α ≃ β :=</span>
<span class="cm">(hom : is_mul_hom to_fun)</span>

<span class="cm">notation ≃*, proved to be reflexive, symmetric and transitive (note: it is not a Prop)</span>
<span class="cm">-/</span>


<span class="c1">--. We will define</span>
<span class="c1">-- bundled homomorphisms of muls, with notation →*, and bundled</span>
<span class="c1">-- equivs, with notation ≃*&#39;</span>


<span class="kn">set_option</span> <span class="n">old_structure_cmd</span> <span class="n">true</span>

<span class="c">/-</span><span class="cm">- bundled homs -/</span>
<span class="kn">structure</span> <span class="n">mul_hom</span> <span class="o">(</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">N</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">N</span><span class="o">)</span>
<span class="o">(</span><span class="n">map_mul&#39;</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">to_fun</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">to_fun</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">to_fun</span> <span class="n">y</span><span class="o">)</span>

<span class="c1">-- notation for homs</span>
<span class="kn">infix</span> <span class="bp">`</span> <span class="bp">→*</span> <span class="bp">`</span><span class="o">:</span><span class="mi">25</span> <span class="o">:=</span> <span class="n">mul_hom</span>

<span class="c1">-- I want to think of a hom as a function sometimes</span>
<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">M</span> <span class="bp">→*</span> <span class="n">N</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">F</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">N</span><span class="o">,</span>
  <span class="n">coe</span> <span class="o">:=</span> <span class="n">mul_hom</span><span class="bp">.</span><span class="n">to_fun</span> <span class="o">}</span>

<span class="c">/-</span><span class="cm">- the statement that mul_homs preserve mul, in its canonical form -/</span>
<span class="n">def</span> <span class="n">mul_hom</span><span class="bp">.</span><span class="n">map_mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→*</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">mul_hom</span><span class="bp">.</span><span class="n">map_mul&#39;</span>

<span class="c1">-- for structures like this you need to prove `id` and `comp` next.</span>
<span class="kn">namespace</span> <span class="n">mul_hom</span>

<span class="c">/-</span><span class="cm">- the identity is a mul_hom-/</span>
<span class="n">def</span> <span class="n">id</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→*</span> <span class="n">M</span> <span class="o">:=</span> <span class="o">{</span><span class="n">to_fun</span> <span class="o">:=</span> <span class="n">id</span><span class="o">,</span> <span class="n">map_mul&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">}</span>

<span class="c">/-</span><span class="cm">- composite of mul_homs is a mul_hom -/</span>
<span class="n">def</span> <span class="n">comp</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→*</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→*</span> <span class="n">γ</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→*</span> <span class="n">γ</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">m</span><span class="o">,</span> <span class="n">g</span> <span class="o">(</span><span class="n">f</span> <span class="n">m</span><span class="o">),</span>
  <span class="n">map_mul&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">map_mul</span> <span class="n">f</span><span class="o">,</span> <span class="n">map_mul</span> <span class="n">g</span><span class="o">]</span> <span class="o">}</span>

<span class="kn">end</span> <span class="n">mul_hom</span>

<span class="c">/-</span><span class="cm">- mul_equiv&#39; (bundled mul_equiv -- the name mul_equiv is currently nicked by unbundled mul_equiv) -/</span>
<span class="kn">structure</span> <span class="n">mul_equiv&#39;</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">B</span><span class="o">]</span> <span class="kn">extends</span> <span class="n">equiv</span> <span class="n">A</span> <span class="n">B</span><span class="o">,</span> <span class="n">mul_hom</span> <span class="n">A</span> <span class="n">B</span>

<span class="c1">-- notation for mul_equiv&#39;</span>
<span class="kn">infix</span> <span class="bp">`</span> <span class="err">≃</span><span class="bp">*</span><span class="err">&#39;</span> <span class="bp">`</span><span class="o">:</span><span class="mi">25</span> <span class="o">:=</span> <span class="n">mul_equiv&#39;</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">M</span> <span class="err">≃</span><span class="bp">*</span><span class="err">&#39;</span> <span class="n">N</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">F</span> <span class="o">:=</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">coe</span> <span class="o">:=</span> <span class="n">mul_equiv&#39;</span><span class="bp">.</span><span class="n">to_fun</span> <span class="o">}</span>

<span class="n">def</span> <span class="n">mul_equiv&#39;</span><span class="bp">.</span><span class="n">map_mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="err">≃</span><span class="bp">*</span><span class="err">&#39;</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">y</span>
<span class="o">:=</span> <span class="n">mul_equiv&#39;</span><span class="bp">.</span><span class="n">map_mul&#39;</span>

<span class="c1">-- now need reflexive, symmetric and transitive</span>

<span class="kn">namespace</span> <span class="n">mul_equiv&#39;</span>

<span class="bp">@</span><span class="o">[</span><span class="n">refl</span><span class="o">]</span> <span class="n">def</span> <span class="n">refl</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">α</span> <span class="err">≃</span><span class="bp">*</span><span class="err">&#39;</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">map_mul&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span>
<span class="bp">..</span><span class="n">equiv</span><span class="bp">.</span><span class="n">refl</span> <span class="n">α</span><span class="o">}</span>

<span class="c1">-- this one did not go so well.</span>
<span class="bp">@</span><span class="o">[</span><span class="n">symm</span><span class="o">]</span> <span class="n">def</span> <span class="n">symm</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">α</span> <span class="err">≃</span><span class="bp">*</span><span class="err">&#39;</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">β</span> <span class="err">≃</span><span class="bp">*</span><span class="err">&#39;</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">map_mul&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">n₁</span> <span class="n">n₂</span><span class="o">,</span> <span class="n">function</span><span class="bp">.</span><span class="n">injective_of_left_inverse</span> <span class="n">h</span><span class="bp">.</span><span class="n">left_inv</span> <span class="k">begin</span>
    <span class="k">show</span> <span class="n">h</span><span class="bp">.</span><span class="n">to_fun</span> <span class="o">(</span><span class="n">h</span><span class="bp">.</span><span class="n">inv_fun</span> <span class="o">(</span><span class="n">n₁</span> <span class="bp">*</span> <span class="n">n₂</span><span class="o">))</span> <span class="bp">=</span>
    <span class="n">h</span> <span class="o">(</span><span class="n">h</span><span class="bp">.</span><span class="n">inv_fun</span> <span class="n">n₁</span> <span class="bp">*</span> <span class="n">h</span><span class="bp">.</span><span class="n">inv_fun</span> <span class="n">n₂</span><span class="o">),</span> <span class="c1">-- annoying to have to `show`</span>
    <span class="n">rw</span> <span class="n">h</span><span class="bp">.</span><span class="n">right_inv</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">h</span><span class="bp">.</span><span class="n">map_mul</span><span class="o">,</span>
    <span class="n">convert</span> <span class="n">rfl</span><span class="o">,</span> <span class="c1">-- annoying to have to `convert`. This should surely just be rewrites.</span>
      <span class="n">exact</span> <span class="n">h</span><span class="bp">.</span><span class="n">right_inv</span> <span class="bp">_</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">h</span><span class="bp">.</span><span class="n">right_inv</span> <span class="bp">_</span><span class="o">,</span>
  <span class="kn">end</span><span class="o">,</span>
  <span class="bp">..</span><span class="n">h</span><span class="bp">.</span><span class="n">to_equiv</span><span class="bp">.</span><span class="n">symm</span><span class="o">}</span>

<span class="bp">@</span><span class="o">[</span><span class="n">trans</span><span class="o">]</span> <span class="n">def</span> <span class="n">trans</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">α</span> <span class="err">≃</span><span class="bp">*</span><span class="err">&#39;</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">β</span> <span class="err">≃</span><span class="bp">*</span><span class="err">&#39;</span> <span class="n">γ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">α</span> <span class="err">≃</span><span class="bp">*</span><span class="err">&#39;</span> <span class="n">γ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">map_mul&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
    <span class="k">show</span> <span class="n">h2</span> <span class="o">(</span><span class="n">h1</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">))</span> <span class="bp">=</span> <span class="n">h2</span> <span class="o">(</span><span class="n">h1</span> <span class="n">x</span><span class="o">)</span> <span class="bp">*</span> <span class="n">h2</span> <span class="o">(</span><span class="n">h1</span> <span class="n">y</span><span class="o">),</span>
    <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">h1</span><span class="bp">.</span><span class="n">map_mul</span><span class="o">,</span> <span class="n">h2</span><span class="bp">.</span><span class="n">map_mul</span><span class="o">],</span>
  <span class="bp">..</span><span class="n">equiv</span><span class="bp">.</span><span class="n">trans</span> <span class="n">h1</span><span class="bp">.</span><span class="n">to_equiv</span> <span class="n">h2</span><span class="bp">.</span><span class="n">to_equiv</span> <span class="o">}</span>

<span class="c1">-- an ≃*&#39; is a hom</span>
<span class="n">def</span> <span class="n">equiv&#39;</span><span class="bp">.</span><span class="n">to_hom</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">M</span> <span class="err">≃</span><span class="bp">*</span><span class="err">&#39;</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→*</span> <span class="n">N</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">h</span><span class="bp">.</span><span class="n">to_equiv</span><span class="o">,</span>
    <span class="n">map_mul&#39;</span> <span class="o">:=</span> <span class="n">h</span><span class="bp">.</span><span class="n">map_mul&#39;</span>
  <span class="o">}</span>

<span class="n">def</span> <span class="n">equiv&#39;</span><span class="bp">.</span><span class="n">inv_hom</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">M</span> <span class="err">≃</span><span class="bp">*</span><span class="err">&#39;</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">N</span> <span class="bp">→*</span> <span class="n">M</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">h</span><span class="bp">.</span><span class="n">symm</span><span class="bp">.</span><span class="n">to_equiv</span><span class="o">,</span>
  <span class="n">map_mul&#39;</span> <span class="o">:=</span> <span class="n">h</span><span class="bp">.</span><span class="n">symm</span><span class="bp">.</span><span class="n">map_mul</span>
  <span class="o">}</span>

<span class="kn">end</span> <span class="n">mul_equiv&#39;</span>
</pre></div>


<p><code>equiv'.symm</code> didn't go well but most of the other stuff looks OK to me</p>

<a name="171140287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171140287" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171140287">Mario Carneiro (Jul 18 2019 at 06:00)</a>:</h4>
<p>People will complain about the order of arguments to <code>comp</code></p>

<a name="171140312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171140312" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171140312">Johan Commelin (Jul 18 2019 at 06:01)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> You probably know this but <code>mul_hom.map_mul</code> should be a <em>lemma</em>, and it is a very good simp-lemma.</p>

<a name="171140315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171140315" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171140315">Mario Carneiro (Jul 18 2019 at 06:01)</a>:</h4>
<p>What's wrong with <code>symm</code>? It looks like that's the sort of thing that is mathematically substantive anyway</p>

<a name="171140359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171140359" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171140359">Johan Commelin (Jul 18 2019 at 06:02)</a>:</h4>
<p>In fact, that's the most important reason for bundling in the first place. That this is a simp-lemma that actually triggers.</p>

<a name="171140363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171140363" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171140363">Johan Commelin (Jul 18 2019 at 06:02)</a>:</h4>
<p>Also, we'll want simp-lemmas <code>id_apply</code> and <code>comp_apply</code>.</p>

<a name="171141338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171141338" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171141338">Kevin Buzzard (Jul 18 2019 at 06:25)</a>:</h4>
<blockquote>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> You probably know this but <code>mul_hom.map_mul</code> should be a <em>lemma</em>, and it is a very good simp-lemma.</p>
</blockquote>
<p>I'm not very good at <code>simp</code> still.</p>

<a name="171161924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171161924" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171161924">Kevin Buzzard (Jul 18 2019 at 11:49)</a>:</h4>
<p>So anyway, there is a bunch of structure most of which is correctly named, and hopefully defined sensibly.  Do we want all all of this in mathlib? And then there's the equivalent stuff for <code>semigroup</code>, for <code>monoid</code> and for <code>group</code>. I don't care about the <code>mul</code> stuff really, I was just practicing. I <em>do</em> care about equivs of monoids and of groups and would like some students to prepare a mathlib PR. </p>
<p>What are we looking for in such a PR? Should the students try and define everything for <code>semigroup</code> when we don't really need it? Is a PR of this nature for <code>group</code> welcome? <span class="user-mention" data-user-id="110044">@Chris Hughes</span> do you have any opinions on this? I've talked to you before about it and you seem to have a clear head about what should be there.</p>

<a name="171161956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171161956" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171161956">Kevin Buzzard (Jul 18 2019 at 11:50)</a>:</h4>
<p>Note that we can define <code>group.hom</code> to be <code>mul_hom</code></p>

<a name="171161995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171161995" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171161995">Kevin Buzzard (Jul 18 2019 at 11:50)</a>:</h4>
<p>I think the last time we talked about this, you liked that idea.</p>

<a name="171163113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171163113" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171163113">Chris Hughes (Jul 18 2019 at 12:08)</a>:</h4>
<p>Don't bother with <code>semigroup</code> stuff unless it's virtually no effort. I'd actually prefer <code>group_hom</code> and <code>monoid_hom</code> to be the same, since these are the two that are actually used. You could write a custom constructor without the unnecessary axiom.</p>
<p>Same idea goes for <code>ring_hom</code> and <code>semiring_hom</code></p>

<a name="171163615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171163615" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171163615">Kevin Buzzard (Jul 18 2019 at 12:16)</a>:</h4>
<p>so you're saying you want <code>group.hom</code> to be called <code>group_hom</code> and to demand that <code>f(1)=1</code>?</p>

<a name="171163633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171163633" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171163633">Kevin Buzzard (Jul 18 2019 at 12:16)</a>:</h4>
<p>What should the custom constructor be called?</p>

<a name="171164305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171164305" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171164305">Chris Hughes (Jul 18 2019 at 12:26)</a>:</h4>
<p>Yes <code>@[reducible] def group_hom := monoid_hom</code>. </p>
<p><code>group_hom.mk</code></p>

<a name="171164339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171164339" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171164339">Chris Hughes (Jul 18 2019 at 12:27)</a>:</h4>
<p>That way, simp lemmas you prove about <code>monoid_hom</code>s will work with group homs.</p>

<a name="171195355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171195355" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171195355">Kevin Buzzard (Jul 18 2019 at 18:15)</a>:</h4>
<p>And should this be reducible too? [sorry for prime on mul_equiv, mathlib has a slightly more unbundled one]</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">monoid_equiv</span> <span class="o">(</span><span class="n">M</span> <span class="n">N</span><span class="o">)</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">N</span><span class="o">]</span> <span class="o">:=</span> <span class="n">mul_equiv&#39;</span> <span class="n">M</span> <span class="n">N</span>
</pre></div>

<a name="171195654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171195654" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171195654">Johan Commelin (Jul 18 2019 at 18:18)</a>:</h4>
<p>Is it clear that making some of these definitions does not create leakage?</p>

<a name="171195706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171195706" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171195706">Kevin Buzzard (Jul 18 2019 at 18:19)</a>:</h4>
<p>I am just experimenting. I will certainly report back.</p>

<a name="171195897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171195897" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171195897">Johan Commelin (Jul 18 2019 at 18:21)</a>:</h4>
<p>Also, I think Lean is quite bad at dealing with situations like this:<br>
I have <code>M1 M2 : Type</code> and <code>[monoid M1] [monoid M2]</code><br>
I also have <code>f : monoid_hom M1 M2</code>.<br>
Then, for some reason, it happens that I can actually prove that <code>M1</code> and <code>M2</code> are groups.<br>
Now I need to work to turn <code>f</code> into a group hom. And if I don't do that, certain lemma's can't be applied, and <code>simp</code> gets stuck etc...</p>

<a name="171195995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171195995" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171195995">Kevin Buzzard (Jul 18 2019 at 18:22)</a>:</h4>
<p>This won't happen with Chris' suggesting of defining <code>group_hom</code> to be equal to <code>monoid_hom</code></p>

<a name="171196002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171196002" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171196002">Johan Commelin (Jul 18 2019 at 18:22)</a>:</h4>
<p>I know it is not very beginner-friendly. But I'm becoming more and more of the opinion that we shouldn't have these "shadowing" classes. Like <code>vector_space</code> (and even <code>module</code>). And so, maybe we should also just get rid of <code>group_hom</code>s</p>

<a name="171196013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171196013" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171196013">Johan Commelin (Jul 18 2019 at 18:22)</a>:</h4>
<p>Nope, that's not true.</p>

<a name="171196022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171196022" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171196022">Kevin Buzzard (Jul 18 2019 at 18:22)</a>:</h4>
<p>and making it reducible</p>

<a name="171196045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171196045" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171196045">Johan Commelin (Jul 18 2019 at 18:22)</a>:</h4>
<p>If I have a module over a field, I can't apply linear algebra results.</p>

<a name="171196071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171196071" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171196071">Johan Commelin (Jul 18 2019 at 18:23)</a>:</h4>
<p>Even if <code>vector_space</code> is reducibly defined to be a module.</p>

<a name="171196081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171196081" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171196081">Johan Commelin (Jul 18 2019 at 18:23)</a>:</h4>
<p>This has bitten me several times.</p>

<a name="171196137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171196137" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171196137">Kevin Buzzard (Jul 18 2019 at 18:24)</a>:</h4>
<p>We need some way of being able to talk about group homomorphisms. What is your suggestion? Unbundled homs? I thought this had problems too?</p>

<a name="171196206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171196206" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171196206">Johan Commelin (Jul 18 2019 at 18:24)</a>:</h4>
<p>No, it's somewhat orthogonal to bundling, but it's very much related to refactoring.</p>

<a name="171196222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171196222" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171196222">Johan Commelin (Jul 18 2019 at 18:24)</a>:</h4>
<p>I want to propose/discuss just ditching <code>group_hom</code> altogether.</p>

<a name="171196270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171196270" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171196270">Johan Commelin (Jul 18 2019 at 18:25)</a>:</h4>
<p>Just write <code>monoid_hom.mk'</code> for the case that you construct monoid homs between groups.</p>

<a name="171196299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171196299" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171196299">Johan Commelin (Jul 18 2019 at 18:25)</a>:</h4>
<p>It doesn't look nice... but it is more flexible.</p>

<a name="171196390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171196390" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171196390">Kevin Buzzard (Jul 18 2019 at 18:26)</a>:</h4>
<blockquote>
<p>This has bitten me several times.</p>
</blockquote>
<p>If you try to fix it by making the actual object you want from the object you have (e.g. the vector space over the field from the module), then you then have two objects which mathematicians find completely indistinguishable, but for which Lean finds it hard to port results about one object to results from the other. This sounds like a good place to try out a transfer tactic, no?</p>

<a name="171196448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171196448" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171196448">Johan Commelin (Jul 18 2019 at 18:27)</a>:</h4>
<p>Meh... I would rather let the problem go away.</p>

<a name="171196468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171196468" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171196468">Johan Commelin (Jul 18 2019 at 18:27)</a>:</h4>
<p>Maybe <code>group_hom</code> can be an <code>abbreviation</code>?? I still don't know what this does exactly.</p>

<a name="171196531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171196531" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171196531">Johan Commelin (Jul 18 2019 at 18:28)</a>:</h4>
<p>But it seems to be something like <code>hyper-super-duper-reducible</code>.</p>

<a name="171196542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171196542" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171196542">Chris Hughes (Jul 18 2019 at 18:28)</a>:</h4>
<blockquote>
<p>And should this be reducible too? [sorry for prime on mul_equiv, mathlib has a slightly more unbundled one]</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">monoid_equiv</span> <span class="o">(</span><span class="n">M</span> <span class="n">N</span><span class="o">)</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">N</span><span class="o">]</span> <span class="o">:=</span> <span class="n">mul_equiv&#39;</span> <span class="n">M</span> <span class="n">N</span>
</pre></div>


</blockquote>
<p>That shouldn't exist</p>

<a name="171196594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171196594" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171196594">Johan Commelin (Jul 18 2019 at 18:29)</a>:</h4>
<p>For the same reason that <code>vector_space</code> shouldn't exist?</p>

<a name="171197093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171197093" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171197093">Kevin Buzzard (Jul 18 2019 at 18:34)</a>:</h4>
<blockquote>
<p>I want to propose/discuss just ditching <code>group_hom</code> altogether.</p>
</blockquote>
<p>If we ditch <code>group_hom</code> altogether, what will be the canonical way of representing the concept of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>:</mo><mi>G</mi><mo>→</mo><mi>H</mi></mrow><annotation encoding="application/x-tex">f:G\to H</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span></span></span></span> with <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(xy)=f(x)f(y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> with <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span></span></span></span> groups?</p>

<a name="171197171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171197171" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171197171">Kevin Buzzard (Jul 18 2019 at 18:35)</a>:</h4>
<blockquote>
<blockquote>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">monoid_equiv</span> <span class="o">(</span><span class="n">M</span> <span class="n">N</span><span class="o">)</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">N</span><span class="o">]</span> <span class="o">:=</span> <span class="n">mul_equiv&#39;</span> <span class="n">M</span> <span class="n">N</span>
</pre></div>


</blockquote>
<p>That shouldn't exist</p>
</blockquote>
<p>If that doesn't exist <em>at all</em>, then what happens to the poor newbie who shows up with their two monoids and wants to know where the equiv is?</p>

<a name="171197298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171197298" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171197298">Johan Commelin (Jul 18 2019 at 18:37)</a>:</h4>
<p>We tell them to use <code>M1 =* M2</code>.</p>

<a name="171197330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171197330" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171197330">Johan Commelin (Jul 18 2019 at 18:37)</a>:</h4>
<p>If we ditch <code>group_hom</code> you just write <code>f : G →m H</code></p>

<a name="171197341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171197341" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171197341">Johan Commelin (Jul 18 2019 at 18:37)</a>:</h4>
<p>Or whatever the notation for monoid homs will be.</p>

<a name="171197626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171197626" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171197626">Chris Hughes (Jul 18 2019 at 18:41)</a>:</h4>
<p>I started on <code>-&gt;1*</code>, but I propose <code>-&gt;*</code>, and screw mul homs notation.</p>

<a name="171200197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171200197" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171200197">Kevin Buzzard (Jul 18 2019 at 19:11)</a>:</h4>
<p>So notation can attempt to solve the issue. Chris are you proposing the notation with no 1 to be overloaded? I am mostly interested in group homs and isoms because a student of mine needs them asap</p>

<a name="171200648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171200648" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171200648">Chris Hughes (Jul 18 2019 at 19:16)</a>:</h4>
<p>I'm proposing no notation for mul homs, since they're rarely used.</p>

<a name="171205025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171205025" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171205025">Kevin Buzzard (Jul 18 2019 at 20:12)</a>:</h4>
<p>then what term is <code>-&gt;*</code> notation for?</p>

<a name="171205059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171205059" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171205059">Kevin Buzzard (Jul 18 2019 at 20:12)</a>:</h4>
<p>I am happy to implement your idea but I don't understand it yet. I would just like isomorphisms and bundled homomorphisms of groups sooner rather than later.</p>

<a name="171205087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171205087" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171205087">Kevin Buzzard (Jul 18 2019 at 20:13)</a>:</h4>
<p>I want to do more experiments with the bundled morphisms approach.</p>

<a name="171205114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171205114" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171205114">Chris Hughes (Jul 18 2019 at 20:13)</a>:</h4>
<p>monoid homs</p>

<a name="171205228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171205228" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171205228">Kevin Buzzard (Jul 18 2019 at 20:14)</a>:</h4>
<p>A monoid hom has this extra condition that 1 goes to 1. So we define <code>monoid_hom</code>, and we can make <code>\equiv\_g</code> be notation for <code>monoid_hom</code>.</p>

<a name="171205262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171205262" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171205262">Johan Commelin (Jul 18 2019 at 20:15)</a>:</h4>
<p>Sure, so Chris is saying <code>→*</code> for monoid homs and group homs. No notation for <code>mul_hom</code>.</p>

<a name="171205276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171205276" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171205276">Kevin Buzzard (Jul 18 2019 at 20:15)</a>:</h4>
<p>and we could also make <code>\equiv\_m</code> be notation for <code>monoid_hom</code> for when we're working with moniods, and then Lean's prettyprinter would have an impossible notation problem to solve.</p>

<a name="171205291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171205291" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171205291">Johan Commelin (Jul 18 2019 at 20:15)</a>:</h4>
<p>And <code>\equiv*</code> might be a nice fit for <code>mul_equiv</code> (and we don't need <code>monoid_equiv</code> or <code>group_equiv</code>).</p>

<a name="171205394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171205394" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171205394">Kevin Buzzard (Jul 18 2019 at 20:16)</a>:</h4>
<p>So we just tell the user in comments in the group section: "the notation for group homomorphisms is <code>-&gt;*</code> and the notation for group isomorphisms is <code>\equiv*</code>"</p>

<a name="171205428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171205428" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171205428">Johan Commelin (Jul 18 2019 at 20:17)</a>:</h4>
<p>Sure... and because the notation is somewhat natural it is even avoiding the awkard <code>f : monoid_hom G H</code> for group homs.</p>

<a name="171205435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171205435" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171205435">Johan Commelin (Jul 18 2019 at 20:17)</a>:</h4>
<p>I think this is quite a nice solution.</p>

<a name="171205545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171205545" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171205545">Kevin Buzzard (Jul 18 2019 at 20:19)</a>:</h4>
<p>That's quite interesting that the force of the mathematical interpretation <code>-&gt;*</code> is "I preserve everything relevant to multiplication that is present"</p>

<a name="171205587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171205587" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171205587">Johan Commelin (Jul 18 2019 at 20:19)</a>:</h4>
<p>The special constructor could be</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">group_hom</span> <span class="o">{</span><span class="n">G</span> <span class="n">H</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">group</span> <span class="n">H</span><span class="o">]</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span><span class="bp">*</span><span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→*</span> <span class="n">H</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>

<a name="171205607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171205607" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171205607">Kevin Buzzard (Jul 18 2019 at 20:20)</a>:</h4>
<p>If you defined monoids to mathematicians and then said "OK now what do you think <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><msup><mo>→</mo><mo>∗</mo></msup><mi>N</mi></mrow><annotation encoding="application/x-tex">M\to^*N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel">→</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> means?" they'd be like "monoid hom I guess"</p>

<a name="171205656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171205656" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171205656">Johan Commelin (Jul 18 2019 at 20:20)</a>:</h4>
<p>(That example didn't type check, but you get the idea.)</p>

<a name="171205696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171205696" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171205696">Kevin Buzzard (Jul 18 2019 at 20:21)</a>:</h4>
<p>But Chris seems to be explictly suggesting that the name <code>group_hom</code> is never assigned. Is this what you think <span class="user-mention" data-user-id="110044">@Chris Hughes</span> ?</p>

<a name="171205723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171205723" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171205723">Johan Commelin (Jul 18 2019 at 20:21)</a>:</h4>
<p>What I'm saying is that <code>monoid_hom.mk</code> is a bad name for constructing monoid homs between groups.</p>

<a name="171205791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171205791" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171205791">Kevin Buzzard (Jul 18 2019 at 20:22)</a>:</h4>
<p>These are all such irrelevances, there must be some solution with automation or something. Mathematically we are doing absolutely nothing at all.</p>

<a name="171205833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171205833" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171205833">Johan Commelin (Jul 18 2019 at 20:22)</a>:</h4>
<p>I've been saying time and again that Fabian can auto-generate all of these.</p>

<a name="171205839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171205839" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171205839">Johan Commelin (Jul 18 2019 at 20:22)</a>:</h4>
<p>But people don't really seem to care.</p>

<a name="171206136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171206136" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171206136">Kevin Buzzard (Jul 18 2019 at 20:26)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> we need computer science help. We have a very rigorous notion of "the same" here -- this seems to me like this is type class inference in a tangle. Do you understand why we are struggling? Why can't Johan do linear algebra with a module over a field? <span class="user-mention" data-user-id="112680">@Johan Commelin</span>  can you give a MWE? We need to get good at this.</p>

<a name="171207184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171207184" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171207184">Mario Carneiro (Jul 18 2019 at 20:41)</a>:</h4>
<p>I think that more names for the same thing is bad for formalization, although I understand why it is mathematically desirable. I am on board with Chris's suggestions</p>

<a name="171207355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171207355" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171207355">Kevin Buzzard (Jul 18 2019 at 20:44)</a>:</h4>
<p>We also need the <code>additive</code> version of everything, I suppose? That entire process can be automated. Can you literally to a regex on the file to generate its additive version? And then you can look observe the funny fact that there are two olean files which are exactly the same</p>

<a name="171207395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171207395" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171207395">Mario Carneiro (Jul 18 2019 at 20:44)</a>:</h4>
<p>While I don't want to minimize Fabian's work, the proofs are not the hard part here. This is all API design questions</p>

<a name="171207424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171207424" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171207424">Kevin Buzzard (Jul 18 2019 at 20:44)</a>:</h4>
<p>Right. I'm trying really hard to make a mathematician's API.</p>

<a name="171207460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171207460" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171207460">Kevin Buzzard (Jul 18 2019 at 20:45)</a>:</h4>
<p>I now have a much better understanding of the issues here and I think it's a really important question for drawing mathematicians in. We want to make it look easy.</p>

<a name="171207636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171207636" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171207636">Kevin Buzzard (Jul 18 2019 at 20:47)</a>:</h4>
<p>I think we might be losing half our audience at</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">what</span> <span class="n">does</span> <span class="n">all</span> <span class="n">this</span> <span class="n">weird</span> <span class="n">stuff</span> <span class="n">mean</span>
</pre></div>


<p>We just want to say "The naturals are <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">N</span></span></span></span></span>, typed <code>\N</code> and they work exactly as you would expect them to". Implementing this is not a trivial thing at all!</p>

<a name="171207846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171207846" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171207846">Mario Carneiro (Jul 18 2019 at 20:50)</a>:</h4>
<p>I heartily disagree</p>

<a name="171207866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171207866" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171207866">Kevin Buzzard (Jul 18 2019 at 20:50)</a>:</h4>
<p>"It goes without saying that if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> are isomorphic <code>comm_ring</code>s then <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> is Gorenstein iff <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> is. It does not need a proof. "</p>

<a name="171207881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171207881" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171207881">Kevin Buzzard (Jul 18 2019 at 20:50)</a>:</h4>
<p>that one is not proving trivial to implement</p>

<a name="171207901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171207901" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171207901">Mario Carneiro (Jul 18 2019 at 20:50)</a>:</h4>
<p>hardcoding what "they work exactly as you would expect" means is just making lean more "magical" and less comprehensible</p>

<a name="171207910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171207910" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171207910">Mario Carneiro (Jul 18 2019 at 20:51)</a>:</h4>
<p>which is setting yourself up for failure</p>

<a name="171207959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171207959" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171207959">Kevin Buzzard (Jul 18 2019 at 20:51)</a>:</h4>
<p>You guys worry too much about these tedious implementation issues</p>

<a name="171208007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171208007" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171208007">Mario Carneiro (Jul 18 2019 at 20:52)</a>:</h4>
<p>That's not an implementation issue, it's a pedagogy issue</p>

<a name="171208014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171208014" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171208014">Kevin Buzzard (Jul 18 2019 at 20:52)</a>:</h4>
<p>We're never going to run the code we're making, you don't need to optimise it</p>

<a name="171208031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171208031" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171208031">Kevin Buzzard (Jul 18 2019 at 20:52)</a>:</h4>
<p>We just want to eat every proposition and every proof bit by bit</p>

<a name="171208037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171208037" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171208037">Mario Carneiro (Jul 18 2019 at 20:52)</a>:</h4>
<p>if lean has tons of special cases then it's big and complicated to learn. This is not an exaggeration, it's already the case</p>

<a name="171208306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171208306" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171208306">Mario Carneiro (Jul 18 2019 at 20:56)</a>:</h4>
<p>implementing <code>transfer</code> is hard because type theory is big and complicated</p>

<a name="171208404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171208404" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171208404">Kevin Buzzard (Jul 18 2019 at 20:57)</a>:</h4>
<p>You should just solve it with pointers or something</p>

<a name="171208783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171208783" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171208783">Mario Carneiro (Jul 18 2019 at 21:03)</a>:</h4>
<p><span aria-label="expressionless" class="emoji emoji-1f611" role="img" title="expressionless">:expressionless:</span></p>

<a name="171208911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171208911" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171208911">Mario Carneiro (Jul 18 2019 at 21:05)</a>:</h4>
<p>That said, <code>transfer</code> is already implemented and mostly works. As I've said many times, what is needed is not a tactic but lemmas for it to use</p>

<a name="171209157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171209157" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171209157">Kevin Buzzard (Jul 18 2019 at 21:08)</a>:</h4>
<p>So mathematicians have a gigantic list of abstract mathematical ideas. And for each of these ideas computer scientists have developed some term in type theory, or perhaps some token (the mathematical symbol of isomorphism comes to mind), and said "look here it is", and then we say "Thanks. Does it do this, this, that and this?" and you guys go "Yes of course. And it does a gazillion other things too like look you can see inside it and you can do that if you want" and we say "no thanks, we just need this this that and this. We will now promise that any future terms will be built using that interface. In return, you must understand our notion of equality, which you can work out from the interface I suppose"</p>
<p>Examples: the real numbers, a group, the localisation of a ring, the module of one-forms for an algebra over a ring, or a sheaf on a space.</p>

<a name="171209258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171209258" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171209258">Mario Carneiro (Jul 18 2019 at 21:09)</a>:</h4>
<p>Except that sometimes you break the interface and pretend you didn't</p>

<a name="171209368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171209368" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171209368">Mario Carneiro (Jul 18 2019 at 21:11)</a>:</h4>
<p>Reading the MO question I was amused that no one noticed that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="double-struck">R</mi><mo>⊆</mo><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\Bbb R\subseteq\Bbb C</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.82486em;vertical-align:-0.13597em;"></span><span class="mord mathbb">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord mathbb">C</span></span></span></span> is not an isomorphism-invariant statement. They say "we know isomorphisms don't matter so we may as well assume it's the case" but then it's not isomorphism invariant anymore</p>

<a name="171209485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171209485" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171209485">Kevin Buzzard (Jul 18 2019 at 21:12)</a>:</h4>
<p>I find those endless comments very hard to read.</p>

<a name="171209570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171209570" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171209570">Mario Carneiro (Jul 18 2019 at 21:13)</a>:</h4>
<p>I think that statement showed up in one of the answers</p>

<a name="171209585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171209585" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171209585">Kevin Buzzard (Jul 18 2019 at 21:13)</a>:</h4>
<p>Was it the one I accepted?</p>

<a name="171209699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171209699" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171209699">Mario Carneiro (Jul 18 2019 at 21:15)</a>:</h4>
<p><a href="https://mathoverflow.net/a/336233/34444" target="_blank" title="https://mathoverflow.net/a/336233/34444">https://mathoverflow.net/a/336233/34444</a></p>

<a name="171209790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171209790" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171209790">Mario Carneiro (Jul 18 2019 at 21:16)</a>:</h4>
<blockquote>
<p>Relatedly, we can assume that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="double-struck">R</mi><mo>⊆</mo><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\Bbb R\subseteq\Bbb C</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.82486em;vertical-align:-0.13597em;"></span><span class="mord mathbb">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord mathbb">C</span></span></span></span> because we only care about the axiomatized properties of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\Bbb R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord mathbb">R</span></span></span></span>, which are preserved under isomorphism. One could manually preserve the original <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\Bbb R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord mathbb">R</span></span></span></span> as an actual subset of its quadratic extension, but that is unnecessary for the reason I just stated.</p>
</blockquote>
<p>This reasoning fails to take into account that by taking advantage of isomorphism invariance you break it</p>

<a name="171209797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171209797" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171209797">Kevin Buzzard (Jul 18 2019 at 21:16)</a>:</h4>
<p>There are also two deleted answers with positive scores which degenerated into flamewars resulting in the OP just deleting everything</p>

<a name="171209818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171209818" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171209818">Mario Carneiro (Jul 18 2019 at 21:17)</a>:</h4>
<p>I saw the comment but I'm not high rep on MO so I can't read it :(</p>

<a name="171209828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171209828" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171209828">Mario Carneiro (Jul 18 2019 at 21:17)</a>:</h4>
<p>Andrej usually has interesting things to say</p>

<a name="171210056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171210056" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171210056">Mario Carneiro (Jul 18 2019 at 21:20)</a>:</h4>
<p>To me the process is tedious but straightforward. We need <code>equiv.rel</code> in mathlib, and then a bunch of isomorphism builders, and a bunch of isomorphism statements, and then this will be easy</p>

<a name="171210162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171210162" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171210162">Mario Carneiro (Jul 18 2019 at 21:22)</a>:</h4>
<p>Don't come to me about making a tactic to do it until you've already done it 10 times and know what it looks like</p>

<a name="171210188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171210188" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171210188">Kevin Buzzard (Jul 18 2019 at 21:22)</a>:</h4>
<p>I think Andrej and I follow each other on Twitter; I'll prod him.</p>

<a name="171210886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171210886" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171210886">Kevin Buzzard (Jul 18 2019 at 21:32)</a>:</h4>
<p>What is the role that this predicate should play? We define the Cauchy reals, and we prove that they are a complete arch field, and then we prove that any two complete arch fields are uniquely isomorphic as ordered fields. We then have this type <code>real</code> and this promise that we will only use <code>complete_archimedean_ordered_field real</code> or whatever. We have given you a precise interface here. What you now need to do somehow is to make this a primitive object -- I would quite happily be in an environment where the real type and its instance as a complete archimedean ordered field was some structure and a bunch of axioms. Why can't we use this abstraction for the reals and only have access to this interface?</p>

<a name="171210999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171210999" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171210999">Kevin Buzzard (Jul 18 2019 at 21:34)</a>:</h4>
<p>It would presumably be easier to reason about proof transportability if you knew the proof had stuck to the interface.</p>

<a name="171211008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211008" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211008">Mario Carneiro (Jul 18 2019 at 21:34)</a>:</h4>
<p>I'm talking about transfer specifically. This is independent of any interface to the reals you may or may not be adhering to</p>

<a name="171211014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211014" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211014">Kevin Buzzard (Jul 18 2019 at 21:34)</a>:</h4>
<p>I want a little bit of HoTT magic at exactly this point</p>

<a name="171211022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211022" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211022">Kevin Buzzard (Jul 18 2019 at 21:34)</a>:</h4>
<p>So tell me again what transfer specifically means?</p>

<a name="171211046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211046" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211046">Mario Carneiro (Jul 18 2019 at 21:35)</a>:</h4>
<blockquote>
<p>To me the process is tedious but straightforward. We need <code>equiv.rel</code> in mathlib, and then a bunch of isomorphism builders, and a bunch of isomorphism statements, and then this will be easy</p>
</blockquote>

<a name="171211077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211077" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211077">Mario Carneiro (Jul 18 2019 at 21:36)</a>:</h4>
<p>The only way to get, provably in lean, invariance from syntax generically is if you have a deeply embedded language and express all your properties in that language. I'm sure we don't want to do that</p>

<a name="171211123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211123" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211123">Kevin Buzzard (Jul 18 2019 at 21:36)</a>:</h4>
<p>Will this tedious but straightforward process be easier to do in Lean 4?</p>

<a name="171211143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211143" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211143">Mario Carneiro (Jul 18 2019 at 21:36)</a>:</h4>
<p>not particularly</p>

<a name="171211156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211156" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211156">Kevin Buzzard (Jul 18 2019 at 21:36)</a>:</h4>
<p>So we may as well start right away :-)</p>

<a name="171211181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211181" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211181">Mario Carneiro (Jul 18 2019 at 21:37)</a>:</h4>
<p>like I said, stop thinking of tactics and start thinking about the problem</p>

<a name="171211212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211212" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211212">Kevin Buzzard (Jul 18 2019 at 21:37)</a>:</h4>
<p>Isn't the immediate problem that someone has to write some meta code?</p>

<a name="171211217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211217" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211217">Mario Carneiro (Jul 18 2019 at 21:37)</a>:</h4>
<p>Once you know what the problem is and what the solution is the tactic writes itself</p>

<a name="171211219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211219" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211219">Mario Carneiro (Jul 18 2019 at 21:37)</a>:</h4>
<p>no</p>

<a name="171211232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211232" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211232">Mario Carneiro (Jul 18 2019 at 21:37)</a>:</h4>
<p>meta code comes later</p>

<a name="171211235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211235" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211235">Mario Carneiro (Jul 18 2019 at 21:38)</a>:</h4>
<p>proofs come first</p>

<a name="171211403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211403" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211403">Mario Carneiro (Jul 18 2019 at 21:40)</a>:</h4>
<p>Tactics never allow you to prove something you couldn't prove before. They just make it easier to do things you already knew how to do</p>

<a name="171211411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211411" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211411">Kevin Buzzard (Jul 18 2019 at 21:40)</a>:</h4>
<p>So maybe a tactic which does this would be interesting: I will define the Dedekind reals in Lean, prove they're a complete arch ordered field, and then demand from you a copy of the Bochner integral but all with Dedekind reals instead of Cauchy reals.</p>

<a name="171211423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211423" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211423">Kevin Buzzard (Jul 18 2019 at 21:40)</a>:</h4>
<p>Do I "know how to do that"? Is this one we're going to solve with tags?</p>

<a name="171211444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211444" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211444">Mario Carneiro (Jul 18 2019 at 21:41)</a>:</h4>
<p>You don't, that's the problem</p>

<a name="171211458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211458" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211458">Kevin Buzzard (Jul 18 2019 at 21:41)</a>:</h4>
<p>the idea is that any PR to mathlib which didn't use the allowable interface would not be accepted.</p>

<a name="171211483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211483" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211483">Kevin Buzzard (Jul 18 2019 at 21:42)</a>:</h4>
<p>So you just have to write some regex to check that people aren't fiddling with the real's privates</p>

<a name="171211533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211533" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211533">Kevin Buzzard (Jul 18 2019 at 21:42)</a>:</h4>
<p>and run all PR's through the regex to check for safety</p>

<a name="171211542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211542" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211542">Mario Carneiro (Jul 18 2019 at 21:42)</a>:</h4>
<p>The safety check is not the problem, the equivalence proofs are</p>

<a name="171211551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211551" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211551">Kevin Buzzard (Jul 18 2019 at 21:42)</a>:</h4>
<p>and if they pass you can accept the PR and then some Lean code generates a proof that all the stuff in mathlib is still "safe"</p>

<a name="171211570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211570" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211570">Mario Carneiro (Jul 18 2019 at 21:43)</a>:</h4>
<p>Even if we know everything is safe that doesn't provide a proof of equivalence</p>

<a name="171211576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211576" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211576">Kevin Buzzard (Jul 18 2019 at 21:43)</a>:</h4>
<p>So what formally is the problem?</p>

<a name="171211616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211616" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211616">Mario Carneiro (Jul 18 2019 at 21:43)</a>:</h4>
<p>You have already stated it: Given a concrete predicate P on rings prove that if A and B are isomorphic rings then P(A) iff P(B)</p>

<a name="171211617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211617" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211617">Kevin Buzzard (Jul 18 2019 at 21:43)</a>:</h4>
<p>Surely it provides a proof that the term exists, it just doesn't actually make the term.</p>

<a name="171211673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211673" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211673">Kevin Buzzard (Jul 18 2019 at 21:44)</a>:</h4>
<p>Why isn't that P(A) iff P(B) thing easy?</p>

<a name="171211685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211685" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211685">Mario Carneiro (Jul 18 2019 at 21:44)</a>:</h4>
<p>It is</p>

<a name="171211690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211690" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211690">Kevin Buzzard (Jul 18 2019 at 21:44)</a>:</h4>
<p>You just peel P apart and do it by induction</p>

<a name="171211693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211693" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211693">Mario Carneiro (Jul 18 2019 at 21:44)</a>:</h4>
<p>Yes, so do it</p>

<a name="171211695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211695" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211695">Kevin Buzzard (Jul 18 2019 at 21:44)</a>:</h4>
<p>You mean it's hard to implement?</p>

<a name="171211700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211700" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211700">Mario Carneiro (Jul 18 2019 at 21:44)</a>:</h4>
<p>No, it's easy</p>

<a name="171211705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211705" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211705">Mario Carneiro (Jul 18 2019 at 21:44)</a>:</h4>
<p>but it's work</p>

<a name="171211709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211709" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211709">Kevin Buzzard (Jul 18 2019 at 21:45)</a>:</h4>
<p>I can't do it, I have my decency.</p>

<a name="171211715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211715" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211715">Mario Carneiro (Jul 18 2019 at 21:45)</a>:</h4>
<p>and it needs to actually be in mathlib</p>

<a name="171211720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211720" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211720">Kevin Buzzard (Jul 18 2019 at 21:45)</a>:</h4>
<p>It's not maths.</p>

<a name="171211738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211738" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211738">Mario Carneiro (Jul 18 2019 at 21:45)</a>:</h4>
<p><code>transfer</code> will not work until mathlib is full of theorems like that</p>

<a name="171211744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211744" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211744">Kevin Buzzard (Jul 18 2019 at 21:45)</a>:</h4>
<p>that's an axiom, you guys have to do that one :-) I would have no idea how to do it. Is it the sort of thing a novice tactic-writer could try?</p>

<a name="171211807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211807" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211807">Mario Carneiro (Jul 18 2019 at 21:46)</a>:</h4>
<p>If you don't know how to do it, how would a novice know?</p>

<a name="171211828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211828" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211828">Kevin Buzzard (Jul 18 2019 at 21:46)</a>:</h4>
<p>I mean maybe they can just read Programming In Lean and then just do it</p>

<a name="171211829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211829" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211829">Mario Carneiro (Jul 18 2019 at 21:46)</a>:</h4>
<p>A novice tactic writer can generalize from examples, but we have none</p>

<a name="171211841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211841" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211841">Mario Carneiro (Jul 18 2019 at 21:46)</a>:</h4>
<p>once we have done it by hand 10 times a novice tactic writer can do the rest</p>

<a name="171211843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211843" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211843">Kevin Buzzard (Jul 18 2019 at 21:46)</a>:</h4>
<p>So what needs doing in practice?</p>

<a name="171211866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211866" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211866">Kevin Buzzard (Jul 18 2019 at 21:47)</a>:</h4>
<p>What's the <em>first thing</em> that needs to be done?</p>

<a name="171211882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211882" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211882">Mario Carneiro (Jul 18 2019 at 21:47)</a>:</h4>
<p><code>equiv.rel</code>, isomorphism builders, and theorems of the form A ~= B -&gt; P(A) &lt;-&gt; P(B)</p>

<a name="171211887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211887" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211887">Kevin Buzzard (Jul 18 2019 at 21:47)</a>:</h4>
<p>Are there some sorts of milestones which you can see to making this <code>transfer</code> tactic?</p>

<a name="171211900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211900" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211900">Kevin Buzzard (Jul 18 2019 at 21:47)</a>:</h4>
<p>So what is the type of <code>equiv.rel</code>?</p>

<a name="171211957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171211957" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171211957">Mario Carneiro (Jul 18 2019 at 21:48)</a>:</h4>
<p><code>equiv.rel (e : A ~= B) : A -&gt; B -&gt; Prop := \lam a b, e a = b</code></p>

<a name="171212015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171212015" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171212015">Mario Carneiro (Jul 18 2019 at 21:49)</a>:</h4>
<p>This allows you to state a theorem of the form <code>A ~= B -&gt; P(A) &lt;-&gt; P(B)</code> as <code>e.rel =&gt; iff</code> where <code>=&gt;</code> is that funny relator operation</p>

<a name="171212016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171212016" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171212016">Kevin Buzzard (Jul 18 2019 at 21:49)</a>:</h4>
<p>oh so that one's done now, right?</p>

<a name="171212024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171212024" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171212024">Mario Carneiro (Jul 18 2019 at 21:50)</a>:</h4>
<p>You need a few theorems about it</p>

<a name="171212083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171212083" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171212083">Mario Carneiro (Jul 18 2019 at 21:50)</a>:</h4>
<p>the most important ones for transfer is that it is left and right unique</p>

<a name="171212099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171212099" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171212099">Kevin Buzzard (Jul 18 2019 at 21:50)</a>:</h4>
<p>OK so is there some structure I need to make on equiv.rel?</p>

<a name="171212102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171212102" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171212102">Mario Carneiro (Jul 18 2019 at 21:50)</a>:</h4>
<p>and the converse is given by equiv.rel of the inverse equiv</p>

<a name="171212127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171212127" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171212127">Mario Carneiro (Jul 18 2019 at 21:51)</a>:</h4>
<p>I think <code>left_unique</code> and <code>right_unique</code> are typeclasses</p>

<a name="171212202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171212202" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171212202">Mario Carneiro (Jul 18 2019 at 21:52)</a>:</h4>
<p>If you look at <code>logic.relator</code> there are several functions related to this sort of thing</p>

<a name="171212535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171212535" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171212535">Kevin Buzzard (Jul 18 2019 at 21:57)</a>:</h4>
<p>Just to be clear -- the <code>e : A =~ B</code> notation -- the type of <code>e</code> is just some random type <code>T A B</code>, or does it have to have some sort of equivalence relation properties?</p>

<a name="171212624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171212624" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171212624">Mario Carneiro (Jul 18 2019 at 21:58)</a>:</h4>
<p><code>e</code> is an equiv</p>

<a name="171212645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171212645" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171212645">Mario Carneiro (Jul 18 2019 at 21:59)</a>:</h4>
<p>not a fancy equiv, just an <code>equiv</code></p>

<a name="171212758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171212758" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171212758">Mario Carneiro (Jul 18 2019 at 22:00)</a>:</h4>
<p>More complicated things would have something like <code>(e.to_equiv.rel =&gt; iff) Gorenstein Gorenstein</code> where <code>e</code> is a ring equiv</p>

<a name="171212776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171212776" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171212776">Jeremy Avigad (Jul 18 2019 at 22:00)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> I can't resist a bit of history here. Read Dedekind's <em>Was sind und was sollen die Zahlen</em> (1888), roughly "What are the [natural] numbers and what should they be." See especially the introduction. (It is the second essay here: <a href="http://www.gutenberg.org/files/21016/21016-pdf.pdf" target="_blank" title="http://www.gutenberg.org/files/21016/21016-pdf.pdf">http://www.gutenberg.org/files/21016/21016-pdf.pdf</a>.) The answer to the question posed in the title is expressed more clearly in his letter to Keferstein: <a href="http://www.bris.ac.uk/media-library/sites/structuralism/migrated/documents/kerfstein.pdf" target="_blank" title="http://www.bris.ac.uk/media-library/sites/structuralism/migrated/documents/kerfstein.pdf">http://www.bris.ac.uk/media-library/sites/structuralism/migrated/documents/kerfstein.pdf</a>. It is as you say: We don't care what they are, as long as they satisfy the properties we want. We only need to construct one to show that the notion is coherent. Then, if as long as we respect the interface, anything we say about one will be true of the other. (The part about respecting the interface is in Section 134 on page 48 of the essay.) In modern terms, he gave an axiomatic characterization of the natural numbers, a set theoretic construction (from the assumption that there exists an infinite set), and a proof that any two systems satisfying the axioms are isomorphic.</p>
<p>Dedekind was an early proponent of a modern, structural view of mathematics, at a time when the subject had a much more calculational style. According to van der Waerden, Emmy Noether used to say "Es steht alles schon bei Dedekind," i.e. everything is already there, in Dedekind.</p>

<a name="171213470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171213470" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171213470">Kevin Buzzard (Jul 18 2019 at 22:11)</a>:</h4>
<p>I have seen all this stuff before but I  just never really understood its depth until recently</p>

<a name="171216483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171216483" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171216483">Kevin Buzzard (Jul 18 2019 at 23:10)</a>:</h4>
<p>But in some sense it really is not mathematics. This whole thing is just a tedious implementation issue.</p>

<a name="171216489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171216489" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171216489">Kevin Buzzard (Jul 18 2019 at 23:10)</a>:</h4>
<p>Everything is already there, in Dedekind.</p>

<a name="171247808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171247808" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171247808">Andrew Ashworth (Jul 19 2019 at 10:57)</a>:</h4>
<p>Maybe the old usage of  <code>transfer</code> to prove properties about ints-as-pairs-of-naturals should be the in mathlib docs, i.e. <a href="https://github.com/leanprover/lean/blob/6ab792733d09878d82ce98d88f6f476c8e0f34d8/library/init/data/int/basic.lean" target="_blank" title="https://github.com/leanprover/lean/blob/6ab792733d09878d82ce98d88f6f476c8e0f34d8/library/init/data/int/basic.lean">https://github.com/leanprover/lean/blob/6ab792733d09878d82ce98d88f6f476c8e0f34d8/library/init/data/int/basic.lean</a></p>

<a name="171281201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171281201" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171281201">Kevin Buzzard (Jul 19 2019 at 18:22)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">logic</span><span class="bp">.</span><span class="n">relator</span>

<span class="n">def</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">rel</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">A</span> <span class="err">≃</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">B</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">e</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">A</span> <span class="err">≃</span> <span class="n">B</span><span class="o">)</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">relator</span><span class="bp">.</span><span class="n">left_unique</span> <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">rel</span> <span class="n">e</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a₁</span> <span class="n">b</span> <span class="n">a₂</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">injective</span> <span class="n">e</span> <span class="err">$</span> <span class="n">eq</span><span class="bp">.</span><span class="n">trans</span> <span class="n">h1</span> <span class="n">h2</span><span class="bp">.</span><span class="n">symm</span>
<span class="kn">instance</span> <span class="o">:</span> <span class="n">relator</span><span class="bp">.</span><span class="n">right_unique</span> <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">rel</span> <span class="n">e</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b₁</span> <span class="n">b₂</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span> <span class="n">eq</span><span class="bp">.</span><span class="n">trans</span> <span class="n">h1</span><span class="bp">.</span><span class="n">symm</span> <span class="n">h2</span>
</pre></div>


<p>What next?</p>

<a name="171281396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171281396" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171281396">Mario Carneiro (Jul 19 2019 at 18:24)</a>:</h4>
<p>pick a simple predicate or construction and try to prove its isomorphism theorem</p>

<a name="171284929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171284929" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171284929">Kevin Buzzard (Jul 19 2019 at 19:02)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">rel_imp</span> <span class="o">:</span> <span class="o">(</span><span class="n">iff</span> <span class="err">⇒</span> <span class="o">(</span><span class="n">iff</span>  <span class="err">⇒</span> <span class="n">iff</span><span class="o">))</span> <span class="n">implies</span> <span class="n">implies</span> <span class="o">:=</span>
</pre></div>


<p>this <code>logic.relator</code> file is pretty cool :-)</p>
<p>But didn't <span class="user-mention" data-user-id="110087">@Scott Morrison</span>  and/or <span class="user-mention" data-user-id="110026">@Simon Hudon</span>  write a bunch of this sort of code years ago?</p>

<a name="171284930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171284930" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171284930">Kevin Buzzard (Jul 19 2019 at 19:02)</a>:</h4>
<p>the lemma below looks like some experimental new one way traffic system</p>

<a name="171284931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171284931" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171284931">Kevin Buzzard (Jul 19 2019 at 19:02)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">rel_iff</span> <span class="o">:</span> <span class="o">((</span><span class="bp">↔</span><span class="o">)</span> <span class="err">⇒</span> <span class="o">(</span><span class="bp">↔</span><span class="o">)</span> <span class="err">⇒</span> <span class="o">(</span><span class="bp">↔</span><span class="o">))</span> <span class="o">(</span><span class="bp">↔</span><span class="o">)</span> <span class="o">(</span><span class="bp">↔</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">...</span>
</pre></div>

<a name="171285022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171285022" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171285022">Mario Carneiro (Jul 19 2019 at 19:03)</a>:</h4>
<p>It's a new way to write <code>*_congr</code> lemmas</p>

<a name="171285117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171285117" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171285117">Mario Carneiro (Jul 19 2019 at 19:04)</a>:</h4>
<p>For the proof, I would just unfold the notations straight away until I know what I'm doing. The <code>transfer</code> tactic knows how to put the lemmas together without unfolding them</p>

<a name="171285290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171285290" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171285290">Kevin Buzzard (Jul 19 2019 at 19:06)</a>:</h4>
<p><a href="#narrow/stream/113488-general/topic/how.20to.20use.20transfer/near/135299706" title="#narrow/stream/113488-general/topic/how.20to.20use.20transfer/near/135299706">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how.20to.20use.20transfer/near/135299706</a></p>

<a name="171285318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171285318" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171285318">Kevin Buzzard (Jul 19 2019 at 19:07)</a>:</h4>
<p>We've talked about this stuff before and I have just about enough control of Zulip search to be able to find some of it.</p>

<a name="171285368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171285368" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171285368">Mario Carneiro (Jul 19 2019 at 19:08)</a>:</h4>
<p>There's another old post where I prove isomorphism theorem for maximal ideals this way</p>

<a name="171285436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171285436" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171285436">Mario Carneiro (Jul 19 2019 at 19:08)</a>:</h4>
<p><a href="#narrow/stream/116395-maths/topic/Perfectoid.20spaces/near/159808751" title="#narrow/stream/116395-maths/topic/Perfectoid.20spaces/near/159808751">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfectoid.20spaces/near/159808751</a></p>

<a name="171285491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171285491" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171285491">Kevin Buzzard (Jul 19 2019 at 19:09)</a>:</h4>
<p>And there was definitely one where I started talking about this sort of thing and was asking how to make a transfer tactic, and Simon and Scott just talked about it for a while and then I think Scott wrote a tonne of code, and there was quite an active period during which you (Mario) were asleep, and then you woke up and checked Zulip and were like "wooah you guys have moved fast" or something. I'd really like to find that thread.</p>

<a name="171285566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171285566" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171285566">Kevin Buzzard (Jul 19 2019 at 19:10)</a>:</h4>
<p>At the time I just remember not understanding the issues well enough, and hence being unable to understand the code properly</p>

<a name="171285655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171285655" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171285655">Kevin Buzzard (Jul 19 2019 at 19:11)</a>:</h4>
<p>It was some code which went through a fair few primitives and proved a lemma about each of them, and then started proving lemmas about other things all hands-on.</p>

<a name="171285726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171285726" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171285726">Kevin Buzzard (Jul 19 2019 at 19:12)</a>:</h4>
<p>Maybe there was also talk about using tags for transfer, and using typeclass resolution to tag more and more stuff as "still OK if replaced by isomorphic thing"</p>

<a name="171285749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171285749" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171285749">Mario Carneiro (Jul 19 2019 at 19:12)</a>:</h4>
<p>oh that's right there was a <code>respects_isomorphism</code> typeclass IIRC</p>

<a name="171285761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171285761" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171285761">Mario Carneiro (Jul 19 2019 at 19:13)</a>:</h4>
<p>I forget the actual name</p>

<a name="171285782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171285782" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171285782">Kevin Buzzard (Jul 19 2019 at 19:13)</a>:</h4>
<p>Each time this transfer conversation occurs I learn quite a lot about the idea, but I still have work to do.</p>

<a name="171301894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171301894" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171301894">Kevin Buzzard (Jul 19 2019 at 23:55)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">instance</span> <span class="kn">notation</span><span class="bp">.</span><span class="n">sub_eq_add_neg</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">has_neg</span> <span class="n">X</span><span class="o">]</span> <span class="o">:</span>
<span class="n">has_sub</span> <span class="n">X</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="bp">+</span> <span class="bp">-</span><span class="n">b</span><span class="bp">⟩</span>

<span class="n">class</span> <span class="n">has_field_notation</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">has_zero</span> <span class="n">X</span><span class="o">,</span> <span class="n">has_one</span> <span class="n">X</span><span class="o">,</span>
<span class="n">has_mul</span> <span class="n">X</span><span class="o">,</span> <span class="n">has_add</span> <span class="n">X</span><span class="o">,</span> <span class="n">has_neg</span> <span class="n">X</span> <span class="c1">-- note: don&#39;t use has_sub</span>
<span class="c1">-- because it might cause a diamond now</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_field_notation</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">refine</span> <span class="o">{}</span><span class="bp">;</span><span class="n">apply_instance</span>

<span class="n">class</span> <span class="n">complete_ordered_archimedean_field</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">has_field_notation</span> <span class="n">X</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">all_the_axioms</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">+</span> <span class="n">x</span><span class="o">)</span> <span class="c1">-- ...</span>
<span class="o">(</span><span class="n">etc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="mi">1</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span>

<span class="c1">-- boring proof omitted</span>
<span class="kn">instance</span> <span class="n">cauchy_reals_are_complete</span> <span class="o">:</span> <span class="n">complete_ordered_archimedean_field</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">structure</span> <span class="n">Reals</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
<span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">has_field_notation</span> <span class="n">X</span><span class="o">]</span>
<span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">complete_ordered_archimedean_field</span> <span class="n">X</span><span class="o">)</span>

<span class="n">def</span> <span class="n">CauchyReals</span> <span class="o">:</span> <span class="n">Reals</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">ℝ</span><span class="o">,</span>
  <span class="n">h</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span><span class="o">,</span>
  <span class="n">e</span> <span class="o">:=</span> <span class="n">cauchy_reals_are_complete</span>
<span class="o">}</span>

<span class="kn">structure</span> <span class="n">ordered_field_equiv</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">has_field_notation</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">has_field_notation</span> <span class="n">Y</span><span class="o">]</span>
  <span class="o">[</span><span class="n">complete_ordered_archimedean_field</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">complete_ordered_archimedean_field</span> <span class="n">Y</span><span class="o">]</span>
  <span class="kn">extends</span> <span class="n">equiv</span> <span class="n">X</span> <span class="n">Y</span> <span class="c1">-- add extra axioms here</span>

<span class="kn">theorem</span> <span class="n">all_reals_are_the_same</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">has_field_notation</span> <span class="n">X</span><span class="o">]</span>
  <span class="o">[</span><span class="n">complete_ordered_archimedean_field</span> <span class="n">X</span><span class="o">]</span> <span class="o">:</span>
<span class="bp">∃</span> <span class="n">e</span> <span class="o">:</span> <span class="n">ordered_field_equiv</span> <span class="n">X</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">true</span> <span class="o">:=</span> <span class="n">sorry</span> <span class="c1">-- boring proof omitted</span>

<span class="n">class</span> <span class="n">platonist_friendly</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Reals</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">X</span> <span class="o">:</span> <span class="n">Reals</span><span class="o">,</span> <span class="n">P</span> <span class="n">X</span> <span class="bp">↔</span> <span class="n">P</span> <span class="n">CauchyReals</span><span class="o">)</span>

<span class="kn">instance</span> <span class="o">(</span><span class="n">P</span> <span class="n">Q</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Reals</span><span class="o">)</span> <span class="o">[</span><span class="n">platonist_friendly</span> <span class="n">P</span><span class="o">]</span> <span class="o">[</span><span class="n">platonist_friendly</span> <span class="n">Q</span><span class="o">]</span> <span class="o">:</span>
<span class="n">platonist_friendly</span> <span class="o">(</span><span class="n">P</span> <span class="err">∩</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="n">X</span><span class="o">,</span> <span class="k">begin</span>
  <span class="k">show</span> <span class="n">P</span> <span class="n">X</span> <span class="bp">∧</span> <span class="n">Q</span> <span class="n">X</span> <span class="bp">↔</span> <span class="n">P</span> <span class="n">CauchyReals</span> <span class="bp">∧</span> <span class="n">Q</span> <span class="n">CauchyReals</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">_</span><span class="n">inst_1</span><span class="bp">.</span><span class="n">e</span><span class="o">,</span> <span class="bp">_</span><span class="n">inst_2</span><span class="bp">.</span><span class="n">e</span><span class="o">]</span>
<span class="kn">end</span><span class="bp">⟩</span>
</pre></div>


<p>I didn't look at your work yet, I just thought I'd try and work out some concepts with this Cauchy / Dedekind reals thing.</p>
<p>One could even play the same game with the Lau Rationals (the field of fractions of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span>) vs the computer science rationals in mathlib.</p>

<a name="171302165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171302165" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171302165">Kevin Buzzard (Jul 20 2019 at 00:02)</a>:</h4>
<p>Is the idea that a tactic can generate instances of the <code>platonist_friendly</code> class, by induction on P somehow? There are no relators above so they are also clearly offering something which I've not yet understood. And finally there is this question which does not appear to be addressed by the above -- if I prove some theorem about some Bochner integral of some function being equal to pi, how do I mark this theorem with the "there is a version of me for Dedekind reals and indeed for all terms of type Reals" tag?</p>

<a name="171302966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171302966" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171302966">Mario Carneiro (Jul 20 2019 at 00:22)</a>:</h4>
<p>What relators bring to the table is the ability to deal with n-ary predicates, with a variety of equivalences on the inputs (one type might be in bijection, the other is a module and there's a module iso, and then relative to the first equiv some elements a and b are related)</p>

<a name="171302975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171302975" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171302975">Mario Carneiro (Jul 20 2019 at 00:23)</a>:</h4>
<p>This is necessary for making the "proof by induction" go through</p>

<a name="171302977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171302977" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171302977">Mario Carneiro (Jul 20 2019 at 00:23)</a>:</h4>
<p>which is why I'm not supportive of the typeclass approach</p>

<a name="171303040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171303040" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171303040">Mario Carneiro (Jul 20 2019 at 00:25)</a>:</h4>
<p>The relator way to write <code>platonist_friendly P</code> is <code>(e.rel =&gt; iff) P P</code> where <code>e</code> is an ordered field equiv</p>

<a name="171303147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171303147" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171303147">Mario Carneiro (Jul 20 2019 at 00:28)</a>:</h4>
<p>well that's not quite accurate since you bundled <code>Reals</code>. Normally you would use some relation <code>R : Reals -&gt; Reals -&gt; Prop</code> asserting that the two elements of <code>Reals</code> are isomorphic, but in the case of <code>Reals</code> that's the trivially true relation</p>

<a name="171318944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171318944" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171318944">Kevin Buzzard (Jul 20 2019 at 08:55)</a>:</h4>
<p>Yes, the reals are somehow an easier case, the universal predicate applies to types with field notation and is just the assertion that they're complete ordered Archimedean fields which is enough to make them "the same as" the platonic reals</p>

<a name="171351722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171351722" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171351722">Kevin Buzzard (Jul 21 2019 at 02:25)</a>:</h4>
<p>I bundled subthings and morphisms of things!</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">basic</span>

<span class="n">class</span> <span class="n">thing</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">.</span> <span class="c1">-- insert data here (usually notation and some axioms)</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span><span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">thing</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">thing</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">thing</span> <span class="n">γ</span><span class="o">]</span>

<span class="n">class</span> <span class="n">is_subthing</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">true</span> <span class="c1">-- this class should not exist. Sometimes you see it in mathlib though.</span>

<span class="kn">set_option</span> <span class="n">old_structure_cmd</span> <span class="n">true</span>

<span class="kn">structure</span> <span class="n">subthing</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">thing</span> <span class="n">α</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">carrier</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="k">proof</span> <span class="o">:</span> <span class="n">is_subthing</span> <span class="n">carrier</span><span class="o">)</span> <span class="c1">-- replace with notation closure axioms e.g. one_mem, mul_mem etc. Note that is_subthing is never used again.</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_coe_to_sort</span> <span class="o">(</span><span class="n">subthing</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="n">subthing</span><span class="bp">.</span><span class="n">carrier</span><span class="bp">⟩</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">subthing</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">subthing</span><span class="bp">.</span><span class="n">carrier</span><span class="bp">⟩</span>

<span class="c1">-- another deprecated class</span>
<span class="n">def</span> <span class="n">is_thing_morphism</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">true</span> <span class="c1">-- this class should not exist. Sometimes you see it in mathlib though.</span>
<span class="c1">-- I won&#39;t bother making it into a class. It&#39;s deprecated.</span>

<span class="kn">structure</span> <span class="n">thing_morphism</span> <span class="n">α</span> <span class="n">β</span> <span class="o">[</span><span class="n">thing</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">thing</span> <span class="n">β</span><span class="o">]:=</span>
<span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>
<span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">is_thing_morphism</span> <span class="n">to_fun</span><span class="o">)</span> <span class="c1">-- replace with notation-preserving axioms e.g. map_one, map_mul.... Note that `is_thing_morphism`  never occurs again</span>

<span class="kn">infixr</span> <span class="bp">`</span> <span class="bp">→</span><span class="n">t</span> <span class="bp">`</span><span class="o">:</span><span class="mi">25</span> <span class="o">:=</span> <span class="n">thing_morphism</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span><span class="n">t</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">F</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">,</span>
  <span class="n">coe</span> <span class="o">:=</span> <span class="n">thing_morphism</span><span class="bp">.</span><span class="n">to_fun</span><span class="o">}</span>

<span class="kn">lemma</span> <span class="n">thing_morphism</span><span class="bp">.</span><span class="n">ext</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span><span class="n">t</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="bp">=</span> <span class="n">g</span> <span class="bp">→</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">:=</span> <span class="k">begin</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">g</span><span class="o">,</span>
  <span class="n">rwa</span> <span class="n">thing_morphism</span><span class="bp">.</span><span class="n">mk</span><span class="bp">.</span><span class="n">inj_eq</span><span class="o">,</span>
<span class="kn">end</span>

<span class="c1">-- bundled equivs using old structure command so no `to_fun` problems</span>
<span class="kn">structure</span> <span class="n">thing_equiv</span> <span class="n">α</span> <span class="n">β</span> <span class="o">[</span><span class="n">thing</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">thing</span> <span class="n">β</span><span class="o">]</span> <span class="kn">extends</span> <span class="n">equiv</span> <span class="n">α</span> <span class="n">β</span><span class="o">,</span> <span class="n">thing_morphism</span> <span class="n">α</span> <span class="n">β</span>

<span class="kn">infix</span> <span class="bp">`</span> <span class="err">≃</span><span class="n">t</span> <span class="bp">`</span><span class="o">:</span><span class="mi">25</span> <span class="o">:=</span> <span class="n">thing_equiv</span>

<span class="kn">namespace</span> <span class="n">thing_equiv</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">thing_equiv</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">F</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">,</span> <span class="n">coe</span> <span class="o">:=</span> <span class="n">to_fun</span><span class="o">}</span>

<span class="kn">theorem</span> <span class="n">ext</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">thing_equiv</span> <span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="bp">=</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">cases</span> <span class="n">f</span><span class="o">,</span> <span class="n">cases</span> <span class="n">g</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">thing_equiv</span><span class="bp">.</span><span class="n">mk</span><span class="bp">.</span><span class="n">inj_eq</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">mk</span><span class="bp">.</span><span class="n">inj</span> <span class="bp">_;</span><span class="n">try</span> <span class="o">{</span><span class="n">assumption</span><span class="o">},</span>
  <span class="n">change</span> <span class="n">f_to_fun</span> <span class="bp">=</span> <span class="n">g_to_fun</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">ext</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">congr_fun</span> <span class="n">h</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">coe_inj</span> <span class="o">:</span> <span class="n">function</span><span class="bp">.</span><span class="n">injective</span> <span class="o">(</span><span class="n">thing_equiv</span><span class="bp">.</span><span class="n">to_equiv</span> <span class="o">:</span> <span class="n">thing_equiv</span> <span class="n">α</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">equiv</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span> <span class="k">begin</span>
  <span class="n">intros</span> <span class="n">f</span> <span class="n">g</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">ext</span><span class="o">,</span>
  <span class="c1">-- is this idiomatic?</span>
  <span class="k">show</span> <span class="err">⇑</span><span class="o">(</span><span class="n">to_equiv</span> <span class="n">f</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kn">end</span>

<span class="bp">@</span><span class="o">[</span><span class="n">refl</span><span class="o">]</span> <span class="kn">protected</span> <span class="n">def</span> <span class="n">refl</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">thing</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">α</span> <span class="err">≃</span><span class="n">t</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">trivial</span><span class="o">,</span><span class="bp">..</span><span class="n">equiv</span><span class="bp">.</span><span class="n">refl</span> <span class="n">α</span><span class="o">}</span>
<span class="bp">@</span><span class="o">[</span><span class="n">symm</span><span class="o">]</span> <span class="kn">protected</span> <span class="n">def</span> <span class="n">symm</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">α</span> <span class="err">≃</span><span class="n">t</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">β</span> <span class="err">≃</span><span class="n">t</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">trivial</span><span class="o">,</span><span class="bp">..</span><span class="n">e</span><span class="bp">.</span><span class="n">to_equiv</span><span class="bp">.</span><span class="n">symm</span><span class="o">}</span>
<span class="bp">@</span><span class="o">[</span><span class="n">trans</span><span class="o">]</span> <span class="kn">protected</span> <span class="n">def</span> <span class="n">trans</span> <span class="o">(</span><span class="n">e1</span> <span class="o">:</span> <span class="n">β</span> <span class="err">≃</span><span class="n">t</span> <span class="n">γ</span><span class="o">)</span> <span class="o">(</span><span class="n">e2</span> <span class="o">:</span> <span class="n">α</span> <span class="err">≃</span><span class="n">t</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="err">≃</span><span class="n">t</span> <span class="n">γ</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">trivial</span><span class="o">,</span><span class="bp">..</span><span class="n">e2</span><span class="bp">.</span><span class="n">to_equiv</span><span class="bp">.</span><span class="n">trans</span> <span class="n">e1</span><span class="bp">.</span><span class="n">to_equiv</span><span class="o">}</span>

<span class="c1">-- perms</span>
<span class="n">def</span> <span class="n">perm</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">thing</span> <span class="n">α</span><span class="o">]</span> <span class="o">:=</span> <span class="n">thing_equiv</span> <span class="n">α</span> <span class="n">α</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_one</span> <span class="o">(</span><span class="n">perm</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">thing_equiv</span><span class="bp">.</span><span class="n">refl</span> <span class="n">α</span><span class="bp">⟩</span>
<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_mul</span> <span class="o">(</span><span class="n">perm</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">thing_equiv</span><span class="bp">.</span><span class="n">trans</span><span class="bp">⟩</span> <span class="c1">-- goodness knows if this is &quot;right&quot; or whether I should swap</span>
<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_inv</span> <span class="o">(</span><span class="n">perm</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">thing_equiv</span><span class="bp">.</span><span class="n">symm</span><span class="bp">⟩</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">group</span> <span class="o">(</span><span class="n">perm</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">mul</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">*</span><span class="o">),</span>
  <span class="n">one</span> <span class="o">:=</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="bp">⁻¹</span><span class="o">,</span>
  <span class="n">mul_assoc</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">ext</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">one_mul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">ext</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">mul_one</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">ext</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">mul_left_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">ext</span> <span class="err">$</span> <span class="k">begin</span> <span class="n">funext</span> <span class="n">x</span><span class="o">,</span> <span class="n">exact</span> <span class="n">f</span><span class="bp">.</span><span class="n">left_inv</span> <span class="n">x</span> <span class="kn">end</span><span class="o">}</span>

<span class="kn">end</span> <span class="n">thing_equiv</span>
</pre></div>


<p>I got as far as the automorphism group of a thing.</p>

<a name="171351886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171351886" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171351886">Kevin Buzzard (Jul 21 2019 at 02:31)</a>:</h4>
<p>Now someone can knock off a tactic and we can just bundle everything instantly.</p>

<a name="171351888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171351888" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171351888">Kevin Buzzard (Jul 21 2019 at 02:31)</a>:</h4>
<p><span class="user-mention" data-user-id="228602">@Sian Carey</span></p>

<a name="171354903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171354903" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171354903">Kevin Buzzard (Jul 21 2019 at 04:14)</a>:</h4>
<p><span class="user-mention" data-user-id="110044">@Chris Hughes</span> my understanding is that you want bundled <code>monoid_hom</code> but no definition of <code>group_hom</code>. Could there still be a <code>group_hom</code> namespace though?</p>

<a name="171355738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171355738" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171355738">Kevin Buzzard (Jul 21 2019 at 04:45)</a>:</h4>
<p>I want to define field homomorphisms between $fields$ which I guess are called <code>discrete_field</code>. Chris / <span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  -- what do you people want the bundled class to be called (<code>discrete_field_hom</code>, <code>field_hom</code>, <code>ring_hom</code>, <code>semiring_hom</code>...) and exactly what instances to you want Lean to ask for in the actual definition of the structure? (e.g. <code>map_zero</code> follows from <code>map_add</code> because everything is a field in my case of interest, so we don't need it, but I don't care if <code>map_zero</code> is a field or not, I just want to do it right).</p>

<a name="171355785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171355785" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171355785">Mario Carneiro (Jul 21 2019 at 04:47)</a>:</h4>
<p>Are <code>semiring_hom</code>, <code>ring_hom</code> and <code>field_hom</code> all the same?</p>

<a name="171355790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171355790" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171355790">Kevin Buzzard (Jul 21 2019 at 04:47)</a>:</h4>
<p>yes but I thought Chris was arguing that some of these things shouldn't even be tokens.</p>

<a name="171355830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171355830" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171355830">Mario Carneiro (Jul 21 2019 at 04:48)</a>:</h4>
<p>Of those <code>ring_hom</code> is my favorite</p>

<a name="171355843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171355843" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171355843">Kevin Buzzard (Jul 21 2019 at 04:49)</a>:</h4>
<p>I thought he suggested that <code>group_hom</code> be not defined, <code>-&gt;*</code> be notation for <code>monoid_hom</code> which also demands <code>map_one</code> and just tell the user to use the right notation for group homs which happens to coincide with the notation for monoid homs. They will never have to make one with their bare hands hopefully :-)</p>

<a name="171355887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171355887" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171355887">Mario Carneiro (Jul 21 2019 at 04:50)</a>:</h4>
<p>We can do the same thing with field homs - call it <code>ring_hom</code>, but it's really a semiring hom and you use it for semirings and fields too</p>

<a name="171355889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171355889" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171355889">Kevin Buzzard (Jul 21 2019 at 04:50)</a>:</h4>
<p>If <code>field_hom</code> is not even defined, can there still be a <code>field_hom</code> namespace? Does that ever happen in mathlib?</p>

<a name="171355891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171355891" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171355891">Mario Carneiro (Jul 21 2019 at 04:50)</a>:</h4>
<p>There can be a namespace</p>

<a name="171355898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171355898" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171355898">Mario Carneiro (Jul 21 2019 at 04:51)</a>:</h4>
<p>Although you will miss out on dot notation</p>

<a name="171355940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171355940" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171355940">Kevin Buzzard (Jul 21 2019 at 04:52)</a>:</h4>
<p>but theorems which are specific for fields, such as injectivity of the underlying map, naturally live there I think...oh, I see your point.</p>

<a name="171355953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171355953" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171355953">Kevin Buzzard (Jul 21 2019 at 04:53)</a>:</h4>
<p>Is <code>-&gt;*+</code> horrible notation for a ring hom?</p>

<a name="171356000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171356000" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171356000">Mario Carneiro (Jul 21 2019 at 04:54)</a>:</h4>
<p>lgtm</p>

<a name="171356004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171356004" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171356004">Kevin Buzzard (Jul 21 2019 at 04:54)</a>:</h4>
<p>I want a LaTeX right-arrow with a + and a * floating over it when we're doing the controlled natural language thing; this notation is just a temporary thing</p>

<a name="171356061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171356061" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171356061">Mario Carneiro (Jul 21 2019 at 04:56)</a>:</h4>
<p>You don't have to convince me, I find this kind of notation more palatable than random selections from the unicode arrow palette</p>

<a name="171356062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171356062" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171356062">Kevin Buzzard (Jul 21 2019 at 04:56)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> what is the categorification of <code>subring R</code>?</p>

<a name="171356066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171356066" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171356066">Kenny Lau (Jul 21 2019 at 04:56)</a>:</h4>
<p>mathematically?</p>

<a name="171356071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171356071" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171356071">Kevin Buzzard (Jul 21 2019 at 04:57)</a>:</h4>
<p>Is it <code>ring_hom A R</code> or <code>injective_ring_hom A R</code>?</p>

<a name="171356077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171356077" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171356077">Kevin Buzzard (Jul 21 2019 at 04:57)</a>:</h4>
<p>Is the question mathematically meaningful?</p>

<a name="171356078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171356078" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171356078">Kenny Lau (Jul 21 2019 at 04:57)</a>:</h4>
<p><a href="https://ncatlab.org/nlab/show/subobject" target="_blank" title="https://ncatlab.org/nlab/show/subobject">https://ncatlab.org/nlab/show/subobject</a></p>

<a name="171356080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171356080" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171356080">Kenny Lau (Jul 21 2019 at 04:57)</a>:</h4>
<p>it's an isomorphism class of monomorphisms</p>

<a name="171356081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171356081" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171356081">Kevin Buzzard (Jul 21 2019 at 04:57)</a>:</h4>
<p>Thanks.</p>

<a name="171356249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171356249" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171356249">Kevin Buzzard (Jul 21 2019 at 05:03)</a>:</h4>
<p>So I think you're saying it's <code>injective_ring_hom</code>.</p>

<a name="171356266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171356266" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171356266">Kevin Buzzard (Jul 21 2019 at 05:04)</a>:</h4>
<p><code>injective</code> is a predicate on <code>ring_hom</code>.</p>

<a name="171356296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171356296" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171356296">Kevin Buzzard (Jul 21 2019 at 05:04)</a>:</h4>
<p>which implies <code>monic</code></p>

<a name="171356310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171356310" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171356310">Kevin Buzzard (Jul 21 2019 at 05:05)</a>:</h4>
<p>Is this something to do with topologies on categories?</p>

<a name="171356360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171356360" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171356360">Kevin Buzzard (Jul 21 2019 at 05:07)</a>:</h4>
<p>These categories -- lattices -- are the best categories in Lean. Do we have topologies on these categories?</p>

<a name="171356833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171356833" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171356833">Kevin Buzzard (Jul 21 2019 at 05:23)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">ring_equiv</span> <span class="o">(</span><span class="n">R</span> <span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">ring</span> <span class="n">S</span><span class="o">]</span> <span class="kn">extends</span> <span class="o">(</span><span class="n">R</span> <span class="err">≃</span> <span class="n">S</span><span class="o">),</span> <span class="o">(</span><span class="n">R</span> <span class="bp">→+*</span> <span class="n">S</span><span class="o">)</span>
</pre></div>

<a name="171356875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171356875" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171356875">Kevin Buzzard (Jul 21 2019 at 05:24)</a>:</h4>
<p>end of definition</p>

<a name="171357396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171357396" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171357396">Kenny Lau (Jul 21 2019 at 05:41)</a>:</h4>
<blockquote>
<p>These categories -- lattices -- are the best categories in Lean. Do we have topologies on these categories?</p>
</blockquote>
<p>we have... Groethendieck topologies</p>

<a name="171359520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171359520" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171359520">Kevin Buzzard (Jul 21 2019 at 06:47)</a>:</h4>
<p>Is <code>monic</code> an example?</p>

<a name="171359644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171359644" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171359644">Kenny Lau (Jul 21 2019 at 06:50)</a>:</h4>
<p>of what?</p>

<a name="171359960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171359960" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171359960">Kevin Buzzard (Jul 21 2019 at 06:58)</a>:</h4>
<p>Something that satisfies the axioms for the admissible morphisms in a grothendieck topology</p>

<a name="171360072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171360072" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171360072">Kenny Lau (Jul 21 2019 at 07:01)</a>:</h4>
<p>grothendieck topology needs admissible <strong>families</strong> of morphisms right</p>

<a name="171360083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171360083" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171360083">Kenny Lau (Jul 21 2019 at 07:01)</a>:</h4>
<p>I can say that { A_i -&gt; A } is admissible if the images generate the whole ring</p>

<a name="171362426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171362426" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171362426">Scott Morrison (Jul 21 2019 at 08:14)</a>:</h4>
<p><code>abbreviation ring_equiv (R S : Type) [ring R] [ring S] := Ring.of R ≅ Ring.of S</code></p>

<a name="171364205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171364205" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171364205">Yury G. Kudryashov (Jul 21 2019 at 09:10)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> The definition with <code>≅</code> has two drawbacks.<br>
1. It only works for <code>R</code> and <code>S</code> in the same universe.<br>
2. It's harder to define elements of this type. Currently, <code>≃*</code> etc ask for a proof of <code>to_fun</code> being a <code>hom</code>, and automatically deduce that <code>inv</code> is a <code>hom</code>.</p>

<a name="171370079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171370079" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171370079">Kevin Buzzard (Jul 21 2019 at 12:10)</a>:</h4>
<p>2 can be solved with a constructor. 1 I personally don't care about because I am a mathematician</p>

<a name="171377241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171377241" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171377241">Kevin Buzzard (Jul 21 2019 at 15:43)</a>:</h4>
<p>Can we use function composition notation with bundled homs? If <code>f : thing_hom A B</code> and <code>g : thing_hom B C</code> then can we have <code>f \circ g : thing_hom A C</code> or whichever way round you want it? Does one just overload notation in this situation?</p>

<a name="171383082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171383082" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171383082">Yury G. Kudryashov (Jul 21 2019 at 18:42)</a>:</h4>
<p>Possibly, we can have something like <code>has_comp</code> and use it.</p>

<a name="171383091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171383091" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171383091">Yury G. Kudryashov (Jul 21 2019 at 18:43)</a>:</h4>
<p>Though it means overriding notation from core.</p>

<a name="171383136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171383136" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171383136">Yury G. Kudryashov (Jul 21 2019 at 18:44)</a>:</h4>
<p>(of course, we can use some other symbol)</p>

<a name="171386180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171386180" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171386180">Scott Morrison (Jul 21 2019 at 20:13)</a>:</h4>
<p>... Kevin, is bring able to talk about things in different universes so important to you that you're willing to give up the completely uniform notation for morphisms, composition, isomorphism, tensor product, etc, notation that the category theory API provides?</p>

<a name="171387802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171387802" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171387802">Kevin Buzzard (Jul 21 2019 at 21:04)</a>:</h4>
<p>I know I know, but the category theory API bundles objects which makes it scary. I don't know how to glue sheaves using the category theory version of sheaves.</p>

<a name="171899451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171899451" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171899451">Kevin Buzzard (Jul 28 2019 at 18:42)</a>:</h4>
<p><code>linear_equiv</code> is defined with the old structure command, and <code>mul_equiv</code> with the new one. In practice this means that <code>mul_equiv</code> just has a field <code>to_equiv</code> and then all the equiv stuff like <code>left_inv</code> comes off that:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">basic</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">linear_equiv</span> <span class="c1">-- long</span>
<span class="bp">#</span><span class="kn">print</span> <span class="n">mul_equiv</span> <span class="c1">-- short</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">linear_equiv</span><span class="bp">.</span><span class="n">left_inv</span> <span class="c1">-- works</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">mul_equiv</span><span class="bp">.</span><span class="n">left_inv</span> <span class="c1">-- fails</span>
</pre></div>


<p>Which is best?</p>

<a name="171901720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171901720" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171901720">Chris Hughes (Jul 28 2019 at 19:51)</a>:</h4>
<p>Old structures are the best.</p>

<a name="171901723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171901723" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171901723">Andrew Ashworth (Jul 28 2019 at 19:51)</a>:</h4>
<p>So the disadvantage with the new structure command is that if you want to use properties of <code>equiv</code>, you have to explicitly write <code>to_equiv</code>. The advantage of new structures is that they are faster.</p>

<a name="171901784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171901784" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171901784">Andrew Ashworth (Jul 28 2019 at 19:53)</a>:</h4>
<p>My rule of thumb is: use old structures if the thing you are describing is a genuine mathematical object. Use a new structure if it's just a universal property.</p>

<a name="171901885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171901885" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171901885">Kevin Buzzard (Jul 28 2019 at 19:56)</a>:</h4>
<p>So all the structures we built in the perfectoid project -- for example adic spaces -- should all be using the old structure command?</p>

<a name="171901895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171901895" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171901895">Kevin Buzzard (Jul 28 2019 at 19:57)</a>:</h4>
<p><span class="user-mention" data-user-id="110044">@Chris Hughes</span> it's about time we started calling them "good old structures" and "the good old structure command".</p>

<a name="171901900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171901900" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171901900">Andrew Ashworth (Jul 28 2019 at 19:57)</a>:</h4>
<p>well, they're equivalent, in a sense, so no need to rewrite things that don't need to be rewritten</p>

<a name="171901902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171901902" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171901902">Andrew Ashworth (Jul 28 2019 at 19:57)</a>:</h4>
<p>in fact, if you've already done it using new structures</p>

<a name="171901907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171901907" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171901907">Andrew Ashworth (Jul 28 2019 at 19:57)</a>:</h4>
<p>you should keep them that way. after all, they are faster</p>

<a name="171902046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171902046" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171902046">Andrew Ashworth (Jul 28 2019 at 20:01)</a>:</h4>
<p>maybe a better rule of thumb is: use a new structure, unless you get annoyed with always having to write <code>to_equiv</code></p>

<a name="171902101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171902101" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171902101">Andrew Ashworth (Jul 28 2019 at 20:03)</a>:</h4>
<p>the most important difference is new structures can't have duplicate fields</p>

<a name="171902184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171902184" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171902184">Chris Hughes (Jul 28 2019 at 20:05)</a>:</h4>
<p>It's just a pain to use the constructor for new structures.</p>

<a name="171902230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171902230" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171902230">Andrew Ashworth (Jul 28 2019 at 20:06)</a>:</h4>
<p>yes, in the original description of new structures, Leo assumed a bunch of the tactics would be updated to transparently handle it all. Well, it didn't</p>

<a name="171902238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171902238" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171902238">Kevin Buzzard (Jul 28 2019 at 20:07)</a>:</h4>
<p>We never really ran into these issues as far as I remember -- our main goal was a definition, and our structures just got bigger and bigger but we were lucky not to ever run into duplicate substructures.</p>

<a name="171902243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171902243" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171902243">Kevin Buzzard (Jul 28 2019 at 20:07)</a>:</h4>
<p>The tactics didn't get updated, or they couldn't be updated?</p>

<a name="171902244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171902244" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171902244">Andrew Ashworth (Jul 28 2019 at 20:07)</a>:</h4>
<p>didn't get updated</p>

<a name="171902303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171902303" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171902303">Andrew Ashworth (Jul 28 2019 at 20:09)</a>:</h4>
<p>I guess also since we have no idea what's happening in Lean 4, maybe prefer and start with new structures and hope they are easier to work with whenever the new version gets released</p>

<a name="171902365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171902365" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171902365">Andrew Ashworth (Jul 28 2019 at 20:10)</a>:</h4>
<p>ahh, so you see, in my last three paras I've given completely contradictory advise</p>

<a name="171902371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171902371" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171902371">Andrew Ashworth (Jul 28 2019 at 20:11)</a>:</h4>
<p>I suppose I don't know which one to prefer either :)</p>

<a name="171957333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171957333" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171957333">Kevin Buzzard (Jul 29 2019 at 15:46)</a>:</h4>
<p>Here's a question about <code>mul_equiv</code>s. I really don't know how to set these up. So far I have gone for the old structure command, extending <code>equiv</code> and adding a field <code>map_mul</code>. The problem is with proving things like symmetry. I have goals like</p>
<div class="codehilite"><pre><span></span><span class="n">h</span><span class="bp">.</span><span class="n">to_fun</span> <span class="o">((</span><span class="n">equiv</span><span class="bp">.</span><span class="n">symm</span> <span class="o">(</span><span class="n">to_equiv</span> <span class="n">h</span><span class="o">))</span><span class="bp">.</span><span class="n">to_fun</span> <span class="o">(</span><span class="n">n₁</span> <span class="bp">*</span> <span class="n">n₂</span><span class="o">))</span> <span class="bp">=</span>
    <span class="n">h</span><span class="bp">.</span><span class="n">to_fun</span> <span class="o">((</span><span class="n">equiv</span><span class="bp">.</span><span class="n">symm</span> <span class="o">(</span><span class="n">to_equiv</span> <span class="n">h</span><span class="o">))</span><span class="bp">.</span><span class="n">to_fun</span> <span class="n">n₁</span> <span class="bp">*</span> <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">symm</span> <span class="o">(</span><span class="n">to_equiv</span> <span class="n">h</span><span class="o">))</span><span class="bp">.</span><span class="n">to_fun</span> <span class="n">n₂</span><span class="o">)</span>
</pre></div>


<p>which I really just want to put into a canonical form and then rewrite/simp to death. But the problem is that the canonical form of <code>h.inv_fun</code> seems to be <code>h.symm</code> when <code>h</code> is an <code>equiv</code>, and if I define <code>symm</code> on <code>mul_equiv</code> then I have to reprove stuff like <code>symm_apply_apply</code> in this situation.</p>

<a name="171957542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171957542" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171957542">Kenny Lau (Jul 29 2019 at 15:48)</a>:</h4>
<p>yeah but the proof is just <code>equiv.symm_apply_apply</code></p>

<a name="171957569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171957569" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171957569">Kevin Buzzard (Jul 29 2019 at 15:48)</a>:</h4>
<p>but I can't rewrite it</p>

<a name="171957626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171957626" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171957626">Kevin Buzzard (Jul 29 2019 at 15:49)</a>:</h4>
<p>In fact my first question is what the canonical notation for the inverse bijection should be with <code>h : mul_equiv G H</code></p>

<a name="171957789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171957789" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171957789">Chris Hughes (Jul 29 2019 at 15:51)</a>:</h4>
<p>Prove that <code>f.symm.to_equiv = f.to_equiv.symm</code> and make it <code>simp</code></p>

<a name="171957872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171957872" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171957872">Kevin Buzzard (Jul 29 2019 at 15:51)</a>:</h4>
<p>I think my issue is that I am in the middle of defining <code>mul_equiv.symm</code> and I am complaining about not being able to use the canonical notation <code>h.symm</code> when stating some intermediate result, but this is spurious because <code>h.symm</code> is in the process of being defined.</p>

<a name="172877572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/172877572" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#172877572">Yury G. Kudryashov (Aug 09 2019 at 18:40)</a>:</h4>
<p>Hi, I was away for some time. It seems that <code>monoid_hom</code> and <code>add_monoid_hom</code> are already bundled. I have a few questions about the implementation:<br>
1. Why do we repeat all the proofs instead of using <code>to_additive</code>? My guess is “to provide docstrings” but we can use <code>tactic.add_doc_string</code>. Actually, the new docstring can be turned into the second optional argument to <code>to_additive</code>.<br>
2. I see that <code>M</code>, <code>N</code>, <code>G</code>, <code>H</code> is used for monoids/groups. Doesn't it break the naming conventions? I'm trying to understand how strict is the style guide w.r.t. naming convention.<br>
3. If I want to migrate, say, <code>polynomial.C</code> to <code>monoid_hom</code>, the definition will look like <code>def C {α} ... : α →* polynomial α</code>, and <code>C (1 : α)</code> fails to coerce <code>C</code> to a function. It works, if I make <code>α</code> a mandatory argument but this is not convenient.</p>

<a name="172877963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/172877963" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#172877963">Kevin Buzzard (Aug 09 2019 at 18:43)</a>:</h4>
<p>1. because I only really worked out the full power of <code>to_additive</code> today (see a thread in #general). <br>
2. Yes it breaks the naming conventions. Computer scientists get a lot of things right about names, but I believe that one of very few exceptions is here. If a computer scientist wants to a call a group alpha and a normal subgroup beta and then some auxiliary set gamma then that's fine by me, but if we call the group G and the normal subgroup N and the auxiliary set S then it is much easier to see at a glance what is happening, especially if variables are being used and the definitions of alpha and beta are 150 lines up. <br>
3. Probably <span class="user-mention" data-user-id="110044">@Chris Hughes</span> will have something to say on the matter.</p>

<a name="172878140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/172878140" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#172878140">Kevin Buzzard (Aug 09 2019 at 18:44)</a>:</h4>
<p><a href="#narrow/stream/113488-general/topic/to_additive.20and.20tags" title="#narrow/stream/113488-general/topic/to_additive.20and.20tags">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/to_additive.20and.20tags</a></p>

<a name="172878257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/172878257" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#172878257">Kevin Buzzard (Aug 09 2019 at 18:45)</a>:</h4>
<p>See <a href="https://github.com/leanprover-community/mathlib/blob/659533e1dc63074d3386ffb8b2fbed50151dd34c/src/group_theory/submonoid.lean#L344" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/659533e1dc63074d3386ffb8b2fbed50151dd34c/src/group_theory/submonoid.lean#L344">https://github.com/leanprover-community/mathlib/blob/659533e1dc63074d3386ffb8b2fbed50151dd34c/src/group_theory/submonoid.lean#L344</a> for the kind of code I am writing now. I think this is better -- I repeat almost nothing.</p>

<a name="172878506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/172878506" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#172878506">Yury G. Kudryashov (Aug 09 2019 at 18:48)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> Thanks for explanations. I'd like to help with migrating to bundled hom. What can I work on to avoid duplication of effort?</p>

<a name="172878798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/172878798" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#172878798">Kevin Buzzard (Aug 09 2019 at 18:50)</a>:</h4>
<p>You would be more than welcome to help <span class="user-mention" data-user-id="118107">@Amelia Livingston</span>  and me with all the to_additive stuff. As you can see we got up to line 569. Amelia also refactored <code>localisation.lean</code> in that branch, to see how things look with the changes, and they seemed fine. We did not think about polynomials though.</p>

<a name="172878881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/172878881" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#172878881">Yury G. Kudryashov (Aug 09 2019 at 18:51)</a>:</h4>
<p>E.g., I can rewrite <code>algebra/group/hom</code> using <code>to_additive</code>. Is it OK?</p>

<a name="172878892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/172878892" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#172878892">Kevin Buzzard (Aug 09 2019 at 18:51)</a>:</h4>
<p>Here's a message I sent Amelia earlier today:</p>
<blockquote>
<p>So what I currently believe is this. Say you have made 10 definitions and proved 20 lemmas in the namespace submonoid and you want to get additive versions in add_submonoid. The one thing which can almost always be avoided is having to write out a proof twice, once in the multiplicative and once in the additive case.</p>
<p>The best possible scenario is when defining a lemma; in this case you can use @[to_additive add_submonoid.foo] and that might be almost all you need to do; this will hopefully generate the proof automatically. Unfortunately it doesn't generate the docstring automatically and you have to add it with this run_cmd which which I don't really understand. There are plenty of examples in the commit I pushed today (all in this bundled_submodules branch of mathlib).</p>
<p>More complicated is a definition. I have been writing definition submonoid.foo ..., getting it working, and then writing #print prefix submonoid.foo (note that you need submonoid even if you're in the submonoid namespace). You then see submonoid.foo but also perhaps submonoid.foo.match_1 or submonoid.foo.equations_eqn3 or something. For structures you see loads of things. After the definition you can write to_additive [add_submonoid.foo.proof_3] submonoid.foo.proof_3 and this needs to be done for everything in the output. However it all has to be done in the right order. If you get red squiggles under a to_additive then look at the error, see if it mentions add_submonoid.foo.equation_2 and then move the corresponding to_additive line above the line with the error. In all cases I got this to work. And don't forget the docstring. Note that in one case the errors I got were errors involving functions which I had not defined -- other people had missed out the to_additive tags on other functions, so I had to add those in (they should probably be moved to the correct part of mathlib at some point).</p>
<p>Even more complicated is a structure. I have been defining the additive ones by hand. And there are some lemmas or definitions which don't port, for example those involving powers x^n turn into ones involving smultiples n \bub x and because the order got switched to_additive sometimes can't handle it. In these cases I leave the submonoid namespace immediately, define the additive one by hand (i.e. write the same code again), do all the to_additive tags and the docstring, and then go back into the submonoid namespace. You then have to re-input all the variables which you had open in that namespace. Variables outside a namespace survive inside it, but variables inside a namespace die once the namespace is closed, even if you go back in.</p>
</blockquote>

<a name="172879013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/172879013" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#172879013">Kevin Buzzard (Aug 09 2019 at 18:53)</a>:</h4>
<p>Everything we have done is in the <code>bundled_submonoids</code> branch of mathlib and our plan was to finish <code>submonoid.lean</code> and then make a PR.</p>

<a name="172879187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/172879187" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#172879187">Kevin Buzzard (Aug 09 2019 at 18:55)</a>:</h4>
<p>We didn't touch the <code>hom</code> file so it will be OK.</p>

<a name="172879215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/172879215" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#172879215">Yury G. Kudryashov (Aug 09 2019 at 18:55)</a>:</h4>
<p>Probably, one of us should learn more about Lean tactic language, and let <code>to_additive</code> handle <code>mydef._proof_n</code> and all those <code>mystruct.cases_on</code> etc.<br>
Another idea is to have <code>@[bundled_hom]</code> user attr that defines <code>has_coe_to_fun</code> and restates all axioms using <code>coe</code> instead of <code>f.to_fun</code>.</p>

<a name="172879305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/172879305" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#172879305">Yury G. Kudryashov (Aug 09 2019 at 18:57)</a>:</h4>
<p>OK, then I'll go through <code>hom</code>, then I'll try to migrate concrete categories (<code>Mon</code> etc.) to bundled homs.</p>

<a name="172879418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/172879418" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#172879418">Kevin Buzzard (Aug 09 2019 at 18:58)</a>:</h4>
<p>Bundling group and monoid and ring stuff (subthings, homs and isomorphisms) is just a one-off job which needs to be done once. The reason I am motivated to do it now is because I think it makes it easier for mathematicians -- but I am not sure about this. Other people also believe it's best to do things like bundle homs and subobjects, for other reasons. What became clear to me was that the task of actually <em>removing</em> unbundled homs and replacing them with bundled ones is a vast task, because is_submonoid appears 200 times in the library and one of the appearances is in the definition of <code>is_subgroup</code> which appears 200 more times, and then <code>is_subring</code> uses both of these etc etc.</p>

<a name="172879696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/172879696" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#172879696">Kevin Buzzard (Aug 09 2019 at 19:01)</a>:</h4>
<p>Furthermore, the switch would be one huge PR which would take a very long time to write and would have to constantly be playing catch-up with the library. This sounded very unappealing. So my plan is to bundle stuff, leave the unbundled stuff in for now (but mention that it is deprecated in docstrings) and then start changing leaf nodes to see if things work. Amelia changed <code>localisation.lean</code> and it worked fine. But changing stuff deeper in mathlib is painful. So our plan is to work from the outside in. The disadvantage of our approach is that ultimately it will in some sense be more work, probably. The advantage is that we can access bundled homs immediately, which is what I wanted really.</p>

<a name="172883788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/172883788" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#172883788">Patrick Massot (Aug 09 2019 at 19:54)</a>:</h4>
<p>I'm very worried about this thread. For the sensitivity conjecture project, I worked seriously with linear maps for the first time. They are bundled, and it simply does not work. The coercion to function works completely randomly, and there are instance search timeout all over the place. It's extremely time-consuming and frustrating to fight that</p>

<a name="172884037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/172884037" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#172884037">Mario Carneiro (Aug 09 2019 at 19:57)</a>:</h4>
<p>Bundled maps have much <em>lower</em> pressure on the typeclass system, because you aren't inferring the fact that the function is a hom anymore</p>

<a name="172884116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/172884116" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#172884116">Mario Carneiro (Aug 09 2019 at 19:58)</a>:</h4>
<p>I can believe that the coercion is problematic sometimes though. The alternative is to write <code>.to_fun</code></p>

<a name="172884125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/172884125" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#172884125">Patrick Massot (Aug 09 2019 at 19:58)</a>:</h4>
<p>but coercions are part of the type class system</p>

<a name="172884141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/172884141" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#172884141">Patrick Massot (Aug 09 2019 at 19:58)</a>:</h4>
<p>The alternative doesn't work, because lemmas are stated without <code>.to_fun</code></p>

<a name="172884226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/172884226" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#172884226">Mario Carneiro (Aug 09 2019 at 19:59)</a>:</h4>
<p>Personally, I would happily live with <code>to_fun</code> everywhere. I put the coercions in because you guys are always going on about nice looking notation and lean 3 provides few other opportunities for this kind of thing</p>

<a name="172884304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/172884304" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#172884304">Patrick Massot (Aug 09 2019 at 20:00)</a>:</h4>
<p>This is really sad</p>

<a name="172884313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/172884313" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#172884313">Yury G. Kudryashov (Aug 09 2019 at 20:00)</a>:</h4>
<p>/me prefers <code>Python</code>-style <code>obj.__call__</code> convention over typeclass resolution</p>

<a name="172884356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/172884356" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#172884356">Mario Carneiro (Aug 09 2019 at 20:01)</a>:</h4>
<p>I agree completely (to both statements)</p>

<a name="172884966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/172884966" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#172884966">Yury G. Kudryashov (Aug 09 2019 at 20:09)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  What's are the other opportunities in Lean 3 for this kind of thing?</p>

<a name="172885066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/172885066" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#172885066">Mario Carneiro (Aug 09 2019 at 20:10)</a>:</h4>
<p>for zero-notation functions, nothing, but if you are willing to accept a character or two you can use a notation</p>

<a name="172885219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/172885219" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#172885219">Yury G. Kudryashov (Aug 09 2019 at 20:12)</a>:</h4>
<p>BTW, what's wrong with dropping <code>has_coe_to_fun</code> and using <code>f.1</code>?</p>

<a name="172885280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/172885280" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#172885280">Yury G. Kudryashov (Aug 09 2019 at 20:13)</a>:</h4>
<p>Forgot to tag <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span></p>

<a name="172885296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/172885296" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#172885296">Patrick Massot (Aug 09 2019 at 20:13)</a>:</h4>
<p>This is really not how we think about maps</p>

<a name="172885925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/172885925" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#172885925">Yury G. Kudryashov (Aug 09 2019 at 20:22)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> I see the following options:<br>
1. the old way; <strong>pros</strong>: already implemented; easy to say that the same map can be <code>is_mul_hom</code> or <code>is_monoid_hom</code> under different assumptions; <strong>cons</strong>: need to find <code>is_*_hom</code> instances here and there; what else?<br>
2. bundled homs, implicit coercion; <strong>pros</strong>: <code>map_mul</code> and <code>map_one</code> are right there; <code>M →* N</code> is exactly <code>Mon.of M \--&gt; Mon.of N</code> (not yet); <strong>cons</strong>: need to find <code>has_coe_to_fun</code> every time; sometimes this coercion fails;<br>
3. bundled homs, <code>f.1</code>; <strong>pros</strong>: see 2 + no class instance resolution at all; <strong>cons</strong>: unnatural notation.<br>
What do I miss?</p>

<a name="172888189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/172888189" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#172888189">Patrick Massot (Aug 09 2019 at 20:55)</a>:</h4>
<p>I don't see what I could add here. Type class inference doesn't work in Lean 3, and it doesn't provide error messages</p>

<a name="172888724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/172888724" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#172888724">Patrick Massot (Aug 09 2019 at 21:02)</a>:</h4>
<blockquote>
<p>2. Yes it breaks the naming conventions. Computer scientists get a lot of things right about names, but I believe that one of very few exceptions is here. If a computer scientist wants to a call a group alpha and a normal subgroup beta and then some auxiliary set gamma then that's fine by me, but if we call the group G and the normal subgroup N and the auxiliary set S then it is much easier to see at a glance what is happening, especially if variables are being used and the definitions of alpha and beta are 150 lines up. </p>
</blockquote>
<p>I also wanted to comment on that. The linear algebra library uses the random greek letter convention, and it's really a nightmare. They are lots of type involved, and not knowing which one is meant to be a base field, an indexing type or a vector space is really awful. They are tons of lemmas whose statements are very hard to parse, and would be very easy with reasonable type naming conventions.</p>

<a name="172889261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/172889261" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#172889261">Yury G. Kudryashov (Aug 09 2019 at 21:10)</a>:</h4>
<p>Then maybe <code>docs/contribute/naming.md</code> should be adjusted.</p>

<a name="172889262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/172889262" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#172889262">Yury G. Kudryashov (Aug 09 2019 at 21:10)</a>:</h4>
<p>With some sensible theory-specific naming conventions.</p>

<a name="172889279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/172889279" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#172889279">Patrick Massot (Aug 09 2019 at 21:10)</a>:</h4>
<p>I'd love that</p>

<a name="172893316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/172893316" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#172893316">Kevin Buzzard (Aug 09 2019 at 22:10)</a>:</h4>
<p>+1 from me.</p>

<a name="172893457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/172893457" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#172893457">Kevin Buzzard (Aug 09 2019 at 22:12)</a>:</h4>
<p><span class="user-mention" data-user-id="214703">@Yury G. Kudryashov</span> the reason I'm bundling is because the community seems to think it's the best idea. To a certain extent it might just be about experimenting to find out what works best. I have seen coercions fail before and you can just write (f : G -&gt; H) to make them happen; I quite like that notation</p>

<a name="172896705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/172896705" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#172896705">Kevin Buzzard (Aug 09 2019 at 23:03)</a>:</h4>
<p>The one place where I feel that the alpha beta notation is natural is when dealing with types that really are that -- just types. For example <code>equiv alpha beta</code> seems fine to me because for all I know this is what computer scientists really call types. But types which are playing a mathematical role such as groups have got such a history of notation behind them and it's used to guide readers, and I don't see the point of throwing it away. Sure some people use <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> for a number field and some use <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>, but nobody uses <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>. The number field library that will one day be written will need to choose a notation, but it should, in my opinion, use one which is already in use.</p>

<a name="172901583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/172901583" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#172901583">Andrew Ashworth (Aug 10 2019 at 00:50)</a>:</h4>
<p>morally speaking isn't it <code>[G : group alpha]</code>?</p>


{% endraw %}

{% include archive_update.html %}