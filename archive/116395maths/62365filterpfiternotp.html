---
layout: archive
title: Lean Prover Zulip Chat Archive 
permalink: archive/116395maths/62365filterpfiternotp.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html">filter p + fiter not p</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="132190025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132190025" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132190025">Kevin Buzzard (Aug 15 2018 at 18:08)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">multiset</span>

<span class="kn">open</span> <span class="n">multiset</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]:</span>
<span class="n">filter</span> <span class="n">p</span> <span class="n">M</span> <span class="bp">+</span> <span class="n">filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">a</span><span class="o">)</span> <span class="n">M</span> <span class="bp">=</span> <span class="n">M</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>


<p>I want this to be much easier than it's turning out to be! Should I be using <code>add_sub_of_le</code>?</p>

<a name="132190288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132190288" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132190288">Kevin Buzzard (Aug 15 2018 at 18:12)</a>:</h4>
<p>Aah Chris has given me a hint :-)</p>

<a name="132195469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132195469" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132195469">Kevin Buzzard (Aug 15 2018 at 19:42)</a>:</h4>
<p>I'm actually trying to prove this:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">multiset</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">l</span> <span class="err">∈</span> <span class="n">L</span><span class="o">,</span> <span class="n">l</span> <span class="bp">=</span> <span class="mi">4</span> <span class="bp">∨</span> <span class="n">l</span> <span class="bp">=</span> <span class="mi">6</span> <span class="bp">∨</span> <span class="n">l</span> <span class="bp">≥</span> <span class="mi">8</span><span class="o">)</span> <span class="o">:</span>
<span class="n">L</span> <span class="bp">=</span> <span class="n">filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">l</span><span class="o">,</span> <span class="n">l</span> <span class="bp">=</span> <span class="mi">4</span><span class="o">)</span> <span class="n">L</span> <span class="bp">+</span> <span class="n">filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">l</span><span class="o">,</span> <span class="n">l</span> <span class="bp">=</span> <span class="mi">6</span><span class="o">)</span> <span class="n">L</span> <span class="bp">+</span> <span class="n">filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">l</span><span class="o">,</span> <span class="n">l</span> <span class="bp">≥</span> <span class="mi">8</span><span class="o">)</span> <span class="n">L</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>


<p>and I had suspected I'd be done if I had the example above but now I realise I also need </p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">q</span><span class="o">]</span> <span class="o">:</span>
<span class="n">filter</span> <span class="n">p</span> <span class="o">(</span><span class="n">filter</span> <span class="n">q</span> <span class="n">L</span><span class="o">)</span> <span class="bp">=</span> <span class="n">filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">p</span> <span class="n">a</span> <span class="bp">∧</span> <span class="n">q</span> <span class="n">a</span><span class="o">)</span> <span class="n">L</span>
</pre></div>


<p>which I'd assumed would be there. </p>
<p>Am I not thinking about this in the right way?</p>

<a name="132195624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132195624" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132195624">Mario Carneiro (Aug 15 2018 at 19:45)</a>:</h4>
<p>I recently discovered that omission as well</p>

<a name="132195642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132195642" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132195642">Mario Carneiro (Aug 15 2018 at 19:45)</a>:</h4>
<p>I could have sworn there was a theorem like that already</p>

<a name="132196310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132196310" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132196310">Kevin Buzzard (Aug 15 2018 at 19:56)</a>:</h4>
<p>For the filter filter thing I've just discovered <code>filter_map</code></p>

<a name="132196408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132196408" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132196408">Kevin Buzzard (Aug 15 2018 at 19:58)</a>:</h4>
<p>There's <code>filter_map_filter_map</code>, <code>filter_filter_map</code> and <code>filter_map_eq_filter</code> and it might be a case of putting these things together.</p>

<a name="132196580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132196580" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132196580">Kevin Buzzard (Aug 15 2018 at 20:01)</a>:</h4>
<p>Another thing I need is </p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">l</span> <span class="err">∈</span> <span class="n">L</span><span class="o">,</span> <span class="n">p</span> <span class="n">l</span> <span class="bp">↔</span> <span class="n">q</span> <span class="n">l</span><span class="o">)</span>
<span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">q</span><span class="o">]</span> <span class="o">:</span>
<span class="n">filter</span> <span class="n">p</span> <span class="n">L</span> <span class="bp">=</span> <span class="n">filter</span> <span class="n">q</span> <span class="n">L</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>


<p>which I suspect I can get with judicious application of <code>filter_le</code></p>

<a name="132197033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132197033" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132197033">Mario Carneiro (Aug 15 2018 at 20:08)</a>:</h4>
<p>that should definitely be there, it should be called <code>filter_congr</code></p>

<a name="132197419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132197419" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132197419">Kevin Buzzard (Aug 15 2018 at 20:15)</a>:</h4>
<p>It seems that it's there for lists but not multisets. Would you try and deduce it for multisets from the list result or use <code>le_filter</code>?</p>

<a name="132198058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132198058" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132198058">Kevin Buzzard (Aug 15 2018 at 20:29)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">filter_congr</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">l</span> <span class="err">∈</span> <span class="n">L</span><span class="o">,</span> <span class="n">p</span> <span class="n">l</span> <span class="bp">↔</span> <span class="n">q</span> <span class="n">l</span><span class="o">)</span>
<span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">q</span><span class="o">]</span> <span class="o">:</span>
<span class="n">filter</span> <span class="n">p</span> <span class="n">L</span> <span class="bp">=</span> <span class="n">filter</span> <span class="n">q</span> <span class="n">L</span> <span class="o">:=</span>
<span class="n">le_antisymm</span>
  <span class="o">(</span><span class="n">le_filter</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">⟨</span><span class="n">filter_le</span> <span class="bp">_</span><span class="o">,</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">Ha</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">mem_filter</span> <span class="n">at</span> <span class="n">Ha</span><span class="bp">;</span><span class="n">exact</span> <span class="o">(</span><span class="n">H</span> <span class="n">a</span> <span class="n">Ha</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="n">Ha</span><span class="bp">.</span><span class="mi">2</span><span class="bp">⟩</span><span class="o">)</span>
  <span class="o">(</span><span class="n">le_filter</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">⟨</span><span class="n">filter_le</span> <span class="bp">_</span><span class="o">,</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">Ha</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">mem_filter</span> <span class="n">at</span> <span class="n">Ha</span><span class="bp">;</span><span class="n">exact</span> <span class="o">(</span><span class="n">H</span> <span class="n">a</span> <span class="n">Ha</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="n">Ha</span><span class="bp">.</span><span class="mi">2</span><span class="bp">⟩</span><span class="o">)</span>
</pre></div>


<p>I'm now at the stage where I can usually prove these things, but am wondering whether I should be trying to prove them or just asking one of the experts to prove it in half the time. I guess a few months ago I had a Mario factor of 10, but maybe he'd have a job making that proof ten times smaller.</p>

<a name="132198230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132198230" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132198230">Kevin Buzzard (Aug 15 2018 at 20:32)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> when you wake up you might like these</p>

<a name="132198236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132198236" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132198236">Mario Carneiro (Aug 15 2018 at 20:32)</a>:</h4>
<div class="codehilite"><pre><span></span>lemma filter_congr {p q : α → Prop} [decidable_pred p] [decidable_pred q]
  {s : multiset α} : (∀ x ∈ s, p x ↔ q x) → filter p s = filter q s :=
quot.induction_on s $ λ l h, congr_arg coe $ filter_congr h
</pre></div>

<a name="132198257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132198257" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132198257">Mario Carneiro (Aug 15 2018 at 20:33)</a>:</h4>
<p>that's like a mario factor of 2.5 or so</p>

<a name="132198259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132198259" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132198259">Mario Carneiro (Aug 15 2018 at 20:33)</a>:</h4>
<p>so definite improvement :)</p>

<a name="132198264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132198264" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132198264">Kevin Buzzard (Aug 15 2018 at 20:33)</a>:</h4>
<p>so you did go for the list approach. Quotients still scare me :-/</p>

<a name="132198307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132198307" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132198307">Mario Carneiro (Aug 15 2018 at 20:34)</a>:</h4>
<p>the theorem was already there...</p>

<a name="132198316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132198316" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132198316">Mario Carneiro (Aug 15 2018 at 20:34)</a>:</h4>
<p>quot.induction_on is great, since everything is suddenly defeq to the equivalent list definition</p>

<a name="132199346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132199346" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132199346">Kevin Buzzard (Aug 15 2018 at 20:54)</a>:</h4>
<p>So I look at it and think "crumbs, I'll end up having to prove that if L1 and L2 are lists which biject with each other then so do filter p L1 and filter p L2, I'm not sure I fancy that..."</p>

<a name="132199458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132199458" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132199458">Chris Hughes (Aug 15 2018 at 20:57)</a>:</h4>
<p>There's only one list.</p>

<a name="132200798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132200798" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132200798">Kevin Buzzard (Aug 15 2018 at 21:28)</a>:</h4>
<p>I just spent some time actually looking at Mario's proof, and somehow he doesn't have to do at all what I expected him to have to do. The work I imagined having to do is already done in the definition of <code>multiset.filter</code>. Hence the proof is much easier than I'd imagined.</p>

<a name="132201117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132201117" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132201117">Kevin Buzzard (Aug 15 2018 at 21:35)</a>:</h4>
<p>There are 45 instances of this <code>congr_arg coe</code> trick in <code>multiset.lean</code></p>

<a name="132201380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132201380" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132201380">Mario Carneiro (Aug 15 2018 at 21:41)</a>:</h4>
<p>it's basically just saying that when two lists are equal then the multisets they generate are also equal</p>

<a name="132201440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132201440" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132201440">Mario Carneiro (Aug 15 2018 at 21:42)</a>:</h4>
<p>it's very common for multiset equalities after applying <code>quot.induction_on</code> since you might know that the lists are equal</p>

<a name="132201459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132201459" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132201459">Mario Carneiro (Aug 15 2018 at 21:43)</a>:</h4>
<p>for example, associativity of addition of multisets follows from associativity of append on lists, but since the goal is to show that the multisets are equal rather than the lists, we have to <code>congr_arg coe</code></p>

<a name="132201474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132201474" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132201474">Mario Carneiro (Aug 15 2018 at 21:43)</a>:</h4>
<p>if instead, we knew not that the lists were equal but that they were permutations of each other, we would use <code>quot.sound</code> instead</p>

<a name="132202271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132202271" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132202271">Kevin Buzzard (Aug 15 2018 at 22:01)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">q</span><span class="o">]</span> <span class="o">:</span>
<span class="n">filter</span> <span class="n">p</span> <span class="o">(</span><span class="n">filter</span> <span class="n">q</span> <span class="n">L</span><span class="o">)</span> <span class="bp">=</span> <span class="n">filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">p</span> <span class="n">a</span> <span class="bp">∧</span> <span class="n">q</span> <span class="n">a</span><span class="o">)</span> <span class="n">L</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="err">←</span><span class="n">filter_map_eq_filter</span> <span class="n">q</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">filter_filter_map</span><span class="o">,</span>
  <span class="n">rw</span> <span class="err">←</span><span class="n">filter_map_eq_filter</span><span class="o">,</span>
  <span class="n">congr</span><span class="o">,</span>
  <span class="n">funext</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">option</span><span class="bp">.</span><span class="n">filter</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">option</span><span class="bp">.</span><span class="n">guard</span><span class="o">,</span>
  <span class="n">split_ifs</span><span class="bp">;</span><span class="n">unfold</span> <span class="n">option</span><span class="bp">.</span><span class="n">bind</span><span class="bp">;</span> <span class="n">try</span> <span class="o">{</span><span class="n">unfold</span> <span class="n">option</span><span class="bp">.</span><span class="n">guard</span><span class="bp">;</span><span class="n">split_ifs</span><span class="o">},</span>
  <span class="n">finish</span><span class="o">,</span><span class="n">cc</span><span class="o">,</span><span class="n">finish</span><span class="o">,</span><span class="n">refl</span><span class="o">,</span><span class="n">finish</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p>I kept wanting it to die but it wouldn't die. I'm not sure this one is mathlib-ready.</p>

<a name="132203124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132203124" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132203124">Mario Carneiro (Aug 15 2018 at 22:18)</a>:</h4>
<p>no worries, I killed it</p>

<a name="132203154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132203154" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132203154">Mario Carneiro (Aug 15 2018 at 22:18)</a>:</h4>
<blockquote>
<p><code>finish,cc,finish,refl,finish</code></p>
</blockquote>
<p>lol, I'm imagining kevin stabbing the proof "die! die! you're finished!"</p>

<a name="132206369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132206369" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132206369">Kevin Buzzard (Aug 15 2018 at 23:27)</a>:</h4>
<p>I guess I can do the original question using <code>multiset.ext</code> if I had these:</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">count_filter_eq_zero</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span>
<span class="o">(</span><span class="n">hnp</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">count</span> <span class="n">a</span> <span class="o">(</span><span class="n">filter</span> <span class="n">p</span> <span class="n">M</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="n">count_eq_zero</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">Hin</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">mem_filter</span> <span class="n">at</span> <span class="n">Hin</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">hnp</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">Hin</span><span class="bp">.</span><span class="n">right</span>
<span class="kn">end</span>

<span class="kn">theorem</span> <span class="n">count_filter</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span>
<span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">count</span> <span class="n">a</span> <span class="n">M</span> <span class="bp">=</span> <span class="n">count</span> <span class="n">a</span> <span class="o">(</span><span class="n">filter</span> <span class="n">p</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>


<p>Straightforward for the first one and could easily be mathlibbed up; one could also define <code>count_filter</code> to mean <code>count a (filter p M) = if (p a) then count a M else 0</code>, perhaps that's the natural lemma?</p>

<a name="132206556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132206556" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132206556">Mario Carneiro (Aug 15 2018 at 23:31)</a>:</h4>
<p>I added the theorems fyi</p>

<a name="132207003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132207003" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132207003">Kevin Buzzard (Aug 15 2018 at 23:43)</a>:</h4>
<p>Oh thanks! I was checking email waiting for a push but I now realise that I only get emails for PR's.</p>

<a name="132285416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132285416" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132285416">Kenny Lau (Aug 17 2018 at 06:27)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">multiset</span>

<span class="kn">open</span> <span class="n">multiset</span>

<span class="kn">theorem</span> <span class="n">filter_inclusion_exclusion</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
  <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">q</span><span class="o">]</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">filter</span> <span class="n">p</span> <span class="n">L</span> <span class="bp">+</span> <span class="n">filter</span> <span class="n">q</span> <span class="n">L</span> <span class="bp">=</span> <span class="n">filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">∨</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="n">L</span> <span class="bp">+</span> <span class="n">filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="n">L</span> <span class="o">:=</span>
<span class="n">multiset</span><span class="bp">.</span><span class="n">induction_on</span> <span class="n">L</span> <span class="o">(</span><span class="k">by</span> <span class="n">simp</span><span class="o">)</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">hd</span> <span class="n">tl</span> <span class="n">ih</span><span class="o">,</span>
<span class="k">by</span> <span class="n">by_cases</span> <span class="n">H1</span> <span class="o">:</span> <span class="n">p</span> <span class="n">hd</span><span class="bp">;</span> <span class="n">by_cases</span> <span class="n">H2</span> <span class="o">:</span> <span class="n">q</span> <span class="n">hd</span><span class="bp">;</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">H1</span><span class="o">,</span> <span class="n">H2</span><span class="o">]</span> <span class="kn">using</span> <span class="n">ih</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">multiset</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">l</span> <span class="err">∈</span> <span class="n">L</span><span class="o">,</span> <span class="n">l</span> <span class="bp">=</span> <span class="mi">4</span> <span class="bp">∨</span> <span class="n">l</span> <span class="bp">=</span> <span class="mi">6</span> <span class="bp">∨</span> <span class="n">l</span> <span class="bp">≥</span> <span class="mi">8</span><span class="o">)</span> <span class="o">:</span>
<span class="n">L</span> <span class="bp">=</span> <span class="n">filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">l</span><span class="o">,</span> <span class="n">l</span> <span class="bp">=</span> <span class="mi">4</span><span class="o">)</span> <span class="n">L</span> <span class="bp">+</span> <span class="n">filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">l</span><span class="o">,</span> <span class="n">l</span> <span class="bp">=</span> <span class="mi">6</span><span class="o">)</span> <span class="n">L</span> <span class="bp">+</span> <span class="n">filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">l</span><span class="o">,</span> <span class="n">l</span> <span class="bp">≥</span> <span class="mi">8</span><span class="o">)</span> <span class="n">L</span> <span class="o">:=</span>
<span class="k">have</span> <span class="n">H1</span> <span class="o">:</span> <span class="n">filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">4</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">6</span><span class="o">)</span> <span class="n">L</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
  <span class="k">from</span> <span class="n">filter_eq_nil</span><span class="bp">.</span><span class="mi">2</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">H</span><span class="o">,</span> <span class="k">by</span> <span class="n">cc</span><span class="o">,</span>
<span class="k">have</span> <span class="n">H2</span> <span class="o">:</span> <span class="n">filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="mi">4</span> <span class="bp">∨</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">6</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">≥</span> <span class="mi">8</span><span class="o">)</span> <span class="n">L</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
  <span class="k">from</span> <span class="n">filter_eq_nil</span><span class="bp">.</span><span class="mi">2</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">H</span><span class="o">,</span> <span class="k">by</span> <span class="n">cases</span> <span class="n">H</span><span class="bp">.</span><span class="mi">1</span><span class="bp">;</span> <span class="n">subst</span> <span class="n">h</span><span class="bp">;</span>
  <span class="k">from</span> <span class="n">absurd</span> <span class="n">H</span><span class="bp">.</span><span class="mi">2</span> <span class="n">dec_trivial</span><span class="o">,</span>
<span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">filter_inclusion_exclusion</span><span class="o">,</span> <span class="n">H1</span><span class="o">,</span> <span class="n">add_zero</span><span class="o">]</span><span class="bp">;</span>
<span class="n">rw</span> <span class="o">[</span><span class="n">filter_inclusion_exclusion</span><span class="o">,</span> <span class="n">H2</span><span class="o">,</span> <span class="n">add_zero</span><span class="o">]</span><span class="bp">;</span>
<span class="n">symmetry</span><span class="bp">;</span> <span class="n">rw</span> <span class="o">[</span><span class="n">filter_eq_self</span><span class="o">]</span><span class="bp">;</span> <span class="n">intros</span><span class="bp">;</span>
<span class="n">rw</span> <span class="o">[</span><span class="n">or_assoc</span><span class="o">]</span><span class="bp">;</span> <span class="n">solve_by_elim</span>
</pre></div>

<a name="132286367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132286367" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132286367">Mario Carneiro (Aug 17 2018 at 06:58)</a>:</h4>
<p><code>filter_inclusion_exclusion</code> is already in mathlib, I think I called it <code>filter_add_filter</code></p>

<a name="132288987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132288987" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132288987">Kevin Buzzard (Aug 17 2018 at 08:17)</a>:</h4>
<p><span class="user-mention" data-user-id="120469">@Ellen Arlt</span> with this and the 468 lemma you can break up your multiset into those three multisets, and evaluate the sum for the fully controlled value on each one. This is how I would prove the second lemma you emailed me. I'm in a field right now with no laptop so can't do it, but everything you need is now there thanks to Mario and Kenny. If you've not done it by Tuesday I can help then.</p>

<a name="132289276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132289276" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132289276">Kevin Buzzard (Aug 17 2018 at 08:25)</a>:</h4>
<p>Are these holes in mathlib by the way? Here's a stupid question. Is there not yet some completely standard list of "all the things that should be proved about multisets" somewhere, and when people make new proof verifiers they just copy the list? I know <code>multiset.lean</code> is long but in some sense are we still "making it up as we go along" and adding things people need, or will this stop at some point, or is there a known list (eg whatever the analogous file is in coq or whatever) of facts which people will need and which haven't all been written up yet? I'm assuming not. I'm asking what multiset.lean will look like in 5 years' time basically</p>

<a name="132289497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132289497" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132289497">Mario Carneiro (Aug 17 2018 at 08:30)</a>:</h4>
<p>I think it is a process of continuous addition with a finite limit</p>

<a name="132289507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132289507" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132289507">Sean Leather (Aug 17 2018 at 08:30)</a>:</h4>
<p>I think there are a couple of things here:</p>
<p>1. It's hard to imagine all the theorems needed to make a theory (e.g. of multisets) complete.<br>
2. Even if you can imagine them all, it will take time to implement them.<br>
3. If you don't release before you implement them all, nobody else can use what you have in the meantime.</p>

<a name="132289524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132289524" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132289524">Mario Carneiro (Aug 17 2018 at 08:31)</a>:</h4>
<p>for example, <code>filter_inclusion_exclusion</code> is on that list, this 468 lemma is not</p>

<a name="132289586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132289586" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132289586">Mario Carneiro (Aug 17 2018 at 08:32)</a>:</h4>
<p>the criterion is basically to have maximally general theorems which combine at most two or three concepts together</p>

<a name="132289624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132289624" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132289624">Mario Carneiro (Aug 17 2018 at 08:33)</a>:</h4>
<p>i.e. <code>a + b + c = a + (b + c)</code> is a good lemma, <code>a + (a + b) + c + (d + e) = e + a + (a + c) + (d + b)</code> is not</p>

<a name="132289841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132289841" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132289841">Mario Carneiro (Aug 17 2018 at 08:39)</a>:</h4>
<p>Coq probably has a similar file, and they are going through a similar process, but since their file is older I'm sure they will be closer to convergence and we might find a few lemmas there that aren't in mathlib. But no one has the complete list, and like any convergent sequence of integers I'm not sure we would know that we have converged when we do</p>

<a name="132289918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132289918" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132289918">Sean Leather (Aug 17 2018 at 08:41)</a>:</h4>
<p>So we need a (meta) proof that the theory is complete...</p>

<a name="132290080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132290080" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132290080">Mario Carneiro (Aug 17 2018 at 08:44)</a>:</h4>
<p>I think that in principle you could write a program to generate these facts. The hart part would be picking only the true ones</p>

<a name="132290108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132290108" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132290108">Mario Carneiro (Aug 17 2018 at 08:45)</a>:</h4>
<p>But keep in mind that this generation process is also highly dependent on what definitions exist. The more definitions you have, the more ways there are to combine them</p>

<a name="132290159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132290159" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132290159">Mario Carneiro (Aug 17 2018 at 08:46)</a>:</h4>
<p>so a definition can make a previously arbitrary looking statement become a natural question</p>

<a name="132290182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132290182" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132290182">Mario Carneiro (Aug 17 2018 at 08:47)</a>:</h4>
<p>and this is why I take seriously the introduction of new definitions, since every definition comes with a cloud of associated theorems to prove</p>

<a name="132290240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132290240" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132290240">Gabriel Ebner (Aug 17 2018 at 08:49)</a>:</h4>
<blockquote>
<p>I think that in principle you could write a program to generate these facts. The hart part would be picking only the true ones</p>
</blockquote>
<p>Moa Johannson has done some work on theory exploration; <a href="https://github.com/moajohansson/IsaHipster" target="_blank" title="https://github.com/moajohansson/IsaHipster">IsaHipster</a> is pretty much such a tool for Isabelle.  Essentially, they enumerate statements up to a certain size and use random testing to filter out obviously wrong ones.  The rest are handed to sledgehammer.</p>

<a name="132559474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20p%20%2B%20fiter%20not%20p/near/132559474" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62365filterpfiternotp.html#132559474">Scott Morrison (Aug 22 2018 at 05:23)</a>:</h4>
<p>Ugh... I'm not sure I want to be part of a tradition of mathematics that works that way. :-)</p>


{% endraw %}
