---
layout: archive
title: Lean Prover Zulip Chat Archive 
permalink: archive/116395maths/28435topologygeneratedbyanorder.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/28435topologygeneratedbyanorder.html">topology generated by an order</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="132171480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topology%20generated%20by%20an%20order/near/132171480" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28435topologygeneratedbyanorder.html#132171480">Kevin Buzzard (Aug 15 2018 at 12:19)</a>:</h4>
<p>I don't know in what generality it's meaningful to ask about the topology "generated by" an order. Luca found <code>ordered_topology</code> in <code>analysis/topology/topological_structures.lean</code> but this is an assertion that sets coming from the order are closed in the topology, it doesn't rule out there being far more closed sets. </p>
<p>Here's a concrete question. Is there a theorem in mathlib saying that the topology on the reals is the one associated in some way to the total order <code>&lt;</code> on the reals? Presumably with a total order one can define basic open sets <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>{</mo><mi>x</mi><mo>:</mo><mi>a</mi><mo>&lt;</mo><mi>x</mi><mo>&lt;</mo><mi>b</mi><mo>}</mo></mrow><annotation encoding="application/x-tex">\{x : a&lt;x&lt;b\}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">{</span><span class="mord mathit">x</span><span class="mrel">:</span><span class="mord mathit">a</span><span class="mrel">&lt;</span><span class="mord mathit">x</span><span class="mrel">&lt;</span><span class="mord mathit">b</span><span class="mclose">}</span></span></span></span> for each pair <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(a,b)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">(</span><span class="mord mathit">a</span><span class="mpunct">,</span><span class="mord mathit">b</span><span class="mclose">)</span></span></span></span>. Is this all there already and how much further does it go? Seems to work fine for total orders, but probably not for partial orders because we seem to need infs and sups. Is this what a lattice is? I am reluctant to do work that's already there and as you can see I am not currently even sure which files I should be looking in.</p>

<a name="132173596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topology%20generated%20by%20an%20order/near/132173596" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28435topologygeneratedbyanorder.html#132173596">Mario Carneiro (Aug 15 2018 at 13:08)</a>:</h4>
<p>note the difference between <code>ordered_topology</code> and <code>orderable_topology</code></p>

<a name="132173603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topology%20generated%20by%20an%20order/near/132173603" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28435topologygeneratedbyanorder.html#132173603">Mario Carneiro (Aug 15 2018 at 13:08)</a>:</h4>
<p>the latter is for what topologists usually call "the order topology"</p>

<a name="132173635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topology%20generated%20by%20an%20order/near/132173635" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28435topologygeneratedbyanorder.html#132173635">Mario Carneiro (Aug 15 2018 at 13:09)</a>:</h4>
<p>the former is more like an order-respecting topology</p>

<a name="132173703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topology%20generated%20by%20an%20order/near/132173703" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28435topologygeneratedbyanorder.html#132173703">Mario Carneiro (Aug 15 2018 at 13:10)</a>:</h4>
<blockquote>
<p>Is there a theorem in mathlib saying that the topology on the reals is the one associated in some way to the total order &lt; on the reals?</p>
</blockquote>
<p>Yes, this is the instance of <code>orderable_topology real</code></p>

<a name="132173758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topology%20generated%20by%20an%20order/near/132173758" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28435topologygeneratedbyanorder.html#132173758">Mario Carneiro (Aug 15 2018 at 13:11)</a>:</h4>
<blockquote>
<p>Is this all there already and how much further does it go? Seems to work fine for total orders, but probably not for partial orders because we seem to need infs and sups. </p>
</blockquote>
<p>If you look at the definition in <code>ordered_topology</code>, you will see that we require that closed intervals are closed, not that open intervals are open. In partial orders this is more natural. In total orders they are equivalent</p>

<a name="132175935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topology%20generated%20by%20an%20order/near/132175935" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28435topologygeneratedbyanorder.html#132175935">Kevin Buzzard (Aug 15 2018 at 13:57)</a>:</h4>
<p>Aah this is perfect -- <code>orderable_topology</code> is exactly what we want. Thanks!</p>

<a name="132231564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topology%20generated%20by%20an%20order/near/132231564" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28435topologygeneratedbyanorder.html#132231564">Luca Gerolla (Aug 16 2018 at 10:46)</a>:</h4>
<p>Thank you very much Mario... It was very helpful to understand the different "order_topologies" in <code>analysis/topology/topological_structures.lean</code>and at the end I found the result I needed: </p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">frontier_lt_subset_eq</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_linear_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">t</span> <span class="o">:</span> <span class="n">ordered_topology</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">[</span><span class="n">topological_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">continuous</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">hg</span> <span class="o">:</span> <span class="n">continuous</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span>
<span class="n">frontier</span> <span class="o">{</span><span class="n">b</span> <span class="bp">|</span> <span class="n">f</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">g</span> <span class="n">b</span><span class="o">}</span> <span class="err">⊆</span> <span class="o">{</span><span class="n">b</span> <span class="bp">|</span> <span class="n">f</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">g</span> <span class="n">b</span><span class="o">}</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">unfold</span> <span class="n">frontier</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h₁</span> <span class="o">:</span> <span class="n">interior</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">f</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">g</span> <span class="n">b</span><span class="o">}</span> <span class="bp">=</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">f</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">g</span> <span class="n">b</span><span class="o">},</span>
    <span class="n">exact</span> <span class="n">interior_eq_iff_open</span><span class="bp">.</span><span class="mi">2</span> <span class="o">(</span><span class="n">is_open_lt</span>  <span class="n">hf</span> <span class="n">hg</span><span class="o">),</span> <span class="n">rw</span> <span class="n">h₁</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h₂</span> <span class="o">:</span> <span class="n">closure</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">f</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">g</span> <span class="n">b</span><span class="o">}</span> <span class="err">⊆</span> <span class="n">closure</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">f</span> <span class="n">b</span> <span class="bp">≤</span>  <span class="n">g</span> <span class="n">b</span><span class="o">},</span>
    <span class="n">refine</span> <span class="n">closure_mono</span> <span class="bp">_</span>  <span class="o">,</span> <span class="n">rw</span> <span class="n">set</span><span class="bp">.</span><span class="n">set_of_subset_set_of</span><span class="o">,</span> <span class="n">intros</span> <span class="n">x</span> <span class="n">h</span><span class="o">,</span> <span class="n">exact</span> <span class="n">le_of_lt</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h₃</span> <span class="o">:</span> <span class="n">closure</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">f</span> <span class="n">b</span> <span class="bp">≤</span>  <span class="n">g</span> <span class="n">b</span><span class="o">}</span> <span class="bp">=</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">f</span> <span class="n">b</span> <span class="bp">≤</span>  <span class="n">g</span> <span class="n">b</span><span class="o">},</span>
    <span class="n">exact</span> <span class="n">closure_eq_iff_is_closed</span><span class="bp">.</span><span class="mi">2</span> <span class="o">(</span><span class="n">is_closed_le</span> <span class="n">hf</span> <span class="n">hg</span><span class="o">),</span> <span class="n">rw</span> <span class="n">h₃</span> <span class="n">at</span> <span class="n">h₂</span> <span class="o">,</span>
  <span class="k">have</span> <span class="n">g₁</span> <span class="o">:</span> <span class="n">closure</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">f</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">g</span> <span class="n">b</span><span class="o">}</span> <span class="err">\</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">f</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">g</span> <span class="n">b</span><span class="o">}</span> <span class="err">⊆</span>
                 <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">f</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">g</span> <span class="n">b</span><span class="o">}</span> <span class="err">\</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">f</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">g</span> <span class="n">b</span><span class="o">},</span>
   <span class="o">{</span><span class="n">unfold</span> <span class="n">has_sdiff</span><span class="bp">.</span><span class="n">sdiff</span> <span class="n">set</span><span class="bp">.</span><span class="n">diff</span><span class="o">,</span> <span class="n">intros</span> <span class="n">a</span> <span class="n">Ha</span><span class="o">,</span> <span class="n">simp</span> <span class="n">at</span> <span class="n">Ha</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">Ha</span> <span class="k">with</span> <span class="n">a₁</span> <span class="n">a₂</span> <span class="o">,</span>
    <span class="k">have</span> <span class="n">h₄</span> <span class="o">:</span> <span class="n">a</span> <span class="err">∈</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">f</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">g</span> <span class="n">b</span><span class="o">},</span> <span class="n">exact</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_of_mem_of_subset</span> <span class="n">a₁</span> <span class="n">h₂</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">mem_set_of_eq</span> <span class="n">at</span> <span class="n">h₄</span><span class="o">,</span> <span class="n">exact</span> <span class="bp">⟨</span> <span class="n">h₄</span><span class="o">,</span> <span class="n">a₂</span> <span class="bp">⟩</span> <span class="o">,</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">g₂</span> <span class="o">:</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">f</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">g</span> <span class="n">b</span><span class="o">}</span> <span class="err">\</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">f</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">g</span> <span class="n">b</span><span class="o">}</span> <span class="err">⊆</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">f</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">g</span> <span class="n">b</span><span class="o">},</span>
    <span class="n">unfold</span> <span class="n">has_sdiff</span><span class="bp">.</span><span class="n">sdiff</span> <span class="n">set</span><span class="bp">.</span><span class="n">diff</span><span class="o">,</span> <span class="n">intros</span> <span class="n">a</span> <span class="n">Ha</span><span class="o">,</span> <span class="n">simp</span>  <span class="n">at</span> <span class="n">Ha</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">mem_set_of_eq</span><span class="o">,</span> <span class="n">exact</span> <span class="n">le_antisymm</span> <span class="n">Ha</span><span class="bp">.</span><span class="mi">1</span> <span class="n">Ha</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">set</span><span class="bp">.</span><span class="n">subset</span><span class="bp">.</span><span class="n">trans</span> <span class="n">g₁</span> <span class="n">g₂</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p>By any chance, would this be helpful (with slicker proof) in mathlib in addition to <code>frontier_le_subset_eq</code>?</p>

<a name="132231657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topology%20generated%20by%20an%20order/near/132231657" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28435topologygeneratedbyanorder.html#132231657">Mario Carneiro (Aug 16 2018 at 10:48)</a>:</h4>
<p>this should be an easy consequence of <code>frontier_le_subset_eq</code></p>

<a name="132231681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topology%20generated%20by%20an%20order/near/132231681" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28435topologygeneratedbyanorder.html#132231681">Mario Carneiro (Aug 16 2018 at 10:49)</a>:</h4>
<p>The frontier of the complement of A is the same as the frontier of A, so each implies the other since <code>{b | f b &lt; g b}</code> is the complement of <code>{b | g b &lt;= f b} </code></p>

<a name="132232056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topology%20generated%20by%20an%20order/near/132232056" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28435topologygeneratedbyanorder.html#132232056">Mario Carneiro (Aug 16 2018 at 10:59)</a>:</h4>
<p>added</p>

<a name="132232441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topology%20generated%20by%20an%20order/near/132232441" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28435topologygeneratedbyanorder.html#132232441">Luca Gerolla (Aug 16 2018 at 11:09)</a>:</h4>
<blockquote>
<p>The frontier of the complement of A is the same as the frontier of A, so each implies the other since <code>{b | f b &lt; g b}</code> is the complement of <code>{b | g b &lt;= f b} </code></p>
</blockquote>
<p>I did try to go along this line of reasoning but  I did not find it that shorter ... Definitely not 2 lines like yours! :)</p>

<a name="132232506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topology%20generated%20by%20an%20order/near/132232506" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28435topologygeneratedbyanorder.html#132232506">Luca Gerolla (Aug 16 2018 at 11:10)</a>:</h4>
<p>Also nice addition  <code>frontier_compl</code>! ..I had better update my mathlib</p>


{% endraw %}
