---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/116395maths/77152categoricalproduct.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/77152categoricalproduct.html">categorical product</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="169545871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/categorical%20product/near/169545871" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/77152categoricalproduct.html#169545871">Kenny Lau (Jul 03 2019 at 07:36)</a>:</h4>
<p>Is there a category <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07153em;">C</span></span></span></span> such that:<br>
1. For every discrete category <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">D</span></span></span></span> and functor <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>:</mo><mi>D</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">F:D\to C</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mrel">:</span><span class="mord mathit" style="margin-right:0.02778em;">D</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.07153em;">C</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.13889em;">F</span></span></span></span> has a limit (i.e. every sub-multi-set of Obj(C) has limit).<br>
2. <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07153em;">C</span></span></span></span> has no product, i.e. there is no functor <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>:</mo><mi>C</mi><mo>×</mo><mi>C</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">F : C \times C \to C</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mrel">:</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mbin">×</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.07153em;">C</span></span></span></span> such that the induced natural transformation <code>Hom(A,B) x Hom(A,C) -&gt; Hom(A,F(B,C))</code> between two functors <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup><mo>×</mo><mi>C</mi><mo>×</mo><mi>C</mi><mo>→</mo><mi>S</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">C^{op} \times C \times C \to Set</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">o</span><span class="mord mathit mtight">p</span></span></span></span></span></span></span></span></span><span class="mbin">×</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mbin">×</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">e</span><span class="mord mathit">t</span></span></span></span> is a natural isomorphism</p>

<a name="169547056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/categorical%20product/near/169547056" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/77152categoricalproduct.html#169547056">Mario Carneiro (Jul 03 2019 at 07:59)</a>:</h4>
<p>Using <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo>=</mo><mrow><mrow><mn mathvariant="bold">2</mn></mrow></mrow></mrow><annotation encoding="application/x-tex">D={\bf 2}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">D</span><span class="mrel">=</span><span class="mord"><span class="mord"><span class="mord mathbf">2</span></span></span></span></span></span>, we know that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07153em;">C</span></span></span></span> has a product object <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A\times B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="base"><span class="mord mathit">A</span><span class="mbin">×</span><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span> for all <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo>∈</mo><mi>O</mi><mi>b</mi><mi>j</mi><mo>(</mo><mi>C</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">A,B\in Obj(C)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">A</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mrel">∈</span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mord mathit">b</span><span class="mord mathit" style="margin-right:0.05724em;">j</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mclose">)</span></span></span></span>. Pick one for every pair A,B to obtain a functor <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo><mo>:</mo><mi>C</mi><mo>×</mo><mi>C</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">\times:C\times C\to C</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="base"><span class="mord">×</span><span class="mrel">:</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mbin">×</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.07153em;">C</span></span></span></span>. (The object part of this is obvious, and if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><msup><mi>A</mi><mo mathvariant="normal">′</mo></msup><mo separator="true">,</mo><mi>g</mi><mo>:</mo><mi>B</mi><mo>→</mo><msup><mi>B</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">f: A\to A', g:B\to B'</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mrel">:</span><span class="mord mathit">A</span><span class="mrel">→</span><span class="mord"><span class="mord mathit">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mrel">:</span><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mrel">→</span><span class="mord"><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> then <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>×</mo><mi>g</mi><mo>:</mo><mo>=</mo><mo>[</mo><mi>f</mi><mo>∘</mo><msubsup><mi>π</mi><mrow><mi>A</mi><mo separator="true">,</mo><mi>B</mi></mrow><mn>1</mn></msubsup><mo separator="true">,</mo><mi>f</mi><mo>∘</mo><msubsup><mi>π</mi><mrow><mi>A</mi><mo separator="true">,</mo><mi>B</mi></mrow><mn>2</mn></msubsup><msub><mo>]</mo><mrow><msup><mi>A</mi><mo mathvariant="normal">′</mo></msup><mo separator="true">,</mo><msup><mi>B</mi><mo mathvariant="normal">′</mo></msup></mrow></msub></mrow><annotation encoding="application/x-tex">f\times g := [f\circ \pi^1_{A,B}, f\circ \pi^2_{A,B}]_{A',B'}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.225547em;vertical-align:-0.411439em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mbin">×</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mrel">:</span><span class="mrel">=</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mbin">∘</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.424669em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">A</span><span class="mpunct mtight">,</span><span class="mord mathit mtight" style="margin-right:0.05017em;">B</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.411439em;"></span></span></span></span></span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mbin">∘</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.424669em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">A</span><span class="mpunct mtight">,</span><span class="mord mathit mtight" style="margin-right:0.05017em;">B</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.411439em;"></span></span></span></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathit mtight">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828285714285715em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathrm mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathit mtight" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828285714285715em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathrm mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"></span></span></span></span></span></span></span></span>.) Then we can define <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϕ</mi><mo>(</mo><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi><mo separator="true">,</mo><mi>g</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>C</mi><mo>)</mo><mo>:</mo><mo>=</mo><mo>[</mo><mi>f</mi><mo separator="true">,</mo><mi>g</mi><msub><mo>]</mo><mrow><mi>B</mi><mo separator="true">,</mo><mi>C</mi></mrow></msub><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi><mo>×</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">\phi(f:A\to B, g:A\to C) := [f, g]_{B,C}:A\to B\times C</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="base"><span class="mord mathit">ϕ</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mrel">:</span><span class="mord mathit">A</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mrel">:</span><span class="mord mathit">A</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mrel">:</span><span class="mrel">=</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right:0.05017em;">B</span><span class="mpunct mtight">,</span><span class="mord mathit mtight" style="margin-right:0.07153em;">C</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"></span></span></span></span></span><span class="mrel">:</span><span class="mord mathit">A</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mbin">×</span><span class="mord mathit" style="margin-right:0.07153em;">C</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>ϕ</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>(</mo><mi>h</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi><mo>×</mo><mi>C</mi><mo>)</mo><mo>:</mo><mo>=</mo><mo>(</mo><msubsup><mi>π</mi><mrow><mi>B</mi><mo separator="true">,</mo><mi>C</mi></mrow><mn>1</mn></msubsup><mo>∘</mo><mi>h</mi><mo separator="true">,</mo><msubsup><mi>π</mi><mrow><mi>B</mi><mo separator="true">,</mo><mi>C</mi></mrow><mn>2</mn></msubsup><mo>∘</mo><mi>h</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\phi^{-1}(h:A\to B\times C) :=(\pi^1_{B,C}\circ h, \pi^2_{B,C}\circ h)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.225547em;vertical-align:-0.411439em;"></span><span class="base"><span class="mord"><span class="mord mathit">ϕ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathrm mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit">h</span><span class="mrel">:</span><span class="mord mathit">A</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mbin">×</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mrel">:</span><span class="mrel">=</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.424669em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right:0.05017em;">B</span><span class="mpunct mtight">,</span><span class="mord mathit mtight" style="margin-right:0.07153em;">C</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.411439em;"></span></span></span></span></span><span class="mbin">∘</span><span class="mord mathit">h</span><span class="mpunct">,</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.424669em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right:0.05017em;">B</span><span class="mpunct mtight">,</span><span class="mord mathit mtight" style="margin-right:0.07153em;">C</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.411439em;"></span></span></span></span></span><span class="mbin">∘</span><span class="mord mathit">h</span><span class="mclose">)</span></span></span></span> and this is an isomorphism.</p>
<p>In short, the only tricky part is using the axiom of choice to pick a product for every pair of objects. After that it's just equating two ways to say "a category with products".</p>

<a name="169548820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/categorical%20product/near/169548820" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/77152categoricalproduct.html#169548820">Kenny Lau (Jul 03 2019 at 08:28)</a>:</h4>
<p>what if Obj(C) is a class...?</p>

<a name="169548999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/categorical%20product/near/169548999" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/77152categoricalproduct.html#169548999">Mario Carneiro (Jul 03 2019 at 08:32)</a>:</h4>
<p>Then you have to be more careful about what you mean</p>

<a name="169549006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/categorical%20product/near/169549006" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/77152categoricalproduct.html#169549006">Kenny Lau (Jul 03 2019 at 08:32)</a>:</h4>
<p>is there a class that has no choice function?</p>

<a name="169549019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/categorical%20product/near/169549019" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/77152categoricalproduct.html#169549019">Mario Carneiro (Jul 03 2019 at 08:32)</a>:</h4>
<p>What's a category? What's a functor? What's an existential quantification over classes?</p>

<a name="169549034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/categorical%20product/near/169549034" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/77152categoricalproduct.html#169549034">Mario Carneiro (Jul 03 2019 at 08:33)</a>:</h4>
<p>large category theory in ZFC is tricky</p>

<a name="169549039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/categorical%20product/near/169549039" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/77152categoricalproduct.html#169549039">Kenny Lau (Jul 03 2019 at 08:33)</a>:</h4>
<p>I see</p>

<a name="169549096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/categorical%20product/near/169549096" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/77152categoricalproduct.html#169549096">Mario Carneiro (Jul 03 2019 at 08:34)</a>:</h4>
<p>For some choice of definitions, I think it's possible that you can have the existential statement 1 without any concrete functor class term refuting 2</p>

<a name="169549107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/categorical%20product/near/169549107" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/77152categoricalproduct.html#169549107">Mario Carneiro (Jul 03 2019 at 08:34)</a>:</h4>
<p>You can't prove 2 though because it's a higher order statement</p>

<a name="169549144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/categorical%20product/near/169549144" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/77152categoricalproduct.html#169549144">Mario Carneiro (Jul 03 2019 at 08:35)</a>:</h4>
<p>ZFC does not prove the existence or nonexistence of a class with no choice function</p>

<a name="169549192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/categorical%20product/near/169549192" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/77152categoricalproduct.html#169549192">Mario Carneiro (Jul 03 2019 at 08:36)</a>:</h4>
<p>Assuming that all classes have a choice function is usually called "global choice" and is morally equivalent to Lean's <code>choice</code></p>

<a name="169549195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/categorical%20product/near/169549195" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/77152categoricalproduct.html#169549195">Kenny Lau (Jul 03 2019 at 08:36)</a>:</h4>
<p>does V\{{}} admit a choice function?</p>

<a name="169549199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/categorical%20product/near/169549199" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/77152categoricalproduct.html#169549199">Mario Carneiro (Jul 03 2019 at 08:36)</a>:</h4>
<p>that's also global choice</p>

<a name="169549212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/categorical%20product/near/169549212" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/77152categoricalproduct.html#169549212">Kenny Lau (Jul 03 2019 at 08:36)</a>:</h4>
<p>I don't like this</p>

<a name="169549230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/categorical%20product/near/169549230" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/77152categoricalproduct.html#169549230">Kenny Lau (Jul 03 2019 at 08:37)</a>:</h4>
<p>it's all because of Russell</p>

<a name="169549235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/categorical%20product/near/169549235" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/77152categoricalproduct.html#169549235">Mario Carneiro (Jul 03 2019 at 08:37)</a>:</h4>
<p>You can't prove it in ZFC because it is a higher order statement, it asserts the existence of a class term</p>

<a name="169549252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/categorical%20product/near/169549252" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/77152categoricalproduct.html#169549252">Mario Carneiro (Jul 03 2019 at 08:38)</a>:</h4>
<p>You can axiomatize global choice by saying "here is a class term, I assert it is a choice function on V"</p>

<a name="169549309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/categorical%20product/near/169549309" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/77152categoricalproduct.html#169549309">Kenny Lau (Jul 03 2019 at 08:38)</a>:</h4>
<p>what if we only look at first order sentences?</p>

<a name="169549323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/categorical%20product/near/169549323" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/77152categoricalproduct.html#169549323">Mario Carneiro (Jul 03 2019 at 08:38)</a>:</h4>
<p>That is a first order statement - the "class term" can be replaced by a primitive unary predicate</p>

<a name="169549358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/categorical%20product/near/169549358" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/77152categoricalproduct.html#169549358">Mario Carneiro (Jul 03 2019 at 08:39)</a>:</h4>
<p>It's conservative over ZFC</p>

<a name="169549426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/categorical%20product/near/169549426" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/77152categoricalproduct.html#169549426">Kenny Lau (Jul 03 2019 at 08:40)</a>:</h4>
<p>is there a sentence in two variables <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\varphi(x,y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">φ</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∀</mi><mi>x</mi><mo>[</mo><mi>x</mi><mo>≠</mo><mi mathvariant="normal">∅</mi><mspace width="0.277778em"></mspace><mo>⟹</mo><mspace width="0.277778em"></mspace><mo>[</mo><mi mathvariant="normal">∃</mi><mo>!</mo><mi>y</mi><mi>φ</mi><mo>]</mo><mo>∧</mo><mo>[</mo><mi mathvariant="normal">∀</mi><mi>y</mi><mi>φ</mi><mspace width="0.277778em"></mspace><mo>⟹</mo><mspace width="0.277778em"></mspace><mi>y</mi><mo>∈</mo><mi>x</mi><mo>]</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">\forall x[x \ne \varnothing \implies [\exists! y \varphi] \land [\forall y \varphi \implies y \in x]]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathrm">∀</span><span class="mord mathit">x</span><span class="mopen">[</span><span class="mord mathit">x</span><span class="mrel">≠</span><span class="mord amsrm">∅</span><span class="mrel"><span class="mspace thickspace"></span><span class="mrel">⟹</span></span><span class="mopen"><span class="mspace thickspace"></span><span class="mopen">[</span></span><span class="mord mathrm">∃</span><span class="mclose">!</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mord mathit">φ</span><span class="mclose">]</span><span class="mbin">∧</span><span class="mopen">[</span><span class="mord mathrm">∀</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mord mathit">φ</span><span class="mrel"><span class="mspace thickspace"></span><span class="mrel">⟹</span></span><span class="mord mathit"><span class="mspace thickspace"></span><span class="mord mathit" style="margin-right:0.03588em;">y</span></span><span class="mrel">∈</span><span class="mord mathit">x</span><span class="mclose">]</span><span class="mclose">]</span></span></span></span></p>

<a name="169549434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/categorical%20product/near/169549434" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/77152categoricalproduct.html#169549434">Mario Carneiro (Jul 03 2019 at 08:40)</a>:</h4>
<p>Not in ZFC</p>

<a name="169549442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/categorical%20product/near/169549442" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/77152categoricalproduct.html#169549442">Kenny Lau (Jul 03 2019 at 08:41)</a>:</h4>
<p>why not?</p>

<a name="169549452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/categorical%20product/near/169549452" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/77152categoricalproduct.html#169549452">Mario Carneiro (Jul 03 2019 at 08:41)</a>:</h4>
<p>choice is not definable</p>

<a name="169549456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/categorical%20product/near/169549456" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/77152categoricalproduct.html#169549456">Kenny Lau (Jul 03 2019 at 08:41)</a>:</h4>
<p>is that a theorem?</p>

<a name="169549458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/categorical%20product/near/169549458" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/77152categoricalproduct.html#169549458">Mario Carneiro (Jul 03 2019 at 08:41)</a>:</h4>
<p>yes</p>

<a name="169549469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/categorical%20product/near/169549469" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/77152categoricalproduct.html#169549469">Kenny Lau (Jul 03 2019 at 08:41)</a>:</h4>
<p>how hard is it?</p>

<a name="169549470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/categorical%20product/near/169549470" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/77152categoricalproduct.html#169549470">Mario Carneiro (Jul 03 2019 at 08:41)</a>:</h4>
<p>For instance, there is no definable well order of the reals</p>

<a name="169549521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/categorical%20product/near/169549521" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/77152categoricalproduct.html#169549521">Mario Carneiro (Jul 03 2019 at 08:42)</a>:</h4>
<p>Not actually sure who to credit for it</p>

<a name="169549534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/categorical%20product/near/169549534" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/77152categoricalproduct.html#169549534">Kenny Lau (Jul 03 2019 at 08:42)</a>:</h4>
<p>so for example this implies V=L?</p>

<a name="169549585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/categorical%20product/near/169549585" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/77152categoricalproduct.html#169549585">Mario Carneiro (Jul 03 2019 at 08:44)</a>:</h4>
<p>Here's a proof: <a href="https://math.stackexchange.com/a/1315720" target="_blank" title="https://math.stackexchange.com/a/1315720">https://math.stackexchange.com/a/1315720</a></p>

<a name="169549655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/categorical%20product/near/169549655" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/77152categoricalproduct.html#169549655">Mario Carneiro (Jul 03 2019 at 08:44)</a>:</h4>
<p>It doesn't imply V=L</p>

<a name="169549752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/categorical%20product/near/169549752" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/77152categoricalproduct.html#169549752">Mario Carneiro (Jul 03 2019 at 08:46)</a>:</h4>
<p>It certainly "enlarges" L but you still can't prove that all sets are constructible without parameters</p>

<a name="169549787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/categorical%20product/near/169549787" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/77152categoricalproduct.html#169549787">Kenny Lau (Jul 03 2019 at 08:47)</a>:</h4>
<p>ok thanks</p>


{% endraw %}

{% include archive_update.html %}