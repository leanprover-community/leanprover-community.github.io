---
layout: archive
title: Lean Prover Zulip Chat Archive 
permalink: archive/116395maths/94255GCD.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/94255GCD.html">GCD</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="133169398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/GCD/near/133169398" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/94255GCD.html#133169398">Patrick Massot (Sep 01 2018 at 08:38)</a>:</h4>
<p><span class="user-mention" data-user-id="110294">@Johannes Hölzl</span> could you summarize the current state of GCD stuff? How many versions do we now have? What are the logical dependencies and future plans?</p>

<a name="133170629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/GCD/near/133170629" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/94255GCD.html#133170629">Johannes Hölzl (Sep 01 2018 at 09:26)</a>:</h4>
<p>We have <code>nat.gcd</code>, <code>int.gcd</code> and <code>gcd_domain.gcd</code> (similar for <code>lcm</code>). The future plan is to add a <code>gcd_domain</code> for polynomials</p>

<a name="133170736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/GCD/near/133170736" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/94255GCD.html#133170736">Johannes Hölzl (Sep 01 2018 at 09:31)</a>:</h4>
<p>There is some more stuff coming from Mason–Stothers. Especially UFDs, formal derivatives, etc</p>

<a name="133170788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/GCD/near/133170788" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/94255GCD.html#133170788">Patrick Massot (Sep 01 2018 at 09:33)</a>:</h4>
<p>Are those three things  completely independant?</p>

<a name="133180154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/GCD/near/133180154" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/94255GCD.html#133180154">Mario Carneiro (Sep 01 2018 at 14:43)</a>:</h4>
<p>Now that gcd_domain and normalization_domain are merged, I would like to see a proof that every integral domain has a normalization. <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> You mentioned something about prime ideals when I asked about this, can you elaborate?</p>
<p>Here's my analysis: The units of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.00773em;">R</span></span></span></span> act freely on <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo>−</mo><mo>{</mo><mn>0</mn><mo>}</mo></mrow><annotation encoding="application/x-tex">R-\{0\}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mbin">−</span><span class="mopen">{</span><span class="mord mathrm">0</span><span class="mclose">}</span></span></span></span> by left multiplication. If we quotient by the orbit relation, we obtain a monoid <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10903em;">M</span></span></span></span>. The goal is to prove the existence of a monoid homomorphism from <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10903em;">M</span></span></span></span> to the unit group of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.00773em;">R</span></span></span></span>. Is there an abstract nonsense reason this should be true?</p>

<a name="133181199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/GCD/near/133181199" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/94255GCD.html#133181199">Mario Carneiro (Sep 01 2018 at 15:18)</a>:</h4>
<p>Never mind, that proof doesn't make any sense. We want to define a subset <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>⊆</mo><mi>R</mi><mo>−</mo><mo>{</mo><mn>0</mn><mo>}</mo></mrow><annotation encoding="application/x-tex">N\subseteq R-\{0\}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mrel">⊆</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mbin">−</span><span class="mopen">{</span><span class="mord mathrm">0</span><span class="mclose">}</span></span></span></span> of normalized elements which is a submonoid of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.00773em;">R</span></span></span></span>, and such that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span></span> contains one element for every associate equivalence class.</p>

<a name="133181540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/GCD/near/133181540" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/94255GCD.html#133181540">Kevin Buzzard (Sep 01 2018 at 15:29)</a>:</h4>
<p>What I said about prime ideals was just for Z[sqrt(2)]. My understanding is that a normalization domain boils down to a choice of your set <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span></span> above. My observation was that, for integral domains, one way of thinking about such a choice is to ask for a canonical generator for each principal ideal, because in an integral domain the ideals <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(a)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">(</span><span class="mord mathit">a</span><span class="mclose">)</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(b)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">(</span><span class="mord mathit">b</span><span class="mclose">)</span></span></span></span> are equal if and only if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">a</span></span></span></span> is a unit times <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">b</span></span></span></span>.</p>

<a name="133181610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/GCD/near/133181610" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/94255GCD.html#133181610">Kevin Buzzard (Sep 01 2018 at 15:31)</a>:</h4>
<p>Now in a principal ideal domain, or more generally in a Dedekind domain, every non-zero ideal is uniquely a product of prime ideals. So I was noting that in a PID all you have to do is to make the choice for each prime ideal (i.e. each prime element) and then you can extend. In retrospect what I was saying about prime ideals can be simplified to the statement that in a UFD to make this <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span></span> choice it suffices to choose what is going on for the prime elements.</p>

<a name="133181734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/GCD/near/133181734" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/94255GCD.html#133181734">Mario Carneiro (Sep 01 2018 at 15:35)</a>:</h4>
<p>Let's try Zorn's lemma. Call a subnormalization a submonoid <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>N</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">N'</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:0.751892em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> where no two elements are associate. Obviously the union of a chain of subnormalizations is a subnormalization, so it suffices to show that if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span></span> is not a normalization, then there is a proper extension of it. If we pick any element <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>∉</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">x\notin N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">x</span><span class="mrel">∉</span><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span></span> and extend to the submonoid closure <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>N</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">N'</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:0.751892em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>, we must show that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>N</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">N'</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:0.751892em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> still has no associates. Each such element has the form <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mi>n</mi></msup><mi>y</mi></mrow><annotation encoding="application/x-tex">x^ny</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.664392em;"></span><span class="strut bottom" style="height:0.858832em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">n</span></span></span></span></span></span></span></span><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span> where <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>∈</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">y\in N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mrel">∈</span><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span></span>, so we reduce to the case <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>∼</mo><msup><mi>x</mi><mi>n</mi></msup><mi>z</mi></mrow><annotation encoding="application/x-tex">y\sim x^n z</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.664392em;"></span><span class="strut bottom" style="height:0.858832em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mrel">∼</span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">n</span></span></span></span></span></span></span></span><span class="mord mathit" style="margin-right:0.04398em;">z</span></span></span></span> where <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo>∈</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">y,z\in N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.04398em;">z</span><span class="mrel">∈</span><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span></span>.</p>

<a name="133182124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/GCD/near/133182124" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/94255GCD.html#133182124">Mario Carneiro (Sep 01 2018 at 15:49)</a>:</h4>
<p>Possible ways to refine this sketch include adding additional constraints on subnormalizations, and choosing <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">x</span></span></span></span> more carefully. In a PID, then if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mo mathvariant="normal">′</mo></msup><mo>∉</mo><msup><mi>R</mi><mo>∗</mo></msup><mi>N</mi></mrow><annotation encoding="application/x-tex">x' \notin R^*N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:0.751892em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">′</span></span></span></span></span></span></span></span></span><span class="mrel">∉</span><span class="mord"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span></span>,  it has a prime factorization and there must be some prime <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit">p</span></span></span></span> in the factorization which is not in <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span></span> (otherwise <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mo mathvariant="normal">′</mo></msup><mo>∈</mo><msup><mi>R</mi><mo>∗</mo></msup><mi>N</mi></mrow><annotation encoding="application/x-tex">x'\in R^*N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:0.790992em;vertical-align:-0.0391em;"></span><span class="base"><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">′</span></span></span></span></span></span></span></span></span><span class="mrel">∈</span><span class="mord"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span></span>), and we can take <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>N</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">N'</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:0.751892em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> to be the submonoid generated by <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo separator="true">,</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">N,p</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mord mathit">p</span></span></span></span>. Unique factorization ensures that if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>∼</mo><msup><mi>p</mi><mi>n</mi></msup><mi>z</mi></mrow><annotation encoding="application/x-tex">y\sim p^n z</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.664392em;"></span><span class="strut bottom" style="height:0.858832em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mrel">∼</span><span class="mord"><span class="mord mathit">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">n</span></span></span></span></span></span></span></span><span class="mord mathit" style="margin-right:0.04398em;">z</span></span></span></span> then <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n=0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">n</span><span class="mrel">=</span><span class="mord mathrm">0</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>=</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">y=z</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.04398em;">z</span></span></span></span>.</p>

<a name="133182174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/GCD/near/133182174" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/94255GCD.html#133182174">Kenny Lau (Sep 01 2018 at 15:50)</a>:</h4>
<p>Does normalization mean something different here? To me, the normalization of an integral domain A is the integral closure of A in its fraction field K</p>

<a name="133182178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/GCD/near/133182178" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/94255GCD.html#133182178">Mario Carneiro (Sep 01 2018 at 15:50)</a>:</h4>
<p>yes, that's a different sense</p>

<a name="133183029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/GCD/near/133183029" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/94255GCD.html#133183029">Johannes Hölzl (Sep 01 2018 at 16:18)</a>:</h4>
<blockquote>
<p>11:33 Are those three things completely independant?</p>
</blockquote>
<p>mostly: I want to use UFDs to construct a GCD domain on polynomials. formal derivatives over polynomials are independent of this.</p>

<a name="133183178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/GCD/near/133183178" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/94255GCD.html#133183178">Johannes Hölzl (Sep 01 2018 at 16:24)</a>:</h4>
<p>My next step is to introduce the quotient over associated elements and unique factorization domains: <a href="https://github.com/johoelzl/mathlib/tree/ufd" target="_blank" title="https://github.com/johoelzl/mathlib/tree/ufd">https://github.com/johoelzl/mathlib/tree/ufd</a><br>
I guess one could classically construct from this the normalisation?</p>

<a name="133183233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/GCD/near/133183233" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/94255GCD.html#133183233">Kevin Buzzard (Sep 01 2018 at 16:27)</a>:</h4>
<blockquote>
<p>Does normalization mean something different here? To me, the normalization of an integral domain A is the integral closure of A in its fraction field K</p>
</blockquote>
<p>Yes that's the standard use in maths. I've never heard of this use before -- the key examples are "normalising" a non-zero poly by making it monic and "normalising" a non-zero integer by taking its absolute value. I don't really know why these CS people want it but it would not surprise me if there were a good reason.</p>

<a name="133183278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/GCD/near/133183278" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/94255GCD.html#133183278">Kevin Buzzard (Sep 01 2018 at 16:29)</a>:</h4>
<p>Oh -- I wrote my comment before I saw Johannes'. So perhaps the issue is that the usual definition of unique factorization domain kind of stinks, you are saying something is equal up to units and re-ordering, which is sort of a mess in Lean. Mario asked me to give an example of how UFD's were used in mathematics, and I couldn't give an example which wasn't of the form "we can solve this Diophantine equation using this trick". But since then we have a couple.</p>

<a name="133183327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/GCD/near/133183327" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/94255GCD.html#133183327">Kevin Buzzard (Sep 01 2018 at 16:30)</a>:</h4>
<p>One is that Johannes pointed out that Mason-Stothers uses it, and the other one is Brian Conrad's observation which he made to me in email, saying that in the theory of smooth schemes one uses a lot that (a) regular local rings are UFD's and (b) in a UFD, all height one primes are principal. So Kenny if you fancy learning some abstract ring theory you can learn the proofs of these two things and then you might have some opinions about how the notion of a UFD should be formalised in Lean.</p>

<a name="133183382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/GCD/near/133183382" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/94255GCD.html#133183382">Mario Carneiro (Sep 01 2018 at 16:32)</a>:</h4>
<p>I didn't write the definition of normalization domain, but it's pretty natural once you decide you want a <em>function</em> <code>gcd : R -&gt; R -&gt; R</code>, and given the definition I want to know if it relates in any obvious way to standard ring theoretic definitions</p>

<a name="133183446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/GCD/near/133183446" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/94255GCD.html#133183446">Mario Carneiro (Sep 01 2018 at 16:35)</a>:</h4>
<p>I guess another option is to quotient by associates; then you could have a function into that quotient which doesn't have this non-functorial normalization structure overlaid</p>

<a name="133183502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/GCD/near/133183502" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/94255GCD.html#133183502">Kenny Lau (Sep 01 2018 at 16:37)</a>:</h4>
<p>why <code>norm_unit u = u⁻¹</code>?</p>

<a name="133183542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/GCD/near/133183542" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/94255GCD.html#133183542">Mario Carneiro (Sep 01 2018 at 16:38)</a>:</h4>
<p>That just means that every unit is normalized to <code>1</code></p>

<a name="133183549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/GCD/near/133183549" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/94255GCD.html#133183549">Mario Carneiro (Sep 01 2018 at 16:39)</a>:</h4>
<p>The actual normalization function is <code>normalize x = x * norm_unit x</code></p>

<a name="133183550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/GCD/near/133183550" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/94255GCD.html#133183550">Kenny Lau (Sep 01 2018 at 16:39)</a>:</h4>
<p>oh ok</p>

<a name="133183552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/GCD/near/133183552" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/94255GCD.html#133183552">Kenny Lau (Sep 01 2018 at 16:39)</a>:</h4>
<p>then why don't we...</p>

<a name="133183597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/GCD/near/133183597" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/94255GCD.html#133183597">Mario Carneiro (Sep 01 2018 at 16:40)</a>:</h4>
<p>why don't we what?</p>

<a name="133183690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/GCD/near/133183690" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/94255GCD.html#133183690">Kenny Lau (Sep 01 2018 at 16:44)</a>:</h4>
<p>why don't we define the normalization to send the element to its normalization?</p>

<a name="133183810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/GCD/near/133183810" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/94255GCD.html#133183810">Mario Carneiro (Sep 01 2018 at 16:49)</a>:</h4>
<p>because you want the evidence that the map is a unit</p>

<a name="133185014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/GCD/near/133185014" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/94255GCD.html#133185014">Mario Carneiro (Sep 01 2018 at 17:34)</a>:</h4>
<p>Maybe the folks at MSE will know whether it is true: <a href="https://math.stackexchange.com/q/2901858/50776" target="_blank" title="https://math.stackexchange.com/q/2901858/50776">https://math.stackexchange.com/q/2901858/50776</a></p>

<a name="133185037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/GCD/near/133185037" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/94255GCD.html#133185037">Kevin Buzzard (Sep 01 2018 at 17:35)</a>:</h4>
<p>Oh, I hadn't realised there was a maths question.</p>

<a name="133185079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/GCD/near/133185079" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/94255GCD.html#133185079">Kevin Buzzard (Sep 01 2018 at 17:36)</a>:</h4>
<p>Heh, when I read the thing about integral domains and normalizations I incorrectly thought (as did Kenny) that you were talking about the integral closure :-)</p>

<a name="133185086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/GCD/near/133185086" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/94255GCD.html#133185086">Mario Carneiro (Sep 01 2018 at 17:37)</a>:</h4>
<p>I'm open to alternate terminology</p>

<a name="133185129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/GCD/near/133185129" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/94255GCD.html#133185129">Mario Carneiro (Sep 01 2018 at 17:38)</a>:</h4>
<p>is this the normalization you are talking about? <a href="https://en.wikipedia.org/wiki/Normal_scheme" target="_blank" title="https://en.wikipedia.org/wiki/Normal_scheme">https://en.wikipedia.org/wiki/Normal_scheme</a></p>

<a name="133185130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/GCD/near/133185130" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/94255GCD.html#133185130">Kevin Buzzard (Sep 01 2018 at 17:39)</a>:</h4>
<p>Yes.</p>

<a name="133185137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/GCD/near/133185137" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/94255GCD.html#133185137">Mario Carneiro (Sep 01 2018 at 17:39)</a>:</h4>
<p>Would "orientation" be more or less confusing than "normalization"?</p>

<a name="133185183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/GCD/near/133185183" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/94255GCD.html#133185183">Kevin Buzzard (Sep 01 2018 at 17:40)</a>:</h4>
<p>heh, that means something else in maths too of course, but not in algebra (as far as I know), so the two clashing uses of "normalisation of an integral domain" would be replaced by something which would confuse a geometer (who wants to orient certain kinds of manifolds) but which would be safer in general I guess.</p>

<a name="133185574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/GCD/near/133185574" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/94255GCD.html#133185574">Mario Carneiro (Sep 01 2018 at 17:56)</a>:</h4>
<p>actually I rather like the "orientation" terminology, since it makes the question of whether there are non-orientable integral domains sound more interesting</p>

<a name="133185583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/GCD/near/133185583" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/94255GCD.html#133185583">Mario Carneiro (Sep 01 2018 at 17:57)</a>:</h4>
<p>(plus there is an obvious analogy to orientable manifolds, at least in the case where the unit group has two elements)</p>

<a name="133187541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/GCD/near/133187541" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/94255GCD.html#133187541">Kevin Buzzard (Sep 01 2018 at 19:06)</a>:</h4>
<p>OK so there are problems if the ID is not normal (;-)) i.e. integrally closed. If <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo>=</mo><mrow><mi mathvariant="double-struck">Z</mi></mrow><mo>[</mo><msup><mrow><mo>(</mo><mo>−</mo><mn>4</mn><mo>)</mo></mrow><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup><mo>]</mo><mo>=</mo><mrow><mi mathvariant="double-struck">Z</mi></mrow><mo>[</mo><mn>2</mn><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">R=\mathbb{Z}[{(-4)}^{1/2}]=\mathbb{Z}[2i]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:1.0279em;"></span><span class="strut bottom" style="height:1.2779em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mrel">=</span><span class="mord"><span class="mord mathbb">Z</span></span><span class="mopen">[</span><span class="mord"><span class="mord"><span class="mopen">(</span><span class="mord">−</span><span class="mord mathrm">4</span><span class="mclose">)</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0279em;"><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">1</span><span class="mord mathrm mtight">/</span><span class="mord mathrm mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">]</span><span class="mrel">=</span><span class="mord"><span class="mord mathbb">Z</span></span><span class="mopen">[</span><span class="mord mathrm">2</span><span class="mord mathit">i</span><span class="mclose">]</span></span></span></span> then <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>i</mi></mrow><annotation encoding="application/x-tex">2i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.65952em;"></span><span class="strut bottom" style="height:0.65952em;vertical-align:0em;"></span><span class="base"><span class="mord mathrm">2</span><span class="mord mathit">i</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base"><span class="mord mathrm">2</span></span></span></span> are not associates, but their squares are, and I think this kills it.</p>


{% endraw %}
