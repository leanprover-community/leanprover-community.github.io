---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/116395maths/83755flexibleindices.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html">flexible indices</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="158961615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/158961615" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#158961615">Johan Commelin (Feb 20 2019 at 09:45)</a>:</h4>
<p>I'm fooling around with sequences of groups. Here is an extract of some code:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">group</span> <span class="n">group_theory</span><span class="bp">.</span><span class="n">subgroup</span>
<span class="kn">import</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">instances</span><span class="bp">.</span><span class="n">groups</span>
<span class="kn">import</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">functor_category</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">function</span>

<span class="n">universes</span> <span class="n">v</span> <span class="n">v‚ÇÅ</span> <span class="n">v‚ÇÇ</span> <span class="n">v‚ÇÉ</span> <span class="n">u</span> <span class="n">u‚ÇÅ</span> <span class="n">u‚ÇÇ</span> <span class="n">u‚ÇÉ</span> <span class="c1">-- declare the `v`&#39;s first; see `category_theory.category` for an explanation</span>

<span class="kn">namespace</span> <span class="n">category_theory</span>
<span class="kn">open</span> <span class="n">set</span> <span class="n">instances</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u‚ÇÅ</span><span class="o">)</span> <span class="o">[</span><span class="err">ùíû</span> <span class="o">:</span> <span class="n">category</span><span class="bp">.</span><span class="o">{</span><span class="n">v‚ÇÅ</span><span class="o">}</span> <span class="n">C</span><span class="o">]</span>
<span class="n">include</span> <span class="err">ùíû</span>

<span class="n">def</span> <span class="n">sequence</span> <span class="o">:=</span> <span class="bp">‚Ñ§</span> <span class="err">‚•§</span> <span class="n">C</span>

<span class="kn">namespace</span> <span class="n">sequence</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">category</span> <span class="o">(</span><span class="n">sequence</span> <span class="n">C</span><span class="o">)</span> <span class="o">:=</span> <span class="n">functor</span><span class="bp">.</span><span class="n">category</span> <span class="bp">_</span> <span class="bp">_</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">C</span><span class="o">}</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">sequence</span> <span class="n">C</span><span class="o">)</span>

<span class="n">def</span> <span class="n">delta</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="bp">‚Ñ§</span><span class="o">)</span> <span class="o">{</span><span class="n">j</span> <span class="o">:</span> <span class="bp">‚Ñ§</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">j</span> <span class="bp">-</span> <span class="mi">1</span> <span class="bp">.</span> <span class="n">obviously</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">X</span><span class="bp">.</span><span class="n">obj</span> <span class="n">i</span> <span class="err">‚ü∂</span> <span class="n">X</span><span class="bp">.</span><span class="n">obj</span> <span class="n">j</span> <span class="o">:=</span>
<span class="n">X</span><span class="bp">.</span><span class="n">map</span> <span class="err">$</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="n">auto_param_eq</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">h</span><span class="o">,</span> <span class="n">tidy</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>

<a name="158961623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/158961623" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#158961623">Johan Commelin (Feb 20 2019 at 09:45)</a>:</h4>
<p>What I am after is a nice definition of <code>delta</code></p>

<a name="158961714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/158961714" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#158961714">Johan Commelin (Feb 20 2019 at 09:47)</a>:</h4>
<p>It is the map <code>X.obj i \hom X.obj (i+1)</code> but I want to use unification to replace <code>i</code> with <code>(i-1+1)</code> when necessary.</p>

<a name="158961922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/158961922" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#158961922">Johan Commelin (Feb 20 2019 at 09:51)</a>:</h4>
<p>Currently this fails:</p>
<div class="codehilite"><pre><span></span><span class="kn">variable</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="bp">‚Ñ§</span><span class="o">)</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">X</span><span class="bp">.</span><span class="n">delta</span> <span class="o">(</span><span class="n">i</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="err">‚â´</span> <span class="n">X</span><span class="bp">.</span><span class="n">delta</span> <span class="n">i</span>
</pre></div>

<a name="158961939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/158961939" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#158961939">Johan Commelin (Feb 20 2019 at 09:51)</a>:</h4>
<p>Because the second <code>X.delta</code> should be <code>X.delta (i-1+1)</code>, which is ugly.</p>

<a name="158962397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/158962397" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#158962397">Johan Commelin (Feb 20 2019 at 09:59)</a>:</h4>
<p>My goal is to make things like this typecheck:</p>
<div class="codehilite"><pre><span></span><span class="kn">variable</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">sequence</span> <span class="n">Group</span><span class="o">)</span>

<span class="n">def</span> <span class="n">is_complex</span> <span class="o">:=</span>
<span class="bp">‚àÄ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="bp">‚Ñ§</span><span class="o">),</span> <span class="n">range</span> <span class="o">(</span><span class="n">A</span><span class="bp">.</span><span class="n">delta</span> <span class="o">(</span><span class="n">i</span><span class="bp">-</span><span class="mi">1</span><span class="o">))</span> <span class="err">‚äÜ</span> <span class="n">ker</span> <span class="o">(</span><span class="n">A</span><span class="bp">.</span><span class="n">delta</span> <span class="n">i</span><span class="o">)</span>
</pre></div>

<a name="158962468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/158962468" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#158962468">Kenny Lau (Feb 20 2019 at 10:00)</a>:</h4>
<p>(never mind)</p>

<a name="158962609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/158962609" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#158962609">Kenny Lau (Feb 20 2019 at 10:03)</a>:</h4>
<p>also your code doesn't work because <code>category_theory.instances.groups</code> doesn't exist</p>

<a name="158964464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/158964464" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#158964464">Johan Commelin (Feb 20 2019 at 10:38)</a>:</h4>
<p>Yes, I know. It exists on my machine. It's a pity it doesn't yet exist in mathlib.</p>

<a name="158965848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/158965848" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#158965848">Johan Commelin (Feb 20 2019 at 11:04)</a>:</h4>
<p>Here is <code>category_theory/instances/groups.lean</code>:</p>
<div class="codehilite"><pre><span></span><span class="c">/-</span><span class="cm"> Copyright (c) 2018 Johan Commelin. All rights reserved.</span>
<span class="cm">Released under Apache 2.0 license as described in the file LICENSE.</span>
<span class="cm">Authors: Johan Commelin</span>

<span class="cm">Introduce Group -- the category of groups.</span>

<span class="cm">Currently only the basic setup.</span>
<span class="cm">Copied from monoids.lean.</span>
<span class="cm">-/</span>

<span class="kn">import</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">concrete_category</span>
<span class="kn">import</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">fully_faithful</span>
<span class="kn">import</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">adjunction</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">finsupp</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="kn">open</span> <span class="n">category_theory</span>

<span class="kn">namespace</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">instances</span>

<span class="c">/-</span><span class="cm">- The category of groups and group morphisms. -/</span>
<span class="bp">@</span><span class="o">[</span><span class="kn">reducible</span><span class="o">]</span> <span class="n">def</span> <span class="n">Group</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">bundled</span> <span class="n">group</span>

<span class="kn">instance</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">Group</span><span class="o">)</span> <span class="o">:</span> <span class="n">group</span> <span class="n">G</span> <span class="o">:=</span> <span class="n">G</span><span class="bp">.</span><span class="n">str</span>

<span class="kn">instance</span> <span class="n">concrete_is_group_hom</span> <span class="o">:</span>
  <span class="n">concrete_category</span> <span class="bp">@</span><span class="n">is_group_hom</span> <span class="o">:=</span>
<span class="bp">‚ü®</span><span class="k">by</span> <span class="n">introsI</span> <span class="n">Œ±</span> <span class="n">ia</span><span class="bp">;</span> <span class="n">apply_instance</span><span class="o">,</span>
  <span class="k">by</span> <span class="n">introsI</span> <span class="n">Œ±</span> <span class="n">Œ≤</span> <span class="n">Œ≥</span> <span class="n">ia</span> <span class="n">ib</span> <span class="n">ic</span> <span class="n">f</span> <span class="n">g</span> <span class="n">hf</span> <span class="n">hg</span><span class="bp">;</span> <span class="n">apply_instance</span><span class="bp">‚ü©</span>

<span class="kn">instance</span> <span class="n">Group_hom_is_group_hom</span> <span class="o">{</span><span class="n">G‚ÇÅ</span> <span class="n">G‚ÇÇ</span> <span class="o">:</span> <span class="n">Group</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">G‚ÇÅ</span> <span class="err">‚ü∂</span> <span class="n">G‚ÇÇ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">is_group_hom</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">G‚ÇÅ</span> <span class="bp">‚Üí</span> <span class="n">G‚ÇÇ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">f</span><span class="bp">.</span><span class="mi">2</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_one</span> <span class="n">Group</span> <span class="o">:=</span> <span class="bp">‚ü®</span><span class="o">{</span> <span class="n">Œ±</span> <span class="o">:=</span> <span class="n">punit</span><span class="o">,</span> <span class="n">str</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">tidy</span> <span class="o">}</span><span class="bp">‚ü©</span>

<span class="c">/-</span><span class="cm">- The category of commutative groups and group morphisms. -/</span>
<span class="bp">@</span><span class="o">[</span><span class="kn">reducible</span><span class="o">]</span> <span class="n">def</span> <span class="n">CommGroup</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">bundled</span> <span class="n">comm_group</span>

<span class="kn">instance</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">CommGroup</span><span class="o">)</span> <span class="o">:</span> <span class="n">comm_group</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">x</span><span class="bp">.</span><span class="n">str</span>

<span class="bp">@</span><span class="o">[</span><span class="kn">reducible</span><span class="o">]</span> <span class="n">def</span> <span class="n">is_comm_group_hom</span> <span class="o">{</span><span class="n">Œ±</span> <span class="n">Œ≤</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_group</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_group</span> <span class="n">Œ≤</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">Œ±</span> <span class="bp">‚Üí</span> <span class="n">Œ≤</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">is_group_hom</span> <span class="n">f</span>

<span class="kn">instance</span> <span class="n">concrete_is_comm_group_hom</span> <span class="o">:</span> <span class="n">concrete_category</span> <span class="bp">@</span><span class="n">is_comm_group_hom</span> <span class="o">:=</span>
<span class="bp">‚ü®</span><span class="k">by</span> <span class="n">introsI</span> <span class="n">Œ±</span> <span class="n">ia</span><span class="bp">;</span> <span class="n">apply_instance</span><span class="o">,</span>
  <span class="k">by</span> <span class="n">introsI</span> <span class="n">Œ±</span> <span class="n">Œ≤</span> <span class="n">Œ≥</span> <span class="n">ia</span> <span class="n">ib</span> <span class="n">ic</span> <span class="n">f</span> <span class="n">g</span> <span class="n">hf</span> <span class="n">hg</span><span class="bp">;</span> <span class="n">apply_instance</span><span class="bp">‚ü©</span>

<span class="kn">instance</span> <span class="n">CommGroup_hom_is_comm_group_hom</span> <span class="o">{</span><span class="n">R</span> <span class="n">S</span> <span class="o">:</span> <span class="n">CommGroup</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">R</span> <span class="err">‚ü∂</span> <span class="n">S</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">is_comm_group_hom</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">‚Üí</span> <span class="n">S</span><span class="o">)</span> <span class="o">:=</span> <span class="n">f</span><span class="bp">.</span><span class="mi">2</span>

<span class="kn">namespace</span> <span class="n">CommGroup</span>
<span class="c">/-</span><span class="cm">- The forgetful functor from commutative groups to groups. -/</span>
<span class="n">def</span> <span class="n">forget_to_Group</span> <span class="o">:</span> <span class="n">CommGroup</span> <span class="err">‚•§</span> <span class="n">Group</span> <span class="o">:=</span>
<span class="n">concrete_functor</span>
  <span class="o">(</span><span class="k">by</span> <span class="n">intros</span> <span class="bp">_</span> <span class="n">c</span><span class="bp">;</span> <span class="n">exact</span> <span class="o">{</span> <span class="bp">..</span><span class="n">c</span> <span class="o">})</span>
  <span class="o">(</span><span class="k">by</span> <span class="n">introsI</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">f</span> <span class="n">i</span><span class="bp">;</span>  <span class="n">exact</span> <span class="o">{</span> <span class="bp">..</span><span class="n">i</span> <span class="o">})</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">faithful</span> <span class="o">(</span><span class="n">forget_to_Group</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{}</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_one</span> <span class="n">CommGroup</span> <span class="o">:=</span> <span class="bp">‚ü®</span><span class="o">{</span> <span class="n">Œ±</span> <span class="o">:=</span> <span class="n">punit</span><span class="o">,</span> <span class="n">str</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">tidy</span> <span class="o">}</span><span class="bp">‚ü©</span>

<span class="kn">end</span> <span class="n">CommGroup</span>

<span class="kn">end</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">instances</span>
</pre></div>

<a name="158969754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/158969754" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#158969754">Kevin Buzzard (Feb 20 2019 at 12:23)</a>:</h4>
<p>What's the story as to why it's not in mathlib? My MSc student was going to use categories for doing schemes but we decided it wasn't a good idea because categories seemed to be happening too slowly</p>

<a name="158981420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/158981420" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#158981420">Johan Commelin (Feb 20 2019 at 14:51)</a>:</h4>
<p>The story is that nobody copied the file about the category of monoids and did a search-replace <code>s/monoid/group/</code>. That's all.</p>

<a name="159419211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159419211" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159419211">Johan Commelin (Feb 26 2019 at 12:13)</a>:</h4>
<blockquote>
<p>My goal is to make things like this typecheck:</p>
<div class="codehilite"><pre><span></span><span class="kn">variable</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">sequence</span> <span class="n">Group</span><span class="o">)</span>

<span class="n">def</span> <span class="n">is_complex</span> <span class="o">:=</span>
<span class="bp">‚àÄ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="bp">‚Ñ§</span><span class="o">),</span> <span class="n">range</span> <span class="o">(</span><span class="n">A</span><span class="bp">.</span><span class="n">delta</span> <span class="o">(</span><span class="n">i</span><span class="bp">-</span><span class="mi">1</span><span class="o">))</span> <span class="err">‚äÜ</span> <span class="n">ker</span> <span class="o">(</span><span class="n">A</span><span class="bp">.</span><span class="n">delta</span> <span class="n">i</span><span class="o">)</span>
</pre></div>


</blockquote>
<p>Does anyone have an idea how to make this work?<br>
I think writing <code>A.delta (i-1+1)</code> is very very ugly.</p>

<a name="159419271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159419271" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159419271">Mario Carneiro (Feb 26 2019 at 12:14)</a>:</h4>
<p>Why not use +1 instead of -1?</p>

<a name="159419274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159419274" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159419274">Mario Carneiro (Feb 26 2019 at 12:14)</a>:</h4>
<p>it's over all integers</p>

<a name="159419303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159419303" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159419303">Mario Carneiro (Feb 26 2019 at 12:15)</a>:</h4>
<p>Another way to flexify the indices for dependent types is to have an equality argument <code>i+1 = j</code> and have <code>i</code> on the left and <code>j</code> on the right</p>

<a name="159419310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159419310" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159419310">Johan Commelin (Feb 26 2019 at 12:15)</a>:</h4>
<p>But can we make it transparent?</p>

<a name="159419322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159419322" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159419322">Mario Carneiro (Feb 26 2019 at 12:15)</a>:</h4>
<p>don't know what you intend to do with this</p>

<a name="159419372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159419372" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159419372">Johan Commelin (Feb 26 2019 at 12:16)</a>:</h4>
<blockquote>
<p>Why not use +1 instead of -1?</p>
</blockquote>
<p>I could do that here. But I think this issue will show up elsewhere as soon as we start looking in a broader range of indices.</p>

<a name="159419382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159419382" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159419382">Johan Commelin (Feb 26 2019 at 12:16)</a>:</h4>
<blockquote>
<p>don't know what you intend to do with this<br>
For starters we could try to prove the snake lemma (-;</p>
</blockquote>

<a name="159419406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159419406" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159419406">Mario Carneiro (Feb 26 2019 at 12:17)</a>:</h4>
<p>More generally, you want an inductive family describing the allowable index combinations</p>

<a name="159419419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159419419" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159419419">Mario Carneiro (Feb 26 2019 at 12:17)</a>:</h4>
<p>In this case it is just <code>inductive next : nat -&gt; nat -&gt; Prop | mk (i) : next i (i+1)</code></p>

<a name="159419477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159419477" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159419477">Johan Commelin (Feb 26 2019 at 12:18)</a>:</h4>
<p>Hmm, how do I use <code>next</code>?</p>

<a name="159419493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159419493" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159419493">Johan Commelin (Feb 26 2019 at 12:18)</a>:</h4>
<p>Should I put that in my definition of <code>delta</code>?</p>

<a name="159419498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159419498" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159419498">Mario Carneiro (Feb 26 2019 at 12:18)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">is_complex</span> <span class="o">:=</span>
<span class="bp">‚àÄ</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="bp">‚Ñ§</span><span class="o">),</span> <span class="n">next</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">-&gt;</span> <span class="n">range</span> <span class="o">(</span><span class="n">A</span><span class="bp">.</span><span class="n">delta</span> <span class="n">i</span><span class="o">)</span> <span class="err">‚äÜ</span> <span class="n">ker</span> <span class="o">(</span><span class="n">A</span><span class="bp">.</span><span class="n">delta</span> <span class="n">j</span><span class="o">)</span>
</pre></div>

<a name="159419514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159419514" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159419514">Mario Carneiro (Feb 26 2019 at 12:19)</a>:</h4>
<p>or are you looking somewhere else?</p>

<a name="159419714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159419714" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159419714">Johan Commelin (Feb 26 2019 at 12:22)</a>:</h4>
<p>Aah, ok</p>

<a name="159419729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159419729" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159419729">Johan Commelin (Feb 26 2019 at 12:23)</a>:</h4>
<p>But that means I have 3 explicit arguments. So I can't just write <code>A.delta i</code></p>

<a name="159419801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159419801" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159419801">Johan Commelin (Feb 26 2019 at 12:24)</a>:</h4>
<p>I would like to tell Lean: "If unification knows what <code>j</code> should be, use that. Otherwise, default to <code>(i+1)</code>."</p>

<a name="159419810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159419810" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159419810">Mario Carneiro (Feb 26 2019 at 12:24)</a>:</h4>
<p>Yeah, I think so... it's just like with categories, you want the objects to be there before the morphisms, rather than extracting objects as the dom/cod of morphisms</p>

<a name="159419828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159419828" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159419828">Johan Commelin (Feb 26 2019 at 12:25)</a>:</h4>
<p>And after that I say to Lean: "Hey, 95% of the time you can prove <code>next i j</code> by <code>mk i</code>. Otherwise, simplify the expression for <code>j</code> before doing that."</p>

<a name="159419841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159419841" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159419841">Johan Commelin (Feb 26 2019 at 12:25)</a>:</h4>
<p>And so in 99% of the cases I can get away with just writing <code>A.delta i</code>. And in 1% of the cases I might to actually work on the proof obligation...</p>

<a name="159419885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159419885" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159419885">Johan Commelin (Feb 26 2019 at 12:26)</a>:</h4>
<p>If something like that can work, that would be cool.</p>

<a name="159419903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159419903" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159419903">Mario Carneiro (Feb 26 2019 at 12:26)</a>:</h4>
<p>So <code>is_complex</code> is actually talking about three objects....</p>

<a name="159419940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159419940" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159419940">Mario Carneiro (Feb 26 2019 at 12:27)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">is_complex</span> <span class="o">:=</span>
<span class="bp">‚àÄ</span> <span class="o">{{</span><span class="n">i</span> <span class="n">j</span> <span class="n">k</span> <span class="o">:</span> <span class="bp">‚Ñ§</span><span class="o">}}</span> <span class="o">(</span><span class="n">n1</span><span class="o">:</span> <span class="n">next</span> <span class="n">i</span> <span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">n2</span> <span class="o">:</span> <span class="n">next</span> <span class="n">j</span> <span class="n">k</span><span class="o">),</span> <span class="n">range</span> <span class="o">(</span><span class="n">A</span><span class="bp">.</span><span class="n">delta</span> <span class="n">n1</span><span class="o">)</span> <span class="err">‚äÜ</span> <span class="n">ker</span> <span class="o">(</span><span class="n">A</span><span class="bp">.</span><span class="n">delta</span> <span class="n">n2</span><span class="o">)</span>
</pre></div>

<a name="159419955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159419955" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159419955">Kenny Lau (Feb 26 2019 at 12:27)</a>:</h4>
<p>what is {{}}?</p>

<a name="159419998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159419998" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159419998">Mario Carneiro (Feb 26 2019 at 12:28)</a>:</h4>
<p>half implicit, too lazy to unicode</p>

<a name="159420001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159420001" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159420001">Mario Carneiro (Feb 26 2019 at 12:28)</a>:</h4>
<p>I think it is working ascii notation though</p>

<a name="159420002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159420002" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159420002">Kenny Lau (Feb 26 2019 at 12:28)</a>:</h4>
<p>what is half implicit?</p>

<a name="159420015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159420015" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159420015">Mario Carneiro (Feb 26 2019 at 12:28)</a>:</h4>
<p>not applied unless you apply an argument after them</p>

<a name="159420024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159420024" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159420024">Mario Carneiro (Feb 26 2019 at 12:29)</a>:</h4>
<p>like in the definition of subset</p>

<a name="159420029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159420029" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159420029">Kenny Lau (Feb 26 2019 at 12:29)</a>:</h4>
<p>:o</p>

<a name="159420237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159420237" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159420237">Johan Commelin (Feb 26 2019 at 12:32)</a>:</h4>
<p>Hmm, but I think you are working on the wrong part. The definition of <code>delta</code> has to change.</p>

<a name="159420250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159420250" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159420250">Johan Commelin (Feb 26 2019 at 12:33)</a>:</h4>
<p><code>is_complex</code> is just an example of something that doesn't typecheck with the current definition of <code>delta</code>.</p>

<a name="159420257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159420257" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159420257">Mario Carneiro (Feb 26 2019 at 12:33)</a>:</h4>
<p>I did that... <code>A.delta {i j} n1</code></p>

<a name="159420270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159420270" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159420270">Johan Commelin (Feb 26 2019 at 12:33)</a>:</h4>
<p>Ooh, right. Ok.</p>

<a name="159420279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159420279" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159420279">Johan Commelin (Feb 26 2019 at 12:33)</a>:</h4>
<p>But that means I can't write <code>A.delta i</code>, can I?</p>

<a name="159420284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159420284" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159420284">Mario Carneiro (Feb 26 2019 at 12:33)</a>:</h4>
<p>although possibly <code>i</code> and <code>j</code> shouldn't be implicit - this will print a bit weird if <code>n1</code> is not a simple term</p>

<a name="159420331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159420331" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159420331">Mario Carneiro (Feb 26 2019 at 12:34)</a>:</h4>
<p>No, I'm claiming that's a bad idea</p>

<a name="159420377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159420377" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159420377">Mario Carneiro (Feb 26 2019 at 12:35)</a>:</h4>
<p>If you don't have the objects lying around already, you can use +1 and -1 to access next elements, but if you ever want to link two of them together you need a variable for the common object</p>

<a name="159420393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159420393" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159420393">Mario Carneiro (Feb 26 2019 at 12:35)</a>:</h4>
<p><code>is_complex</code> is a good example of this - <code>j</code> is mediating the connection between <code>i</code> and <code>k</code></p>

<a name="159420406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159420406" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159420406">Mario Carneiro (Feb 26 2019 at 12:35)</a>:</h4>
<p>I know this looks silly but it's a DTT thing</p>

<a name="159420514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159420514" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159420514">Johan Commelin (Feb 26 2019 at 12:37)</a>:</h4>
<p>This will be hard to explain to mathematicians...</p>

<a name="159420518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159420518" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159420518">Johan Commelin (Feb 26 2019 at 12:37)</a>:</h4>
<p>Why can't automation help us here?</p>

<a name="159420577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159420577" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159420577">Mario Carneiro (Feb 26 2019 at 12:38)</a>:</h4>
<p>because DTT doesn't like it when you try to prove defeqs</p>

<a name="159420593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159420593" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159420593">Johan Commelin (Feb 26 2019 at 12:38)</a>:</h4>
<p>If Lean figures out <code>j</code> by unification, that's cool. If it didn't: use <code>i+1</code>.</p>

<a name="159420605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159420605" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159420605">Mario Carneiro (Feb 26 2019 at 12:38)</a>:</h4>
<p>You want all rewriting and stuff to happen in prop land</p>

<a name="159420616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159420616" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159420616">Mario Carneiro (Feb 26 2019 at 12:38)</a>:</h4>
<p>but <code>delta</code> is data, so it needs a general type</p>

<a name="159420639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159420639" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159420639">Mario Carneiro (Feb 26 2019 at 12:39)</a>:</h4>
<p>it's not a question of figuring out the expressions, it's about making <code>i+1-1</code> defeq to <code>i</code></p>

<a name="159420910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159420910" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159420910">Johan Commelin (Feb 26 2019 at 12:44)</a>:</h4>
<p>Hmmm, I think that I wouldn't mind if automation could also help us with providing data, and not only proofs.</p>

<a name="159420997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159420997" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159420997">Patrick Massot (Feb 26 2019 at 12:46)</a>:</h4>
<p>I don't know if automation is the right word here, but it's pretty clear that proof assistants that require using this <code>next</code> trick are not ready for use by mathematicians</p>

<a name="159421008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159421008" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159421008">Mario Carneiro (Feb 26 2019 at 12:46)</a>:</h4>
<p>It's about wrangling DTT issues</p>

<a name="159421021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159421021" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159421021">Mario Carneiro (Feb 26 2019 at 12:47)</a>:</h4>
<p>You are causing equality of integers to propagate to equality of types, which is bad</p>

<a name="159421023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159421023" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159421023">Patrick Massot (Feb 26 2019 at 12:47)</a>:</h4>
<p>I understand. It means we need either better wrangling tools or a better foundational framework. I'm not saying this is an easy question</p>

<a name="159421032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159421032" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159421032">Mario Carneiro (Feb 26 2019 at 12:47)</a>:</h4>
<p>I am in favor of both of those</p>

<a name="159421079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159421079" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159421079">Patrick Massot (Feb 26 2019 at 12:48)</a>:</h4>
<p>What a nice thesis topic!</p>

<a name="159421127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159421127" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159421127">Johan Commelin (Feb 26 2019 at 12:49)</a>:</h4>
<p>Mario, I agree with Patrick. I understand the issues. But the issues are non-mathematical, so they should be hidden. Somehow...</p>

<a name="159421196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159421196" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159421196">Johan Commelin (Feb 26 2019 at 12:50)</a>:</h4>
<p>In the end, DTT should be our assembly language. We want a Python on top of that.</p>

<a name="159421204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159421204" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159421204">Patrick Massot (Feb 26 2019 at 12:50)</a>:</h4>
<p>You already have it: the tactic language</p>

<a name="159421207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159421207" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159421207">Mario Carneiro (Feb 26 2019 at 12:50)</a>:</h4>
<p>DTT is a horrible assembly language</p>

<a name="159421226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159421226" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159421226">Mario Carneiro (Feb 26 2019 at 12:51)</a>:</h4>
<p>it's like javascript - high level ish but used for low level things</p>

<a name="159421252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159421252" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159421252">Mario Carneiro (Feb 26 2019 at 12:51)</a>:</h4>
<p>I know a much better proof assembly language, and it starts with M</p>

<a name="159421299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159421299" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159421299">Johan Commelin (Feb 26 2019 at 12:52)</a>:</h4>
<p>Sure, but is there a Python on top of your M?</p>

<a name="159421315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159421315" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159421315">Johan Commelin (Feb 26 2019 at 12:52)</a>:</h4>
<p>One that will let me define functors on objects and morphisms, and check that they are lawful in a completely transparent way?</p>

<a name="159421629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159421629" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159421629">Mario Carneiro (Feb 26 2019 at 12:58)</a>:</h4>
<p>Proof automation is hard, and no one has a perfect solution. Lean could have the stuff you are talking about if it didn't have to fight its own foundation</p>

<a name="159421718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159421718" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159421718">Johan Commelin (Feb 26 2019 at 13:00)</a>:</h4>
<p>What do you mean with that last sentence?</p>

<a name="159421860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159421860" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159421860">Mario Carneiro (Feb 26 2019 at 13:02)</a>:</h4>
<p>You could just rewrite <code>i+1-1 = i</code> with the simplifier and we would all be happy</p>

<a name="159423093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159423093" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159423093">Johan Commelin (Feb 26 2019 at 13:22)</a>:</h4>
<p>Sure, that's exactly what I would want. But what do you mean with:</p>
<blockquote>
<p>Lean could have the stuff you are talking about if it didn't have to fight its own foundation<br>
Is that an issue that can be solved, or is this fight some intrinsic DTT issue?</p>
</blockquote>

<a name="159426569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159426569" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159426569">Mario Carneiro (Feb 26 2019 at 14:14)</a>:</h4>
<p>it's an intrinsic DTT issue</p>

<a name="159426583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159426583" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159426583">Mario Carneiro (Feb 26 2019 at 14:14)</a>:</h4>
<p>defeq matters, and tactics can't change that</p>

<a name="159426590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159426590" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159426590">Johan Commelin (Feb 26 2019 at 14:14)</a>:</h4>
<p>Aah, so Lean will always be fighting its foundations.</p>

<a name="159426749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159426749" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159426749">Johan Commelin (Feb 26 2019 at 14:17)</a>:</h4>
<p>So, why don't we write a Python-like on top of your assembly M? Do you think we would get further into state-of-the-art research level maths with a Python-like on top of M? Or is Lean just the best there is, and are we stuck with a system that fights its own foundations?</p>

<a name="159426793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159426793" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159426793">Mario Carneiro (Feb 26 2019 at 14:17)</a>:</h4>
<p>You are hitting surprisingly close to my current research areas</p>

<a name="159426868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159426868" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159426868">Johan Commelin (Feb 26 2019 at 14:18)</a>:</h4>
<p>That only means that I've been paying attention to what you've been saying on Zulip over the last couple of months (-;</p>

<a name="159426922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159426922" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159426922">Mario Carneiro (Feb 26 2019 at 14:19)</a>:</h4>
<p>I think that the killer combo is untyped foundations (ZFC like) + good tactic language + metaprogramming</p>

<a name="159426998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159426998" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159426998">Mario Carneiro (Feb 26 2019 at 14:20)</a>:</h4>
<p>as you can see lean has 2 out of 3</p>

<a name="159427047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159427047" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159427047">Mario Carneiro (Feb 26 2019 at 14:21)</a>:</h4>
<p>Isabelle gets pretty close, but it's not quite untyped foundations and as a result they are stuck with some things</p>

<a name="159427056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159427056" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159427056">Johan Commelin (Feb 26 2019 at 14:21)</a>:</h4>
<p>Hmmm, so why again did you give my colleagues that nlab blogpost on why type theory p0wns set theory?</p>

<a name="159427119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159427119" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159427119">Mario Carneiro (Feb 26 2019 at 14:22)</a>:</h4>
<p>I didn't write it, and I don't really endorse most of nLab philosophy</p>

<a name="159427136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159427136" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159427136">Mario Carneiro (Feb 26 2019 at 14:22)</a>:</h4>
<p>but it's a good place to find the philosophy when you want it</p>

<a name="159443240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159443240" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159443240">Johan Commelin (Feb 26 2019 at 17:56)</a>:</h4>
<blockquote>
<p>Why not use +1 instead of -1?</p>
</blockquote>
<p>So, for <code>is_complex</code> I could do this. But for <code>is_exact_at (i : int)</code> you need to reference <code>A.obj (i-1)</code> at some point. You can't avoid the subtraction. (Unless you want to break with the indexing conventions, but that will just move the pain to the next page, where it will hit you twice as hard.)</p>

<a name="159443585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159443585" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159443585">Mario Carneiro (Feb 26 2019 at 18:01)</a>:</h4>
<p>with the <code>next</code> thing, you can say <code>\ex j, next i j /\ ...</code></p>

<a name="159443669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159443669" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159443669">Mario Carneiro (Feb 26 2019 at 18:02)</a>:</h4>
<p>but depending on what you want to say just plain <code>A.obj (i-1)</code> might be best</p>

<a name="159443832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159443832" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159443832">Johan Commelin (Feb 26 2019 at 18:05)</a>:</h4>
<p>So what is actually the benefit of <code>next</code>? Why can't I just write a condition <code>(h : j = i+1)</code> in the definition of <code>delta</code>?</p>

<a name="159443845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159443845" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159443845">Mario Carneiro (Feb 26 2019 at 18:05)</a>:</h4>
<p>you can</p>

<a name="159443860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159443860" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159443860">Mario Carneiro (Feb 26 2019 at 18:05)</a>:</h4>
<p>but it generalizes to more complicated index structures</p>

<a name="159444088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159444088" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159444088">Johan Commelin (Feb 26 2019 at 18:09)</a>:</h4>
<p>I see...</p>

<a name="159444105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159444105" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159444105">Mario Carneiro (Feb 26 2019 at 18:09)</a>:</h4>
<p>I'm not saying you should necessarily use it here</p>

<a name="159444253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159444253" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159444253">Reid Barton (Feb 26 2019 at 18:11)</a>:</h4>
<p>Another example of this index business is (commutative / graded commutative) graded algebras</p>

<a name="159444327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159444327" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159444327">Reid Barton (Feb 26 2019 at 18:12)</a>:</h4>
<p>where multiplication is a family of operations <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>:</mo><msub><mi>A</mi><mi>i</mi></msub><mo>√ó</mo><msub><mi>A</mi><mi>j</mi></msub><mo>‚Üí</mo><msub><mi>A</mi><mrow><mi>i</mi><mo>+</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">m : A_i \times A_j \to A_{i+j}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="base"><span class="mord mathit">m</span><span class="mrel">:</span><span class="mord"><span class="mord mathit">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mbin">√ó</span><span class="mord"><span class="mord mathit">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"></span></span></span></span></span><span class="mrel">‚Üí</span><span class="mord"><span class="mord mathit">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">i</span><span class="mbin mtight">+</span><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">m</span></span></span></span> is supposed to be, say, associative, but stating that depends on the associativity of addition of indices</p>

<a name="159444385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159444385" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159444385">Johan Commelin (Feb 26 2019 at 18:13)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Do you know how mathematicians write the predicate <code>is_complex</code>?<br>
They just write <code>A.delta \circ A.delta = 0</code><br>
Now, I thought I should write <code>\forall i, A.delta i \circ A.delta (i-1) = 0</code>. But you are telling me I need 3 explicit arguments... it will probably take my psyche some time to adjust.</p>

<a name="159444505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159444505" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159444505">Johan Commelin (Feb 26 2019 at 18:15)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> Yeah, I was thinking about those a bit. (Because you can of course also do sequences as graded modules with a differential of degree 1.) I really don't know if the <code>A_i</code> should be an indexed family of types or an indexed family of subsets... We will probably need both...</p>

<a name="159449374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159449374" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159449374">Sebastien Gouezel (Feb 26 2019 at 19:15)</a>:</h4>
<blockquote>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> Do you know how mathematicians write the predicate <code>is_complex</code>?<br>
They just write <code>A.delta \circ A.delta = 0</code></p>
</blockquote>
<p>You can also write it in this way in Lean if you think of the total space of your complex as a group/module/whatever (with an additional filtered structure), and <code>A.delta</code>as a group/module/whatever morphism that, incidentally, happens to respect the filtration.</p>

<a name="159449990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flexible%20indices/near/159449990" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/83755flexibleindices.html#159449990">Johan Commelin (Feb 26 2019 at 19:23)</a>:</h4>
<p>Yes, but I fear that will make talking about homogeneous elements a lot more awkward...</p>


{% endraw %}

{% include archive_update.html %}