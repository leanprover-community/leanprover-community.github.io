---
layout: archive
title: Lean Prover Zulip Chat Archive 
permalink: archive/116395maths/75424HoTT.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html">HoTT</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="166520970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166520970" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166520970">Kevin Buzzard (May 25 2019 at 10:17)</a>:</h4>
<p>Here's a message I just posted to the <a href="https://groups.google.com/forum/#!forum/homotopytypetheory" target="_blank" title="https://groups.google.com/forum/#!forum/homotopytypetheory">homotopy type theory google group forum</a>:</p>
<blockquote>
<p>Hi from a Lean user.</p>
<p>As many people here will know, Tom Hales' formal abstracts project <a href="https://formalabstracts.github.io/" target="_blank" title="https://formalabstracts.github.io/">https://formalabstracts.github.io/</a> wants to formalise many of the statements of modern pure mathematics in Lean. One could ask more generally about a project of formalising many of the statements of modern pure mathematics in an arbitrary system, such as HoTT. I know enough about the formalisation process to know that whatever system one chooses, there will be pain points, because some mathematical ideas fit more readily into some foundational systems than others.</p>
<p>I have seen enough of Lean to become convinced that the pain points would be surmountable in Lean. I have seen enough of Isabelle/HOL to become skeptical about the idea that it would be suitable for all of modern pure mathematics, although it is clearly suitable for some of it; however it seems that simple type theory struggles to handle things like tensor products of sheaves of modules on a scheme, because sheaves are dependent types and it seems that one cannot use Isabelle's typeclass system to handle the rings showing up in a sheaf of rings.</p>
<p>I have very little experience with HoTT. I have heard that the fact that "all constructions must be isomorphism-invariant" is both a blessing and a curse. However I would like to know more details. I am speaking at the Big Proof conference in Edinburgh this coming Wednesday on the pain points involved with formalising mathematical objects in dependent type theory and during the preparation of my talk I began to wonder what the analogous picture was with HoTT.</p>
<p>Everyone will have a different interpretation of "modern pure mathematics" so to fix our ideas, let me say that for the purposes of this discussion, "modern pure mathematics" means the statements of the theorems publishsed by the Annals of Mathematics over the last few years, so for example I am talking about formalising statements of theorems involving L-functions of abelian varieties over number fields, Hodge theory, cohomology of algebraic varieties, Hecke algebras of symmetric groups, Ricci flow and the like; one can see titles and more at <a href="http://annals.math.princeton.edu/2019/189-3" target="_blank" title="http://annals.math.princeton.edu/2019/189-3">http://annals.math.princeton.edu/2019/189-3</a> . Classical logic and the axiom of choice are absolutely essential -- I am only interested in the hard-core "classical mathematician" stance of the way mathematics works, and what it is.</p>
<p>If this is not the right forum for this question, I would be happily directed to somewhere more suitable. After spending 10 minutes failing to get onto ##hott on freenode ("you need to be identified with services") I decided it was easier just to ask here. If people want to chat directly I am usually around at <a href="" target="_blank" title="">https://leanprover.zulipchat.com/</a> (registration required, full names are usually used, I'll start a HoTT thread in #mathematics).</p>
<p>Kevin Buzzard</p>
</blockquote>
<p>Does anyone here have enough experience with HoTT to say anything? I've asked here questions like "what would the pain points be if one tried to formalise a scheme in HoTT?" and have got answers of the form "if you want to find out, you should go ahead and try". I'm not sure I have time to learn another system though. I have even dumber questions -- how would one define the trace of a linear map from a finite-dimensional vector space to itself? A mathematician would pick a basis, compute the trace of the corresponding matrix, and then note that it was independent of the choice. Is this problematic in HoTT?</p>

<a name="166521201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166521201" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166521201">Reid Barton (May 25 2019 at 10:25)</a>:</h4>
<p>I suppose it will depend on exactly how you define "finite-dimensional vector space". If it's defined as a vector space together with <code>trunc</code> of a basis, then the procedure for defining the trace of a map goes exactly how you describe.</p>

<a name="166521275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166521275" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166521275">Reid Barton (May 25 2019 at 10:27)</a>:</h4>
<p><code>trunc</code> is called the "propositional truncation" in HoTT although "proposition" there more closely corresponds to what Lean calls <code>subsingleton</code></p>

<a name="166521523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166521523" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166521523">Reid Barton (May 25 2019 at 10:35)</a>:</h4>
<p>In particular, this definition is constructive. However you would probably need the axiom of choice to prove that a quotient of a finite dimensional vector space is again finite dimensional.</p>

<a name="166521718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166521718" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166521718">Reid Barton (May 25 2019 at 10:41)</a>:</h4>
<p>Or maybe LEM is enough, but that's still an uncomputable axiom</p>

<a name="166522080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166522080" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166522080">Reid Barton (May 25 2019 at 10:52)</a>:</h4>
<p>I haven't actually used a HoTT-based theorem prover yet, only read the book. I do find it difficult to get a sense of how HoTT+choice would work in practice. I think this is a cultural phenomenon: there tends to be overlap between people interested in HoTT and people interested in constructive logic. (Consider that the same could be said about Coq, yet Lean is based on essentially the same underlying type theory and look where we are now.)</p>

<a name="166522337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166522337" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166522337">Reid Barton (May 25 2019 at 11:01)</a>:</h4>
<p><span class="user-mention" data-user-id="111080">@Floris van Doorn</span> Does the construction of the Serre SS use any axioms?</p>

<a name="166522344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166522344" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166522344">Reid Barton (May 25 2019 at 11:01)</a>:</h4>
<p>Kevin, I wouldn't be surprised if in fact nobody has done anything resembling what you're asking about.</p>

<a name="166522401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166522401" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166522401">Reid Barton (May 25 2019 at 11:03)</a>:</h4>
<p>In the areas that require classical logic/choice, I mean.</p>

<a name="166522651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166522651" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166522651">Mario Carneiro (May 25 2019 at 11:10)</a>:</h4>
<p>I think UniMath is trying to build a general mathematical library on a HoTT foundation</p>

<a name="166522664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166522664" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166522664">Mario Carneiro (May 25 2019 at 11:11)</a>:</h4>
<p>I think it slowed down when Voevodsky died though</p>

<a name="166522666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166522666" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166522666">Kevin Buzzard (May 25 2019 at 11:11)</a>:</h4>
<p>What am I asking about? Doing fabstracts in hott or making schemes in hott? I am currently thinking about undergraduate maths. Say V and W are finite dimensional vector spaces over an arbitrary field, defined however you like, and we have a linear map from V to W. Say X is the kernel. Say I have a linear map from X to X. Can I define its trace in HoTT?</p>

<a name="166522670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166522670" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166522670">Kevin Buzzard (May 25 2019 at 11:11)</a>:</h4>
<p>So unimath is to mathlib as hott is to lean?</p>

<a name="166522716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166522716" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166522716">Mario Carneiro (May 25 2019 at 11:12)</a>:</h4>
<p>I think so, I'm no expert though</p>

<a name="166522739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166522739" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166522739">Kevin Buzzard (May 25 2019 at 11:13)</a>:</h4>
<p>Then where is the analogue of me who tried to do completely dumb simple maths things in HoTT?</p>

<a name="166522797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166522797" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166522797">Mario Carneiro (May 25 2019 at 11:14)</a>:</h4>
<p>I certainly wouldn't be able to answer that</p>

<a name="166522799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166522799" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166522799">Mario Carneiro (May 25 2019 at 11:14)</a>:</h4>
<p>I'm sure there are such people in the community but I'm not enough a part of it to say</p>

<a name="166522801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166522801" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166522801">Kevin Buzzard (May 25 2019 at 11:14)</a>:</h4>
<p>Can it be done and how far did they get? Where are the pain points? Who should I ask?</p>

<a name="166522805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166522805" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166522805">Mario Carneiro (May 25 2019 at 11:15)</a>:</h4>
<p>I guess the UniMath foundation?</p>

<a name="166522814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166522814" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166522814">Kevin Buzzard (May 25 2019 at 11:15)</a>:</h4>
<p>Hopefully someone will respond to my post on the mailing list</p>

<a name="166522819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166522819" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166522819">Kevin Buzzard (May 25 2019 at 11:15)</a>:</h4>
<p>Thanks, I'll try them</p>

<a name="166522873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166522873" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166522873">Mario Carneiro (May 25 2019 at 11:16)</a>:</h4>
<p>Part of the problem is that the HoTT world is very fragmented, so no individual project has very many people working on it</p>

<a name="166522878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166522878" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166522878">Mario Carneiro (May 25 2019 at 11:16)</a>:</h4>
<p>which I might argue is one of the downsides of DTT, strangely enough</p>

<a name="166522897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166522897" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166522897">Mario Carneiro (May 25 2019 at 11:17)</a>:</h4>
<p>The HoTT people really embrace the D in DTT, and when you work like that the exact details of definitional equality matter a lot; but there is not a uniform conception of what it should be, so you end up with a bunch of incompatible axiomatizations</p>

<a name="166522948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166522948" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166522948">Kevin Buzzard (May 25 2019 at 11:18)</a>:</h4>
<p>Does unimath work only with constructive maths??</p>

<a name="166522952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166522952" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166522952">Kevin Buzzard (May 25 2019 at 11:18)</a>:</h4>
<p>No such system will ever catch on with mathematicians</p>

<a name="166522972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166522972" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166522972">Mario Carneiro (May 25 2019 at 11:19)</a>:</h4>
<blockquote>
<p>The axioms accepted are: the univalence axiom, the law of excluded middle, the axiom of choice, and a few new variants of the axiom of choice, validated by the semantic model.</p>
</blockquote>

<a name="166522973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166522973" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166522973">Kevin Buzzard (May 25 2019 at 11:19)</a>:</h4>
<p>I am continually weirded out by the fact that Leo simultaneously seems completely uninterested in mathematics and yet seems to have made the system which is most suitable for general pure mathematicians</p>

<a name="166523021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166523021" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166523021">Kevin Buzzard (May 25 2019 at 11:20)</a>:</h4>
<p>Ok great I'll ask the univalent people if they can define the trace of a linear map and a scheme</p>

<a name="166523036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166523036" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166523036">Mario Carneiro (May 25 2019 at 11:21)</a>:</h4>
<p>I heard about it from Daniel Grayson, who is the lead developer; you could ask him for a summary</p>

<a name="166523044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166523044" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166523044">Kevin Buzzard (May 25 2019 at 11:22)</a>:</h4>
<p>Oh I know Dan from my sci.math.research days</p>

<a name="166523091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166523091" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166523091">Mario Carneiro (May 25 2019 at 11:22)</a>:</h4>
<p>the readme at <a href="https://github.com/UniMath/UniMath/tree/master/UniMath" target="_blank" title="https://github.com/UniMath/UniMath/tree/master/UniMath">https://github.com/UniMath/UniMath/tree/master/UniMath</a> has a bunch of useful general info</p>

<a name="166523260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166523260" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166523260">Reid Barton (May 25 2019 at 11:27)</a>:</h4>
<blockquote>
<p>What am I asking about? Doing fabstracts in hott or making schemes in hott? I am currently thinking about undergraduate maths. Say V and W are finite dimensional vector spaces over an arbitrary field, defined however you like, and we have a linear map from V to W. Say X is the kernel. Say I have a linear map from X to X. Can I define its trace in HoTT?</p>
</blockquote>
<p>I mean formalizing even relatively basic constructions like this one that (apparently) require choice.<br>
I'm pretty sure that this is possible in HoTT (plus choice). In either HoTT or Lean you must first prove that X is finite dimensional (has a finite basis); that part will go the same way. In HoTT you will also need to prove that the trace is independent of the choice of basis, which is not a bad thing.</p>

<a name="166524854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166524854" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166524854">Kevin Buzzard (May 25 2019 at 12:15)</a>:</h4>
<p>In HoTT if I define what it means for a ring to be local, would I have to prove that a ring isomorphic to a local ring is local before I can even make the definition?</p>

<a name="166525101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166525101" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166525101">Reid Barton (May 25 2019 at 12:22)</a>:</h4>
<p>No, you'd define it the same way as in Lean</p>

<a name="166525291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166525291" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166525291">Chris Hughes (May 25 2019 at 12:28)</a>:</h4>
<p>I think even stupid thing like this are isomorphism invariant in HoTT.</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∃</span> <span class="n">h</span> <span class="o">:</span> <span class="bp">ℤ</span> <span class="bp">=</span> <span class="n">α</span><span class="o">,</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="n">eq</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">h</span> <span class="mi">37</span>
</pre></div>

<a name="166525302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166525302" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166525302">Reid Barton (May 25 2019 at 12:29)</a>:</h4>
<p>I think a first approximation to how choice works in HoTT, expressed in the language of Lean, is that one can no longer have <code>choice : nonempty X -&gt; X</code>, but one still has</p>
<ul>
<li><code>unique_choice : nonempty X -&gt; trunc X</code>, which means that you can extract a witness for an existential to construct something provided you can prove the result doesn't depend on the choice of witness, and</li>
<li><code>axiom_of_choice : (∀ x, ∃ y, r x y) -&gt; ∃ f, ∀ x, r x (f x)</code></li>
</ul>

<a name="166525353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166525353" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166525353">Chris Hughes (May 25 2019 at 12:30)</a>:</h4>
<p>What's the difference between <code>nonempty</code> and <code>trunc</code> in HoTT?</p>

<a name="166525366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166525366" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166525366">Reid Barton (May 25 2019 at 12:31)</a>:</h4>
<p>There isn't one (at least in book HoTT) because HoTT has no notion of judgmentally being a proposition.</p>

<a name="166525373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166525373" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166525373">Chris Hughes (May 25 2019 at 12:31)</a>:</h4>
<p>So unique choice is <code>id</code>?</p>

<a name="166525374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166525374" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166525374">Reid Barton (May 25 2019 at 12:31)</a>:</h4>
<p>So the result is that places where we would use an ∃ in Lean correspond to <code>|| ∃ ... ||</code> in HoTT</p>

<a name="166525419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166525419" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166525419">Reid Barton (May 25 2019 at 12:32)</a>:</h4>
<p>or let's say <code>|| Σ ... ||</code> to be more clear</p>

<a name="166525435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166525435" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166525435">Reid Barton (May 25 2019 at 12:33)</a>:</h4>
<p>where <code>|| ... ||</code> is the propositional truncation (Lean <code>trunc</code>)</p>

<a name="166525484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166525484" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166525484">Reid Barton (May 25 2019 at 12:34)</a>:</h4>
<p>Right, so unique choice doesn't really correspond to anything in HoTT but I tried to give a translation into a Lean worldview.</p>

<a name="166525501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166525501" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166525501">Reid Barton (May 25 2019 at 12:35)</a>:</h4>
<p>Actually the HoTT book does have something it calls "unique choice", which is the statement that if P is a Prop (Lean: <code>subsingleton P</code>) then P is equivalent to ||P||.</p>

<a name="166525503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166525503" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166525503">Reid Barton (May 25 2019 at 12:35)</a>:</h4>
<p>But it's a theorem</p>

<a name="166526168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166526168" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166526168">Kevin Buzzard (May 25 2019 at 12:53)</a>:</h4>
<p>Is UniMath written in book HoTT?</p>

<a name="166526726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166526726" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166526726">Reid Barton (May 25 2019 at 13:08)</a>:</h4>
<p>"Close enough"</p>

<a name="166526753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166526753" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166526753">Reid Barton (May 25 2019 at 13:09)</a>:</h4>
<p>It seems to be book HoTT minus some features like inductive types</p>

<a name="166526835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166526835" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166526835">Kevin Buzzard (May 25 2019 at 13:11)</a>:</h4>
<p>So given a tool like Coq or Lean, you can either use it as God intended, as it were, or you can start adding additional rules of the form "you can use this axiom" and "you can't use this command"</p>

<a name="166526884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166526884" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166526884">Kevin Buzzard (May 25 2019 at 13:12)</a>:</h4>
<p>This then surely makes for a more inefficient system, as the way it is designed is somehow slightly in conflict with the way it is being used.</p>

<a name="166527727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166527727" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166527727">Koundinya Vajjha (May 25 2019 at 13:36)</a>:</h4>
<p>Here's my two cents:<br>
The main advantage univalence gives us from a formalization perspective is that it allows for implementation irrelevance. I can build an entire library of the p-adics using the algebraic definition, and if someone in the future needs to use the analytic definition, she can simply transport the statements (and proofs!) proven using the first definitions onto the second.</p>

<a name="166527791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166527791" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166527791">Koundinya Vajjha (May 25 2019 at 13:38)</a>:</h4>
<p>However, this requires computable univalence, which is an open problem in book HoTT.</p>

<a name="166528012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166528012" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166528012">Koundinya Vajjha (May 25 2019 at 13:45)</a>:</h4>
<p>If we do "fabstracts in HoTT", then it would mean that we could formalize a single definition for each mathematical statement and that would, by univalence, be akin to formalizing a whole equivalence class of such definitions. (<em>upto homotopy</em>)</p>

<a name="166528065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166528065" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166528065">Koundinya Vajjha (May 25 2019 at 13:46)</a>:</h4>
<p>Sadly this would require changes to the underlying type theory to one where univalence actually computes, such as cubical type theory.</p>

<a name="166528125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166528125" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166528125">Kevin Buzzard (May 25 2019 at 13:48)</a>:</h4>
<blockquote>
<p>Here's my two cents:<br>
The main advantage univalence gives us from a formalization perspective is that it allows for implementation irrelevance. I can build an entire library of the p-adics using the algebraic definition, and if someone in the future needs to use the analytic definition, she can simply transport the statements (and proofs!) proven using the first definitions onto the second.</p>
</blockquote>
<p>I don't see any reason why we can't do this in Lean, once those computer scientists have written the <code>transport </code> tactic for us.</p>

<a name="166528326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166528326" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166528326">Koundinya Vajjha (May 25 2019 at 13:55)</a>:</h4>
<p>I haven't used <code>transport</code> so I don't know how it works. But I would conjecture that it isn't as powerful as full univalence. (In what sense exactly, I don't know)<br>
But people <em>have</em> tried to get Univalent parametricity without changing the type theory: <a href="https://hal.inria.fr/hal-01559073" target="_blank" title="https://hal.inria.fr/hal-01559073">https://hal.inria.fr/hal-01559073</a></p>

<a name="166529423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166529423" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166529423">Mario Carneiro (May 25 2019 at 14:24)</a>:</h4>
<p>I think that untyped set theory is <em>much</em> better at "implementation invariance" than dependent type theory, in general</p>

<a name="166529448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166529448" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166529448">Mario Carneiro (May 25 2019 at 14:25)</a>:</h4>
<p>In DTT all your definitions can potentially be "unfolded" and this might matter for making some terms type correct, if they appear as dependencies in a type</p>

<a name="166529452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166529452" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166529452">Mario Carneiro (May 25 2019 at 14:25)</a>:</h4>
<p>so you basically can't really hide anything, at least in principle</p>

<a name="166529518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166529518" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166529518">Mario Carneiro (May 25 2019 at 14:27)</a>:</h4>
<p>Whether <code>transport</code> is as powerful as full univalence is actually an open research question. It's related to whether univalence computes "propositionally" in book HoTT</p>

<a name="166529972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166529972" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166529972">Kevin Buzzard (May 25 2019 at 14:39)</a>:</h4>
<p>I still don't really understand how Strickland's idea managed to get the schemes project out of the hole I'd dug it into.</p>

<a name="166651904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166651904" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166651904">Floris van Doorn (May 27 2019 at 17:07)</a>:</h4>
<p>I'm late to the party, but here are some of my responses.</p>
<blockquote>
<p>Does the construction of the Serre SS use any axioms?</p>
</blockquote>
<p>No, only univalence and higher inductive types. In HoTT there is a very strong sense of "trying to avoid the axiom of choice". And if you care about that (which mathematicians of course don't), there are some nice new things you can do with HoTT to avoid axioms:</p>
<ul>
<li>You can elimination from the propositional truncation (which is like <code>nonempty</code>) to any subsingleton type without using an axiom. In Lean you would use <code>choice</code> for this.</li>
<li>Normally, if you define the real numbers as Cauchy sequences, you need the (countable) axiom of choice to prove completeness of the real numbers. In HoTT there is a definition of the Cauchy real numbers as a higher inductive type where you can prove completeness without the axiom of choice (you still need choice to prove that it is equivalent to the Dedekind real numbers).</li>
</ul>
<p>This is not to say you cannot add the axiom of choice to HoTT and work classically. This is very much possible. However, as Reid mentions you cannot add <code>classical.choice</code> (that is inconsistent with univalence), you need the weaker set-theoretic formulation of choice (e.g. every surjection has a section).</p>

<a name="166652260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166652260" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166652260">Floris van Doorn (May 27 2019 at 17:14)</a>:</h4>
<blockquote>
<p>what would the pain points be if one tried to formalise a scheme in HoTT?</p>
</blockquote>
<p>I think the pain points much more depend on which proof assistant you use, and more importantly: which tactics and automation is available. One example of a pain point when doing HoTT in Lean 2 which are specific to HoTT, is that - for example - I had to prove that the ordering on the natural numbers is a proposition (subsingleton): <a href="https://github.com/leanprover/lean2/blob/master/hott/types/nat/hott.hlean#L14" target="_blank" title="https://github.com/leanprover/lean2/blob/master/hott/types/nat/hott.hlean#L14">https://github.com/leanprover/lean2/blob/master/hott/types/nat/hott.hlean#L14</a></p>
<div class="codehilite"><pre><span></span>definition is_prop_le [instance] (n m : ℕ) : is_prop (n ≤ m)
</pre></div>


<p>A much bigger pain point is that univalence doesn't compute in Lean 2, so if you want a function you define to compute definitionally (and in Lean 2 we wanted that, partially because of the lack of a good <code>simp</code>), then you want to avoid using univalence. This made me define many many concepts explicitly which I could have defined using univalence.</p>

<a name="166652496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166652496" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166652496">Floris van Doorn (May 27 2019 at 17:20)</a>:</h4>
<p>One mentality problem in HoTT is that everything - even proofs of propositions - are definitions and it sometimes matters how you define/prove them, especially if you use dependent types heavily. For example, if you have a sequence of maps <code>X 0 -&gt; X 1 -&gt; X 2 -&gt; ...</code> then you can define a function <code>n &lt;= m -&gt; X n -&gt; X m</code>. In HoTT you can define this function by recursion on the proof that <code>n &lt;= m</code>, and so how that function computes depends on how you have proven that <code>n &lt;= m</code> (for numerals <code>n</code> and <code>m</code> there is only 1 way to do this, but for variables there could be different ways, of course). At one point, I reproved some inequalities of natural numbers to make this function compute better (and it was important that it computed better because I was using dependent types).</p>

<a name="166665147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166665147" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166665147">Andrew Ashworth (May 27 2019 at 21:28)</a>:</h4>
<p>Out of curiosity, does anyone know about how usable cubical type theory is?</p>

<a name="166666107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166666107" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166666107">Floris van Doorn (May 27 2019 at 21:52)</a>:</h4>
<p>What do you mean by usable?</p>
<ul>
<li>Usable for doing HoTT? Yes, although most proof assistants implementing univalence are pretty experimental and lack high-level features.</li>
<li>Usable for computation of univalence? Yes, it can compute univalence. Although with complicated proofs, the computation is inefficient, so you will have to optimize your proof for efficient computation.</li>
<li>Usable for doing ordinary mathematics? Probably not really.</li>
</ul>

<a name="166670185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/166670185" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#166670185">Kevin Buzzard (May 27 2019 at 23:02)</a>:</h4>
<p>You mean for the cubing a cube question? ;-)</p>

<a name="167131772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167131772" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167131772">Kevin Buzzard (Jun 02 2019 at 17:59)</a>:</h4>
<p><a href="https://groups.google.com/forum/#!topic/homotopytypetheory/NhIhMd7SM_4" target="_blank" title="https://groups.google.com/forum/#!topic/homotopytypetheory/NhIhMd7SM_4">https://groups.google.com/forum/#!topic/homotopytypetheory/NhIhMd7SM_4</a></p>
<p>The discussion on the HoTT mailing list says a bunch of things which many people here knew already; I guess they are slowly but surely dawning on me.</p>

<a name="167274706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167274706" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167274706">Johan Commelin (Jun 04 2019 at 09:34)</a>:</h4>
<p>It seems that HoTT and UniMath find it very important that everything is constructive and computable. Are their p-adics computable?</p>

<a name="167285889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167285889" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167285889">Kevin Buzzard (Jun 04 2019 at 12:12)</a>:</h4>
<p>The p-adics are uncountable so it's not even clear, I think, what this question can mean.</p>

<a name="167286716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167286716" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167286716">Rob Lewis (Jun 04 2019 at 12:24)</a>:</h4>
<p>Their paper says their p-adics are constructive. One way to interpret the computability question is to ask if they can define computable functions on the p-adics. For example, given a closed term of Z_p you might want to compute its norm. As far as I could tell, they don't define any functions beyond the arithmetic ones, computably or noncomputably. And univalence doesn't compute in UniMath. That may or may not show up to block things here, I don't know.</p>

<a name="167670100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167670100" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167670100">Kevin Buzzard (Jun 08 2019 at 22:06)</a>:</h4>
<p>A quote from (page 1 of) <span class="user-mention" data-user-id="111080">@Floris van Doorn</span> 's <a href="https://florisvandoorn.com/papers/dissertation.pdf" target="_blank" title="https://florisvandoorn.com/papers/dissertation.pdf">thesis</a>:</p>
<blockquote>
<p>The fact that all constructions are homotopy invariant also leads to some challenges.<br>
It is not always clear whether we can define a concept of homotopy theory in homotopy<br>
type theory. For example, singular homology is a homotopy invariant notion, but in the<br>
construction we use the set of all simplices in a space, which is not a homotopy invariant<br>
notion. In this case, we can define homology in a different way (see Section 5.5).<br>
However, for other definitions, such as the Grassmannian manifolds, it is an open<br>
problem whether they can be constructed in homotopy type theory.</p>
</blockquote>
<p>Wait--what? Are we just talking about the standard smooth projective varieties of e.g. subspaces of a f.d. vector space? What is the trouble with making them in HoTT?</p>

<a name="167670378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167670378" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167670378">Reid Barton (Jun 08 2019 at 22:15)</a>:</h4>
<p>The problem is to construct HoTT types whose "internal homotopy type" is the homotopy type of a real or complex Grassmannian.<br>
Here "internal homotopy type of X" means, for example, use the interpretation of HoTT in simplicial sets and take the homotopy type of the simplicial set corresponding to X.</p>

<a name="167670689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167670689" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167670689">Reid Barton (Jun 08 2019 at 22:24)</a>:</h4>
<p>Of course you can also reinvent the real numbers, classical topology, linear algebra, etc. in HoTT just the same way you would do in Lean and define Grassmannians that way, but there's no known way in book HoTT to relate this classical homotopy theory to the internal homotopy theory.</p>

<a name="167670754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167670754" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167670754">Reid Barton (Jun 08 2019 at 22:26)</a>:</h4>
<p>I think there was a discussion about this here before but I can't find it now</p>

<a name="167670816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167670816" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167670816">Kevin Buzzard (Jun 08 2019 at 22:28)</a>:</h4>
<p>The penny is slowly dropping. Last summer <span class="user-mention" data-user-id="120256">@Ali Sever</span> developed synthetic 2-dimensional geometry in Lean (following Tarski), where "point" and "line" are just abstract types and there are relations between them. This is different to "analytic 2-dimensional geometry" where you define <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi mathvariant="double-struck">R</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\mathbb{R}^2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">2</span></span></span></span></span></span></span></span></span></span></span> and then points are points in <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi mathvariant="double-struck">R</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\mathbb{R}^2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">2</span></span></span></span></span></span></span></span></span></span></span> and lines are lines in <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi mathvariant="double-struck">R</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\mathbb{R}^2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">2</span></span></span></span></span></span></span></span></span></span></span>. </p>
<p>This HoTT is just the same sort of thing isn't it. You're saying we can do it the "analytic" way, but this basic interpretation of types as spaces-up-to-homotopy is like the synthetic way of doing it.</p>

<a name="167670834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167670834" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167670834">Kevin Buzzard (Jun 08 2019 at 22:29)</a>:</h4>
<p>This is basically explained on p4 of the thesis. "Synthetic geometry limits the things one can state or prove, but these proofs are applicable in every model of the axioms". That's all well and good, but what about if you only care about one model?</p>

<a name="167670886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167670886" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167670886">Kevin Buzzard (Jun 08 2019 at 22:30)</a>:</h4>
<p>So there might be more models of HoTT other than spaces-up-to-homotopy?</p>

<a name="167670894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167670894" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167670894">Reid Barton (Jun 08 2019 at 22:30)</a>:</h4>
<p>There are definitely multiple models (I know it's not in English, but see the bottom of page 2)</p>

<a name="167670910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167670910" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167670910">Kevin Buzzard (Jun 08 2019 at 22:31)</a>:</h4>
<p>Hmm, yeah that doesn't really help :-/</p>

<a name="167670956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167670956" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167670956">Kevin Buzzard (Jun 08 2019 at 22:32)</a>:</h4>
<p>So is "spaces up to homotopy" a "model" for HoTT?</p>

<a name="167670972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167670972" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167670972">Kevin Buzzard (Jun 08 2019 at 22:33)</a>:</h4>
<p>Is "the simplicial set model" something like "simplicial sets up to some sort of simplicial homotopy relation"?</p>

<a name="167670977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167670977" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167670977">Kevin Buzzard (Jun 08 2019 at 22:33)</a>:</h4>
<p>Where can I read about Grothendieck infinity,1 toposes? Assume I know what a Grothendieck topos is.</p>

<a name="167671150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167671150" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167671150">Koundinya Vajjha (Jun 08 2019 at 22:38)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>  this is what people usually refer to when they talk about the "simplicial set model" - <a href="https://arxiv.org/abs/1211.2851" target="_blank" title="https://arxiv.org/abs/1211.2851">https://arxiv.org/abs/1211.2851</a></p>

<a name="167671706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167671706" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167671706">Reid Barton (Jun 08 2019 at 22:55)</a>:</h4>
<blockquote>
<p>Where can I read about Grothendieck infinity,1 toposes? Assume I know what a Grothendieck topos is.</p>
</blockquote>
<p>Instead of sheaves of sets on a site, take sheaves of spaces on a site.</p>

<a name="167671759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167671759" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167671759">Reid Barton (Jun 08 2019 at 22:56)</a>:</h4>
<p>An (infinity,1)-topos is a particular kind of (infinity,1)-category, which you could model using any choice of models for (infinity,1)-categories, for example, quasicategories as in Jacob's book.</p>

<a name="167671828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167671828" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167671828">Reid Barton (Jun 08 2019 at 22:58)</a>:</h4>
<p>Incidentally Lean minus all the axioms can also be interpreted in any Grothendieck topos, so this question about multiple models is sort of orthogonal to the question about HoTT or not.</p>

<a name="167671852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167671852" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167671852">Reid Barton (Jun 08 2019 at 22:59)</a>:</h4>
<p>You have to do a pretty large amount of work to get from an (infinity,1)-topos to an interpretation of HoTT though</p>

<a name="167671905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167671905" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167671905">Reid Barton (Jun 08 2019 at 23:00)</a>:</h4>
<p>Maybe this is the best thing to say about the spaces model:</p>

<a name="167671908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167671908" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167671908">Kevin Buzzard (Jun 08 2019 at 23:00)</a>:</h4>
<p>I only know one Grothendieck topos really, and that's the category of sets :-)</p>

<a name="167671912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167671912" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167671912">Reid Barton (Jun 08 2019 at 23:00)</a>:</h4>
<p>We're going to interpret a type as a simplicial set (or more accurately, a Kan complex)</p>

<a name="167671925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167671925" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167671925">Kevin Buzzard (Jun 08 2019 at 23:01)</a>:</h4>
<blockquote>
<p>Instead of sheaves of sets on a site, take sheaves of spaces on a site.</p>
</blockquote>
<p>Do I have to invert homotopy equivalences though?</p>

<a name="167671972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167671972" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167671972">Reid Barton (Jun 08 2019 at 23:02)</a>:</h4>
<p>and if the interpretation of <code>T</code> is a simplicial set <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07847em;">X</span></span></span></span>, then the interpretation of <code>@eq T a b</code> is the simplicial set of maps <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi mathvariant="normal">Δ</mi><mn>1</mn></msup><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">\Delta^1 \to X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathrm">Δ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">1</span></span></span></span></span></span></span></span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.07847em;">X</span></span></span></span> sending <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base"><span class="mord mathrm">0</span></span></span></span> to <code>a</code> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base"><span class="mord mathrm">1</span></span></span></span> to <code>b</code></p>

<a name="167671974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167671974" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167671974">Kevin Buzzard (Jun 08 2019 at 23:02)</a>:</h4>
<p>Right.</p>

<a name="167671977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167671977" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167671977">Reid Barton (Jun 08 2019 at 23:02)</a>:</h4>
<p>Not invert exactly but keep track of them in the higher morphisms, yes.</p>

<a name="167671983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167671983" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167671983">Kevin Buzzard (Jun 08 2019 at 23:03)</a>:</h4>
<p>A simplicial version of everything.</p>

<a name="167671989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167671989" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167671989">Kevin Buzzard (Jun 08 2019 at 23:03)</a>:</h4>
<blockquote>
<p>Not invert exactly but keep track of them in the higher morphisms, yes.</p>
</blockquote>
<p>Aah!</p>

<a name="167671991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167671991" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167671991">Reid Barton (Jun 08 2019 at 23:03)</a>:</h4>
<p>Is that an "Aaa" or an "Ahh"</p>

<a name="167671993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167671993" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167671993">Kevin Buzzard (Jun 08 2019 at 23:03)</a>:</h4>
<p>Oh I see, I am conflating two uses of "=".</p>

<a name="167672040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167672040" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167672040">Kevin Buzzard (Jun 08 2019 at 23:04)</a>:</h4>
<p>I shouldn't be thinking of "X=Y" as meaning "X looks exactly the same as Y"</p>

<a name="167672043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167672043" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167672043">Reid Barton (Jun 08 2019 at 23:04)</a>:</h4>
<p>Of course I should also tell you how to define the rest of the connectives but some of them are easy, for example <code>prod</code> becomes the product and <code>-&gt;</code> becomes the mapping space (let's ignore Pi types for now)</p>

<a name="167672056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167672056" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167672056">Kevin Buzzard (Jun 08 2019 at 23:05)</a>:</h4>
<p>Pi types are just some fibration or something</p>

<a name="167672059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167672059" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167672059">Kevin Buzzard (Jun 08 2019 at 23:05)</a>:</h4>
<p>oh, in the simplicial world you have to make them</p>

<a name="167672061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167672061" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167672061">Reid Barton (Jun 08 2019 at 23:05)</a>:</h4>
<p>So if I have <code>f, g : X -&gt; Y</code> then a term <code>t : f = g</code> is a map <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi mathvariant="normal">Δ</mi><mn>1</mn></msup><mo>→</mo><msup><mi>Y</mi><mi>X</mi></msup></mrow><annotation encoding="application/x-tex">\Delta^1 \to Y^X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathrm">Δ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">1</span></span></span></span></span></span></span></span><span class="mrel">→</span><span class="mord"><span class="mord mathit" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.07847em;">X</span></span></span></span></span></span></span></span></span></span></span>--which I can also treat as <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>×</mo><msup><mi mathvariant="normal">Δ</mi><mn>1</mn></msup><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \times \Delta^1 \to Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07847em;">X</span><span class="mbin">×</span><span class="mord"><span class="mord mathrm">Δ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">1</span></span></span></span></span></span></span></span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.22222em;">Y</span></span></span></span>, i.e., a simplicial homotopy (since I assumed my spaces were Kan complexes, I can represent every homotopy which should exist this way)</p>

<a name="167672111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167672111" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167672111">Kevin Buzzard (Jun 08 2019 at 23:06)</a>:</h4>
<p>How do I know that this simplicial model is definitely different to the topological spaces model?</p>

<a name="167672124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167672124" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167672124">Reid Barton (Jun 08 2019 at 23:07)</a>:</h4>
<p>I think there can't really be a topological spaces model for technical reasons but if there was one it should not be different in any meaningful way</p>

<a name="167672170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167672170" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167672170">Kevin Buzzard (Jun 08 2019 at 23:08)</a>:</h4>
<p>So what did you mean by "sheaves of spaces" [on a point]?</p>

<a name="167672171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167672171" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167672171">Reid Barton (Jun 08 2019 at 23:08)</a>:</h4>
<p>so you can just imagine topological spaces instead of simplicial sets, if you prefer</p>

<a name="167672173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167672173" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167672173">Reid Barton (Jun 08 2019 at 23:08)</a>:</h4>
<p>"Space" is a free-for-all word that means simplicial set or topological space or whatever you like that models the homotopy theory of spaces</p>

<a name="167672175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167672175" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167672175">Kevin Buzzard (Jun 08 2019 at 23:08)</a>:</h4>
<p>clever!</p>

<a name="167672237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167672237" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167672237">Reid Barton (Jun 08 2019 at 23:10)</a>:</h4>
<p>It's sort of analogous to how we don't care what model you pick for a <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi><mo>(</mo><mi>G</mi><mo separator="true">,</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">K(G,1)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="mopen">(</span><span class="mord mathit">G</span><span class="mpunct">,</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span> or whatever, but one level higher</p>

<a name="167672262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167672262" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167672262">Kevin Buzzard (Jun 08 2019 at 23:11)</a>:</h4>
<p>So HoTT is a way of making the "basic objects" Kan complexes. And it feels to me that Lean is a way of making the basic objects into non-intersecting sets. So if you want to do some parts of homotopy theory then HoTT is a really good way to do it because the basic objects are so close to the objects you want to model. But it sounds like a less good way of doing all mathematics, because Lean's types seem to me to be closer to the kind of objects that mathematicians use. Are there people out there who would argue that I am wrong here and I should be thinking of Z/6Z or the p-adic numbers as some sort of space?</p>

<a name="167672332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167672332" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167672332">Reid Barton (Jun 08 2019 at 23:13)</a>:</h4>
<p>Z/6Z no; of course you already think of the p-adic numbers as some kind of space--it's not the kind of space that HoTT helps you with, but another flavor of type theory might</p>

<a name="167672340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167672340" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167672340">Reid Barton (Jun 08 2019 at 23:13)</a>:</h4>
<p>or rather than changing your type theory, you could change your model (condensed sets?)</p>

<a name="167672382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167672382" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167672382">Kevin Buzzard (Jun 08 2019 at 23:14)</a>:</h4>
<p>I definitely don't think of the p-adic numbers as only being defined up to homotopy!</p>

<a name="167672388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167672388" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167672388">Kevin Buzzard (Jun 08 2019 at 23:14)</a>:</h4>
<blockquote>
<p>or rather than changing your type theory, you could change your model (condensed sets?)</p>
</blockquote>
<p>Do they have anything to do with all this nonsense?</p>

<a name="167672391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167672391" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167672391">Reid Barton (Jun 08 2019 at 23:14)</a>:</h4>
<p>Anyways in HoTT you can always impose a condition that makes a type X into a genuine set: namely <code>isSet X := \Pi (a b : X) (e f : a = b), e = f</code></p>

<a name="167672395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167672395" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167672395">Kevin Buzzard (Jun 08 2019 at 23:15)</a>:</h4>
<p>Right. And then I can perhaps prove that some things are sets.</p>

<a name="167672457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167672457" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167672457">Kevin Buzzard (Jun 08 2019 at 23:16)</a>:</h4>
<p>It seems to me that I have lost the ability to rewrite, and this extra condition is some attempt to put it back again. Hmm. Maybe what I'm saying is that I have lost <code>Prop</code>, and one can attempt to make it again, but I bet in practice it's not as good as my beloved Lean <code>Prop</code>.</p>

<a name="167672458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167672458" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167672458">Reid Barton (Jun 08 2019 at 23:16)</a>:</h4>
<p>and then manually use <code>isSet</code> where you would in Lean rely on proof irrelevance--and then you get only a propositional equality and not a definitional one. It doesn't seem very ergonomic to me, but I've never tried to use it myself.</p>

<a name="167672459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167672459" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167672459">Reid Barton (Jun 08 2019 at 23:16)</a>:</h4>
<p>Basically what you just wrote</p>

<a name="167672470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167672470" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167672470">Kevin Buzzard (Jun 08 2019 at 23:17)</a>:</h4>
<p>My attempt over the last couple of weeks to understand HoTT has taken some of the gloss off it. I think I'd rather have a <code>transfer</code> tactic than lose all this other stuff. The <code>transfer</code> tactic seems accessible to me.</p>

<a name="167672515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167672515" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167672515">Reid Barton (Jun 08 2019 at 23:18)</a>:</h4>
<p>Now you could probably design a system with both HoTT-style types and sets, or more generally track the "h-level" of a type (= how truncated it is) the same way Lean tracks universe levels, it just doesn't exist yet as far as I know</p>

<a name="167672557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167672557" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167672557">Kevin Buzzard (Jun 08 2019 at 23:19)</a>:</h4>
<p>I see. So one could imagine some future version of Leo coming along with a new model, a slightly different kind of type theory which was perhaps some way between Lean and HoTT, which worked even better for mathematics, and then we'd all have to start again?</p>

<a name="167672736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167672736" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167672736">Reid Barton (Jun 08 2019 at 23:24)</a>:</h4>
<p>Or possibly we figure out how to extend/embed these systems in a way that doesn't require starting over</p>

<a name="167672870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167672870" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167672870">Reid Barton (Jun 08 2019 at 23:29)</a>:</h4>
<p>The question you started with about building types in HoTT that correspond to things we classically build using geometric constructions is a big deal if you want to go far into homotopy theory, too.</p>

<a name="167672875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167672875" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167672875">Kevin Buzzard (Jun 08 2019 at 23:29)</a>:</h4>
<p>It seems to me that for "normal mathematicians" (i.e. mathematicians who don't know anything about type theory or set theory or category theory), vanilla Lean 3 is currently the best option for formalising "all normal maths" on a computer. HOL has no dependent types so just isn't flexible enough for algebra (although it's very good at analysis) and HoTT is great at homotopy theory but lacks a decent implementation in a computer system. Mizar seems to be dead, for some reason, so that leaves Coq, Lean and Agda, and Lean is somehow better than the other two because it was written later on so has learnt from the mistakes of the earlier systems (quotients, term mode and tactic mode, ...)</p>

<a name="167672937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167672937" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167672937">Kevin Buzzard (Jun 08 2019 at 23:30)</a>:</h4>
<blockquote>
<p>The question you started with about building types in HoTT that correspond to things we classically build using geometric constructions is a big deal if you want to go far into homotopy theory, too.</p>
</blockquote>
<p>Why? If you want to reason about complicated objects which have an analytic construction but not a synthetic one then you should figure out what extra properties you need from the analytic construction which don't "come for free" via some formal synthetic argument, right?</p>

<a name="167672948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167672948" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167672948">Reid Barton (Jun 08 2019 at 23:31)</a>:</h4>
<p>Well, and then what? Add them as constants/axioms?</p>

<a name="167672950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167672950" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167672950">Reid Barton (Jun 08 2019 at 23:31)</a>:</h4>
<p>If you're willing to extend the theory then you have options</p>

<a name="167672957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167672957" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167672957">Kevin Buzzard (Jun 08 2019 at 23:32)</a>:</h4>
<p>Oh we're slightly at cross purposes. I was imagining building them analytically. Sure you're in trouble if you want to do everything synthetically.</p>

<a name="167673001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167673001" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167673001">Kevin Buzzard (Jun 08 2019 at 23:32)</a>:</h4>
<p>sounds to me like you can't even do Grassmannians if you stick to the synthetic approach.</p>

<a name="167673003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167673003" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167673003">Reid Barton (Jun 08 2019 at 23:32)</a>:</h4>
<p>Right and that means no K-theory, or complex cobordism which is at the heart of chromatic homotopy theory, etc</p>

<a name="167673017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167673017" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167673017">Reid Barton (Jun 08 2019 at 23:33)</a>:</h4>
<p>So one thing I would like to attempt some day is to turn the Kapulkin-Lumsdaine paper that <span class="user-mention" data-user-id="116448">@Koundinya Vajjha</span> linked earlier into Lean so that you can do the synthetic homotopy theory parts in an embedded HoTT language and the analytic parts with whatever means are necessary.</p>

<a name="167673065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167673065" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167673065">Reid Barton (Jun 08 2019 at 23:34)</a>:</h4>
<p>though I have very little idea how well the "embedded HoTT language" part would work in practice</p>

<a name="167673134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167673134" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167673134">Kevin Buzzard (Jun 08 2019 at 23:36)</a>:</h4>
<p>I just can't get away from the fact that HoTT is making a tool which makes some parts of homotopy theory very nice. What about the rest of maths? It's like Isabelle/HOL with its real analysis.</p>

<a name="167673159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167673159" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167673159">Kevin Buzzard (Jun 08 2019 at 23:36)</a>:</h4>
<p>These tools are very suitable for parts of maths, but a lot less suitable for other parts.</p>

<a name="167673193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167673193" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167673193">Reid Barton (Jun 08 2019 at 23:37)</a>:</h4>
<p>I mean, it does also solve your "if R is local and S is isomorphic to R then S is local" problem.</p>

<a name="167673245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167673245" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167673245">Reid Barton (Jun 08 2019 at 23:38)</a>:</h4>
<p>I think the area where HoTT is strongest is actually category theory (and maybe n-categories for very small values of n like 2) and maybe this is why UniMath has so much of it.</p>

<a name="167673408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167673408" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167673408">Kevin Buzzard (Jun 08 2019 at 23:42)</a>:</h4>
<blockquote>
<p>I mean, it does also solve your "if R is local and S is isomorphic to R then S is local" problem.</p>
</blockquote>
<p>It does, but it sounds to me like Lean might be able to make a better solution.</p>

<a name="167673417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167673417" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167673417">Kevin Buzzard (Jun 08 2019 at 23:43)</a>:</h4>
<p>because Lean's solution will have computational content.</p>

<a name="167673423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167673423" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167673423">Kevin Buzzard (Jun 08 2019 at 23:43)</a>:</h4>
<p>If we make some computable definition that depends on R, and then port it over to S, it should remain computable.</p>

<a name="167673609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167673609" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167673609">Reid Barton (Jun 08 2019 at 23:49)</a>:</h4>
<p>Oh, I don't know whether this helps, but regarding the term "sheaf of spaces" which I never really defined, if you require the spaces to only have <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>π</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\pi_0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\pi_1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span>, then it's the same thing as a stack.</p>

<a name="167673614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167673614" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167673614">Reid Barton (Jun 08 2019 at 23:49)</a>:</h4>
<p>Because a space with only <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>π</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\pi_0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\pi_1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> is the same thing as a groupoid</p>

<a name="167673874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167673874" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167673874">Reid Barton (Jun 08 2019 at 23:56)</a>:</h4>
<p><a href="https://homotopytypetheory.org/2017/09/16/a-hands-on-introduction-to-cubicaltt/" target="_blank" title="https://homotopytypetheory.org/2017/09/16/a-hands-on-introduction-to-cubicaltt/">https://homotopytypetheory.org/2017/09/16/a-hands-on-introduction-to-cubicaltt/</a></p>
<blockquote>
<p>cubicaltt is based on a novel type theory called Cubical Type Theory that provides new ways to reason about equality. Most notably it makes various extensionality principles, like function extensionality and Voevodsky’s univalence axiom, into theorems instead of axioms. This is done such that these principles have computational content and in particular that we can transport structures between equivalent types and that these transports compute. This is different from when one postulates the univalence axiom in a proof assistant like Coq or Agda. If one just adds an axiom there is no way for Coq or Agda to know how it should compute and one looses the good computational properties of type theory. In particular canonicity no longer holds and one can produce terms that are stuck (e.g. booleans that are neither true nor false but don’t reduce further). In other words this is like having a programming language in which one doesn’t know how to run the programs. So cubicaltt provides an operational semantics for Homotopy Type Theory and Univalent Foundations by giving a computational justification for the univalence axiom and (some) higher inductive types.</p>
</blockquote>

<a name="167673884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167673884" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167673884">Kevin Buzzard (Jun 08 2019 at 23:57)</a>:</h4>
<p>So how's its maths library?</p>

<a name="167673887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167673887" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167673887">Reid Barton (Jun 08 2019 at 23:57)</a>:</h4>
<p>I think this is currently even more impractical to actually use though.</p>

<a name="167673888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167673888" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167673888">Reid Barton (Jun 08 2019 at 23:57)</a>:</h4>
<blockquote>
<p>For those who cannot live without implicit arguments and other features of modern proof assistants there is now an experimental cubical mode shipped with the master branch of Agda.</p>
</blockquote>

<a name="167673941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167673941" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167673941">Kevin Buzzard (Jun 08 2019 at 23:58)</a>:</h4>
<p>and presumably, like Coq or Lean, if you try it in Agda then you have to promise not to use some of Agda's functionality?</p>

<a name="167673956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167673956" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167673956">Kevin Buzzard (Jun 08 2019 at 23:59)</a>:</h4>
<p>What's the easiest way of proving <code>false</code> using the Lean 3 HoTT package?</p>

<a name="167674024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167674024" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167674024">Kevin Buzzard (Jun 09 2019 at 00:00)</a>:</h4>
<p>Is <code>bool = fin 2 -&gt; false</code> provable in Lean?</p>

<a name="167674083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167674083" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167674083">Reid Barton (Jun 09 2019 at 00:02)</a>:</h4>
<p>It looks like the Agda cubical thing is a mode that Agda is aware of, so it probably automatically prevents you from breaking the rules (assuming there aren't bugs), like Lean 2's HoTT mode</p>

<a name="167674090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167674090" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167674090">Kevin Buzzard (Jun 09 2019 at 00:02)</a>:</h4>
<p>Maybe it's easier to write down two equivalences bool -&gt; bool</p>

<a name="167674091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167674091" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167674091">Kenny Lau (Jun 09 2019 at 00:02)</a>:</h4>
<blockquote>
<p>Is <code>bool = fin 2 -&gt; false</code> provable in Lean?</p>
</blockquote>
<p>no</p>

<a name="167674145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167674145" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167674145">Reid Barton (Jun 09 2019 at 00:04)</a>:</h4>
<blockquote>
<p>What's the easiest way of proving <code>false</code> using the Lean 3 HoTT package?</p>
</blockquote>
<p>Use univalence to construct <code>e : bool = bool</code> such that <code>eq.rec</code> on <code>e</code> swaps the values, and then use proof irrelevance to get <code>e = rfl</code></p>

<a name="167674158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167674158" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167674158">Kevin Buzzard (Jun 09 2019 at 00:05)</a>:</h4>
<p>right.</p>

<a name="167674162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167674162" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167674162">Chris Hughes (Jun 09 2019 at 00:05)</a>:</h4>
<p>Is <code>tt == ff</code> in HoTT</p>

<a name="167674217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167674217" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167674217">Kevin Buzzard (Jun 09 2019 at 00:07)</a>:</h4>
<blockquote>
<p>Use univalence to construct <code>e : bool = bool</code> such that <code>eq.rec</code> on <code>e</code> swaps the values, and then use proof irrelevance to get <code>e = rfl</code></p>
</blockquote>
<p>dammit <code>e</code> has type Type 1 instead of <code>Prop</code></p>

<a name="167674219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167674219" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167674219">Kevin Buzzard (Jun 09 2019 at 00:07)</a>:</h4>
<p><code>=</code> has been redefined to mean <code>hott.eq</code></p>

<a name="167674265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167674265" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167674265">Chris Hughes (Jun 09 2019 at 00:08)</a>:</h4>
<p>Are you in HoTT Lean?</p>

<a name="167674266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167674266" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167674266">Kevin Buzzard (Jun 09 2019 at 00:08)</a>:</h4>
<p>rofl <code>=</code> is overloaded</p>

<a name="167674268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167674268" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167674268">Kevin Buzzard (Jun 09 2019 at 00:08)</a>:</h4>
<p>I'm just goofing around in <span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> 's hott3 repo</p>

<a name="167674270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167674270" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167674270">Kevin Buzzard (Jun 09 2019 at 00:08)</a>:</h4>
<p><code>=</code> is overloaded! It's just like normal maths!</p>

<a name="167674331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167674331" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167674331">Kevin Buzzard (Jun 09 2019 at 00:10)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">hott_theory_cmd</span> <span class="s2">&quot;local infix ` = ` := hott.eq&quot;</span>

<span class="bp">@</span><span class="o">[</span><span class="n">hott</span><span class="o">,</span> <span class="kn">reducible</span><span class="o">]</span> <span class="n">def</span> <span class="n">rfl</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">}</span> <span class="o">:=</span> <span class="n">eq</span><span class="bp">.</span><span class="n">refl</span> <span class="n">a</span>
</pre></div>


<p>You've got to be pretty darn careful in this repo!</p>

<a name="167674335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167674335" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167674335">Reid Barton (Jun 09 2019 at 00:10)</a>:</h4>
<p>Oh I was afraid of that, but I only skimmed the source on github, I didn't actually build it.</p>

<a name="167674349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167674349" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167674349">Kevin Buzzard (Jun 09 2019 at 00:11)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">eq</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="bp">|</span> <span class="n">refl</span> <span class="o">:</span> <span class="n">eq</span> <span class="n">a</span>
</pre></div>

<a name="167674350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167674350" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167674350">Reid Barton (Jun 09 2019 at 00:11)</a>:</h4>
<p>Okay so it's the same as the normal <code>eq</code>, just not a Prop.</p>

<a name="167674352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167674352" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167674352">Kevin Buzzard (Jun 09 2019 at 00:11)</a>:</h4>
<p>right</p>

<a name="167674469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167674469" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167674469">Reid Barton (Jun 09 2019 at 00:15)</a>:</h4>
<p>You can still prove that any two terms of type <code>hott.eq a b</code> are equal but it's more complicated than you might expect under the hood.</p>

<a name="167674514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167674514" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167674514">Kevin Buzzard (Jun 09 2019 at 00:16)</a>:</h4>
<p>Perhaps I'm not supposed to be proving that sort of thing.</p>

<a name="167674520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167674520" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167674520">Reid Barton (Jun 09 2019 at 00:17)</a>:</h4>
<p>Well that's how you finish the proof of <code>false</code>--it replaces the proof irrelevance step</p>

<a name="167674532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167674532" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167674532">Reid Barton (Jun 09 2019 at 00:17)</a>:</h4>
<p>So yes you're not supposed to prove it</p>

<a name="167674818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167674818" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167674818">Chris Hughes (Jun 09 2019 at 00:25)</a>:</h4>
<p>This always seemed to me to be something that felt accidentally consistent. You have a recursor that says every proof is <code>refl</code>, but somehow you can't prove everything's a set. A lot of the proofs in the HoTT book informally prove equalities by saying "assume everything's refl". Is there some intuition behind when this is valid? Very imprecise question, I know.</p>

<a name="167674829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167674829" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167674829">Koundinya Vajjha (Jun 09 2019 at 00:25)</a>:</h4>
<blockquote>
<p>So one thing I would like to attempt some day is to turn the Kapulkin-Lumsdaine paper that <span class="user-mention silent" data-user-id="116448">Koundinya Vajjha</span> linked earlier into Lean so that you can do the synthetic homotopy theory parts in an embedded HoTT language and the analytic parts with whatever means are necessary.</p>
</blockquote>
<p>AFAIK, synthetic homotopy theory uses Higher Inductive types and the Kapulkin-Lumsdaine paper avoids HITs altogether. As of last year, I think HITs have a semantics in the simplicial model, although I'm not totally sure.</p>

<a name="167674876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167674876" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167674876">Reid Barton (Jun 09 2019 at 00:26)</a>:</h4>
<p>It avoids them in the sense that it does not handle them, yeah.</p>

<a name="167674878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167674878" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167674878">Kevin Buzzard (Jun 09 2019 at 00:26)</a>:</h4>
<p>The definition of the <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>S</mi><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">S^1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">1</span></span></span></span></span></span></span></span></span></span></span> type (the circle) seems to have one point <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">x</span></span></span></span> and one proof <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">x=x</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">x</span><span class="mrel">=</span><span class="mord mathit">x</span></span></span></span> and you can compose this proof with itself lots of times and get lots of proofs of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">x=x</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">x</span><span class="mrel">=</span><span class="mord mathit">x</span></span></span></span> and only one of them will be <code>refl</code></p>

<a name="167674896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167674896" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167674896">Kevin Buzzard (Jun 09 2019 at 00:27)</a>:</h4>
<p>This proof of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">x=x</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">x</span><span class="mrel">=</span><span class="mord mathit">x</span></span></span></span> is made as an explicit constructor in the definition of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>S</mi><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">S^1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">1</span></span></span></span></span></span></span></span></span></span></span> so is really not proved by <code>refl</code></p>

<a name="167674899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167674899" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167674899">Kevin Buzzard (Jun 09 2019 at 00:27)</a>:</h4>
<p>I don't even know if I'm supposed to be calling it a "proof".</p>

<a name="167675138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167675138" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167675138">Mario Carneiro (Jun 09 2019 at 00:34)</a>:</h4>
<p><span class="user-mention" data-user-id="110044">@Chris Hughes</span> It's not exactly about "assume everything's refl", but it's hard not to read it that way because that's what the J rule (aka <code>eq.drec</code>) says</p>

<a name="167675148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167675148" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167675148">Reid Barton (Jun 09 2019 at 00:35)</a>:</h4>
<blockquote>
<p>This always seemed to me to be something that felt accidentally consistent. You have a recursor that says every proof is <code>refl</code>, but somehow you can't prove everything's a set. A lot of the proofs in the HoTT book informally prove equalities by saying "assume everything's refl". Is there some intuition behind when this is valid? Very imprecise question, I know.</p>
</blockquote>
<p>At least one endpoint of the equality has to be a variable; then you can replace it and the equality proof by the other endpoint and <code>refl</code>. The intuition is that if you have a path in a space, if you're allowed to move one endpoint, then you can collapse the path down to a constant path, but if you're not allowed to then you can't. (Well that is kind of obvious, but the point is that even if the two endpoints are the same then the path might not be equal to the constant path.)</p>

<a name="167694290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167694290" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167694290">Floris van Doorn (Jun 09 2019 at 10:41)</a>:</h4>
<p>Some comments:</p>
<blockquote>
<p>Kevin Buzzard: So how's its [cubicaltt's] maths library?</p>
</blockquote>
<p>There is none, up to a rounding error. I doubt that the rational numbers are defined. Note that cubicaltt does not support implicit arguments, and yes, that is every bit as inconvenient as you think it is.</p>
<blockquote>
<p>What's the easiest way of proving false using the Lean 3 HoTT package?</p>
</blockquote>
<p>The claim of consistency of the Lean 3 HoTT library is that you cannot prove <code>false</code> in a declaration with the <code>@[hott]</code> attribute without generating a warning/error message. Without this attribute you can do it, as stated above (you have to prove that <code>hott.eq</code> and <code>eq</code> are equivalent).</p>
<blockquote>
<p>Is <code>tt == ff</code> in HoTT</p>
</blockquote>
<p>If <code>==</code> is the <code>heq</code> analogue for HoTT, then yes. However, this is not in contradiction, since you cannot prove that if <code>x == y</code> and <code>x : A</code> and <code>y : A</code> then <code>x = y</code>. What this shows is that <code>heq</code> is not a useful notion in HoTT. Instead, we use pathovers: <a href="https://github.com/gebner/hott3/blob/master/src/hott/init/pathover.lean" target="_blank" title="https://github.com/gebner/hott3/blob/master/src/hott/init/pathover.lean">https://github.com/gebner/hott3/blob/master/src/hott/init/pathover.lean</a></p>
<blockquote>
<p><code>=</code> is overloaded! It's just like normal maths!</p>
</blockquote>
<p>If I recall correctly, local notation doesn't overload global notation, but replaces it. But now that I test it, that doesn't seem to be true. I'm quite sure it was never a problem (presumably because <code>hott.eq</code> always applies when <code>eq</code> does [for the use cases of HoTT].</p>

<a name="167698093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167698093" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167698093">Chris Hughes (Jun 09 2019 at 12:31)</a>:</h4>
<p>Is HoTT is consistent with proof irrelevance without large elimination?</p>

<a name="167728363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167728363" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167728363">Floris van Doorn (Jun 10 2019 at 02:35)</a>:</h4>
<p>With "large elimination" do you mean "singleton elimination" (the reason that <code>eq</code>, <code>acc</code>, <code>true</code> and similar inductive propositions/predicates can eliminate to <code>Type*</code> instead of just <code>Prop</code>)? Assuming you also remove choice and quotients, then I strongly suspect it is consistent, since in that case there is probably no way to go from <code>Prop</code> to <code>Type*</code>. In other words, if you can construct an element of a type, then I suspect you can construct that element without proving any proposition.</p>

<a name="167842318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167842318" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167842318">Chris Hughes (Jun 11 2019 at 11:51)</a>:</h4>
<p>This took me forever. HoTT is weird.</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">hott</span><span class="o">]</span> <span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">unit</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">),</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span>
<span class="n">punit</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">a</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="bp">@</span><span class="n">eq</span><span class="bp">.</span><span class="n">rec_on</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span> <span class="n">h</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">y</span><span class="o">,</span> <span class="n">eq</span> <span class="n">h</span> <span class="n">y</span><span class="o">)</span> <span class="bp">_</span> <span class="bp">_</span> <span class="err">$</span>
  <span class="bp">λ</span> <span class="n">y</span><span class="o">,</span> <span class="bp">@</span><span class="n">eq</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">unit</span> <span class="o">()</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">punit</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">a</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">eq</span> <span class="o">(</span><span class="n">eq</span><span class="bp">.</span><span class="n">refl</span> <span class="o">())</span> <span class="n">h</span><span class="o">))</span> <span class="o">()</span> <span class="n">y</span> <span class="o">(</span><span class="n">eq</span><span class="bp">.</span><span class="n">refl</span> <span class="bp">_</span><span class="o">))</span>
</pre></div>

<a name="167842429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167842429" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167842429">Kenny Lau (Jun 11 2019 at 11:53)</a>:</h4>
<p>are there no tactics in hott?</p>

<a name="167842530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167842530" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167842530">Chris Hughes (Jun 11 2019 at 11:54)</a>:</h4>
<p>I haven't found any. <code>cases</code> gives the the error <code>not hott: uses large eliminator eq.rec</code></p>

<a name="167842539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167842539" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167842539">Kenny Lau (Jun 11 2019 at 11:54)</a>:</h4>
<p><code>not hott</code> rhymes</p>

<a name="167842570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167842570" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167842570">Chris Hughes (Jun 11 2019 at 11:55)</a>:</h4>
<p>Also the elaborator can never compute the motive for these funny ones.</p>

<a name="167845678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167845678" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167845678">Gabriel Ebner (Jun 11 2019 at 12:39)</a>:</h4>
<p>Some tactics are available.  For example, <code>cases</code> (and the equations compiler) works as long as the type you match on is not dependent (i.e., unit, prod, list are fine.  sigma, eq is bad).  Floris wrote an <code>hinduction</code> tactic that does induction on equalities.  There is also an <code>hsimp</code> tactic that adapts the simplifier to work on <code>hott.eq</code>.</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">hott</span><span class="o">]</span> <span class="n">def</span> <span class="n">ex2</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">unit</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">),</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intro</span> <span class="n">x</span><span class="o">,</span> <span class="n">hinduction</span> <span class="n">x</span><span class="o">,</span> <span class="n">intro</span> <span class="n">y</span><span class="o">,</span> <span class="n">cases</span> <span class="n">a</span><span class="o">,</span>
<span class="n">apply</span> <span class="bp">@</span><span class="n">eq</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">unit</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">⟨⟩</span> <span class="n">h</span><span class="o">,</span> <span class="n">refl</span> <span class="bp">_</span> <span class="bp">=</span> <span class="n">h</span><span class="o">)</span> <span class="bp">_</span> <span class="n">y</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">rfl</span>
<span class="kn">end</span>
</pre></div>


<p>(My HoTT is really rusty now.)  BTW, <code>@[hott]</code> doesn't work on examples.</p>

<a name="167846809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167846809" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167846809">Chris Hughes (Jun 11 2019 at 12:55)</a>:</h4>
<p>How do I prove <code>0 \ne nat.succ n</code> in HoTT</p>

<a name="167847047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167847047" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167847047">Reid Barton (Jun 11 2019 at 12:57)</a>:</h4>
<p>can't you do it the same way as usual?</p>

<a name="167847199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167847199" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167847199">Kenny Lau (Jun 11 2019 at 12:59)</a>:</h4>
<p>spoilers: there's a proof in <code>hott.nat.basic</code></p>

<a name="167847422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167847422" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167847422">Kenny Lau (Jun 11 2019 at 13:02)</a>:</h4>
<p>spoilers<br>
.<br>
.<br>
.<br>
.<br>
.<br>
.<br>
.</p>
<div class="codehilite"><pre><span></span><span class="bp">.</span>
<span class="bp">.</span>
<span class="bp">.</span>
<span class="bp">.</span>
<span class="bp">.</span>
<span class="bp">.</span>
<span class="bp">.</span>
<span class="bp">.</span>
<span class="bp">.</span>
<span class="bp">.</span>
<span class="bp">.</span>
<span class="bp">.</span>
<span class="bp">.</span>
<span class="bp">.</span>
<span class="bp">.</span>
<span class="bp">.</span>
<span class="bp">.</span>
<span class="bp">.</span>
<span class="bp">.</span>
<span class="bp">.</span>
<span class="bp">.</span>
<span class="bp">.</span>
<span class="bp">.</span>
<span class="bp">.</span>
<span class="bp">.</span>
<span class="bp">.</span>
<span class="bp">.</span>
<span class="bp">.</span>
<span class="bp">@</span><span class="o">[</span><span class="n">hott</span><span class="o">,</span> <span class="kn">reducible</span><span class="o">]</span> <span class="kn">protected</span> <span class="n">def</span> <span class="n">code</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="mi">0</span>        <span class="mi">0</span>        <span class="o">:=</span> <span class="n">unit</span>
<span class="bp">|</span> <span class="mi">0</span>        <span class="o">(</span><span class="n">succ</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span> <span class="n">empty</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="mi">0</span>        <span class="o">:=</span> <span class="n">empty</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">succ</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span> <span class="n">code</span> <span class="n">n</span> <span class="n">m</span>

<span class="bp">@</span><span class="o">[</span><span class="n">hott</span><span class="o">]</span> <span class="kn">protected</span> <span class="n">def</span> <span class="n">refl</span> <span class="o">:</span> <span class="bp">Π</span><span class="n">n</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">code</span> <span class="n">n</span> <span class="n">n</span>
<span class="bp">|</span> <span class="mi">0</span>        <span class="o">:=</span> <span class="n">star</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">refl</span> <span class="n">n</span>

<span class="bp">@</span><span class="o">[</span><span class="n">hott</span><span class="o">]</span> <span class="kn">protected</span> <span class="n">def</span> <span class="n">encode</span> <span class="o">{</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">m</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">code</span> <span class="n">n</span> <span class="n">m</span> <span class="o">:=</span>
<span class="n">p</span> <span class="bp">▸</span> <span class="n">nat</span><span class="bp">.</span><span class="n">refl</span> <span class="n">n</span>

<span class="bp">@</span><span class="o">[</span><span class="n">hott</span><span class="o">]</span> <span class="n">def</span> <span class="n">succ_ne_zero</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">succ</span> <span class="n">n</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="n">nat</span><span class="bp">.</span><span class="n">encode</span>
</pre></div>

<a name="167847432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167847432" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167847432">Chris Hughes (Jun 11 2019 at 13:02)</a>:</h4>
<p><code>nat.no_confusion</code> will prove it for normal <code>eq</code> not HoTT <code>eq</code>. I guess I could define <code>nat.hno_confusion</code> again.</p>

<a name="167907694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167907694" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167907694">Floris van Doorn (Jun 12 2019 at 01:58)</a>:</h4>
<p>The <code>nat.code</code>/<code>encode</code>/<code>decode</code> are very similar to <code>nat.no_confusion_type</code>. They are a bit stronger, they also allow you to prove that <code>n = m</code> is equivalent (as a type) to <code>code n m</code>, which allows you to prove that <code>n = m</code> is a proposition, and hence that <code>nat</code> is a set.</p>

<a name="167907731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167907731" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167907731">Floris van Doorn (Jun 12 2019 at 01:59)</a>:</h4>
<p>There are tactic proofs in HoTT3, but there are also a bunch of illegal tactics that use proof irrelevance (<code>cases</code>/<code>rw</code>/<code>simp</code>). Instead of <code>cases</code> you can do <code>induction</code> (which is less sophisticated) and Gabriel wrote HoTT-compatible versions of <code>rw</code> and <code>simp</code> called <code>rwr</code> and <code>hsimp</code>.</p>

<a name="167908008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167908008" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167908008">Floris van Doorn (Jun 12 2019 at 02:05)</a>:</h4>
<p><span class="user-mention" data-user-id="110044">@Chris Hughes</span> That proof is indeed counter-intuitive. Here is the version in the HoTT library:<br>
<a href="https://github.com/gebner/hott3/blob/64a297c4c1effa4886abcdc08dd88824a7b27455/src/hott/init/trunc.lean#L156-L161" target="_blank" title="https://github.com/gebner/hott3/blob/64a297c4c1effa4886abcdc08dd88824a7b27455/src/hott/init/trunc.lean#L156-L161">https://github.com/gebner/hott3/blob/64a297c4c1effa4886abcdc08dd88824a7b27455/src/hott/init/trunc.lean#L156-L161</a></p>
<p>The idea behind the proof is that you first want to define a "canonical" proof that any two elements in your type are equal (which is equal to refl when the two terms are definitionally equal), and then (using path/eq induction) proof that an arbitrary path/eq is equal to the canonical one.</p>
<p>You can also look in chapter 3 of the HoTT book (I think section 3.1) for a proof in words.</p>

<a name="167908109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167908109" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167908109">Floris van Doorn (Jun 12 2019 at 02:07)</a>:</h4>
<p>There are plenty of tactic proofs in the HoTT library: <a href="https://github.com/gebner/hott3/search?q=begin&amp;unscoped_q=begin" target="_blank" title="https://github.com/gebner/hott3/search?q=begin&amp;unscoped_q=begin">https://github.com/gebner/hott3/search?q=begin&amp;unscoped_q=begin</a></p>

<a name="167960482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167960482" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167960482">Johan Commelin (Jun 12 2019 at 15:50)</a>:</h4>
<p>Here is one question that I've been wondering about:<br>
suppose that I formalise groups in HoTT. It would be something like</p>
<div class="codehilite"><pre><span></span><span class="n">class</span> <span class="n">group</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">set</span> <span class="o">:</span> <span class="n">is_a_set</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">one</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">axioms</span> <span class="o">:</span> <span class="n">blah</span><span class="o">)</span>
</pre></div>


<p>The difference is of course the addition of the <code>is_a_set</code> condition.</p>
<p>Now I formalise <code>Group</code> as bundled groups, and endow this with the obvious category structure. I then have isomorphisms in the category <code>Group</code>, but HoTT also gives me transport along paths. These two notions are mathematically the same. How hard is it to derive this in HoTT?</p>

<a name="167961567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167961567" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167961567">Reid Barton (Jun 12 2019 at 16:00)</a>:</h4>
<p>I'm pretty sure the chapter on categories in the hott book discusses this exact issue</p>

<a name="167961811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167961811" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167961811">Reid Barton (Jun 12 2019 at 16:03)</a>:</h4>
<p>This condition that the groupoid of isomorphisms agrees with the homotopy type of the space of objects is something you can write down internally</p>

<a name="167962029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167962029" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167962029">Reid Barton (Jun 12 2019 at 16:04)</a>:</h4>
<p>For Set it is the univalence axiom (for sets)</p>

<a name="167962192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167962192" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167962192">Reid Barton (Jun 12 2019 at 16:05)</a>:</h4>
<p>I forget what the hott book calls it, but it's essentially the "complete" condition of complete Segal spaces</p>

<a name="167962311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167962311" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167962311">Reid Barton (Jun 12 2019 at 16:06)</a>:</h4>
<p>I'm pretty sure the book explains why it is also automatically satisfied for algebraic structures like groups</p>

<a name="167965828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167965828" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167965828">Johan Commelin (Jun 12 2019 at 16:48)</a>:</h4>
<p>Ok, thanks. I should have a look at the HoTT book again.<br>
With "automatically satisfied" you mean that it is <em>true</em>, not that you get the result for free, I guess.</p>

<a name="167966427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167966427" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167966427">Reid Barton (Jun 12 2019 at 16:56)</a>:</h4>
<p>right</p>

<a name="167966437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167966437" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167966437">Reid Barton (Jun 12 2019 at 16:56)</a>:</h4>
<p>but I don't think it should be very hard, and it should be mechanical</p>

<a name="167992116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167992116" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167992116">Scott Morrison (Jun 12 2019 at 21:55)</a>:</h4>
<p>You know that the cool kids these days define a group as a tuple:<br>
<code>(G : Type) (BG : Type) (h : G = \Omega BG)</code> ...</p>

<a name="167992138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/HoTT/near/167992138" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75424HoTT.html#167992138">Scott Morrison (Jun 12 2019 at 21:55)</a>:</h4>
<p>(i.e. it's some type which is the loop space of some other type)</p>


{% endraw %}
