---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/116395maths/24026Categorytheory.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html">Category theory</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="124502143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/124502143" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#124502143">Kenny Lau (Apr 01 2018 at 21:38)</a>:</h4>
<p><a href="https://github.com/kckennylau/category-theory/blob/master/src/adjunction_examples.lean" target="_blank" title="https://github.com/kckennylau/category-theory/blob/master/src/adjunction_examples.lean">https://github.com/kckennylau/category-theory/blob/master/src/adjunction_examples.lean</a></p>

<a name="124520998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/124520998" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#124520998">Kenny Lau (Apr 02 2018 at 10:02)</a>:</h4>
<div class="codehilite"><pre><span></span>@[reducible] def Set.Prod_Hom (B : Type u) : adjunction examples.Set examples.Set :=
adjunction.make _ _
  (examples.Set.product_functor B)
  (examples.Set.Hom_functor_right B)
  (λ A C f x, f x.1 x.2)
  (λ A C f x y, f (x, y))
  (λ A₁ A₂ C₁ C₂ f g t, rfl)
  (λ A₁ A₂ C₁ C₂ f g t, rfl)
  (λ A C f, funext $ λ ⟨t₁, t₂⟩, rfl)
  (λ A C f, rfl)
</pre></div>

<a name="124520999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/124520999" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#124520999">Kenny Lau (Apr 02 2018 at 10:02)</a>:</h4>
<p>so natural</p>

<a name="124521485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/124521485" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#124521485">Kenny Lau (Apr 02 2018 at 10:20)</a>:</h4>
<div class="codehilite"><pre><span></span>@[reducible] def Top_Set : adjunction examples.Top examples.Set :=
adjunction.free_forgetful _
  examples.Top.discrete
  examples.Top.forgetful
  (λ S T f, ⟨f, continuous_top⟩)
  (λ S T f, f.1)
  (λ T₁ T₂ S₁ S₂ f g t z, rfl)
  (λ T₁ T₂ S₁ S₂ f g t, subtype.eq rfl)
  (λ S T f, subtype.eq rfl)
  (λ S T f, rfl)

@[reducible] def Set_Top : adjunction examples.Set examples.Top :=
adjunction.make _ _
  examples.Top.forgetful
  examples.Top.indiscrete
  (λ S T f, f.1)
  (λ S T f, ⟨f, continuous_bot⟩)
  (λ T₁ T₂ S₁ S₂ f g t, subtype.eq rfl)
  (λ T₁ T₂ S₁ S₂ f g t, rfl)
  (λ S T f, rfl)
  (λ S T f, subtype.eq rfl)
</pre></div>

<a name="124521487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/124521487" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#124521487">Kenny Lau (Apr 02 2018 at 10:20)</a>:</h4>
<p>that moment when they're adjoint to each other</p>

<a name="124769998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/124769998" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#124769998">Kenny Lau (Apr 07 2018 at 17:25)</a>:</h4>
<p>for a set S, denoting by L(S) the transitive closure of S, we see that for any transitive set T with S ⊆ T, then L(S) ⊆ T</p>

<a name="124769999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/124769999" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#124769999">Kenny Lau (Apr 07 2018 at 17:25)</a>:</h4>
<p>I wonder if this is the left adjoint of some forgetful functor</p>

<a name="124770041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/124770041" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#124770041">Kenny Lau (Apr 07 2018 at 17:26)</a>:</h4>
<p>well, working in the category of sets with inclusion as morphism, we see that Hom_Trans(L(S),T) = Hom_Set(S,R(T)), where Trans is the category of transitive sets</p>

<a name="124771927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/124771927" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#124771927">Kevin Buzzard (Apr 07 2018 at 18:43)</a>:</h4>
<p>What does this even mean? What is a transitive set?</p>

<a name="124771967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/124771967" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#124771967">Kenny Lau (Apr 07 2018 at 18:44)</a>:</h4>
<p>A set X is transitive if for every x and y such that x∈y∈X, we have x∈X</p>

<a name="124771978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/124771978" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#124771978">Kenny Lau (Apr 07 2018 at 18:45)</a>:</h4>
<p>if the transitive closure is indeed a left adjoint, then we get right-exactness for free</p>

<a name="124772086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/124772086" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#124772086">Kevin Buzzard (Apr 07 2018 at 18:49)</a>:</h4>
<p>Eew. I think I saw that notion in undergraduate set theory nearly 30 years ago, and I'm not sure I've seen it since. Maybe I saw it in the context of ordinals, which is something else I've not seen since.</p>

<a name="124772191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/124772191" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#124772191">Kevin Buzzard (Apr 07 2018 at 18:53)</a>:</h4>
<p>Are you making an assertion here? What is R(T)?</p>

<a name="124772193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/124772193" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#124772193">Kenny Lau (Apr 07 2018 at 18:53)</a>:</h4>
<p>the forgetful functor that forgets the fact that T is transitive</p>

<a name="124772194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/124772194" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#124772194">Kevin Buzzard (Apr 07 2018 at 18:53)</a>:</h4>
<p>Is what you write true?</p>

<a name="124772195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/124772195" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#124772195">Kenny Lau (Apr 07 2018 at 18:53)</a>:</h4>
<p>I believe so</p>

<a name="124772234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/124772234" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#124772234">Kevin Buzzard (Apr 07 2018 at 18:54)</a>:</h4>
<p>If S and T are both transitive, then you're asserting that the transitive maps from S to T are the same as the maps from S to T then?</p>

<a name="124772235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/124772235" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#124772235">Kenny Lau (Apr 07 2018 at 18:54)</a>:</h4>
<p>yes, since here the morphisms are just inclusions, so there is only one morphism per pair of sets</p>

<a name="124772241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/124772241" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#124772241">Kevin Buzzard (Apr 07 2018 at 18:55)</a>:</h4>
<p>What does Hom_Set mean then?</p>

<a name="124772243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/124772243" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#124772243">Kenny Lau (Apr 07 2018 at 18:55)</a>:</h4>
<p>oh, inclusion</p>

<a name="124772287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/124772287" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#124772287">Kevin Buzzard (Apr 07 2018 at 18:57)</a>:</h4>
<p>Do you have a question?</p>

<a name="124772288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/124772288" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#124772288">Kenny Lau (Apr 07 2018 at 18:57)</a>:</h4>
<p>is my belief right</p>

<a name="124772327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/124772327" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#124772327">Kevin Buzzard (Apr 07 2018 at 18:58)</a>:</h4>
<p>What does Hom_Trans mean?</p>

<a name="124772328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/124772328" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#124772328">Kenny Lau (Apr 07 2018 at 18:58)</a>:</h4>
<p>subcategory</p>

<a name="124772329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/124772329" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#124772329">Kevin Buzzard (Apr 07 2018 at 18:58)</a>:</h4>
<p>I don't know what anything means. It feels like you have made these categories up.</p>

<a name="124772331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/124772331" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#124772331">Kevin Buzzard (Apr 07 2018 at 18:59)</a>:</h4>
<p>It also seems that you are just as capable of writing down a proof of your assertion as I am. Why not check it in Lean? ;-)</p>

<a name="124772336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/124772336" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#124772336">Kenny Lau (Apr 07 2018 at 18:59)</a>:</h4>
<p>because to hell with the category of sets in Lean</p>

<a name="124772338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/124772338" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#124772338">Kevin Buzzard (Apr 07 2018 at 18:59)</a>:</h4>
<p>What does Hom_Trans mean?</p>

<a name="124772339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/124772339" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#124772339">Kenny Lau (Apr 07 2018 at 18:59)</a>:</h4>
<p>the inclusion in the category of transitive sets</p>

<a name="124772340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/124772340" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#124772340">Kevin Buzzard (Apr 07 2018 at 18:59)</a>:</h4>
<p>So at most one map between two sets?</p>

<a name="124772378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/124772378" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#124772378">Kenny Lau (Apr 07 2018 at 19:00)</a>:</h4>
<p>yes</p>

<a name="124772387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/124772387" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#124772387">Kevin Buzzard (Apr 07 2018 at 19:00)</a>:</h4>
<p>" we see that for any transitive set T with S ⊆ T, then L(S) ⊆ T ". Is that your question?</p>

<a name="124772388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/124772388" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#124772388">Kenny Lau (Apr 07 2018 at 19:00)</a>:</h4>
<p>well that's the UMP of transitive closure</p>

<a name="124772389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/124772389" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#124772389">Kenny Lau (Apr 07 2018 at 19:00)</a>:</h4>
<p>which should be right</p>

<a name="124772398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/124772398" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#124772398">Kevin Buzzard (Apr 07 2018 at 19:01)</a>:</h4>
<p>But what is your question if it is not precisely that statement?</p>

<a name="124772399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/124772399" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#124772399">Kenny Lau (Apr 07 2018 at 19:01)</a>:</h4>
<p>no idea</p>

<a name="124772400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/124772400" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#124772400">Kevin Buzzard (Apr 07 2018 at 19:01)</a>:</h4>
<p>We might be done then :-)</p>

<a name="124772437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/124772437" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#124772437">Kenny Lau (Apr 07 2018 at 19:02)</a>:</h4>
<p>interesting</p>

<a name="133190899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/133190899" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#133190899">Reid Barton (Sep 01 2018 at 21:06)</a>:</h4>
<p>Scott I guess I'll keep you updated on what I'm doing by sending pastebin links for now.</p>

<a name="133190905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/133190905" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#133190905">Reid Barton (Sep 01 2018 at 21:07)</a>:</h4>
<p><a href="https://pastebin.com/WmdNgPdx" target="_blank" title="https://pastebin.com/WmdNgPdx">https://pastebin.com/WmdNgPdx</a> is limits and colimits in types (nice and easy) and small and filtered categories (also easy).</p>

<a name="133190955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/133190955" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#133190955">Reid Barton (Sep 01 2018 at 21:08)</a>:</h4>
<p>Next I plan to try to show that small limits commute with filtered colimits</p>

<a name="133190963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/133190963" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#133190963">Reid Barton (Sep 01 2018 at 21:08)</a>:</h4>
<p>Probably I won't finish that in the next few days.</p>

<a name="133193621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/133193621" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#133193621">Scott Morrison (Sep 01 2018 at 22:45)</a>:</h4>
<p>Thanks, Reid, that patch has been applied!</p>

<a name="133219652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/133219652" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#133219652">Reid Barton (Sep 02 2018 at 15:54)</a>:</h4>
<p>I defined the limit functor but the proofs aren't as concise as they should be, especially map_id'.<br>
<a href="https://pastebin.com/QDM9H7TX" target="_blank" title="https://pastebin.com/QDM9H7TX">https://pastebin.com/QDM9H7TX</a></p>

<a name="133219672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/133219672" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#133219672">Reid Barton (Sep 02 2018 at 15:55)</a>:</h4>
<p>Scott -- maybe the simp lemmas could be set up so that map_id' can be proved by obviously?<br>
map_comp' is more complicated, since you have to use associativity (backwards)</p>

<a name="133230162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/133230162" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#133230162">Scott Morrison (Sep 02 2018 at 22:10)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span>, in fact I already had this, obscurely hidden in <code>universal/complete/default.lean</code>, with slightly different proofs. I've incorporated some changes from yours, but left my proofs for now. Curiously, <code>obviously</code> does just fine for <code>map_comp'</code>, but fails on <code>map_id'</code> because for some reason <code>simp</code> won't apply <code>limit.lift_π</code>.</p>

<a name="133230214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/133230214" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#133230214">Scott Morrison (Sep 02 2018 at 22:13)</a>:</h4>
<p>I guess it was hiding in that directory because I wrote it for the sake of <a href="https://github.com/semorrison/lean-category-theory/blob/master/src/category_theory/universal/complete/functor_category.lean" target="_blank" title="https://github.com/semorrison/lean-category-theory/blob/master/src/category_theory/universal/complete/functor_category.lean">https://github.com/semorrison/lean-category-theory/blob/master/src/category_theory/universal/complete/functor_category.lean</a>, a still incomplete proof that C \lea D has limits if D does.</p>

<a name="136174097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/136174097" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#136174097">Kenny Lau (Oct 20 2018 at 15:59)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> Will you change some of the mathlib files to use category theory?</p>

<a name="136174143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/136174143" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#136174143">Kenny Lau (Oct 20 2018 at 16:00)</a>:</h4>
<p>what's the plan for category theory?</p>

<a name="136174176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/136174176" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#136174176">Scott Morrison (Oct 20 2018 at 16:00)</a>:</h4>
<p>I think at first, not much. Things like <code>has_products CommRing</code> can first live under <code>category_theory/</code>, as we get used to them.</p>

<a name="136174189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/136174189" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#136174189">Kenny Lau (Oct 20 2018 at 16:01)</a>:</h4>
<p>will they gradually assimilate into the main mathlib library?</p>

<a name="136174190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/136174190" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#136174190">Scott Morrison (Oct 20 2018 at 16:01)</a>:</h4>
<p>Eventually such facts should move out to their natural homes, immediately following where the underlying lemmas are actually proved.</p>

<a name="136174193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/136174193" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#136174193">Kenny Lau (Oct 20 2018 at 16:01)</a>:</h4>
<p>nice</p>

<a name="136174205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/136174205" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#136174205">Scott Morrison (Oct 20 2018 at 16:01)</a>:</h4>
<p>I suspect in the long run a lot of files will want to import <code>category_theory.isomorphism</code>, to avoid having to define their own custom version of <code>equiv</code> for the structure at hand.</p>

<a name="136987135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/136987135" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#136987135">Kenny Lau (Nov 02 2018 at 09:58)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> The new module will be:</p>
<div class="codehilite"><pre><span></span><span class="n">class</span> <span class="n">module</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">out_param</span> <span class="err">$</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">out_param</span> <span class="err">$</span> <span class="n">ring</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">β</span><span class="o">]</span> <span class="kn">extends</span> <span class="n">semimodule</span> <span class="n">α</span> <span class="n">β</span>
</pre></div>


<p>How will your category theory library deal with this?</p>

<a name="136992913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/136992913" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#136992913">Scott Morrison (Nov 02 2018 at 11:02)</a>:</h4>
<p>Mostly users will just want the category of R-modules for some fixed R. After you've fixed the ring this is no more or less scary than bundling any other algebraic typeclass, I think.</p>

<a name="136994837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/136994837" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#136994837">Kenny Lau (Nov 02 2018 at 11:15)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> I don't see how <code>bundle</code> can solve this</p>

<a name="136994962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/136994962" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#136994962">Scott Morrison (Nov 02 2018 at 11:16)</a>:</h4>
<p>Oh, I didn't imply that we should use <code>bundled</code>. It's only intended for the simplest cases.</p>

<a name="136995172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/136995172" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#136995172">Scott Morrison (Nov 02 2018 at 11:18)</a>:</h4>
<p>But <code>structure Module (a : Type) [ring a] := (b : Type) (m : module a b)</code>, is presumably fine.</p>

<a name="136995228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/136995228" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#136995228">Scott Morrison (Nov 02 2018 at 11:18)</a>:</h4>
<p>Maybe you haven't actually said what you're concerned about?</p>

<a name="136995271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/136995271" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#136995271">Kenny Lau (Nov 02 2018 at 11:18)</a>:</h4>
<p>well you forgot the add_comm_group</p>

<a name="136995293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/136995293" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#136995293">Kenny Lau (Nov 02 2018 at 11:18)</a>:</h4>
<p>and actually that's all I'm concerned about</p>

<a name="136995418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/136995418" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#136995418">Scott Morrison (Nov 02 2018 at 11:19)</a>:</h4>
<p>So <code>structure Module (a : Type) [ring a] := (b : Type) (g : add_comm_group b) (m : module a b)</code>...?</p>

<a name="136995910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/136995910" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#136995910">Kenny Lau (Nov 02 2018 at 11:22)</a>:</h4>
<p>I'm not really sure how all of this works, because last time in my own category repo, I was wrestling with sigma</p>

<a name="136996578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/136996578" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#136996578">Scott Morrison (Nov 02 2018 at 11:27)</a>:</h4>
<p>Yeah, I think just building custom structures, and then a few lemmas that peel back out the typeclasses as needed, is easiest.</p>

<a name="136996598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/136996598" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#136996598">Scott Morrison (Nov 02 2018 at 11:27)</a>:</h4>
<p>I'll make a few more examples.</p>

<a name="137000581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137000581" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137000581">Kenny Lau (Nov 02 2018 at 11:55)</a>:</h4>
<p>thanks</p>

<a name="137066926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137066926" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137066926">Kenny Lau (Nov 02 2018 at 16:46)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> is <code>bundled category</code> a category? If not, what's the proper name?</p>

<a name="137078410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137078410" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137078410">Johan Commelin (Nov 02 2018 at 19:54)</a>:</h4>
<p>I have a natural transformation <code>a</code> from <code>F</code> to <code>G</code>, and Lean is looking for a natural transformation from <code>G.op</code> to <code>F.op</code>. So I would like to provide <code>a.op</code> but this is not defined yet. What is the natural place to add this definition? In <code>opposites.lean</code> or in <code>natural_transformation.lean</code>?</p>

<a name="137078733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137078733" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137078733">Reid Barton (Nov 02 2018 at 20:00)</a>:</h4>
<p>I think it makes sense to keep <code>category</code>/<code>functor</code>/<code>natural_transformation</code> "at the bottom" and so put <code>a.op</code> in <code>opposites</code> like <code>F.op</code></p>

<a name="137079047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137079047" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137079047">Johan Commelin (Nov 02 2018 at 20:05)</a>:</h4>
<p>Ok... fine with me. I could also imagine <code>opposites</code> being pretty "fundamental".</p>

<a name="137079230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137079230" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137079230">Kenny Lau (Nov 02 2018 at 20:09)</a>:</h4>
<p>It would be quite interesting if we know that functors form a category but not that categories form a category...</p>

<a name="137079231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137079231" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137079231">Kenny Lau (Nov 02 2018 at 20:09)</a>:</h4>
<p>I've searched all the files</p>

<a name="137079297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137079297" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137079297">Mario Carneiro (Nov 02 2018 at 20:10)</a>:</h4>
<p>the problem is that categories form a 2-category</p>

<a name="137079305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137079305" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137079305">Mario Carneiro (Nov 02 2018 at 20:10)</a>:</h4>
<p>so "categories form a category" is true but mostly useless</p>

<a name="137079310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137079310" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137079310">Reid Barton (Nov 02 2018 at 20:10)</a>:</h4>
<p>Categories also form a perfectly good category, we just don't have it yet</p>

<a name="137079773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137079773" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137079773">Johan Commelin (Nov 02 2018 at 20:19)</a>:</h4>
<p>Ok, I'm testing out a heresy:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">cocone</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">J</span> <span class="err">⥤</span> <span class="n">C</span><span class="o">)</span> <span class="o">:=</span> <span class="n">cone</span> <span class="n">F</span><span class="bp">.</span><span class="n">op</span>
</pre></div>


<p>The first problem I hit is that for <code>c : cocone F</code> the tip of the cocone <code>c.X</code> is now an object of <code>C\op</code> instead of <code>C</code>. Can this somehow be fixed? I would rather just write <code>f : c.X \hom X</code> instead of</p>
<div class="codehilite"><pre><span></span><span class="n">f</span> <span class="o">:</span> <span class="bp">@</span><span class="n">category</span><span class="bp">.</span><span class="n">hom</span> <span class="n">C</span> <span class="bp">_</span> <span class="n">c</span><span class="bp">.</span><span class="n">X</span> <span class="n">X</span>
</pre></div>

<a name="137080246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137080246" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137080246">Reid Barton (Nov 02 2018 at 20:27)</a>:</h4>
<p>I actually have this problem in ordinary informal math as well: it's hard to talk about both C and C^op at the same time.<br>
Sometimes I write things like <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><mi>A</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{A}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8833300000000001em;"></span><span class="strut bottom" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="base"><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathit">A</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span> for the object of C^op corresponding to the object <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">A</span></span></span></span> of C, but I'm not really fond of it.</p>

<a name="137080336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137080336" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137080336">Kenny Lau (Nov 02 2018 at 20:28)</a>:</h4>
<p>"ordinary informal math" = category</p>

<a name="137080436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137080436" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137080436">Johan Commelin (Nov 02 2018 at 20:30)</a>:</h4>
<p>Sure, so we could write <code>X.op</code> for such objects. But this problem is different. With my definition <code>c.X</code> lives in <code>C^op</code> by definition. But I'dd rather have it live in <code>C</code>... And somehow just writing <code>f : (c.X : C) \hom X</code> doesn't cut it....</p>

<a name="137080457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137080457" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137080457">Johan Commelin (Nov 02 2018 at 20:30)</a>:</h4>
<p>Hmmm... I have to run. See y'all later.</p>

<a name="137081858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137081858" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137081858">Reid Barton (Nov 02 2018 at 20:52)</a>:</h4>
<p>Perhaps we could have <code>unop : C\op \to C</code>?</p>

<a name="137082098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137082098" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137082098">Kenny Lau (Nov 02 2018 at 20:56)</a>:</h4>
<p>or maybe an equivalence of categories <code>C\op\op \cong C</code>?</p>

<a name="137083573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137083573" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137083573">Kenny Lau (Nov 02 2018 at 21:22)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">module</span>
<span class="kn">import</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">examples</span><span class="bp">.</span><span class="n">rings</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">opposites</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span>

<span class="n">class</span> <span class="n">Module</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">add_comm_group</span> <span class="n">M</span><span class="o">,</span> <span class="n">module</span> <span class="n">R</span> <span class="n">M</span>

<span class="n">def</span> <span class="n">Module</span><span class="bp">.</span><span class="n">is_linear_map</span> <span class="o">{</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">Module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">Module</span> <span class="n">R</span> <span class="n">N</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">is_linear_map</span> <span class="n">f</span>

<span class="kn">open</span> <span class="n">category_theory</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">examples</span>

<span class="kn">instance</span> <span class="n">Module</span><span class="bp">.</span><span class="n">concrete_category</span> <span class="o">:</span> <span class="n">concrete_category</span> <span class="o">(</span><span class="bp">@</span><span class="n">Module</span><span class="bp">.</span><span class="n">is_linear_map</span> <span class="n">R</span> <span class="bp">_</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="k">by</span> <span class="n">constructor</span><span class="bp">;</span> <span class="n">intros</span><span class="bp">;</span> <span class="n">refl</span><span class="o">,</span>
<span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">hf</span> <span class="n">hg</span><span class="o">,</span> <span class="k">by</span> <span class="n">cases</span> <span class="n">hf</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">hg</span><span class="bp">;</span> <span class="n">constructor</span><span class="bp">;</span> <span class="n">intros</span><span class="bp">;</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[(</span><span class="err">∘</span><span class="o">),</span> <span class="bp">*</span><span class="o">]</span><span class="bp">⟩</span>

<span class="bp">@</span><span class="o">[</span><span class="kn">reducible</span><span class="o">]</span> <span class="n">def</span> <span class="n">Mod</span> <span class="o">:=</span> <span class="n">bundled</span> <span class="o">(</span><span class="n">Module</span> <span class="n">R</span><span class="o">)</span>

<span class="bp">@</span><span class="o">[</span><span class="kn">reducible</span><span class="o">]</span> <span class="n">def</span> <span class="n">Cat</span> <span class="o">:=</span> <span class="n">bundled</span> <span class="n">category</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">category</span> <span class="n">Cat</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">hom</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">C</span> <span class="n">D</span><span class="o">,</span> <span class="bp">@</span><span class="n">category_theory</span><span class="bp">.</span><span class="n">functor</span> <span class="n">C</span><span class="bp">.</span><span class="mi">1</span> <span class="n">C</span><span class="bp">.</span><span class="mi">2</span> <span class="n">D</span><span class="bp">.</span><span class="mi">1</span> <span class="n">D</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
  <span class="n">id</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">C</span><span class="o">,</span> <span class="bp">@</span><span class="n">functor</span><span class="bp">.</span><span class="n">id</span> <span class="n">C</span><span class="bp">.</span><span class="mi">1</span> <span class="n">C</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
  <span class="n">comp</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">C</span> <span class="n">D</span> <span class="n">E</span><span class="o">,</span> <span class="bp">@</span><span class="n">category_theory</span><span class="bp">.</span><span class="n">functor</span><span class="bp">.</span><span class="n">comp</span> <span class="n">C</span><span class="bp">.</span><span class="mi">1</span> <span class="n">C</span><span class="bp">.</span><span class="mi">2</span> <span class="n">D</span><span class="bp">.</span><span class="mi">1</span> <span class="n">D</span><span class="bp">.</span><span class="mi">2</span> <span class="n">E</span><span class="bp">.</span><span class="mi">1</span> <span class="n">E</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
  <span class="n">id_comp&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">C</span> <span class="n">D</span> <span class="n">f</span><span class="o">,</span> <span class="k">by</span> <span class="n">cases</span> <span class="n">f</span><span class="bp">;</span> <span class="n">refl</span><span class="o">,</span>
  <span class="n">comp_id&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">C</span> <span class="n">D</span> <span class="n">f</span><span class="o">,</span> <span class="k">by</span> <span class="n">cases</span> <span class="n">f</span><span class="bp">;</span> <span class="n">refl</span> <span class="o">}</span>

<span class="n">def</span> <span class="n">Mod</span> <span class="o">:</span> <span class="n">Ring</span><span class="err">ᵒᵖ</span> <span class="err">⥤</span> <span class="n">Cat</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">obj</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">R</span><span class="o">,</span> <span class="n">bundled</span><span class="bp">.</span><span class="n">mk</span> <span class="bp">_</span> <span class="o">(</span><span class="n">Mod</span> <span class="n">R</span><span class="bp">.</span><span class="mi">1</span><span class="o">),</span>
  <span class="n">map&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">R</span> <span class="n">S</span> <span class="n">φ</span><span class="o">,</span> <span class="n">concrete_functor</span> <span class="o">(</span><span class="k">begin</span> <span class="kn">end</span><span class="o">)</span> <span class="o">(</span><span class="k">begin</span> <span class="kn">end</span><span class="o">)</span> <span class="o">}</span>
</pre></div>

<a name="137084172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137084172" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137084172">Reid Barton (Nov 02 2018 at 21:34)</a>:</h4>
<p>This looks good, but then the real test is whether it's convenient to use objects of <code>Mod R</code> as modules and vice versa, and the same for <code>Cat</code></p>

<a name="137084272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137084272" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137084272">Reid Barton (Nov 02 2018 at 21:36)</a>:</h4>
<p>At a minimum you want the instance that gets you the <code>Module</code> back out from <code>x : Mod R</code></p>

<a name="137084280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137084280" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137084280">Reid Barton (Nov 02 2018 at 21:37)</a>:</h4>
<p>analogous to <code>instance (x : Ring) : ring x := x.str</code></p>

<a name="137084285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137084285" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137084285">Kenny Lau (Nov 02 2018 at 21:37)</a>:</h4>
<p>that's just interface</p>

<a name="137084287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137084287" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137084287">Kenny Lau (Nov 02 2018 at 21:37)</a>:</h4>
<p>anyone can write an interface</p>

<a name="137084348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137084348" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137084348">Reid Barton (Nov 02 2018 at 21:38)</a>:</h4>
<p>anyone can define <code>Cat</code>, too</p>

<a name="137084357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137084357" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137084357">Reid Barton (Nov 02 2018 at 21:38)</a>:</h4>
<p>Finding a good interface is the important thing</p>

<a name="137084372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137084372" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137084372">Chris Hughes (Nov 02 2018 at 21:38)</a>:</h4>
<p>Interfaces are hard.</p>

<a name="137084448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137084448" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137084448">Kenny Lau (Nov 02 2018 at 21:40)</a>:</h4>
<p>I think <code>opposite</code> can have a better interface</p>

<a name="137087104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137087104" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137087104">Kenny Lau (Nov 02 2018 at 22:36)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> how should we define an additive category?</p>

<a name="137087138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137087138" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137087138">Scott Morrison (Nov 02 2018 at 22:36)</a>:</h4>
<p>ugh, yeah, defining enriched categories may take a lot of work to do in general. :-(</p>

<a name="137087180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137087180" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137087180">Scott Morrison (Nov 02 2018 at 22:37)</a>:</h4>
<p>If you _just_ want additive categories (which is very reasonable, later we can retrofit them as special cases of enriched categories)</p>

<a name="137087225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137087225" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137087225">Scott Morrison (Nov 02 2018 at 22:38)</a>:</h4>
<p>then I don't think it's too bad</p>

<a name="137087236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137087236" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137087236">Kenny Lau (Nov 02 2018 at 22:38)</a>:</h4>
<p>ok, then how?</p>

<a name="137087237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137087237" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137087237">Scott Morrison (Nov 02 2018 at 22:38)</a>:</h4>
<p>Just have a new typeclass <code>[additive_category C]</code>, with fields <code>hom_abelian : add_comm_group (X \hom Y)</code> and <code>comp_bilinear : ...</code></p>

<a name="137087239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137087239" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137087239">Scott Morrison (Nov 02 2018 at 22:39)</a>:</h4>
<p>and then some <code>defs</code> that create instances from these fields</p>

<a name="137087261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137087261" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137087261">Kenny Lau (Nov 02 2018 at 22:39)</a>:</h4>
<p>can we instead declare it as a functor from the Hom category to the Ab category</p>

<a name="137087302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137087302" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137087302">Kenny Lau (Nov 02 2018 at 22:40)</a>:</h4>
<p>such that some triangle commutes</p>

<a name="137087316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137087316" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137087316">Kenny Lau (Nov 02 2018 at 22:40)</a>:</h4>
<p>I guess Hom isn't a category</p>

<a name="137087321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137087321" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137087321">Scott Morrison (Nov 02 2018 at 22:40)</a>:</h4>
<p>yeah, I'm not sure what you mean</p>

<a name="137087339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137087339" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137087339">Kenny Lau (Nov 02 2018 at 22:41)</a>:</h4>
<p>there must be a way to do this category-theoretically...</p>

<a name="137087358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137087358" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137087358">Scott Morrison (Nov 02 2018 at 22:41)</a>:</h4>
<p>Well... I think often it's better to have the definitions "explicit" and then have lemmas saying "you can interpret this in categorical terms"</p>

<a name="137087367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137087367" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137087367">Kenny Lau (Nov 02 2018 at 22:41)</a>:</h4>
<p>sure</p>

<a name="137087368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137087368" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137087368">Scott Morrison (Nov 02 2018 at 22:41)</a>:</h4>
<p>In particular, for monoidal categories (or 2-categories), which I really want to get back to,</p>

<a name="137087421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137087421" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137087421">Scott Morrison (Nov 02 2018 at 22:42)</a>:</h4>
<p>it turns out to be a really bad idea to say that a monoidal category is a category equipped with a functor (C x C) \func C, such that ...</p>

<a name="137087436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137087436" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137087436">Kenny Lau (Nov 02 2018 at 22:42)</a>:</h4>
<p>why isn't Lean ready for a category theory library?</p>

<a name="137087445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137087445" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137087445">Scott Morrison (Nov 02 2018 at 22:42)</a>:</h4>
<p>and instead you should do everything grossly: a function <code>tensorObjects</code>, a function <code>tensorMorphisms</code>, and then have a lemma saying these form that functor</p>

<a name="137087481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137087481" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137087481">Scott Morrison (Nov 02 2018 at 22:43)</a>:</h4>
<p>This sounds like a really bad idea, but the way lean's notation system and elaborator work, you run into endless misery making the functor the "primary" description of the tensor product.</p>

<a name="137087484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137087484" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137087484">Scott Morrison (Nov 02 2018 at 22:43)</a>:</h4>
<p>It's very unfortunate. :-(</p>

<a name="137087555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137087555" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137087555">Scott Morrison (Nov 02 2018 at 22:45)</a>:</h4>
<blockquote>
<p>why isn't Lean ready for a category theory library?</p>
</blockquote>
<p>Speaking to mathematicians, Lean, like every other ITP system, is not ready to do mathematics in. :-)</p>
<p>Lean is terrible, just less terrible than all the others!</p>

<a name="137088959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137088959" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137088959">Reid Barton (Nov 02 2018 at 23:17)</a>:</h4>
<p>I don't know whether this would be easier or harder, but you don't actually need monoidal categories to do enriched categories; you could enrich in a multicategory instead</p>

<a name="137089207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137089207" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137089207">Kevin Buzzard (Nov 02 2018 at 23:23)</a>:</h4>
<p>I've found it quite good fun doing abstract maths in Lean. I've not used categories though. But stuff like commutative algebra seems to come out nicely.</p>

<a name="137089255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137089255" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137089255">Kenny Lau (Nov 02 2018 at 23:24)</a>:</h4>
<p>right, until the module thing came along</p>

<a name="137089369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137089369" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137089369">Chris Hughes (Nov 02 2018 at 23:27)</a>:</h4>
<p>Lean is often good at abstract stuff. I think maybe abstract usually means it has to be done on paper more formally, because there's less real world intuition.</p>

<a name="137103458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137103458" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137103458">Scott Morrison (Nov 03 2018 at 07:16)</a>:</h4>
<blockquote>
<p>But stuff like commutative algebra seems to come out nicely.</p>
</blockquote>
<p>Stockholm syndrome. :-)</p>

<a name="137177771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137177771" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137177771">Reid Barton (Nov 05 2018 at 00:44)</a>:</h4>
<p>Scott, are you attached to the name <code>category_theory.embedding</code>?<br>
How about <code>fully_faithful</code>?</p>

<a name="137177843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137177843" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137177843">Reid Barton (Nov 05 2018 at 00:47)</a>:</h4>
<p><code>embedding</code> is ambiguous, I feel. Someone may think it implies "injective on objects" for example. The nlab gives a variety of definitions.</p>

<a name="137177890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137177890" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137177890">Reid Barton (Nov 05 2018 at 00:48)</a>:</h4>
<p>(Also it collides with the top-level <code>embedding</code> of topological spaces, which is not <code>category_theory</code>'s fault but it did cause some extremely confusing behavior during one of my lean-homotopy-theory mathlib version bumps.)</p>

<a name="137179986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/137179986" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#137179986">Scott Morrison (Nov 05 2018 at 02:00)</a>:</h4>
<p>Yes, we should definitely change this.</p>

<a name="146815330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146815330" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146815330">Johan Commelin (Nov 05 2018 at 18:52)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> Do you have any idea why this would fail?</p>
<div class="codehilite"><pre><span></span><span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="n">class</span> <span class="kn">instance</span> <span class="n">for</span>
<span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₁</span><span class="o">,</span>
<span class="err">𝒳</span> <span class="o">:</span> <span class="n">category</span> <span class="n">X</span><span class="o">,</span>
<span class="n">U</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span>
<span class="n">f</span> <span class="o">:</span> <span class="n">covering_family</span> <span class="n">U</span><span class="o">,</span>
<span class="n">p</span> <span class="o">:</span> <span class="n">f</span><span class="bp">.</span><span class="n">index</span> <span class="bp">×</span> <span class="n">f</span><span class="bp">.</span><span class="n">index</span>
<span class="err">⊢</span> <span class="n">category</span> <span class="o">(</span><span class="n">X</span><span class="err">ᵒᵖ</span> <span class="err">⥤</span> <span class="kt">Type</span> <span class="n">v₁</span><span class="o">)</span>
</pre></div>

<a name="146815457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146815457" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146815457">Scott Morrison (Nov 05 2018 at 18:54)</a>:</h4>
<p>either you're missing the import, or something is weird with universe levels?</p>

<a name="146815502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146815502" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146815502">Johan Commelin (Nov 05 2018 at 18:55)</a>:</h4>
<p>I have</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">presheaf</span> <span class="o">:=</span> <span class="n">X</span><span class="err">ᵒᵖ</span> <span class="err">⥤</span> <span class="n">C</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">X</span><span class="o">}</span> <span class="o">{</span><span class="n">C</span><span class="o">}</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">category</span> <span class="o">(</span><span class="n">presheaf</span> <span class="n">X</span> <span class="n">C</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">unfold</span> <span class="n">presheaf</span><span class="bp">;</span> <span class="n">apply_instance</span>
</pre></div>


<p>in the same file.</p>

<a name="146815626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146815626" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146815626">Scott Morrison (Nov 05 2018 at 18:57)</a>:</h4>
<p>Turn on pp.universes?</p>

<a name="146815660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146815660" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146815660">Johan Commelin (Nov 05 2018 at 18:57)</a>:</h4>
<p>I'll try that. I also see</p>
<div class="codehilite"><pre><span></span>[class_instances] (0) ?x_0 : category (Xᵒᵖ ⥤ Type v₁) := @functor.category ?x_40 ?x_41 ?x_42 ?x_43
failed is_def_eq
</pre></div>


<p>in the trace.</p>

<a name="146815837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146815837" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146815837">Johan Commelin (Nov 05 2018 at 19:00)</a>:</h4>
<p>Ok, that gave me</p>
<div class="codehilite"><pre><span></span><span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="n">class</span> <span class="kn">instance</span> <span class="n">for</span>
<span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₁</span><span class="o">,</span>
<span class="err">𝒳</span> <span class="o">:</span> <span class="n">category</span><span class="bp">.</span><span class="o">{</span><span class="n">u₁</span> <span class="n">v₁</span><span class="o">}</span> <span class="n">X</span><span class="o">,</span>
<span class="n">U</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span>
<span class="n">f</span> <span class="o">:</span> <span class="n">covering_family</span><span class="bp">.</span><span class="o">{</span><span class="n">u₁</span> <span class="n">v₁</span><span class="o">}</span> <span class="n">U</span><span class="o">,</span>
<span class="n">p</span> <span class="o">:</span> <span class="n">f</span><span class="bp">.</span><span class="n">index</span> <span class="bp">×</span> <span class="n">f</span><span class="bp">.</span><span class="n">index</span>
<span class="err">⊢</span> <span class="n">category</span><span class="bp">.</span><span class="o">{(</span><span class="n">max</span> <span class="n">u₁</span> <span class="o">(</span><span class="n">v₁</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="n">v₁</span><span class="o">}</span> <span class="o">(</span><span class="n">X</span><span class="err">ᵒᵖ</span> <span class="err">⥤</span> <span class="kt">Type</span> <span class="n">v₁</span><span class="o">)</span>
</pre></div>

<a name="146815842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146815842" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146815842">Johan Commelin (Nov 05 2018 at 19:00)</a>:</h4>
<p>Maybe I don't understand universes well enough...</p>

<a name="146815850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146815850" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146815850">Johan Commelin (Nov 05 2018 at 19:00)</a>:</h4>
<p>Should that last <code>v_1</code> be a <code>v_1 + 1</code>?</p>

<a name="146815950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146815950" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146815950">Reid Barton (Nov 05 2018 at 19:02)</a>:</h4>
<p>I think it should be <code>max u_1 v_1</code>, if I calculated right</p>

<a name="146815980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146815980" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146815980">Reid Barton (Nov 05 2018 at 19:03)</a>:</h4>
<p>Ah, Scott was kind enough to write out the universe parameters in <code>instance functor.category</code>.</p>

<a name="146815996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146815996" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146815996">Reid Barton (Nov 05 2018 at 19:03)</a>:</h4>
<p>My guess: perhaps you are doing something where you actually need <code>X</code> to be a small category?</p>

<a name="146816055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146816055" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146816055">Reid Barton (Nov 05 2018 at 19:04)</a>:</h4>
<p>it's hard to say what to do without knowing where that goal is coming from</p>

<a name="146816060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146816060" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146816060">Johan Commelin (Nov 05 2018 at 19:04)</a>:</h4>
<p>But in <code>yoneda</code> Scott is doing the same thing as I'm doing. Now I'm really confused.</p>
<div class="codehilite"><pre><span></span><span class="kn">variables</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₁</span><span class="o">)</span> <span class="o">[</span><span class="err">𝒞</span> <span class="o">:</span> <span class="n">category</span><span class="bp">.</span><span class="o">{</span><span class="n">u₁</span> <span class="n">v₁</span><span class="o">}</span> <span class="n">C</span><span class="o">]</span>
<span class="n">include</span> <span class="err">𝒞</span>

<span class="n">def</span> <span class="n">yoneda</span> <span class="o">:</span> <span class="n">C</span> <span class="err">⥤</span> <span class="o">((</span><span class="n">C</span><span class="err">ᵒᵖ</span><span class="o">)</span> <span class="err">⥤</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">v₁</span><span class="o">))</span> <span class="o">:=</span>
</pre></div>

<a name="146816089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146816089" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146816089">Reid Barton (Nov 05 2018 at 19:05)</a>:</h4>
<p>Sure you can write down <code>X\op \func Type v_1</code>, but it might not have <code>v_1</code>-small hom sets.</p>

<a name="146816155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146816155" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146816155">Reid Barton (Nov 05 2018 at 19:06)</a>:</h4>
<p>Which is what your goal is asking for</p>

<a name="146816217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146816217" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146816217">Mario Carneiro (Nov 05 2018 at 19:07)</a>:</h4>
<p>how big are the homsets of the functor category?</p>

<a name="146816296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146816296" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146816296">Scott Morrison (Nov 05 2018 at 19:08)</a>:</h4>
<div class="codehilite"><pre><span></span>variables (C : Type u₁) [𝒞 : category.{u₁ v₁} C] (D : Type u₂) [𝒟 : category.{u₂ v₂} D]
include 𝒞 𝒟

instance functor.category :
  category.{(max u₁ v₁ u₂ v₂) (max u₁ v₂)} (C ⥤ D) :=
</pre></div>

<a name="146816308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146816308" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146816308">Scott Morrison (Nov 05 2018 at 19:08)</a>:</h4>
<p>I wrote the universe levels explicitly in the definition, as documentation for just these moments. :-)</p>

<a name="146816354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146816354" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146816354">Johan Commelin (Nov 05 2018 at 19:09)</a>:</h4>
<p>Thanks! I'm probably dense, but I'm still confused why Scott could write what he wrote for <code>yoneda</code>, and now I want to apply it and Lean complains...</p>

<a name="146816417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146816417" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146816417">Scott Morrison (Nov 05 2018 at 19:10)</a>:</h4>
<p>The danger is always the <code>u1</code> appearing the morphism universe level.</p>

<a name="146816437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146816437" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146816437">Reid Barton (Nov 05 2018 at 19:10)</a>:</h4>
<p>Apply what how? What is the actual math?</p>

<a name="146816449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146816449" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146816449">Scott Morrison (Nov 05 2018 at 19:10)</a>:</h4>
<p>So in Yoneda, we don't care about the universe level of the morphisms in the resulting category.</p>

<a name="146816456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146816456" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146816456">Scott Morrison (Nov 05 2018 at 19:10)</a>:</h4>
<p>But you _do_ care.</p>

<a name="146816472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146816472" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146816472">Scott Morrison (Nov 05 2018 at 19:11)</a>:</h4>
<p>You need a category  <code>category.{(max u₁ (v₁+1)) v₁} (Xᵒᵖ ⥤ Type v₁)</code></p>

<a name="146816490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146816490" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146816490">Johan Commelin (Nov 05 2018 at 19:11)</a>:</h4>
<p>Ooops... I crashed the machine I was logged into...</p>

<a name="146816497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146816497" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146816497">Johan Commelin (Nov 05 2018 at 19:11)</a>:</h4>
<p>I was working on the <code>sheaf</code> branch.</p>

<a name="146816561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146816561" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146816561">Johan Commelin (Nov 05 2018 at 19:12)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/blob/sheaf/category_theory/sheaf.lean#L41" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/sheaf/category_theory/sheaf.lean#L41">https://github.com/leanprover-community/mathlib/blob/sheaf/category_theory/sheaf.lean#L41</a></p>

<a name="146816588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146816588" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146816588">Scott Morrison (Nov 05 2018 at 19:13)</a>:</h4>
<p>But with <code>category.{u1 v1} X</code>, you're going to find <code>Xop \func Type v1</code> only has a category structure with</p>

<a name="146816603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146816603" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146816603">Scott Morrison (Nov 05 2018 at 19:13)</a>:</h4>
<p>objects in universe <code>max u1 (v1+1)</code> (which is fine)</p>

<a name="146816619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146816619" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146816619">Scott Morrison (Nov 05 2018 at 19:13)</a>:</h4>
<p>and morphisms in universe <code>max u1 v1</code></p>

<a name="146816623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146816623" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146816623">Scott Morrison (Nov 05 2018 at 19:14)</a>:</h4>
<p>which breaks your constraint</p>

<a name="146816683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146816683" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146816683">Johan Commelin (Nov 05 2018 at 19:14)</a>:</h4>
<p>I see. So now I should convince Lean that it should be looking for a more relaxed constraint...</p>

<a name="146816844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146816844" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146816844">Johan Commelin (Nov 05 2018 at 19:16)</a>:</h4>
<p>First need to build mathlib on a new machine. (What is the emoji for compiling?)</p>

<a name="146817011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146817011" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146817011">Johan Commelin (Nov 05 2018 at 19:19)</a>:</h4>
<p>I propose <span class="emoji emoji-1f93a" title="fencing">:fencing:</span> for compiling because of <a href="https://www.xkcd.com/303/" target="_blank" title="https://www.xkcd.com/303/">https://www.xkcd.com/303/</a></p>

<a name="146817352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146817352" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146817352">Reid Barton (Nov 05 2018 at 19:24)</a>:</h4>
<p>I guess this is one of the points where one uses universes in a more serious way</p>

<a name="146817488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146817488" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146817488">Mario Carneiro (Nov 05 2018 at 19:26)</a>:</h4>
<p>is this what representable functors are for?</p>

<a name="146817526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146817526" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146817526">Reid Barton (Nov 05 2018 at 19:27)</a>:</h4>
<p>In math one could just pass to a universe in which X is a small category</p>

<a name="146817571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146817571" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146817571">Kevin Buzzard (Nov 05 2018 at 19:27)</a>:</h4>
<blockquote>
<p>is this what representable functors are for?</p>
</blockquote>
<p>They're used in the Fermat's Last Theorem proof to produce rings out of thin air.</p>

<a name="146817863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146817863" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146817863">Reid Barton (Nov 05 2018 at 19:31)</a>:</h4>
<p>I think your options are</p>
<ul>
<li>Assume <code>X</code> is a <code>small_category.{v_1}</code></li>
<li>Have <code>sieve</code> take values in presheaves valued in <code>Type (max u_1 v_1)</code></li>
<li>Redesign limits so that you can talk about the limit of a <code>w</code>-sized diagram in a <code>category.{u v}</code> (but I don't think this sounds like a good idea)</li>
</ul>

<a name="146817945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146817945" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146817945">Reid Barton (Nov 05 2018 at 19:33)</a>:</h4>
<p>The first two are both versions of the math "just pick a universe in which X looks small", and it's a matter of where you want to put that shift of universe</p>

<a name="146817951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146817951" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146817951">Kevin Buzzard (Nov 05 2018 at 19:33)</a>:</h4>
<p>The fpqc topology has some issues with large limits. <span class="user-mention" data-user-id="112680">@Johan Commelin</span> are you planning on writing something sufficently general to deal with the fpqc topology?</p>

<a name="146817961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146817961" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146817961">Johan Commelin (Nov 05 2018 at 19:33)</a>:</h4>
<p>Yes.</p>

<a name="146817974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146817974" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146817974">Johan Commelin (Nov 05 2018 at 19:33)</a>:</h4>
<p>I want to do sheaves in the biggest generality possible.</p>

<a name="146817983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146817983" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146817983">Kevin Buzzard (Nov 05 2018 at 19:33)</a>:</h4>
<p>Conrad would argue that the fpqc topology "does not exist"</p>

<a name="146817984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146817984" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146817984">Johan Commelin (Nov 05 2018 at 19:34)</a>:</h4>
<p>I think I'll go for option 2.</p>

<a name="146817988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146817988" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146817988">Reid Barton (Nov 05 2018 at 19:34)</a>:</h4>
<p>Are they actual issues or just issues for people who don't believe in universes?</p>

<a name="146818048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146818048" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146818048">Kevin Buzzard (Nov 05 2018 at 19:34)</a>:</h4>
<p>I don't fully understand the issues</p>

<a name="146818056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146818056" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146818056">Johan Commelin (Nov 05 2018 at 19:35)</a>:</h4>
<p>I think a little bit of both. You need to do resizing at some point. Like we were discussing <code>kappa</code>-small stuff a while ago.</p>

<a name="146818087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146818087" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146818087">Reid Barton (Nov 05 2018 at 19:35)</a>:</h4>
<p>I think if you express any topology other than the Zariski one naturally in Lean it will have the same issues as the fpqc topology--otherwise you will need to manually replace your category with an essentially equivalent small one</p>

<a name="146818088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146818088" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146818088">Kevin Buzzard (Nov 05 2018 at 19:35)</a>:</h4>
<p>I do understand that the issue with an fpqc cover is that you can't make a set of all fpqc covers</p>

<a name="146818107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146818107" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146818107">Kevin Buzzard (Nov 05 2018 at 19:35)</a>:</h4>
<p>I'm not sure this is accurate Reid</p>

<a name="146818172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146818172" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146818172">Kevin Buzzard (Nov 05 2018 at 19:36)</a>:</h4>
<p>With the etale topology there is in some formal sense not a set of etale covers</p>

<a name="146818174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146818174" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146818174">Kevin Buzzard (Nov 05 2018 at 19:36)</a>:</h4>
<p>but there is a set of etale covers such that every etale cover is isomorphic to a cover in your set</p>

<a name="146818187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146818187" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146818187">Kevin Buzzard (Nov 05 2018 at 19:36)</a>:</h4>
<p>with fpqc the problem is genuinely worse</p>

<a name="146818188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146818188" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146818188">Kevin Buzzard (Nov 05 2018 at 19:36)</a>:</h4>
<p>because an arbitrary morphism of fields is fpqc</p>

<a name="146818203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146818203" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146818203">Kevin Buzzard (Nov 05 2018 at 19:37)</a>:</h4>
<p>so there is not even a set of isomorphism classes of etale covers of spec(field)</p>

<a name="146818256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146818256" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146818256">Kevin Buzzard (Nov 05 2018 at 19:37)</a>:</h4>
<p>I don't know whether thinking about things in a more universey way makes these two problems become the same</p>

<a name="146818305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146818305" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146818305">Kevin Buzzard (Nov 05 2018 at 19:38)</a>:</h4>
<p>but in ZFC I've always had the impression that they were not the same</p>

<a name="146818326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146818326" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146818326">Reid Barton (Nov 05 2018 at 19:38)</a>:</h4>
<p>Right, that is what I mean--you would not be able to define etale covers as just "a scheme with an etale map to X", because that will live in a too large universe--you need to manually replace the category with an equivalent small one with some kind of cardinality argument</p>

<a name="146818343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146818343" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146818343">Kevin Buzzard (Nov 05 2018 at 19:38)</a>:</h4>
<p>right</p>

<a name="146818352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146818352" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146818352">Kevin Buzzard (Nov 05 2018 at 19:38)</a>:</h4>
<p>but you can't do that for fpqc</p>

<a name="146818363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146818363" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146818363">Reid Barton (Nov 05 2018 at 19:38)</a>:</h4>
<p>right</p>

<a name="146818411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146818411" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146818411">Reid Barton (Nov 05 2018 at 19:39)</a>:</h4>
<p>so there are two kinds of issues which could arise then</p>

<a name="146818486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146818486" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146818486">Reid Barton (Nov 05 2018 at 19:40)</a>:</h4>
<p>one is if you don't accept the universe axiom, then you can't talk about such large collections like the category of sheaves for the fpqc topology on X at all</p>

<a name="146818510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146818510" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146818510">Kevin Buzzard (Nov 05 2018 at 19:40)</a>:</h4>
<p>I believe Conrad is strictly ZFC so rejects the fpqc topology</p>

<a name="146818514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146818514" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146818514">Reid Barton (Nov 05 2018 at 19:40)</a>:</h4>
<p>but that's not an issue if you do accept universes</p>

<a name="146818575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146818575" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146818575">Scott Morrison (Nov 05 2018 at 19:41)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> I pushed my (inconclusive) changes to the sheaf branch. Now my dog insists on a walk (in the rain).</p>

<a name="146818580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146818580" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146818580">Reid Barton (Nov 05 2018 at 19:41)</a>:</h4>
<p>but then a second issue which might come up is: you need to take a limit of sets or something, but because the indexing diagram of the limit is large it could take you outside the category you called Set. And that is a real issue even if you believe in universes</p>

<a name="146819009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146819009" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146819009">Johan Commelin (Nov 05 2018 at 19:46)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> Thanks! I'll take a look!</p>

<a name="146819201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146819201" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146819201">Kevin Buzzard (Nov 05 2018 at 19:49)</a>:</h4>
<p>Looking through old emails I've exchanged with Conrad on the fpqc matter, he basically says "fppf is enough for everything, and anyone who wants to work with fpqc -- well, that's their problem, and they can work out the details for themselves"</p>

<a name="146819571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146819571" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146819571">Reid Barton (Nov 05 2018 at 19:54)</a>:</h4>
<p>Another possible approach is <a href="https://ncatlab.org/nlab/show/small+presheaf" target="_blank" title="https://ncatlab.org/nlab/show/small+presheaf">https://ncatlab.org/nlab/show/small+presheaf</a></p>

<a name="146819792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146819792" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146819792">Reid Barton (Nov 05 2018 at 19:57)</a>:</h4>
<p>I think you can also think of this as like Ind, but with no restriction on the indexing diagrams you allow</p>

<a name="146819837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146819837" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146819837">Reid Barton (Nov 05 2018 at 19:58)</a>:</h4>
<p>However I don't know whether this is useful for applications in algebraic geometry</p>

<a name="146819848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146819848" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146819848">Reid Barton (Nov 05 2018 at 19:58)</a>:</h4>
<p><a href="https://ncatlab.org/nlab/show/large+site" target="_blank" title="https://ncatlab.org/nlab/show/large+site">https://ncatlab.org/nlab/show/large+site</a> is a not particularly encouraging page</p>

<a name="146820504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146820504" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146820504">Johan Commelin (Nov 05 2018 at 20:09)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> Hmmzz, I'm not really making any progress...</p>

<a name="146820515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146820515" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146820515">Reid Barton (Nov 05 2018 at 20:09)</a>:</h4>
<p>I expect you will have other problems, too <span class="emoji emoji-1f642" title="slight smile">:slight_smile:</span></p>

<a name="146820521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146820521" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146820521">Johan Commelin (Nov 05 2018 at 20:09)</a>:</h4>
<p>/me is not designed to think about universe issues...</p>

<a name="146820597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146820597" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146820597">Johan Commelin (Nov 05 2018 at 20:10)</a>:</h4>
<p>What do you think is the best solution for now? Making <code>X</code> small?</p>

<a name="146820648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146820648" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146820648">Reid Barton (Nov 05 2018 at 20:11)</a>:</h4>
<p>certainly easiest for the time being</p>

<a name="146820668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146820668" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146820668">Reid Barton (Nov 05 2018 at 20:11)</a>:</h4>
<p>and you don't really lose any generality</p>

<a name="146820672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146820672" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146820672">Johan Commelin (Nov 05 2018 at 20:11)</a>:</h4>
<p>Ok, then I'll leave the headaches for the sheaves refactor that Mario will work on next summer (-;</p>

<a name="146820747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146820747" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146820747">Reid Barton (Nov 05 2018 at 20:12)</a>:</h4>
<p>I think your next problem was going to be: you have some coproducts indexed on a <code>Type v_1</code>, but now the morphism size is <code>max u_1 v_1</code></p>

<a name="146820750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146820750" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146820750">Reid Barton (Nov 05 2018 at 20:12)</a>:</h4>
<p>so you would need to add some <code>ulift</code> to align them</p>

<a name="146821056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146821056" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146821056">Johan Commelin (Nov 05 2018 at 20:17)</a>:</h4>
<p>You're completely right.</p>

<a name="146821111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146821111" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146821111">Johan Commelin (Nov 05 2018 at 20:18)</a>:</h4>
<p>So I want my indexing type to be <em>small</em> small</p>

<a name="146821132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146821132" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146821132">Johan Commelin (Nov 05 2018 at 20:18)</a>:</h4>
<p>In which universe should the indexing type of a covering family live?</p>

<a name="146821143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146821143" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146821143">Johan Commelin (Nov 05 2018 at 20:19)</a>:</h4>
<p><code>max u_1 v_1</code>?</p>

<a name="146821152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146821152" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146821152">Reid Barton (Nov 05 2018 at 20:19)</a>:</h4>
<p>I thought you were going to make X small instead</p>

<a name="146821157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146821157" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146821157">Reid Barton (Nov 05 2018 at 20:19)</a>:</h4>
<p>so u_1 = v_1</p>

<a name="146821163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146821163" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146821163">Reid Barton (Nov 05 2018 at 20:19)</a>:</h4>
<p>if not, then I'm not sure</p>

<a name="146821344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146821344" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146821344">Johan Commelin (Nov 05 2018 at 20:22)</a>:</h4>
<p>Yes, I am going to do that. So then I should just take <code>u_1</code>, right?</p>

<a name="146821455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146821455" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146821455">Reid Barton (Nov 05 2018 at 20:24)</a>:</h4>
<p>Whatever the universe level of X is. It seems we tend to call it <code>v</code> in <code>category_theory</code></p>

<a name="146821697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146821697" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146821697">Reid Barton (Nov 05 2018 at 20:28)</a>:</h4>
<p>Well, or <code>u</code></p>

<a name="146823630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146823630" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146823630">Johan Commelin (Nov 05 2018 at 21:01)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> Wouldn't it be useful to have <code>has_pullbacks_of_has_limits</code> be an instance in general?</p>

<a name="146823698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146823698" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146823698">Scott Morrison (Nov 05 2018 at 21:02)</a>:</h4>
<p>I'm afraid of doing that before we know that the pullbacks thus produced are "nice enough".</p>

<a name="146823713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146823713" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146823713">Johan Commelin (Nov 05 2018 at 21:02)</a>:</h4>
<p>Ok, I see.</p>

<a name="146823719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146823719" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146823719">Scott Morrison (Nov 05 2018 at 21:02)</a>:</h4>
<p>I suspect that you'll only want that instance "in desperation", when you don't have access to a construction of pullbacks that is defeq to something easier to work with than the general limit.</p>

<a name="146823743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146823743" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146823743">Johan Commelin (Nov 05 2018 at 21:03)</a>:</h4>
<p>Hmmm, ok</p>

<a name="146823759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146823759" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146823759">Johan Commelin (Nov 05 2018 at 21:03)</a>:</h4>
<p>So now I've made two small edits to <code>sheaf</code>.</p>

<a name="146823819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146823819" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146823819">Johan Commelin (Nov 05 2018 at 21:04)</a>:</h4>
<p>Do you have a minute to look at the errors that remain? I'm very bad at fighting these universe issues.</p>

<a name="146824066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146824066" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146824066">Scott Morrison (Nov 05 2018 at 21:08)</a>:</h4>
<p>hah, we've been duplicating effort :-)</p>

<a name="146824201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146824201" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146824201">Johan Commelin (Nov 05 2018 at 21:11)</a>:</h4>
<p>Well, I didn't do much...</p>

<a name="146824312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146824312" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146824312">Johan Commelin (Nov 05 2018 at 21:13)</a>:</h4>
<p>Do you think the library is ready for this? Or am I making too big a jump?</p>

<a name="146824367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146824367" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146824367">Scott Morrison (Nov 05 2018 at 21:14)</a>:</h4>
<p>We're almost there. :-)</p>

<a name="146824419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146824419" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146824419">Scott Morrison (Nov 05 2018 at 21:14)</a>:</h4>
<p>And this is exactly the sort of stress testing of limits that we need.</p>

<a name="146824431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146824431" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146824431">Scott Morrison (Nov 05 2018 at 21:14)</a>:</h4>
<p>I committed a little, but it's still badly broken, and I have to get the kids to school/me to work.</p>

<a name="146824449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146824449" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146824449">Johan Commelin (Nov 05 2018 at 21:14)</a>:</h4>
<p>Sure, those are more important than silly sheaves (-;</p>

<a name="146824459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146824459" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146824459">Johan Commelin (Nov 05 2018 at 21:15)</a>:</h4>
<p>See you later</p>

<a name="146824782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146824782" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146824782">Kevin Buzzard (Nov 05 2018 at 21:19)</a>:</h4>
<p>I've just been reading SGA4 in the bath</p>

<a name="146824788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146824788" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146824788">Kevin Buzzard (Nov 05 2018 at 21:19)</a>:</h4>
<p>As you do</p>

<a name="146824860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146824860" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146824860">Kevin Buzzard (Nov 05 2018 at 21:20)</a>:</h4>
<p>And very early on when talking about limits and colimits</p>

<a name="146824888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146824888" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146824888">Kevin Buzzard (Nov 05 2018 at 21:20)</a>:</h4>
<p>They assume that the diagram is u-small</p>

<a name="146824928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146824928" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146824928">Kevin Buzzard (Nov 05 2018 at 21:21)</a>:</h4>
<p>ie isomorphic to an element of the universe u</p>

<a name="146824964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146824964" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146824964">Kevin Buzzard (Nov 05 2018 at 21:21)</a>:</h4>
<p>Their categories are u-categories</p>

<a name="146824981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146824981" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146824981">Kevin Buzzard (Nov 05 2018 at 21:21)</a>:</h4>
<p>Ie hom sets are all in u</p>

<a name="146825039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146825039" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146825039">Kevin Buzzard (Nov 05 2018 at 21:22)</a>:</h4>
<p>But the limits are over u-small diagrams consistently</p>

<a name="146825391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146825391" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146825391">Kevin Buzzard (Nov 05 2018 at 21:28)</a>:</h4>
<p>Example theorem : the category of u-abelian groups has u-limits. This <em>means</em> that you take the category  whose objects are abelian groups in some universe, and then take a limit but only over a category which is itself an <em>element</em> of u</p>

<a name="146825626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146825626" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146825626">Reid Barton (Nov 05 2018 at 21:31)</a>:</h4>
<p>That's essentially our setup too, see <a href="https://github.com/leanprover-community/mathlib/blob/limits-others-new/category_theory/limits/limits.lean#L21-L22" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/limits-others-new/category_theory/limits/limits.lean#L21-L22">https://github.com/leanprover-community/mathlib/blob/limits-others-new/category_theory/limits/limits.lean#L21-L22</a></p>

<a name="146826137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146826137" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146826137">Johan Commelin (Nov 05 2018 at 21:39)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> In things like <code>coequalizer.desc</code> should the argument <code>w</code> get an auto_param <code>obviously</code>?</p>

<a name="146826530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146826530" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146826530">Scott Morrison (Nov 05 2018 at 21:45)</a>:</h4>
<p>Yes, that seems plausible.</p>

<a name="146826939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146826939" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146826939">Johan Commelin (Nov 05 2018 at 21:50)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> I just pushed some more silly stuff. Didn't make fundamental progress.</p>

<a name="146850316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146850316" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146850316">Johan Commelin (Nov 06 2018 at 07:37)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> I don't think <code>functor.const</code> should be in <code>cones</code>. It is more fundamental. Should this be moved to <code>functor</code> or something?</p>

<a name="146851045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/146851045" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#146851045">Scott Morrison (Nov 06 2018 at 07:58)</a>:</h4>
<p>Sounds good.</p>

<a name="147440403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/147440403" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#147440403">Reid Barton (Nov 10 2018 at 17:08)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> did you ever find a setup for typing the functor arrow in emacs?</p>

<a name="147442348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/147442348" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#147442348">Johan Commelin (Nov 10 2018 at 18:04)</a>:</h4>
<p>Nah, haven't looked into it yet. Sorry. Maybe some other emacs user can tell us how to fix this. <span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span> ?</p>

<a name="147442884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/147442884" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#147442884">Gabriel Ebner (Nov 10 2018 at 18:21)</a>:</h4>
<p>The input abbreviations for emacs are defined here: <a href="https://github.com/leanprover/lean-mode/blob/9d6b8471e2044310b4cd7cd3213b1fc8f78ec499/lean-input.el#L407" target="_blank" title="https://github.com/leanprover/lean-mode/blob/9d6b8471e2044310b4cd7cd3213b1fc8f78ec499/lean-input.el#L407">https://github.com/leanprover/lean-mode/blob/9d6b8471e2044310b4cd7cd3213b1fc8f78ec499/lean-input.el#L407</a>  It should be straightforward to submit a PR adding the new arrows (you might also want to add Scott's calligraphic symbols).</p>

<a name="147443005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/147443005" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#147443005">Gabriel Ebner (Nov 10 2018 at 18:25)</a>:</h4>
<p>These are the relevant changes in the vscode extension:<br>
<code>\McB</code>, etc. <a href="https://github.com/leanprover/vscode-lean/commit/46ef6b277f4b90ef440730e3b2f73f9381aa08b0#diff-7c2385f0b8db521fe81e3d20489e5f12" target="_blank" title="https://github.com/leanprover/vscode-lean/commit/46ef6b277f4b90ef440730e3b2f73f9381aa08b0#diff-7c2385f0b8db521fe81e3d20489e5f12">https://github.com/leanprover/vscode-lean/commit/46ef6b277f4b90ef440730e3b2f73f9381aa08b0#diff-7c2385f0b8db521fe81e3d20489e5f12</a><br>
<code>\bbA</code>, etc. <a href="https://github.com/leanprover/vscode-lean/commit/0080ed0f7c80b199abf31212a7eb9356d3cbc896#diff-7c2385f0b8db521fe81e3d20489e5f12" target="_blank" title="https://github.com/leanprover/vscode-lean/commit/0080ed0f7c80b199abf31212a7eb9356d3cbc896#diff-7c2385f0b8db521fe81e3d20489e5f12">https://github.com/leanprover/vscode-lean/commit/0080ed0f7c80b199abf31212a7eb9356d3cbc896#diff-7c2385f0b8db521fe81e3d20489e5f12</a><br>
<code>\functor</code> <a href="https://github.com/leanprover/vscode-lean/commit/d3988d9fae1ab4a7e4785486a08c5eddcd33c575#diff-7c2385f0b8db521fe81e3d20489e5f12" target="_blank" title="https://github.com/leanprover/vscode-lean/commit/d3988d9fae1ab4a7e4785486a08c5eddcd33c575#diff-7c2385f0b8db521fe81e3d20489e5f12">https://github.com/leanprover/vscode-lean/commit/d3988d9fae1ab4a7e4785486a08c5eddcd33c575#diff-7c2385f0b8db521fe81e3d20489e5f12</a></p>

<a name="147443017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/147443017" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#147443017">Gabriel Ebner (Nov 10 2018 at 18:25)</a>:</h4>
<p>In the long term, we might want to have a common source for these abbreviations that is shared by the editor extensions.</p>

<a name="147443021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/147443021" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#147443021">Johan Commelin (Nov 10 2018 at 18:25)</a>:</h4>
<p><span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> Thanks a lot for the links! Once I find some time, I hope to add a PR.</p>

<a name="147739528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/147739528" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#147739528">Johan Commelin (Nov 15 2018 at 13:04)</a>:</h4>
<p>Do we know that composition of functors is associative? I can't find it...</p>

<a name="147739654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/147739654" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#147739654">Reid Barton (Nov 15 2018 at 13:07)</a>:</h4>
<p>I don't think so, but it is true by defeq at least</p>

<a name="147739865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/147739865" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#147739865">Johan Commelin (Nov 15 2018 at 13:11)</a>:</h4>
<p>I see. So I guess this should be added sooner rather than later.</p>

<a name="147768822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/147768822" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#147768822">Scott Morrison (Nov 15 2018 at 19:56)</a>:</h4>
<p>It's in <code>lean-category-theory</code>, under <code>functor_categories/isomorphisms.lean</code>.</p>

<a name="147768830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/147768830" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#147768830">Scott Morrison (Nov 15 2018 at 19:56)</a>:</h4>
<p>At least -- it constructs the equality as a natural isomorphism.</p>

<a name="147768858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/147768858" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#147768858">Scott Morrison (Nov 15 2018 at 19:56)</a>:</h4>
<p>I thought it would be good to also prove the the unitors and associator for functors satisfy the triangles and pentagon equations, but didn't do that.</p>

<a name="147772079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/147772079" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#147772079">Scott Morrison (Nov 15 2018 at 20:45)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span>, it turned out this was easy to do, so there's a new PR adding unitors and associators for functors, as well as checking the pentagon and triangle. (These will be necessary one day when we want an example of a 2-category!)</p>

<a name="147797409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/147797409" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#147797409">Johan Commelin (Nov 16 2018 at 05:35)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> <span class="user-mention" data-user-id="110032">@Reid Barton</span>  I have a question about yoneda. I find the <code>yoneda.lean</code> file a bit confusing. Is there an easy way to extract that <code>F.obj U</code> is canonically the same as <code>yoneda.obj  ⟹ F</code>, where <code>U : X</code> and <code>F : presheaf X</code>? Or is this something that we have to add to this file?</p>

<a name="147797624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/147797624" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#147797624">Reid Barton (Nov 16 2018 at 05:42)</a>:</h4>
<p>In the adjunctions branch I just sort of ignored most of the contents of <code>yoneda.lean</code> and added an <code>equiv</code> which I could actually understand</p>

<a name="147797631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/147797631" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#147797631">Reid Barton (Nov 16 2018 at 05:42)</a>:</h4>
<p>though I feel this approach isn't ideal either</p>

<a name="147802724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/147802724" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#147802724">Johan Commelin (Nov 16 2018 at 08:09)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> I don't think this is in your Yoneda file in an equivalent form, is it?</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">yoneda_sections</span> <span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span>
<span class="o">(</span><span class="n">yoneda</span><span class="bp">.</span><span class="n">obj</span> <span class="n">U</span> <span class="err">⟹</span> <span class="n">F</span><span class="o">)</span> <span class="err">≅</span> <span class="n">F</span><span class="bp">.</span><span class="n">obj</span> <span class="n">U</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">hom</span> <span class="o">:=</span> <span class="k">show</span> <span class="o">(</span><span class="n">yoneda</span><span class="bp">.</span><span class="n">obj</span> <span class="n">U</span> <span class="err">⟹</span> <span class="n">F</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">F</span><span class="bp">.</span><span class="n">obj</span> <span class="n">U</span><span class="o">),</span> <span class="k">from</span> <span class="bp">λ</span> <span class="n">α</span><span class="o">,</span> <span class="n">α</span><span class="bp">.</span><span class="n">app</span> <span class="n">U</span> <span class="o">(</span><span class="mi">𝟙</span> <span class="n">U</span><span class="o">),</span>
  <span class="n">inv</span> <span class="o">:=</span> <span class="k">show</span> <span class="n">F</span><span class="bp">.</span><span class="n">obj</span> <span class="n">U</span> <span class="bp">→</span> <span class="n">yoneda</span><span class="bp">.</span><span class="n">obj</span> <span class="n">U</span> <span class="err">⟹</span> <span class="n">F</span><span class="o">,</span> <span class="k">from</span> <span class="bp">λ</span> <span class="n">s</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">app</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">V</span><span class="o">,</span> <span class="k">show</span> <span class="bp">_</span> <span class="bp">→</span> <span class="n">F</span><span class="bp">.</span><span class="n">obj</span> <span class="n">V</span><span class="o">,</span> <span class="k">from</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">F</span><span class="bp">.</span><span class="n">map</span> <span class="n">i</span> <span class="n">s</span><span class="o">,</span>
    <span class="n">naturality&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">V₁</span> <span class="n">V₂</span> <span class="n">i</span><span class="o">,</span> <span class="k">by</span> <span class="n">tidy</span><span class="bp">;</span> <span class="n">erw</span> <span class="n">F</span><span class="bp">.</span><span class="n">map_comp</span><span class="bp">;</span> <span class="n">tidy</span> <span class="o">},</span>
  <span class="n">hom_inv_id&#39;</span> <span class="o">:=</span>
  <span class="k">begin</span>
    <span class="n">ext</span> <span class="n">α</span> <span class="n">V</span> <span class="n">i</span><span class="o">,</span>
    <span class="n">tidy</span> <span class="o">{</span><span class="n">trace_result</span> <span class="o">:=</span> <span class="n">tt</span><span class="o">},</span>
    <span class="k">have</span> <span class="o">:=</span> <span class="n">congr</span> <span class="o">(</span><span class="n">α</span><span class="bp">.</span><span class="n">naturality</span> <span class="n">i</span><span class="o">),</span>
    <span class="n">dsimp</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">erw</span> <span class="err">←</span><span class="o">(</span><span class="n">this</span> <span class="n">rfl</span><span class="o">),</span>
    <span class="n">simp</span>
  <span class="kn">end</span><span class="o">,</span>
  <span class="n">inv_hom_id&#39;</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">tidy</span><span class="bp">;</span> <span class="n">erw</span> <span class="n">F</span><span class="bp">.</span><span class="n">map_id</span><span class="bp">;</span> <span class="n">tidy</span> <span class="o">}</span>
</pre></div>


<p>That <code>hom_inv_id'</code> is particularly nasty. Would <code>tidy</code> + <code>rewrite_search</code> be able to deal with that?</p>

<a name="147803013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/147803013" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#147803013">Scott Morrison (Nov 16 2018 at 08:16)</a>:</h4>
<p>No, we've already got this. This iso is just a component of the natural isomorphism produced in <code>yoneda_lemma</code>.</p>

<a name="147803015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/147803015" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#147803015">Scott Morrison (Nov 16 2018 at 08:16)</a>:</h4>
<div class="codehilite"><pre><span></span>@[simp] lemma yoneda_sections (X : C) (F : Cᵒᵖ ⥤ Type v₁) : (yoneda.obj X ⟹ F) ≅ ulift.{u₁} (F.obj X) :=
nat_iso.app (yoneda_lemma C) (X, F)
</pre></div>

<a name="147803018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/147803018" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#147803018">Scott Morrison (Nov 16 2018 at 08:16)</a>:</h4>
<p>should do it.</p>

<a name="147803027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/147803027" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#147803027">Scott Morrison (Nov 16 2018 at 08:17)</a>:</h4>
<p>If you're already working in a small category you can remove the <code>ulift</code>.</p>

<a name="147803088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/147803088" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#147803088">Scott Morrison (Nov 16 2018 at 08:18)</a>:</h4>
<p><code>yoneda_lemma</code> is the natural isomorphism between the two functors starting with <code>(X, F)</code>. You can either embed <code>X</code> into presheafs, via the yoneda embedding, and then take hom, or you can just evaluate <code>F</code> on <code>X</code>.</p>

<a name="147803312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/147803312" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#147803312">Scott Morrison (Nov 16 2018 at 08:25)</a>:</h4>
<p>And</p>
<div class="codehilite"><pre><span></span>omit 𝒞
def ulift_trivial (V : Type u₁) : ulift.{u₁} V ≅ V := by tidy

@[simp] def yoneda_sections_small {C : Type u₁} [small_category C] (X : C) (F : Cᵒᵖ ⥤ Type u₁) : (yoneda.obj X ⟹ F) ≅ F.obj X :=
nat_iso.app (yoneda_lemma C) (X, F) ≪≫ ulift_trivial _
</pre></div>


<p>gives you the version you want, for small categories.</p>

<a name="147803314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/147803314" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#147803314">Scott Morrison (Nov 16 2018 at 08:25)</a>:</h4>
<p>Shall I just push this as a separate PR?</p>

<a name="147803361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/147803361" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#147803361">Scott Morrison (Nov 16 2018 at 08:26)</a>:</h4>
<p>Sorry, it was an obvious omission in writing <code>yoneda.lean</code>, just writing out the main result in components.</p>

<a name="147804444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/147804444" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#147804444">Scott Morrison (Nov 16 2018 at 08:53)</a>:</h4>
<p>This is available at <a href="https://github.com/leanprover/mathlib/pull/480" target="_blank" title="https://github.com/leanprover/mathlib/pull/480">https://github.com/leanprover/mathlib/pull/480</a>.</p>

<a name="147804449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/147804449" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#147804449">Scott Morrison (Nov 16 2018 at 08:53)</a>:</h4>
<p>It depends on the limits PR, because it's not worth backporting, but you're welcome to merge into the <code>sheaf</code> branch.</p>

<a name="147827210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/147827210" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#147827210">Johan Commelin (Nov 16 2018 at 16:18)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> Ok cool! I kept on struggling with that product category. But this looks really nice!</p>

<a name="147868545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/147868545" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#147868545">Johan Commelin (Nov 17 2018 at 07:46)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> Is <code>iso_of_is_iso</code> missing in the library?</p>

<a name="147868567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/147868567" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#147868567">Scott Morrison (Nov 17 2018 at 07:46)</a>:</h4>
<p>Yes, lots of iso stuff is missing, that I've just been discovering now. :-)</p>

<a name="147868569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/147868569" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#147868569">Scott Morrison (Nov 17 2018 at 07:46)</a>:</h4>
<p>I've been filling it in the monoidal categories repository, which is where I need it immediately.</p>

<a name="147868576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/147868576" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#147868576">Scott Morrison (Nov 17 2018 at 07:47)</a>:</h4>
<p>Is it holding you up? I can make yet another PR to mathlib with some improvements to the <code>iso</code> and <code>is_iso</code> interface.</p>

<a name="147868625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/147868625" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#147868625">Johan Commelin (Nov 17 2018 at 07:49)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">iso_of_is_iso</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="err">⟶</span> <span class="n">Y</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">is_iso</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="n">X</span> <span class="err">≅</span> <span class="n">Y</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">hom</span> <span class="o">:=</span> <span class="n">f</span><span class="o">,</span>
  <span class="bp">..</span><span class="n">h</span><span class="o">}</span>
</pre></div>


<p>That's whay I have at the top of my file now.</p>

<a name="147868668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/147868668" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#147868668">Scott Morrison (Nov 17 2018 at 07:50)</a>:</h4>
<p>Ok, if that's keeping you afloat for now, I'll finish up a few things before making a "fixing isos" PR. It turns out there are at least a dozen other things missing too. :-)</p>

<a name="147868676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/147868676" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#147868676">Scott Morrison (Nov 17 2018 at 07:51)</a>:</h4>
<p>As I'm sure Mario has told us many times before, you actually have to use this stuff!</p>

<a name="147869737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/147869737" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#147869737">Johan Commelin (Nov 17 2018 at 08:29)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> I just pushed a whole bunch of stuff to the <code>sheaf</code> branch. If you want more data points for how stuff is used...</p>

<a name="147869739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/147869739" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#147869739">Johan Commelin (Nov 17 2018 at 08:29)</a>:</h4>
<p>I'm gathering stuff that should move elsewhere at the top of the file. If it fits into PRs that you are preparing, please take it.</p>

<a name="148077160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148077160" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148077160">David Michael Roberts (Nov 20 2018 at 23:42)</a>:</h4>
<blockquote>
<p>I do understand that the issue with an fpqc cover is that you can't make a set of all fpqc covers</p>
</blockquote>
<p>The issue is that there is not even a set of fpqc covers whose elements refine all possible fpqc covers, whereas for fppf and coarser this is true, even when there's not a set of isomorphism classes of covers. This is a genuine problem, and there is a model of ZF whose category of sets forms a large site with this 'feature' (with covers=surjective functions).</p>

<a name="148077261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148077261" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148077261">David Michael Roberts (Nov 20 2018 at 23:44)</a>:</h4>
<p>One can of course consider whether a given presheaf is a fpqc sheaf or not, but forget trying to fpcq-sheafify in general. The hypotheses of the general adjoint functor theorem are not satisfied, so one cannot construct the left adjoint to Sh_fpqc(Aff) --&gt; PreSh(Aff).</p>

<a name="148639830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148639830" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148639830">Johan Commelin (Nov 27 2018 at 14:10)</a>:</h4>
<p>I currently have</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">map_left_id</span> <span class="o">:</span> <span class="n">map_left</span> <span class="n">R</span> <span class="o">(</span><span class="n">nat_trans</span><span class="bp">.</span><span class="n">id</span> <span class="n">L</span><span class="o">)</span> <span class="err">≅</span> <span class="n">functor</span><span class="bp">.</span><span class="n">id</span> <span class="bp">_</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">hom</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">app</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">X</span><span class="o">,</span> <span class="o">{</span> <span class="n">left</span> <span class="o">:=</span> <span class="mi">𝟙</span> <span class="bp">_</span><span class="o">,</span> <span class="n">right</span> <span class="o">:=</span> <span class="mi">𝟙</span> <span class="bp">_</span> <span class="o">}</span> <span class="o">},</span>
  <span class="n">inv</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">app</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">X</span><span class="o">,</span> <span class="o">{</span> <span class="n">left</span> <span class="o">:=</span> <span class="mi">𝟙</span> <span class="bp">_</span><span class="o">,</span> <span class="n">right</span> <span class="o">:=</span> <span class="mi">𝟙</span> <span class="bp">_</span> <span class="o">}</span> <span class="o">}</span> <span class="o">}</span>
</pre></div>


<p>but that is a worthless simp-lemma because of <code>≅</code>. I think that in fact equality should hold:</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">map_left_id&#39;</span> <span class="o">:</span> <span class="n">map_left</span> <span class="n">R</span> <span class="o">(</span><span class="n">nat_trans</span><span class="bp">.</span><span class="n">id</span> <span class="n">L</span><span class="o">)</span> <span class="bp">=</span> <span class="n">functor</span><span class="bp">.</span><span class="n">id</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>


<p>But I have no idea how to prove that two terms of a structure are equal. Is it true that they are equal if all their fields are equal? Is this somewhere in mathlib?</p>

<a name="148640013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148640013" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148640013">Reid Barton (Nov 27 2018 at 14:13)</a>:</h4>
<p>This is generally what extensionality lemmas do... but you're probably going to have a bad time working with equality of functors</p>

<a name="148640081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148640081" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148640081">Reid Barton (Nov 27 2018 at 14:14)</a>:</h4>
<p>what's <code>map_left</code>?</p>

<a name="148640129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148640129" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148640129">Reid Barton (Nov 27 2018 at 14:15)</a>:</h4>
<p>Never mind, I figured it out from one of your other messages</p>

<a name="148640189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148640189" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148640189">Patrick Massot (Nov 27 2018 at 14:16)</a>:</h4>
<p>Not sure it will help, but your question looks like the classic:</p>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">johan</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">aone</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span>

<span class="kn">lemma</span> <span class="n">johan</span><span class="bp">.</span><span class="n">ext</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">johan</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">X</span><span class="bp">.</span><span class="n">a</span> <span class="bp">=</span> <span class="n">Y</span><span class="bp">.</span><span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">Y</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">cases</span> <span class="n">X</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">Y</span><span class="o">,</span>
  <span class="n">congr</span> <span class="bp">;</span> <span class="n">assumption</span>
<span class="kn">end</span>
</pre></div>

<a name="148640204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148640204" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148640204">Patrick Massot (Nov 27 2018 at 14:17)</a>:</h4>
<p>sorry about the silly example, but I wanted a structure including at least one data and one proof field</p>

<a name="148640336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148640336" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148640336">Johan Commelin (Nov 27 2018 at 14:19)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> Thanks, I should have thought about <code>cases</code>.</p>

<a name="148640349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148640349" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148640349">Reid Barton (Nov 27 2018 at 14:19)</a>:</h4>
<p>I think what you have now is the best way</p>

<a name="148640352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148640352" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148640352">Johan Commelin (Nov 27 2018 at 14:19)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> Well, but working with natural isomorphisms is also a massive pain atm.</p>

<a name="148640456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148640456" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148640456">Reid Barton (Nov 27 2018 at 14:21)</a>:</h4>
<p>I guarantee it is not as bad as rewriting morphisms across equalities of objects and then trying to reason about the result</p>

<a name="148640556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148640556" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148640556">Patrick Massot (Nov 27 2018 at 14:23)</a>:</h4>
<p>We should really setup a FAQ somewhere</p>

<a name="148662831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148662831" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148662831">Johan Commelin (Nov 27 2018 at 19:48)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> I have no idea if this makes any sense, but I regularly get errors like these:</p>
<div class="codehilite"><pre><span></span><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">colimit</span><span class="bp">.</span><span class="n">pre_map</span> <span class="o">(</span><span class="n">comma</span><span class="bp">.</span><span class="n">fst</span> <span class="n">yoneda</span> <span class="o">(</span><span class="n">functor</span><span class="bp">.</span><span class="n">of_obj</span> <span class="n">X</span><span class="o">)</span> <span class="err">⋙</span> <span class="n">F</span><span class="o">)</span> <span class="o">((</span><span class="n">comma</span><span class="bp">.</span><span class="n">map_right_id&#39;</span> <span class="n">yoneda</span> <span class="o">(</span><span class="n">functor</span><span class="bp">.</span><span class="n">of_obj</span> <span class="n">X</span><span class="o">))</span><span class="bp">.</span><span class="n">hom</span><span class="o">)</span>
<span class="n">term</span>
  <span class="o">(</span><span class="n">comma</span><span class="bp">.</span><span class="n">map_right_id&#39;</span> <span class="n">yoneda</span> <span class="o">(</span><span class="n">functor</span><span class="bp">.</span><span class="n">of_obj</span> <span class="n">X</span><span class="o">))</span><span class="bp">.</span><span class="n">hom</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="n">comma</span><span class="bp">.</span><span class="n">map_right</span> <span class="n">yoneda</span> <span class="o">(</span><span class="mi">𝟙</span> <span class="o">(</span><span class="n">functor</span><span class="bp">.</span><span class="n">of_obj</span> <span class="n">X</span><span class="o">))</span> <span class="err">⟶</span> <span class="n">functor</span><span class="bp">.</span><span class="n">id</span> <span class="o">(</span><span class="n">comma</span> <span class="n">yoneda</span> <span class="o">(</span><span class="n">functor</span><span class="bp">.</span><span class="n">of_obj</span> <span class="n">X</span><span class="o">))</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span>
        <span class="o">(</span><span class="n">max</span> <span class="err">?</span> <span class="n">v</span><span class="o">)</span>
        <span class="n">v</span>
        <span class="err">?</span><span class="o">)</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="err">?</span><span class="n">m_3</span> <span class="err">⟹</span> <span class="err">?</span><span class="n">m_4</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span>
</pre></div>


<p>Would it help to just get rid of the notation <code>⟹</code>, and always speak of natural transformations as homs in the functor category?</p>

<a name="148662863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148662863" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148662863">Johan Commelin (Nov 27 2018 at 19:48)</a>:</h4>
<p>Or is this a stupid universe issue again? (I just realise there are annoying <code>?</code> in the error...)</p>

<a name="148662980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148662980" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148662980">Johan Commelin (Nov 27 2018 at 19:50)</a>:</h4>
<p>Ok, never mind. It's a universe issue.</p>

<a name="148664964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148664964" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148664964">Kenny Lau (Nov 27 2018 at 20:20)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> how do you get that many colours</p>

<a name="148665094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148665094" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148665094">Johan Commelin (Nov 27 2018 at 20:22)</a>:</h4>
<p>I had <code>less</code> syntax, instead of <code>lean</code> <span class="emoji emoji-1f643" title="upside down">:upside_down:</span> <span class="user-mention" data-user-id="110064">@Kenny Lau</span></p>

<a name="148666324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148666324" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148666324">Scott Morrison (Nov 27 2018 at 20:40)</a>:</h4>
<blockquote>
<p>I guarantee it is not as bad as rewriting morphisms across equalities of objects and then trying to reason about the result</p>
</blockquote>
<p>Yes. This. Please don't prove equalities between functors, you are just setting yourself up for suffering.</p>

<a name="148670683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148670683" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148670683">Reid Barton (Nov 27 2018 at 21:50)</a>:</h4>
<blockquote>
<p>Would it help to just get rid of the notation <code>⟹</code>, and always speak of natural transformations as homs in the functor category?</p>
</blockquote>
<p>I have actually wondered about this too, after a few minor annoyances involving the difference between <code>nat_trans.vcomp</code> and <code>category.comp</code>.</p>

<a name="148670713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148670713" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148670713">Reid Barton (Nov 27 2018 at 21:50)</a>:</h4>
<p>It's hard to predict which one you will get once you start talking about colimits in categories of presheaves, as Johan has probably also experienced.</p>

<a name="148671054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148671054" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148671054">Reid Barton (Nov 27 2018 at 21:57)</a>:</h4>
<p>It might be a rather invasive change though, or even not workable for some reason</p>

<a name="148673378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148673378" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148673378">Scott Morrison (Nov 27 2018 at 22:33)</a>:</h4>
<p>I've experienced the same pain, but haven't tried removing <code>⟹</code>. It seems a reasonable experiment, however.</p>

<a name="148696347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148696347" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148696347">Johan Commelin (Nov 28 2018 at 08:12)</a>:</h4>
<p>I don't like the idea of setting myself up for suffering.</p>

<a name="148696378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148696378" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148696378">Johan Commelin (Nov 28 2018 at 08:12)</a>:</h4>
<p>But I'm suffering hard at the moment.</p>

<a name="148696393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148696393" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148696393">Johan Commelin (Nov 28 2018 at 08:13)</a>:</h4>
<p>After all <code>functor.id ⋙ F</code> is not defeq to <code>F</code>, and so we need some natural isomorphisms, and I just get the general feeling that we are walking headfirst into nasty 2-categorical territory.</p>

<a name="148696399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148696399" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148696399">Johan Commelin (Nov 28 2018 at 08:14)</a>:</h4>
<p>Because, say what you like, but Lean isn't very good at working with the canonical natural isomorphism between <code>functor.id ⋙ F</code> and <code>F</code>.</p>

<a name="148696451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148696451" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148696451">Johan Commelin (Nov 28 2018 at 08:15)</a>:</h4>
<p>I've got the following context:</p>
<div class="codehilite"><pre><span></span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">,</span>
<span class="err">𝒞</span> <span class="o">:</span> <span class="n">small_category</span> <span class="n">C</span><span class="o">,</span>
<span class="n">D</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">,</span>
<span class="err">𝒟</span> <span class="o">:</span> <span class="n">category</span> <span class="n">D</span><span class="o">,</span>
<span class="n">F</span> <span class="o">:</span> <span class="n">C</span> <span class="err">⥤</span> <span class="n">D</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_1</span> <span class="o">:</span> <span class="n">has_colimits</span> <span class="n">D</span><span class="o">,</span>
<span class="n">X</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">C</span>
<span class="err">⊢</span> <span class="n">colimit</span><span class="bp">.</span><span class="n">pre</span> <span class="o">(</span><span class="n">comma</span><span class="bp">.</span><span class="n">fst</span> <span class="n">yoneda</span> <span class="o">(</span><span class="n">functor</span><span class="bp">.</span><span class="n">of_obj</span> <span class="n">X</span><span class="o">)</span> <span class="err">⋙</span> <span class="n">F</span><span class="o">)</span> <span class="o">(</span><span class="n">comma</span><span class="bp">.</span><span class="n">map_right</span> <span class="n">yoneda</span> <span class="o">(</span><span class="mi">𝟙</span> <span class="o">(</span><span class="n">functor</span><span class="bp">.</span><span class="n">of_obj</span> <span class="n">X</span><span class="o">)))</span> <span class="bp">=</span>
    <span class="mi">𝟙</span> <span class="o">(</span><span class="n">colimit</span> <span class="o">(</span><span class="n">comma</span><span class="bp">.</span><span class="n">fst</span> <span class="n">yoneda</span> <span class="o">(</span><span class="n">functor</span><span class="bp">.</span><span class="n">of_obj</span> <span class="n">X</span><span class="o">)</span> <span class="err">⋙</span> <span class="n">F</span><span class="o">))</span>
</pre></div>


<p>This might look a bit daunting, but <code>(comma.map_right yoneda (𝟙 (functor.of_obj X)))</code> is naturally isomorphic to <code>functor.id _</code></p>

<a name="148696511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148696511" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148696511">Johan Commelin (Nov 28 2018 at 08:16)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> I'm really lost here. The maths is trivial. But Lean is fighting back hard.</p>

<a name="148696896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148696896" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148696896">Scott Morrison (Nov 28 2018 at 08:27)</a>:</h4>
<p>Want to point me to a file and a commit?</p>

<a name="148697034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148697034" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148697034">Johan Commelin (Nov 28 2018 at 08:30)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> <a href="https://github.com/leanprover-community/mathlib/blob/sheaf/category_theory/presheaf.lean#L69" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/sheaf/category_theory/presheaf.lean#L69">https://github.com/leanprover-community/mathlib/blob/sheaf/category_theory/presheaf.lean#L69</a></p>

<a name="148697048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148697048" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148697048">Johan Commelin (Nov 28 2018 at 08:31)</a>:</h4>
<p>Maybe I still don't know how to let the library do the heavy lifting for me...</p>

<a name="148697316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148697316" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148697316">Scott Morrison (Nov 28 2018 at 08:38)</a>:</h4>
<p>woah, checking out that branch is like stepping into the future. adjunctions, cocompletions, groupoids, oh my.</p>

<a name="148697393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148697393" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148697393">Johan Commelin (Nov 28 2018 at 08:40)</a>:</h4>
<p>Well, most of that is by Reid.</p>

<a name="148697415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148697415" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148697415">Johan Commelin (Nov 28 2018 at 08:41)</a>:</h4>
<p>Or I should say: all of <em>that</em> is by Reid.</p>

<a name="148697497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148697497" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148697497">Scott Morrison (Nov 28 2018 at 08:43)</a>:</h4>
<p>Can we not call functors <code>f</code>, when they could perfectly well be <code>F</code>?</p>

<a name="148697542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148697542" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148697542">Scott Morrison (Nov 28 2018 at 08:44)</a>:</h4>
<p>Also, I feel you're slightly overusing variables. Things like <code>map</code> and <code>map'</code> should have the variable <code>F : C \func D</code> visible right there at the definition.</p>

<a name="148697554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148697554" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148697554">Scott Morrison (Nov 28 2018 at 08:45)</a>:</h4>
<p>variables are great for implicit arguments, or even the primary argument if they are the sole primary argument for 20 definitions in a row...</p>

<a name="148697568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148697568" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148697568">Johan Commelin (Nov 28 2018 at 08:45)</a>:</h4>
<p>Sure. I was using <code>F</code> for presheaves, but I decided that maybe I shouldn't yet do that.</p>

<a name="148697647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148697647" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148697647">Johan Commelin (Nov 28 2018 at 08:47)</a>:</h4>
<p>Anyway, you shouldn't look too much at the <code>sheaf.lean</code> file. It will need a major rewrite once I have working presheaves.</p>

<a name="148697740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148697740" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148697740">Scott Morrison (Nov 28 2018 at 08:49)</a>:</h4>
<p>Lots of stuff doesn't compile?</p>

<a name="148697742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148697742" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148697742">Scott Morrison (Nov 28 2018 at 08:49)</a>:</h4>
<p>In the imports of presheaf.lean</p>

<a name="148697786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148697786" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148697786">Johan Commelin (Nov 28 2018 at 08:50)</a>:</h4>
<p>Hmmm... I thought those were fine... but maybe stuff broke.</p>

<a name="148697789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148697789" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148697789">Scott Morrison (Nov 28 2018 at 08:50)</a>:</h4>
<p>e.g. limits/limits.lean and adjunctions.lean</p>

<a name="148697815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148697815" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148697815">Johan Commelin (Nov 28 2018 at 08:51)</a>:</h4>
<p>adjunctions probably don't compile</p>

<a name="148697822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148697822" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148697822">Johan Commelin (Nov 28 2018 at 08:51)</a>:</h4>
<p>limits should work, but maybe it broke after I merged in Reid's branch</p>

<a name="148697824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148697824" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148697824">Scott Morrison (Nov 28 2018 at 08:51)</a>:</h4>
<p>Ok, I see the thing you probably need, which is naturality in the second argument of colimit.pre</p>

<a name="148697831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148697831" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148697831">Scott Morrison (Nov 28 2018 at 08:51)</a>:</h4>
<p>I can try to provide you that, and you can try to get stuff to compile :-)</p>

<a name="148697896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148697896" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148697896">Johan Commelin (Nov 28 2018 at 08:53)</a>:</h4>
<p>Ok, so I have <code>colimit.pre_map</code></p>

<a name="148697904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148697904" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148697904">Scott Morrison (Nov 28 2018 at 08:53)</a>:</h4>
<p>yes, but that's naturality in the first argument, which isn't what you need</p>

<a name="148697907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148697907" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148697907">Johan Commelin (Nov 28 2018 at 08:53)</a>:</h4>
<p>But I guess we need to upgrade <code>pre</code> into a functor?</p>

<a name="148697911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148697911" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148697911">Scott Morrison (Nov 28 2018 at 08:53)</a>:</h4>
<p>unfortunately I think that might need to wait for 2-categories, I'm not sure. :-)</p>

<a name="148697919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148697919" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148697919">Johan Commelin (Nov 28 2018 at 08:54)</a>:</h4>
<p>Right... but it is where this stuff is sucking us into, not?</p>

<a name="148697960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148697960" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148697960">Scott Morrison (Nov 28 2018 at 08:54)</a>:</h4>
<p>I'm actually not sure where I should do this work. The main <code>limits</code> branch is now a bit stranded, as Reid has been pulling stuff out into separate PRs.</p>

<a name="148697966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148697966" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148697966">Scott Morrison (Nov 28 2018 at 08:54)</a>:</h4>
<p>Doing work on the limits branch now may get orphaned, I'm not sure.</p>

<a name="148697980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148697980" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148697980">Johan Commelin (Nov 28 2018 at 08:54)</a>:</h4>
<p>Maybe dump it into <code>sheafy_preamble</code></p>

<a name="148697995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148697995" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148697995">Johan Commelin (Nov 28 2018 at 08:55)</a>:</h4>
<p>I've been using that file to collect all sorts of facts that I need.</p>

<a name="148698006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148698006" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148698006">Scott Morrison (Nov 28 2018 at 08:56)</a>:</h4>
<p>Yeah, I'm worried about that getting orphaned too. :-)</p>

<a name="148698050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148698050" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148698050">Scott Morrison (Nov 28 2018 at 08:56)</a>:</h4>
<p>We're playing a bit fast and loose with our branches at the moment.</p>

<a name="148698056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148698056" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148698056">Johan Commelin (Nov 28 2018 at 08:56)</a>:</h4>
<p>Very much.</p>

<a name="148698093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148698093" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148698093">Johan Commelin (Nov 28 2018 at 08:57)</a>:</h4>
<p>So what exactly is the statement that you are trying to prove?</p>

<a name="148698100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148698100" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148698100">Scott Morrison (Nov 28 2018 at 08:57)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span>, I'd really like to straighten out the limits branches a bit. What is the best way to "rebase" (possibly by hand) everything remaining on top of <code>limits-2</code>? Is this a bad thing to want to do?</p>

<a name="148698145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148698145" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148698145">Scott Morrison (Nov 28 2018 at 08:58)</a>:</h4>
<p>No idea :-) I hadn't even started.</p>

<a name="148698181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148698181" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148698181">Scott Morrison (Nov 28 2018 at 08:59)</a>:</h4>
<p>Say we have a natural transformation a : E \natt E'.</p>

<a name="148698235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148698235" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148698235">Scott Morrison (Nov 28 2018 at 09:00)</a>:</h4>
<p>colim.map (a &gt;&gt;&gt; F) gives a map from colim (E &gt;&gt;&gt; F) to colim (E' &gt;&gt;&gt; F)</p>

<a name="148698250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148698250" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148698250">Scott Morrison (Nov 28 2018 at 09:00)</a>:</h4>
<p>presumably the triangle, obtained by mapping both of those to colim F via colim.pre, commutes?</p>

<a name="148698274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148698274" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148698274">Scott Morrison (Nov 28 2018 at 09:01)</a>:</h4>
<p>So then if a is invertible, we have <code>colim.pre F E = colim.map (a^{-1} &gt;&gt;&gt; F) &gt;&gt; colim.pre F E' &gt;&gt; colim.map (a &gt;&gt;&gt; F)</code>.</p>

<a name="148698318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148698318" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148698318">Scott Morrison (Nov 28 2018 at 09:02)</a>:</h4>
<p>and hopefully now if E' is the identity, as in your case, everything quickly simplifies from there</p>

<a name="148698343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148698343" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148698343">Johan Commelin (Nov 28 2018 at 09:03)</a>:</h4>
<p>So <code>pre_map</code> is saying that this triangle commutes.</p>

<a name="148698410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148698410" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148698410">Scott Morrison (Nov 28 2018 at 09:04)</a>:</h4>
<p>No. <code>pre_map</code> is about changing the functor <code>F</code>, not the functor <code>E</code>.</p>

<a name="148698416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148698416" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148698416">Johan Commelin (Nov 28 2018 at 09:04)</a>:</h4>
<p>But if <code>E' = functor.id _</code> it still doesn't simplify, because <code>functor.id _ &gt;&gt;&gt; F</code> is not <code>F</code>. For example <code>colimit.pre F (functor.id _) = \b1 (colimit F)</code> does not typecheck <span class="emoji emoji-2639" title="sad">:sad:</span></p>

<a name="148698417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148698417" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148698417">Scott Morrison (Nov 28 2018 at 09:04)</a>:</h4>
<p>I've just been looking at the history of the <code>sheaf</code> branch.</p>

<a name="148698433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148698433" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148698433">Johan Commelin (Nov 28 2018 at 09:05)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> I think you are confusing <code>map_pre</code> and <code>pre_map</code>.</p>

<a name="148698437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148698437" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148698437">Scott Morrison (Nov 28 2018 at 09:05)</a>:</h4>
<p>And ... you're up shit creek without a paddle. :-)</p>

<a name="148698441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148698441" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148698441">Johan Commelin (Nov 28 2018 at 09:05)</a>:</h4>
<p><code>pre_map</code> is something I added. It is in <code>sheafy_preamble.lean</code></p>

<a name="148698445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148698445" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148698445">Scott Morrison (Nov 28 2018 at 09:05)</a>:</h4>
<p>Getting <code>sheaf</code> back on top of master after <code>limits-2</code> is merged is going to suck.</p>

<a name="148698488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148698488" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148698488">Johan Commelin (Nov 28 2018 at 09:06)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> I will probably just copy-paste stuff into a new branch...</p>

<a name="148698489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148698489" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148698489">Scott Morrison (Nov 28 2018 at 09:06)</a>:</h4>
<p>I'm looking at</p>
<div class="codehilite"><pre><span></span>lemma colimit.pre_map {K : Type v} [small_category K] [has_colimits_of_shape K C] (E : K ⥤ J) :
  colimit.pre F E ≫ colim.map α = colim.map (whisker_left E α) ≫ colimit.pre G E :=
by ext; rw [←assoc, colimit.ι_pre, colim.ι_map, ←assoc, colim.ι_map, assoc, colimit.ι_pre]; refl
</pre></div>


<p>in <code>limits-2</code>.</p>

<a name="148698507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148698507" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148698507">Scott Morrison (Nov 28 2018 at 09:07)</a>:</h4>
<p>I see. But yes, your <code>pre_map</code> is what we need. :-)</p>

<a name="148698523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148698523" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148698523">Johan Commelin (Nov 28 2018 at 09:07)</a>:</h4>
<p>Aaahrg... so the names have changed...</p>

<a name="148698565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148698565" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148698565">Johan Commelin (Nov 28 2018 at 09:08)</a>:</h4>
<p>What is called <code>pre_map</code> in <code>limits-2</code> used to be <code>map_pre</code> on your old limits branch.</p>

<a name="148698572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148698572" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148698572">Johan Commelin (Nov 28 2018 at 09:08)</a>:</h4>
<p>Ok, so in <code>presheaf.lean</code> you can see that I already <code>erw</code>d the <code>pre_map</code>-thingy.</p>

<a name="148698574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148698574" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148698574">Scott Morrison (Nov 28 2018 at 09:08)</a>:</h4>
<p>I see. :-) Reid must have fixed it. :-) As I said, up a creek! :-)</p>

<a name="148698581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148698581" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148698581">Scott Morrison (Nov 28 2018 at 09:08)</a>:</h4>
<p>Well, I can't see that, because nothing compiles. :-)</p>

<a name="148698603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148698603" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148698603">Scott Morrison (Nov 28 2018 at 09:09)</a>:</h4>
<p>So, you need to keep the <code>colim.map</code> in there for the unitor.</p>

<a name="148698613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148698613" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148698613">Johan Commelin (Nov 28 2018 at 09:09)</a>:</h4>
<p>Sorry, I need to run to a seminar...</p>

<a name="148698663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148698663" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148698663">Johan Commelin (Nov 28 2018 at 09:10)</a>:</h4>
<p>And I'm sorry that stuff doens't compile. I still have some sort of interactive VScode when I work on this...</p>

<a name="148698669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148698669" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148698669">Johan Commelin (Nov 28 2018 at 09:10)</a>:</h4>
<p>Maybe I should just wait till limits are merged, and then start from scratch.</p>

<a name="148698678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148698678" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148698678">Scott Morrison (Nov 28 2018 at 09:10)</a>:</h4>
<p>You just want to know that</p>
<div class="codehilite"><pre><span></span>colimit.pre F (functor.id _) = colimit.map (left_unitor F)
</pre></div>


<p>(that's not meant to be real code).</p>

<a name="148698746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148698746" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148698746">Scott Morrison (Nov 28 2018 at 09:12)</a>:</h4>
<p>Okay, in any case, keep bugging me about this. I'd both like to help, and like to see the resolution. I think it's going to be fine. :-)</p>

<a name="148704306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148704306" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148704306">Johan Commelin (Nov 28 2018 at 11:06)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> Thanks for all your comments. I'll see if I can make any progress.</p>

<a name="148708825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148708825" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148708825">Reid Barton (Nov 28 2018 at 12:46)</a>:</h4>
<p>Oh yeah, I noticed all the <code>limit.</code> lemmas had names of the form <code>limit.foo_bar</code> if the left-hand side looked like <code>limit.foo ... &gt;&gt; limit.bar ...</code>, and so I reversed the components of all the names of the corresponding <code>colimit</code> lemmas because they have the composition on the left-hand side in the other order.</p>

<a name="148708855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148708855" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148708855">Reid Barton (Nov 28 2018 at 12:47)</a>:</h4>
<p>Actually I just copied and pasted the limit lemmas to make colimit versions, I ignored whatever was there before (which I think was not a full set of matching lemmas)</p>

<a name="148709058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148709058" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148709058">Johan Commelin (Nov 28 2018 at 12:51)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> I fixed a bunch of compile issues, which we due to <code>functor.const</code> being picked from the wrong namespace (even though <code>category_theory</code> seems to be open). I really hope Lean 4 will kick a lot of these things out of the root namespace, because these conflicts are quite annoying.</p>

<a name="148709086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148709086" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148709086">Reid Barton (Nov 28 2018 at 12:52)</a>:</h4>
<p>Yeah I encountered that same <code>functor.const</code> issue too, not sure what caused it to crop up suddenly</p>

<a name="148709263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148709263" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148709263">Keeley Hoek (Nov 28 2018 at 12:55)</a>:</h4>
<p>Does @[priority] affect that kind of resolution?</p>

<a name="148710423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148710423" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148710423">Reid Barton (Nov 28 2018 at 13:18)</a>:</h4>
<p>I can try to produce a rebased version of my <code>adjunctions</code> branch, that shouldn't take too long.</p>

<a name="148712087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148712087" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148712087">Reid Barton (Nov 28 2018 at 13:48)</a>:</h4>
<p>It looks like Johan has mostly just been working on one file, so probably easiest to just copy the <code>sheaf</code> branch into a new branch indeed</p>

<a name="148712367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148712367" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148712367">Reid Barton (Nov 28 2018 at 13:53)</a>:</h4>
<p>Oh, also the specific shape limit stuff isn't in <code>limits-2</code> yet. I do have a copy that at least builds on top of <code>limits-2</code> though, so I can push that somewhere as a temporary measure for you, Johan</p>

<a name="148712439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148712439" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148712439">Johan Commelin (Nov 28 2018 at 13:54)</a>:</h4>
<p>Ooh, don't worry too much about this</p>

<a name="148712447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148712447" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148712447">Johan Commelin (Nov 28 2018 at 13:55)</a>:</h4>
<p>I think it's best to fix it after <code>limits-2</code> is merged.</p>

<a name="148712710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148712710" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148712710">Reid Barton (Nov 28 2018 at 13:59)</a>:</h4>
<p>Ah, fair enough. I'll hold off on these things then</p>

<a name="148720854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148720854" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148720854">Johan Commelin (Nov 28 2018 at 15:48)</a>:</h4>
<p>I'm very confused about <a href="https://github.com/leanprover-community/mathlib/blob/sheaf/category_theory/commas.lean#L155-L156" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/sheaf/category_theory/commas.lean#L155-L156">https://github.com/leanprover-community/mathlib/blob/sheaf/category_theory/commas.lean#L155-L156</a><br>
I thought I understood <code>rfl</code> by now. But apparently this is not <code>rfl</code>. If someone can explain this mystery, I would be very grateful.</p>

<a name="148721486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148721486" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148721486">Gabriel Ebner (Nov 28 2018 at 15:51)</a>:</h4>
<p><code>map_right_id'</code> should be a <code>def</code>.  Theorems don't unfold (except for special circumstances / options).</p>

<a name="148721547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148721547" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148721547">Johan Commelin (Nov 28 2018 at 15:52)</a>:</h4>
<p>Aaah, it should certainly be a <code>def</code>. Let me try again.</p>

<a name="148721603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148721603" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148721603">Johan Commelin (Nov 28 2018 at 15:53)</a>:</h4>
<p><span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> Cool! Now it works.</p>

<a name="148727291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148727291" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148727291">Kevin Buzzard (Nov 28 2018 at 17:12)</a>:</h4>
<p>Computer scientists have such weird ideas about what a theorem is :-)</p>

<a name="148728262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148728262" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148728262">Johan Commelin (Nov 28 2018 at 17:25)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> <span class="user-mention" data-user-id="110032">@Reid Barton</span> I suggest we replace <code>of_obj</code> with <code>of.obj</code> after defining</p>
<div class="codehilite"><pre><span></span><span class="kn">namespace</span> <span class="n">functor</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="err">𝒞</span> <span class="o">:</span> <span class="n">category</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span> <span class="n">v</span><span class="o">}</span> <span class="n">C</span><span class="o">]</span>
<span class="n">include</span> <span class="err">𝒞</span>

<span class="n">def</span> <span class="n">of</span> <span class="o">:</span> <span class="n">C</span> <span class="err">⥤</span> <span class="o">(</span><span class="n">punit</span> <span class="err">⥤</span> <span class="n">C</span><span class="o">)</span> <span class="o">:=</span> <span class="n">const</span> <span class="n">punit</span>

<span class="kn">namespace</span> <span class="n">of</span>
<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">obj_obj</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">of</span><span class="bp">.</span><span class="n">obj</span> <span class="n">X</span><span class="o">)</span><span class="bp">.</span><span class="n">obj</span> <span class="bp">=</span> <span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">obj_map</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">of</span><span class="bp">.</span><span class="n">obj</span> <span class="n">X</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="bp">=</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="mi">𝟙</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">map_app</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="err">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">of</span><span class="bp">.</span><span class="n">map</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">app</span> <span class="bp">=</span> <span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kn">end</span> <span class="n">of</span>

<span class="kn">end</span> <span class="n">functor</span>
</pre></div>


<p>Is that ok?</p>

<a name="148728479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148728479" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148728479">Reid Barton (Nov 28 2018 at 17:28)</a>:</h4>
<p>Yes, that seems sensible</p>

<a name="148748886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148748886" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148748886">Reid Barton (Nov 28 2018 at 22:27)</a>:</h4>
<blockquote>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> I fixed a bunch of compile issues, which we due to <code>functor.const</code> being picked from the wrong namespace (even though <code>category_theory</code> seems to be open). I really hope Lean 4 will kick a lot of these things out of the root namespace, because these conflicts are quite annoying.</p>
</blockquote>
<p>If someone could track this down, it would be super helpful. I'm not sure what changed here.</p>

<a name="148861225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148861225" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148861225">Johan Commelin (Nov 30 2018 at 13:33)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> <span class="user-mention" data-user-id="110087">@Scott Morrison</span> Do you think we need something like this? I find it extremely annoying that Lean refuses some of my morphisms because the come from an opposite category. I understand why Lean complains, but getting it to accept the arrow is extremely annoying. This might help...</p>
<div class="codehilite"><pre><span></span><span class="kn">namespace</span> <span class="n">category</span><span class="bp">.</span><span class="n">hom</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="err">𝒞</span> <span class="o">:</span> <span class="n">category</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span> <span class="n">v</span><span class="o">}</span> <span class="n">C</span><span class="o">]</span>
<span class="n">include</span> <span class="err">𝒞</span>

<span class="n">def</span> <span class="n">op</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="err">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="bp">@</span><span class="n">category</span><span class="bp">.</span><span class="n">hom</span> <span class="bp">_</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">opposite</span> <span class="n">Y</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">f</span>
<span class="n">def</span> <span class="n">deop</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="err">ᵒᵖ</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="err">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="bp">@</span><span class="n">category</span><span class="bp">.</span><span class="n">hom</span> <span class="bp">_</span> <span class="err">𝒞</span> <span class="n">Y</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">f</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">op_deop</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="err">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span><span class="bp">.</span><span class="n">op</span><span class="bp">.</span><span class="n">deop</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">deop_op</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="err">ᵒᵖ</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="err">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span><span class="bp">.</span><span class="n">deop</span><span class="bp">.</span><span class="n">op</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kn">end</span> <span class="n">category</span><span class="bp">.</span><span class="n">hom</span>
</pre></div>

<a name="148898413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/148898413" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#148898413">Scott Morrison (Nov 30 2018 at 23:51)</a>:</h4>
<p>This sounds fine to me. I agree dealing with opposites is gross. :-(</p>

<a name="150778353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/150778353" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#150778353">Johan Commelin (Dec 03 2018 at 15:38)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> Have you had similar experiences? What is your opinion on my proposed solution?</p>

<a name="150835179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/150835179" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#150835179">Scott Morrison (Dec 04 2018 at 09:55)</a>:</h4>
<p>Hi <span class="user-mention" data-user-id="112680">@Johan Commelin</span>, I am experimenting with making <code>op</code> irreducible, and thus _requiring_ the use of <code>op</code> or <code>deop</code> (and corresponding <code>op_obj</code> and <code>deop_obj</code> on objects).</p>

<a name="150835194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/150835194" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#150835194">Scott Morrison (Dec 04 2018 at 09:55)</a>:</h4>
<p>It is slightly grosser, but I think we've all discovered that too much can go mysteriously wrong with the current implementation of opposites.</p>

<a name="150835467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/150835467" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#150835467">Johan Commelin (Dec 04 2018 at 10:00)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> Aah, that sounds like a good idea!</p>

<a name="150835496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/150835496" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#150835496">Johan Commelin (Dec 04 2018 at 10:01)</a>:</h4>
<p>I hadn't thought about making it irreducible. Those boundaries are useful, but I'm not yet aware of how to make the system help us.</p>

<a name="150835503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/150835503" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#150835503">Johan Commelin (Dec 04 2018 at 10:01)</a>:</h4>
<p>So yes, I think it is very good if we have to be explicit about <code>op</code>ing and <code>deop</code>ing.</p>

<a name="150840492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/150840492" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#150840492">Scott Morrison (Dec 04 2018 at 11:30)</a>:</h4>
<p><a href="https://github.com/leanprover/mathlib/issues/510" target="_blank" title="https://github.com/leanprover/mathlib/issues/510">#510</a></p>

<a name="150841470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/150841470" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#150841470">Johan Commelin (Dec 04 2018 at 11:53)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> Looks good to me. I do wonder if we can remove the <code>_obj</code> suffix to make things a bit shorter. We could rename the existing <code>op</code> to <code>op_cat</code>.</p>

<a name="150841491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/150841491" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#150841491">Johan Commelin (Dec 04 2018 at 11:53)</a>:</h4>
<p>I think this is a good PR, but I regret that a lot of stuff is also becoming somewhat uglier.</p>

<a name="151459647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/151459647" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#151459647">Kevin Buzzard (Dec 11 2018 at 16:53)</a>:</h4>
<p><span class="user-mention" data-user-id="132858">@Ramon Fernandez Mir</span> is making me engage with the category theory stuff! Is there a name for this map: <code>(λ f r, f r : (FF.obj x ⟶ FF.obj y) → (FF.obj x → FF.obj y)) </code>? I'm changing a long arrow to a short one. The target of the functor FF is the category <code>CommRing</code>, so I want to take an abstract element of the hom set and actually produce the ring hom. There's a coercion that does it magically, but I actually have a set of abstract homs and want a set of concrete homs and I have to feed <code>set.image</code> something.</p>

<a name="151461302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/151461302" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#151461302">Johan Commelin (Dec 11 2018 at 17:18)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> Could you provide slightly more context? I typically get away without doing anything.</p>

<a name="151461833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/151461833" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#151461833">Kevin Buzzard (Dec 11 2018 at 17:26)</a>:</h4>
<p>We had a functor <code>FF</code> from a small category <code>J</code> to <code>CommRing</code> and two objects <code>x</code> and <code>y</code> of <code>J</code>, and we wanted the set of maps from <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mi>F</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">FF(x)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mi>F</mi><mo>(</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">FF(y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> coming from <code>J</code>.</p>

<a name="151461946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/151461946" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#151461946">Johan Commelin (Dec 11 2018 at 17:28)</a>:</h4>
<p>I see, and <code>FF.obj x \hom FF.obj y</code> is a subtype, but you want a set?</p>

<a name="151461981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/151461981" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#151461981">Johan Commelin (Dec 11 2018 at 17:28)</a>:</h4>
<p>Is that correct? If so, I think <code>subtype.val</code> would be the function you are looking for.</p>

<a name="151461995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/151461995" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#151461995">Johan Commelin (Dec 11 2018 at 17:29)</a>:</h4>
<p>I don't know by heart how <code>CommRing</code> is defined.</p>

<a name="151462204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/151462204" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#151462204">Kevin Buzzard (Dec 11 2018 at 17:31)</a>:</h4>
<p>I'm trying to get from <code>category_theory.category.hom R S</code> to <code>R -&gt; S</code></p>

<a name="151462333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/151462333" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#151462333">Kevin Buzzard (Dec 11 2018 at 17:32)</a>:</h4>
<p>I can just evaluate a term of type <code>category_theory.category.hom R S</code> at <code>r</code> and get <code>s : S</code></p>

<a name="151462431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/151462431" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#151462431">Kevin Buzzard (Dec 11 2018 at 17:34)</a>:</h4>
<p>but I was wondering what the name of the coercion was, because I needed to refer to the map itself when doing something else.</p>

<a name="151465278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/151465278" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#151465278">Johan Commelin (Dec 11 2018 at 17:55)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> On line 90 of <code>category.lean</code> you can find</p>
<div class="codehilite"><pre><span></span><span class="o">{</span> <span class="n">hom</span>   <span class="o">:=</span> <span class="bp">λ</span><span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">subtype</span> <span class="o">(</span><span class="n">hom</span> <span class="n">a</span><span class="bp">.</span><span class="mi">2</span> <span class="n">b</span><span class="bp">.</span><span class="mi">2</span><span class="o">),</span>
</pre></div>


<p>(This is in the instance of <code>concrete_category</code> --&gt; <code>category</code>.) So the map you want is called <code>subtype.val</code>.</p>

<a name="151467554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/151467554" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#151467554">Reid Barton (Dec 11 2018 at 18:13)</a>:</h4>
<p>I think there is (or should be?) some more high-level name for this, like <code>forget</code></p>

<a name="151469130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/151469130" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#151469130">Johan Commelin (Dec 11 2018 at 18:26)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> That's right. As Reid mentioned, there is a <code>forget</code>ful functor. You will have to</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">types</span>
</pre></div>

<a name="151469476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/151469476" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#151469476">Reid Barton (Dec 11 2018 at 18:29)</a>:</h4>
<p>Ah that's where it is</p>

<a name="151755507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/151755507" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#151755507">Reid Barton (Dec 14 2018 at 05:15)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> did you end up using <code>forget</code>? I'm inclined to make its "C" argument implicit, would that help or hurt you?</p>

<a name="151758445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/151758445" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#151758445">Kevin Buzzard (Dec 14 2018 at 06:51)</a>:</h4>
<p>I didn't do anything. I was talking about it with Ramon at our last meeting and haven't thought about it since</p>

<a name="151758486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/151758486" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#151758486">Kevin Buzzard (Dec 14 2018 at 06:52)</a>:</h4>
<p>I am completely snowed under with teaching and reference writing</p>

<a name="152438280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/152438280" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#152438280">Ramon Fernandez Mir (Dec 23 2018 at 19:05)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> sorry I just saw this. I was playing with that code a few days ago and I didn't manage to make it work with forget. What is the "C" argument meant to be?</p>

<a name="172717348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/172717348" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#172717348">Gun Pinyo (Aug 07 2019 at 21:23)</a>:</h4>
<p>In <a href="https://github.com/leanprover-community/mathlib/blob/master/src/category_theory/category.lean" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/src/category_theory/category.lean">https://github.com/leanprover-community/mathlib/blob/master/src/category_theory/category.lean</a>,<br>
Could anyone tells me why objects are not a field but a parameter to the definition of <code>category</code>? What is the advantage of it? Also, why the definition of a category is a class rather than an ordinary structure?</p>

<a name="172717412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/172717412" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#172717412">Kenny Lau (Aug 07 2019 at 21:24)</a>:</h4>
<p>It allows us to say that the "set" of all groups have a category structure on it</p>

<a name="172717451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/172717451" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#172717451">Kenny Lau (Aug 07 2019 at 21:24)</a>:</h4>
<p>so given two groups <code>G</code> and <code>H</code>, Lean can infer what <code>G \hom H</code> means</p>

<a name="172717474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/172717474" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#172717474">Kenny Lau (Aug 07 2019 at 21:25)</a>:</h4>
<p>structure instances can't be automatically inferred</p>

<a name="172717820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/172717820" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#172717820">Gun Pinyo (Aug 07 2019 at 21:30)</a>:</h4>
<p>Ok, but what if want to say something like "let C be a category" I need to explicitly state its object and become "let C be a category that has objects as blah". I find this quite wired.</p>
<p>I know that this can be solved using <code>Σ obj : Type*, category obj</code> but this is a little bit ad-hoc, does mathlib has a definition for this?</p>

<a name="172717942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/172717942" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#172717942">Kenny Lau (Aug 07 2019 at 21:31)</a>:</h4>
<p>Let X be a type that has a category structure C on it</p>

<a name="172718443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/172718443" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#172718443">Gun Pinyo (Aug 07 2019 at 21:38)</a>:</h4>
<p>This way of defining a category really see a category as an underlining structure of some type. However, many interesting categories focus more on the morphism whereas object carries almost no information e.g. the category of simplexes in which I believe that it has type as <code>category ℕ</code>.</p>

<a name="172718495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/172718495" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#172718495">Kenny Lau (Aug 07 2019 at 21:39)</a>:</h4>
<p>This is an interesting example.</p>

<a name="172718560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/172718560" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#172718560">Kenny Lau (Aug 07 2019 at 21:40)</a>:</h4>
<p>I don't know what to do with it.</p>

<a name="172719065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/172719065" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#172719065">Scott Morrison (Aug 07 2019 at 21:49)</a>:</h4>
<p>You just do something like <code>def \Delta := \nat</code>, and then <code>instance : category \Delta</code>. This is what type synonyms are for.</p>

<a name="172719072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/172719072" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#172719072">Scott Morrison (Aug 07 2019 at 21:49)</a>:</h4>
<p>But yes, my initial starts on the category theory library did use bundled categories.</p>

<a name="172719150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/172719150" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#172719150">Scott Morrison (Aug 07 2019 at 21:50)</a>:</h4>
<p>The payoff, which has not yet been realised in mathlib, of using unbundled categories is that it would allow us to use uniform notation <code>\iso</code>, <code>\hom</code>, <code>\otimes</code> etc across all examples.</p>

<a name="172719172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/172719172" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#172719172">Scott Morrison (Aug 07 2019 at 21:51)</a>:</h4>
<p>Mostly this hasn't happened because the category theoretic notion of <code>iso</code> between rings, say, would only allow talking about isomorphisms between rings in the same universe.</p>

<a name="172719184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/172719184" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#172719184">Scott Morrison (Aug 07 2019 at 21:51)</a>:</h4>
<p>This distinction matters, I think for <code>equiv</code> (rather than just using <code>iso</code> in <code>category Type</code>), where it's pretty common to want to shift universes.</p>

<a name="172719255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/172719255" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#172719255">Scott Morrison (Aug 07 2019 at 21:52)</a>:</h4>
<p>On the other hand it's rare that one deals with isomorphisms of rings in different universes.</p>

<a name="172719262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/172719262" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#172719262">Scott Morrison (Aug 07 2019 at 21:52)</a>:</h4>
<p>(but it does happen, sure)</p>

<a name="172719294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/172719294" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#172719294">Scott Morrison (Aug 07 2019 at 21:53)</a>:</h4>
<p>If I were king, I'd use <code>iso</code> instead of <code>mul_equiv</code>, <code>algebra_equiv</code>, <code>homeomorphism</code>, etc. etc., and even use <code>iso</code> in <code>Type</code>, adding an extra <code>pequiv</code> for talking about equivalences that cross universe levels.</p>

<a name="172719397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/172719397" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#172719397">Scott Morrison (Aug 07 2019 at 21:54)</a>:</h4>
<p><span class="user-mention" data-user-id="144193">@Gun Pinyo</span>, there is <a href="https://github.com/leanprover-community/mathlib/blob/master/src/category_theory/Cat.lean" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/src/category_theory/Cat.lean"><code>src/category_theory/Cat.lean</code></a>, which defines bundled categories in mathlib, although doesn't do very much with them.</p>

<a name="172722548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/172722548" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#172722548">Kevin Buzzard (Aug 07 2019 at 22:49)</a>:</h4>
<blockquote>
<p>(but it does happen, sure)</p>
</blockquote>
<p>Why do you say this? In maths I never leave <code>Type</code>. This universe polymorphism is just something which the CS people want to make us use and this is one point where it adds to the confusion.</p>

<a name="172726922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/172726922" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#172726922">Mario Carneiro (Aug 08 2019 at 00:05)</a>:</h4>
<p>Is Cat a category? If so, you aren't working in Type</p>

<a name="172727001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/172727001" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#172727001">Mario Carneiro (Aug 08 2019 at 00:07)</a>:</h4>
<p>Maybe that's not the best example, but <code>Type (u+1)</code> makes several appearances in mathlib</p>

<a name="172727066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/172727066" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#172727066">Mario Carneiro (Aug 08 2019 at 00:08)</a>:</h4>
<p>Perhaps you don't think it's important to have ordinals or cardinals or surreals or a model of ZFC</p>

<a name="172727350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/172727350" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#172727350">Mario Carneiro (Aug 08 2019 at 00:13)</a>:</h4>
<p>Probably the only one of those you use regularly are cardinals. Of course there are ways to do cardinals in ZFC as well, but the question is not whether it's possible but whether it is easy to work that way. Jeremy told me today that he believes that FLT can probably be proven in primitive recursive arithmetic (PRA), a weak subsystem of Peano arithmetic, but such a proof would obviously look almost unrecognizable compared to Wiles' proof</p>

<a name="172727616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/172727616" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#172727616">Gun Pinyo (Aug 08 2019 at 00:18)</a>:</h4>
<blockquote>
<p>You just do something like <code>def \Delta := \nat</code>, and then <code>instance : category \Delta</code>. This is what type synonyms are for.</p>
</blockquote>
<p>Well,  <code>def \Delta := \nat</code> is the abuse of notation, what if I want to define the category of cubes then I should do <code>def \square := \nat</code> then suddenly we have <code>\Delta = \square</code> which shouldn't be true.</p>

<a name="172727984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/172727984" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#172727984">Gun Pinyo (Aug 08 2019 at 00:26)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span>  If the advantage of unbundled categories couldn't be used in practice, should we go back and use bundled one (as the main def) as before?</p>

<a name="172730778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/172730778" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#172730778">Scott Morrison (Aug 08 2019 at 01:35)</a>:</h4>
<p><span class="user-mention" data-user-id="144193">@Gun Pinyo</span>, I don't think you should think of that as abuse of notation. It is used all over mathlib, and is just part of how typeclasses are used in dependent type theory. After building the API for <code>\Delta</code> or for <code>\square</code>, one should then mark <code>\Delta</code> as <code>[irreducible]</code>, preventing people from seeing the implementation detail that it is definitionally equal to <code>nat</code>.</p>

<a name="172730792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/172730792" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#172730792">Scott Morrison (Aug 08 2019 at 01:35)</a>:</h4>
<p>I don't think that the advantages of unbundled categories <em>can't</em> be used in practice, we're just not there yet. :-)</p>

<a name="172730841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/172730841" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#172730841">Scott Morrison (Aug 08 2019 at 01:36)</a>:</h4>
<p>The algebraists are currently busy bundling ring homs and similar gadgets, and this actually makes it easier to use the uniform notions provided by the the category theory library.</p>

<a name="172730865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/172730865" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#172730865">Scott Morrison (Aug 08 2019 at 01:37)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> </p>
<blockquote>
<p>Why do you say this? In maths I never leave <code>Type</code>. </p>
</blockquote>
<p>So let's get rid of <code>ring_equiv</code> and friends... :-) If you're happy not being able to change universe levels across a <code>ring_equiv</code>, there's not much advantage over just using the uniform <code>iso</code>.</p>

<a name="172730925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/172730925" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#172730925">Scott Morrison (Aug 08 2019 at 01:39)</a>:</h4>
<p>There is the point that in an <code>iso</code> you need to explicitly say that both directions are ring homomorphisms, while the default constructor of <code>ring_equiv</code> only asks that you prove this in one direction, but solving this is just a tiny bit of plumbing. (i.e. we can provide an alternative constructor for isomorphisms of rings, etc)</p>

<a name="172739125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category%20theory/near/172739125" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/24026Categorytheory.html#172739125">Johan Commelin (Aug 08 2019 at 05:20)</a>:</h4>
<p><span class="user-mention" data-user-id="144193">@Gun Pinyo</span> Just for the record, I think that <span class="user-mention" data-user-id="110294">@Johannes Hölzl</span> also developped some stuff with cubes. In particular he had a definition of cubical homology, I think. <span class="user-mention" data-user-id="110294">@Johannes Hölzl</span> do you still have this code somewhere?</p>


{% endraw %}

{% include archive_update.html %}