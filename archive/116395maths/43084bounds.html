---
layout: archive
title: Lean Prover Zulip Chat Archive 
permalink: archive/116395maths/43084bounds.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/43084bounds.html">bounds</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="147874320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bounds/near/147874320" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/43084bounds.html#147874320">Kevin Buzzard (Nov 17 2018 at 11:23)</a>:</h4>
<p>This is more of a funny story than anything else.</p>
<p>This week just gone at Imperial, we were looking at the real numbers and the completeness axiom in my class. Some of the students were involved in a (maths not Lean) project of constructing the real numbers as Dedekind cuts. The sheet started by defining totally ordered sets (the <code>linear_order</code> class in Lean) and the "least upper bound property" -- any non-empty bounded-above subset has a least upper bound. The sheet then remarked something I'd never realised -- there is no point defining also the "greatest lower bound property", because this follows from the least upper bound property. For the reals I had always imagined that this was proved by just considering <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>{</mo><mo>−</mo><mi>x</mi><mspace width="0.16667em"></mspace><mo>∣</mo><mspace width="0.16667em"></mspace><mi>x</mi><mo>∈</mo><mi>S</mi><mo>}</mo></mrow><annotation encoding="application/x-tex">\{-x\,\mid\,x\in S\}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">{</span><span class="mord">−</span><span class="mord mathit">x</span><span class="mrel"><span class="mspace thinspace"></span><span class="mrel">∣</span></span><span class="mord mathit"><span class="mspace thinspace"></span><span class="mord mathit">x</span></span><span class="mrel">∈</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mclose">}</span></span></span></span> but actually there is a direct proof which only uses total orders. </p>
<div class="codehilite"><pre><span></span><span class="c1">-- from order/bounds.lean</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span>
<span class="n">def</span> <span class="n">upper_bounds</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">x</span> <span class="bp">|</span> <span class="bp">∀</span><span class="n">a</span> <span class="err">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">x</span> <span class="o">}</span>
<span class="n">def</span> <span class="n">lower_bounds</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">x</span> <span class="bp">|</span> <span class="bp">∀</span><span class="n">a</span> <span class="err">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">a</span> <span class="o">}</span>
<span class="n">def</span> <span class="n">is_least</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">s</span> <span class="bp">∧</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">lower_bounds</span> <span class="n">s</span>
<span class="n">def</span> <span class="n">is_greatest</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">s</span> <span class="bp">∧</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">upper_bounds</span> <span class="n">s</span>
<span class="n">def</span> <span class="n">is_lub</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">is_least</span> <span class="o">(</span><span class="n">upper_bounds</span> <span class="n">s</span><span class="o">)</span>
<span class="n">def</span> <span class="n">is_glb</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">is_greatest</span> <span class="o">(</span><span class="n">lower_bounds</span> <span class="n">s</span><span class="o">)</span>

<span class="kn">theorem</span> <span class="n">warm_up</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">S</span><span class="o">]</span> <span class="o">:</span>
<span class="o">(</span><span class="bp">∀</span> <span class="n">E</span> <span class="o">:</span> <span class="n">set</span> <span class="n">S</span><span class="o">,</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">E</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">b</span><span class="o">,</span> <span class="n">b</span> <span class="err">∈</span> <span class="n">upper_bounds</span> <span class="n">E</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">s</span> <span class="o">:</span> <span class="n">S</span><span class="o">,</span> <span class="n">is_lub</span> <span class="n">E</span> <span class="n">s</span><span class="o">)</span> <span class="bp">→</span>
<span class="o">(</span><span class="bp">∀</span> <span class="n">E</span> <span class="o">:</span> <span class="n">set</span> <span class="n">S</span><span class="o">,</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">E</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">b</span><span class="o">,</span> <span class="n">b</span> <span class="err">∈</span> <span class="n">lower_bounds</span> <span class="n">E</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">s</span> <span class="o">:</span> <span class="n">S</span><span class="o">,</span> <span class="n">is_glb</span> <span class="n">E</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>


<p>Of course the proof requires a mathematical idea -- knowing any non-empty bounded-above set has a sup, and given a non-empty bounded-below set, we need to produce an inf without this involution which we have on the reals.</p>

<a name="147874402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bounds/near/147874402" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/43084bounds.html#147874402">Kevin Buzzard (Nov 17 2018 at 11:26)</a>:</h4>
<p>So I could see what the idea must be, and knocked up a tactic proof without too much trouble.</p>
<p>And then because the bounds definitions applied not just to <code>linear_order</code> but to <code>preorder</code>, Chris asked whether my proof also worked for partial orders or preorders. So the question became -- what do you actually need to assume about your order to prove this warm-up question? I'll post our conclusions later on today if nobody else fancies trying to figure this out :-)</p>

<a name="147874403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bounds/near/147874403" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/43084bounds.html#147874403">Kevin Buzzard (Nov 17 2018 at 11:26)</a>:</h4>
<p>No spoilers Kenny/Chris, if you're reading :-)</p>

<a name="147875349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bounds/near/147875349" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/43084bounds.html#147875349">Johannes Hölzl (Nov 17 2018 at 11:58)</a>:</h4>
<p>This is a standard construction at least for complete lattices, there often one defines the supremum or infimum and derives the other exterma. And these structures where the extrema only exists for non-empty bounded sets are called "conditionally complete lattices"</p>

<a name="147878523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bounds/near/147878523" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/43084bounds.html#147878523">Kevin Buzzard (Nov 17 2018 at 13:54)</a>:</h4>
<p>Right. So the question is: you might well know already that if, in a lattice, all non-empty bounded-above sets have a sup, then all non-empty bounded-below sets have an inf. This is a pleasant exercise. The question is whether you can get away with less than a lattice.</p>

<a name="147878636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bounds/near/147878636" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/43084bounds.html#147878636">Mario Carneiro (Nov 17 2018 at 13:59)</a>:</h4>
<p>if every set has a least upper bound, then it's already a lattice</p>

<a name="147878638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bounds/near/147878638" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/43084bounds.html#147878638">Kevin Buzzard (Nov 17 2018 at 13:59)</a>:</h4>
<p>I am only demanding on my order that every non-empty bounded above set has a least upper bound.</p>

<a name="147878687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bounds/near/147878687" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/43084bounds.html#147878687">Mario Carneiro (Nov 17 2018 at 14:00)</a>:</h4>
<p>then you get a conditionally complete lattice</p>

<a name="147878690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bounds/near/147878690" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/43084bounds.html#147878690">Kevin Buzzard (Nov 17 2018 at 14:00)</a>:</h4>
<p>but I need enough from my order to be able to deduce from this that every non-empty bounded-below set has a greatest lower bound.</p>

<a name="147878699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bounds/near/147878699" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/43084bounds.html#147878699">Mario Carneiro (Nov 17 2018 at 14:01)</a>:</h4>
<p>You might have to be careful about how you say bounded below, but the usual proof should go through</p>

<a name="147878709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bounds/near/147878709" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/43084bounds.html#147878709">Kevin Buzzard (Nov 17 2018 at 14:01)</a>:</h4>
<p>I explain exactly what I mean by all of these terms in the original post</p>

<a name="147878711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bounds/near/147878711" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/43084bounds.html#147878711">Kevin Buzzard (Nov 17 2018 at 14:01)</a>:</h4>
<p>The question is how much you can relax the typeclasses and still be able to fill in the sorry</p>

<a name="147878753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bounds/near/147878753" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/43084bounds.html#147878753">Kevin Buzzard (Nov 17 2018 at 14:02)</a>:</h4>
<p>e.g. can you prove</p>
<div class="codehilite"><pre><span></span><span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span>
<span class="n">def</span> <span class="n">upper_bounds</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">x</span> <span class="bp">|</span> <span class="bp">∀</span><span class="n">a</span> <span class="err">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">x</span> <span class="o">}</span>
<span class="n">def</span> <span class="n">lower_bounds</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">x</span> <span class="bp">|</span> <span class="bp">∀</span><span class="n">a</span> <span class="err">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">a</span> <span class="o">}</span>
<span class="n">def</span> <span class="n">is_least</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">s</span> <span class="bp">∧</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">lower_bounds</span> <span class="n">s</span>
<span class="n">def</span> <span class="n">is_greatest</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">s</span> <span class="bp">∧</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">upper_bounds</span> <span class="n">s</span>
<span class="n">def</span> <span class="n">is_lub</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">is_least</span> <span class="o">(</span><span class="n">upper_bounds</span> <span class="n">s</span><span class="o">)</span>
<span class="n">def</span> <span class="n">is_glb</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">is_greatest</span> <span class="o">(</span><span class="n">lower_bounds</span> <span class="n">s</span><span class="o">)</span>

<span class="kn">theorem</span> <span class="n">warm_up</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">S</span><span class="o">]</span> <span class="o">:</span>
<span class="o">(</span><span class="bp">∀</span> <span class="n">E</span> <span class="o">:</span> <span class="n">set</span> <span class="n">S</span><span class="o">,</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">E</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">b</span><span class="o">,</span> <span class="n">b</span> <span class="err">∈</span> <span class="n">upper_bounds</span> <span class="n">E</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">s</span> <span class="o">:</span> <span class="n">S</span><span class="o">,</span> <span class="n">is_lub</span> <span class="n">E</span> <span class="n">s</span><span class="o">)</span> <span class="bp">→</span>
<span class="o">(</span><span class="bp">∀</span> <span class="n">E</span> <span class="o">:</span> <span class="n">set</span> <span class="n">S</span><span class="o">,</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">E</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">b</span><span class="o">,</span> <span class="n">b</span> <span class="err">∈</span> <span class="n">lower_bounds</span> <span class="n">E</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">s</span> <span class="o">:</span> <span class="n">S</span><span class="o">,</span> <span class="n">is_glb</span> <span class="n">E</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>

<a name="147878808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bounds/near/147878808" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/43084bounds.html#147878808">Mario Carneiro (Nov 17 2018 at 14:04)</a>:</h4>
<p>I think so</p>

<a name="147878810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bounds/near/147878810" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/43084bounds.html#147878810">Kevin Buzzard (Nov 17 2018 at 14:04)</a>:</h4>
<p>so now begin dropping the axioms of a preorder</p>

<a name="147878818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bounds/near/147878818" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/43084bounds.html#147878818">Kevin Buzzard (Nov 17 2018 at 14:05)</a>:</h4>
<p>and how far can you get?</p>

<a name="147878822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bounds/near/147878822" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/43084bounds.html#147878822">Mario Carneiro (Nov 17 2018 at 14:05)</a>:</h4>
<p>if you take <code>E := lower_bounds E</code> then it's nonempty, and an element of <code>E</code> is an upper bound for <code>lower_bounds E</code></p>

<a name="147878825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bounds/near/147878825" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/43084bounds.html#147878825">Kevin Buzzard (Nov 17 2018 at 14:05)</a>:</h4>
<p>right. And which axioms for a preorder do you use in this proof?</p>

<a name="147878866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bounds/near/147878866" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/43084bounds.html#147878866">Mario Carneiro (Nov 17 2018 at 14:06)</a>:</h4>
<p>if <code>a in E</code> and <code>b in lower_bounds E</code> then <code>b &lt;= a</code> so <code>a</code> is an upper bound of <code>lower_bounds E</code></p>

<a name="147878867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bounds/near/147878867" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/43084bounds.html#147878867">Mario Carneiro (Nov 17 2018 at 14:06)</a>:</h4>
<p>it uses nothing</p>

<a name="147878872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bounds/near/147878872" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/43084bounds.html#147878872">Kevin Buzzard (Nov 17 2018 at 14:07)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_le</span> <span class="n">α</span><span class="o">]</span>
<span class="n">def</span> <span class="n">upper_bounds</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">x</span> <span class="bp">|</span> <span class="bp">∀</span><span class="n">a</span> <span class="err">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">x</span> <span class="o">}</span>
<span class="n">def</span> <span class="n">lower_bounds</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">x</span> <span class="bp">|</span> <span class="bp">∀</span><span class="n">a</span> <span class="err">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">a</span> <span class="o">}</span>
<span class="n">def</span> <span class="n">is_least</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">s</span> <span class="bp">∧</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">lower_bounds</span> <span class="n">s</span>
<span class="n">def</span> <span class="n">is_greatest</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">s</span> <span class="bp">∧</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">upper_bounds</span> <span class="n">s</span>
<span class="n">def</span> <span class="n">is_lub</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">is_least</span> <span class="o">(</span><span class="n">upper_bounds</span> <span class="n">s</span><span class="o">)</span>
<span class="n">def</span> <span class="n">is_glb</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">is_greatest</span> <span class="o">(</span><span class="n">lower_bounds</span> <span class="n">s</span><span class="o">)</span>

<span class="kn">theorem</span> <span class="n">warm_up</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">has_le</span> <span class="n">S</span><span class="o">]</span> <span class="o">:</span>
<span class="o">(</span><span class="bp">∀</span> <span class="n">E</span> <span class="o">:</span> <span class="n">set</span> <span class="n">S</span><span class="o">,</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">E</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">b</span><span class="o">,</span> <span class="n">b</span> <span class="err">∈</span> <span class="n">upper_bounds</span> <span class="n">E</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">s</span> <span class="o">:</span> <span class="n">S</span><span class="o">,</span> <span class="n">is_lub</span> <span class="n">E</span> <span class="n">s</span><span class="o">)</span> <span class="bp">→</span>
<span class="o">(</span><span class="bp">∀</span> <span class="n">E</span> <span class="o">:</span> <span class="n">set</span> <span class="n">S</span><span class="o">,</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">E</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">b</span><span class="o">,</span> <span class="n">b</span> <span class="err">∈</span> <span class="n">lower_bounds</span> <span class="n">E</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">s</span> <span class="o">:</span> <span class="n">S</span><span class="o">,</span> <span class="n">is_glb</span> <span class="n">E</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">H</span> <span class="n">E</span> <span class="bp">⟨⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">haE</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">hbuE</span><span class="bp">⟩⟩</span><span class="o">,</span>
<span class="k">let</span> <span class="bp">⟨</span><span class="n">s</span><span class="o">,</span> <span class="n">hs1</span><span class="o">,</span> <span class="n">hs2</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">H</span> <span class="o">(</span><span class="n">lower_bounds</span> <span class="n">E</span><span class="o">)</span> <span class="bp">⟨⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">hbuE</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">a</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">s</span> <span class="n">hs</span><span class="o">,</span> <span class="n">hs</span> <span class="n">a</span> <span class="n">haE</span><span class="bp">⟩⟩</span> <span class="k">in</span>
<span class="bp">⟨</span><span class="n">s</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">t</span> <span class="n">htE</span><span class="o">,</span> <span class="n">hs2</span> <span class="n">t</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">z</span> <span class="n">hzLE</span><span class="o">,</span> <span class="n">hzLE</span> <span class="n">t</span> <span class="n">htE</span><span class="o">),</span> <span class="n">hs1</span><span class="bp">⟩</span>
</pre></div>

<a name="147878874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bounds/near/147878874" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/43084bounds.html#147878874">Kevin Buzzard (Nov 17 2018 at 14:07)</a>:</h4>
<p>punchline achieved</p>

<a name="147878877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bounds/near/147878877" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/43084bounds.html#147878877">Mario Carneiro (Nov 17 2018 at 14:07)</a>:</h4>
<p>it could be any relation</p>

<a name="147878878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bounds/near/147878878" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/43084bounds.html#147878878">Kevin Buzzard (Nov 17 2018 at 14:07)</a>:</h4>
<p>This made me wonder why preorder was assumed in bounds.lean</p>

<a name="147878922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bounds/near/147878922" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/43084bounds.html#147878922">Mario Carneiro (Nov 17 2018 at 14:08)</a>:</h4>
<p>because preorder is our weakest "lawful" order class</p>

<a name="147878923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bounds/near/147878923" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/43084bounds.html#147878923">Kevin Buzzard (Nov 17 2018 at 14:08)</a>:</h4>
<p>surely has_le is weaker?</p>

<a name="147878925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bounds/near/147878925" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/43084bounds.html#147878925">Kevin Buzzard (Nov 17 2018 at 14:08)</a>:</h4>
<p>It's surely an order class</p>

<a name="147878926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bounds/near/147878926" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/43084bounds.html#147878926">Kevin Buzzard (Nov 17 2018 at 14:08)</a>:</h4>
<p>because of the notation</p>

<a name="147878938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bounds/near/147878938" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/43084bounds.html#147878938">Kevin Buzzard (Nov 17 2018 at 14:09)</a>:</h4>
<p>you yourself know that has_add and has_mul are two completely different classes</p>

<a name="147878939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bounds/near/147878939" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/43084bounds.html#147878939">Kevin Buzzard (Nov 17 2018 at 14:09)</a>:</h4>
<p>that's why you had to define groups twice</p>

<a name="147878994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bounds/near/147878994" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/43084bounds.html#147878994">Mario Carneiro (Nov 17 2018 at 14:10)</a>:</h4>
<p>if it's not a preorder, you probably shouldn't be using <code>&lt;=</code></p>

<a name="147879007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bounds/near/147879007" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/43084bounds.html#147879007">Mario Carneiro (Nov 17 2018 at 14:11)</a>:</h4>
<p>plus all the terminology there doesn't really make sense without some transitivity</p>

<a name="147879514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bounds/near/147879514" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/43084bounds.html#147879514">Kevin Buzzard (Nov 17 2018 at 14:29)</a>:</h4>
<p>I am surprised that this is your attitude. I think the notation implies a "way of thinking" about the structure, but why can't I define the "upper bounds" of a set with has_le to be the obvious things? I thought that this was the mathlib philosophy -- you define things in the max generality that they parse, and for these definitions like upper_bounds we need nothing more than the predicate.</p>

<a name="147879519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bounds/near/147879519" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/43084bounds.html#147879519">Kevin Buzzard (Nov 17 2018 at 14:29)</a>:</h4>
<p>Octonians aren't associative, and yet people still use <code>*</code> to multiply them</p>

<a name="147879616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bounds/near/147879616" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/43084bounds.html#147879616">Mario Carneiro (Nov 17 2018 at 14:32)</a>:</h4>
<p>octonions aren't completely lawless though</p>

<a name="147879619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bounds/near/147879619" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/43084bounds.html#147879619">Mario Carneiro (Nov 17 2018 at 14:33)</a>:</h4>
<p>If we cared about them we would define loops or power-associative monoids or whatever</p>

<a name="147879676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bounds/near/147879676" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/43084bounds.html#147879676">Mario Carneiro (Nov 17 2018 at 14:35)</a>:</h4>
<p>I think it helps to be at least a little application-driven here. If it's only ever used on preorders then why the suprious generalization?</p>

<a name="147879678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bounds/near/147879678" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/43084bounds.html#147879678">Mario Carneiro (Nov 17 2018 at 14:35)</a>:</h4>
<p>note also that typeclass inference is a bit longer for lower classes, although this is probably a small effect</p>

<a name="147879731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bounds/near/147879731" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/43084bounds.html#147879731">Mario Carneiro (Nov 17 2018 at 14:36)</a>:</h4>
<p>I would recommend using pure notation classes only in lawless situations like <code>meta</code> programming</p>

<a name="147880123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bounds/near/147880123" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/43084bounds.html#147880123">Kevin Buzzard (Nov 17 2018 at 14:49)</a>:</h4>
<p>Oh that's an interesting comment. So there is a place for the has_lt typeclass beyond just a notational trick?</p>

<a name="147880125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bounds/near/147880125" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/43084bounds.html#147880125">Kevin Buzzard (Nov 17 2018 at 14:49)</a>:</h4>
<p>It's just in lawless metaland :-)</p>

<a name="161006728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bounds/near/161006728" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/43084bounds.html#161006728">Kevin Buzzard (Mar 17 2019 at 17:10)</a>:</h4>
<blockquote>
<p>I think it helps to be at least a little application-driven here. If it's only ever used on preorders then why the suprious generalization?</p>
</blockquote>
<p>In <a href="https://github.com/leanprover-community/mathlib/issues/789" target="_blank" title="https://github.com/leanprover-community/mathlib/issues/789">#789</a> I PR'ed <code>monoid_equiv</code> and Chris suggested I change it to <code>mul_equiv</code>. I want <code>linear_ordered_comm_group_equiv</code> but should this be extending <code>le_equiv</code> or <code>preorder_equiv</code>? Note the conversation above.</p>

<a name="161006736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bounds/near/161006736" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/43084bounds.html#161006736">Kevin Buzzard (Mar 17 2019 at 17:11)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> . I just seem to be getting conflicting ideas about this one.</p>


{% endraw %}
