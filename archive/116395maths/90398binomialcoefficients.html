---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/116395maths/90398binomialcoefficients.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html">binomial coefficients</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="146974762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/146974762" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#146974762">Kevin Buzzard (Nov 07 2018 at 17:36)</a>:</h4>
<p>Preparing a lecture on the binomial and multinomial theorem. For pedagogical reasons I will not prove the binomial theorem the way it's proved in Lean (although the students who come to the "extra material" session will see the Lean proof). In Lean I guess the binomial coefficient <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><mrow><mi>n</mi></mrow><mrow><mi>r</mi></mrow></mfrac><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\binom{n}{r}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.85em;"></span><span class="strut bottom" style="height:1.20001em;vertical-align:-0.35001em;"></span><span class="base"><span class="mord"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7453919999999999em;"><span style="top:-2.3550000000000004em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right:0.02778em;">r</span></span></span></span><span style="top:-3.144em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span></span></span></span> is defined to be <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>n</mi><mo>!</mo></mrow><mrow><mi>r</mi><mo>!</mo><mo>(</mo><mi>n</mi><mo>−</mo><mi>r</mi><mo>)</mo><mo>!</mo></mrow></mfrac><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\frac{n!}{r!(n-r)!}. </annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8801079999999999em;"></span><span class="strut bottom" style="height:1.400108em;vertical-align:-0.52em;"></span><span class="base"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right:0.02778em;">r</span><span class="mclose mtight">!</span><span class="mopen mtight">(</span><span class="mord mathit mtight">n</span><span class="mbin mtight">−</span><span class="mord mathit mtight" style="margin-right:0.02778em;">r</span><span class="mclose mtight">)</span><span class="mclose mtight">!</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">n</span><span class="mclose mtight">!</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathrm">.</span></span></span></span> So is there in Lean a proof that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><mrow><mi>n</mi></mrow><mrow><mi>r</mi></mrow></mfrac><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\binom{n}{r}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.85em;"></span><span class="strut bottom" style="height:1.20001em;vertical-align:-0.35001em;"></span><span class="base"><span class="mord"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7453919999999999em;"><span style="top:-2.3550000000000004em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right:0.02778em;">r</span></span></span></span><span style="top:-3.144em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span></span></span></span> equals the number of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">r</span></span></span></span>-element subtypes of a a type of size <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">n</span></span></span></span>? [this is my definition of the binomial coefficient in my lectures]</p>

<a name="146974999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/146974999" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#146974999">Johan Commelin (Nov 07 2018 at 17:40)</a>:</h4>
<p>Do we know that the powerset of a type of size <code>n</code> has size <code>2 ^ n</code>?</p>

<a name="146975085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/146975085" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#146975085">Johan Commelin (Nov 07 2018 at 17:40)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> Wouldn't it make sense to define <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><mrow><mi>n</mi></mrow><mrow><mi>r</mi></mrow></mfrac><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">n \choose r</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.85em;"></span><span class="strut bottom" style="height:1.20001em;vertical-align:-0.35001em;"></span><span class="base"><span class="mord"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7453919999999999em;"><span style="top:-2.3550000000000004em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right:0.02778em;">r</span></span></span></span><span style="top:-3.144em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span></span></span></span> via Pascal's triangle?</p>

<a name="146975630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/146975630" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#146975630">Johannes Hölzl (Nov 07 2018 at 17:48)</a>:</h4>
<p>it is defined recursively in <code>mathlib</code> (in <code>mathlib/data/nat/choose.lean</code>):</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">choose</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="bp">_</span>             <span class="mi">0</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="mi">0</span>       <span class="o">(</span><span class="n">k</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">k</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">choose</span> <span class="n">n</span> <span class="n">k</span> <span class="bp">+</span> <span class="n">choose</span> <span class="n">n</span> <span class="o">(</span><span class="n">succ</span> <span class="n">k</span><span class="o">)</span>
</pre></div>

<a name="146975661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/146975661" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#146975661">Kevin Buzzard (Nov 07 2018 at 17:49)</a>:</h4>
<p>Sure, that would be another way; then you can prove it's what I said it is by induction on n. Hmm and I guess you could then prove the result about the subsets of size r of a set of size n by induction on n.</p>

<a name="147108963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/147108963" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#147108963">Kevin Buzzard (Nov 07 2018 at 17:49)</a>:</h4>
<p>I guess I was just checking that everything I said today was in Lean. I am giving this awful proof of the binomial theorem of the form "imagine multiplying out (a+b)(a+b)(a+b)...(a+b) n times -- now think about what the general term looks like? You choose r brackets and choose a from them, and choose b from the rest -- done"</p>

<a name="147109092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/147109092" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#147109092">Kevin Buzzard (Nov 07 2018 at 17:51)</a>:</h4>
<p>but actually I think everything is either there or could be there. <span class="user-mention" data-user-id="112680">@Johan Commelin</span> the sum of the binomial coefficients being <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.664392em;"></span><span class="strut bottom" style="height:0.664392em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathrm">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">n</span></span></span></span></span></span></span></span></span></span></span> is easy: you can deduce it from the binomial theorem with <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mi>b</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a=b=1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">a</span><span class="mrel">=</span><span class="mord mathit">b</span><span class="mrel">=</span><span class="mord mathrm">1</span></span></span></span> ;-)</p>

<a name="147109115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/147109115" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#147109115">Johan Commelin (Nov 07 2018 at 17:51)</a>:</h4>
<p>Sure. But that's not exactly what I asked <span class="emoji emoji-1f609" title="wink">:wink:</span></p>

<a name="147109165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/147109165" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#147109165">Bryan Gin-ge Chen (Nov 07 2018 at 17:52)</a>:</h4>
<p>I think what you asked for is <a href="https://github.com/leanprover/mathlib/blob/89431cf4f01ff0f6b4005f96795a23571258cbf0/data/finset.lean#L1198" target="_blank" title="https://github.com/leanprover/mathlib/blob/89431cf4f01ff0f6b4005f96795a23571258cbf0/data/finset.lean#L1198">here</a>.</p>

<a name="147242495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/147242495" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#147242495">Kevin Buzzard (Nov 07 2018 at 17:53)</a>:</h4>
<p>...as long as you can prove that the size of a subset is at most the size of the set (which I am pretty sure is there) and the result about subsets of size r (which should be fine by induction on n).</p>

<a name="147613115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/147613115" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#147613115">Bryan Gin-ge Chen (Nov 13 2018 at 18:06)</a>:</h4>
<blockquote>
<p>So is there in Lean a proof that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><mrow><mi>n</mi></mrow><mrow><mi>r</mi></mrow></mfrac><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\binom{n}{r}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.85em;"></span><span class="strut bottom" style="height:1.20001em;vertical-align:-0.35001em;"></span><span class="base"><span class="mord"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7453919999999999em;"><span style="top:-2.3550000000000004em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right:0.02778em;">r</span></span></span></span><span style="top:-3.144em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span></span></span></span> equals the number of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">r</span></span></span></span>-element subtypes of a type of size <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">n</span></span></span></span>?</p>
</blockquote>
<p>I couldn't find this in mathlib so I've been working off-and-on on this. I finally have a proof, but it seems excessively long and ugly. Well, actually what I have is <a href="https://gist.github.com/bryangingechen/3f8e3fa3664bb4b044e9e607725cab1b" target="_blank" title="https://gist.github.com/bryangingechen/3f8e3fa3664bb4b044e9e607725cab1b">a proof of this</a>:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">card_subsets_of_range_eq_choose</span> <span class="o">(</span><span class="n">n</span> <span class="n">k</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">card</span> <span class="o">((</span><span class="n">powerset</span> <span class="o">(</span><span class="n">range</span> <span class="n">n</span><span class="o">))</span><span class="bp">.</span><span class="n">filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">t</span><span class="o">,</span> <span class="n">card</span> <span class="n">t</span> <span class="bp">=</span> <span class="n">k</span><span class="o">))</span> <span class="bp">=</span> <span class="n">choose</span> <span class="n">n</span> <span class="n">k</span> <span class="o">:=</span>
</pre></div>


<p>(what should be the name?) though what you really want is this:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">card_subsets_card_eq_choose</span>  <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">card</span> <span class="o">((</span><span class="n">powerset</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">t</span><span class="o">,</span> <span class="n">card</span> <span class="n">t</span> <span class="bp">=</span> <span class="n">k</span><span class="o">))</span> <span class="bp">=</span> <span class="n">choose</span> <span class="o">(</span><span class="n">card</span> <span class="n">s</span><span class="o">)</span> <span class="n">k</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>


<p><a href="#narrow/stream/113488-general/subject/tutorial/near/135254614" title="#narrow/stream/113488-general/subject/tutorial/near/135254614">Last time I ran into something like this</a>, <span class="user-mention" data-user-id="110026">@Simon Hudon</span> ended up writing a bunch of stuff for me which is now in the tutorials branch. This one's probably much easier but I haven't tried to tackle it yet...</p>
<p>Anyways, if anyone wants to golf this down to something reasonable or give advice on making it nicer, I'd really appreciate it!</p>

<a name="147613222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/147613222" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#147613222">Mario Carneiro (Nov 13 2018 at 18:08)</a>:</h4>
<p>I would hope to have a function on <code>list</code> that constructs all k element sublists</p>

<a name="147613231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/147613231" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#147613231">Mario Carneiro (Nov 13 2018 at 18:09)</a>:</h4>
<p>maybe we have it already?</p>

<a name="147613251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/147613251" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#147613251">Bryan Gin-ge Chen (Nov 13 2018 at 18:09)</a>:</h4>
<p>Oh that sounds like a good idea.</p>

<a name="147613290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/147613290" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#147613290">Mario Carneiro (Nov 13 2018 at 18:10)</a>:</h4>
<p>I don't think we have it</p>

<a name="147613355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/147613355" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#147613355">Mario Carneiro (Nov 13 2018 at 18:10)</a>:</h4>
<p>The nice thing about this is that the proof that this list has length <code>choose n k</code> will be obvious from the construction</p>

<a name="147613375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/147613375" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#147613375">Mario Carneiro (Nov 13 2018 at 18:11)</a>:</h4>
<p>and the rest is just lifting to the quotient</p>

<a name="147613405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/147613405" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#147613405">Bryan Gin-ge Chen (Nov 13 2018 at 18:11)</a>:</h4>
<p>right, this is like the approach to finite partitions you suggested before that I still haven't managed to do</p>

<a name="147615848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/147615848" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#147615848">Chris Hughes (Nov 13 2018 at 18:45)</a>:</h4>
<p><span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span> </p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">sublists_of_length</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">l</span>      <span class="mi">0</span>     <span class="o">:=</span> <span class="o">[[]]</span>
<span class="bp">|</span> <span class="o">[]</span>     <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span><span class="bp">::</span><span class="n">l</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">sublists_of_length</span> <span class="n">l</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">cons</span> <span class="n">a</span><span class="o">)</span> <span class="bp">++</span>
  <span class="o">(</span><span class="n">sublists_of_length</span> <span class="n">l</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span>
</pre></div>


<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> The definition of <code>list.sublists</code> in mathlib is totally incomprehensible to me, but is faster than the most natural definition. This approach to <code>sublist_of_length</code> is presumably not the fastest. What's the general policy on fast definitions versus comprehensible definitions?</p>

<a name="147615890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/147615890" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#147615890">Mario Carneiro (Nov 13 2018 at 18:45)</a>:</h4>
<p>fast is better than comprehensible</p>

<a name="147615949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/147615949" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#147615949">Mario Carneiro (Nov 13 2018 at 18:46)</a>:</h4>
<p>you can often prove the comprehensible definition as a lemma though</p>

<a name="147615968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/147615968" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#147615968">Mario Carneiro (Nov 13 2018 at 18:46)</a>:</h4>
<p>I think the definition of <code>list.sublists</code> is based on haskell's</p>

<a name="147615988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/147615988" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#147615988">Chris Hughes (Nov 13 2018 at 18:46)</a>:</h4>
<p>Even if fast means much longer proofs?</p>

<a name="147616009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/147616009" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#147616009">Mario Carneiro (Nov 13 2018 at 18:47)</a>:</h4>
<p>yes, although we can also retrofit a faster definition</p>

<a name="147616013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/147616013" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#147616013">Johannes Hölzl (Nov 13 2018 at 18:47)</a>:</h4>
<p>for me comprehensible is better than fast. For fast we often need a different solution anyway</p>

<a name="147616086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/147616086" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#147616086">Johannes Hölzl (Nov 13 2018 at 18:48)</a>:</h4>
<p>With Lean4 <span class="emoji emoji-1f340" title="four leaf clover">:four_leaf_clover:</span>  we hopefully can simply redefine constants for fast evaluation</p>

<a name="147616098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/147616098" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#147616098">Mario Carneiro (Nov 13 2018 at 18:48)</a>:</h4>
<p>Note that in the case of <code>sublists</code> there is actually a separate version <code>sublists'</code> that is basically the comprehensible one, to which we prove equivalence</p>

<a name="147616131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/147616131" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#147616131">Johannes Hölzl (Nov 13 2018 at 18:48)</a>:</h4>
<p>Hm, then it would be better to have <code>sublist</code> to be the comprehensible one?!</p>

<a name="147616160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/147616160" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#147616160">Mario Carneiro (Nov 13 2018 at 18:49)</a>:</h4>
<p>The idea is that the default one should be VM-fast</p>

<a name="147616174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/147616174" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#147616174">Mario Carneiro (Nov 13 2018 at 18:49)</a>:</h4>
<p>because this is in the computational part</p>

<a name="147616280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/147616280" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#147616280">Mario Carneiro (Nov 13 2018 at 18:50)</a>:</h4>
<p>(there is an additional complication, in that <code>sublists</code> and <code>sublists'</code> are not equal but differ by a complicated permutation)</p>

<a name="147616338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/147616338" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#147616338">Mario Carneiro (Nov 13 2018 at 18:51)</a>:</h4>
<p>They actually both have fast VM definitions, but <code>sublists</code> is faster</p>

<a name="147616348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/147616348" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#147616348">Mario Carneiro (Nov 13 2018 at 18:51)</a>:</h4>
<p>and <code>sublists'</code> has nicer equation lemmas</p>

<a name="147618019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/147618019" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#147618019">Mario Carneiro (Nov 13 2018 at 19:14)</a>:</h4>
<p>here's a faster version of the same definition:</p>
<div class="codehilite"><pre><span></span>def sublists_of_length_aux {α : Type*} : list α → ℕ → (list α → list α) → list (list α) → list (list α)
| l      0     f r := f [] :: r
| []     (n+1) f r := r
| (a::l) (n+1) f r := sublists_of_length_aux l n (f ∘ list.cons a)
  (sublists_of_length_aux l (n + 1) f r)

def sublists_of_length {α : Type*} (l : list α) (n : ℕ) : list (list α) :=
sublists_of_length_aux l n id []
</pre></div>


<p>the idea is to define <code>(sublists_of_length l n).map f ++ r</code> by recursion without stacking recursive calls to <code>map</code> or <code>append</code></p>

<a name="147618069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/147618069" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#147618069">Mario Carneiro (Nov 13 2018 at 19:15)</a>:</h4>
<p>You can prove without too much difficulty that <code>sublists_of_length_aux l n f r = (sublists_of_length l n).map f ++ r</code> and then you can prove your equation lemmas as theorems</p>

<a name="147712036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/147712036" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#147712036">Jeremy Avigad (Nov 15 2018 at 01:07)</a>:</h4>
<p>We used to have this in Lean 2 (but it would be nice to have cleaner proofs).<br>
<a href="https://github.com/leanprover/lean2/blob/master/library/theories/combinatorics/choose.lean#L208-L220" target="_blank" title="https://github.com/leanprover/lean2/blob/master/library/theories/combinatorics/choose.lean#L208-L220">https://github.com/leanprover/lean2/blob/master/library/theories/combinatorics/choose.lean#L208-L220</a></p>

<a name="147980872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/147980872" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#147980872">Bryan Gin-ge Chen (Nov 19 2018 at 17:28)</a>:</h4>
<blockquote>
<p>You can prove without too much difficulty that <code>sublists_of_length_aux l n f r = (sublists_of_length l n).map f ++ r</code> and then you can prove your equation lemmas as theorems</p>
</blockquote>
<p>Could I get a hint on this step? I'm not sure what to do even to get started:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">sublists_of_length_aux</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="o">(</span><span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">l</span>      <span class="mi">0</span>     <span class="n">f</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">f</span> <span class="o">[]</span> <span class="bp">::</span> <span class="n">r</span>
<span class="bp">|</span> <span class="o">[]</span>     <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">f</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">r</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span><span class="bp">::</span><span class="n">l</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">f</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">sublists_of_length_aux</span> <span class="n">l</span> <span class="n">n</span> <span class="o">(</span><span class="n">f</span> <span class="err">∘</span> <span class="n">list</span><span class="bp">.</span><span class="n">cons</span> <span class="n">a</span><span class="o">)</span>
  <span class="o">(</span><span class="n">sublists_of_length_aux</span> <span class="n">l</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">f</span> <span class="n">r</span><span class="o">)</span>

<span class="n">def</span> <span class="n">sublists_of_length</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">sublists_of_length_aux</span> <span class="n">l</span> <span class="n">n</span> <span class="n">id</span> <span class="o">[]</span>

<span class="kn">lemma</span> <span class="n">foo</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span> <span class="bp">∀</span><span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">α</span><span class="o">)),</span>
  <span class="n">sublists_of_length_aux</span> <span class="n">l</span> <span class="n">n</span> <span class="n">f</span> <span class="n">r</span> <span class="bp">=</span> <span class="o">(</span><span class="n">sublists_of_length</span> <span class="n">l</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">f</span> <span class="bp">++</span> <span class="n">r</span>
<span class="bp">|</span> <span class="n">l</span> <span class="mi">0</span> <span class="n">f</span> <span class="n">r</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="c1">--unfold sublists_of_length_aux,</span>
  <span class="n">sorry</span>
<span class="kn">end</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">f</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span><span class="bp">::</span><span class="n">l</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">f</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>


<p>I was hoping I could make the first one <code>refl</code>, but it seems I need to do something else first, and I'm having trouble working with the definitions.</p>

<a name="147981987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/147981987" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#147981987">Mario Carneiro (Nov 19 2018 at 17:49)</a>:</h4>
<p>ah, it looks like lean did a case split on <code>l</code> first, then <code>n</code>, in the definition of <code>sublists_of_length_aux</code>, so that the first equation isn't true by <code>refl</code> but rather by <code>cases l; refl</code></p>

<a name="147981997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/147981997" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#147981997">Mario Carneiro (Nov 19 2018 at 17:49)</a>:</h4>
<p>you can fix this by swapping the order of the first two arguments to <code>sublists_of_length_aux</code></p>

<a name="147982276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/147982276" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#147982276">Bryan Gin-ge Chen (Nov 19 2018 at 17:55)</a>:</h4>
<p>Cool, that did the trick.</p>

<a name="147982611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/147982611" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#147982611">Mario Carneiro (Nov 19 2018 at 18:01)</a>:</h4>
<p>but actually I think you want to generalize the lemma a bit to prove it:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">sublists_of_length_aux</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="o">(</span><span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">|</span> <span class="mi">0</span>     <span class="n">l</span>      <span class="n">f</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">f</span> <span class="o">[]</span> <span class="bp">::</span> <span class="n">r</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">[]</span>     <span class="n">f</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">r</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span><span class="bp">::</span><span class="n">l</span><span class="o">)</span> <span class="n">f</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">sublists_of_length_aux</span> <span class="n">n</span> <span class="n">l</span> <span class="o">(</span><span class="n">f</span> <span class="err">∘</span> <span class="n">list</span><span class="bp">.</span><span class="n">cons</span> <span class="n">a</span><span class="o">)</span>
  <span class="o">(</span><span class="n">sublists_of_length_aux</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">l</span> <span class="n">f</span> <span class="n">r</span><span class="o">)</span>

<span class="n">def</span> <span class="n">sublists_of_length</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">sublists_of_length_aux</span> <span class="n">n</span> <span class="n">l</span> <span class="n">id</span> <span class="o">[]</span>

<span class="kn">lemma</span> <span class="n">foo</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">α</span><span class="o">)),</span>
  <span class="n">sublists_of_length_aux</span> <span class="n">n</span> <span class="n">l</span> <span class="o">(</span><span class="n">g</span> <span class="err">∘</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span><span class="bp">.</span><span class="n">map</span> <span class="n">g</span> <span class="bp">++</span> <span class="n">s</span><span class="o">)</span> <span class="bp">=</span>
  <span class="o">(</span><span class="n">sublists_of_length_aux</span> <span class="n">n</span> <span class="n">l</span> <span class="n">f</span> <span class="n">r</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">g</span> <span class="bp">++</span> <span class="n">s</span>
<span class="bp">|</span> <span class="mi">0</span>     <span class="n">l</span>      <span class="n">f</span> <span class="n">g</span> <span class="n">r</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">[]</span>     <span class="n">f</span> <span class="n">g</span> <span class="n">r</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span><span class="bp">::</span><span class="n">l</span><span class="o">)</span> <span class="n">f</span> <span class="n">g</span> <span class="n">r</span> <span class="n">s</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">unfold</span> <span class="n">sublists_of_length_aux</span><span class="bp">;</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">foo</span><span class="o">,</span> <span class="k">show</span> <span class="o">((</span><span class="n">g</span> <span class="err">∘</span> <span class="n">f</span><span class="o">)</span> <span class="err">∘</span> <span class="n">list</span><span class="bp">.</span><span class="n">cons</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">g</span> <span class="err">∘</span> <span class="n">f</span> <span class="err">∘</span> <span class="n">list</span><span class="bp">.</span><span class="n">cons</span> <span class="n">a</span><span class="o">),</span> <span class="k">by</span> <span class="n">refl</span><span class="o">,</span> <span class="n">foo</span><span class="o">]</span>
</pre></div>


<p>The theorem you want is now a simple corollary</p>

<a name="162783741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/162783741" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#162783741">Mario Carneiro (Apr 08 2019 at 02:11)</a>:</h4>
<p>What I mean by "reflecting the combinatorics": Consider how you would give the combinatoric bijection. You have a finite set, and you are making a list of all the subsets of length k; you first list all the ones that don't contain some arbitrary element a, then all the ones that do. A little reflection reveals that you don't need any of the structure of finite sets for this, so you may as well do it on lists. Now you want to define a function <code>sublists_len k l</code> such that <code>sublists_len 0 l = [[]]</code>, and <code>sublists_len (k+1) (a::l) = sublists_len (k+1) l ++ map (a::) (sublists_len k l)</code>, because we have split the problem into the size <code>k+1</code> elements in <code>l</code> and the size k elements of <code>l</code> with <code>a</code> appended. This is exactly the definition of <code>sublists_len</code> I give (with a slight optimization so that you don't have to nest maps). As a result, it's trivial to prove a statement about the length being <code>choose n k</code></p>

<a name="162783794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/162783794" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#162783794">Mario Carneiro (Apr 08 2019 at 02:12)</a>:</h4>
<p>The proof is very combinatoric and constructive</p>

<a name="162783882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/162783882" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#162783882">Mario Carneiro (Apr 08 2019 at 02:15)</a>:</h4>
<p>You could actually stop there, but in the interest of getting closer to your version, I also lift the list function to a function on multisets and finsets. There isn't really any added content there, it's just restating facts in the new context. There are some additional observations to be made about how the list function preserves permutations and nodups so that the constructions lift, but that is relatively simple</p>

<a name="162783934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/162783934" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#162783934">Mario Carneiro (Apr 08 2019 at 02:16)</a>:</h4>
<p>The point I want to make is that I'm not proving a theorem, I'm constructing a function</p>

<a name="162784227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/162784227" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#162784227">Mario Carneiro (Apr 08 2019 at 02:24)</a>:</h4>
<p>It is possible that you are getting hung up on the strange definition <code>sublists_len_aux</code>. If so I would encourage you to ignore it and look only at <code>sublists_len_zero</code>, <code>sublists_len_succ_nil</code>, and <code>sublists_len_succ_cons</code> as the equation lemmas, because that's what they are</p>

<a name="162784609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/162784609" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#162784609">Kenny Lau (Apr 08 2019 at 02:35)</a>:</h4>
<p>it's a simple corollary of the orbit-stabilizer theorem... :P</p>

<a name="162791913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/162791913" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#162791913">Kevin Buzzard (Apr 08 2019 at 06:02)</a>:</h4>
<p>Stepping back a bit, I wonder whether dependent type theory is not really suited to combinatorial arguments like this, although I know sufficiently little about other formalisations of mathematics to know whether any of them would be any better. Something I learnt recently is that simple type theory seems to be not suitable for developing the theory of schemes, and I guess what's going on is that different formalisations of the foundations are better suited to different (possibly overlapping) areas.</p>

<a name="162791943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/162791943" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#162791943">Mario Carneiro (Apr 08 2019 at 06:03)</a>:</h4>
<p>Finite combinatorics is usually a strong point in DTT. That's why every introductory example has you doing stuff with nat</p>

<a name="162791996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/162791996" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#162791996">Mario Carneiro (Apr 08 2019 at 06:04)</a>:</h4>
<p>Type dependencies don't really come up here</p>

<a name="162792017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/162792017" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#162792017">Scott Morrison (Apr 08 2019 at 06:05)</a>:</h4>
<p>I think the problem in this example is more along the "programs / proofs" axis than the "DTT / something else" axis.</p>

<a name="162792024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/162792024" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#162792024">Scott Morrison (Apr 08 2019 at 06:06)</a>:</h4>
<p>Mario has written a "maths as programs" proof.</p>

<a name="162792145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/162792145" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#162792145">Kevin Buzzard (Apr 08 2019 at 06:08)</a>:</h4>
<p>Maybe type theory itself isn't suited to combinatorics?</p>

<a name="162792147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/162792147" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#162792147">Kevin Buzzard (Apr 08 2019 at 06:08)</a>:</h4>
<p>Would this all be easier in ZFC?</p>

<a name="162792451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/162792451" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#162792451">Mario Carneiro (Apr 08 2019 at 06:16)</a>:</h4>
<p>I can show you <a href="http://us2.metamath.org/mpeuni/hashbclem.html" target="_blank" title="http://us2.metamath.org/mpeuni/hashbclem.html">http://us2.metamath.org/mpeuni/hashbclem.html</a> but I don't think you are in a position to say whether this proof is easier or harder than the lean proof</p>

<a name="162792456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/162792456" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#162792456">Mario Carneiro (Apr 08 2019 at 06:16)</a>:</h4>
<p>It is most similar to Jeremy's proof</p>

<a name="162792537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/162792537" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#162792537">Mario Carneiro (Apr 08 2019 at 06:18)</a>:</h4>
<p>the core of the proof is construction of a bijection from <code>{ x \sub A | a e. x /\ #x = n + 1 }</code> to <code>{y \sub A | #y = n }</code> by showing that <code>x |-&gt; x / {a}</code> and <code>y |-&gt; y u. {a}</code> are inverse</p>

<a name="162792606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/binomial%20coefficients/near/162792606" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/90398binomialcoefficients.html#162792606">Mario Carneiro (Apr 08 2019 at 06:20)</a>:</h4>
<p>Personally, I prefer the "program" proof. The style could be mimicked in ZFC with a bunch of new definitions</p>


{% endraw %}

{% include archive_update.html %}