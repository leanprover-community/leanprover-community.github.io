---
layout: archive
title: Lean Prover Zulip Chat Archive 
permalink: archive/116395maths/06586groupcounterexample.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/06586groupcounterexample.html">group counterexample</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="148214352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/group%20counterexample/near/148214352" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/06586groupcounterexample.html#148214352">Kevin Buzzard (Nov 23 2018 at 07:59)</a>:</h4>
<p>Q1 part (i) on the 2nd year group theory sheet at Imperial (where <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">G</span></span></span></span> is a group throughout) is "True or false : If we can find elements <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.03588em;">g</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">h</span></span></span></span> in <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">G</span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>h</mi><mo>=</mo><mi>h</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">gh = hg</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">h</span><span class="mrel">=</span><span class="mord mathit">h</span><span class="mord mathit" style="margin-right:0.03588em;">g</span></span></span></span> then <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">G</span></span></span></span> is abelian."</p>
<p>So this is false, and <span class="user-mention" data-user-id="118107">@Amelia Livingston</span> and I were thinking about this question at Xena today. I wanted to formalise the question as closely as possible to the example sheet, so I wanted to write something like</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">q1p1</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">],</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">g</span> <span class="n">h</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">g</span> <span class="bp">*</span> <span class="n">h</span> <span class="bp">=</span> <span class="n">h</span> <span class="bp">*</span> <span class="n">g</span><span class="o">)</span> <span class="bp">→</span> <span class="n">is_abelian</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>


<p>You have to put the negation at the front of everything, so <code>group J</code> is after the colon and Lean doesn't know what <code>*</code> is. So version 2, which typechecks, is</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">q1p1</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">],</span> <span class="k">by</span> <span class="n">exactI</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">g</span> <span class="n">h</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">g</span> <span class="bp">*</span> <span class="n">h</span> <span class="bp">=</span> <span class="n">h</span> <span class="bp">*</span> <span class="n">g</span><span class="o">)</span> <span class="bp">→</span> <span class="n">is_abelian</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span>
</pre></div>


<p>But then we run into universe issues in the proof:</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">q1p1</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">],</span> <span class="k">by</span> <span class="n">exactI</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">g</span> <span class="n">h</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">g</span> <span class="bp">*</span> <span class="n">h</span> <span class="bp">=</span> <span class="n">h</span> <span class="bp">*</span> <span class="n">g</span><span class="o">)</span> <span class="bp">→</span> <span class="n">is_abelian</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">H</span>
  <span class="n">replace</span> <span class="n">H</span> <span class="o">:=</span> <span class="n">H</span> <span class="o">(</span><span class="n">perm</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">)),</span> <span class="c1">-- fails</span>
</pre></div>


<p>The error is</p>
<div class="codehilite"><pre><span></span>type mismatch at application
  H (perm (fin 3))
term
  perm (fin 3)
has type
  Type : Type 1
but is expected to have type
  Type u_1 : Type (u_1+1)
</pre></div>


<p>I guess I understand that we can't do much about the <code>by exactI</code> stuff, but why can't Lean resolve my universe metavariable? Am I accidentally claiming that there are counterexamples in every universe?</p>

<a name="148214469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/group%20counterexample/near/148214469" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/06586groupcounterexample.html#148214469">Johan Commelin (Nov 23 2018 at 08:01)</a>:</h4>
<p>Yes you are</p>

<a name="148214477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/group%20counterexample/near/148214477" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/06586groupcounterexample.html#148214477">Johan Commelin (Nov 23 2018 at 08:01)</a>:</h4>
<p>Take <code>G : Type</code> instead of <code>Type*</code>. I think that will help</p>

<a name="148216373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/group%20counterexample/near/148216373" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/06586groupcounterexample.html#148216373">Kevin Buzzard (Nov 23 2018 at 08:50)</a>:</h4>
<p>But isn't that cheating?</p>

<a name="148216392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/group%20counterexample/near/148216392" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/06586groupcounterexample.html#148216392">Kevin Buzzard (Nov 23 2018 at 08:51)</a>:</h4>
<p>How do I formalise the statement that it is not true that for all groups in all universes, some stupid thing holds</p>

<a name="148216435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/group%20counterexample/near/148216435" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/06586groupcounterexample.html#148216435">Kevin Buzzard (Nov 23 2018 at 08:52)</a>:</h4>
<p>I want the quantifier in the not</p>

<a name="148216437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/group%20counterexample/near/148216437" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/06586groupcounterexample.html#148216437">Kevin Buzzard (Nov 23 2018 at 08:52)</a>:</h4>
<p>The universe quantifier</p>

<a name="148217061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/group%20counterexample/near/148217061" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/06586groupcounterexample.html#148217061">Mario Carneiro (Nov 23 2018 at 09:08)</a>:</h4>
<p>impossible</p>

<a name="148217069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/group%20counterexample/near/148217069" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/06586groupcounterexample.html#148217069">Mario Carneiro (Nov 23 2018 at 09:08)</a>:</h4>
<p>that's existential quantification over universes</p>

<a name="148217081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/group%20counterexample/near/148217081" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/06586groupcounterexample.html#148217081">Mario Carneiro (Nov 23 2018 at 09:09)</a>:</h4>
<p>What you can do instead is show a counterexample in a particular universe, which of course implies the existential that you can't write</p>

<a name="148217369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/group%20counterexample/near/148217369" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/06586groupcounterexample.html#148217369">Kevin Buzzard (Nov 23 2018 at 09:16)</a>:</h4>
<p>So do I have to use <code>ulift</code> to get <code>replace H := H (perm (fin 3))</code> working? I've never used <code>ulift</code> before.</p>


{% endraw %}
