---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/116395maths/14020topologicalspacefromfilter.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html">topological space from filter</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="189325904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189325904" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189325904">Kevin Buzzard (Feb 28 2020 at 16:33)</a>:</h4>
<p>The argument I know to prove that if X is a top space and  X x Y -&gt; Y is a closed map for all Y then X is compact involves a topological structure on <code>option X</code> if X is a set with a filter on it. It looks like this:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">filter_topology</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="o">(</span><span class="n">option</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">is_open</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span><span class="o">,</span> <span class="k">if</span> <span class="n">none</span> <span class="err">∈</span> <span class="n">U</span> <span class="k">then</span> <span class="n">some</span> <span class="bp">⁻¹</span><span class="err">&#39;</span> <span class="n">U</span> <span class="err">∈</span> <span class="n">F</span> <span class="k">else</span> <span class="n">true</span><span class="o">,</span>
  <span class="n">is_open_univ</span> <span class="o">:=</span> <span class="k">begin</span>
    <span class="n">rw</span> <span class="n">if_pos</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">preimage_univ</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">filter</span><span class="bp">.</span><span class="n">univ_mem_sets</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">mem_univ</span> <span class="o">(</span><span class="n">none</span> <span class="o">:</span> <span class="n">option</span> <span class="n">X</span><span class="o">),</span>
  <span class="kn">end</span><span class="o">,</span>
  <span class="n">is_open_inter</span> <span class="o">:=</span> <span class="k">begin</span>
    <span class="n">intros</span> <span class="n">U</span> <span class="n">V</span> <span class="n">hU</span> <span class="n">hV</span><span class="o">,</span>
    <span class="n">split_ifs</span><span class="o">,</span> <span class="n">swap</span><span class="o">,</span> <span class="n">trivial</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">h0U</span> <span class="n">h0V</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">if_pos</span> <span class="n">at</span> <span class="n">hU</span><span class="o">,</span> <span class="n">swap</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h0U</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">if_pos</span> <span class="n">at</span> <span class="n">hV</span><span class="o">,</span> <span class="n">swap</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h0V</span><span class="o">,</span>
    <span class="k">show</span> <span class="n">some</span> <span class="bp">⁻¹</span><span class="err">&#39;</span> <span class="o">(</span><span class="n">U</span> <span class="err">∩</span> <span class="n">V</span><span class="o">)</span> <span class="err">∈</span> <span class="n">F</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">preimage_inter</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">F</span><span class="bp">.</span><span class="n">inter_sets</span> <span class="n">hU</span> <span class="n">hV</span><span class="o">,</span>
  <span class="kn">end</span><span class="o">,</span>
  <span class="n">is_open_sUnion</span> <span class="o">:=</span> <span class="k">begin</span>
    <span class="n">intros</span> <span class="n">I</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">hI</span><span class="o">,</span>
    <span class="n">split_ifs</span><span class="o">,</span> <span class="n">swap</span><span class="o">,</span> <span class="n">trivial</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">mem_sUnion</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">h</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">hU</span><span class="o">,</span> <span class="n">h0U</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">preimage_sUnion</span><span class="o">,</span>
    <span class="n">replace</span> <span class="n">hI</span> <span class="o">:=</span> <span class="n">hI</span> <span class="n">U</span> <span class="n">hU</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">if_pos</span> <span class="n">at</span> <span class="n">hI</span><span class="o">,</span> <span class="n">swap</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h0U</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">filter</span><span class="bp">.</span><span class="n">mem_sets_of_superset</span> <span class="n">hI</span> <span class="bp">_</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">subset_bUnion_of_mem</span> <span class="n">hU</span><span class="o">,</span>
  <span class="kn">end</span>
<span class="o">}</span>
</pre></div>


<p>Is that some well-known topological construction? Do we have it in mathlib?</p>

<a name="189325998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189325998" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189325998">Kevin Buzzard (Feb 28 2020 at 16:34)</a>:</h4>
<p>In short, X gets the discrete topology, and the neighbourhoods of the extra points are precisely (the point) + (element of the filter).</p>

<a name="189326205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189326205" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189326205">Reid Barton (Feb 28 2020 at 16:37)</a>:</h4>
<p>The one-point compactification is an instance of this construction, right? With F = the filter of sets whose complement has compact closure, or so?</p>

<a name="189326317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189326317" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189326317">Kevin Buzzard (Feb 28 2020 at 16:38)</a>:</h4>
<p>X has the discrete topology in my construction, I didn't think about whether it extended to a general top space. In this case F would be the cofinite filter.</p>

<a name="189326324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189326324" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189326324">Patrick Massot (Feb 28 2020 at 16:38)</a>:</h4>
<p>It is well-known, some (deviant) people define filters using it. I don't think it's in mathlib.</p>

<a name="189326326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189326326" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189326326">Reid Barton (Feb 28 2020 at 16:38)</a>:</h4>
<p>Ah yes, I just noticed that too</p>

<a name="189326542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189326542" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189326542">Kevin Buzzard (Feb 28 2020 at 16:41)</a>:</h4>
<p>If you know that X x Y -&gt; Y is a closed map for all Y, and you want to prove that X is compact, your problem is that you don't have a clue which Y to use. My first thought was to try Y=X, but I don't know whether it's true that S x S -&gt; S closed implies S compact and I kind of doubt it. The proof I know goes like this: let F be a proper filter on X, and we want to show that F has an adherent point. Let Y be the top space defined above (note: use discrete top on X even though X is a top space) and now consider the closure of the diagonal map {(x,x)}; its image is closed so must contain <code>*</code>, and if <code>(x,*)</code> is in X x Y in the closure of the diagonal then x does the job.</p>

<a name="189326688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189326688" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189326688">Reid Barton (Feb 28 2020 at 16:42)</a>:</h4>
<p>Good thing the computer scientists chose the definition of compact that they did right?</p>

<a name="189326702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189326702" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189326702">Kevin Buzzard (Feb 28 2020 at 16:42)</a>:</h4>
<p>Right!</p>

<a name="189326745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189326745" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189326745">Kevin Buzzard (Feb 28 2020 at 16:43)</a>:</h4>
<p>And in the proof the other way (showing that if X is compact then pr_2 is always closed) I never have to unfold the definition of compact because we have the tube lemma which is all I need.</p>

<a name="189327237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189327237" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189327237">Reid Barton (Feb 28 2020 at 16:48)</a>:</h4>
<p>The new point is always closed in this construction, right?</p>

<a name="189327263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189327263" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189327263">Reid Barton (Feb 28 2020 at 16:48)</a>:</h4>
<p>Your original one</p>

<a name="189327301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189327301" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189327301">Kevin Buzzard (Feb 28 2020 at 16:48)</a>:</h4>
<p>Yes I guess so. Any subset of X is open.</p>

<a name="189327335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189327335" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189327335">Kevin Buzzard (Feb 28 2020 at 16:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/116395-maths/topic/topological.20space.20from.20filter/near/189326688" title="#narrow/stream/116395-maths/topic/topological.20space.20from.20filter/near/189326688">said</a>:</p>
<blockquote>
<p>Good thing the computer scientists chose the definition of compact that they did right?</p>
</blockquote>
<p>I'm just counting myself lucky that they didn't <a href="https://math.stackexchange.com/a/1690753/443634" target="_blank" title="https://math.stackexchange.com/a/1690753/443634">use this approach</a></p>

<a name="189327876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189327876" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189327876">Reid Barton (Feb 28 2020 at 16:54)</a>:</h4>
<p>I'm guessing that there is a general construction that takes two topological spaces <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span></span> and tells you what data you need to write down (something like how the neighborhood filters of points of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span></span> look when intersected with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span></span>) to build a space <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><mi>U</mi><mo>∪</mo><mi>Z</mi></mrow><annotation encoding="application/x-tex">X = U \cup Z</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span></span> with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span></span> open and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span></span> its complement. Your construction would then be a special case of this where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span></span> is X with the discrete topology and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span></span> is a point.</p>

<a name="189327955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189327955" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189327955">Reid Barton (Feb 28 2020 at 16:55)</a>:</h4>
<p>Of course you will recognize this from algebraic geometry, I'm just not sure exactly what the right data is in this setting</p>

<a name="189336789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189336789" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189336789">Kevin Buzzard (Feb 28 2020 at 18:27)</a>:</h4>
<p>Here's the application:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">topology</span><span class="bp">.</span><span class="n">maps</span> <span class="n">topology</span><span class="bp">.</span><span class="n">subset_properties</span>

<span class="kn">example</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="mi">691</span>

<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kn">open</span> <span class="n">set</span>

<span class="c">/-</span><span class="cm">- If X is compact then pr₂ : X × Y → Y is a closed map -/</span>
<span class="kn">theorem</span> <span class="n">closed_pr2_of_compact</span>
  <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">compact_space</span> <span class="n">X</span><span class="o">]</span>
  <span class="o">{</span><span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">Y</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">is_closed_map</span> <span class="o">(</span><span class="n">prod</span><span class="bp">.</span><span class="n">snd</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">×</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span> <span class="n">C</span> <span class="n">hC</span><span class="o">,</span>
  <span class="n">rw</span> <span class="err">←</span><span class="n">is_open_compl_iff</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">is_open_iff_forall_mem_open</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">generalized_tube_lemma</span> <span class="o">(</span><span class="n">compact_univ</span> <span class="o">:</span> <span class="n">compact</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">))</span>
    <span class="o">(</span><span class="n">compact_singleton</span> <span class="o">:</span> <span class="n">compact</span> <span class="o">{</span><span class="n">y</span><span class="o">})</span> <span class="o">(</span><span class="n">is_open_compl_iff</span><span class="bp">.</span><span class="mi">2</span> <span class="n">hC</span><span class="o">)</span> <span class="bp">_</span> <span class="k">with</span>
    <span class="bp">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">V</span><span class="o">,</span> <span class="n">hU</span><span class="o">,</span> <span class="n">hV</span><span class="o">,</span> <span class="n">hXU</span><span class="o">,</span> <span class="n">hyV</span><span class="o">,</span> <span class="n">hUV</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">use</span> <span class="n">V</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rintros</span> <span class="n">v</span> <span class="n">hvV</span> <span class="bp">⟨</span><span class="n">uv</span><span class="o">,</span> <span class="n">huv</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span>
      <span class="n">revert</span> <span class="n">huv</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">hUV</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_prod</span><span class="o">,</span>
      <span class="n">split</span><span class="o">,</span>
        <span class="n">apply</span> <span class="n">hXU</span><span class="o">,</span> <span class="n">apply</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_univ</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">hvV</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="n">split</span><span class="o">,</span> <span class="n">exact</span> <span class="n">hV</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">hyV</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_singleton</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">xy</span> <span class="n">hxy</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">hxyC</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">hy</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">xy</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span> <span class="n">exact</span> <span class="n">hxyC</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">mem_prod</span> <span class="n">at</span> <span class="n">hxy</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">hxy</span> <span class="k">with</span> <span class="n">hx</span> <span class="n">hy</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">mem_singleton_iff</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hy</span><span class="o">,</span>
  <span class="o">}</span>
<span class="kn">end</span>

<span class="n">def</span> <span class="n">filter_topology</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="o">(</span><span class="n">option</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">is_open</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span><span class="o">,</span> <span class="k">if</span> <span class="n">none</span> <span class="err">∈</span> <span class="n">U</span> <span class="k">then</span> <span class="n">some</span> <span class="bp">⁻¹</span><span class="err">&#39;</span> <span class="n">U</span> <span class="err">∈</span> <span class="n">F</span> <span class="k">else</span> <span class="n">true</span><span class="o">,</span>
  <span class="n">is_open_univ</span> <span class="o">:=</span> <span class="k">begin</span>
    <span class="n">rw</span> <span class="n">if_pos</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">preimage_univ</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">filter</span><span class="bp">.</span><span class="n">univ_mem_sets</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">mem_univ</span> <span class="o">(</span><span class="n">none</span> <span class="o">:</span> <span class="n">option</span> <span class="n">X</span><span class="o">),</span>
  <span class="kn">end</span><span class="o">,</span>
  <span class="n">is_open_inter</span> <span class="o">:=</span> <span class="k">begin</span>
    <span class="n">intros</span> <span class="n">U</span> <span class="n">V</span> <span class="n">hU</span> <span class="n">hV</span><span class="o">,</span>
    <span class="n">split_ifs</span><span class="o">,</span> <span class="n">swap</span><span class="o">,</span> <span class="n">trivial</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">h0U</span> <span class="n">h0V</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">if_pos</span> <span class="n">at</span> <span class="n">hU</span><span class="o">,</span> <span class="n">swap</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h0U</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">if_pos</span> <span class="n">at</span> <span class="n">hV</span><span class="o">,</span> <span class="n">swap</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h0V</span><span class="o">,</span>
    <span class="k">show</span> <span class="n">some</span> <span class="bp">⁻¹</span><span class="err">&#39;</span> <span class="o">(</span><span class="n">U</span> <span class="err">∩</span> <span class="n">V</span><span class="o">)</span> <span class="err">∈</span> <span class="n">F</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">preimage_inter</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">F</span><span class="bp">.</span><span class="n">inter_sets</span> <span class="n">hU</span> <span class="n">hV</span><span class="o">,</span>
  <span class="kn">end</span><span class="o">,</span>
  <span class="n">is_open_sUnion</span> <span class="o">:=</span> <span class="k">begin</span>
    <span class="n">intros</span> <span class="n">I</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">hI</span><span class="o">,</span>
    <span class="n">split_ifs</span><span class="o">,</span> <span class="n">swap</span><span class="o">,</span> <span class="n">trivial</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">mem_sUnion</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">h</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">hU</span><span class="o">,</span> <span class="n">h0U</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">preimage_sUnion</span><span class="o">,</span>
    <span class="n">replace</span> <span class="n">hI</span> <span class="o">:=</span> <span class="n">hI</span> <span class="n">U</span> <span class="n">hU</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">if_pos</span> <span class="n">at</span> <span class="n">hI</span><span class="o">,</span> <span class="n">swap</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h0U</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">filter</span><span class="bp">.</span><span class="n">mem_sets_of_superset</span> <span class="n">hI</span> <span class="bp">_</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">subset_bUnion_of_mem</span> <span class="n">hU</span><span class="o">,</span>
  <span class="kn">end</span>
<span class="o">}</span>

<span class="c">/-</span><span class="cm">- Conversely, if pr₂ : X × Y → Y is a closed map for all Y then X is compact -/</span>
<span class="kn">instance</span> <span class="n">compact_space_of_closed_pr2</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span>
  <span class="o">(</span><span class="n">hclosed</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">Y</span><span class="o">],</span> <span class="n">is_closed_map</span> <span class="o">(</span><span class="n">prod</span><span class="bp">.</span><span class="n">snd</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">×</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">compact_space</span> <span class="n">X</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">constructor</span><span class="o">,</span>
  <span class="c1">-- we will show that every proper filter has an adherent point</span>
  <span class="n">intros</span> <span class="n">F</span> <span class="n">hF</span> <span class="n">h</span><span class="o">,</span> <span class="n">clear</span> <span class="n">h</span><span class="o">,</span>
  <span class="c1">-- Let Y be the topological space defined above (X + extra point with nhds F)</span>
  <span class="n">letI</span> <span class="o">:=</span> <span class="n">filter_topology</span> <span class="n">F</span><span class="o">,</span>
  <span class="n">replace</span> <span class="n">hclosed</span> <span class="o">:=</span> <span class="n">hclosed</span> <span class="o">(</span><span class="n">option</span> <span class="n">X</span><span class="o">),</span>
  <span class="c1">-- Let D be the closure of {(x,x)} in X × Y.</span>
  <span class="n">set</span> <span class="n">D</span> <span class="o">:=</span> <span class="n">closure</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="o">(</span><span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">some</span> <span class="n">x</span><span class="bp">⟩</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">×</span> <span class="n">option</span> <span class="n">X</span><span class="o">)))</span> <span class="k">with</span> <span class="n">hD</span><span class="o">,</span>
  <span class="c1">-- Its image in Y is closed.</span>
  <span class="n">replace</span> <span class="n">hclosed</span> <span class="o">:=</span> <span class="n">hclosed</span> <span class="n">D</span> <span class="o">(</span><span class="n">is_closed_closure</span><span class="o">),</span>
  <span class="c1">-- If the image contains the extra point</span>
  <span class="n">by_cases</span> <span class="n">hnone</span> <span class="o">:</span> <span class="n">none</span> <span class="err">∈</span> <span class="n">prod</span><span class="bp">.</span><span class="n">snd</span> <span class="err">&#39;&#39;</span> <span class="n">D</span><span class="o">,</span>
  <span class="o">{</span> <span class="c1">-- then (x, extra point) is in the closure of D</span>
    <span class="n">rcases</span> <span class="n">hnone</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">xy</span><span class="o">,</span> <span class="n">hxy</span><span class="o">,</span> <span class="n">hy</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="c1">-- and we claim this x works</span>
    <span class="n">use</span> <span class="n">xy</span><span class="bp">.</span><span class="n">fst</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span> <span class="n">exact</span> <span class="n">mem_univ</span> <span class="bp">_</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">hbot</span><span class="o">,</span>
    <span class="n">rw</span> <span class="err">←</span><span class="n">filter</span><span class="bp">.</span><span class="n">empty_in_sets_eq_bot</span> <span class="n">at</span> <span class="n">hbot</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">filter</span><span class="bp">.</span><span class="n">mem_inf_sets</span> <span class="n">at</span> <span class="n">hbot</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">hbot</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">A</span><span class="o">,</span> <span class="n">hA</span><span class="o">,</span> <span class="n">U</span><span class="o">,</span> <span class="n">hU</span><span class="o">,</span> <span class="n">hAU</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">subset_empty_iff</span> <span class="n">at</span> <span class="n">hAU</span><span class="o">,</span>
    <span class="n">revert</span> <span class="n">hAU</span><span class="o">,</span>
    <span class="n">change</span> <span class="n">A</span> <span class="err">∩</span> <span class="n">U</span> <span class="bp">≠</span> <span class="err">∅</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">set</span><span class="bp">.</span><span class="n">ne_empty_iff_nonempty</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">mem_nhds_sets_iff</span> <span class="n">at</span> <span class="n">hU</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">hU</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">U&#39;</span><span class="o">,</span> <span class="n">hU&#39;U</span><span class="o">,</span> <span class="n">hU&#39;</span><span class="o">,</span> <span class="n">hxyU&#39;</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">set</span> <span class="n">V</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">X</span> <span class="bp">×</span> <span class="n">option</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="n">set</span><span class="bp">.</span><span class="n">prod</span> <span class="n">U&#39;</span> <span class="o">(</span><span class="n">insert</span> <span class="n">none</span> <span class="o">(</span><span class="n">some</span> <span class="err">&#39;&#39;</span> <span class="n">A</span><span class="o">)),</span>
    <span class="k">have</span> <span class="n">hV</span> <span class="o">:</span> <span class="n">is_open</span> <span class="n">V</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">is_open_prod</span> <span class="n">hU&#39;</span><span class="o">,</span>
      <span class="n">change</span> <span class="k">if</span> <span class="n">none</span> <span class="err">∈</span> <span class="o">(</span><span class="n">insert</span> <span class="n">none</span> <span class="o">(</span><span class="n">some</span> <span class="err">&#39;&#39;</span> <span class="n">A</span><span class="o">))</span> <span class="k">then</span> <span class="n">some</span> <span class="bp">⁻¹</span><span class="err">&#39;</span> <span class="o">(</span><span class="n">insert</span> <span class="n">none</span> <span class="o">(</span><span class="n">some</span> <span class="err">&#39;&#39;</span> <span class="n">A</span><span class="o">))</span> <span class="err">∈</span> <span class="n">F</span> <span class="k">else</span> <span class="n">true</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">if_pos</span><span class="o">,</span>
        <span class="n">convert</span> <span class="n">hA</span> <span class="kn">using</span> <span class="mi">1</span><span class="o">,</span>
        <span class="n">ext</span> <span class="n">a</span><span class="o">,</span>
        <span class="n">simp</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">mem_insert</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hxyV</span> <span class="o">:</span> <span class="n">xy</span> <span class="err">∈</span> <span class="n">V</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">mem_prod</span><span class="o">,</span>
      <span class="n">split</span><span class="o">,</span> <span class="n">exact</span> <span class="n">hxyU&#39;</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">hy</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">mem_insert</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">hD</span> <span class="n">at</span> <span class="n">hxy</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">mem_closure_iff</span> <span class="n">at</span> <span class="n">hxy</span><span class="o">,</span>
    <span class="n">replace</span> <span class="n">hxy</span> <span class="o">:=</span> <span class="n">hxy</span> <span class="n">V</span> <span class="n">hV</span> <span class="n">hxyV</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">hxy</span> <span class="k">with</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="n">hp</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">p</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">mem_prod</span> <span class="n">at</span> <span class="n">hp</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">hp</span> <span class="k">with</span> <span class="n">hpU</span> <span class="n">hpA</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span>
      <span class="n">change</span> <span class="n">some</span> <span class="n">p</span> <span class="err">∈</span> <span class="bp">_</span> <span class="n">at</span> <span class="n">hpA</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">mem_insert_iff</span> <span class="n">at</span> <span class="n">hpA</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">hpA</span><span class="o">,</span> <span class="n">cases</span> <span class="n">hpA</span><span class="o">,</span>
      <span class="n">rcases</span> <span class="n">hpA</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">p&#39;</span><span class="o">,</span> <span class="n">hp&#39;</span><span class="o">,</span> <span class="n">hpp&#39;</span><span class="bp">⟩</span><span class="o">,</span>
      <span class="n">convert</span> <span class="n">hp&#39;</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">option</span><span class="bp">.</span><span class="n">some_inj</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hpp&#39;</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">hU&#39;U</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">hpU</span>
  <span class="o">},</span>
  <span class="o">{</span> <span class="c1">-- And if the image doesn&#39;t contain the extra point then</span>
    <span class="c1">-- in fact we can get a contradiction.</span>
    <span class="n">exfalso</span><span class="o">,</span>
    <span class="c1">-- Indeed X is a subset of the image because (x,x) ∈ D</span>
    <span class="k">have</span> <span class="n">hX</span> <span class="o">:</span> <span class="n">range</span> <span class="n">some</span> <span class="err">⊆</span> <span class="n">prod</span><span class="bp">.</span><span class="n">snd</span> <span class="err">&#39;&#39;</span> <span class="n">D</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rintros</span> <span class="bp">_</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span>
      <span class="n">use</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">some</span> <span class="n">x</span><span class="bp">⟩</span><span class="o">,</span>
      <span class="n">split</span><span class="o">,</span> <span class="n">swap</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">subset_closure</span><span class="o">,</span>
      <span class="n">use</span> <span class="n">x</span>
    <span class="o">},</span>
    <span class="n">rw</span> <span class="err">←</span><span class="n">is_open_compl_iff</span> <span class="n">at</span> <span class="n">hclosed</span><span class="o">,</span>
    <span class="n">change</span> <span class="k">if</span> <span class="n">none</span> <span class="err">∈</span> <span class="bp">-</span><span class="o">(</span><span class="n">prod</span><span class="bp">.</span><span class="n">snd</span> <span class="err">&#39;&#39;</span> <span class="n">D</span><span class="o">)</span> <span class="k">then</span> <span class="n">some</span> <span class="bp">⁻¹</span><span class="err">&#39;</span> <span class="bp">-</span><span class="o">(</span><span class="n">prod</span><span class="bp">.</span><span class="n">snd</span> <span class="err">&#39;&#39;</span> <span class="n">D</span><span class="o">)</span> <span class="err">∈</span> <span class="n">F</span>
      <span class="k">else</span> <span class="n">true</span> <span class="n">at</span> <span class="n">hclosed</span><span class="o">,</span>
    <span class="n">replace</span> <span class="n">hnone</span> <span class="o">:=</span> <span class="n">mem_compl</span> <span class="n">hnone</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">if_pos</span> <span class="n">hnone</span> <span class="n">at</span> <span class="n">hclosed</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">hF</span><span class="o">,</span>
    <span class="n">rw</span> <span class="err">←</span><span class="n">filter</span><span class="bp">.</span><span class="n">empty_in_sets_eq_bot</span><span class="o">,</span>
    <span class="n">convert</span> <span class="n">hclosed</span><span class="o">,</span>
    <span class="n">symmetry</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">eq_empty_iff_forall_not_mem</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">hx</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">hX</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">x</span><span class="o">,</span>
  <span class="o">}</span>
<span class="kn">end</span>
</pre></div>


<p>I have said before that I feel like I write Lean code like a child, just stepping through carefully with each basic tactic. I never really get stuck any more and I really enjoy going through these sorts of proofs in Lean. But what should I be doing to make my Lean code better? I kind of suspect that (a) this result would be fine to put in mathlib but (b) this proof would be not acceptable.</p>

<a name="189338780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189338780" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189338780">Scott Morrison (Feb 28 2020 at 18:46)</a>:</h4>
<p>Maybe golf some bits into term mode? I remain unconvinced that the proofs get better, but they certainly get shorter and that makes me feel more grown-up. :-)</p>

<a name="189338815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189338815" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189338815">Scott Morrison (Feb 28 2020 at 18:46)</a>:</h4>
<p>I doubt the last one should be an <code>instance</code>, as the <code>hclosed</code> argument can't be found by typeclass search.</p>

<a name="189338963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189338963" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189338963">Scott Morrison (Feb 28 2020 at 18:48)</a>:</h4>
<p>I like shorter proofs, with more lemmas, so another stage of golfing might be to do that. e.g. prove that last result in the special case <code>Y =  (option X)</code>, then deduce the universally quantified one from it trivially. You could also separate the two branches of <code>by_cases</code> into lemmas, I guess.</p>

<a name="189339053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189339053" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189339053">Scott Morrison (Feb 28 2020 at 18:49)</a>:</h4>
<p>I would certainly add more braces: you're using pythonic indenting to simulate proper braces. :-)</p>

<a name="189339210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189339210" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189339210">Scott Morrison (Feb 28 2020 at 18:51)</a>:</h4>
<p>But I think it's pretty reasonable. We should have more "all tactics" proofs in mathlib, to reduce the stigma. You do you! :-)</p>

<a name="189349295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189349295" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189349295">Jalex Stark (Feb 28 2020 at 20:47)</a>:</h4>
<p>I think proof irrelevance means that "add a good theorem to mathlib with an okay proof" is a good contribution, and then later someone else could make a good contribution by improving the proof?<br>
Also as a new user I feel like "read mathlib" is one of the main strategies I have to get better at theory building, and I imagine that the code Kevin just wrote is easier for me to learn from than whatever we get after some code golfing.</p>

<a name="189349438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189349438" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189349438">Jalex Stark (Feb 28 2020 at 20:48)</a>:</h4>
<p>I guess it's somewhat open how pedagogical the code in mathlib is supposed to be, but I think making it more pedagogical speeds up community growth</p>

<a name="189350047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189350047" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189350047">Kevin Buzzard (Feb 28 2020 at 20:55)</a>:</h4>
<p>I don't really understand the mathlib principles which in some sense are maximally anti-pedagogical. The job of the library is not to teach. Because I'm not a programmer I don't really question the principles behind it all. I think there is a place for code which teaches but I'm pretty sure that it isn't mathlib</p>

<a name="189357373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189357373" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189357373">Reid Barton (Feb 28 2020 at 22:28)</a>:</h4>
<p>By the way, isn't there a version of this for proper maps?</p>

<a name="189360896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189360896" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189360896">Kevin Buzzard (Feb 28 2020 at 23:17)</a>:</h4>
<p>You mean in algebraic geometry? Yes, that's why I got interested in the result. I proved it for projective morphisms today in class and realised that I didn't actually know the proof of this topological variant</p>

<a name="189361342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189361342" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189361342">Reid Barton (Feb 28 2020 at 23:24)</a>:</h4>
<p>Even in topology (proper = preimage of compact is compact)</p>

<a name="189369615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189369615" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189369615">Reid Barton (Feb 29 2020 at 01:50)</a>:</h4>
<p>I guess the direction "<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f : X \to Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> universally closed implies <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span> proper" follows from what you did already. (It would certainly suffice to show that if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo lspace="0em" mathvariant="normal" rspace="0em">′</mo></msup><mo>:</mo><msup><mi>X</mi><mo lspace="0em" mathvariant="normal" rspace="0em">′</mo></msup><mo>→</mo><msup><mi>Y</mi><mo lspace="0em" mathvariant="normal" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">f' : X' \to Y'</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> is a pullback of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span> with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>Y</mi><mo lspace="0em" mathvariant="normal" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">Y'</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> compact, then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>X</mi><mo lspace="0em" mathvariant="normal" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">X'</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> is compact. But <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo lspace="0em" mathvariant="normal" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">f'</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> is again universally closed, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>Y</mi><mo lspace="0em" mathvariant="normal" rspace="0em">′</mo></msup><mo>→</mo><mo>∗</mo></mrow><annotation encoding="application/x-tex">Y' \to *</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord">∗</span></span></span></span> is universally closed because <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>Y</mi><mo lspace="0em" mathvariant="normal" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">Y'</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> is compact, so <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>X</mi><mo lspace="0em" mathvariant="normal" rspace="0em">′</mo></msup><mo>→</mo><mo>∗</mo></mrow><annotation encoding="application/x-tex">X' \to *</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord">∗</span></span></span></span> is universally closed and therefore <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>X</mi><mo lspace="0em" mathvariant="normal" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">X'</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> is compact.) I didn't think about the other direction.</p>

<a name="189390280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189390280" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189390280">Patrick Massot (Feb 29 2020 at 13:20)</a>:</h4>
<p>I had a look at local simplification in Kevin's proof. One option is to use more automation, without changing the structure of the proof. I think the main problem of Kevin's approach is not cleaning tactic state after applying the tube lemma. Here the algorithm can be to use <code>simp at *</code>, look at tactic state and then reproduce it with a more civilized method. This brings you to:</p>
<div class="codehilite"><pre><span></span><span class="c">/-</span><span class="cm">- If X is compact then pr₂ : X × Y → Y is a closed map -/</span>
<span class="kn">theorem</span> <span class="n">closed_pr2_of_compact</span>
  <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">compact_space</span> <span class="n">X</span><span class="o">]</span>
  <span class="o">{</span><span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">Y</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">is_closed_map</span> <span class="o">(</span><span class="n">prod</span><span class="bp">.</span><span class="n">snd</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">×</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span> <span class="n">C</span> <span class="n">hC</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="err">←</span><span class="n">is_open_compl_iff</span><span class="o">,</span> <span class="n">is_open_iff_forall_mem_open</span><span class="o">],</span>
  <span class="n">intros</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span>

  <span class="n">rcases</span> <span class="n">generalized_tube_lemma</span> <span class="o">(</span><span class="n">compact_univ</span> <span class="o">:</span> <span class="n">compact</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">))</span>
    <span class="o">(</span><span class="n">compact_singleton</span> <span class="o">:</span> <span class="n">compact</span> <span class="o">{</span><span class="n">y</span><span class="o">})</span> <span class="o">(</span><span class="n">is_open_compl_iff</span><span class="bp">.</span><span class="mi">2</span> <span class="n">hC</span><span class="o">)</span> <span class="bp">_</span> <span class="k">with</span>
    <span class="bp">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">V</span><span class="o">,</span> <span class="n">hU</span><span class="o">,</span> <span class="n">hV</span><span class="o">,</span> <span class="n">hXU</span><span class="o">,</span> <span class="n">hyV</span><span class="o">,</span> <span class="n">hUV</span><span class="bp">⟩</span><span class="o">,</span>

  <span class="o">{</span> <span class="c1">-- The next three lines were found by typing `simp at *` and then noticing</span>
    <span class="c1">-- univ_subset_iff is mysteriously not a simp lemma</span>
    <span class="n">replace</span> <span class="n">hy</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">),</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="err">∉</span> <span class="n">C</span><span class="o">,</span> <span class="k">by</span> <span class="n">simpa</span> <span class="kn">using</span> <span class="n">hy</span><span class="o">,</span>
    <span class="n">replace</span> <span class="n">hXU</span> <span class="o">:</span> <span class="n">U</span> <span class="bp">=</span> <span class="n">univ</span><span class="o">,</span> <span class="k">by</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">univ_subset_iff</span><span class="o">]</span> <span class="kn">using</span> <span class="n">hXU</span><span class="o">,</span>
    <span class="n">replace</span> <span class="n">hyV</span> <span class="o">:</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">V</span><span class="o">,</span> <span class="k">by</span> <span class="n">simpa</span> <span class="kn">using</span> <span class="n">hyV</span><span class="o">,</span>
    <span class="n">refine</span> <span class="bp">⟨</span><span class="n">V</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="k">by</span> <span class="n">assumption</span><span class="o">,</span> <span class="k">by</span> <span class="n">assumption</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">rintros</span> <span class="n">v</span> <span class="n">hvV</span> <span class="bp">⟨</span><span class="n">uv</span><span class="o">,</span> <span class="n">huv</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">revert</span> <span class="n">huv</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">hUV</span><span class="o">,</span>
    <span class="n">finish</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">xy</span> <span class="n">hxy</span> <span class="n">hxyC</span><span class="o">,</span>
    <span class="n">rw</span> <span class="err">←</span> <span class="o">(</span><span class="k">show</span> <span class="n">xy</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">=</span> <span class="n">y</span><span class="o">,</span> <span class="k">by</span> <span class="n">simpa</span> <span class="kn">using</span> <span class="n">hxy</span><span class="o">)</span> <span class="n">at</span> <span class="n">hy</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">hy</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">xy</span><span class="o">,</span>
    <span class="n">finish</span><span class="o">,</span> <span class="o">}</span>
<span class="kn">end</span>
</pre></div>

<a name="189390287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189390287" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189390287">Patrick Massot (Feb 29 2020 at 13:21)</a>:</h4>
<p>(this is using the same imports as in Kevin's message)</p>

<a name="189390357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189390357" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189390357">Patrick Massot (Feb 29 2020 at 13:23)</a>:</h4>
<p>This is probably using too much automation for mathlib's taste. But this discussion is a red herring. mathlib also has a mathematical taste. In topology this taste dictates one shouldn't fear filters and lattices. I'll write a filtery proof next.</p>

<a name="189390976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189390976" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189390976">Sebastien Gouezel (Feb 29 2020 at 13:45)</a>:</h4>
<p>May I suggest to replace the big <code>rcases</code> with an <code>obtain</code> to improve readability?</p>

<a name="189391098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189391098" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189391098">Patrick Massot (Feb 29 2020 at 13:49)</a>:</h4>
<p>The readable proof will be the filter one. I've worked it out on paper, but I need to go so I'll Lean later.</p>

<a name="189397021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189397021" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189397021">Patrick Massot (Feb 29 2020 at 16:59)</a>:</h4>
<p>Let's come back to this closed map question. Remember the statement : if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> is compact the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mi>Y</mi></msub><mo>:</mo><mi>X</mi><mo>×</mo><mi>Y</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">\pi_Y : X \times Y \to Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">Y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> is a closed map for every <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span>. Now let's assume <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> or <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> are metric spaces (or any other kind of spaces whose topology is entirely seen by sequences). Then the proof is:</p>
<ol>
<li>Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> be a closed subset of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>×</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X\times Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span>, and let's prove <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mi>Y</mi></msub><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_Y(C)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">Y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mclose">)</span></span></span></span> is closed.</li>
<li>Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> be a point in the closure of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mi>Y</mi></msub><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_Y(C)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">Y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mclose">)</span></span></span></span></li>
<li>Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">v_n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> be a sequence in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mi>Y</mi></msub><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_Y(C)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">Y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mclose">)</span></span></span></span> converging to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span></li>
<li>By definition of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mi>Y</mi></msub><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_Y(C)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">Y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mclose">)</span></span></span></span>, there is a sequence <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">u_n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>u</mi><mi>n</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo>∈</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">(u_n, v_n) \in C</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span></li>
<li>By compactness of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>, wlog <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">u_n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> converges to some <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span></li>
<li>Because <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> is closed the limit <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x, y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>u</mi><mi>n</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(u_n, v_n)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> belongs to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span></li>
<li>Hence <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><msub><mi>π</mi><mi>Y</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y = \pi_Y(x, y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">Y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> belongs to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span>.</li>
</ol>

<a name="189397202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189397202" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189397202">Patrick Massot (Feb 29 2020 at 17:05)</a>:</h4>
<p>Now we need to do the general case. Remember filter replace sequences. More precisely a sequence <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> gives a filter <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mo>∗</mo></msub><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">u_*\infty</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.175696em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∞</span></span></span></span> where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord">∞</span></span></span></span> is the <code>at_top</code> filter on natural numbers. Saying that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">v_n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> belongs to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mi>Y</mi></msub><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_Y(C)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">Y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mclose">)</span></span></span></span> for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> large enough is equivalent to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mo>∗</mo></msub><mi mathvariant="normal">∞</mi><mo>≤</mo><mi>P</mi><mo stretchy="false">(</mo><msub><mi>π</mi><mi>Y</mi></msub><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">v_*\infty \leq P(\pi_Y(C))</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.175696em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∞</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">Y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span> means <code>principal</code>. In particular the existence of $v$ converging in Step 3 implies <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">N</mi><mi>y</mi></msub><mo>⊓</mo><mi>P</mi><mo stretchy="false">(</mo><msub><mi>π</mi><mi>Y</mi></msub><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{N}_y \sqcap P(\pi_Y(C))</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.14736em;">N</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊓</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">Y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> is proper. In the general case, Step 3 is replaced by this conclusion: <code>𝓝 y ⊓ 𝓟 (πY '' C) ≠ ⊥</code></p>

<a name="189397429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189397429" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189397429">Patrick Massot (Feb 29 2020 at 17:12)</a>:</h4>
<p>Step 4 is a bit more tricky. You need to understand the analogue is upgrade Step 3 to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>π</mi><mi>Y</mi><mo>∗</mo></msubsup><msub><mi mathvariant="script">N</mi><mi>y</mi></msub><mo>⊔</mo><mi>P</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo><mo mathvariant="normal">≠</mo><mi mathvariant="normal">⊥</mi></mrow><annotation encoding="application/x-tex">\pi_Y^*\mathcal{N}_y \sqcup P(C) \neq \bot</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.974804em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-2.424669em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">Y</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.275331em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.14736em;">N</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊔</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">⊥</span></span></span></span>. Here you need the push-pull formula: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mo>∗</mo></msub><mo stretchy="false">(</mo><mi>F</mi><mo>⊓</mo><msup><mi>f</mi><mo>∗</mo></msup><mi>G</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>f</mi><mo>∗</mo></msub><mi>F</mi><mo>⊓</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">f_*(F \sqcap f^<em>G) = f_</em>F \sqcap G</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.175696em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊓</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mord mathdefault">G</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.175696em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊓</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span>.</p>

<a name="189397479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189397479" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189397479">Patrick Massot (Feb 29 2020 at 17:14)</a>:</h4>
<p>Step 5 is straightforward, compactness of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> implies <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>π</mi><mi>X</mi></msub><msub><mo stretchy="false">)</mo><mo>∗</mo></msub><mo stretchy="false">(</mo><msubsup><mi>π</mi><mi>Y</mi><mo>∗</mo></msubsup><msub><mi mathvariant="script">N</mi><mi>y</mi></msub><mo>⊓</mo><mi>P</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\pi_X)_* (\pi_Y^*\mathcal{N}_y \sqcap P(C))</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.175696em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-2.424669em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">Y</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.275331em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.14736em;">N</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊓</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> has a cluster point <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>.</p>

<a name="189397484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189397484" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189397484">Patrick Massot (Feb 29 2020 at 17:14)</a>:</h4>
<p>Then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x, y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> is in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> because <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> is closed.</p>

<a name="189397498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189397498" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189397498">Patrick Massot (Feb 29 2020 at 17:15)</a>:</h4>
<p>I need to run, I'll paste the Lean code later.</p>

<a name="189401247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189401247" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189401247">Patrick Massot (Feb 29 2020 at 19:01)</a>:</h4>
<p>First one needs to fill weird holes in the library (or be better at finding stuff). I'm pretty sure some of those are somewhere buried in the perfectoid project, we need to go back PRing.</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">topology</span><span class="bp">.</span><span class="n">maps</span> <span class="n">topology</span><span class="bp">.</span><span class="n">subset_properties</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">apply_fun</span>

<span class="kn">open</span> <span class="n">set</span> <span class="n">filter</span> <span class="n">function</span> <span class="n">lattice</span>
<span class="n">open_locale</span> <span class="n">classical</span> <span class="n">topological_space</span>


<span class="kn">lemma</span> <span class="n">cluster_point_of_compact</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">compact_space</span> <span class="n">X</span><span class="o">]</span>
  <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">≠</span> <span class="err">⊥</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="err">⊓</span> <span class="err">𝓝</span> <span class="n">x</span> <span class="bp">≠</span> <span class="err">⊥</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">simpa</span> <span class="kn">using</span> <span class="n">compact_univ</span> <span class="n">f</span> <span class="n">h</span> <span class="o">(</span><span class="k">by</span> <span class="n">simpa</span> <span class="kn">using</span> <span class="n">f</span><span class="bp">.</span><span class="n">univ_sets</span><span class="o">)</span>

<span class="c1">-- Not in library?!?</span>
<span class="kn">lemma</span> <span class="n">set</span><span class="bp">.</span><span class="n">image_inter_subset</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f</span> <span class="err">&#39;&#39;</span> <span class="o">(</span><span class="n">s</span> <span class="err">∩</span> <span class="n">t</span><span class="o">)</span> <span class="err">⊆</span> <span class="n">f</span> <span class="err">&#39;&#39;</span> <span class="n">s</span> <span class="err">∩</span> <span class="n">f</span> <span class="err">&#39;&#39;</span> <span class="n">t</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rintro</span> <span class="bp">_</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">xs</span><span class="o">,</span> <span class="n">xt</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">exact</span> <span class="bp">⟨</span><span class="n">mem_image_of_mem</span> <span class="bp">_</span> <span class="n">xs</span><span class="o">,</span><span class="n">mem_image_of_mem</span> <span class="bp">_</span> <span class="n">xt</span><span class="bp">⟩</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">set</span><span class="bp">.</span><span class="n">push_pull</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
<span class="n">f</span> <span class="err">&#39;&#39;</span> <span class="o">(</span><span class="n">s</span> <span class="err">∩</span> <span class="n">f</span> <span class="bp">⁻¹</span><span class="err">&#39;</span> <span class="n">t</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="err">&#39;&#39;</span> <span class="n">s</span> <span class="err">∩</span> <span class="n">t</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">apply</span> <span class="n">subset</span><span class="bp">.</span><span class="n">antisymm</span><span class="o">,</span>
  <span class="o">{</span> <span class="k">calc</span> <span class="n">f</span> <span class="err">&#39;&#39;</span> <span class="o">(</span><span class="n">s</span> <span class="err">∩</span> <span class="n">f</span> <span class="bp">⁻¹</span><span class="err">&#39;</span> <span class="n">t</span><span class="o">)</span> <span class="err">⊆</span> <span class="n">f</span> <span class="err">&#39;&#39;</span> <span class="n">s</span> <span class="err">∩</span> <span class="o">(</span><span class="n">f</span> <span class="err">&#39;&#39;</span> <span class="o">(</span><span class="n">f</span><span class="bp">⁻¹</span><span class="err">&#39;</span> <span class="n">t</span><span class="o">))</span> <span class="o">:</span> <span class="n">image_inter_subset</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span>
  <span class="bp">...</span> <span class="err">⊆</span> <span class="n">f</span> <span class="err">&#39;&#39;</span> <span class="n">s</span> <span class="err">∩</span> <span class="n">t</span> <span class="o">:</span> <span class="n">inter_subset_inter_right</span> <span class="bp">_</span> <span class="o">(</span><span class="n">image_preimage_subset</span> <span class="n">f</span> <span class="n">t</span><span class="o">)</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintros</span> <span class="bp">_</span> <span class="bp">⟨⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">h&#39;</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">h</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">finish</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">lattice</span><span class="bp">.</span><span class="n">inf_le_inf_left</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semilattice_inf</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="n">c</span><span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span><span class="o">):</span> <span class="n">b</span> <span class="err">⊓</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">c</span> <span class="err">⊓</span> <span class="n">a</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">finish</span>

<span class="kn">lemma</span> <span class="n">lattice</span><span class="bp">.</span><span class="n">inf_le_inf_right</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semilattice_inf</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="n">c</span><span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span><span class="o">):</span> <span class="n">a</span> <span class="err">⊓</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span> <span class="err">⊓</span> <span class="n">c</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">finish</span>

<span class="kn">open</span> <span class="n">lattice</span>

<span class="kn">lemma</span> <span class="n">filter</span><span class="bp">.</span><span class="n">push_pull</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
<span class="n">map</span> <span class="n">f</span> <span class="o">(</span><span class="n">F</span> <span class="err">⊓</span> <span class="n">comap</span> <span class="n">f</span> <span class="n">G</span><span class="o">)</span> <span class="bp">=</span> <span class="n">map</span> <span class="n">f</span> <span class="n">F</span> <span class="err">⊓</span> <span class="n">G</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">apply</span> <span class="n">le_antisymm</span><span class="o">,</span>
  <span class="o">{</span> <span class="k">calc</span> <span class="n">map</span> <span class="n">f</span> <span class="o">(</span><span class="n">F</span> <span class="err">⊓</span> <span class="n">comap</span> <span class="n">f</span> <span class="n">G</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">map</span> <span class="n">f</span> <span class="n">F</span> <span class="err">⊓</span> <span class="o">(</span><span class="n">map</span> <span class="n">f</span> <span class="err">$</span> <span class="n">comap</span> <span class="n">f</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">map_inf_le</span>
      <span class="bp">...</span> <span class="bp">≤</span> <span class="n">map</span> <span class="n">f</span> <span class="n">F</span> <span class="err">⊓</span> <span class="n">G</span> <span class="o">:</span> <span class="n">inf_le_inf_right</span> <span class="o">(</span><span class="n">map</span> <span class="n">f</span> <span class="n">F</span><span class="o">)</span> <span class="n">map_comap_le</span> <span class="o">},</span>
  <span class="o">{</span>
    <span class="n">rintros</span> <span class="n">U</span> <span class="bp">⟨</span><span class="n">V</span><span class="o">,</span> <span class="n">V_in</span><span class="o">,</span> <span class="n">W</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">Z</span><span class="o">,</span> <span class="n">Z_in</span><span class="o">,</span> <span class="n">hZ</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">h</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">rw</span> <span class="err">←</span> <span class="n">image_subset_iff</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">mem_inf_sets</span><span class="o">,</span>
    <span class="n">use</span> <span class="o">[</span><span class="n">f</span> <span class="err">&#39;&#39;</span> <span class="n">V</span><span class="o">,</span> <span class="n">image_mem_map</span> <span class="n">V_in</span><span class="o">,</span> <span class="n">Z</span><span class="o">,</span> <span class="n">Z_in</span><span class="o">],</span>
    <span class="n">refine</span> <span class="n">subset</span><span class="bp">.</span><span class="n">trans</span> <span class="bp">_</span> <span class="n">h</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:</span> <span class="n">f</span> <span class="err">&#39;&#39;</span> <span class="o">(</span><span class="n">V</span> <span class="err">∩</span> <span class="n">f</span> <span class="bp">⁻¹</span><span class="err">&#39;</span> <span class="n">Z</span><span class="o">)</span> <span class="err">⊆</span> <span class="n">f</span> <span class="err">&#39;&#39;</span> <span class="o">(</span><span class="n">V</span> <span class="err">∩</span> <span class="n">W</span><span class="o">),</span>
    <span class="o">{</span> <span class="n">apply</span> <span class="n">image_subset</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">inter_subset_inter_right</span> <span class="bp">_</span> <span class="err">‹</span><span class="bp">_</span><span class="err">›</span><span class="o">,</span> <span class="o">},</span>
    <span class="n">rwa</span> <span class="n">set</span><span class="bp">.</span><span class="n">push_pull</span> <span class="n">at</span> <span class="n">this</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">filter</span><span class="bp">.</span><span class="n">push_pull&#39;</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
<span class="n">map</span> <span class="n">f</span> <span class="o">(</span><span class="n">comap</span> <span class="n">f</span> <span class="n">G</span> <span class="err">⊓</span> <span class="n">F</span><span class="o">)</span> <span class="bp">=</span> <span class="n">G</span> <span class="err">⊓</span> <span class="n">map</span> <span class="n">f</span> <span class="n">F</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">filter</span><span class="bp">.</span><span class="n">push_pull</span><span class="o">,</span> <span class="n">inf_comm</span><span class="o">]</span>

<span class="kn">lemma</span> <span class="n">filter</span><span class="bp">.</span><span class="n">ne_bot_of_map_ne_bot</span>  <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">map</span> <span class="n">f</span> <span class="n">F</span> <span class="bp">≠</span> <span class="err">⊥</span><span class="o">)</span> <span class="o">:</span> <span class="n">F</span> <span class="bp">≠</span> <span class="err">⊥</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">map_bot</span>
<span class="kn">end</span>
</pre></div>

<a name="189401260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189401260" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189401260">Patrick Massot (Feb 29 2020 at 19:01)</a>:</h4>
<p>Then one can prove Kevin's theorem:</p>
<div class="codehilite"><pre><span></span><span class="n">local</span> <span class="kn">notation</span> <span class="bp">`</span><span class="err">𝓟</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">principal</span>
<span class="n">local</span> <span class="kn">infix</span> <span class="bp">`×</span><span class="err">ᶠ</span><span class="bp">`</span><span class="o">:</span><span class="mi">55</span> <span class="o">:=</span> <span class="n">filter</span><span class="bp">.</span><span class="n">prod</span>

<span class="c">/-</span><span class="cm">- If X is compact then pr₂ : X × Y → Y is a closed map -/</span>
<span class="kn">theorem</span> <span class="n">closed_pr2_of_compact&#39;</span>
  <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">compact_space</span> <span class="n">X</span><span class="o">]</span>
  <span class="o">{</span><span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">Y</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">is_closed_map</span> <span class="o">(</span><span class="n">prod</span><span class="bp">.</span><span class="n">snd</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">×</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">set</span> <span class="n">πX</span> <span class="o">:=</span> <span class="o">(</span><span class="n">prod</span><span class="bp">.</span><span class="n">fst</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">×</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">X</span><span class="o">),</span>
  <span class="n">set</span> <span class="n">πY</span> <span class="o">:=</span> <span class="o">(</span><span class="n">prod</span><span class="bp">.</span><span class="n">snd</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">×</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">),</span>
  <span class="k">assume</span> <span class="n">C</span> <span class="o">(</span><span class="n">hC</span> <span class="o">:</span> <span class="n">is_closed</span> <span class="n">C</span><span class="o">),</span>
  <span class="n">rw</span> <span class="n">is_closed_iff_nhds</span> <span class="n">at</span> <span class="n">hC</span> <span class="err">⊢</span><span class="o">,</span>
  <span class="k">assume</span> <span class="n">y</span> <span class="o">(</span><span class="n">y_closure</span> <span class="o">:</span> <span class="err">𝓝</span> <span class="n">y</span> <span class="err">⊓</span> <span class="err">𝓟</span> <span class="o">(</span><span class="n">πY</span> <span class="err">&#39;&#39;</span> <span class="n">C</span><span class="o">)</span> <span class="bp">≠</span> <span class="err">⊥</span><span class="o">),</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">map</span> <span class="n">πX</span> <span class="o">(</span><span class="n">comap</span> <span class="n">πY</span> <span class="o">(</span><span class="err">𝓝</span> <span class="n">y</span><span class="o">)</span> <span class="err">⊓</span> <span class="err">𝓟</span> <span class="n">C</span><span class="o">)</span> <span class="bp">≠</span> <span class="err">⊥</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">suffices</span> <span class="o">:</span> <span class="n">map</span> <span class="n">πY</span> <span class="o">(</span><span class="n">comap</span> <span class="n">πY</span> <span class="o">(</span><span class="err">𝓝</span> <span class="n">y</span><span class="o">)</span> <span class="err">⊓</span> <span class="err">𝓟</span> <span class="n">C</span><span class="o">)</span> <span class="bp">≠</span> <span class="err">⊥</span><span class="o">,</span>
      <span class="k">from</span> <span class="n">map_ne_bot</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">this</span> <span class="err">$</span>  <span class="k">by</span> <span class="n">rw</span> <span class="n">h</span> <span class="bp">;</span> <span class="n">exact</span> <span class="n">map_bot</span> <span class="o">),</span>
    <span class="k">calc</span> <span class="n">map</span> <span class="n">πY</span> <span class="o">(</span><span class="n">comap</span> <span class="n">πY</span> <span class="o">(</span><span class="err">𝓝</span> <span class="n">y</span><span class="o">)</span> <span class="err">⊓</span> <span class="err">𝓟</span> <span class="n">C</span><span class="o">)</span> <span class="bp">=</span>
       <span class="err">𝓝</span> <span class="n">y</span> <span class="err">⊓</span> <span class="n">map</span> <span class="n">πY</span> <span class="o">(</span><span class="err">𝓟</span> <span class="n">C</span><span class="o">)</span> <span class="o">:</span> <span class="n">filter</span><span class="bp">.</span><span class="n">push_pull&#39;</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="err">𝓝</span> <span class="n">y</span> <span class="err">⊓</span> <span class="err">𝓟</span> <span class="o">(</span><span class="n">πY</span> <span class="err">&#39;&#39;</span> <span class="n">C</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">map_principal</span>
      <span class="bp">...</span> <span class="bp">≠</span> <span class="err">⊥</span> <span class="o">:</span> <span class="n">y_closure</span> <span class="o">},</span>
  <span class="k">obtain</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="bp">⟩</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">map</span> <span class="n">πX</span> <span class="o">(</span><span class="n">comap</span> <span class="n">πY</span> <span class="o">(</span><span class="err">𝓝</span> <span class="n">y</span><span class="o">)</span> <span class="err">⊓</span> <span class="err">𝓟</span> <span class="n">C</span><span class="o">)</span> <span class="err">⊓</span> <span class="err">𝓝</span> <span class="n">x</span> <span class="bp">≠</span> <span class="err">⊥</span><span class="o">,</span>
    <span class="k">from</span> <span class="n">cluster_point_of_compact</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">refine</span> <span class="bp">⟨⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">πY</span><span class="o">]</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">hC</span><span class="o">,</span> <span class="n">clear</span> <span class="n">hC</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">filter</span><span class="bp">.</span><span class="n">ne_bot_of_map_ne_bot</span> <span class="n">πX</span><span class="o">,</span>
  <span class="k">calc</span> <span class="n">map</span> <span class="n">πX</span> <span class="o">(</span><span class="err">𝓝</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="err">⊓</span> <span class="err">𝓟</span> <span class="n">C</span><span class="o">)</span>
      <span class="bp">=</span> <span class="n">map</span> <span class="n">πX</span> <span class="o">(</span><span class="n">comap</span> <span class="n">πX</span> <span class="o">(</span><span class="err">𝓝</span> <span class="n">x</span><span class="o">)</span> <span class="err">⊓</span> <span class="n">comap</span> <span class="n">πY</span> <span class="o">(</span><span class="err">𝓝</span> <span class="n">y</span><span class="o">)</span> <span class="err">⊓</span> <span class="err">𝓟</span> <span class="n">C</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">nhds_prod_eq</span><span class="o">,</span> <span class="n">filter</span><span class="bp">.</span><span class="n">prod</span><span class="o">]</span>
  <span class="bp">...</span> <span class="bp">=</span> <span class="n">map</span> <span class="n">πX</span> <span class="o">(</span><span class="n">comap</span> <span class="n">πY</span> <span class="o">(</span><span class="err">𝓝</span> <span class="n">y</span><span class="o">)</span> <span class="err">⊓</span> <span class="err">𝓟</span> <span class="n">C</span> <span class="err">⊓</span> <span class="n">comap</span> <span class="n">πX</span> <span class="o">(</span><span class="err">𝓝</span> <span class="n">x</span><span class="o">))</span> <span class="o">:</span> <span class="k">by</span> <span class="n">ac_refl</span>
  <span class="bp">...</span> <span class="bp">=</span> <span class="n">map</span> <span class="n">πX</span> <span class="o">(</span><span class="n">comap</span> <span class="n">πY</span> <span class="o">(</span><span class="err">𝓝</span> <span class="n">y</span><span class="o">)</span> <span class="err">⊓</span> <span class="err">𝓟</span> <span class="n">C</span><span class="o">)</span> <span class="err">⊓</span> <span class="err">𝓝</span> <span class="n">x</span>            <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">filter</span><span class="bp">.</span><span class="n">push_pull</span>
  <span class="bp">...</span> <span class="bp">≠</span> <span class="err">⊥</span> <span class="o">:</span> <span class="n">hx</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>

<a name="189402236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189402236" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189402236">Kevin Buzzard (Feb 29 2020 at 19:28)</a>:</h4>
<p>Do you think you're reproving the generalised tube lemma somehow?</p>

<a name="189402247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189402247" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189402247">Kevin Buzzard (Feb 29 2020 at 19:29)</a>:</h4>
<p>Thanks a lot for this Patrick.</p>

<a name="189402319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189402319" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189402319">Kevin Buzzard (Feb 29 2020 at 19:31)</a>:</h4>
<p>The current version of my proof is <a href="https://github.com/ImperialCollegeLondon/M4P33/blob/66a80669fdbf58b6b2883f7d26b91369f02138e4/src/for_mathlib/topological_space.lean#L37" target="_blank" title="https://github.com/ImperialCollegeLondon/M4P33/blob/66a80669fdbf58b6b2883f7d26b91369f02138e4/src/for_mathlib/topological_space.lean#L37">here</a> (with the converse later on in the file -- I refactored it this afternoon)</p>

<a name="189406918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189406918" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189406918">Patrick Massot (Feb 29 2020 at 21:51)</a>:</h4>
<p>See <a href="https://github.com/leanprover-community/mathlib/pull/2069" target="_blank" title="https://github.com/leanprover-community/mathlib/pull/2069">https://github.com/leanprover-community/mathlib/pull/2069</a></p>


{% endraw %}

{% include archive_update.html %}