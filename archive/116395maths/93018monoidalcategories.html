---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/116395maths/93018monoidalcategories.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html">monoidal categories</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="146915123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915123" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915123">Scott Morrison (Nov 07 2018 at 03:24)</a>:</h4>
<p><span class="user-mention" data-user-id="128547">@Michael Jendrusch</span> has recently started work on monoidal categories again. (Yay!)</p>

<a name="146915139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915139" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915139">Scott Morrison (Nov 07 2018 at 03:24)</a>:</h4>
<p>I've been looking at what he's written, and I want to resume my rant about how terrible coercions are, as a result.</p>

<a name="146915148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915148" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915148">Scott Morrison (Nov 07 2018 at 03:25)</a>:</h4>
<p>He's defined monoidal categories, and I think these are uncontroversial.</p>

<a name="146915151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915151" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915151">Scott Morrison (Nov 07 2018 at 03:25)</a>:</h4>
<p><a href="https://github.com/mjendrusch/monoidal-categories-reboot/blob/master/src/monoidal_categories_reboot/monoidal_category.lean" target="_blank" title="https://github.com/mjendrusch/monoidal-categories-reboot/blob/master/src/monoidal_categories_reboot/monoidal_category.lean">https://github.com/mjendrusch/monoidal-categories-reboot/blob/master/src/monoidal_categories_reboot/monoidal_category.lean</a></p>

<a name="146915158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915158" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915158">Mario Carneiro (Nov 07 2018 at 03:25)</a>:</h4>
<p>so many axioms...</p>

<a name="146915160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915160" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915160">Scott Morrison (Nov 07 2018 at 03:25)</a>:</h4>
<p>However when he gets to monoidal functors the horrors caused by coercions start to creep out...</p>

<a name="146915162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915162" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915162">Scott Morrison (Nov 07 2018 at 03:25)</a>:</h4>
<p>Ah -- maybe I should address that first.</p>

<a name="146915165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915165" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915165">Scott Morrison (Nov 07 2018 at 03:25)</a>:</h4>
<p>You might have said:</p>

<a name="146915211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915211" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915211">Scott Morrison (Nov 07 2018 at 03:26)</a>:</h4>
<p>surely a monoidal category should be described as a category <code>C</code> equipped with a functor <code>C \times C \func C</code>, satisfying ...</p>

<a name="146915216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915216" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915216">Scott Morrison (Nov 07 2018 at 03:26)</a>:</h4>
<p>(this will certainly reduce the number of axioms, at least slightly, because various things are wrapped up in functoriality)</p>

<a name="146915225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915225" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915225">Scott Morrison (Nov 07 2018 at 03:27)</a>:</h4>
<p>However... implementation details forced on us by Lean make this a bad idea (as I discovered when I did monoidal categories previously)</p>

<a name="146915228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915228" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915228">Mario Carneiro (Nov 07 2018 at 03:27)</a>:</h4>
<p>hopefully you prove the equivalence though?</p>

<a name="146915274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915274" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915274">Scott Morrison (Nov 07 2018 at 03:28)</a>:</h4>
<p>Yes, it's easy (and Michael started doing it) to show afterwards that these things assemble into functors, and natural transformations, and so on.</p>

<a name="146915297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915297" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915297">Scott Morrison (Nov 07 2018 at 03:29)</a>:</h4>
<p>The problem with making tensor product a functor first of all is that it becomes really painful to implement notation <code>X \otimes Y</code> and <code>f \otimes' g</code>.</p>

<a name="146915307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915307" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915307">Mario Carneiro (Nov 07 2018 at 03:29)</a>:</h4>
<p>what's the issue?</p>

<a name="146915348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915348" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915348">Scott Morrison (Nov 07 2018 at 03:30)</a>:</h4>
<p>You end up having to define as auxiliary lemmas curried versions of the functor of objects, but even then the elaborator often really struggles.</p>

<a name="146915363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915363" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915363">Scott Morrison (Nov 07 2018 at 03:30)</a>:</h4>
<p>(Sorry, it's been a year or so since I last fought with this issue... give me a moment.)</p>

<a name="146915369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915369" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915369">Mario Carneiro (Nov 07 2018 at 03:30)</a>:</h4>
<p>Can you make it a curried functor instead?</p>

<a name="146915376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915376" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915376">Mario Carneiro (Nov 07 2018 at 03:31)</a>:</h4>
<p>cat being a CCC and all</p>

<a name="146915434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915434" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915434">Scott Morrison (Nov 07 2018 at 03:32)</a>:</h4>
<p>You could make it a curried functor, but I don't think it would help. If T was your tensor product functor, you still couldn't write <code>T X Y</code> and have the elaborator successfully introduce both coercions.</p>

<a name="146915471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915471" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915471">Scott Morrison (Nov 07 2018 at 03:33)</a>:</h4>
<p>Neither <code>T (X, Y)</code>, if <code>T : C \times C \func C</code>, or <code>T X Y</code>, if <code>T : C \func (C \func C)</code> will elaborate reliably. (In fact, I think they won't ever elaborate.)</p>

<a name="146915479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915479" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915479">Mario Carneiro (Nov 07 2018 at 03:33)</a>:</h4>
<p>that's sad...</p>

<a name="146915532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915532" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915532">Scott Morrison (Nov 07 2018 at 03:34)</a>:</h4>
<p>You can see examples of this all over my (no-longer-compiling) earlier attempt at monoidal categories.</p>

<a name="146915535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915535" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915535">Mario Carneiro (Nov 07 2018 at 03:34)</a>:</h4>
<p>What about an infix functor application operator?</p>

<a name="146915540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915540" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915540">Mario Carneiro (Nov 07 2018 at 03:34)</a>:</h4>
<p>like <code>&lt;$&gt;</code> for <code>functor</code></p>

<a name="146915549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915549" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915549">Scott Morrison (Nov 07 2018 at 03:35)</a>:</h4>
<div class="codehilite"><pre><span></span>@[ematch] definition interchange (f : U ⟶ V) (g : V ⟶ W) (h : X ⟶ Y) (k : Y ⟶ Z) :
  (f ≫ g) ⊗ (h ≫ k) = (f ⊗ h) ≫ (g ⊗ k) :=
  @Functor.functoriality (C × C) _ C _ (tensor C) ⟨U, X⟩ ⟨V, Y⟩ ⟨W, Z⟩ ⟨f, h⟩ ⟨g, k⟩
</pre></div>


<p>should really just be proved by <code>(tensor  C).map_comp (f, h) (g,k)</code>, but instead we need to use @, and specify way too many implicit arguments.</p>

<a name="146915556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915556" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915556">Scott Morrison (Nov 07 2018 at 03:35)</a>:</h4>
<p>Yes --- so this is what I had long ago.</p>

<a name="146915560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915560" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915560">Scott Morrison (Nov 07 2018 at 03:35)</a>:</h4>
<p>I had <code>+&gt;</code> for obj, and <code>&amp;&gt;</code> for map, although I really don't care what the symbols are.</p>

<a name="146915564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915564" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915564">Scott Morrison (Nov 07 2018 at 03:35)</a>:</h4>
<p>I would _love_ to move back to this model, which would let us get rid of lots of coercions.</p>

<a name="146915612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915612" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915612">Mario Carneiro (Nov 07 2018 at 03:36)</a>:</h4>
<p>I've heard this story before, and I don't disagree with you</p>

<a name="146915628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915628" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915628">Mario Carneiro (Nov 07 2018 at 03:36)</a>:</h4>
<p>I really want coercions to work, and in principle they could, but lean's coercion model is not extensible enough</p>

<a name="146915646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915646" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915646">Mario Carneiro (Nov 07 2018 at 03:37)</a>:</h4>
<p>it should be a parser extension rather than being tied to <code>coe</code> in core</p>

<a name="146915652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915652" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915652">Scott Morrison (Nov 07 2018 at 03:37)</a>:</h4>
<p>If we were in a situation where modifying the coercion mechanism was on the table, I would absolutely support struggling on with coercions, essentially to gain data about what we really want.</p>

<a name="146915697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915697" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915697">Scott Morrison (Nov 07 2018 at 03:38)</a>:</h4>
<p>But I'm not sure whether <span class="emoji emoji-1f340" title="four leaf clover">:four_leaf_clover:</span> gives us this prospect, or not.</p>

<a name="146915706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915706" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915706">Mario Carneiro (Nov 07 2018 at 03:38)</a>:</h4>
<p>I think it might, at least it should not be far from the areas under development</p>

<a name="146915710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915710" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915710">Scott Morrison (Nov 07 2018 at 03:39)</a>:</h4>
<p>If my fighting with coercions is not significantly likely to result in better coercions later, I just want the suffering to go away. :-)</p>

<a name="146915724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915724" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915724">Mario Carneiro (Nov 07 2018 at 03:39)</a>:</h4>
<p>the fact that simp doesn't work under coercions is something we might be able to fix in lean 3</p>

<a name="146915727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915727" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915727">Scott Morrison (Nov 07 2018 at 03:39)</a>:</h4>
<p>I haven't even started explaining the difficulties coercions are causing in the design of <code>monoidal_functor</code>... :-)</p>

<a name="146915773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915773" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915773">Mario Carneiro (Nov 07 2018 at 03:40)</a>:</h4>
<p>right, sorry to derail your story. carry on</p>

<a name="146915790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915790" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915790">Scott Morrison (Nov 07 2018 at 03:41)</a>:</h4>
<p>Essentially: if we want <code>monoidal_functor</code> to extend <code>functor</code>, we need new coercions so we can still write <code>F X</code>, when <code>F</code> is a monoidal functor. Now however none of the lemmas involving <code>F X</code> will apply when <code>F</code> is a monoidal functor, because the coercion won't be the right one.</p>

<a name="146915792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915792" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915792">Scott Morrison (Nov 07 2018 at 03:41)</a>:</h4>
<p>So we'll have to reproduce all the lemmas...</p>

<a name="146915795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915795" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915795">Scott Morrison (Nov 07 2018 at 03:41)</a>:</h4>
<p>And we'll have to do this again for <code>braided_functor</code>, and then again for <code>additive_functor</code>, and then again for ...</p>

<a name="146915834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915834" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915834">Mario Carneiro (Nov 07 2018 at 03:42)</a>:</h4>
<p>wait, what's a monoidal functor now</p>

<a name="146915847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915847" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915847">Mario Carneiro (Nov 07 2018 at 03:42)</a>:</h4>
<p>oh <a href="https://github.com/mjendrusch/monoidal-categories-reboot/blob/master/src/monoidal_categories_reboot/monoidal_functor.lean" target="_blank" title="https://github.com/mjendrusch/monoidal-categories-reboot/blob/master/src/monoidal_categories_reboot/monoidal_functor.lean">https://github.com/mjendrusch/monoidal-categories-reboot/blob/master/src/monoidal_categories_reboot/monoidal_functor.lean</a></p>

<a name="146915848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915848" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915848">Scott Morrison (Nov 07 2018 at 03:42)</a>:</h4>
<p>monoidal functor doesn't exist yet, beyond Michael's first cut at <a href="https://github.com/mjendrusch/monoidal-categories-reboot/blob/master/src/monoidal_categories_reboot/monoidal_functor.lean" target="_blank" title="https://github.com/mjendrusch/monoidal-categories-reboot/blob/master/src/monoidal_categories_reboot/monoidal_functor.lean">https://github.com/mjendrusch/monoidal-categories-reboot/blob/master/src/monoidal_categories_reboot/monoidal_functor.lean</a></p>

<a name="146915853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915853" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915853">Scott Morrison (Nov 07 2018 at 03:42)</a>:</h4>
<p>and you can see at the bottom of that file the problems waiting for us as soon as we define composition of monoidal functors.</p>

<a name="146915944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915944" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915944">Mario Carneiro (Nov 07 2018 at 03:45)</a>:</h4>
<p>What's the alternative?</p>

<a name="146915954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915954" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915954">Scott Morrison (Nov 07 2018 at 03:45)</a>:</h4>
<p>well, if all the coercions were gone, our problems would mostly disappear.</p>

<a name="146915997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146915997" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146915997">Mario Carneiro (Nov 07 2018 at 03:46)</a>:</h4>
<p>if the coercions were gone, it wouldn't typecheck. Are you writing explicit functions now?</p>

<a name="146916000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146916000" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146916000">Scott Morrison (Nov 07 2018 at 03:46)</a>:</h4>
<p>Instead of having <code>functor.map'</code>, the structure field, which doesn't use the coercion, and <code>functor.map</code>, the same, as a lemma written using the coercion, we'd just have the structure field.</p>

<a name="146916006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146916006" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146916006">Mario Carneiro (Nov 07 2018 at 03:46)</a>:</h4>
<p><code>F.to_functor.map f</code>?</p>

<a name="146916008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146916008" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146916008">Scott Morrison (Nov 07 2018 at 03:46)</a>:</h4>
<p>So we wouldn't have to define a new version of <code>map</code> for monoidal functors, so all the lemmas about <code>functor.map</code> would still apply</p>

<a name="146916009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146916009" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146916009">Scott Morrison (Nov 07 2018 at 03:46)</a>:</h4>
<p>Yes.</p>

<a name="146916020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146916020" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146916020">Scott Morrison (Nov 07 2018 at 03:47)</a>:</h4>
<p>But you wouldn't have to write the <code>.to_functor</code> explicitly.</p>

<a name="146916022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146916022" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146916022">Mario Carneiro (Nov 07 2018 at 03:47)</a>:</h4>
<p>?</p>

<a name="146916025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146916025" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146916025">Mario Carneiro (Nov 07 2018 at 03:47)</a>:</h4>
<p>what's the magic sauce you are using in place of coercions</p>

<a name="146916029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146916029" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146916029">Scott Morrison (Nov 07 2018 at 03:47)</a>:</h4>
<p>Am I wrong? I thought that's how the extension mechanism works -- you can refer directly to the fields of the parent structure.</p>

<a name="146916074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146916074" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146916074">Mario Carneiro (Nov 07 2018 at 03:48)</a>:</h4>
<p>It depends on whether you are using the old structures or new</p>

<a name="146916076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146916076" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146916076">Scott Morrison (Nov 07 2018 at 03:48)</a>:</h4>
<p>new</p>

<a name="146916082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146916082" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146916082">Scott Morrison (Nov 07 2018 at 03:48)</a>:</h4>
<p>but this certainly works, I just double checked :-)</p>

<a name="146916094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146916094" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146916094">Mario Carneiro (Nov 07 2018 at 03:49)</a>:</h4>
<p>Is the <code>to_functor</code> in the pp.all term?</p>

<a name="146916287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146916287" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146916287">Scott Morrison (Nov 07 2018 at 03:54)</a>:</h4>
<p>Yes</p>

<a name="146916297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146916297" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146916297">Scott Morrison (Nov 07 2018 at 03:55)</a>:</h4>
<p>The <code>to_functor</code> is in fact there even without <code>pp.all</code>. You just don't need to write it.</p>

<a name="146916427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146916427" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146916427">Scott Morrison (Nov 07 2018 at 03:58)</a>:</h4>
<p>As far as I can see the parser is doing this. There's no <code>monoidal_functor.obj</code> field at all,  but you can nevertheless write <code>F.obj X</code> when <code>F</code> is a monoidal functor, and when you pp the resulting term it shows as <code>F.to_functor.obj X</code>.</p>

<a name="146916445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146916445" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146916445">Scott Morrison (Nov 07 2018 at 03:59)</a>:</h4>
<p>The essential problem is that because of coercions, we have all this duplication: <code>functor</code> has both <code>map'</code> and <code>map</code>, and <code>map_comp'</code> and <code>map_comp</code>, etc.</p>

<a name="146916452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146916452" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146916452">Scott Morrison (Nov 07 2018 at 03:59)</a>:</h4>
<p>Every time we extend functor (or anything similar), we will need to reproduce all this duplication again.</p>

<a name="146916502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146916502" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146916502">Mario Carneiro (Nov 07 2018 at 04:00)</a>:</h4>
<p>hm, this is parser magic we can't duplicate</p>

<a name="146916655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146916655" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146916655">Reid Barton (Nov 07 2018 at 04:05)</a>:</h4>
<p>Sorry, so to go back to the start, if we forgot about coercions entirely, is there still an issue with defining the tensor product to be a functor from C x C to C?</p>

<a name="146916709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146916709" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146916709">Scott Morrison (Nov 07 2018 at 04:07)</a>:</h4>
<p>I think there still is.</p>

<a name="146916711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146916711" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146916711">Scott Morrison (Nov 07 2018 at 04:07)</a>:</h4>
<p>The basic question is how to implement <code>X \otimes Y</code>.</p>

<a name="146916717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146916717" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146916717">Reid Barton (Nov 07 2018 at 04:07)</a>:</h4>
<p><code>T.app (X, Y)</code>?</p>

<a name="146916719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146916719" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146916719">Scott Morrison (Nov 07 2018 at 04:07)</a>:</h4>
<p>You mean <code>T.obj (X, Y)</code>?</p>

<a name="146916720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146916720" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146916720">Reid Barton (Nov 07 2018 at 04:08)</a>:</h4>
<p>er, <code>T.obj</code></p>

<a name="146916765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146916765" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146916765">Reid Barton (Nov 07 2018 at 04:08)</a>:</h4>
<p>I can see that writing down the functors which the associator is supposed to be a natural isomorphism between is going to be ugly</p>

<a name="146916767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146916767" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146916767">Scott Morrison (Nov 07 2018 at 04:08)</a>:</h4>
<p>The problem there is that for reasons I don't totally understand, even having the pair construction in there gums up the elaborator.</p>

<a name="146916768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146916768" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146916768">Reid Barton (Nov 07 2018 at 04:08)</a>:</h4>
<p>hm</p>

<a name="146916773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146916773" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146916773">Scott Morrison (Nov 07 2018 at 04:09)</a>:</h4>
<p>My old monoidal-categories repository didn't use any coercions.</p>

<a name="146916780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146916780" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146916780">Scott Morrison (Nov 07 2018 at 04:09)</a>:</h4>
<p>(unfortunately I don't have a compiling version of it anymore...)</p>

<a name="146916812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146916812" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146916812">Scott Morrison (Nov 07 2018 at 04:10)</a>:</h4>
<p>But I found myself having to use</p>
<div class="codehilite"><pre><span></span>-- Convenience methods which take two arguments, rather than a pair. (This seems to often help the elaborator avoid getting stuck on `prod.mk`.)
definition tensorObjects (X Y : C) : C := (tensor C) +&gt; (X, Y)

infixr ` ⊗ `:80 := tensorObjects -- type as \otimes
</pre></div>

<a name="146916854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146916854" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146916854">Reid Barton (Nov 07 2018 at 04:11)</a>:</h4>
<p>Another question: how about using isos for the associator/unitors instead of four fields each?</p>

<a name="146916855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146916855" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146916855">Reid Barton (Nov 07 2018 at 04:11)</a>:</h4>
<p>I imagine you thought of that already</p>

<a name="146916857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146916857" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146916857">Scott Morrison (Nov 07 2018 at 04:11)</a>:</h4>
<p>but then there's an extra layer of folding and unfolding <code>tensorObjects</code></p>

<a name="146916860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146916860" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146916860">Scott Morrison (Nov 07 2018 at 04:11)</a>:</h4>
<p>Actually, the question of using isos is a good one.</p>

<a name="146916862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146916862" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146916862">Scott Morrison (Nov 07 2018 at 04:11)</a>:</h4>
<p>and I'm not sure that I did think about it carefully.</p>

<a name="146916903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146916903" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146916903">Scott Morrison (Nov 07 2018 at 04:12)</a>:</h4>
<p>I suspect I wrote my initial monoidal categories library before I'd actually ironed out a usable implementation of isomorphisms....</p>

<a name="146916908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146916908" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146916908">Scott Morrison (Nov 07 2018 at 04:13)</a>:</h4>
<p><span class="user-mention" data-user-id="128547">@Michael Jendrusch</span>, next time you're around, how about we try this idea out: using isomorphisms as the fields for associators and unitors, rather than the four separate fields?</p>

<a name="146916961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146916961" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146916961">Reid Barton (Nov 07 2018 at 04:14)</a>:</h4>
<p>Also: no bicategories?? <span class="emoji emoji-1f643" title="upside down">:upside_down:</span></p>

<a name="146917029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146917029" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146917029">Reid Barton (Nov 07 2018 at 04:16)</a>:</h4>
<p>I kind of want to formalize (bi)limits in bicategories, since I feel the literature on them is kind of spotty.</p>

<a name="146918446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146918446" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146918446">Reid Barton (Nov 07 2018 at 05:00)</a>:</h4>
<p>but, I might want to do it less if it is going to look like <a href="https://ncatlab.org/nlab/show/bicategory#detailedDefn" target="_blank" title="https://ncatlab.org/nlab/show/bicategory#detailedDefn">https://ncatlab.org/nlab/show/bicategory#detailedDefn</a>. How would I even know that I got the definition correct?</p>

<a name="146922053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146922053" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146922053">Scott Morrison (Nov 07 2018 at 06:49)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span>, I've been considering trying to talk <span class="user-mention" data-user-id="128547">@Michael Jendrusch</span> into doing bicategories. :-) I would like them, too.</p>

<a name="146922071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146922071" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146922071">Scott Morrison (Nov 07 2018 at 06:49)</a>:</h4>
<p>But I think it makes sense to sort out the issues we're having here first, and if they are all solvable it might be a cheap rewrite to generalise...</p>

<a name="146922130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146922130" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146922130">Scott Morrison (Nov 07 2018 at 06:50)</a>:</h4>
<p><span class="user-mention" data-user-id="128547">@Michael Jendrusch</span>, I just added two new commits that package associators, unitors, and tensorators as isos. I think it is nicer.</p>

<a name="146924968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146924968" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146924968">Johan Commelin (Nov 07 2018 at 07:52)</a>:</h4>
<p>Yesterday one of my colleagues walked in to have a quick look at the workshop. He is working on derivators and such stuff. He explained how we might want to use multicategories for this. But I'm not sure how much work it would be to set up all the basics. He said it would help us get rid of the pentagon axiom in some sense. But I'm not sure if it means that the carpet won't fit in another corner... (is this an English idiom?).<br>
<span class="user-mention" data-user-id="110087">@Scott Morrison</span> Are you familiar with this multicategorical approach?</p>

<a name="146925211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146925211" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146925211">Michael Jendrusch (Nov 07 2018 at 07:59)</a>:</h4>
<blockquote>
<p><span class="user-mention" data-user-id="128547">@Michael Jendrusch</span>, I just added two new commits that package associators, unitors, and tensorators as isos. I think it is nicer.</p>
</blockquote>
<p>It's merged! I would kind of like to have bicategories, too, but this looks painful (<a href="https://ncatlab.org/nlab/show/bicategory#detailedDefn" target="_blank" title="https://ncatlab.org/nlab/show/bicategory#detailedDefn">https://ncatlab.org/nlab/show/bicategory#detailedDefn</a>).</p>

<a name="146925412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146925412" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146925412">Michael Jendrusch (Nov 07 2018 at 08:02)</a>:</h4>
<p>On another note, making <code>µ</code> an iso in the definition of a monoidal functor makes that a _strict_ monoidal functor according to nLab, where I would also want _lax_ monoidal functors. Maybe we can define a _lax_ monoidal functor and then extend it to a _strict_ monoidal functor?</p>

<a name="146926349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146926349" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146926349">Scott Morrison (Nov 07 2018 at 08:28)</a>:</h4>
<p>Ah, it's  a little subtle. If you want lax monoidal functors, then I want oplax ones (this is a serious request, actually: &lt;<a href="https://arxiv.org/abs/1701.00567" target="_blank" title="https://arxiv.org/abs/1701.00567">https://arxiv.org/abs/1701.00567</a>&gt;. So if we want to do it via inheritance we'll be dealing with a diamond.</p>

<a name="146926350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146926350" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146926350">Scott Morrison (Nov 07 2018 at 08:29)</a>:</h4>
<p>But I agree it's desirable.</p>

<a name="146926357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146926357" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146926357">Scott Morrison (Nov 07 2018 at 08:29)</a>:</h4>
<p>(But you certainly can't use the name monoidal functor if you mean a lax one. :-)</p>

<a name="146926559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146926559" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146926559">Scott Morrison (Nov 07 2018 at 08:34)</a>:</h4>
<p>Regarding multicategories --- I'm not opposed to someone also introducing these, but I'm pretty confident it's all blind men describing an elephant. Now if we want to talk about disklike categories &lt;<a href="https://arxiv.org/pdf/1108.5386.pdf" target="_blank" title="https://arxiv.org/pdf/1108.5386.pdf">https://arxiv.org/pdf/1108.5386.pdf</a>&gt;, then we'd be cooking with gas.</p>

<a name="146964187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/146964187" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#146964187">Reid Barton (Nov 07 2018 at 15:04)</a>:</h4>
<p>Actually, maybe bicategories won't be that bad at all. Shouldn't it just be a matter of asking for <code>Pi a b. category (C a b)</code>, then adding a bunch of type indices everywhere in the definition of monoidal category?</p>

<a name="147252547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/147252547" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#147252547">Scott Morrison (Nov 07 2018 at 20:18)</a>:</h4>
<p>Yes, that sounds right. It's a pity you can't mix <code>variables</code> syntax with structures; you could almost leave out all those extra type indices!</p>

<a name="147289125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/147289125" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#147289125">Michael Jendrusch (Nov 08 2018 at 10:01)</a>:</h4>
<blockquote>
<p>Ah, it's  a little subtle. If you want lax monoidal functors, then I want oplax ones (this is a serious request, actually: &lt;<a href="https://arxiv.org/abs/1701.00567" target="_blank" title="https://arxiv.org/abs/1701.00567">https://arxiv.org/abs/1701.00567</a>&gt;. So if we want to do it via inheritance we'll be dealing with a diamond.</p>
</blockquote>
<p>It seems that a lot of things in category theory result in diamonds when using inheritance (e.g. with strict monoidal categories). Is there another standard way of treating this without inheritance, and what are the actual problems one gets with diamonds in Lean?</p>

<a name="147297174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/147297174" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#147297174">Michael Jendrusch (Nov 08 2018 at 12:58)</a>:</h4>
<p>would it make sense to try and work around inheritance (and thus diamonds) by not having a classes <code>lax_monoidal_functor</code>, <code>oplax_monoidal_functor</code> both inheriting from functor (and getting a diamond from defining <code>monoidal_functor</code> as inheriting from both), instead opting to have <code>functor_is_lax_monoidal</code>, <code>functor_is_oplax_monoidal</code> together with an instance <code>functor_is_monoidal</code> for every functor which is both lax and oplax, like this?</p>
<div class="codehilite"><pre><span></span><span class="n">class</span> <span class="n">functor_is_lax_monoidal</span>
  <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">monoidal_category</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span> <span class="n">v</span><span class="o">}</span> <span class="n">C</span><span class="o">]</span>
  <span class="o">(</span><span class="n">D</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u&#39;</span><span class="o">)</span> <span class="o">[</span><span class="n">monoidal_category</span><span class="bp">.</span><span class="o">{</span><span class="n">u&#39;</span> <span class="n">v&#39;</span><span class="o">}</span> <span class="n">D</span><span class="o">]</span>
  <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">C</span> <span class="err">⥤</span> <span class="n">D</span><span class="o">)</span> <span class="o">:=</span>
<span class="c1">-- definition of lax monoidal functor here.</span>

<span class="n">class</span> <span class="n">functor_is_oplax_monoidal</span>
  <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">monoidal_category</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span> <span class="n">v</span><span class="o">}</span> <span class="n">C</span><span class="o">]</span>
  <span class="o">(</span><span class="n">D</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u&#39;</span><span class="o">)</span> <span class="o">[</span><span class="n">monoidal_category</span><span class="bp">.</span><span class="o">{</span><span class="n">u&#39;</span> <span class="n">v&#39;</span><span class="o">}</span> <span class="n">D</span><span class="o">]</span>
  <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">C</span> <span class="err">⥤</span> <span class="n">D</span><span class="o">)</span> <span class="o">:=</span>
<span class="c1">-- definition of oplax monoidal functor here.</span>

<span class="n">class</span> <span class="n">functor_is_monoidal</span>
  <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">monoidal_category</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span> <span class="n">v</span><span class="o">}</span> <span class="n">C</span><span class="o">]</span>
  <span class="o">(</span><span class="n">D</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u&#39;</span><span class="o">)</span> <span class="o">[</span><span class="n">monoidal_category</span><span class="bp">.</span><span class="o">{</span><span class="n">u&#39;</span> <span class="n">v&#39;</span><span class="o">}</span> <span class="n">D</span><span class="o">]</span>
  <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">C</span> <span class="err">⥤</span> <span class="n">D</span><span class="o">)</span> <span class="o">:=</span>
<span class="c1">-- definition of monoidal functor here.</span>

<span class="kn">instance</span> <span class="n">lax_and_oplax</span>
  <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">monoidal_category</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span> <span class="n">v</span><span class="o">}</span> <span class="n">C</span><span class="o">]</span>
  <span class="o">(</span><span class="n">D</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u&#39;</span><span class="o">)</span> <span class="o">[</span><span class="n">monoidal_category</span><span class="bp">.</span><span class="o">{</span><span class="n">u&#39;</span> <span class="n">v&#39;</span><span class="o">}</span> <span class="n">D</span><span class="o">]</span>
  <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">C</span> <span class="err">⥤</span> <span class="n">D</span><span class="o">)</span> <span class="o">[</span><span class="n">functor_is_lax_monoidal</span> <span class="n">C</span> <span class="n">D</span> <span class="n">F</span><span class="o">]</span> <span class="o">[</span><span class="n">functor_is_oplax_monoidal</span> <span class="n">C</span> <span class="n">D</span> <span class="n">F</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">functor_is_monoidal</span> <span class="n">C</span> <span class="n">D</span> <span class="n">F</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">obviously</span>
</pre></div>

<a name="147333122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/147333122" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#147333122">Scott Morrison (Nov 08 2018 at 22:05)</a>:</h4>
<p>This is an interesting approach; I wonder if we should re-explore making <code>functor</code> a typeclass right from the beginning.</p>

<a name="147333145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/147333145" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#147333145">Scott Morrison (Nov 08 2018 at 22:05)</a>:</h4>
<p>My concern is that <code>functor_is_monoidal</code> carries data (the tensorator), so it's a little scary making it a typeclass.</p>

<a name="147333211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/147333211" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#147333211">Scott Morrison (Nov 08 2018 at 22:06)</a>:</h4>
<p>However in my experience it's extremely rare that one considers two different tensorators for the same functor. (Although not _never_)</p>

<a name="147333229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/147333229" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#147333229">Scott Morrison (Nov 08 2018 at 22:06)</a>:</h4>
<p>But if we're going to carry this data in a typeclass, why aren't we carrying the data of <code>functor.map</code> in a typeclass?</p>

<a name="147333256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/147333256" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#147333256">Scott Morrison (Nov 08 2018 at 22:07)</a>:</h4>
<p>I have tried this, ..., but it was a long time ago and I don't really remember why I didn't like it then.</p>

<a name="147448765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/monoidal%20categories/near/147448765" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/93018monoidalcategories.html#147448765">Scott Morrison (Nov 10 2018 at 21:32)</a>:</h4>
<p><span class="user-mention" data-user-id="128547">@Michael Jendrusch</span>, I started adding the monoidal structure on any category with products, that should subsume your initial example of <code>Type u</code>. It's not there yet, but I think it's a fun test of our limits library to make sure this is doable with no more effort than in the <code>Type u</code> case.</p>


{% endraw %}

{% include archive_update.html %}