---
layout: archive
title: Lean Prover Zulip Chat Archive 
permalink: archive/116395maths/89979Multipledifferentiability.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html">Multiple differentiability</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="164404643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164404643" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164404643">Sebastien Gouezel (Apr 28 2019 at 20:09)</a>:</h4>
<p>I have a universe polymorphism question in the definition of multiple differentiability. The definition I have currently is</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">times_cont_diff_on</span> <span class="o">:</span> <span class="bp">∀</span><span class="n">n</span> <span class="o">:</span> <span class="n">with_top</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="bp">∀</span><span class="o">{</span><span class="n">E</span><span class="o">:</span><span class="kt">Type</span> <span class="n">v</span><span class="o">},</span> <span class="bp">∀</span><span class="o">{</span><span class="n">F</span><span class="o">:</span><span class="kt">Type</span> <span class="n">v</span><span class="o">},</span>
  <span class="bp">∀</span><span class="o">[</span><span class="n">hE</span><span class="o">:</span><span class="n">normed_space</span> <span class="n">k</span> <span class="n">E</span><span class="o">],</span> <span class="bp">∀</span><span class="o">[</span><span class="n">hF</span><span class="o">:</span><span class="n">normed_space</span> <span class="n">k</span> <span class="n">F</span><span class="o">],</span> <span class="bp">∀</span><span class="n">f</span> <span class="o">:</span> <span class="n">E</span><span class="bp">→</span><span class="n">F</span><span class="o">,</span> <span class="bp">∀</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">E</span><span class="o">,</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">some</span> <span class="mi">0</span><span class="o">)</span>     <span class="o">:=</span> <span class="bp">λ</span><span class="n">E</span> <span class="n">F</span> <span class="n">hE</span> <span class="n">hF</span> <span class="n">f</span> <span class="n">s</span><span class="o">,</span> <span class="k">by</span> <span class="o">{</span> <span class="n">resetI</span><span class="o">,</span> <span class="n">exact</span> <span class="n">continuous_on</span> <span class="n">f</span> <span class="n">s</span> <span class="o">}</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">some</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="o">:=</span> <span class="bp">λ</span><span class="n">E</span> <span class="n">F</span> <span class="n">hE</span> <span class="n">hF</span> <span class="n">f</span> <span class="n">s</span><span class="o">,</span> <span class="k">by</span> <span class="o">{</span> <span class="n">resetI</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">fdifferentiable_on</span> <span class="n">k</span> <span class="n">f</span> <span class="n">s</span> <span class="bp">∧</span> <span class="n">times_cont_diff_on</span> <span class="n">n</span> <span class="o">(</span><span class="bp">λ</span><span class="n">x</span><span class="o">,</span> <span class="n">fderiv_at_within</span> <span class="n">k</span> <span class="n">f</span> <span class="n">x</span> <span class="n">s</span><span class="o">)</span> <span class="n">s</span> <span class="o">}</span>
<span class="bp">|</span> <span class="n">none</span>         <span class="o">:=</span> <span class="bp">λ</span><span class="n">E</span> <span class="n">F</span> <span class="n">hE</span> <span class="n">hF</span> <span class="n">f</span> <span class="n">s</span><span class="o">,</span> <span class="k">by</span> <span class="o">{</span> <span class="n">resetI</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">(</span><span class="bp">∀</span><span class="n">n</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">,</span> <span class="n">times_cont_diff_on</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">with_top</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="n">f</span> <span class="n">s</span><span class="o">)</span> <span class="o">}</span>
<span class="n">using_well_founded</span> <span class="o">{</span>
  <span class="n">rel_tac</span> <span class="o">:=</span> <span class="bp">λ_</span> <span class="bp">_</span><span class="o">,</span> <span class="bp">`</span><span class="o">[</span><span class="n">exact</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="n">with_top</span><span class="bp">.</span><span class="n">well_founded_lt</span> <span class="n">nat</span><span class="bp">.</span><span class="n">lt_wf</span><span class="bp">⟩</span><span class="o">],</span>
  <span class="n">dec_tac</span> <span class="o">:=</span> <span class="bp">`</span><span class="o">[</span><span class="n">apply</span> <span class="n">with_top</span><span class="bp">.</span><span class="n">coe_lt_top</span> <span class="bp">&lt;|&gt;</span> <span class="n">apply</span> <span class="n">with_top</span><span class="bp">.</span><span class="n">some_lt_some</span><span class="bp">.</span><span class="mi">2</span> <span class="o">(</span><span class="n">lt_add_one</span> <span class="bp">_</span><span class="o">)]</span> <span class="o">}</span>
</pre></div>


<p>In this definition, I define inductively what it means for a function <code>f : E -&gt; F</code> to be <code>n</code> times continuously differentiable on a set <code>s</code>. For <code>n=0</code>, it is just continuous. For <code>n+1</code>, it means that <code>f</code> is differentiable, and its derivative is <code>n</code> times continuously differentiable (but now from the space <code>E</code> to the space <code>E -&gt;L[k] F</code> of bounded linear maps from <code>E</code> to <code>F</code>). If <code>E</code> and <code>F</code> live in the same universe <code>v</code>, everything is fine. But if <code>E</code> lives in <code>v</code> and <code>F</code> in <code>w</code>, then <code>E -&gt;L[k] F</code> lives in <code>max v w</code> and my induction is not correct any more. The options I see:<br>
* keep <code>E</code> and <code>F</code> in the same universe and be content with it.<br>
* have an auxiliary definition where <code>E</code> is in <code>v</code> and <code>F</code> in <code>max v w</code>. And use it for the inductive step of the general case. Inductions become much more cumbersome (statements should first be proved for the auxiliary definition, and then the main one).<br>
* Or some better trick I don't know.</p>
<p>Comments welcome!</p>

<a name="164404797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164404797" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164404797">Kevin Buzzard (Apr 28 2019 at 20:13)</a>:</h4>
<p>My comment is that I spent 25 years of my life doing mathematics in one universe and I never had any problems whatsover. I know they tell us to be universe polymorphic here but I would like to interpret that as "just use one universe u". I was encouraged by the CS people to have objects in one universe and morphisms in a different universe in category theory -- because why not? -- and I think it just makes a terrible mess of things. I hereby propose that if you're actually doing sensible mathematics then you just stick to one universe until someone gives you a really good reason not to. I am yet to see a convincing argument for using more than one universe in mathematics.</p>

<a name="164404922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164404922" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164404922">Sebastien Gouezel (Apr 28 2019 at 20:15)</a>:</h4>
<p>My main problem with this is that, if someone starts a file with <code>variables {E : Type*} {F : Type*}</code> and tries to define a <code>C^2</code> map from <code>E</code> to <code>F</code>, then Lean complains with a hard to understand error message. But from the mathematical point of view, I am also completely happy to do everything in one universe (or even in Type).</p>

<a name="164404984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164404984" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164404984">Kevin Buzzard (Apr 28 2019 at 20:16)</a>:</h4>
<p>So they should be doing maths in one universe too!</p>

<a name="164405004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164405004" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164405004">Kevin Buzzard (Apr 28 2019 at 20:17)</a>:</h4>
<p>When I made schemes I made them all in <code>Type</code>. But when Ramon made them, he switched to a universe polymorphic set-up.</p>

<a name="164405072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164405072" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164405072">Kevin Buzzard (Apr 28 2019 at 20:18)</a>:</h4>
<p>I tried using the category theory library and I had universe identification nightmares. Every category I had was either a large category (like rings) or a small category (like some graph of a directed system coming from <code>nhds x</code>). I never needed more than one universe. I don't get why they always want us to use lots of universes. This is maths!</p>

<a name="164405207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164405207" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164405207">Sebastien Gouezel (Apr 28 2019 at 20:21)</a>:</h4>
<p>OK, let's go for <code>E</code> and <code>F</code> in the same universe, unless someone complains.</p>

<a name="164405260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164405260" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164405260">Kevin Buzzard (Apr 28 2019 at 20:22)</a>:</h4>
<p>It would be interesting to hear what the CS people have to say. For me, the fact that it causes you trouble being multiply universe polymorphic in a situation where there is mathematically no foundational issue at all, means that being multiply universe polymorphic is the wrong idea in mathematics. Sure use one universe. But the set theorists always ask me why I need more than one (this happened in Freiburg this week and it's not the first time).</p>

<a name="164405338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164405338" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164405338">Kevin Buzzard (Apr 28 2019 at 20:24)</a>:</h4>
<p>One of my plans for later on is to refactor the schemes project using <span class="user-mention" data-user-id="110087">@Scott Morrison</span> 's category theory library, and I would like to start with using only small and large categories, and one universe only. For me it will then be easy to do universe unification by hand because I know exactly which categories are small and which ones are large.</p>

<a name="164405491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164405491" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164405491">Kevin Buzzard (Apr 28 2019 at 20:28)</a>:</h4>
<p>I had exactly universe unification issues with perfectoid spaces when we tried using categories and it put me off to an extent that I decided not to use them, and instead try to import them into Ramon's scheme project later. I really want to see category theory being used more and next time I am absolutely sticking with one universe.</p>

<a name="164420619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164420619" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164420619">Johan Commelin (Apr 29 2019 at 03:08)</a>:</h4>
<p><span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> Thanks for working on this. The last time there was discussion about this, I think you said you were using <code>enat</code>. Now I see that you are using <code>with_top nat</code>. Can you comment on the change? I was thinking <code>enat</code> might be easier for applications (because you avoid the <code>infty</code>-case).</p>

<a name="164427698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164427698" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164427698">Sebastien Gouezel (Apr 29 2019 at 06:09)</a>:</h4>
<p>I tried first with <code>enat</code>, but since the definition and the proofs are really inductive, it turned out to be much more convenient in <code>with_top nat</code>. I wouldn't know how to write the definition in <code>enat</code>, in fact!</p>

<a name="164429347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164429347" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164429347">Johan Commelin (Apr 29 2019 at 06:49)</a>:</h4>
<p><span class="user-mention" data-user-id="110294">@Johannes Hölzl</span> You said that a coinductive approach might be a good idea. Could you help us out?</p>

<a name="164429440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164429440" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164429440">Mario Carneiro (Apr 29 2019 at 06:51)</a>:</h4>
<p>I think this definition should be done in two parts rather than using a messy recursion. Define what C^k means first for k : nat, and then define it for <code>k : enat</code> by extension</p>

<a name="164429848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164429848" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164429848">Sebastien Gouezel (Apr 29 2019 at 07:01)</a>:</h4>
<p>That's what I had done first. But then it means that all proofs have to be done twice, first for finite differentiability using nat induction, and then for enat. With two different lemmas each time, the auxiliary one on nat and then the main one on enat. I got tired of this after ten identical repetitions of proofs, then I tried the inductive definition in <code>with_top nat</code> and it turned out to be completely smooth. Here is a random proof in this file:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">times_cont_diff_on</span><span class="bp">.</span><span class="n">congr_mono</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">with_top</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">E</span><span class="o">}</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">times_cont_diff_on</span> <span class="n">k</span> <span class="n">n</span> <span class="n">f</span> <span class="n">s</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">unique_diff_on</span> <span class="n">k</span> <span class="n">s₁</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span><span class="n">x</span> <span class="err">∈</span> <span class="n">s₁</span><span class="o">,</span> <span class="n">f₁</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">s₁</span> <span class="err">⊆</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">times_cont_diff_on</span> <span class="n">k</span> <span class="n">n</span> <span class="n">f₁</span> <span class="n">s₁</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">tactic</span><span class="bp">.</span><span class="n">unfreeze_local_instances</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="kn">using</span> <span class="n">with_top_nat_induction</span> <span class="k">with</span> <span class="n">n</span> <span class="n">IH</span> <span class="n">Itop</span> <span class="n">generalizing</span> <span class="n">F</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">continuous_on</span><span class="bp">.</span><span class="n">congr_mono</span> <span class="n">H</span> <span class="n">h</span> <span class="n">h₁</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="bp">⟨</span><span class="n">fdifferentiable_on</span><span class="bp">.</span><span class="n">congr_mono</span> <span class="n">H</span><span class="bp">.</span><span class="mi">1</span> <span class="n">h</span> <span class="n">h₁</span><span class="o">,</span> <span class="n">IH</span> <span class="n">H</span><span class="bp">.</span><span class="mi">2</span> <span class="o">(</span><span class="bp">λ</span><span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="bp">_</span><span class="o">)</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">differentiable_at_within</span><span class="bp">.</span><span class="n">fderiv_at_within_congr_mono</span>
      <span class="o">(</span><span class="n">H</span><span class="bp">.</span><span class="mi">1</span> <span class="n">x</span> <span class="o">(</span><span class="n">h₁</span> <span class="n">hx</span><span class="o">))</span> <span class="n">h</span> <span class="o">(</span><span class="n">h</span> <span class="n">x</span> <span class="n">hx</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="n">x</span> <span class="n">hx</span><span class="o">)</span> <span class="n">h₁</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="k">assume</span> <span class="n">n</span><span class="o">,</span> <span class="n">exact</span> <span class="n">Itop</span> <span class="n">n</span> <span class="o">(</span><span class="n">H</span> <span class="n">n</span><span class="o">)</span> <span class="n">h</span> <span class="o">}</span>
<span class="kn">end</span>
</pre></div>


<p>It used to be much more tedious with nat induction and then enat extension.</p>

<a name="164429994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164429994" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164429994">Mario Carneiro (Apr 29 2019 at 07:05)</a>:</h4>
<p>wouldn't it be the same with the appropriate induction lemma?</p>

<a name="164430145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164430145" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164430145">Sebastien Gouezel (Apr 29 2019 at 07:09)</a>:</h4>
<p>I had more difficulties with the two definitions on nat and enat as things were less defeq, so I had to do more things by hand. But in retrospect I don't see why this was the case, so maybe I'll try again. In the end, both definitions, if well crafted, should give the same proofs!</p>

<a name="164430146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164430146" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164430146">Mario Carneiro (Apr 29 2019 at 07:09)</a>:</h4>
<p>I think there are actually two definitions here, though, and mixing them is part of the problem for this question</p>

<a name="164430208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164430208" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164430208">Mario Carneiro (Apr 29 2019 at 07:10)</a>:</h4>
<p>For your C^k universe problem, I think you want to define "L is the k times differential of f at x"</p>

<a name="164430210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164430210" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164430210">Mario Carneiro (Apr 29 2019 at 07:10)</a>:</h4>
<p>which lives in some space like <code>E^k -&gt;l F</code></p>

<a name="164430278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164430278" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164430278">Mario Carneiro (Apr 29 2019 at 07:12)</a>:</h4>
<p>You could either define that recursively or inductively. If you do it recursively then since you want that space to live in <code>max u v</code>, at <code>k = 0</code> it's <code>ulift F</code> or something equivalent to it</p>

<a name="164430358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164430358" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164430358">Mario Carneiro (Apr 29 2019 at 07:14)</a>:</h4>
<p>Actually, I guess a witness for C^k requires a whole list of different <code>E^k' -&gt;l F</code> functions (for <code>k' &lt;= k</code>)?</p>

<a name="164430368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164430368" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164430368">Sebastien Gouezel (Apr 29 2019 at 07:14)</a>:</h4>
<p>No, the k-th derivative lives in a much more complicated space. Either <code>E -&gt;l (E -&gt;l (E -&gt;l ... F))))</code>, or the space of <code>k</code>-linear maps from <code>E^k</code> to <code>F</code> (but the natural space from the inductive definition is the first one). In general, one never uses the <code>k</code>-th derivative beyond <code>k=2</code>, so I am really going for an existence result.</p>

<a name="164430395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164430395" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164430395">Mario Carneiro (Apr 29 2019 at 07:15)</a>:</h4>
<p>Sure, but I still think being able to name the objects is useful</p>

<a name="164430447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164430447" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164430447">Mario Carneiro (Apr 29 2019 at 07:16)</a>:</h4>
<p>When I say <code>E^k -&gt;l F</code> I really mean what you said, it's a new definition like <code>E -&gt;l ... -&gt;l F</code></p>

<a name="164430453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164430453" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164430453">Mario Carneiro (Apr 29 2019 at 07:16)</a>:</h4>
<p>I think that can be expressed as a unary function though, from the tensor product space</p>

<a name="164430469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164430469" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164430469">Sebastien Gouezel (Apr 29 2019 at 07:17)</a>:</h4>
<p>For instance, when you prove that the composition of C^k functions is C^k, you definitely don't want to exhibit the derivative!</p>

<a name="164430479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164430479" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164430479">Mario Carneiro (Apr 29 2019 at 07:17)</a>:</h4>
<p>I'm not convinced that's true... we probably want the appropriate operators on tensors anyway</p>

<a name="164430527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164430527" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164430527">Sebastien Gouezel (Apr 29 2019 at 07:18)</a>:</h4>
<p>With tensor products, there are difficulties here as we are really talking about normed spaces, and there are many possible norms on a tensor product, that are not equivalent in general.</p>

<a name="164430544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164430544" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164430544">Mario Carneiro (Apr 29 2019 at 07:19)</a>:</h4>
<p>this new definition gives you the opportunity to pick the right one, though</p>

<a name="164430553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164430553" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164430553">Mario Carneiro (Apr 29 2019 at 07:19)</a>:</h4>
<p>I admit it's not the approach that leads to the least additional work</p>

<a name="164430567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164430567" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164430567">Mario Carneiro (Apr 29 2019 at 07:20)</a>:</h4>
<p>but I'm trying to gauge if this extra work is worth it for library building reasons</p>

<a name="164430882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164430882" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164430882">Sebastien Gouezel (Apr 29 2019 at 07:25)</a>:</h4>
<p>There is no "right" norm on tensor products, unfortunately. I just checked <a href="https://en.wikipedia.org/wiki/Topological_tensor_product" target="_blank" title="https://en.wikipedia.org/wiki/Topological_tensor_product">https://en.wikipedia.org/wiki/Topological_tensor_product</a>, which starts with the sentence "the theory is notoriously subtle" :)</p>

<a name="164431043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164431043" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164431043">Johan Commelin (Apr 29 2019 at 07:29)</a>:</h4>
<p>We need the "dangerous bend" emoji of Bourbaki/Knuth</p>

<a name="164431136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164431136" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164431136">Mario Carneiro (Apr 29 2019 at 07:31)</a>:</h4>
<p>The first questions that come to mind are: does it matter which of these norms we take? Apparently some norm is definable, and there is some space of them, but maybe they are all topologically equivalent or have the same little O sets</p>

<a name="164431312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164431312" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164431312">Mario Carneiro (Apr 29 2019 at 07:34)</a>:</h4>
<p>Assuming these issues of the tensor product cannot be resolved, it is still possible to define the space <code>E ^[n]-&gt;l F</code> (or whatever notation) via iteration of <code>E -&gt;l</code> on <code>ulift F</code></p>

<a name="164431341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164431341" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164431341">Mario Carneiro (Apr 29 2019 at 07:35)</a>:</h4>
<p>and then given <code>f : E ^[n]-&gt;l F</code> and <code>x : E^n</code> you can define <code>f x : F</code></p>

<a name="164431403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164431403" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164431403">Mario Carneiro (Apr 29 2019 at 07:36)</a>:</h4>
<p>That is, you can still treat it like the space <code>E^n -&gt; F</code> but its norm is derived from <code>E -&gt; ... -&gt; F</code></p>

<a name="164483167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164483167" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164483167">Johannes Hölzl (Apr 29 2019 at 19:54)</a>:</h4>
<p>The coinductive definition would look like this:</p>
<div class="codehilite"><pre><span></span><span class="n">coinductive</span> <span class="n">C</span> <span class="o">:</span> <span class="n">enat</span> <span class="bp">→</span> <span class="o">(</span><span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="bp">∀</span><span class="n">f</span><span class="o">,</span> <span class="n">continuous</span> <span class="n">f</span> <span class="bp">→</span> <span class="n">C</span> <span class="mi">0</span> <span class="n">f</span>
<span class="bp">|</span> <span class="n">deriv</span> <span class="o">:</span> <span class="bp">∀</span><span class="n">n</span> <span class="n">f</span> <span class="n">f&#39;</span><span class="o">,</span> <span class="n">C</span> <span class="n">n</span> <span class="n">f</span> <span class="bp">→</span> <span class="n">derivative</span> <span class="n">f</span> <span class="n">f&#39;</span> <span class="bp">→</span> <span class="n">C</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">f&#39;</span>
</pre></div>


<p>So we get the 0 case, the +1 case and by coinduction the infinite (ω) case.</p>

<a name="164483221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164483221" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164483221">Kevin Buzzard (Apr 29 2019 at 19:55)</a>:</h4>
<p><span class="user-mention" data-user-id="110294">@Johannes Hölzl</span> what do you think about the claim that mathematicians may as well just work in <code>Type u</code> and not ever use more than one universe in their work?</p>

<a name="164484061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164484061" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164484061">Johannes Hölzl (Apr 29 2019 at 20:05)</a>:</h4>
<p>You mean work in <code>Type 0</code>? I'm coming from a HOL background, and I see that everything can be done in <code>Type 0</code> (AFAIK arithmetic even in second-order logic) . But it is a annoying restriction which is hard to work around.I would prefer two different universes for <code>E</code> and <code>F</code>. We have the problem already for <code>dim</code>, where many rules are restricted to be in one universe (saving some <code>ulift</code> etc.).</p>

<a name="164484463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164484463" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164484463">Kevin Buzzard (Apr 29 2019 at 20:10)</a>:</h4>
<p>I know that you guys are not a fan of <code>Type 0</code>. I was proposing <code>Type u</code> as a way of meeting you in the middle. I don't want to ever consider a category with objects in some universe <code>u</code> and morphisms in some random unrelated universe <code>v</code>. These things do not even show up in mathematics -- there is always a relation between u and v (small categories or large ones). But the "maximally universe polymorphic" mantra coming from the CS people who know type theory says that this is how it should be done. Mathematicians are running into issues with this when more than one universe is involved.</p>

<a name="164484839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164484839" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164484839">Jesse Michael Han (Apr 29 2019 at 20:15)</a>:</h4>
<p>a concrete example which came up in discussion is Lean's treatment of ordinals, which, being isomorphism classes of well-ordered types, live one universe level up. Johannes mentioned that it's not possible to do this in just <code>Type 0</code>, and that some workaround must be implemented.</p>
<p>i think mathematicians would prefer being able to rigorously think of ordinals as giant equivalence classes whenever it's convenient. (arguably this falls under the scope of kevin's argument---i haven't seen an example where more than two type universes are needed... yet)</p>

<a name="164485119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164485119" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164485119">Johannes Hölzl (Apr 29 2019 at 20:19)</a>:</h4>
<p>Well as a computer scientist I also only want to work in <code>Type u</code> (or even better in <code>Type 0</code>). Or better: as a user I only want to work in <code>Type 0</code> (and in the worst case in a fixed type universe <code>u</code>).</p>
<p>But as a library developer were other people should use and apply my theorems I know that for some cases different type universes are neccesary, and it is usually very hard to introduce them afterwards. </p>
<p>So this is not a question between CS and math. It is a question between easy but restricted and harder but in difficult cases easier to apply.</p>

<a name="164485240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164485240" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164485240">Kevin Buzzard (Apr 29 2019 at 20:20)</a>:</h4>
<p>But if we did the entire corpus of mathematics with only one universe (I don't know if you realise this but this is what is done in practice) then no mathematician would ever notice if our maths libraries only had one universe in.</p>

<a name="164486494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164486494" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164486494">Johannes Hölzl (Apr 29 2019 at 20:36)</a>:</h4>
<p>Kevin there is a difference between doing everything in one type universe from the perspective of not doing it in a formal way. and doing it in one type universe from the perspective of doing it formally in DTT.</p>

<a name="164486534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164486534" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164486534">Kevin Buzzard (Apr 29 2019 at 20:37)</a>:</h4>
<p>I can believe you, but I don't really understand this difference properly.</p>

<a name="164486634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164486634" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164486634">Kevin Buzzard (Apr 29 2019 at 20:38)</a>:</h4>
<p>All I know is that if Sebastien runs into issues like the above issue and then has to work hard to get around things, and there are <em>no set-theoretic issues</em>, then in my opinion he is being too universe-polymorphic for mathematics.</p>

<a name="164486867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164486867" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164486867">Johannes Hölzl (Apr 29 2019 at 20:41)</a>:</h4>
<p>Or we need a better understanding / methods / tools / syntax to handle the universe polymorphism. This could also go in the direction that we write a constant with only one universe parameter, but have some "magical" tools which generalize this parameter into multiple different ones.</p>

<a name="164487080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164487080" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164487080">Johannes Hölzl (Apr 29 2019 at 20:44)</a>:</h4>
<p>But currently I don't see a good solution here. A solution is surely to go with one parameter and when somebody runs into a problem with multiple parameters they need to deal with it (including rewriting the theory)</p>

<a name="164487459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164487459" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164487459">Chris Hughes (Apr 29 2019 at 20:49)</a>:</h4>
<p>It's not that hard to prove it for <code>u v</code>,  given a proof for <code>u u</code>, just by proving everything's isomorphic to something in <code>max u v</code> surely?</p>

<a name="164487474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164487474" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164487474">Chris Hughes (Apr 29 2019 at 20:49)</a>:</h4>
<p>You don't need to rewrite the theory.</p>

<a name="164487761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164487761" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164487761">Johannes Hölzl (Apr 29 2019 at 20:52)</a>:</h4>
<p>Yes, but it requires infrastructure w.r.t isophisms between different type universes.</p>

<a name="164488124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164488124" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164488124">Patrick Massot (Apr 29 2019 at 20:57)</a>:</h4>
<p>Hi <span class="user-mention" data-user-id="110294">@Johannes Hölzl</span> ! It's nice to see you here. How is your new life?</p>

<a name="164488294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164488294" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164488294">Johannes Hölzl (Apr 29 2019 at 20:59)</a>:</h4>
<p>It's good here! (but we have more rain than Amsterdam)</p>

<a name="164488401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164488401" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164488401">Patrick Massot (Apr 29 2019 at 21:00)</a>:</h4>
<p>Do we have Lean on iPhone now?</p>

<a name="164488468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164488468" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164488468">Johannes Hölzl (Apr 29 2019 at 21:01)</a>:</h4>
<p>I don't know, do we?</p>

<a name="164488521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164488521" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164488521">Patrick Massot (Apr 29 2019 at 21:02)</a>:</h4>
<p>You're the one making IPhones now</p>

<a name="164488527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164488527" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164488527">Johannes Hölzl (Apr 29 2019 at 21:02)</a>:</h4>
<p>I don't have a iPhone (yet)</p>

<a name="164488585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164488585" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164488585">Patrick Massot (Apr 29 2019 at 21:03)</a>:</h4>
<p>Apple is becoming so laxist...</p>

<a name="164488616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164488616" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164488616">Patrick Massot (Apr 29 2019 at 21:03)</a>:</h4>
<p>If they continue down that road, one day they will allow people to install non-Apple software on their computer</p>

<a name="164488636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164488636" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164488636">Johannes Hölzl (Apr 29 2019 at 21:03)</a>:</h4>
<p>oh god</p>

<a name="164488696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164488696" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164488696">Johannes Hölzl (Apr 29 2019 at 21:04)</a>:</h4>
<p>You mean like software developed by Microsoft?</p>

<a name="164488721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164488721" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164488721">Patrick Massot (Apr 29 2019 at 21:04)</a>:</h4>
<p>Worse: free software funded by Microsoft</p>

<a name="164488724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164488724" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164488724">Johannes Hölzl (Apr 29 2019 at 21:04)</a>:</h4>
<p>I heard Microsoft Office is running quiet well on macOS</p>

<a name="164488839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164488839" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164488839">Johannes Hölzl (Apr 29 2019 at 21:06)</a>:</h4>
<p>Also git works on macOS (better than on Windows)</p>

<a name="164490337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164490337" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164490337">Kevin Buzzard (Apr 29 2019 at 21:27)</a>:</h4>
<p>great to see that you've had such an impact already ;-)</p>

<a name="164490632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164490632" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164490632">Johannes Hölzl (Apr 29 2019 at 21:30)</a>:</h4>
<p>Hehe, yeah I managed to install git on my computer :-)</p>

<a name="164490689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164490689" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164490689">Johannes Hölzl (Apr 29 2019 at 21:31)</a>:</h4>
<p>But Munich is the city of Isabelle.</p>


{% endraw %}
