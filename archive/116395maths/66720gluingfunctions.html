---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/116395maths/66720gluingfunctions.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html">gluing functions</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="171359646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171359646" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171359646">Kenny Lau (Jul 21 2019 at 06:50)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">topology</span><span class="bp">.</span><span class="n">opens</span>

<span class="n">universes</span> <span class="n">v</span> <span class="n">u</span>
<span class="kn">open</span> <span class="n">topological_space</span> <span class="n">lattice</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span>

<span class="kn">set_option</span> <span class="n">old_structure_cmd</span> <span class="n">true</span>

<span class="kn">structure</span> <span class="n">presheaf</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="o">(</span><span class="n">v</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">U</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">,</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span>
<span class="o">(</span><span class="n">res</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">U</span> <span class="n">V</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">,</span> <span class="n">V</span> <span class="bp">≤</span> <span class="n">U</span> <span class="bp">→</span> <span class="n">F</span> <span class="n">U</span> <span class="bp">→</span> <span class="n">F</span> <span class="n">V</span><span class="o">)</span>
<span class="o">(</span><span class="n">res_self</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">U</span> <span class="n">x</span><span class="o">,</span> <span class="n">res</span> <span class="n">U</span> <span class="n">U</span> <span class="o">(</span><span class="n">le_refl</span> <span class="n">U</span><span class="o">)</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">res_res</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">U</span> <span class="n">V</span> <span class="n">W</span> <span class="n">HWV</span> <span class="n">HVU</span> <span class="n">x</span><span class="o">,</span> <span class="n">res</span> <span class="n">V</span> <span class="n">W</span> <span class="n">HWV</span> <span class="o">(</span><span class="n">res</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">res</span> <span class="n">U</span> <span class="n">W</span> <span class="o">(</span><span class="n">le_trans</span> <span class="n">HWV</span> <span class="n">HVU</span><span class="o">)</span> <span class="n">x</span><span class="o">)</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">X</span><span class="o">}</span>
<span class="kn">structure</span> <span class="n">covering</span> <span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="o">(</span><span class="n">map</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span>
<span class="o">(</span><span class="n">map_le</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">map</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">U</span><span class="o">)</span>
<span class="o">(</span><span class="n">exists_of_mem</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">U</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">i</span><span class="o">,</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">map</span> <span class="n">i</span><span class="o">)</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">X</span><span class="o">)</span>

<span class="kn">structure</span> <span class="n">sheaf</span> <span class="kn">extends</span> <span class="n">presheaf</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="o">(</span><span class="n">v</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">locality</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">U</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">F</span> <span class="n">U</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">OC</span> <span class="o">:</span> <span class="n">covering</span> <span class="n">U</span><span class="o">,</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">OC</span><span class="bp">.</span><span class="n">ι</span><span class="o">,</span> <span class="n">res</span> <span class="n">U</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map_le</span> <span class="n">i</span><span class="o">)</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">res</span> <span class="n">U</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map_le</span> <span class="n">i</span><span class="o">)</span> <span class="n">t</span><span class="o">)</span> <span class="bp">→</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">t</span><span class="o">)</span>
<span class="o">(</span><span class="n">gluing</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">U</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">OC</span> <span class="o">:</span> <span class="n">covering</span> <span class="n">U</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">S</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">i</span> <span class="o">:</span> <span class="n">OC</span><span class="bp">.</span><span class="n">ι</span><span class="o">,</span> <span class="n">F</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">i</span><span class="o">),</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">OC</span><span class="bp">.</span><span class="n">ι</span><span class="o">,</span> <span class="n">res</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">i</span> <span class="err">⊓</span> <span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">j</span><span class="o">)</span> <span class="n">inf_le_left</span> <span class="o">(</span><span class="n">S</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span>
    <span class="n">res</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">i</span> <span class="err">⊓</span> <span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">j</span><span class="o">)</span> <span class="n">inf_le_right</span> <span class="o">(</span><span class="n">S</span> <span class="n">j</span><span class="o">))</span> <span class="bp">→</span>
  <span class="bp">∃</span> <span class="n">s</span> <span class="o">:</span> <span class="n">F</span> <span class="n">U</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">OC</span><span class="bp">.</span><span class="n">ι</span><span class="o">,</span> <span class="n">res</span> <span class="n">U</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map_le</span> <span class="n">i</span><span class="o">)</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">S</span> <span class="n">i</span><span class="o">)</span>

<span class="n">def</span> <span class="n">Func</span> <span class="o">(</span><span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="n">sheaf</span><span class="bp">.</span><span class="o">{(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="n">u</span><span class="o">}</span> <span class="n">X</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">F</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span><span class="o">,</span> <span class="n">U</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">,</span>
  <span class="n">res</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="n">s</span> <span class="n">v</span><span class="o">,</span> <span class="n">s</span> <span class="bp">⟨</span><span class="n">v</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span> <span class="n">HVU</span> <span class="n">v</span><span class="bp">.</span><span class="mi">2</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">res_self</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">funext</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">res_res</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">locality</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">s</span> <span class="n">t</span> <span class="n">OC</span> <span class="n">H</span><span class="o">,</span> <span class="n">funext</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">u</span><span class="o">,</span> <span class="n">hu</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="k">let</span> <span class="bp">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hui</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">OC</span><span class="bp">.</span><span class="n">exists_of_mem</span> <span class="n">u</span> <span class="n">hu</span> <span class="k">in</span>
    <span class="k">have</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">congr_fun</span> <span class="o">(</span><span class="n">H</span> <span class="n">i</span><span class="o">)</span> <span class="bp">⟨</span><span class="n">u</span><span class="o">,</span> <span class="n">hui</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">gluing</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">OC</span> <span class="n">S</span> <span class="n">H</span><span class="o">,</span> <span class="bp">⟨λ</span> <span class="n">u</span><span class="o">,</span> <span class="n">S</span> <span class="o">(</span><span class="n">classical</span><span class="bp">.</span><span class="n">some</span> <span class="err">$</span> <span class="n">OC</span><span class="bp">.</span><span class="n">exists_of_mem</span> <span class="n">u</span><span class="bp">.</span><span class="mi">1</span> <span class="n">u</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span>
      <span class="bp">⟨</span><span class="n">u</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span> <span class="n">classical</span><span class="bp">.</span><span class="n">some_spec</span> <span class="err">$</span> <span class="n">OC</span><span class="bp">.</span><span class="n">exists_of_mem</span> <span class="n">u</span><span class="bp">.</span><span class="mi">1</span> <span class="n">u</span><span class="bp">.</span><span class="mi">2</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">funext</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">u</span><span class="o">,</span> <span class="n">hu</span><span class="bp">⟩</span><span class="o">,</span> <span class="k">have</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">congr_fun</span> <span class="o">(</span><span class="n">H</span> <span class="n">i</span> <span class="err">$</span> <span class="n">classical</span><span class="bp">.</span><span class="n">some</span> <span class="err">$</span> <span class="n">OC</span><span class="bp">.</span><span class="n">exists_of_mem</span> <span class="n">u</span> <span class="err">$</span> <span class="n">OC</span><span class="bp">.</span><span class="n">map_le</span> <span class="n">i</span> <span class="n">hu</span><span class="o">)</span>
      <span class="bp">⟨</span><span class="n">u</span><span class="o">,</span> <span class="n">hu</span><span class="o">,</span> <span class="n">classical</span><span class="bp">.</span><span class="n">some_spec</span> <span class="err">$</span> <span class="n">OC</span><span class="bp">.</span><span class="n">exists_of_mem</span> <span class="n">u</span> <span class="err">$</span> <span class="n">OC</span><span class="bp">.</span><span class="n">map_le</span> <span class="n">i</span> <span class="n">hu</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">this</span><span class="bp">.</span><span class="n">symm</span><span class="bp">⟩</span> <span class="o">}</span>
</pre></div>

<a name="171395304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171395304" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171395304">Johan Commelin (Jul 22 2019 at 00:59)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> That looks great!!</p>

<a name="171395373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171395373" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171395373">Johan Commelin (Jul 22 2019 at 01:01)</a>:</h4>
<p>Maybe we should forget about sites for the moment. I do want to use functors though. I don't see any reason why you would handroll your own presheaves if their definition is defeq to functors (up to iota/eta for records [I always forget which Greek letter I need to invoke]).</p>

<a name="171402068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171402068" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171402068">Kenny Lau (Jul 22 2019 at 04:21)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">namespace</span> <span class="n">opens</span>
<span class="n">def</span> <span class="n">covering_res</span> <span class="o">(</span><span class="n">U</span> <span class="n">V</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">V</span> <span class="err">⊆</span> <span class="n">U</span><span class="o">)</span> <span class="o">(</span><span class="n">OC</span> <span class="o">:</span> <span class="n">covering</span> <span class="n">U</span><span class="o">)</span> <span class="o">:</span> <span class="n">covering</span> <span class="n">V</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">ι</span> <span class="o">:=</span> <span class="n">OC</span><span class="bp">.</span><span class="n">ι</span><span class="o">,</span>
  <span class="n">map</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span> <span class="o">:</span> <span class="n">OC</span><span class="bp">.</span><span class="n">ι</span><span class="o">,</span> <span class="n">V</span> <span class="err">⊓</span> <span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">i</span><span class="o">,</span>
  <span class="n">map_le</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">inf_le_left</span><span class="o">,</span>
  <span class="n">exists_of_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">hxV</span><span class="o">,</span> <span class="k">let</span> <span class="bp">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hi</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">OC</span><span class="bp">.</span><span class="n">exists_of_mem</span> <span class="bp">_</span> <span class="o">(</span><span class="n">H</span> <span class="n">hxV</span><span class="o">)</span> <span class="k">in</span> <span class="bp">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hxV</span><span class="o">,</span> <span class="n">hi</span><span class="bp">⟩</span> <span class="o">}</span>
<span class="kn">end</span> <span class="n">opens</span>

<span class="kn">structure</span> <span class="n">subpresheaf</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_set</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">U</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">,</span> <span class="n">set</span> <span class="o">(</span><span class="n">F</span> <span class="n">U</span><span class="o">))</span>
<span class="o">(</span><span class="n">res_mem_to_set</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">U</span> <span class="n">V</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">HVU</span> <span class="o">:</span> <span class="n">V</span> <span class="err">⊆</span> <span class="n">U</span><span class="o">)</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">F</span> <span class="n">U</span><span class="o">},</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">to_set</span> <span class="n">U</span> <span class="bp">→</span> <span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">to_set</span> <span class="n">V</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">subpresheaf</span>

<span class="kn">instance</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">subpresheaf</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨_</span><span class="o">,</span> <span class="n">to_set</span><span class="bp">⟩</span>

<span class="kn">instance</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">partial_order</span> <span class="o">(</span><span class="n">subpresheaf</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">partial_order</span><span class="bp">.</span><span class="n">lift</span> <span class="n">to_set</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">y</span><span class="o">,</span> <span class="n">hy</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">mk</span><span class="bp">.</span><span class="n">inj_eq</span><span class="bp">.</span><span class="n">mpr</span><span class="o">)</span> <span class="n">infer_instance</span>

<span class="n">def</span> <span class="n">to_subsheaf</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">subpresheaf</span> <span class="n">F</span><span class="o">)</span> <span class="o">:</span> <span class="n">subpresheaf</span> <span class="n">F</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_set</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span><span class="o">,</span> <span class="o">{</span> <span class="n">x</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">OC</span> <span class="o">:</span> <span class="n">covering</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">U</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">OC</span><span class="bp">.</span><span class="n">ι</span><span class="o">,</span> <span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">U</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map_le</span> <span class="n">i</span><span class="o">)</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">S</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">i</span><span class="o">)</span> <span class="o">},</span>
  <span class="n">res_mem_to_set</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="n">x</span> <span class="bp">⟨</span><span class="n">OC</span><span class="o">,</span> <span class="n">hx</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">opens</span><span class="bp">.</span><span class="n">covering_res</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="n">OC</span><span class="o">,</span>
    <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="k">have</span> <span class="bp">_</span> <span class="err">∈</span> <span class="n">S</span> <span class="o">((</span><span class="n">opens</span><span class="bp">.</span><span class="n">covering_res</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="n">OC</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span> <span class="n">S</span><span class="bp">.</span><span class="n">res_mem_to_set</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">inter_subset_right</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="o">(</span><span class="n">hx</span> <span class="n">i</span><span class="o">),</span>
    <span class="k">by</span> <span class="n">rwa</span> <span class="n">F</span><span class="bp">.</span><span class="n">res_res</span> <span class="n">at</span> <span class="n">this</span> <span class="err">⊢</span><span class="bp">⟩</span> <span class="o">}</span>

<span class="kn">theorem</span> <span class="n">le_to_subsheaf</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">subpresheaf</span> <span class="n">F</span><span class="o">)</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">≤</span> <span class="n">S</span><span class="bp">.</span><span class="n">to_subsheaf</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">U</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="bp">⟨</span><span class="o">{</span> <span class="n">ι</span> <span class="o">:=</span> <span class="n">punit</span><span class="o">,</span> <span class="n">map</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">U</span><span class="o">,</span> <span class="n">map_le</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">le_refl</span> <span class="n">U</span><span class="o">,</span> <span class="n">exists_of_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">hxU</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">punit</span><span class="bp">.</span><span class="n">star</span><span class="o">,</span> <span class="n">hxU</span><span class="bp">⟩</span> <span class="o">},</span>
<span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="k">by</span> <span class="n">rwa</span> <span class="n">F</span><span class="bp">.</span><span class="n">res_self</span><span class="bp">⟩</span>

<span class="n">def</span> <span class="n">to_presheaf</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">subpresheaf</span> <span class="n">F</span><span class="o">)</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">X</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">F</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span><span class="o">,</span> <span class="n">S</span> <span class="n">U</span><span class="o">,</span>
  <span class="n">res</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="n">x</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="n">x</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span> <span class="n">S</span><span class="bp">.</span><span class="mi">2</span> <span class="n">HVU</span> <span class="n">x</span><span class="bp">.</span><span class="mi">2</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">res_self</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">x</span><span class="o">,</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">eq</span> <span class="err">$</span> <span class="n">F</span><span class="bp">.</span><span class="n">res_self</span> <span class="n">U</span> <span class="n">x</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span>
  <span class="n">res_res</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">V</span> <span class="n">W</span> <span class="n">HWV</span> <span class="n">HVU</span> <span class="n">x</span><span class="o">,</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">eq</span> <span class="err">$</span> <span class="n">F</span><span class="bp">.</span><span class="n">res_res</span> <span class="n">U</span> <span class="n">V</span> <span class="n">W</span> <span class="n">HWV</span> <span class="n">HVU</span> <span class="n">x</span><span class="bp">.</span><span class="mi">1</span> <span class="o">}</span>

<span class="kn">end</span> <span class="n">subpresheaf</span>

<span class="kn">structure</span> <span class="n">subsheaf</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">X</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">subpresheaf</span> <span class="n">F</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">mem_of_res_mem</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">U</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">},</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">F</span> <span class="n">U</span><span class="o">},</span> <span class="bp">∀</span> <span class="n">OC</span> <span class="o">:</span> <span class="n">covering</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">U</span><span class="o">,</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">OC</span><span class="bp">.</span><span class="n">ι</span><span class="o">,</span> <span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">U</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map_le</span> <span class="n">i</span><span class="o">)</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">to_set</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">i</span><span class="o">))</span> <span class="bp">→</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">to_set</span> <span class="n">U</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">subsheaf</span>

<span class="n">def</span> <span class="n">to_sheaf</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">sheaf</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">subsheaf</span> <span class="n">F</span><span class="bp">.</span><span class="n">to_presheaf</span><span class="o">)</span> <span class="o">:</span> <span class="n">sheaf</span> <span class="n">X</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">locality</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span> <span class="bp">⟨</span><span class="n">s</span><span class="o">,</span> <span class="n">hs</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">t</span><span class="o">,</span> <span class="n">ht</span><span class="bp">⟩</span> <span class="n">OC</span> <span class="n">H</span><span class="o">,</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">eq</span> <span class="err">$</span> <span class="n">F</span><span class="bp">.</span><span class="n">locality</span> <span class="n">U</span> <span class="n">s</span> <span class="n">t</span> <span class="n">OC</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span>
    <span class="k">have</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">congr_arg</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">val</span> <span class="o">(</span><span class="n">H</span> <span class="n">i</span><span class="o">),</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">gluing</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">OC</span> <span class="n">ss</span> <span class="n">H</span><span class="o">,</span> <span class="k">let</span> <span class="bp">⟨</span><span class="n">s</span><span class="o">,</span> <span class="n">hs</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">F</span><span class="bp">.</span><span class="n">gluing</span> <span class="n">U</span> <span class="n">OC</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">ss</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span>
      <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="k">have</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">congr_arg</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">val</span> <span class="o">(</span><span class="n">H</span> <span class="n">i</span> <span class="n">j</span><span class="o">),</span> <span class="n">this</span><span class="o">)</span> <span class="k">in</span>
    <span class="bp">⟨⟨</span><span class="n">s</span><span class="o">,</span> <span class="n">S</span><span class="bp">.</span><span class="n">mem_of_res_mem</span> <span class="n">OC</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="k">show</span> <span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="err">∈</span> <span class="bp">_</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">hs</span><span class="bp">;</span> <span class="n">exact</span> <span class="o">(</span><span class="n">ss</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">eq</span> <span class="err">$</span> <span class="o">(</span><span class="n">hs</span> <span class="n">i</span><span class="o">)</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="bp">..</span> <span class="n">S</span><span class="bp">.</span><span class="n">to_subpresheaf</span><span class="bp">.</span><span class="n">to_presheaf</span> <span class="o">}</span>

<span class="kn">end</span> <span class="n">subsheaf</span>

<span class="n">def</span> <span class="n">continuous_subsheaf</span> <span class="o">(</span><span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">Y</span><span class="o">]</span> <span class="o">:</span> <span class="n">subsheaf</span> <span class="o">(</span><span class="n">Func</span> <span class="n">X</span> <span class="n">Y</span><span class="o">)</span><span class="bp">.</span><span class="n">to_presheaf</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_set</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span><span class="o">,</span> <span class="o">{</span> <span class="n">f</span> <span class="bp">|</span> <span class="n">continuous</span> <span class="n">f</span> <span class="o">},</span>
  <span class="n">res_mem_to_set</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="n">s</span> <span class="n">hs</span><span class="o">,</span> <span class="n">hs</span><span class="bp">.</span><span class="n">comp</span> <span class="err">$</span> <span class="n">continuous_induced_rng</span> <span class="n">continuous_induced_dom</span><span class="o">,</span>
  <span class="n">mem_of_res_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">s</span> <span class="n">OC</span> <span class="n">H</span><span class="o">,</span> <span class="n">continuous_iff_continuous_at</span><span class="bp">.</span><span class="mi">2</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hxU</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="k">let</span> <span class="bp">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hi</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">OC</span><span class="bp">.</span><span class="n">exists_of_mem</span> <span class="n">x</span> <span class="n">hxU</span> <span class="k">in</span> <span class="bp">λ</span> <span class="n">V</span> <span class="n">HV</span><span class="o">,</span>
    <span class="k">let</span> <span class="bp">⟨</span><span class="n">t</span><span class="o">,</span> <span class="n">htV</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">u</span><span class="o">,</span> <span class="n">hu</span><span class="o">,</span> <span class="n">hut</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">hxt</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">mem_nhds_sets_iff</span><span class="bp">.</span><span class="mi">1</span> <span class="o">(</span><span class="n">continuous_iff_continuous_at</span><span class="bp">.</span><span class="mi">1</span> <span class="o">(</span><span class="n">H</span> <span class="n">i</span><span class="o">)</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hi</span><span class="bp">⟩</span> <span class="n">HV</span><span class="o">)</span> <span class="k">in</span>
    <span class="n">mem_nhds_sets_iff</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">⟨</span><span class="n">subtype</span><span class="bp">.</span><span class="n">val</span> <span class="bp">⁻¹</span><span class="err">&#39;</span> <span class="o">(</span><span class="n">subtype</span><span class="bp">.</span><span class="n">val</span> <span class="err">&#39;&#39;</span> <span class="n">t</span><span class="o">),</span>
      <span class="k">by</span> <span class="n">rintros</span> <span class="bp">⟨</span><span class="n">y</span><span class="o">,</span> <span class="n">hy</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">z</span><span class="o">,</span> <span class="n">hzt</span><span class="o">,</span> <span class="n">hzy</span><span class="bp">⟩;</span> <span class="n">dsimp</span> <span class="n">only</span> <span class="n">at</span> <span class="n">hzy</span><span class="bp">;</span> <span class="n">subst</span> <span class="n">hzy</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">htV</span> <span class="n">hzt</span><span class="o">,</span>
      <span class="bp">⟨</span><span class="n">u</span> <span class="err">∩</span> <span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">i</span><span class="o">,</span> <span class="n">is_open_inter</span> <span class="n">hu</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="err">←</span> <span class="n">hut</span><span class="o">,</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">image_preimage_val</span><span class="o">]</span><span class="bp">;</span> <span class="n">refl</span><span class="bp">⟩</span><span class="o">,</span>
      <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hi</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">hxt</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span> <span class="o">}</span>
</pre></div>

<a name="171403565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171403565" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171403565">Kenny Lau (Jul 22 2019 at 05:04)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">namespace</span> <span class="n">subpresheaf</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">X</span><span class="o">)</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_sup</span> <span class="o">(</span><span class="n">subpresheaf</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">S</span> <span class="n">T</span><span class="o">,</span> <span class="bp">⟨λ</span> <span class="n">U</span><span class="o">,</span> <span class="n">S</span> <span class="n">U</span> <span class="err">∪</span> <span class="n">T</span> <span class="n">U</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="n">s</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">imp</span> <span class="o">(</span><span class="n">S</span><span class="bp">.</span><span class="mi">2</span> <span class="n">HVU</span><span class="o">)</span> <span class="o">(</span><span class="n">T</span><span class="bp">.</span><span class="mi">2</span> <span class="n">HVU</span><span class="o">)</span><span class="bp">⟩⟩</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_inf</span> <span class="o">(</span><span class="n">subpresheaf</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">S</span> <span class="n">T</span><span class="o">,</span> <span class="bp">⟨λ</span> <span class="n">U</span><span class="o">,</span> <span class="n">S</span> <span class="n">U</span> <span class="err">∩</span> <span class="n">T</span> <span class="n">U</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="n">s</span><span class="o">,</span> <span class="n">and</span><span class="bp">.</span><span class="n">imp</span> <span class="o">(</span><span class="n">S</span><span class="bp">.</span><span class="mi">2</span> <span class="n">HVU</span><span class="o">)</span> <span class="o">(</span><span class="n">T</span><span class="bp">.</span><span class="mi">2</span> <span class="n">HVU</span><span class="o">)</span><span class="bp">⟩⟩</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_Sup</span> <span class="o">(</span><span class="n">subpresheaf</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">SS</span><span class="o">,</span> <span class="bp">⟨λ</span> <span class="n">U</span><span class="o">,</span> <span class="err">⋃</span> <span class="n">S</span> <span class="err">∈</span> <span class="n">SS</span><span class="o">,</span> <span class="n">to_set</span> <span class="n">S</span> <span class="n">U</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="n">s</span> <span class="n">hs</span><span class="o">,</span>
<span class="k">let</span> <span class="bp">⟨</span><span class="n">S</span><span class="o">,</span> <span class="n">HS</span><span class="o">,</span> <span class="n">hsS</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_bUnion_iff</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hs</span> <span class="k">in</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_bUnion_iff</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">⟨</span><span class="n">S</span><span class="o">,</span> <span class="n">HS</span><span class="o">,</span> <span class="n">S</span><span class="bp">.</span><span class="mi">2</span> <span class="n">HVU</span> <span class="n">hsS</span><span class="bp">⟩⟩⟩</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_Inf</span> <span class="o">(</span><span class="n">subpresheaf</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">SS</span><span class="o">,</span> <span class="bp">⟨λ</span> <span class="n">U</span><span class="o">,</span> <span class="err">⋂</span> <span class="n">S</span> <span class="err">∈</span> <span class="n">SS</span><span class="o">,</span> <span class="n">to_set</span> <span class="n">S</span> <span class="n">U</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="n">s</span> <span class="n">hs</span><span class="o">,</span>
<span class="n">set</span><span class="bp">.</span><span class="n">mem_bInter</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">S</span> <span class="n">HS</span><span class="o">,</span> <span class="n">S</span><span class="bp">.</span><span class="mi">2</span> <span class="n">HVU</span> <span class="err">$</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_bInter_iff</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hs</span> <span class="n">S</span> <span class="n">HS</span><span class="bp">⟩⟩</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_top</span> <span class="o">(</span><span class="n">subpresheaf</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨⟨λ</span> <span class="n">U</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">univ</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="n">s</span> <span class="bp">_</span><span class="o">,</span> <span class="n">trivial</span><span class="bp">⟩⟩</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_bot</span> <span class="o">(</span><span class="n">subpresheaf</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨⟨λ</span> <span class="n">U</span><span class="o">,</span> <span class="err">∅</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="n">s</span><span class="o">,</span> <span class="n">false</span><span class="bp">.</span><span class="n">elim</span><span class="bp">⟩⟩</span>

<span class="kn">instance</span> <span class="n">subpresheaf</span><span class="bp">.</span><span class="n">complete_lattice</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">complete_lattice</span> <span class="o">(</span><span class="n">subpresheaf</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">le_sup_left</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">S</span> <span class="n">T</span> <span class="n">U</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">subset_union_left</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">le_sup_right</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">S</span> <span class="n">T</span> <span class="n">U</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">subset_union_right</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">sup_le</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">S1</span> <span class="n">S2</span> <span class="n">S3</span> <span class="n">H13</span> <span class="n">H23</span> <span class="n">U</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">union_subset</span> <span class="o">(</span><span class="n">H13</span> <span class="n">U</span><span class="o">)</span> <span class="o">(</span><span class="n">H23</span> <span class="n">U</span><span class="o">),</span>
  <span class="n">inf_le_left</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">S</span> <span class="n">T</span> <span class="n">U</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">inter_subset_left</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">inf_le_right</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">S</span> <span class="n">T</span> <span class="n">U</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">inter_subset_right</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">le_inf</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">S1</span> <span class="n">S2</span> <span class="n">S3</span> <span class="n">H12</span> <span class="n">H13</span> <span class="n">U</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">subset_inter</span> <span class="o">(</span><span class="n">H12</span> <span class="n">U</span><span class="o">)</span> <span class="o">(</span><span class="n">H13</span> <span class="n">U</span><span class="o">),</span>
  <span class="n">le_top</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">S</span> <span class="n">U</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">subset_univ</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">bot_le</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">S</span> <span class="n">U</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">empty_subset</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">le_Sup</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">SS</span> <span class="n">S</span> <span class="n">HS</span> <span class="n">U</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">subset_bUnion_of_mem</span> <span class="n">HS</span><span class="o">,</span>
  <span class="n">Sup_le</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">SS</span> <span class="n">S</span> <span class="n">HS</span> <span class="n">U</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">bUnion_subset</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">T</span> <span class="n">HT</span><span class="o">,</span> <span class="n">HS</span> <span class="n">T</span> <span class="n">HT</span> <span class="n">U</span><span class="o">,</span>
  <span class="n">Inf_le</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">SS</span> <span class="n">S</span> <span class="n">HS</span> <span class="n">U</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">bInter_subset_of_mem</span> <span class="n">HS</span><span class="o">,</span>
  <span class="n">le_Inf</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">SS</span> <span class="n">S</span> <span class="n">HS</span> <span class="n">U</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">subset_bInter</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">T</span> <span class="n">HT</span><span class="o">,</span> <span class="n">HS</span> <span class="n">T</span> <span class="n">HT</span> <span class="n">U</span><span class="o">,</span>
  <span class="bp">..</span> <span class="n">subpresheaf</span><span class="bp">.</span><span class="n">partial_order</span> <span class="n">F</span><span class="o">,</span>
  <span class="bp">..</span> <span class="n">subpresheaf</span><span class="bp">.</span><span class="n">lattice</span><span class="bp">.</span><span class="n">has_sup</span> <span class="n">F</span><span class="o">,</span>
  <span class="bp">..</span> <span class="n">subpresheaf</span><span class="bp">.</span><span class="n">lattice</span><span class="bp">.</span><span class="n">has_inf</span> <span class="n">F</span><span class="o">,</span>
  <span class="bp">..</span> <span class="n">subpresheaf</span><span class="bp">.</span><span class="n">lattice</span><span class="bp">.</span><span class="n">has_Sup</span> <span class="n">F</span><span class="o">,</span>
  <span class="bp">..</span> <span class="n">subpresheaf</span><span class="bp">.</span><span class="n">lattice</span><span class="bp">.</span><span class="n">has_Inf</span> <span class="n">F</span><span class="o">,</span>
  <span class="bp">..</span> <span class="n">subpresheaf</span><span class="bp">.</span><span class="n">lattice</span><span class="bp">.</span><span class="n">has_top</span> <span class="n">F</span><span class="o">,</span>
  <span class="bp">..</span> <span class="n">subpresheaf</span><span class="bp">.</span><span class="n">lattice</span><span class="bp">.</span><span class="n">has_bot</span> <span class="n">F</span> <span class="o">}</span>

<span class="kn">end</span> <span class="n">subpresheaf</span>
</pre></div>

<a name="171404225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171404225" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171404225">Kenny Lau (Jul 22 2019 at 05:24)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">namespace</span> <span class="n">subsheaf</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">X</span><span class="o">)</span>

<span class="kn">instance</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">subsheaf</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨_</span><span class="o">,</span> <span class="n">to_set</span><span class="bp">⟩</span>

<span class="kn">instance</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">partial_order</span> <span class="o">(</span><span class="n">subsheaf</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">partial_order</span><span class="bp">.</span><span class="n">lift</span> <span class="n">to_set</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx1</span><span class="o">,</span> <span class="n">hx2</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">y</span><span class="o">,</span> <span class="n">hy1</span><span class="o">,</span> <span class="n">hy2</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">mk</span><span class="bp">.</span><span class="n">inj_eq</span><span class="bp">.</span><span class="n">mpr</span><span class="o">)</span> <span class="n">infer_instance</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_inf</span> <span class="o">(</span><span class="n">subsheaf</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">S</span> <span class="n">T</span><span class="o">,</span> <span class="bp">⟨λ</span> <span class="n">U</span><span class="o">,</span> <span class="n">S</span> <span class="n">U</span> <span class="err">∩</span> <span class="n">T</span> <span class="n">U</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="n">s</span><span class="o">,</span> <span class="n">and</span><span class="bp">.</span><span class="n">imp</span> <span class="o">(</span><span class="n">S</span><span class="bp">.</span><span class="mi">2</span> <span class="n">HVU</span><span class="o">)</span> <span class="o">(</span><span class="n">T</span><span class="bp">.</span><span class="mi">2</span> <span class="n">HVU</span><span class="o">),</span>
  <span class="bp">λ</span> <span class="n">U</span> <span class="n">s</span> <span class="n">OC</span> <span class="n">H</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">S</span><span class="bp">.</span><span class="mi">3</span> <span class="n">OC</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">H</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span> <span class="n">T</span><span class="bp">.</span><span class="mi">3</span> <span class="n">OC</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">H</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="bp">⟩⟩⟩</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_Inf</span> <span class="o">(</span><span class="n">subsheaf</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">SS</span><span class="o">,</span> <span class="bp">⟨λ</span> <span class="n">U</span><span class="o">,</span> <span class="err">⋂</span> <span class="n">S</span> <span class="err">∈</span> <span class="n">SS</span><span class="o">,</span> <span class="n">to_set</span> <span class="n">S</span> <span class="n">U</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="n">s</span> <span class="n">hs</span><span class="o">,</span>
<span class="n">set</span><span class="bp">.</span><span class="n">mem_bInter</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">S</span> <span class="n">HS</span><span class="o">,</span> <span class="n">S</span><span class="bp">.</span><span class="mi">2</span> <span class="n">HVU</span> <span class="err">$</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_bInter_iff</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hs</span> <span class="n">S</span> <span class="n">HS</span><span class="o">,</span>
<span class="bp">λ</span> <span class="n">U</span> <span class="n">s</span> <span class="n">OC</span> <span class="n">H</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_bInter</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">S</span> <span class="n">HS</span><span class="o">,</span> <span class="n">S</span><span class="bp">.</span><span class="mi">3</span> <span class="n">OC</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_bInter_iff</span><span class="bp">.</span><span class="mi">1</span> <span class="o">(</span><span class="n">H</span> <span class="n">i</span><span class="o">)</span> <span class="n">S</span> <span class="n">HS</span><span class="bp">⟩⟩</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_top</span> <span class="o">(</span><span class="n">subsheaf</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨⟨λ</span> <span class="n">U</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">univ</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="n">s</span> <span class="bp">_</span><span class="o">,</span> <span class="n">trivial</span><span class="o">,</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">trivial</span><span class="bp">⟩⟩</span>

<span class="kn">instance</span> <span class="n">subsheaf</span><span class="bp">.</span><span class="n">semilattice_inf_top</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">semilattice_inf_top</span> <span class="o">(</span><span class="n">subsheaf</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">inf_le_left</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">S</span> <span class="n">T</span> <span class="n">U</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">inter_subset_left</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">inf_le_right</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">S</span> <span class="n">T</span> <span class="n">U</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">inter_subset_right</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">le_inf</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">S1</span> <span class="n">S2</span> <span class="n">S3</span> <span class="n">H12</span> <span class="n">H13</span> <span class="n">U</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">subset_inter</span> <span class="o">(</span><span class="n">H12</span> <span class="n">U</span><span class="o">)</span> <span class="o">(</span><span class="n">H13</span> <span class="n">U</span><span class="o">),</span>
  <span class="n">le_top</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">S</span> <span class="n">U</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">subset_univ</span> <span class="bp">_</span><span class="o">,</span>
  <span class="bp">..</span> <span class="n">subsheaf</span><span class="bp">.</span><span class="n">partial_order</span> <span class="n">F</span><span class="o">,</span>
  <span class="bp">..</span> <span class="n">subsheaf</span><span class="bp">.</span><span class="n">lattice</span><span class="bp">.</span><span class="n">has_inf</span> <span class="n">F</span><span class="o">,</span>
  <span class="bp">..</span> <span class="n">subsheaf</span><span class="bp">.</span><span class="n">lattice</span><span class="bp">.</span><span class="n">has_Inf</span> <span class="n">F</span><span class="o">,</span>
  <span class="bp">..</span> <span class="n">subsheaf</span><span class="bp">.</span><span class="n">lattice</span><span class="bp">.</span><span class="n">has_top</span> <span class="n">F</span> <span class="o">}</span>

<span class="kn">theorem</span> <span class="n">Inf_le</span> <span class="o">(</span><span class="n">SS</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">subsheaf</span> <span class="n">F</span><span class="o">))</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">subsheaf</span> <span class="n">F</span><span class="o">)</span> <span class="o">(</span><span class="n">HS</span> <span class="o">:</span> <span class="n">S</span> <span class="err">∈</span> <span class="n">SS</span><span class="o">)</span> <span class="o">:</span> <span class="n">Inf</span> <span class="n">SS</span> <span class="bp">≤</span> <span class="n">S</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">U</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">bInter_subset_of_mem</span> <span class="n">HS</span>

<span class="kn">theorem</span> <span class="n">le_Inf</span> <span class="o">(</span><span class="n">SS</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">subsheaf</span> <span class="n">F</span><span class="o">))</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">subsheaf</span> <span class="n">F</span><span class="o">)</span> <span class="o">(</span><span class="n">HS</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">b</span> <span class="err">∈</span> <span class="n">SS</span><span class="o">,</span> <span class="n">S</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">≤</span> <span class="n">Inf</span> <span class="n">SS</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">U</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">subset_bInter</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">T</span> <span class="n">HT</span><span class="o">,</span> <span class="n">HS</span> <span class="n">T</span> <span class="n">HT</span> <span class="n">U</span>

<span class="kn">end</span> <span class="n">subsheaf</span>
</pre></div>

<a name="171404315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171404315" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171404315">Kenny Lau (Jul 22 2019 at 05:27)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">section_subsheaf</span> <span class="o">(</span><span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">π</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">subsheaf</span> <span class="o">(</span><span class="n">Func</span> <span class="n">X</span> <span class="n">Y</span><span class="o">)</span><span class="bp">.</span><span class="n">to_presheaf</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_set</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span><span class="o">,</span> <span class="o">{</span> <span class="n">s</span> <span class="bp">|</span> <span class="bp">∀</span> <span class="n">u</span> <span class="o">:</span> <span class="n">U</span><span class="o">,</span> <span class="n">π</span> <span class="o">(</span><span class="n">s</span> <span class="n">u</span><span class="o">)</span> <span class="bp">=</span> <span class="n">u</span><span class="bp">.</span><span class="mi">1</span> <span class="o">},</span>
  <span class="n">res_mem_to_set</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="n">s</span> <span class="n">hs</span> <span class="bp">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">hv</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">hs</span> <span class="bp">⟨</span><span class="n">v</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span>
  <span class="n">mem_of_res_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">s</span> <span class="n">OC</span> <span class="n">H</span> <span class="bp">⟨</span><span class="n">u</span><span class="o">,</span> <span class="n">hu</span><span class="bp">⟩</span><span class="o">,</span> <span class="k">let</span> <span class="bp">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hi</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">OC</span><span class="bp">.</span><span class="n">exists_of_mem</span> <span class="n">u</span> <span class="n">hu</span> <span class="k">in</span> <span class="n">H</span> <span class="n">i</span> <span class="bp">⟨</span><span class="n">u</span><span class="o">,</span> <span class="n">hi</span><span class="bp">⟩</span> <span class="o">}</span>
</pre></div>

<a name="171404373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171404373" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171404373">Kenny Lau (Jul 22 2019 at 05:28)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">continuous_section_subsheaf</span> <span class="o">(</span><span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">Y</span><span class="o">]</span> <span class="o">(</span><span class="n">π</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">subsheaf</span> <span class="o">(</span><span class="n">Func</span> <span class="n">X</span> <span class="n">Y</span><span class="o">)</span><span class="bp">.</span><span class="n">to_presheaf</span> <span class="o">:=</span>
<span class="n">continuous_subsheaf</span> <span class="n">Y</span> <span class="err">⊓</span> <span class="n">section_subsheaf</span> <span class="n">Y</span> <span class="n">π</span>
</pre></div>

<a name="171404842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171404842" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171404842">Johan Commelin (Jul 22 2019 at 05:42)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> What is your objection against using functors on <code>(opens X)^op</code>?</p>

<a name="171404872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171404872" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171404872">Kenny Lau (Jul 22 2019 at 05:43)</a>:</h4>
<p>the large amount of unop required</p>

<a name="171404935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171404935" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171404935">Johan Commelin (Jul 22 2019 at 05:45)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> Should we make a <code>cv_functor</code>?</p>

<a name="171405068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171405068" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171405068">Johan Commelin (Jul 22 2019 at 05:49)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> Given that you already have this <code>covering</code> class. How hard do you think it is to generalise to sites?</p>

<a name="171405071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171405071" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171405071">Johan Commelin (Jul 22 2019 at 05:49)</a>:</h4>
<p>Do you see particular troubles on the road?</p>

<a name="171405075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171405075" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171405075">Kenny Lau (Jul 22 2019 at 05:49)</a>:</h4>
<p>I dont know</p>

<a name="171405342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171405342" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171405342">Scott Morrison (Jul 22 2019 at 05:55)</a>:</h4>
<p><code>cv_functor</code> feels like we’d be unnecessarily multiplying entities.</p>

<a name="171405432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171405432" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171405432">Scott Morrison (Jul 22 2019 at 05:56)</a>:</h4>
<p>I’m not so sure there is so much <code>unopened required. This is certainly the way I felt at first when you guys insists I couldn’t just define </code>opens X<code> as what is now </code>(opens X)^op`, but it never got particularly bad.</p>

<a name="171405443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171405443" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171405443">Scott Morrison (Jul 22 2019 at 05:56)</a>:</h4>
<p>I don’t like essentially redefining functors here. It’s a recipe for duplication and confusion.</p>

<a name="171406066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171406066" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171406066">Johan Commelin (Jul 22 2019 at 06:11)</a>:</h4>
<p>Is there a coordinated approach to navigate ourselves out of this mess? We've been talking about sheafy things for more than a year, and mathlib still doesn't have them.<br>
I'm fine with ignoring sites for the moment. There is loads of interesting stuff to say about sheaves on topological spaces.</p>

<a name="171421457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171421457" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171421457">Kenny Lau (Jul 22 2019 at 11:10)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">germ</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span>
<span class="o">(</span><span class="n">hxU</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">U</span><span class="o">)</span>
<span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">F</span> <span class="n">U</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">germ</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">setoid</span> <span class="o">(</span><span class="n">germ</span> <span class="n">F</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">r</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g1</span> <span class="n">g2</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">U</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">,</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">U</span> <span class="bp">∧</span> <span class="bp">∃</span> <span class="n">H1</span> <span class="o">:</span> <span class="n">U</span> <span class="bp">≤</span> <span class="n">g1</span><span class="bp">.</span><span class="n">U</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">H2</span> <span class="o">:</span> <span class="n">U</span> <span class="bp">≤</span> <span class="n">g2</span><span class="bp">.</span><span class="n">U</span><span class="o">,</span> <span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">g1</span><span class="bp">.</span><span class="n">U</span> <span class="n">U</span> <span class="n">H1</span> <span class="n">g1</span><span class="bp">.</span><span class="n">s</span> <span class="bp">=</span> <span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">g2</span><span class="bp">.</span><span class="n">U</span> <span class="n">U</span> <span class="n">H2</span> <span class="n">g2</span><span class="bp">.</span><span class="n">s</span><span class="o">,</span>
  <span class="n">iseqv</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="n">g1</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">g1</span><span class="bp">.</span><span class="n">U</span><span class="o">,</span> <span class="n">g1</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span> <span class="n">le_refl</span> <span class="bp">_</span><span class="o">,</span> <span class="n">le_refl</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="bp">λ</span> <span class="n">g1</span> <span class="n">g2</span> <span class="bp">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">hx</span><span class="o">,</span> <span class="n">H1</span><span class="o">,</span> <span class="n">H2</span><span class="o">,</span> <span class="n">H3</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">hx</span><span class="o">,</span> <span class="n">H2</span><span class="o">,</span> <span class="n">H1</span><span class="o">,</span> <span class="n">H3</span><span class="bp">.</span><span class="n">symm</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="bp">λ</span> <span class="n">g1</span> <span class="n">g2</span> <span class="n">g3</span> <span class="bp">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">hxU</span><span class="o">,</span> <span class="n">H1</span><span class="o">,</span> <span class="n">H2</span><span class="o">,</span> <span class="n">H3</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">V</span><span class="o">,</span> <span class="n">hxV</span><span class="o">,</span> <span class="n">H4</span><span class="o">,</span> <span class="n">H5</span><span class="o">,</span> <span class="n">H6</span><span class="bp">⟩</span><span class="o">,</span>
      <span class="bp">⟨</span><span class="n">U</span> <span class="err">⊓</span> <span class="n">V</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">hxU</span><span class="o">,</span> <span class="n">hxV</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">le_trans</span> <span class="n">inf_le_left</span> <span class="n">H1</span><span class="o">,</span> <span class="n">le_trans</span> <span class="n">inf_le_right</span> <span class="n">H5</span><span class="o">,</span>
      <span class="k">calc</span>  <span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">g1</span><span class="bp">.</span><span class="n">U</span> <span class="o">(</span><span class="n">U</span> <span class="err">⊓</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">le_trans</span> <span class="n">inf_le_left</span> <span class="n">H1</span><span class="o">)</span> <span class="n">g1</span><span class="bp">.</span><span class="n">s</span>
          <span class="bp">=</span> <span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">U</span> <span class="o">(</span><span class="n">U</span> <span class="err">⊓</span> <span class="n">V</span><span class="o">)</span> <span class="n">inf_le_left</span> <span class="o">(</span><span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">g1</span><span class="bp">.</span><span class="n">U</span> <span class="n">U</span> <span class="n">H1</span> <span class="n">g1</span><span class="bp">.</span><span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">F</span><span class="bp">.</span><span class="n">res_res</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">U</span> <span class="o">(</span><span class="n">U</span> <span class="err">⊓</span> <span class="n">V</span><span class="o">)</span> <span class="n">inf_le_left</span> <span class="o">(</span><span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">g2</span><span class="bp">.</span><span class="n">U</span> <span class="n">U</span> <span class="n">H2</span> <span class="n">g2</span><span class="bp">.</span><span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">H3</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">V</span> <span class="o">(</span><span class="n">U</span> <span class="err">⊓</span> <span class="n">V</span><span class="o">)</span> <span class="n">inf_le_right</span> <span class="o">(</span><span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">g2</span><span class="bp">.</span><span class="n">U</span> <span class="n">V</span> <span class="n">H4</span> <span class="n">g2</span><span class="bp">.</span><span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">F</span><span class="bp">.</span><span class="n">res_res</span><span class="o">,</span> <span class="n">F</span><span class="bp">.</span><span class="n">res_res</span><span class="o">]</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">V</span> <span class="o">(</span><span class="n">U</span> <span class="err">⊓</span> <span class="n">V</span><span class="o">)</span> <span class="n">inf_le_right</span> <span class="o">(</span><span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">g3</span><span class="bp">.</span><span class="n">U</span> <span class="n">V</span> <span class="n">H5</span> <span class="n">g3</span><span class="bp">.</span><span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">H6</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">g3</span><span class="bp">.</span><span class="n">U</span> <span class="o">(</span><span class="n">U</span> <span class="err">⊓</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">le_trans</span> <span class="n">inf_le_right</span> <span class="n">H5</span><span class="o">)</span> <span class="n">g3</span><span class="bp">.</span><span class="n">s</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">F</span><span class="bp">.</span><span class="n">res_res</span><span class="bp">⟩⟩</span> <span class="o">}</span>

<span class="kn">end</span> <span class="n">germ</span>

<span class="n">def</span> <span class="n">stalk</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">quotient</span> <span class="o">(</span><span class="n">germ</span><span class="bp">.</span><span class="n">setoid</span> <span class="n">F</span> <span class="n">x</span><span class="o">)</span>

<span class="n">def</span> <span class="n">to_stalk</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">hxU</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">U</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">F</span> <span class="n">U</span><span class="o">)</span> <span class="o">:</span> <span class="n">stalk</span> <span class="n">F</span> <span class="n">x</span> <span class="o">:=</span>
<span class="err">⟦</span><span class="bp">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">hxU</span><span class="o">,</span> <span class="n">s</span><span class="bp">⟩</span><span class="err">⟧</span>

<span class="kn">theorem</span> <span class="n">to_stalk_res</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">U</span> <span class="n">V</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">hxV</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">HVU</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">≤</span> <span class="n">U</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">F</span> <span class="n">U</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">to_stalk</span> <span class="n">F</span> <span class="n">x</span> <span class="n">V</span> <span class="n">hxV</span> <span class="o">(</span><span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="n">s</span><span class="o">)</span> <span class="bp">=</span> <span class="n">to_stalk</span> <span class="n">F</span> <span class="n">x</span> <span class="n">U</span> <span class="o">(</span><span class="n">HVU</span> <span class="n">hxV</span><span class="o">)</span> <span class="n">s</span> <span class="o">:=</span>
<span class="n">quotient</span><span class="bp">.</span><span class="n">sound</span> <span class="bp">⟨</span><span class="n">V</span><span class="o">,</span> <span class="n">hxV</span><span class="o">,</span> <span class="n">le_refl</span> <span class="n">V</span><span class="o">,</span> <span class="n">HVU</span><span class="o">,</span> <span class="n">F</span><span class="bp">.</span><span class="n">res_res</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_⟩</span>

<span class="n">def</span> <span class="n">espace_etale</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="err">Σ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">stalk</span> <span class="n">F</span> <span class="n">x</span>

<span class="kn">instance</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="o">(</span><span class="n">espace_etale</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">is_open</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">S</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">S</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">U</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">hxU</span> <span class="o">:</span> <span class="n">sigma</span><span class="bp">.</span><span class="n">fst</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">U</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">s</span> <span class="o">:</span> <span class="n">F</span> <span class="n">U</span><span class="o">,</span> <span class="n">to_stalk</span> <span class="n">F</span> <span class="n">x</span><span class="bp">.</span><span class="mi">1</span> <span class="n">U</span> <span class="n">hxU</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">x</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">∧</span>
    <span class="bp">∀</span> <span class="n">p</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">hpU</span> <span class="o">:</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">U</span><span class="o">,</span> <span class="o">(</span><span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">to_stalk</span> <span class="n">F</span> <span class="n">p</span> <span class="n">U</span> <span class="n">hpU</span> <span class="n">s</span><span class="bp">⟩</span> <span class="o">:</span> <span class="n">espace_etale</span> <span class="n">F</span><span class="o">)</span> <span class="err">∈</span> <span class="n">S</span><span class="o">,</span>
  <span class="n">is_open_univ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">g</span><span class="bp">⟩</span> <span class="bp">_</span><span class="o">,</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">induction_on</span> <span class="n">g</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">hpU</span><span class="o">,</span> <span class="n">s</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">hpU</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">trivial</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">is_open_inter</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">S</span> <span class="n">T</span> <span class="n">HS</span> <span class="n">HT</span> <span class="n">x</span> <span class="n">hxST</span><span class="o">,</span> <span class="k">let</span> <span class="bp">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">hxU</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">hsx</span><span class="o">,</span> <span class="n">hs</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">HS</span> <span class="n">x</span> <span class="n">hxST</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span>
    <span class="bp">⟨</span><span class="n">V</span><span class="o">,</span> <span class="n">hxV</span><span class="o">,</span> <span class="n">t</span><span class="o">,</span> <span class="n">htx</span><span class="o">,</span> <span class="n">ht</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">HT</span> <span class="n">x</span> <span class="n">hxST</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">W</span><span class="o">,</span> <span class="n">hxW</span><span class="o">,</span> <span class="n">HWU</span><span class="o">,</span> <span class="n">HWV</span><span class="o">,</span> <span class="n">h</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">exact</span> <span class="o">(</span><span class="n">hsx</span><span class="bp">.</span><span class="n">trans</span> <span class="n">htx</span><span class="bp">.</span><span class="n">symm</span><span class="o">)</span> <span class="k">in</span>
    <span class="bp">⟨</span><span class="n">W</span><span class="o">,</span> <span class="n">hxW</span><span class="o">,</span> <span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">U</span> <span class="n">W</span> <span class="n">HWU</span> <span class="n">s</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">to_stalk_res</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">hsx</span><span class="o">,</span>
    <span class="bp">λ</span> <span class="n">q</span> <span class="n">hqW</span><span class="o">,</span> <span class="bp">⟨</span><span class="k">by</span> <span class="n">rw</span> <span class="n">to_stalk_res</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">hs</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">to_stalk_res</span><span class="o">]</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">ht</span><span class="bp">⟩⟩</span><span class="o">,</span>
  <span class="n">is_open_sUnion</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">SS</span> <span class="n">H</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="k">let</span> <span class="bp">⟨</span><span class="n">t</span><span class="o">,</span> <span class="n">htSS</span><span class="o">,</span> <span class="n">hxt</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_sUnion</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hx</span><span class="o">,</span>
    <span class="bp">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">hxU</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">hsx</span><span class="o">,</span> <span class="n">hs</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">H</span> <span class="n">t</span> <span class="n">htSS</span> <span class="n">x</span> <span class="n">hxt</span> <span class="k">in</span> <span class="bp">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">hxU</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">hsx</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">p</span> <span class="n">hpU</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_sUnion_of_mem</span> <span class="o">(</span><span class="n">hs</span> <span class="n">p</span> <span class="n">hpU</span><span class="o">)</span> <span class="n">htSS</span><span class="bp">⟩</span> <span class="o">}</span>

<span class="n">def</span> <span class="n">of_espace_etale</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">espace_etale</span> <span class="n">F</span><span class="o">)</span> <span class="o">:</span> <span class="n">X</span> <span class="o">:=</span>
<span class="n">x</span><span class="bp">.</span><span class="mi">1</span>

<span class="kn">theorem</span> <span class="n">continuous_of_espace_etale</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">continuous</span> <span class="o">(</span><span class="n">of_espace_etale</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">U</span> <span class="n">HU</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">g</span><span class="bp">⟩</span> <span class="n">hpU</span><span class="o">,</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">induction_on</span> <span class="n">g</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">V</span><span class="o">,</span> <span class="n">hpV</span><span class="o">,</span> <span class="n">s</span><span class="bp">⟩</span><span class="o">,</span>
<span class="bp">⟨⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">HU</span><span class="bp">⟩</span> <span class="err">⊓</span> <span class="n">V</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">hpU</span><span class="o">,</span> <span class="n">hpV</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">V</span> <span class="bp">_</span> <span class="n">inf_le_right</span> <span class="n">s</span><span class="o">,</span> <span class="n">to_stalk_res</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">q</span> <span class="n">hqUV</span><span class="o">,</span> <span class="n">hqUV</span><span class="bp">.</span><span class="mi">1</span><span class="bp">⟩</span>
</pre></div>

<a name="171421618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171421618" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171421618">Johan Commelin (Jul 22 2019 at 11:13)</a>:</h4>
<p>Kenny, you realise that presheaves and stalks are already in mathlib?</p>

<a name="171426874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171426874" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171426874">Kevin Buzzard (Jul 22 2019 at 12:46)</a>:</h4>
<p>But are those presheaves usable? Kenny has <a href="https://github.com/ramonfmir/lean-scheme/blob/master/src/Kenny/sheaf_of_rings_on_opens.lean" target="_blank" title="https://github.com/ramonfmir/lean-scheme/blob/master/src/Kenny/sheaf_of_rings_on_opens.lean">glued sheaves of rings</a> and proved the universal property. Last time I talked to Scott he was still trying to work out the best way to define a sheaf. The schemes project has a definition of presheaf which is not the same as the one in mathlib but we are miles ahead of mathlib and it is my firm belief that because the mathlib definition is not the best way of doing sheaves in dependent type theory, that gap is only set to grow.</p>

<a name="171426994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171426994" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171426994">Kevin Buzzard (Jul 22 2019 at 12:48)</a>:</h4>
<p>To define products of schemes we do it in the affine case and then glue the top space and glue the sheaves of rings. We need products and pullbacks etc to define cohomology. We have a system that works and is moving fast. You have a definition of a presheaf. Some serious decisions need to be made.</p>

<a name="171427038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171427038" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171427038">Kevin Buzzard (Jul 22 2019 at 12:49)</a>:</h4>
<p>I tried to <em>state</em> the construction of glueing presheaves of types using the mathlib language and it was a nightmare.</p>

<a name="171427279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171427279" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171427279">Johan Commelin (Jul 22 2019 at 12:53)</a>:</h4>
<p>I really don't understand this. Your definition of a presheaf is a special case of a contravariant functor. The mathlib definition is the same. I cannot see where the trouble lies.</p>

<a name="171427298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171427298" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171427298">Johan Commelin (Jul 22 2019 at 12:53)</a>:</h4>
<p>Sure, with the sheaf condition there might be trouble.</p>

<a name="171427322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171427322" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171427322">Johan Commelin (Jul 22 2019 at 12:53)</a>:</h4>
<p>I would very much like to see PR's going from the schemes project to mathlib. But I haven't seen any PR's apart from a 20 line thingy on kernels of ring morphisms.</p>

<a name="171427461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171427461" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171427461">Johan Commelin (Jul 22 2019 at 12:55)</a>:</h4>
<p>And I'm not saying that we have to use the category lib per se. But (i) avoiding duplication seems a good thing, and (ii) we'll need categorical machinery to build machines for cohomology theories. Unless we don't want those machines.</p>

<a name="171427520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171427520" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171427520">Kevin Buzzard (Jul 22 2019 at 12:56)</a>:</h4>
<p>I agree that we'll have to the the categorical language in the end.</p>

<a name="171427532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171427532" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171427532">Kevin Buzzard (Jul 22 2019 at 12:56)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> are you going to PR glueing sheaves of rings?</p>

<a name="171427656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171427656" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171427656">Kevin Buzzard (Jul 22 2019 at 12:58)</a>:</h4>
<blockquote>
<p>Sure, with the sheaf condition there might be trouble.</p>
</blockquote>
<p>We had no trouble at all with the sheaf condition. What is the trouble you are having? You say your presheaves are "the same" as ours but then sheaves might be trouble for you, and not for us?</p>

<a name="171427917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171427917" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171427917">Johan Commelin (Jul 22 2019 at 13:00)</a>:</h4>
<p>I mean that if you want to state the sheaf condition using categorical language, saying that some diagram is an equalizer.</p>

<a name="171428060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171428060" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171428060">Johan Commelin (Jul 22 2019 at 13:02)</a>:</h4>
<p>Kenny said he didn't like the <code>unop</code>s that our definition gave. Ok, I understand that. But that's life.</p>

<a name="171428087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171428087" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171428087">Johan Commelin (Jul 22 2019 at 13:02)</a>:</h4>
<p>We have lot's of annoying little things popping up in our goals that you can't see in maths.</p>

<a name="171428119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171428119" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171428119">Johan Commelin (Jul 22 2019 at 13:03)</a>:</h4>
<p>I don't like all the <code>to_additive</code> statements in mathlib. They are complete stupid. But it is the best solution we have.</p>

<a name="171428255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171428255" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171428255">Johan Commelin (Jul 22 2019 at 13:04)</a>:</h4>
<p>Kenny and Mario did a wonderful job with the gluing of sheaves thing. Now it should go to mathlib, instead of rot away on a Zulip thread.</p>

<a name="171433738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171433738" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171433738">Kevin Buzzard (Jul 22 2019 at 14:10)</a>:</h4>
<p>But they use a different definition of presheaf to the one in mathlib. I am not clear about how you want to take this forward.</p>

<a name="171436657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171436657" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171436657">Johan Commelin (Jul 22 2019 at 14:45)</a>:</h4>
<p>Is it different from the one Kenny is using in this thread? Because the one in this thread is only syntactically different from the one in mathlib.</p>

<a name="171436748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171436748" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171436748">Kevin Buzzard (Jul 22 2019 at 14:46)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">presheaf</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">F</span>     <span class="o">:</span> <span class="n">opens</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span>
<span class="o">(</span><span class="n">res</span>   <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">U</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">HVU</span> <span class="o">:</span> <span class="n">V</span> <span class="err">⊆</span> <span class="n">U</span><span class="o">),</span> <span class="n">F</span> <span class="n">U</span> <span class="bp">→</span> <span class="n">F</span> <span class="n">V</span><span class="o">)</span>
<span class="o">(</span><span class="n">Hid</span>   <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">U</span><span class="o">),</span> <span class="n">res</span> <span class="n">U</span> <span class="n">U</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">subset</span><span class="bp">.</span><span class="n">refl</span> <span class="n">U</span><span class="o">)</span> <span class="bp">=</span> <span class="n">id</span><span class="o">)</span>
<span class="o">(</span><span class="n">Hcomp</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">U</span> <span class="n">V</span> <span class="n">W</span><span class="o">)</span> <span class="o">(</span><span class="n">HWV</span> <span class="o">:</span> <span class="n">W</span> <span class="err">⊆</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">HVU</span> <span class="o">:</span> <span class="n">V</span> <span class="err">⊆</span> <span class="n">U</span><span class="o">),</span>
  <span class="n">res</span> <span class="n">U</span> <span class="n">W</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">subset</span><span class="bp">.</span><span class="n">trans</span> <span class="n">HWV</span> <span class="n">HVU</span><span class="o">)</span> <span class="bp">=</span> <span class="n">res</span> <span class="n">V</span> <span class="n">W</span> <span class="n">HWV</span> <span class="err">∘</span> <span class="n">res</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span><span class="o">)</span>
</pre></div>

<a name="171437001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171437001" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171437001">Kevin Buzzard (Jul 22 2019 at 14:49)</a>:</h4>
<p>Mathlib:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">presheaf</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Top</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">})</span> <span class="o">:=</span> <span class="o">(</span><span class="n">opens</span> <span class="n">X</span><span class="o">)</span><span class="err">ᵒᵖ</span> <span class="err">⥤</span> <span class="n">C</span>
</pre></div>

<a name="171437085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171437085" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171437085">Johan Commelin (Jul 22 2019 at 14:50)</a>:</h4>
<p>But <code>⥤</code> expands to your <code>structure</code> (up to contravariance).</p>

<a name="171437242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171437242" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171437242">Kevin Buzzard (Jul 22 2019 at 14:52)</a>:</h4>
<p>so ours is slightly better for this use case because we don't have the <code>op</code> issues.</p>

<a name="171437292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171437292" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171437292">Kevin Buzzard (Jul 22 2019 at 14:53)</a>:</h4>
<p>I don't know how serious they are to deal with though, I have never used categories seriously.</p>

<a name="171437418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171437418" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171437418">Kevin Buzzard (Jul 22 2019 at 14:54)</a>:</h4>
<p>I can see Kenny's point of view though, he made what he needed in the simplest way and he knows how to work with it.</p>

<a name="171437454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171437454" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171437454">Kevin Buzzard (Jul 22 2019 at 14:55)</a>:</h4>
<p>The issue that was holding me back was another one, namely the question on how to define a sheaf on an open subset of X.</p>

<a name="171437476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171437476" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171437476">Kevin Buzzard (Jul 22 2019 at 14:55)</a>:</h4>
<p>Kenny just defined it to be a sheaf on X.</p>

<a name="171437494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171437494" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171437494">Kevin Buzzard (Jul 22 2019 at 14:55)</a>:</h4>
<p>and then never used <code>=</code></p>

<a name="171437673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171437673" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171437673">Johan Commelin (Jul 22 2019 at 14:57)</a>:</h4>
<p>Sure, but that is orthogonal to whether you use the category library.</p>

<a name="171437748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171437748" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171437748">Kevin Buzzard (Jul 22 2019 at 14:58)</a>:</h4>
<p>Kenny is just using the definition which is most convenient for doing what it is he wants to do</p>

<a name="171437770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171437770" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171437770">Kevin Buzzard (Jul 22 2019 at 14:58)</a>:</h4>
<p>The category theory library offers this slightly more bundled experience and the added inconvenience of the ops.</p>

<a name="171437791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171437791" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171437791">Kevin Buzzard (Jul 22 2019 at 14:59)</a>:</h4>
<p>I can see why he's chosen to do it this way.</p>

<a name="171438441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171438441" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171438441">Johan Commelin (Jul 22 2019 at 15:06)</a>:</h4>
<p>Do you already have the adjunction between ^* and _*?</p>

<a name="171438446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171438446" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171438446">Johan Commelin (Jul 22 2019 at 15:06)</a>:</h4>
<p>If you have that, I'll shut up.</p>

<a name="171438477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171438477" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171438477">Kevin Buzzard (Jul 22 2019 at 15:07)</a>:</h4>
<p>We only have pullback along an open map because we don't have sheafification.</p>

<a name="171438502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171438502" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171438502">Kevin Buzzard (Jul 22 2019 at 15:07)</a>:</h4>
<p>Wait -- are you asking about presheaves or sheaves? We don't define presheaf pullback</p>

<a name="171438528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171438528" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171438528">Kevin Buzzard (Jul 22 2019 at 15:07)</a>:</h4>
<p>(deleted)</p>

<a name="171439077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171439077" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171439077">Johan Commelin (Jul 22 2019 at 15:14)</a>:</h4>
<p>I'm asking about sheaves.</p>

<a name="171439091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171439091" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171439091">Johan Commelin (Jul 22 2019 at 15:14)</a>:</h4>
<p>But I think we want both.</p>

<a name="171439244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171439244" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171439244">Johan Commelin (Jul 22 2019 at 15:16)</a>:</h4>
<p>I'm not married to the category library. It's just that there's a bunch of general purpose tools there that I feel we are now duplicating. I think it might pay of to debug any problems that show up when using the category library. Because if we make the category lib usable, we can apply it in other situations as well.</p>

<a name="171440737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171440737" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171440737">Kevin Buzzard (Jul 22 2019 at 15:33)</a>:</h4>
<p>We haven't defined pullback because we haven't defined sheafification.</p>

<a name="171466155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171466155" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171466155">Brendan Seamas Murphy (Jul 22 2019 at 20:44)</a>:</h4>
<p>I have a working local implementation of sheafification (for presheaves abelian groups). Can I help out with this somehow?</p>

<a name="171470883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171470883" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171470883">Kevin Buzzard (Jul 22 2019 at 21:46)</a>:</h4>
<p>Did you prove the adjointness? :-) </p>
<p>Here's the situation. Johan is concerned that an MSc student of mine came up with another definition of presheaf (following me, who defined a presheaf 18 months ago in Lean without knowing anything about how category theory worked in Lean). Now this is becoming an issue because there's another definition of presheaf in mathlib, but various Imperial students are just pushing ahead and developing a nice little theory of schemes mostly by themselves:</p>
<p><a href="https://github.com/ramonfmir/lean-scheme" target="_blank" title="https://github.com/ramonfmir/lean-scheme">https://github.com/ramonfmir/lean-scheme</a></p>
<p>The initial purpose of that repo was an MSc project, which is now done. Johan is concerned that if the work doesn't get PR'ed to mathlib it will bitrot; however it is using an incompatible definition of presheaf.  It would not surprise me if Kenny Lau was interested in your sheafification stuff. Which definition of presheaf did you use? :-)</p>

<a name="171488482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171488482" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171488482">Johan Commelin (Jul 23 2019 at 04:23)</a>:</h4>
<p><span class="user-mention" data-user-id="231775">@Brendan Seamas Murphy</span> Nice! Well done!</p>

<a name="171488524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171488524" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171488524">Brendan Seamas Murphy (Jul 23 2019 at 04:24)</a>:</h4>
<p>Oh I haven't got the adjointness down (well I was planning on doing the universal property but I think that's the same thing)</p>

<a name="171488526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171488526" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171488526">Brendan Seamas Murphy (Jul 23 2019 at 04:24)</a>:</h4>
<p>I used the definition in the lean-schemes repo</p>

<a name="171488529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171488529" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171488529">Brendan Seamas Murphy (Jul 23 2019 at 04:24)</a>:</h4>
<p>Copied the ring stuff and changed the type classes</p>

<a name="171488531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171488531" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171488531">Brendan Seamas Murphy (Jul 23 2019 at 04:24)</a>:</h4>
<p>Thanks Johan!</p>

<a name="171489040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171489040" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171489040">Johan Commelin (Jul 23 2019 at 04:40)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> <span class="user-mention" data-user-id="110064">@Kenny Lau</span> Let me stress that in the end I don't really care about the shape and form of the solution. I would be very happy to (i) reach some synthesis sooner than later, and (ii) see things moving towards mathlib.</p>

<a name="171490301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171490301" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171490301">Kenny Lau (Jul 23 2019 at 05:15)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> I have "relative" sheafification</p>

<a name="171501620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171501620" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171501620">Kevin Buzzard (Jul 23 2019 at 09:09)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> do you believe this work on gluing schemes should be in mathlib and do you have an opinion on the two definitions of presheaf?</p>

<a name="171504587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171504587" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171504587">Kenny Lau (Jul 23 2019 at 09:59)</a>:</h4>
<p>I would consult <span class="user-mention" data-user-id="110049">@Mario Carneiro</span></p>

<a name="171524227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171524227" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171524227">Kenny Lau (Jul 23 2019 at 14:34)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">to_stalk_res</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">U</span> <span class="n">V</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">hxV</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">HVU</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">≤</span> <span class="n">U</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">F</span> <span class="n">U</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">to_stalk</span> <span class="n">F</span> <span class="n">x</span> <span class="n">V</span> <span class="n">hxV</span> <span class="o">(</span><span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="n">s</span><span class="o">)</span> <span class="bp">=</span> <span class="n">to_stalk</span> <span class="n">F</span> <span class="n">x</span> <span class="n">U</span> <span class="o">(</span><span class="n">HVU</span> <span class="n">hxV</span><span class="o">)</span> <span class="n">s</span> <span class="o">:=</span>
<span class="n">quotient</span><span class="bp">.</span><span class="n">sound</span> <span class="bp">⟨</span><span class="n">V</span><span class="o">,</span> <span class="n">hxV</span><span class="o">,</span> <span class="n">le_refl</span> <span class="n">V</span><span class="o">,</span> <span class="n">HVU</span><span class="o">,</span> <span class="n">F</span><span class="bp">.</span><span class="n">res_res</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_⟩</span>

<span class="n">def</span> <span class="n">espace_etale</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="err">Σ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">stalk</span> <span class="n">F</span> <span class="n">x</span>

<span class="n">def</span> <span class="n">of_espace_etale</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">espace_etale</span> <span class="n">F</span><span class="o">)</span> <span class="o">:</span> <span class="n">X</span> <span class="o">:=</span>
<span class="n">x</span><span class="bp">.</span><span class="mi">1</span>

<span class="n">def</span> <span class="n">to_espace_etale</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">F</span> <span class="n">U</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">U</span><span class="o">)</span> <span class="o">:</span> <span class="n">espace_etale</span> <span class="n">F</span> <span class="o">:=</span>
<span class="bp">⟨</span><span class="n">p</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span> <span class="n">to_stalk</span> <span class="n">F</span> <span class="n">p</span><span class="bp">.</span><span class="mi">1</span> <span class="n">U</span> <span class="n">p</span><span class="bp">.</span><span class="mi">2</span> <span class="n">s</span><span class="bp">⟩</span>

<span class="kn">instance</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="o">(</span><span class="n">espace_etale</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">is_open</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">S</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">S</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">U</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">hxU</span> <span class="o">:</span> <span class="n">sigma</span><span class="bp">.</span><span class="n">fst</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">U</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">s</span> <span class="o">:</span> <span class="n">F</span> <span class="n">U</span><span class="o">,</span> <span class="n">to_stalk</span> <span class="n">F</span> <span class="n">x</span><span class="bp">.</span><span class="mi">1</span> <span class="n">U</span> <span class="n">hxU</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">x</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">∧</span>
    <span class="bp">∀</span> <span class="n">p</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">hpU</span> <span class="o">:</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">U</span><span class="o">,</span> <span class="o">(</span><span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">to_stalk</span> <span class="n">F</span> <span class="n">p</span> <span class="n">U</span> <span class="n">hpU</span> <span class="n">s</span><span class="bp">⟩</span> <span class="o">:</span> <span class="n">espace_etale</span> <span class="n">F</span><span class="o">)</span> <span class="err">∈</span> <span class="n">S</span><span class="o">,</span>
  <span class="n">is_open_univ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">g</span><span class="bp">⟩</span> <span class="bp">_</span><span class="o">,</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">induction_on</span> <span class="n">g</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">hpU</span><span class="o">,</span> <span class="n">s</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">hpU</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">trivial</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">is_open_inter</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">S</span> <span class="n">T</span> <span class="n">HS</span> <span class="n">HT</span> <span class="n">x</span> <span class="n">hxST</span><span class="o">,</span> <span class="k">let</span> <span class="bp">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">hxU</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">hsx</span><span class="o">,</span> <span class="n">hs</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">HS</span> <span class="n">x</span> <span class="n">hxST</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span>
    <span class="bp">⟨</span><span class="n">V</span><span class="o">,</span> <span class="n">hxV</span><span class="o">,</span> <span class="n">t</span><span class="o">,</span> <span class="n">htx</span><span class="o">,</span> <span class="n">ht</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">HT</span> <span class="n">x</span> <span class="n">hxST</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">W</span><span class="o">,</span> <span class="n">hxW</span><span class="o">,</span> <span class="n">HWU</span><span class="o">,</span> <span class="n">HWV</span><span class="o">,</span> <span class="n">h</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">exact</span> <span class="o">(</span><span class="n">hsx</span><span class="bp">.</span><span class="n">trans</span> <span class="n">htx</span><span class="bp">.</span><span class="n">symm</span><span class="o">)</span> <span class="k">in</span>
    <span class="bp">⟨</span><span class="n">W</span><span class="o">,</span> <span class="n">hxW</span><span class="o">,</span> <span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">U</span> <span class="n">W</span> <span class="n">HWU</span> <span class="n">s</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">to_stalk_res</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">hsx</span><span class="o">,</span>
    <span class="bp">λ</span> <span class="n">q</span> <span class="n">hqW</span><span class="o">,</span> <span class="bp">⟨</span><span class="k">by</span> <span class="n">rw</span> <span class="n">to_stalk_res</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">hs</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">to_stalk_res</span><span class="o">]</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">ht</span><span class="bp">⟩⟩</span><span class="o">,</span>
  <span class="n">is_open_sUnion</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">SS</span> <span class="n">H</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="k">let</span> <span class="bp">⟨</span><span class="n">t</span><span class="o">,</span> <span class="n">htSS</span><span class="o">,</span> <span class="n">hxt</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_sUnion</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hx</span><span class="o">,</span>
    <span class="bp">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">hxU</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">hsx</span><span class="o">,</span> <span class="n">hs</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">H</span> <span class="n">t</span> <span class="n">htSS</span> <span class="n">x</span> <span class="n">hxt</span> <span class="k">in</span> <span class="bp">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">hxU</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">hsx</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">p</span> <span class="n">hpU</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_sUnion_of_mem</span> <span class="o">(</span><span class="n">hs</span> <span class="n">p</span> <span class="n">hpU</span><span class="o">)</span> <span class="n">htSS</span><span class="bp">⟩</span> <span class="o">}</span>

<span class="kn">theorem</span> <span class="n">continuous_of_espace_etale</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">continuous</span> <span class="o">(</span><span class="n">of_espace_etale</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">U</span> <span class="n">HU</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">g</span><span class="bp">⟩</span> <span class="n">hpU</span><span class="o">,</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">induction_on</span> <span class="n">g</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">V</span><span class="o">,</span> <span class="n">hpV</span><span class="o">,</span> <span class="n">s</span><span class="bp">⟩</span><span class="o">,</span>
<span class="bp">⟨⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">HU</span><span class="bp">⟩</span> <span class="err">⊓</span> <span class="n">V</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">hpU</span><span class="o">,</span> <span class="n">hpV</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">V</span> <span class="bp">_</span> <span class="n">inf_le_right</span> <span class="n">s</span><span class="o">,</span> <span class="n">to_stalk_res</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">q</span> <span class="n">hqUV</span><span class="o">,</span> <span class="n">hqUV</span><span class="bp">.</span><span class="mi">1</span><span class="bp">⟩</span>

<span class="kn">theorem</span> <span class="n">continuous_to_espace_etale</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">F</span> <span class="n">U</span><span class="o">)</span> <span class="o">:</span> <span class="n">continuous</span> <span class="o">(</span><span class="n">to_espace_etale</span> <span class="n">F</span> <span class="n">U</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">S</span> <span class="n">HS</span><span class="o">,</span> <span class="n">is_open_iff_forall_mem_open</span><span class="bp">.</span><span class="mi">2</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">q</span> <span class="n">hq</span><span class="o">,</span> <span class="k">let</span> <span class="bp">⟨</span><span class="n">V</span><span class="o">,</span> <span class="n">hqV</span><span class="o">,</span> <span class="n">t</span><span class="o">,</span> <span class="n">hts</span><span class="o">,</span> <span class="n">ht</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">HS</span> <span class="bp">_</span> <span class="n">hq</span><span class="o">,</span>
<span class="bp">⟨</span><span class="n">W</span><span class="o">,</span> <span class="n">hqW</span><span class="o">,</span> <span class="n">HWV</span><span class="o">,</span> <span class="n">HWU</span><span class="o">,</span> <span class="n">HW</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">exact</span> <span class="n">hts</span> <span class="k">in</span>
<span class="bp">⟨</span><span class="n">subtype</span><span class="bp">.</span><span class="n">val</span> <span class="bp">⁻¹</span><span class="err">&#39;</span> <span class="n">W</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span>
<span class="bp">λ</span> <span class="n">p</span> <span class="n">hpW</span><span class="o">,</span> <span class="k">show</span> <span class="o">(</span><span class="bp">⟨_</span><span class="o">,</span> <span class="bp">_⟩</span> <span class="o">:</span> <span class="n">espace_etale</span> <span class="n">F</span><span class="o">)</span> <span class="err">∈</span> <span class="n">S</span><span class="o">,</span> <span class="k">by</span> <span class="n">erw</span> <span class="o">[</span><span class="err">←</span> <span class="n">to_stalk_res</span> <span class="n">F</span> <span class="n">p</span><span class="bp">.</span><span class="mi">1</span> <span class="n">U</span> <span class="n">W</span> <span class="n">hpW</span> <span class="n">HWU</span><span class="o">,</span> <span class="err">←</span> <span class="n">HW</span><span class="o">,</span> <span class="n">to_stalk_res</span><span class="o">]</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">ht</span><span class="o">,</span>
<span class="n">continuous_subtype_val</span> <span class="bp">_</span> <span class="n">W</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span> <span class="n">hqW</span><span class="bp">⟩</span>

<span class="n">def</span> <span class="n">espace_etale</span><span class="bp">.</span><span class="n">basic</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">F</span> <span class="n">U</span><span class="o">)</span> <span class="o">:</span> <span class="n">opens</span> <span class="o">(</span><span class="n">espace_etale</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨</span><span class="o">{</span> <span class="n">x</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">hxU</span> <span class="o">:</span> <span class="n">x</span><span class="bp">.</span><span class="mi">1</span> <span class="err">∈</span> <span class="n">U</span><span class="o">,</span> <span class="n">to_stalk</span> <span class="n">F</span> <span class="n">x</span><span class="bp">.</span><span class="mi">1</span> <span class="n">U</span> <span class="n">hxU</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">x</span><span class="bp">.</span><span class="mi">2</span> <span class="o">},</span>
<span class="bp">λ</span> <span class="n">x</span> <span class="bp">⟨</span><span class="n">hxU</span><span class="o">,</span> <span class="n">hx</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">hxU</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">hx</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">p</span> <span class="n">hpU</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">hpU</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩⟩⟩</span>

<span class="kn">structure</span> <span class="n">presheaf</span><span class="bp">.</span><span class="n">hom</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">U</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">,</span> <span class="n">F</span> <span class="n">U</span> <span class="bp">→</span> <span class="n">G</span> <span class="n">U</span><span class="o">)</span>
<span class="o">(</span><span class="n">to_fun_res</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">U</span> <span class="n">V</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">HVU</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">≤</span> <span class="n">U</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">s</span> <span class="o">:</span> <span class="n">F</span> <span class="n">U</span><span class="o">,</span> <span class="n">to_fun</span> <span class="n">V</span> <span class="o">(</span><span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="n">s</span><span class="o">)</span> <span class="bp">=</span> <span class="n">G</span><span class="bp">.</span><span class="n">res</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="o">(</span><span class="n">to_fun</span> <span class="n">U</span> <span class="n">s</span><span class="o">))</span>

<span class="kn">structure</span> <span class="n">presheaf</span><span class="bp">.</span><span class="n">equiv</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">U</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">,</span> <span class="n">F</span> <span class="n">U</span> <span class="bp">→</span> <span class="n">G</span> <span class="n">U</span><span class="o">)</span>
<span class="o">(</span><span class="n">inv_fun</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">U</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">,</span> <span class="n">G</span> <span class="n">U</span> <span class="bp">→</span> <span class="n">F</span> <span class="n">U</span><span class="o">)</span>
<span class="o">(</span><span class="n">left_inv</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">U</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">s</span> <span class="o">:</span> <span class="n">F</span> <span class="n">U</span><span class="o">,</span> <span class="n">inv_fun</span> <span class="n">U</span> <span class="o">(</span><span class="n">to_fun</span> <span class="n">U</span> <span class="n">s</span><span class="o">)</span> <span class="bp">=</span> <span class="n">s</span><span class="o">)</span>
<span class="o">(</span><span class="n">right_inv</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">U</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">s</span> <span class="o">:</span> <span class="n">G</span> <span class="n">U</span><span class="o">,</span> <span class="n">to_fun</span> <span class="n">U</span> <span class="o">(</span><span class="n">inv_fun</span> <span class="n">U</span> <span class="n">s</span><span class="o">)</span> <span class="bp">=</span> <span class="n">s</span><span class="o">)</span>
<span class="o">(</span><span class="n">to_fun_res</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">U</span> <span class="n">V</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">HVU</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">≤</span> <span class="n">U</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">s</span> <span class="o">:</span> <span class="n">F</span> <span class="n">U</span><span class="o">,</span> <span class="n">to_fun</span> <span class="n">V</span> <span class="o">(</span><span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="n">s</span><span class="o">)</span> <span class="bp">=</span> <span class="n">G</span><span class="bp">.</span><span class="n">res</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="o">(</span><span class="n">to_fun</span> <span class="n">U</span> <span class="n">s</span><span class="o">))</span>

<span class="kn">theorem</span> <span class="n">sheaf</span><span class="bp">.</span><span class="n">locality&#39;</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">sheaf</span> <span class="n">X</span><span class="o">)</span> <span class="o">{</span><span class="n">U</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">F</span><span class="bp">.</span><span class="n">to_presheaf</span> <span class="n">U</span><span class="o">}</span>
  <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">U</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">V</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">HVU</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">≤</span> <span class="n">U</span><span class="o">,</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">V</span> <span class="bp">∧</span> <span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">s</span> <span class="bp">=</span> <span class="n">t</span> <span class="o">:=</span>
<span class="n">F</span><span class="bp">.</span><span class="n">locality</span> <span class="n">U</span> <span class="n">s</span> <span class="n">t</span> <span class="bp">⟨</span><span class="n">U</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="n">classical</span><span class="bp">.</span><span class="n">some</span> <span class="err">$</span> <span class="n">H</span> <span class="n">p</span><span class="bp">.</span><span class="mi">1</span> <span class="n">p</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="n">classical</span><span class="bp">.</span><span class="n">some</span> <span class="err">$</span> <span class="n">classical</span><span class="bp">.</span><span class="n">some_spec</span> <span class="err">$</span> <span class="n">H</span> <span class="n">p</span><span class="bp">.</span><span class="mi">1</span> <span class="n">p</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
  <span class="bp">λ</span> <span class="n">p</span> <span class="n">hp</span><span class="o">,</span> <span class="bp">⟨⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">hp</span><span class="bp">⟩</span><span class="o">,</span> <span class="o">(</span><span class="n">classical</span><span class="bp">.</span><span class="n">some_spec</span> <span class="err">$</span> <span class="n">classical</span><span class="bp">.</span><span class="n">some_spec</span> <span class="err">$</span> <span class="n">H</span> <span class="n">p</span> <span class="n">hp</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span><span class="bp">⟩⟩</span> <span class="err">$</span>
<span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="o">(</span><span class="n">classical</span><span class="bp">.</span><span class="n">some_spec</span> <span class="err">$</span> <span class="n">classical</span><span class="bp">.</span><span class="n">some_spec</span> <span class="err">$</span> <span class="n">H</span> <span class="n">p</span><span class="bp">.</span><span class="mi">1</span> <span class="n">p</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span>

<span class="kn">theorem</span> <span class="n">sheaf</span><span class="bp">.</span><span class="n">locality&#39;&#39;</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">sheaf</span> <span class="n">X</span><span class="o">)</span> <span class="o">{</span><span class="n">U</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">F</span><span class="bp">.</span><span class="n">to_presheaf</span> <span class="n">U</span><span class="o">}</span>
  <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">U</span><span class="o">,</span> <span class="n">to_stalk</span> <span class="n">F</span><span class="bp">.</span><span class="n">to_presheaf</span> <span class="n">x</span> <span class="n">U</span> <span class="n">H</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">to_stalk</span> <span class="n">F</span><span class="bp">.</span><span class="n">to_presheaf</span> <span class="n">x</span> <span class="n">U</span> <span class="n">H</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">s</span> <span class="bp">=</span> <span class="n">t</span> <span class="o">:=</span>
<span class="n">F</span><span class="bp">.</span><span class="n">locality&#39;</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">hxU</span><span class="o">,</span> <span class="k">let</span> <span class="bp">⟨</span><span class="n">V</span><span class="o">,</span> <span class="n">hxV</span><span class="o">,</span> <span class="n">HVU</span><span class="o">,</span> <span class="n">HVU&#39;</span><span class="o">,</span> <span class="n">hv</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">exact</span> <span class="o">(</span><span class="n">H</span> <span class="n">x</span> <span class="n">hxU</span><span class="o">)</span> <span class="k">in</span> <span class="bp">⟨</span><span class="n">V</span><span class="o">,</span> <span class="n">HVU</span><span class="o">,</span> <span class="n">hxV</span><span class="o">,</span> <span class="n">hv</span><span class="bp">⟩</span>

<span class="kn">theorem</span> <span class="n">germ</span><span class="bp">.</span><span class="n">eta</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">germ</span> <span class="n">F</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">⟨</span><span class="n">g</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span> <span class="n">H</span><span class="o">,</span> <span class="n">g</span><span class="bp">.</span><span class="mi">3</span><span class="bp">⟩</span> <span class="o">:</span> <span class="n">germ</span> <span class="n">F</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">cases</span> <span class="n">g</span><span class="bp">;</span> <span class="n">refl</span>

<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">sheaf</span><span class="bp">.</span><span class="n">glue</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">sheaf</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">OC</span> <span class="o">:</span> <span class="n">covering</span> <span class="n">U</span><span class="o">)</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">i</span> <span class="o">:</span> <span class="n">OC</span><span class="bp">.</span><span class="n">ι</span><span class="o">,</span> <span class="n">F</span><span class="bp">.</span><span class="n">to_presheaf</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">i</span><span class="o">))</span>
  <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">OC</span><span class="bp">.</span><span class="n">ι</span><span class="o">,</span> <span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">i</span> <span class="err">⊓</span> <span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">j</span><span class="o">)</span> <span class="n">inf_le_left</span> <span class="o">(</span><span class="n">S</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span>
    <span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">i</span> <span class="err">⊓</span> <span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">j</span><span class="o">)</span> <span class="n">inf_le_right</span> <span class="o">(</span><span class="n">S</span> <span class="n">j</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">F</span><span class="bp">.</span><span class="n">to_presheaf</span> <span class="n">U</span> <span class="o">:=</span>
<span class="n">classical</span><span class="bp">.</span><span class="n">some</span> <span class="err">$</span> <span class="n">F</span><span class="bp">.</span><span class="n">gluing</span> <span class="n">U</span> <span class="n">OC</span> <span class="n">S</span> <span class="n">H</span>

<span class="kn">theorem</span> <span class="n">res_glue</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">sheaf</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">OC</span> <span class="o">:</span> <span class="n">covering</span> <span class="n">U</span><span class="o">)</span> <span class="o">(</span><span class="n">S</span> <span class="n">H</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">U</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map_le</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">F</span><span class="bp">.</span><span class="n">glue</span> <span class="n">U</span> <span class="n">OC</span> <span class="n">S</span> <span class="n">H</span><span class="o">)</span> <span class="bp">=</span> <span class="n">S</span> <span class="n">i</span> <span class="o">:=</span>
<span class="n">classical</span><span class="bp">.</span><span class="n">some_spec</span> <span class="o">(</span><span class="n">F</span><span class="bp">.</span><span class="n">gluing</span> <span class="n">U</span> <span class="n">OC</span> <span class="n">S</span> <span class="n">H</span><span class="o">)</span> <span class="n">i</span>

<span class="kn">theorem</span> <span class="n">glue_eq</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">sheaf</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">OC</span> <span class="o">:</span> <span class="n">covering</span> <span class="n">U</span><span class="o">)</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">i</span> <span class="o">:</span> <span class="n">OC</span><span class="bp">.</span><span class="n">ι</span><span class="o">,</span> <span class="n">F</span><span class="bp">.</span><span class="n">to_presheaf</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">i</span><span class="o">))</span> <span class="o">(</span><span class="n">H</span> <span class="n">s</span><span class="o">)</span>
  <span class="o">(</span><span class="n">H2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">U</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map_le</span> <span class="n">i</span><span class="o">)</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">S</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">F</span><span class="bp">.</span><span class="n">glue</span> <span class="n">U</span> <span class="n">OC</span> <span class="n">S</span> <span class="n">H</span> <span class="bp">=</span> <span class="n">s</span> <span class="o">:=</span>
<span class="n">F</span><span class="bp">.</span><span class="n">locality</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">OC</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">res_glue</span><span class="o">,</span> <span class="n">H2</span><span class="o">]</span>

<span class="kn">theorem</span> <span class="n">to_stalk_glue</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">sheaf</span> <span class="n">X</span><span class="o">)</span> <span class="o">{</span><span class="n">U</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">}</span> <span class="o">{</span><span class="n">OC</span> <span class="o">:</span> <span class="n">covering</span> <span class="n">U</span><span class="o">}</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">i</span> <span class="o">:</span> <span class="n">OC</span><span class="bp">.</span><span class="n">ι</span><span class="o">,</span> <span class="n">F</span><span class="bp">.</span><span class="n">to_presheaf</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">i</span><span class="o">)}</span>
  <span class="o">{</span><span class="n">H</span> <span class="n">p</span><span class="o">}</span> <span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">H2</span> <span class="o">:</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">to_stalk</span> <span class="n">F</span><span class="bp">.</span><span class="n">to_presheaf</span> <span class="n">p</span> <span class="n">U</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map_le</span> <span class="n">i</span> <span class="n">H2</span><span class="o">)</span> <span class="o">(</span><span class="n">F</span><span class="bp">.</span><span class="n">glue</span> <span class="n">U</span> <span class="n">OC</span> <span class="n">S</span> <span class="n">H</span><span class="o">)</span> <span class="bp">=</span> <span class="n">to_stalk</span> <span class="n">F</span><span class="bp">.</span><span class="n">to_presheaf</span> <span class="n">p</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">i</span><span class="o">)</span> <span class="n">H2</span> <span class="o">(</span><span class="n">S</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">rw</span> <span class="err">←</span> <span class="n">to_stalk_res</span><span class="bp">;</span> <span class="n">congr&#39;</span> <span class="mi">1</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">res_glue</span>
</pre></div>

<a name="171524295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171524295" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171524295">Kenny Lau (Jul 23 2019 at 14:35)</a>:</h4>
<p>Fundamental theorem of sheaf theory:</p>
<div class="codehilite"><pre><span></span><span class="n">noncomputable</span> <span class="n">def</span> <span class="n">equiv_continuous_section_espace_etale</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">sheaf</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">F</span><span class="bp">.</span><span class="n">to_presheaf</span><span class="bp">.</span><span class="n">equiv</span> <span class="o">(</span><span class="n">continuous_section_subsheaf</span> <span class="o">(</span><span class="n">espace_etale</span> <span class="n">F</span><span class="bp">.</span><span class="n">to_presheaf</span><span class="o">)</span> <span class="o">(</span><span class="n">of_espace_etale</span> <span class="n">F</span><span class="bp">.</span><span class="n">to_presheaf</span><span class="o">))</span><span class="bp">.</span><span class="n">to_sheaf</span><span class="bp">.</span><span class="n">to_presheaf</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">s</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">to_espace_etale</span> <span class="n">F</span><span class="bp">.</span><span class="n">to_presheaf</span> <span class="n">U</span> <span class="n">s</span><span class="o">,</span> <span class="n">continuous_to_espace_etale</span> <span class="n">F</span><span class="bp">.</span><span class="n">to_presheaf</span> <span class="n">U</span> <span class="n">s</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">s</span><span class="o">,</span> <span class="n">F</span><span class="bp">.</span><span class="n">glue</span> <span class="n">U</span>
    <span class="bp">⟨</span><span class="n">U</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">subtype</span><span class="bp">.</span><span class="n">val</span> <span class="err">&#39;&#39;</span> <span class="o">(</span><span class="n">s</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">⁻¹</span><span class="err">&#39;</span> <span class="o">(</span><span class="n">espace_etale</span><span class="bp">.</span><span class="n">basic</span> <span class="n">F</span><span class="bp">.</span><span class="n">to_presheaf</span> <span class="o">(</span><span class="n">quotient</span><span class="bp">.</span><span class="n">out</span> <span class="o">(</span><span class="n">s</span><span class="bp">.</span><span class="mi">1</span> <span class="n">p</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="o">(</span><span class="n">quotient</span><span class="bp">.</span><span class="n">out</span> <span class="o">(</span><span class="n">s</span><span class="bp">.</span><span class="mi">1</span> <span class="n">p</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span><span class="bp">.</span><span class="mi">3</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span><span class="o">),</span>
        <span class="k">let</span> <span class="bp">⟨</span><span class="n">V</span><span class="o">,</span> <span class="n">hv1</span><span class="o">,</span> <span class="n">hv2</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">s</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">1</span> <span class="o">(</span><span class="n">espace_etale</span><span class="bp">.</span><span class="n">basic</span> <span class="n">F</span><span class="bp">.</span><span class="n">to_presheaf</span> <span class="o">(</span><span class="n">quotient</span><span class="bp">.</span><span class="n">out</span> <span class="o">(</span><span class="n">s</span><span class="bp">.</span><span class="mi">1</span> <span class="n">p</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="o">(</span><span class="n">quotient</span><span class="bp">.</span><span class="n">out</span> <span class="o">(</span><span class="n">s</span><span class="bp">.</span><span class="mi">1</span> <span class="n">p</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span><span class="bp">.</span><span class="mi">3</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span>
          <span class="o">(</span><span class="n">espace_etale</span><span class="bp">.</span><span class="n">basic</span> <span class="n">F</span><span class="bp">.</span><span class="n">to_presheaf</span> <span class="o">(</span><span class="n">quotient</span><span class="bp">.</span><span class="n">out</span> <span class="o">(</span><span class="n">s</span><span class="bp">.</span><span class="mi">1</span> <span class="n">p</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="o">(</span><span class="n">quotient</span><span class="bp">.</span><span class="n">out</span> <span class="o">(</span><span class="n">s</span><span class="bp">.</span><span class="mi">1</span> <span class="n">p</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span><span class="bp">.</span><span class="mi">3</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="k">in</span>
        <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="err">←</span> <span class="n">hv2</span><span class="o">,</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">image_preimage_val</span><span class="o">]</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">is_open_inter</span> <span class="n">hv1</span> <span class="n">U</span><span class="bp">.</span><span class="mi">2</span><span class="bp">⟩</span><span class="o">,</span>
      <span class="bp">λ</span> <span class="n">p</span> <span class="n">q</span> <span class="bp">⟨</span><span class="n">r</span><span class="o">,</span> <span class="n">hr</span><span class="o">,</span> <span class="n">hrq</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">hrq</span> <span class="bp">▸</span> <span class="n">r</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
      <span class="bp">λ</span> <span class="n">p</span> <span class="n">hpU</span><span class="o">,</span> <span class="bp">⟨⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">hpU</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">hpU</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="o">(</span><span class="n">quotient</span><span class="bp">.</span><span class="n">out</span> <span class="o">(</span><span class="n">s</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">hpU</span><span class="bp">⟩</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
        <span class="k">by</span> <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">to_stalk</span><span class="o">]</span><span class="bp">;</span> <span class="n">rw</span> <span class="n">germ</span><span class="bp">.</span><span class="n">eta</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">out_eq</span> <span class="bp">_⟩</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩⟩</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="o">(</span><span class="n">quotient</span><span class="bp">.</span><span class="n">out</span> <span class="o">(</span><span class="n">s</span><span class="bp">.</span><span class="mi">1</span> <span class="n">p</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">q</span> <span class="bp">⟨</span><span class="n">r</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">hsr1</span><span class="o">,</span> <span class="n">hsr2</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">hrq</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">hrq</span> <span class="bp">▸</span> <span class="n">s</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">2</span> <span class="n">r</span> <span class="bp">▸</span> <span class="n">hsr1</span><span class="o">)</span> <span class="o">(</span><span class="n">quotient</span><span class="bp">.</span><span class="n">out</span> <span class="o">(</span><span class="n">s</span><span class="bp">.</span><span class="mi">1</span> <span class="n">p</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span><span class="bp">.</span><span class="mi">3</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span> <span class="n">q</span><span class="o">,</span> <span class="n">F</span><span class="bp">.</span><span class="n">locality&#39;&#39;</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">r</span> <span class="bp">⟨⟨</span><span class="n">u</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">hsu1</span><span class="o">,</span> <span class="n">hsu2</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">hur</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">v</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">hsv1</span><span class="o">,</span> <span class="n">hsv2</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">hvr</span><span class="bp">⟩⟩</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">huv</span> <span class="o">:</span> <span class="n">u</span> <span class="bp">=</span> <span class="n">v</span><span class="o">,</span> <span class="k">from</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">eq</span> <span class="err">$</span> <span class="n">hur</span><span class="bp">.</span><span class="n">trans</span> <span class="n">hvr</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">hsu</span> <span class="o">:</span> <span class="o">(</span><span class="n">s</span><span class="bp">.</span><span class="mi">1</span> <span class="n">u</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">=</span> <span class="n">u</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span> <span class="k">from</span> <span class="n">s</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">2</span> <span class="n">u</span><span class="o">,</span>
      <span class="k">begin</span>
        <span class="n">clear_</span><span class="o">,</span> <span class="n">iterate</span> <span class="mi">4</span> <span class="o">{</span> <span class="n">erw</span> <span class="n">to_stalk_res</span> <span class="o">}</span><span class="bp">;</span> <span class="n">substs</span> <span class="n">huv</span> <span class="n">hur</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">u</span> <span class="k">with</span> <span class="n">u</span> <span class="n">hu</span><span class="bp">;</span> <span class="n">dsimp</span> <span class="n">only</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
        <span class="n">generalize</span> <span class="o">:</span> <span class="n">equiv_continuous_section_espace_etale</span><span class="bp">._</span><span class="n">match_3</span> <span class="n">F</span> <span class="n">U</span> <span class="n">s</span> <span class="n">p</span> <span class="n">u</span> <span class="bp">_</span> <span class="bp">=</span> <span class="n">h1</span><span class="o">,</span>
        <span class="n">generalize</span> <span class="o">:</span> <span class="n">equiv_continuous_section_espace_etale</span><span class="bp">._</span><span class="n">match_3</span> <span class="n">F</span> <span class="n">U</span> <span class="n">s</span> <span class="n">q</span> <span class="n">u</span> <span class="bp">_</span> <span class="bp">=</span> <span class="n">h2</span><span class="o">,</span>
        <span class="n">revert</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span> <span class="n">rw</span> <span class="err">←</span> <span class="n">hsu</span><span class="o">,</span> <span class="n">intros</span><span class="o">,</span> <span class="n">erw</span> <span class="o">[</span><span class="n">hsu2</span><span class="o">,</span> <span class="n">hsv2</span><span class="o">]</span>
      <span class="kn">end</span><span class="o">),</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">s</span><span class="o">,</span> <span class="n">glue_eq</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="n">F</span><span class="bp">.</span><span class="n">locality&#39;&#39;</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">q</span> <span class="bp">⟨</span><span class="n">u</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">hsu1</span><span class="o">,</span> <span class="n">hsu2</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">huq</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="k">by</span> <span class="n">clear_</span><span class="bp">;</span> <span class="n">erw</span> <span class="o">[</span><span class="n">to_stalk_res</span><span class="o">,</span> <span class="n">to_stalk_res</span><span class="o">]</span><span class="bp">;</span> <span class="n">subst</span> <span class="n">huq</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">hsu2</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">s</span><span class="o">,</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">eq</span> <span class="err">$</span> <span class="n">funext</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="n">sigma</span><span class="bp">.</span><span class="n">eq</span> <span class="o">(</span><span class="n">s</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">2</span> <span class="n">p</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="err">$</span> <span class="k">begin</span>
    <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">to_espace_etale</span><span class="o">],</span>
    <span class="n">generalize</span> <span class="o">:</span> <span class="n">to_espace_etale</span><span class="bp">._</span><span class="n">proof_1</span> <span class="n">U</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">h1</span><span class="o">,</span>
    <span class="n">generalize</span> <span class="o">:</span> <span class="o">(</span><span class="n">s</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">2</span> <span class="n">p</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">=</span> <span class="n">h2</span><span class="o">,</span>
    <span class="n">revert</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span> <span class="n">rw</span> <span class="err">←</span> <span class="n">s</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">2</span> <span class="n">p</span><span class="o">,</span> <span class="n">intros</span><span class="o">,</span> <span class="n">dsimp</span> <span class="n">only</span><span class="o">,</span>
    <span class="n">erw</span> <span class="n">to_stalk_glue</span> <span class="n">F</span><span class="o">,</span> <span class="n">swap</span> <span class="mi">3</span><span class="o">,</span> <span class="n">exact</span> <span class="n">p</span><span class="o">,</span> <span class="n">swap</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">refine</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="bp">⟨</span><span class="o">(</span><span class="n">quotient</span><span class="bp">.</span><span class="n">out</span> <span class="o">(</span><span class="n">s</span><span class="bp">.</span><span class="mi">1</span> <span class="n">p</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span> <span class="o">(</span><span class="n">s</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">2</span> <span class="n">p</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="bp">⟩</span><span class="o">,</span>
      <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">to_stalk</span><span class="o">],</span> <span class="n">rw</span> <span class="o">[</span><span class="n">germ</span><span class="bp">.</span><span class="n">eta</span><span class="o">,</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">out_eq</span><span class="o">]</span> <span class="o">},</span>
    <span class="n">erw</span> <span class="n">to_stalk_res</span><span class="o">,</span> <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">to_stalk</span><span class="o">],</span> <span class="n">rw</span> <span class="o">[</span><span class="n">germ</span><span class="bp">.</span><span class="n">eta</span><span class="o">,</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">out_eq</span><span class="o">]</span>
  <span class="kn">end</span><span class="o">,</span>
  <span class="n">to_fun_res</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="n">s</span><span class="o">,</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">eq</span> <span class="err">$</span> <span class="n">funext</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="n">sigma</span><span class="bp">.</span><span class="n">eq</span> <span class="n">rfl</span> <span class="err">$</span> <span class="n">to_stalk_res</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">}</span>
</pre></div>

<a name="171524337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171524337" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171524337">Kenny Lau (Jul 23 2019 at 14:35)</a>:</h4>
<p>thanks for attending my "live" coding session</p>

<a name="171524350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171524350" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171524350">Kevin Buzzard (Jul 23 2019 at 14:35)</a>:</h4>
<p>:-)</p>

<a name="171524362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171524362" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171524362">Kevin Buzzard (Jul 23 2019 at 14:35)</a>:</h4>
<p>Did you PR to lean-scheme?</p>

<a name="171524368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171524368" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171524368">Kenny Lau (Jul 23 2019 at 14:35)</a>:</h4>
<p>no</p>

<a name="171524373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171524373" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171524373">Kevin Buzzard (Jul 23 2019 at 14:36)</a>:</h4>
<p>I mean push</p>

<a name="171524452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171524452" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171524452">Kevin Buzzard (Jul 23 2019 at 14:36)</a>:</h4>
<p>I would like to amalgamate this with the extra power of bundled top spaces at some point</p>

<a name="171525986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171525986" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171525986">Johan Commelin (Jul 23 2019 at 14:53)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> Thanks for sharing your coding session with us <span aria-label="stuck out tongue wink" class="emoji emoji-1f61c" role="img" title="stuck out tongue wink">:stuck_out_tongue_wink:</span></p>

<a name="171526020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171526020" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171526020">Kevin Buzzard (Jul 23 2019 at 14:53)</a>:</h4>
<p>What's the notation for <code>sum</code>? I don't know how to work it out without asking</p>

<a name="171526036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171526036" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171526036">Johan Commelin (Jul 23 2019 at 14:53)</a>:</h4>
<p>Which <code>sum</code>?</p>

<a name="171526041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171526041" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171526041">Johan Commelin (Jul 23 2019 at 14:53)</a>:</h4>
<p>Sum of types?</p>

<a name="171526063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171526063" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171526063">Kevin Buzzard (Jul 23 2019 at 14:54)</a>:</h4>
<p>yes</p>

<a name="171526093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171526093" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171526093">Kevin Buzzard (Jul 23 2019 at 14:54)</a>:</h4>
<p>disjoint union. I'm making a category, I think</p>

<a name="171526095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171526095" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171526095">Johan Commelin (Jul 23 2019 at 14:54)</a>:</h4>
<p>Does <code>\oplus</code> work?</p>

<a name="171526107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171526107" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171526107">Kevin Buzzard (Jul 23 2019 at 14:54)</a>:</h4>
<p>Well, I'm making a partially ordered set. I'm assuming I can get a category from it.</p>

<a name="171526123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171526123" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171526123">Johan Commelin (Jul 23 2019 at 14:54)</a>:</h4>
<p>Yep, that's done by type class inference.</p>

<a name="171526138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171526138" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171526138">Johan Commelin (Jul 23 2019 at 14:54)</a>:</h4>
<p>Once you've imported the right files, of course.</p>

<a name="171526166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171526166" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171526166">Kevin Buzzard (Jul 23 2019 at 14:55)</a>:</h4>
<p>Do I just import the same files as in Scott's tutorial?</p>

<a name="171526176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171526176" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171526176">Kevin Buzzard (Jul 23 2019 at 14:55)</a>:</h4>
<p>I don't know where to look for information</p>

<a name="171526667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171526667" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171526667">Johan Commelin (Jul 23 2019 at 15:00)</a>:</h4>
<div class="codehilite"><pre><span></span>$ git grep preorder <span class="p">|</span> grep category_theory
src/category_theory/category.lean:namespace preorder
src/category_theory/category.lean:instance small_category <span class="o">[</span>preorder α<span class="o">]</span> : small_category α :<span class="o">=</span>
src/category_theory/category.lean:end preorder
</pre></div>

<a name="171526694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171526694" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171526694">Johan Commelin (Jul 23 2019 at 15:00)</a>:</h4>
<p>So, it's in the most basic file, and you'll be fine.</p>

<a name="171532006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171532006" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171532006">Kevin Buzzard (Jul 23 2019 at 15:57)</a>:</h4>
<p>Are there any special functions for dealing with Prop-valued diagrams? I only care about maps from partial orders to Top and I'm having trouble defining functors because inductive props can't eliminate into type :-/</p>

<a name="171535302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171535302" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171535302">Kevin Buzzard (Jul 23 2019 at 16:38)</a>:</h4>
<p>If I want to do a simple diagram like one with three objects U, V, and U intersect V, and maps corresponding to inclusions, because I want to take a colimit, should I make the diagram category using props as homs or subsingletons?</p>

<a name="171535332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171535332" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171535332">Kevin Buzzard (Jul 23 2019 at 16:39)</a>:</h4>
<p>I want to glue open sets <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>U</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">U_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> over common open subsets <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>U</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">U_{ij}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> which are morally <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>U</mi><mi>i</mi></msub><mo>∩</mo><msub><mi>U</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">U_i\cap U_j</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></p>

<a name="171535474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171535474" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171535474">Kevin Buzzard (Jul 23 2019 at 16:41)</a>:</h4>
<p>Trying to define the functor I am stuck with goals like</p>
<div class="codehilite"><pre><span></span>1 goal
A B C : Type,
h : A = B ∨ A = C,
b : B,
c : C
⊢ A
</pre></div>

<a name="171535502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171535502" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171535502">Kevin Buzzard (Jul 23 2019 at 16:41)</a>:</h4>
<p>so I have to use classical.some in a situation where I don't feel like I need classicality.</p>

<a name="171536235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171536235" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171536235">Kevin Buzzard (Jul 23 2019 at 16:51)</a>:</h4>
<p>What do I do with a term of type <code>plift h</code> where h is a proposition? I want to do cases on it without dropping into Prop world.</p>

<a name="171536400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171536400" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171536400">Chris Hughes (Jul 23 2019 at 16:53)</a>:</h4>
<p><code>pilft.down</code> or something</p>

<a name="171536466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171536466" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171536466">Kevin Buzzard (Jul 23 2019 at 16:54)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">plift</span> <span class="o">(</span><span class="n">A</span> <span class="bp">=</span> <span class="n">B</span> <span class="bp">∨</span> <span class="n">A</span> <span class="bp">=</span> <span class="n">C</span><span class="o">))</span> <span class="o">:</span> <span class="n">plift</span> <span class="o">(</span><span class="n">A</span> <span class="bp">=</span> <span class="n">B</span><span class="o">)</span> <span class="err">⊕</span> <span class="n">plift</span> <span class="o">(</span><span class="n">A</span> <span class="bp">=</span> <span class="n">C</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>

<a name="171536471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171536471" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171536471">Kevin Buzzard (Jul 23 2019 at 16:54)</a>:</h4>
<p>Is that a thing?</p>

<a name="171536485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171536485" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171536485">Kevin Buzzard (Jul 23 2019 at 16:54)</a>:</h4>
<p>I'll have classical, noncomputable, anything you like.</p>

<a name="171536525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171536525" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171536525">Chris Hughes (Jul 23 2019 at 16:55)</a>:</h4>
<p>Yes</p>

<a name="171536659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171536659" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171536659">Kevin Buzzard (Jul 23 2019 at 16:57)</a>:</h4>
<p>I've always found the definition of <code>up</code> and <code>down</code> rather beautiful.</p>
<div class="codehilite"><pre><span></span><span class="c">/-</span><span class="cm">- Universe lifting operation from Sort to Type -/</span>
<span class="kn">structure</span> <span class="n">plift</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="o">:=</span>
<span class="n">up</span> <span class="bp">::</span> <span class="o">(</span><span class="n">down</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
</pre></div>


<p>(that's it). Is it proved to be a subsingleton?</p>

<a name="171536826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171536826" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171536826">Chris Hughes (Jul 23 2019 at 16:58)</a>:</h4>
<p><code>classical.choice $ h.down.elim (sum.inl \circ plift.up) (sum.inr \circ plift.up)</code> I think</p>

<a name="171536871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171536871" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171536871">Chris Hughes (Jul 23 2019 at 16:59)</a>:</h4>
<p>I forgot some <code>nonempty.intro</code></p>

<a name="171537172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171537172" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171537172">Chris Hughes (Jul 23 2019 at 17:02)</a>:</h4>
<p>Why do you need <code>plift</code>? I believe proofs as homs are allowed these days.</p>

<a name="171537215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171537215" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171537215">Kevin Buzzard (Jul 23 2019 at 17:03)</a>:</h4>
<p>I thought I let type class inference turn my poset into a category and that's what I got. Let me check this again.</p>

<a name="171537317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171537317" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171537317">Kevin Buzzard (Jul 23 2019 at 17:05)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="bp">#</span><span class="kn">check</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">X</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">X</span><span class="o">),</span> <span class="n">x</span> <span class="err">⟶</span> <span class="n">y</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">Π (X : Type u) [_inst_3 : preorder X] (x y : X), x ⟶ y : Type (u+1)</span>
<span class="cm">-/</span>
</pre></div>

<a name="171537325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171537325" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171537325">Chris Hughes (Jul 23 2019 at 17:05)</a>:</h4>
<p>Maybe the library hasn't been updated to take advantage of this yet.</p>

<a name="171537386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171537386" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171537386">Kevin Buzzard (Jul 23 2019 at 17:05)</a>:</h4>
<p>I'm on Xena, that's usually bleeding edge because I don't care if it doesn't compile any more. Future explorers can just see which commit of mathlib I was using at the time ;-)</p>

<a name="171537470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171537470" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171537470">Chris Hughes (Jul 23 2019 at 17:06)</a>:</h4>
<p>Maybe the preorder to category instance in bleeding edge hasn't been uodated</p>

<a name="171537773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171537773" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171537773">Kevin Buzzard (Jul 23 2019 at 17:11)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">noncomputable</span> <span class="kn">example</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">plift</span> <span class="o">(</span><span class="n">A</span> <span class="bp">=</span> <span class="n">B</span> <span class="bp">∨</span> <span class="n">A</span> <span class="bp">=</span> <span class="n">C</span><span class="o">))</span> <span class="o">:</span> <span class="n">plift</span> <span class="o">(</span><span class="n">A</span> <span class="bp">=</span> <span class="n">B</span><span class="o">)</span> <span class="err">⊕</span> <span class="n">plift</span> <span class="o">(</span><span class="n">A</span> <span class="bp">=</span> <span class="n">C</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">classical</span><span class="bp">.</span><span class="n">choice</span> <span class="err">$</span> <span class="n">h</span><span class="bp">.</span><span class="n">down</span><span class="bp">.</span><span class="n">elim</span> <span class="o">(</span><span class="n">nonempty</span><span class="bp">.</span><span class="n">intro</span> <span class="err">∘</span> <span class="n">sum</span><span class="bp">.</span><span class="n">inl</span> <span class="err">∘</span> <span class="n">plift</span><span class="bp">.</span><span class="n">up</span><span class="o">)</span> <span class="o">(</span><span class="n">nonempty</span><span class="bp">.</span><span class="n">intro</span> <span class="err">∘</span> <span class="n">sum</span><span class="bp">.</span><span class="n">inr</span> <span class="err">∘</span> <span class="n">plift</span><span class="bp">.</span><span class="n">up</span><span class="o">)</span>
</pre></div>

<a name="171537805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171537805" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171537805">Kenny Lau (Jul 23 2019 at 17:11)</a>:</h4>
<p>my "live" coding session can be found in <a href="https://github.com/kckennylau/Lean/blob/master/sheaf_fundamental.lean" target="_blank" title="https://github.com/kckennylau/Lean/blob/master/sheaf_fundamental.lean">https://github.com/kckennylau/Lean/blob/master/sheaf_fundamental.lean</a></p>

<a name="171537876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171537876" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171537876">Kevin Buzzard (Jul 23 2019 at 17:12)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">noncomputable</span> <span class="kn">example</span> <span class="o">(</span><span class="n">P</span> <span class="n">Q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">plift</span> <span class="o">(</span><span class="n">P</span> <span class="bp">∨</span> <span class="n">Q</span><span class="o">))</span> <span class="o">:</span> <span class="n">plift</span> <span class="n">P</span> <span class="err">⊕</span> <span class="n">plift</span> <span class="n">Q</span> <span class="o">:=</span>
<span class="n">classical</span><span class="bp">.</span><span class="n">choice</span> <span class="err">$</span> <span class="n">h</span><span class="bp">.</span><span class="n">down</span><span class="bp">.</span><span class="n">elim</span> <span class="o">(</span><span class="n">nonempty</span><span class="bp">.</span><span class="n">intro</span> <span class="err">∘</span> <span class="n">sum</span><span class="bp">.</span><span class="n">inl</span> <span class="err">∘</span> <span class="n">plift</span><span class="bp">.</span><span class="n">up</span><span class="o">)</span> <span class="o">(</span><span class="n">nonempty</span><span class="bp">.</span><span class="n">intro</span> <span class="err">∘</span> <span class="n">sum</span><span class="bp">.</span><span class="n">inr</span> <span class="err">∘</span> <span class="n">plift</span><span class="bp">.</span><span class="n">up</span><span class="o">)</span>
</pre></div>


<p>Now I formalise the correct statement, and Chris' proof is so beautiful that the same proof proves the correct theorem</p>

<a name="171538065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171538065" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171538065">Kevin Buzzard (Jul 23 2019 at 17:14)</a>:</h4>
<p>Kenny I really think you should consider writing a lot of this in the language of lattices.</p>

<a name="171538120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171538120" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171538120">Kenny Lau (Jul 23 2019 at 17:14)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">attribute</span> <span class="o">[</span><span class="kn">instance</span><span class="o">]</span> <span class="n">classical</span><span class="bp">.</span><span class="n">prop_decidable</span>
<span class="n">noncomputable</span> <span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">plift</span> <span class="o">(</span><span class="n">p</span> <span class="bp">∨</span> <span class="n">q</span><span class="o">))</span> <span class="o">:</span> <span class="n">plift</span> <span class="n">p</span> <span class="err">⊕</span> <span class="n">plift</span> <span class="n">q</span> <span class="o">:=</span>
<span class="n">or</span><span class="bp">.</span><span class="n">by_cases</span> <span class="n">h</span><span class="bp">.</span><span class="mi">1</span> <span class="o">(</span><span class="n">sum</span><span class="bp">.</span><span class="n">inl</span> <span class="err">∘</span> <span class="n">plift</span><span class="bp">.</span><span class="n">up</span><span class="o">)</span> <span class="o">(</span><span class="n">sum</span><span class="bp">.</span><span class="n">inr</span> <span class="err">∘</span> <span class="n">plift</span><span class="bp">.</span><span class="n">up</span><span class="o">)</span>
</pre></div>

<a name="171538130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171538130" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171538130">Kevin Buzzard (Jul 23 2019 at 17:14)</a>:</h4>
<p>When you bundled ideals, you really wanted to use lattices and I was quite anti the idea.</p>

<a name="171538138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171538138" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171538138">Kevin Buzzard (Jul 23 2019 at 17:14)</a>:</h4>
<p>But now I've started to use lattices I think it's a really good idea.</p>

<a name="171538184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171538184" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171538184">Kevin Buzzard (Jul 23 2019 at 17:15)</a>:</h4>
<p>The fact that mathematicians want to see a different symbol should not be the problem of the code designer. This is some translation issue which is coming later.</p>

<a name="171538223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171538223" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171538223">Kevin Buzzard (Jul 23 2019 at 17:15)</a>:</h4>
<p>These issues should be solved using controlled natural language stuff leaving Lean to be as latticey as it wants to be.</p>

<a name="171539534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171539534" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171539534">Johan Commelin (Jul 23 2019 at 17:30)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> Chris is right. This line should be changed: <a href="https://github.com/leanprover-community/mathlib/blob/master/src/category_theory/category.lean#L137" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/src/category_theory/category.lean#L137">https://github.com/leanprover-community/mathlib/blob/master/src/category_theory/category.lean#L137</a></p>

<a name="171539560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171539560" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171539560">Johan Commelin (Jul 23 2019 at 17:31)</a>:</h4>
<p>Changing it might break some other parts of mathlib, but the refactor should make things easier (-;</p>

<a name="171540722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171540722" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171540722">Kevin Buzzard (Jul 23 2019 at 17:44)</a>:</h4>
<p>Every time Patrick or I try something, there's always some issue. You guys need to do some recruitment. I thought Australians were experts at category theory?</p>

<a name="171540889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171540889" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171540889">Kevin Buzzard (Jul 23 2019 at 17:46)</a>:</h4>
<p>I can't refactor a library I've barely used. I am still staring at</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">cylinder</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Top</span><span class="o">)</span> <span class="o">:</span> <span class="n">Top</span> <span class="o">:=</span> <span class="n">limit</span> <span class="o">(</span><span class="n">pair</span> <span class="n">X</span> <span class="n">I</span><span class="o">)</span>
<span class="c1">-- To define a map to the cylinder, we give a map to each factor.</span>
<span class="c1">-- `binary_fan.mk` is a helper method for constructing a `cone` over `pair X Y`.</span>
<span class="n">def</span> <span class="n">cylinder_0</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Top</span><span class="o">)</span> <span class="o">:</span> <span class="n">X</span> <span class="err">⟶</span> <span class="n">cylinder</span> <span class="n">X</span> <span class="o">:=</span>
<span class="n">limit</span><span class="bp">.</span><span class="n">lift</span> <span class="o">(</span><span class="n">pair</span> <span class="n">X</span> <span class="n">I</span><span class="o">)</span> <span class="o">(</span><span class="n">binary_fan</span><span class="bp">.</span><span class="n">mk</span> <span class="o">(</span><span class="mi">𝟙</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">to_pt</span> <span class="n">X</span> <span class="err">≫</span> <span class="n">I_0</span><span class="o">))</span>
</pre></div>


<p>and thinking "that's how you do <code>example (b : B) : A -&gt; A \prod B := \lam a, (a, b)</code> now is it? :-(</p>

<a name="171540914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171540914" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171540914">Johan Commelin (Jul 23 2019 at 17:46)</a>:</h4>
<p>The last time I tried to do modular forms in mathlib I had loads of issues (-; There was really nothing at all.</p>

<a name="171541105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171541105" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171541105">Johan Commelin (Jul 23 2019 at 17:48)</a>:</h4>
<p>Well, to be honest, in the example you give, you also have to include the fact that your easy definition is continuous.</p>

<a name="171541130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171541130" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171541130">Johan Commelin (Jul 23 2019 at 17:48)</a>:</h4>
<p>If you do that, I think the total count of characters won't be too far away from Scott's example.</p>

<a name="171541152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171541152" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171541152">Kevin Buzzard (Jul 23 2019 at 17:49)</a>:</h4>
<p>Do you think type class inference would do it?</p>

<a name="171541171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171541171" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171541171">Johan Commelin (Jul 23 2019 at 17:49)</a>:</h4>
<p>No, because <code>continuous</code> is not a class.</p>

<a name="171541197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171541197" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171541197">Kevin Buzzard (Jul 23 2019 at 17:49)</a>:</h4>
<p>Oh! Why not?</p>

<a name="171541215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171541215" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171541215">Kevin Buzzard (Jul 23 2019 at 17:49)</a>:</h4>
<p>I think we've had this discussion before</p>

<a name="171541282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171541282" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171541282">Kevin Buzzard (Jul 23 2019 at 17:50)</a>:</h4>
<p>So you are kind of elevating it to class status</p>

<a name="171541296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171541296" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171541296">Johan Commelin (Jul 23 2019 at 17:50)</a>:</h4>
<p>Ooh, and snap... <code>ulift $ plift</code> stuff for preorder cats is there to make the category small )-;</p>

<a name="171541315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171541315" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171541315">Johan Commelin (Jul 23 2019 at 17:50)</a>:</h4>
<p>I have no idea why <code>continuous</code> is not a class. But it was never done.</p>

<a name="171541978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171541978" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171541978">Chris Hughes (Jul 23 2019 at 17:57)</a>:</h4>
<p>I tried fixing the <code>preorder.category</code>, but Prop homs aren't small categories any more, so the limit stuff doesn't work because that is all on small categories.</p>

<a name="171542157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171542157" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171542157">Johan Commelin (Jul 23 2019 at 17:59)</a>:</h4>
<p>Stupid non-cumulative universes <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>

<a name="171542566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171542566" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171542566">Johan Commelin (Jul 23 2019 at 18:02)</a>:</h4>
<p>I guess we'll have to live with <code>uplift</code>... taking non-small limits comes with its own bucket of headaches.</p>

<a name="171555088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171555088" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171555088">Kevin Buzzard (Jul 23 2019 at 20:28)</a>:</h4>
<p>I'm trying to prove that my homsets are subsingletons and Lean is asking me whether the left inclusion <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi><mo>∩</mo><mi>U</mi><mo>→</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">U\cap U\to U</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span></span> is equal to the right inclusion.</p>

<a name="171555097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171555097" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171555097">Kevin Buzzard (Jul 23 2019 at 20:29)</a>:</h4>
<p>What am I supposed to say to that??</p>

<a name="171555108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171555108" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171555108">Kevin Buzzard (Jul 23 2019 at 20:29)</a>:</h4>
<p>They're definitely the same :-/</p>

<a name="171555228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171555228" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171555228">Kevin Buzzard (Jul 23 2019 at 20:30)</a>:</h4>
<p>I think I mustn't implement the hom sets as abstract types. I think I actually need to think about them as explicit functions and then I can extensionality.</p>

<a name="171556026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171556026" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171556026">Kevin Buzzard (Jul 23 2019 at 20:41)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> <span class="user-mention" data-user-id="112680">@Johan Commelin</span> I don't know how to steer the category theory library. All I want to do is glue a bunch of unbundled top spaces together. I need to make the appropriate category. The objects I can make. For the morphisms I tried first making a partial order on the objects and then making the associated small category, and I was forever having to deal with goals like <code>plift (X or Y)</code> not being able to decompose easily. I'm now trying to build the morphisms but I can't prove that hom sets are subsingletons and I don't know whether I should be trying to do that or not.</p>

<a name="171556497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171556497" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171556497">Kevin Buzzard (Jul 23 2019 at 20:47)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">topology</span><span class="bp">.</span><span class="n">Top</span><span class="bp">.</span><span class="n">limits</span>
<span class="kn">import</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">limits</span><span class="bp">.</span><span class="n">shapes</span>
<span class="kn">import</span> <span class="n">topology</span><span class="bp">.</span><span class="n">instances</span><span class="bp">.</span><span class="n">real</span>

<span class="c1">-- Want to create X from an open cover U_i, as a colimit.</span>
<span class="c1">-- So we&#39;re given the U_i for i in an index type I, and</span>
<span class="c1">-- also the &quot;glue&quot;</span>

<span class="c1">-- unbundled data</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">i</span>
<span class="kn">variable</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">i</span><span class="o">)</span> <span class="c1">-- index type</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">Ui</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">topological_space</span> <span class="o">(</span><span class="n">Ui</span> <span class="n">i</span><span class="o">)]</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">Uij</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">→</span> <span class="n">I</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">topological_space</span> <span class="o">(</span><span class="n">Uij</span> <span class="n">i</span> <span class="n">j</span><span class="o">)]</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">inc_l</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">i</span> <span class="n">j</span><span class="o">},</span> <span class="n">Uij</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">→</span> <span class="n">Ui</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">inc_l_cts</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">I</span><span class="o">,</span> <span class="n">continuous</span> <span class="o">(</span><span class="bp">@</span><span class="n">inc_l</span> <span class="n">i</span> <span class="n">j</span><span class="o">))</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">inc_r</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">i</span> <span class="n">j</span><span class="o">},</span> <span class="n">Uij</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">→</span> <span class="n">Ui</span> <span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">inc_r_cts</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">I</span><span class="o">,</span> <span class="n">continuous</span> <span class="o">(</span><span class="bp">@</span><span class="n">inc_r</span> <span class="n">i</span> <span class="n">j</span><span class="o">))</span>

<span class="kn">inductive</span> <span class="n">J</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">i</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">of_I</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">→</span> <span class="n">J</span>
<span class="bp">|</span> <span class="n">of_glue</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">→</span> <span class="n">I</span> <span class="bp">→</span> <span class="n">J</span>

<span class="kn">namespace</span> <span class="n">J</span>

<span class="c1">-- In general, things are easier if homs are props.</span>
<span class="c1">-- But in category theory I had problems defining maps</span>
<span class="c1">-- from a proppyhom category because I was always having</span>
<span class="c1">-- to solve goals of the form plift (X ∨ Y) -&gt; plift X ⊕ plift Y.</span>
<span class="c1">-- So I gave up on</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">inductive le : J I → J I → Prop</span>
<span class="cm">| refl (j : J I) : le j j</span>
<span class="cm">| res_l (i₁ i₂ : I) : le (of_I i₁) (of_glue i₁ i₂)</span>
<span class="cm">| res_r (i₁ i₂ : I) : le (of_I i₂) (of_glue i₁ i₂)</span>
<span class="cm">-/</span>

<span class="c1">-- and went for homs in Type u.</span>

<span class="kn">inductive</span> <span class="n">hom</span> <span class="o">:</span> <span class="n">J</span> <span class="n">I</span> <span class="bp">→</span> <span class="n">J</span> <span class="n">I</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">i</span>
<span class="bp">|</span> <span class="n">id</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">J</span> <span class="n">I</span><span class="o">)</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">j</span> <span class="n">j</span>
<span class="bp">|</span> <span class="n">res_l</span> <span class="o">(</span><span class="n">i₁</span> <span class="n">i₂</span> <span class="o">:</span> <span class="n">I</span><span class="o">)</span> <span class="o">:</span> <span class="n">hom</span> <span class="o">(</span><span class="n">of_I</span> <span class="n">i₁</span><span class="o">)</span> <span class="o">(</span><span class="n">of_glue</span> <span class="n">i₁</span> <span class="n">i₂</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">res_r</span> <span class="o">(</span><span class="n">i₁</span> <span class="n">i₂</span> <span class="o">:</span> <span class="n">I</span><span class="o">)</span> <span class="o">:</span> <span class="n">hom</span> <span class="o">(</span><span class="n">of_I</span> <span class="n">i₂</span><span class="o">)</span> <span class="o">(</span><span class="n">of_glue</span> <span class="n">i₁</span> <span class="n">i₂</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">hom</span>

<span class="n">def</span> <span class="n">hom</span><span class="bp">.</span><span class="n">comp</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span> <span class="o">:</span> <span class="n">J</span> <span class="n">I</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">I</span> <span class="n">X</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">I</span> <span class="n">Y</span> <span class="n">Z</span><span class="o">),</span> <span class="n">hom</span> <span class="n">I</span> <span class="n">X</span> <span class="n">Z</span>
  <span class="bp">|</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="n">id</span> <span class="bp">_</span><span class="o">)</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">h</span>
  <span class="bp">|</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">h</span> <span class="o">(</span><span class="n">id</span> <span class="bp">_</span><span class="o">)</span> <span class="o">:=</span> <span class="n">h</span>
  <span class="c1">-- these next lines should match the line above, right?</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">of_I</span> <span class="bp">_</span><span class="o">)</span> <span class="o">(</span><span class="n">of_glue</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="o">(</span><span class="n">of_glue</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="o">(</span><span class="n">res_l</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="o">(</span><span class="n">id</span> <span class="o">(</span><span class="n">of_glue</span> <span class="n">i₁</span> <span class="n">i₂</span><span class="o">))</span> <span class="o">:=</span> <span class="n">res_l</span> <span class="n">i₁</span> <span class="n">i₂</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">of_I</span> <span class="bp">_</span><span class="o">)</span> <span class="o">(</span><span class="n">of_glue</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="o">(</span><span class="n">of_glue</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="o">(</span><span class="n">res_r</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="o">(</span><span class="n">id</span> <span class="o">(</span><span class="n">of_glue</span> <span class="n">i₁</span> <span class="n">i₂</span><span class="o">))</span> <span class="o">:=</span> <span class="n">res_r</span> <span class="bp">_</span> <span class="bp">_</span>

<span class="kn">open</span> <span class="n">category_theory</span>

<span class="kn">instance</span> <span class="n">category_struct</span> <span class="o">:</span> <span class="n">category_struct</span> <span class="o">(</span><span class="n">J</span> <span class="n">I</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">hom</span>  <span class="o">:=</span> <span class="n">hom</span> <span class="n">I</span><span class="o">,</span>
  <span class="n">id</span>   <span class="o">:=</span> <span class="n">hom</span><span class="bp">.</span><span class="n">id</span><span class="o">,</span>
  <span class="n">comp</span> <span class="o">:=</span> <span class="n">hom</span><span class="bp">.</span><span class="n">comp</span> <span class="n">I</span> <span class="o">}</span>

<span class="kn">instance</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">J</span> <span class="n">I</span><span class="o">)</span> <span class="o">:</span> <span class="n">subsingleton</span> <span class="o">(</span><span class="n">X</span> <span class="err">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:=</span> <span class="k">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">refl</span><span class="o">,</span>
  <span class="c1">-- wait this might not actually be true. Is res_l i i equal to res_r i i?</span>
  <span class="n">sorry</span><span class="o">,</span><span class="n">sorry</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p>Do I care about subsingletons?</p>

<a name="171556531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171556531" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171556531">Kevin Buzzard (Jul 23 2019 at 20:47)</a>:</h4>
<p>Is <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi><mo>∩</mo><mi>U</mi><mo>=</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">U\cap U=U</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span></span> abstractly or not?</p>

<a name="171560569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171560569" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171560569">Kevin Buzzard (Jul 23 2019 at 21:44)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> if I just want to mimic taking the union of some subspaces of a topological space as a colimit, what diagram should I use?</p>

<a name="171562459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171562459" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171562459">Mario Carneiro (Jul 23 2019 at 22:19)</a>:</h4>
<p>Making <code>hom</code> live in Type like that is actually a big difference than making it live in Prop and applying <code>plift</code> to the result. <code>hom</code> is not a subsingleton; your statement in the comment is false</p>

<a name="171569015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171569015" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171569015">Scott Morrison (Jul 24 2019 at 00:36)</a>:</h4>
<p>It's just not true; the category you're defining does not have subsingleton homsets.</p>

<a name="171585026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171585026" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171585026">Kevin Buzzard (Jul 24 2019 at 07:40)</a>:</h4>
<p>Do I care? Maybe I just decide not to care at this point</p>


{% endraw %}

{% include archive_update.html %}