---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/116395maths/65388linearequivconstructor.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/65388linearequivconstructor.html">linear equiv constructor</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="194477546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20equiv%20constructor/near/194477546" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/65388linearequivconstructor.html#194477546">orlando (Apr 17 2020 at 17:55)</a>:</h4>
<p>Hello, in the file <code> basic / module </code><br>
There is the definition of linear equivalence : </p>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">linear_equiv</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">M₂</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">)</span>
  <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M₂</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M₂</span><span class="o">]</span>
  <span class="kn">extends</span> <span class="n">M</span> <span class="bp">→</span><span class="err">ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">M₂</span><span class="o">,</span> <span class="n">M</span> <span class="err">≃</span> <span class="n">M₂</span>
<span class="kn">end</span>
</pre></div>


<p>I never work with a structure extend structure,   how is the form of the constructor ?</p>

<a name="194478051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20equiv%20constructor/near/194478051" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/65388linearequivconstructor.html#194478051">Kevin Buzzard (Apr 17 2020 at 17:59)</a>:</h4>
<p>One way which always works is this: <code>def foo (R : Type u) (M : Type v) (M₂ : Type w) [ring R] [add_comm_group M] [add_comm_group M₂] [module R M] [module R M₂] : M ≃ₗ[R] M₂  := {! !}</code> and then click on the <code>!</code> and then click on the little yellow lightbulb and select the last-but-one option: "generate a skeleton for the structure under construction".</p>

<a name="194478227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20equiv%20constructor/near/194478227" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/65388linearequivconstructor.html#194478227">Kevin Buzzard (Apr 17 2020 at 18:00)</a>:</h4>
<p>(I assume you're talking about <code>linear_algebra.basic</code>; <code>M ≃ₗ[R] M₂</code> is notation for <code>linear_equiv R M M₂</code>)</p>

<a name="194478491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20equiv%20constructor/near/194478491" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/65388linearequivconstructor.html#194478491">orlando (Apr 17 2020 at 18:02)</a>:</h4>
<p>Thx Kevin, I think you already gave me this trick ! sorry ! </p>
<p>Yes   <code>linear_algebra.basic </code></p>

<a name="194478660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20equiv%20constructor/near/194478660" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/65388linearequivconstructor.html#194478660">Kevin Buzzard (Apr 17 2020 at 18:03)</a>:</h4>
<p>But if you already have <code>e : M ≃ M₂</code> then you do not have to fill in <code>to_fun</code> or <code>inv_fun</code> or <code>left_inv</code> or <code>right_inv</code>, you can just write <code>..e</code> after you have defined the other fields.</p>

<a name="194478795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20equiv%20constructor/near/194478795" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/65388linearequivconstructor.html#194478795">Kevin Buzzard (Apr 17 2020 at 18:04)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">basic</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span>

<span class="n">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">M₂</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">)</span>
<span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M₂</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M₂</span><span class="o">]</span>
<span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">M</span> <span class="err">≃</span> <span class="n">M₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">M</span> <span class="err">≃ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">M₂</span>  <span class="o">:=</span>
<span class="o">{</span>
  <span class="n">add</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">smul</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="bp">..</span><span class="n">e</span><span class="o">}</span>
</pre></div>

<a name="194478895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20equiv%20constructor/near/194478895" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/65388linearequivconstructor.html#194478895">Kevin Buzzard (Apr 17 2020 at 18:05)</a>:</h4>
<p>and similarly if you already have a linear map<code>f : M →ₗ[R] M₂</code> then you only have to fill in the inverse map and the proofs that it is an inverse, and then add <code>..f</code></p>

<a name="194478909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20equiv%20constructor/near/194478909" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/65388linearequivconstructor.html#194478909">orlando (Apr 17 2020 at 18:05)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>  my bad, i use your trick two hour ago ! with this structure </p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">rest_is_lin_equiv</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">stable_sub_module</span> <span class="n">ρ</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="err">≃ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">p</span> <span class="o">:=</span>  <span class="k">begin</span>
<span class="o">{</span><span class="bp">!</span> <span class="bp">!</span> <span class="o">}</span><span class="kn">end</span>
</pre></div>


<p>And i have i message : </p>
<div class="codehilite"><pre><span></span><span class="n">too</span> <span class="n">many</span> <span class="n">constructors</span>
<span class="n">state</span><span class="o">:</span>
<span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">,</span>
<span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">,</span>
<span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_1</span> <span class="o">:</span> <span class="n">group</span> <span class="n">G</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_2</span> <span class="o">:</span> <span class="n">ring</span> <span class="n">R</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_3</span> <span class="o">:</span> <span class="n">add_comm_group</span> <span class="n">M</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_4</span> <span class="o">:</span> <span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">,</span>
<span class="n">ρ</span> <span class="o">:</span> <span class="n">group_representation</span> <span class="n">G</span> <span class="n">R</span> <span class="n">M</span><span class="o">,</span>
<span class="n">p</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="n">stable_sub_module</span> <span class="n">ρ</span> <span class="n">p</span><span class="o">,</span>
<span class="n">g</span> <span class="o">:</span> <span class="n">G</span>
<span class="err">⊢</span> <span class="n">tactic</span> <span class="o">{</span><span class="bp">!</span> <span class="bp">!</span><span class="o">}</span>
</pre></div>


<p>But without <code>begin end </code> it's ok !</p>

<a name="194478990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20equiv%20constructor/near/194478990" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/65388linearequivconstructor.html#194478990">Kevin Buzzard (Apr 17 2020 at 18:06)</a>:</h4>
<p>Yes, <code>{! !}</code> is term mode.</p>

<a name="194479008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20equiv%20constructor/near/194479008" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/65388linearequivconstructor.html#194479008">orlando (Apr 17 2020 at 18:06)</a>:</h4>
<p>rohhhhh</p>

<a name="194479017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20equiv%20constructor/near/194479017" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/65388linearequivconstructor.html#194479017">Kevin Buzzard (Apr 17 2020 at 18:06)</a>:</h4>
<p>Make definitions in term mode, and prove theorems in tactic mode.</p>

<a name="194479125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20equiv%20constructor/near/194479125" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/65388linearequivconstructor.html#194479125">Kevin Buzzard (Apr 17 2020 at 18:07)</a>:</h4>
<p>If you are defining <code>X : Type*</code> or <code>P : Prop</code> or <code>x : X</code> with <code>X : Type*</code>, it's best to use term mode. If you are defining <code>h : P</code> with <code>P : Prop</code> then tactic mode is fine. If you see <code>⊢ P</code> in tactic mode then it is best if <code>P : Prop</code>.</p>

<a name="194479334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20equiv%20constructor/near/194479334" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/65388linearequivconstructor.html#194479334">Kevin Buzzard (Apr 17 2020 at 18:09)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">basic</span>

<span class="n">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">M₂</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M₂</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M₂</span><span class="o">]</span>
 <span class="o">:</span> <span class="n">M</span> <span class="err">≃ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">M₂</span>  <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">constructor</span><span class="o">,</span>
  <span class="n">sorry</span><span class="o">,</span> <span class="n">sorry</span><span class="o">,</span> <span class="n">sorry</span><span class="o">,</span> <span class="n">sorry</span><span class="o">,</span> <span class="n">sorry</span><span class="o">,</span> <span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>


<p>is not a good idea.</p>

<a name="194479452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20equiv%20constructor/near/194479452" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/65388linearequivconstructor.html#194479452">orlando (Apr 17 2020 at 18:10)</a>:</h4>
<p>I do that <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span>  and it's not a good idea ! Complicated to understand the field !</p>

<a name="194479478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20equiv%20constructor/near/194479478" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/65388linearequivconstructor.html#194479478">orlando (Apr 17 2020 at 18:10)</a>:</h4>
<p>Thx !!!!</p>

<a name="194479776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20equiv%20constructor/near/194479776" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/65388linearequivconstructor.html#194479776">Kevin Buzzard (Apr 17 2020 at 18:12)</a>:</h4>
<p>But this is OK:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">basic</span> <span class="n">data</span><span class="bp">.</span><span class="n">rat</span><span class="bp">.</span><span class="n">basic</span>

<span class="n">def</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">ℚ</span> <span class="err">≃ₗ</span><span class="o">[</span><span class="bp">ℤ</span><span class="o">]</span> <span class="n">ℚ</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">refine_struct</span>
  <span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">id</span><span class="o">,</span>
    <span class="n">inv_fun</span> <span class="o">:=</span> <span class="n">id</span>
  <span class="o">},</span>
  <span class="o">{</span> <span class="n">sorry</span><span class="o">},</span>
  <span class="o">{</span> <span class="n">sorry</span><span class="o">},</span>
  <span class="o">{</span> <span class="n">sorry</span><span class="o">},</span>
  <span class="o">{</span> <span class="n">sorry</span><span class="o">}</span>
<span class="kn">end</span>
</pre></div>


<p>Here I define the data using term mode, and then I have four goals to solve in tactic mode.</p>

<a name="194479842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20equiv%20constructor/near/194479842" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/65388linearequivconstructor.html#194479842">Kevin Buzzard (Apr 17 2020 at 18:13)</a>:</h4>
<p><code>refine_struct</code> is a tactic which takes some structure field definitions (in term mode), and then leaves the rest of them as goals (in tactic mode). So now you can work on the goals which are theorems, in tactic mode.</p>

<a name="194490436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20equiv%20constructor/near/194490436" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/65388linearequivconstructor.html#194490436">orlando (Apr 17 2020 at 19:41)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>  : all good ... thx <span aria-label="+1" class="emoji emoji-1f44d" role="img" title="+1">:+1:</span></p>

<a name="194513353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20equiv%20constructor/near/194513353" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/65388linearequivconstructor.html#194513353">orlando (Apr 17 2020 at 23:45)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>  i have show that a linear map is an linear equiv. Can i have access to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex"> f^{-1} </annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> notation ? I don't understand how ? (there is no example in the file) .</p>

<a name="194513972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20equiv%20constructor/near/194513972" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/65388linearequivconstructor.html#194513972">Kevin Buzzard (Apr 17 2020 at 23:53)</a>:</h4>
<p>No, <code>\-1</code> is notation for <code>has_inv.inv</code> and <code>has_inv.inv : X -&gt; X</code>. But here the type of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">f^{-1}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> differ in general.</p>

<a name="194514047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20equiv%20constructor/near/194514047" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/65388linearequivconstructor.html#194514047">Kevin Buzzard (Apr 17 2020 at 23:54)</a>:</h4>
<p><code>\-1</code> notation is really bad anyway. For example <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mo><mi>sin</mi><mo>⁡</mo></mo><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><msup><mi>x</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sin^{-1}(x^{-1})</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.121868em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">sin</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.871868em;"><span style="top:-3.12076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> is two different uses of it, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mo><mi>sin</mi><mo>⁡</mo></mo><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">\sin^{-1}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.871868em;vertical-align:0em;"></span><span class="mop"><span class="mop">sin</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.871868em;"><span style="top:-3.12076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> isn't a two-sided inverse for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>sin</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\sin</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.66786em;vertical-align:0em;"></span><span class="mop">sin</span></span></span></span> anyway.</p>

<a name="194514094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20equiv%20constructor/near/194514094" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/65388linearequivconstructor.html#194514094">Kevin Buzzard (Apr 17 2020 at 23:55)</a>:</h4>
<p>If <code>e : M ≃ₗ[R] M₂</code> then...I can't remember if there's a coercion to function or not for equivalences.</p>

<a name="194514129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20equiv%20constructor/near/194514129" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/65388linearequivconstructor.html#194514129">Kevin Buzzard (Apr 17 2020 at 23:55)</a>:</h4>
<p>If there is, then <code>e.symm</code> is probably the inverse function (or <code>\u= e.symm</code>) and if there isn't then it's <code>e.inv_fun</code>.</p>

<a name="194514572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20equiv%20constructor/near/194514572" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/65388linearequivconstructor.html#194514572">orlando (Apr 18 2020 at 00:00)</a>:</h4>
<p>Ok Kevin, i check <code>e.symm</code>  another thing tomorow <span aria-label="slight smile" class="emoji emoji-1f642" role="img" title="slight smile">:slight_smile:</span></p>

<a name="194514781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20equiv%20constructor/near/194514781" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/65388linearequivconstructor.html#194514781">Scott Morrison (Apr 18 2020 at 00:03)</a>:</h4>
<p>Avoid using <code>inv_fun</code>. The preference is definitely to use <code>e.symm</code>, and the coercion to a function. So hopefully you can just write something like <code>e.symm x</code>. If the coercion to a function fails (this is fairly flaky in Lean 3; it's a hard problem for the elaborator), adding types usually works: <code>(e.symm : X \to Y) x</code>.</p>


{% endraw %}

{% include archive_update.html %}