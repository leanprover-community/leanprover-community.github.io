---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/116395maths/68348Liealgebras.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/68348Liealgebras.html">Lie algebras</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="127997275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20algebras/near/127997275" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/68348Liealgebras.html#127997275">Johan Commelin (Jun 13 2018 at 08:43)</a>:</h4>
<p>I am completely stuck on the sorried definition. Is this just to ambitious at the moment?</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">module</span>

<span class="n">class</span> <span class="n">has_bracket</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">bracket</span> <span class="o">:</span> <span class="n">Œ±</span> <span class="bp">‚Üí</span> <span class="n">Œ±</span> <span class="bp">‚Üí</span> <span class="n">Œ±</span><span class="o">)</span>

<span class="n">local</span> <span class="kn">notation</span> <span class="bp">`</span><span class="o">[</span><span class="bp">`</span> <span class="n">a</span> <span class="bp">`</span><span class="o">,</span><span class="bp">`</span> <span class="n">b</span> <span class="bp">`</span><span class="o">]</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">has_bracket</span><span class="bp">.</span><span class="n">bracket</span> <span class="n">a</span> <span class="n">b</span>

<span class="n">class</span> <span class="n">lie_algebra</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="n">out_param</span> <span class="err">$</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="err">ùî§</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">out_param</span> <span class="err">$</span> <span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>
<span class="kn">extends</span> <span class="n">module</span> <span class="n">R</span> <span class="err">ùî§</span><span class="o">,</span> <span class="n">has_bracket</span> <span class="err">ùî§</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">left_linear</span>  <span class="o">:=</span> <span class="bp">‚àÄ</span> <span class="n">y</span> <span class="o">:</span> <span class="err">ùî§</span><span class="o">,</span> <span class="n">is_linear_map</span> <span class="o">(</span><span class="bp">Œª</span> <span class="n">x</span> <span class="o">:</span> <span class="err">ùî§</span><span class="o">,</span> <span class="o">[</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">]))</span>
<span class="o">(</span><span class="n">right_linear</span> <span class="o">:=</span> <span class="bp">‚àÄ</span> <span class="n">x</span> <span class="o">:</span> <span class="err">ùî§</span><span class="o">,</span> <span class="n">is_linear_map</span> <span class="o">(</span><span class="bp">Œª</span> <span class="n">y</span> <span class="o">:</span> <span class="err">ùî§</span><span class="o">,</span> <span class="o">[</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">]))</span>
<span class="o">(</span><span class="n">alternating</span>  <span class="o">:=</span> <span class="bp">‚àÄ</span> <span class="n">x</span> <span class="o">:</span> <span class="err">ùî§</span><span class="o">,</span> <span class="o">[</span><span class="n">x</span><span class="o">,</span><span class="n">x</span><span class="o">]</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>
<span class="o">(</span><span class="n">Jacobi_identity</span> <span class="o">:=</span> <span class="bp">‚àÄ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="err">ùî§</span><span class="o">,</span> <span class="o">[</span><span class="n">x</span><span class="o">,[</span><span class="n">y</span><span class="o">,</span><span class="n">z</span><span class="o">]]</span> <span class="bp">+</span> <span class="o">[</span><span class="n">z</span><span class="o">,[</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">]]</span> <span class="bp">+</span> <span class="o">[</span><span class="n">y</span><span class="o">,[</span><span class="n">z</span><span class="o">,</span><span class="n">x</span><span class="o">]]</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>
<span class="o">(</span><span class="n">anti_comm</span>    <span class="o">:=</span> <span class="bp">‚àÄ</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="err">ùî§</span><span class="o">,</span> <span class="o">[</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">]</span> <span class="bp">=</span> <span class="bp">-</span><span class="o">([</span><span class="n">y</span><span class="o">,</span><span class="n">x</span><span class="o">]))</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ri</span> <span class="o">:</span> <span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">{</span><span class="err">ùî§</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">la</span> <span class="o">:</span> <span class="n">lie_algebra</span> <span class="n">R</span> <span class="err">ùî§</span><span class="o">]</span>
<span class="n">include</span> <span class="n">ri</span> <span class="n">la</span>

<span class="kn">section</span> <span class="n">from_ring</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">S</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">‚Üí</span> <span class="n">S</span><span class="o">}</span>  <span class="o">[</span><span class="n">is_ring_hom</span> <span class="n">f</span><span class="o">]</span>

<span class="kn">instance</span> <span class="n">commutator_bracket</span> <span class="o">:</span> <span class="n">has_bracket</span> <span class="n">S</span> <span class="o">:=</span> <span class="bp">‚ü®Œª</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span><span class="bp">*</span><span class="n">y</span> <span class="bp">-</span> <span class="n">y</span><span class="bp">*</span><span class="n">x</span><span class="bp">‚ü©</span>

<span class="kn">definition</span> <span class="n">ring</span><span class="bp">.</span><span class="n">to_lie_algebra</span> <span class="o">:</span> <span class="n">lie_algebra</span> <span class="n">R</span> <span class="n">S</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="c1">-- { sorry,</span>
<span class="c1">--   ..ring.to_module }</span>

<span class="kn">end</span> <span class="n">from_ring</span>
</pre></div>

<a name="127997433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20algebras/near/127997433" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/68348Liealgebras.html#127997433">Kevin Buzzard (Jun 13 2018 at 08:47)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">definition</span> <span class="n">ring</span><span class="bp">.</span><span class="n">to_lie_algebra</span> <span class="o">:</span> <span class="n">lie_algebra</span> <span class="n">R</span> <span class="n">S</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">constructor</span><span class="o">,</span> <span class="c1">-- fails</span>
<span class="kn">end</span>
</pre></div>

<a name="127997434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20algebras/near/127997434" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/68348Liealgebras.html#127997434">Kevin Buzzard (Jun 13 2018 at 08:47)</a>:</h4>
<p>I am a bit surprised about this.</p>

<a name="127997547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20algebras/near/127997547" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/68348Liealgebras.html#127997547">Kevin Buzzard (Jun 13 2018 at 08:50)</a>:</h4>
<p><code>{}</code> is more instructive</p>

<a name="127997549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20algebras/near/127997549" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/68348Liealgebras.html#127997549">Kevin Buzzard (Jun 13 2018 at 08:50)</a>:</h4>
<p>It says it can't prove <code>module R S</code></p>

<a name="127997556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20algebras/near/127997556" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/68348Liealgebras.html#127997556">Kevin Buzzard (Jun 13 2018 at 08:51)</a>:</h4>
<p>which is fair enough because you never mentioned <code>f</code></p>

<a name="127997636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20algebras/near/127997636" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/68348Liealgebras.html#127997636">Kevin Buzzard (Jun 13 2018 at 08:53)</a>:</h4>
<p>and <code>ring.to_module</code> is only the statement that <code>R</code> is an <code>R</code>-module</p>

<a name="127997692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20algebras/near/127997692" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/68348Liealgebras.html#127997692">Johan Commelin (Jun 13 2018 at 08:54)</a>:</h4>
<p>Right. Thanks a lot!</p>

<a name="127997693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20algebras/near/127997693" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/68348Liealgebras.html#127997693">Kevin Buzzard (Jun 13 2018 at 08:54)</a>:</h4>
<p>I think when I was in your position a few months ago, wrestling with the type class inference system (but in a much less complex situation) Sebastian just pointed out that I could over-ride everything.</p>

<a name="127997709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20algebras/near/127997709" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/68348Liealgebras.html#127997709">Kevin Buzzard (Jun 13 2018 at 08:55)</a>:</h4>
<p>so I would just go and make my own explicit instances of everything</p>

<a name="127997714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20algebras/near/127997714" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/68348Liealgebras.html#127997714">Kevin Buzzard (Jun 13 2018 at 08:55)</a>:</h4>
<p>and this got me a bit further</p>

<a name="127997734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20algebras/near/127997734" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/68348Liealgebras.html#127997734">Kevin Buzzard (Jun 13 2018 at 08:56)</a>:</h4>
<p>I guess <code>constructor</code> doesn't work because it didn't even get round to thinking about how to construct the extra fields, it just gets hung up with the fact that it can't even make the extension</p>

<a name="127997822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20algebras/near/127997822" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/68348Liealgebras.html#127997822">Johan Commelin (Jun 13 2018 at 08:57)</a>:</h4>
<p>Ok, so I've got a proof of <code>module R S</code>. How do I feed it to the system?</p>

<a name="127997830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20algebras/near/127997830" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/68348Liealgebras.html#127997830">Johan Commelin (Jun 13 2018 at 08:57)</a>:</h4>
<p>Because <code>@lie_algebra</code> is not interested in such a proof...</p>

<a name="127997887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20algebras/near/127997887" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/68348Liealgebras.html#127997887">Johan Commelin (Jun 13 2018 at 08:58)</a>:</h4>
<p>Is the <code>extends module R _</code> giving me trouble? Does that <code>extends</code> imply that it wants do deduce the module structure by type class inference?</p>

<a name="127997963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20algebras/near/127997963" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/68348Liealgebras.html#127997963">Kevin Buzzard (Jun 13 2018 at 09:00)</a>:</h4>
<p>I used to ask this sort of question all the time. If you search for type class woes you'll find my thread where I asked about 10 questions of this nature.</p>

<a name="127998035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20algebras/near/127998035" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/68348Liealgebras.html#127998035">Kevin Buzzard (Jun 13 2018 at 09:02)</a>:</h4>
<p>Unfortunately I can't keep all the answers in my head and I still have not found the time to go through that thread and write down all the tips in a proper doc</p>

<a name="127998455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20algebras/near/127998455" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/68348Liealgebras.html#127998455">Johan Commelin (Jun 13 2018 at 09:12)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> Misa stupid! In the definition of the class I shouldn't use <code>:=</code> but <code>:</code> for the axioms... it should be</p>
<div class="codehilite"><pre><span></span><span class="n">class</span> <span class="n">lie_algebra</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="n">out_param</span> <span class="err">$</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="err">ùî§</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">out_param</span> <span class="err">$</span> <span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>
<span class="kn">extends</span> <span class="n">module</span> <span class="n">R</span> <span class="err">ùî§</span><span class="o">,</span> <span class="n">has_bracket</span> <span class="err">ùî§</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">left_linear</span>  <span class="o">:</span> <span class="bp">‚àÄ</span> <span class="n">y</span> <span class="o">:</span> <span class="err">ùî§</span><span class="o">,</span> <span class="n">is_linear_map</span> <span class="o">(</span><span class="bp">Œª</span> <span class="n">x</span> <span class="o">:</span> <span class="err">ùî§</span><span class="o">,</span> <span class="o">[</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">]))</span>
<span class="o">(</span><span class="n">right_linear</span> <span class="o">:</span> <span class="bp">‚àÄ</span> <span class="n">x</span> <span class="o">:</span> <span class="err">ùî§</span><span class="o">,</span> <span class="n">is_linear_map</span> <span class="o">(</span><span class="bp">Œª</span> <span class="n">y</span> <span class="o">:</span> <span class="err">ùî§</span><span class="o">,</span> <span class="o">[</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">]))</span>
<span class="o">(</span><span class="n">alternating</span>  <span class="o">:</span> <span class="bp">‚àÄ</span> <span class="n">x</span> <span class="o">:</span> <span class="err">ùî§</span><span class="o">,</span> <span class="o">[</span><span class="n">x</span><span class="o">,</span><span class="n">x</span><span class="o">]</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>
<span class="o">(</span><span class="n">Jacobi_identity</span> <span class="o">:</span> <span class="bp">‚àÄ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="err">ùî§</span><span class="o">,</span> <span class="o">[</span><span class="n">x</span><span class="o">,[</span><span class="n">y</span><span class="o">,</span><span class="n">z</span><span class="o">]]</span> <span class="bp">+</span> <span class="o">[</span><span class="n">z</span><span class="o">,[</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">]]</span> <span class="bp">+</span> <span class="o">[</span><span class="n">y</span><span class="o">,[</span><span class="n">z</span><span class="o">,</span><span class="n">x</span><span class="o">]]</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>
<span class="o">(</span><span class="n">anti_comm</span>    <span class="o">:</span> <span class="bp">‚àÄ</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="err">ùî§</span><span class="o">,</span> <span class="o">[</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">]</span> <span class="bp">=</span> <span class="bp">-</span><span class="o">([</span><span class="n">y</span><span class="o">,</span><span class="n">x</span><span class="o">]))</span>
</pre></div>


<p>That messed up everything. Now that I've fixed it, all of a sudden problems vanish!</p>

<a name="127999527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20algebras/near/127999527" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/68348Liealgebras.html#127999527">Kevin Buzzard (Jun 13 2018 at 09:42)</a>:</h4>
<p>Oh yeah. Sorry, I should have caught that.</p>

<a name="128000028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20algebras/near/128000028" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/68348Liealgebras.html#128000028">Johan Commelin (Jun 13 2018 at 09:55)</a>:</h4>
<p>Yoohoo!</p>
<div class="codehilite"><pre><span></span><span class="kn">section</span> <span class="n">from_ring</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">S</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">‚Üí</span> <span class="n">S</span><span class="o">}</span>  <span class="o">[</span><span class="n">is_ring_hom</span> <span class="n">f</span><span class="o">]</span>
<span class="kn">variable</span>  <span class="o">{</span><span class="n">central</span> <span class="o">:</span> <span class="bp">‚àÄ</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">S</span><span class="o">),</span> <span class="n">f</span><span class="o">(</span><span class="n">r</span><span class="o">)</span> <span class="bp">*</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">s</span> <span class="bp">*</span> <span class="n">f</span><span class="o">(</span><span class="n">r</span><span class="o">)}</span>

<span class="kn">instance</span> <span class="n">commutator_bracket</span> <span class="o">:</span> <span class="n">has_bracket</span> <span class="n">S</span> <span class="o">:=</span> <span class="bp">‚ü®Œª</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span><span class="bp">*</span><span class="n">y</span> <span class="bp">-</span> <span class="n">y</span><span class="bp">*</span><span class="n">x</span><span class="bp">‚ü©</span>

<span class="n">include</span> <span class="n">central</span>
<span class="kn">definition</span> <span class="n">ring</span><span class="bp">.</span><span class="n">to_lie_algebra</span> <span class="o">:</span> <span class="n">lie_algebra</span> <span class="n">R</span> <span class="n">S</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">left_linear</span>  <span class="o">:=</span> <span class="k">begin</span>
    <span class="n">intro</span> <span class="n">y</span><span class="o">,</span>
    <span class="n">dsimp</span> <span class="o">[</span><span class="n">commutator_bracket</span><span class="o">],</span>
    <span class="n">constructor</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">x‚ÇÅ</span> <span class="n">x‚ÇÇ</span><span class="o">,</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">left_distrib</span><span class="o">,</span><span class="n">right_distrib</span><span class="o">,</span><span class="n">mul_assoc</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">r</span> <span class="n">x</span><span class="o">,</span>
      <span class="k">show</span> <span class="n">f</span> <span class="n">r</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">+</span> <span class="bp">-</span><span class="o">(</span><span class="n">y</span> <span class="bp">*</span> <span class="o">(</span><span class="n">f</span> <span class="n">r</span> <span class="bp">*</span> <span class="n">x</span><span class="o">))</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">r</span> <span class="bp">*</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">+</span> <span class="bp">-</span><span class="o">(</span><span class="n">y</span> <span class="bp">*</span> <span class="n">x</span><span class="o">)),</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">left_distrib</span><span class="o">,</span><span class="n">right_distrib</span><span class="o">,</span><span class="n">mul_assoc</span><span class="o">,</span><span class="n">central</span><span class="o">]</span> <span class="o">}</span>
  <span class="kn">end</span><span class="o">,</span>
  <span class="n">right_linear</span> <span class="o">:=</span> <span class="k">begin</span>
    <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">dsimp</span> <span class="o">[</span><span class="n">commutator_bracket</span><span class="o">],</span>
    <span class="n">constructor</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">x‚ÇÅ</span> <span class="n">x‚ÇÇ</span><span class="o">,</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">left_distrib</span><span class="o">,</span><span class="n">right_distrib</span><span class="o">,</span><span class="n">mul_assoc</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">r</span> <span class="n">y</span><span class="o">,</span>
      <span class="k">show</span> <span class="n">x</span> <span class="bp">*</span> <span class="o">(</span><span class="n">f</span> <span class="n">r</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">+</span> <span class="bp">-</span><span class="o">(</span><span class="n">f</span> <span class="n">r</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">*</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">r</span> <span class="bp">*</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">+</span> <span class="bp">-</span><span class="o">(</span><span class="n">y</span> <span class="bp">*</span> <span class="n">x</span><span class="o">)),</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">left_distrib</span><span class="o">,</span><span class="n">right_distrib</span><span class="o">,</span><span class="n">mul_assoc</span><span class="o">,</span><span class="n">central</span><span class="o">]</span> <span class="o">}</span>
  <span class="kn">end</span><span class="o">,</span>
  <span class="n">alternating</span>  <span class="o">:=</span> <span class="k">begin</span>
    <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">dsimp</span> <span class="o">[</span><span class="n">commutator_bracket</span><span class="o">],</span>
    <span class="n">simp</span>
  <span class="kn">end</span><span class="o">,</span>
  <span class="n">Jacobi_identity</span> <span class="o">:=</span> <span class="k">begin</span>
    <span class="n">intros</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">,</span>
    <span class="n">dsimp</span> <span class="o">[</span><span class="n">commutator_bracket</span><span class="o">],</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">left_distrib</span><span class="o">,</span><span class="n">right_distrib</span><span class="o">,</span><span class="n">mul_assoc</span><span class="o">],</span>
  <span class="kn">end</span><span class="o">,</span>
  <span class="n">anti_comm</span> <span class="o">:=</span> <span class="k">begin</span>
    <span class="n">intros</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
    <span class="n">dsimp</span> <span class="o">[</span><span class="n">commutator_bracket</span><span class="o">],</span>
    <span class="n">simp</span>
  <span class="kn">end</span><span class="o">,</span>
  <span class="bp">..</span><span class="n">restriction_of_scalars</span><span class="bp">.</span><span class="n">restriction_of_scalars</span> <span class="n">f</span> <span class="n">S</span>
<span class="o">}</span>

<span class="kn">end</span> <span class="n">from_ring</span>
</pre></div>

<a name="128000036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20algebras/near/128000036" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/68348Liealgebras.html#128000036">Johan Commelin (Jun 13 2018 at 09:55)</a>:</h4>
<p>I like <code>simp</code>!</p>

<a name="128000082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20algebras/near/128000082" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/68348Liealgebras.html#128000082">Johan Commelin (Jun 13 2018 at 09:56)</a>:</h4>
<p>It's a pity I can't use <code>ring</code> because I'm not in a commutative setting...</p>

<a name="128000416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20algebras/near/128000416" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/68348Liealgebras.html#128000416">Kevin Buzzard (Jun 13 2018 at 10:04)</a>:</h4>
<blockquote>
<p>It's a pity I can't use <code>ring</code> because I'm not in a commutative setting...</p>
</blockquote>
<p>I can tell you how to write the non-commutative version :-)</p>

<a name="128000429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20algebras/near/128000429" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/68348Liealgebras.html#128000429">Johan Commelin (Jun 13 2018 at 10:05)</a>:</h4>
<p>Lol</p>

<a name="128000435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20algebras/near/128000435" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/68348Liealgebras.html#128000435">Kevin Buzzard (Jun 13 2018 at 10:05)</a>:</h4>
<p>actually there would be an issue</p>

<a name="128000446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20algebras/near/128000446" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/68348Liealgebras.html#128000446">Johan Commelin (Jun 13 2018 at 10:05)</a>:</h4>
<p>Yes, I wouldn't be surprised if commutativity is essential [also: lunch]</p>

<a name="128000491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20algebras/near/128000491" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/68348Liealgebras.html#128000491">Kevin Buzzard (Jun 13 2018 at 10:06)</a>:</h4>
<p>There's even an issue with my baby ring tactic -- one needs to be able to put every polynomial into a "canonical form", so that two polynomials (e.g. x^2+1 and 0*x^3+x^2+1) are equal if and only if their canonical forms are equal.</p>

<a name="128000502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20algebras/near/128000502" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/68348Liealgebras.html#128000502">Chris Hughes (Jun 13 2018 at 10:07)</a>:</h4>
<p>Make your polynomials a subtype, with a proof that the leading coeff is not zero</p>

<a name="128000509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20algebras/near/128000509" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/68348Liealgebras.html#128000509">Chris Hughes (Jun 13 2018 at 10:07)</a>:</h4>
<p>Like finsets.</p>

<a name="128000510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20algebras/near/128000510" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/68348Liealgebras.html#128000510">Kevin Buzzard (Jun 13 2018 at 10:07)</a>:</h4>
<p>In my baby ring tactic this isn't even present (yet). In the grown-up ring tactic Mario uses Gregoire-Mahboubi's strategy of writing everything in "horner form" because this is much more efficient for sparse polys</p>

<a name="128000519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20algebras/near/128000519" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/68348Liealgebras.html#128000519">Kevin Buzzard (Jun 13 2018 at 10:07)</a>:</h4>
<p>but in the non-comm case you would have to figure out a canonical form I guess, at least if you wanted to maximise the chance that the tactic worked.</p>

<a name="128000560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20algebras/near/128000560" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/68348Liealgebras.html#128000560">Kevin Buzzard (Jun 13 2018 at 10:08)</a>:</h4>
<p>Chris -- this doesn't work for zero</p>

<a name="128000566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20algebras/near/128000566" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/68348Liealgebras.html#128000566">Kevin Buzzard (Jun 13 2018 at 10:08)</a>:</h4>
<p>I was going to go for the following:</p>

<a name="128000571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20algebras/near/128000571" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/68348Liealgebras.html#128000571">Kevin Buzzard (Jun 13 2018 at 10:08)</a>:</h4>
<p>either an empty list, or a non-empty list with last element non-zero</p>

<a name="128000588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20algebras/near/128000588" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/68348Liealgebras.html#128000588">Kevin Buzzard (Jun 13 2018 at 10:09)</a>:</h4>
<p>One would have to check non-zero-ness in the ground ring (which might be Z/2Z)</p>

<a name="128000589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20algebras/near/128000589" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/68348Liealgebras.html#128000589">Chris Hughes (Jun 13 2018 at 10:09)</a>:</h4>
<p>What's the last element function?</p>

<a name="128000593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20algebras/near/128000593" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/68348Liealgebras.html#128000593">Kevin Buzzard (Jun 13 2018 at 10:09)</a>:</h4>
<p>I've seen one before</p>

<a name="128000595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20algebras/near/128000595" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/68348Liealgebras.html#128000595">Kevin Buzzard (Jun 13 2018 at 10:09)</a>:</h4>
<p>I've seen an n'th element function somewhere in list.lean</p>

<a name="128000596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20algebras/near/128000596" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/68348Liealgebras.html#128000596">Chris Hughes (Jun 13 2018 at 10:09)</a>:</h4>
<p>How does it habdle the empty list? If it's option you're okay.</p>

<a name="128000599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20algebras/near/128000599" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/68348Liealgebras.html#128000599">Kevin Buzzard (Jun 13 2018 at 10:09)</a>:</h4>
<p>unsurprisingly, there are all sorts of variants</p>

<a name="128000646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20algebras/near/128000646" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/68348Liealgebras.html#128000646">Kevin Buzzard (Jun 13 2018 at 10:10)</a>:</h4>
<p>e.g. one which asks for a proof that n &lt; length before giving you a non-option n'th element</p>

<a name="128000696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20algebras/near/128000696" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/68348Liealgebras.html#128000696">Chris Hughes (Jun 13 2018 at 10:11)</a>:</h4>
<p><code>list.head'</code> looks like the best one, depending on the order of your lists.</p>


{% endraw %}

{% include archive_update.html %}