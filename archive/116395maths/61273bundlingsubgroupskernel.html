---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/116395maths/61273bundlingsubgroupskernel.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/61273bundlingsubgroupskernel.html">bundling subgroups -- kernel</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="189968634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189968634" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/61273bundlingsubgroupskernel.html#189968634">Kevin Buzzard (Mar 07 2020 at 12:12)</a>:</h4>
<p>What's the best definition of kernel? Are there arguments in both directions?</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">ker</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→+</span> <span class="n">H</span><span class="o">)</span> <span class="o">:</span> <span class="n">add_subgroup</span> <span class="n">G</span> <span class="o">:=</span> <span class="o">(</span><span class="err">⊥</span> <span class="o">:</span> <span class="n">add_subgroup</span> <span class="n">H</span><span class="o">)</span><span class="bp">.</span><span class="n">comap</span> <span class="n">f</span>

<span class="n">def</span> <span class="n">ker&#39;</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→+</span> <span class="n">H</span><span class="o">)</span> <span class="o">:</span> <span class="n">add_subgroup</span> <span class="n">G</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">carrier</span> <span class="o">:=</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">|</span> <span class="n">f</span> <span class="n">g</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">},</span>
  <span class="n">zero_mem</span> <span class="o">:=</span> <span class="bp">...</span>
  <span class="bp">...</span>
<span class="o">}</span>
</pre></div>


<p>The difference is that with the second definition <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>∈</mo><mi>k</mi><mi>e</mi><mi>r</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mtext>  </mtext><mo>⟺</mo><mtext>  </mtext><mi>f</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">g\in ker(f)\iff f(g)=0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⟺</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> is definitional, whereas the other definition expands to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo><mo>∈</mo><mo stretchy="false">{</mo><mn>0</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">f(g)\in\{0\}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mclose">}</span></span></span></span> which is defeq to something else</p>

<a name="189968744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189968744" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/61273bundlingsubgroupskernel.html#189968744">Johan Commelin (Mar 07 2020 at 12:16)</a>:</h4>
<p>My gut feeling would say, go for (2).</p>

<a name="189968746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189968746" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/61273bundlingsubgroupskernel.html#189968746">Johan Commelin (Mar 07 2020 at 12:16)</a>:</h4>
<p>But you'll want a lemma that says that the two definition are equal anyway.</p>

<a name="189968753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189968753" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/61273bundlingsubgroupskernel.html#189968753">Kevin Buzzard (Mar 07 2020 at 12:17)</a>:</h4>
<p>Sure, this is purely a question of which one you want to be the definition and which one you want to be the theorem. But I don't have any real criteria for deciding.</p>

<a name="189968800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189968800" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/61273bundlingsubgroupskernel.html#189968800">Mario Carneiro (Mar 07 2020 at 12:18)</a>:</h4>
<p>Alternatively you could step back to <code>\bot</code> itself, to fix the definition so that you get the definitional equality you want with the first version</p>

<a name="189968805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189968805" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/61273bundlingsubgroupskernel.html#189968805">Kevin Buzzard (Mar 07 2020 at 12:19)</a>:</h4>
<p>\bot is a subgroup of H so I need to define the carrier set.</p>

<a name="189968808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189968808" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/61273bundlingsubgroupskernel.html#189968808">Mario Carneiro (Mar 07 2020 at 12:19)</a>:</h4>
<p><code>{x | x = 0}</code></p>

<a name="189968809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189968809" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/61273bundlingsubgroupskernel.html#189968809">Kevin Buzzard (Mar 07 2020 at 12:19)</a>:</h4>
<p>!</p>

<a name="189968810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189968810" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/61273bundlingsubgroupskernel.html#189968810">Kevin Buzzard (Mar 07 2020 at 12:19)</a>:</h4>
<p>If I do it like this then they're probably defeq.</p>

<a name="189968812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189968812" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/61273bundlingsubgroupskernel.html#189968812">Kevin Buzzard (Mar 07 2020 at 12:19)</a>:</h4>
<p>:D</p>

<a name="189968852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189968852" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/61273bundlingsubgroupskernel.html#189968852">Mario Carneiro (Mar 07 2020 at 12:20)</a>:</h4>
<p>I  feel like a lot of things would be simpler if this was the definition of <code>singleton 0</code></p>

<a name="189968856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189968856" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/61273bundlingsubgroupskernel.html#189968856">Mario Carneiro (Mar 07 2020 at 12:21)</a>:</h4>
<p>maybe we should remove the definition of <code>singleton</code> from <code>init.core</code>?</p>

<a name="189968858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189968858" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/61273bundlingsubgroupskernel.html#189968858">Kevin Buzzard (Mar 07 2020 at 12:21)</a>:</h4>
<p>One could imagine that notation could handle this somehow -- <code>{}</code> expands to false and <code>{x}</code> to what you just said and then <code>{a,b}</code> could mean <code>{x | x = a \or x = b}</code> etc.</p>

<a name="189968903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189968903" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/61273bundlingsubgroupskernel.html#189968903">Mario Carneiro (Mar 07 2020 at 12:22)</a>:</h4>
<p>the idea that <code>singleton a = insert a empty</code> in all circumstances is probably a bad idea</p>

<a name="189968904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189968904" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/61273bundlingsubgroupskernel.html#189968904">Mario Carneiro (Mar 07 2020 at 12:22)</a>:</h4>
<p>but the definition is in <code>core</code>, in the very first file</p>

<a name="189968909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189968909" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/61273bundlingsubgroupskernel.html#189968909">Mario Carneiro (Mar 07 2020 at 12:23)</a>:</h4>
<p>we have a typeclass <code>has_insert</code>, so we could have <code>has_singleton</code> as well for the version in core to bind to</p>

<a name="189968912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189968912" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/61273bundlingsubgroupskernel.html#189968912">Mario Carneiro (Mar 07 2020 at 12:24)</a>:</h4>
<p>and then the <code>{a, ..., z}</code> notation expands to <code>insert a (insert b ... (singleton z))</code></p>

<a name="189969004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189969004" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/61273bundlingsubgroupskernel.html#189969004">Kevin Buzzard (Mar 07 2020 at 12:26)</a>:</h4>
<p>This would probably break a lot of stuff in a good way i.e. the fix would be "make it a bit simpler"</p>

<a name="189969006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189969006" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/61273bundlingsubgroupskernel.html#189969006">Kevin Buzzard (Mar 07 2020 at 12:26)</a>:</h4>
<p>and <code>mem_singleton</code> would be <code>rfl</code></p>

<a name="189969051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189969051" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/61273bundlingsubgroupskernel.html#189969051">Mario Carneiro (Mar 07 2020 at 12:28)</a>:</h4>
<p>it is very often that I am too lazy or golfy to go find the relevant theorem and given <code>a \in {b}</code> use <code>rcases h with rfl|&lt;&lt;&gt;&gt;</code> to get at the value. This idiom would get simpler</p>

<a name="189969331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189969331" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/61273bundlingsubgroupskernel.html#189969331">Kevin Buzzard (Mar 07 2020 at 12:38)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">set_option</span> <span class="n">pp</span><span class="bp">.</span><span class="kn">notation</span> <span class="n">false</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">t</span> <span class="err">∈</span> <span class="o">{</span><span class="n">s</span><span class="o">}</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">unfold</span> <span class="n">singleton</span><span class="o">,</span>
  <span class="c1">-- there&#39;s a metavariable in the goal?!</span>
  <span class="c">/-</span><span class="cm"></span>
<span class="cm">  ⊢ has_mem.mem t (has_insert.insert s (has_emptyc.emptyc ?m_1))</span>
<span class="cm">  -/</span>
  <span class="n">sorry</span>
<span class="kn">end</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">tactic failed, result contains meta-variables</span>
<span class="cm">state:</span>
<span class="cm">no goals</span>
<span class="cm">-/</span>
</pre></div>


<p>I was trying to work out what <code>t ∈ {s}</code> was defeq to and I think I broke something</p>

<a name="189969378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189969378" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/61273bundlingsubgroupskernel.html#189969378">Mario Carneiro (Mar 07 2020 at 12:40)</a>:</h4>
<p>Notice that both <code>{s} : set α</code> and <code>{s} : finset α</code> would be consistent with your theorem statement. I imagine that if you use <code>theorem T</code> instead of <code>example</code> you will get an error</p>

<a name="189969385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189969385" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/61273bundlingsubgroupskernel.html#189969385">Mario Carneiro (Mar 07 2020 at 12:41)</a>:</h4>
<p>it's because <code>insert</code> has type <code>A -&gt; B -&gt; B</code></p>

<a name="189969395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189969395" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/61273bundlingsubgroupskernel.html#189969395">Mario Carneiro (Mar 07 2020 at 12:41)</a>:</h4>
<p>and mem has type <code>A -&gt; B -&gt; Prop</code></p>

<a name="189969397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189969397" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/61273bundlingsubgroupskernel.html#189969397">Mario Carneiro (Mar 07 2020 at 12:41)</a>:</h4>
<p>so nothing there says what <code>B</code> is</p>

<a name="189969443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189969443" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/61273bundlingsubgroupskernel.html#189969443">Kevin Buzzard (Mar 07 2020 at 12:42)</a>:</h4>
<p>nice catch -- thanks.</p>

<a name="189969912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189969912" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/61273bundlingsubgroupskernel.html#189969912">Kevin Buzzard (Mar 07 2020 at 12:59)</a>:</h4>
<p>Just to confirm that <code>{s}</code> currently expands to <code>{b : α | b = s ∨ false}</code> -- I was going to say this in the first post but then I got distracted by the example/theorem thing</p>

<a name="189970605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189970605" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/61273bundlingsubgroupskernel.html#189970605">Kevin Buzzard (Mar 07 2020 at 13:23)</a>:</h4>
<p>I can't solve the analogous question for range though. If I use <code>set.univ</code> for top (which is {x | true}) and define <code>range</code> to be <code>map top</code> then <code>mem_range</code> (h is in the range iff there exists g with f(g) = h) isn't <code>rfl</code>, it's </p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span>
<span class="o">(</span><span class="bp">∃</span> <span class="n">a</span><span class="o">,</span> <span class="n">true</span> <span class="bp">∧</span> <span class="n">P</span> <span class="n">a</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">a</span><span class="o">,</span> <span class="n">P</span> <span class="n">a</span><span class="o">)</span>
</pre></div>


<p><code>library_search</code> couldn't find this in <code>logic.basic</code>.</p>

<a name="189970706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189970706" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/61273bundlingsubgroupskernel.html#189970706">Kevin Buzzard (Mar 07 2020 at 13:26)</a>:</h4>
<p>Indeed, for <code>set.range</code> they just define it directly so mem_range is rfl.</p>

<a name="189970828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189970828" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/61273bundlingsubgroupskernel.html#189970828">Kevin Buzzard (Mar 07 2020 at 13:31)</a>:</h4>
<p>Aah, <code>simp</code> does it.</p>

<a name="190138721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/190138721" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/61273bundlingsubgroupskernel.html#190138721">Yury G. Kudryashov (Mar 10 2020 at 03:03)</a>:</h4>
<p>Last time I checked <code>{a, b}</code> expanded to <code>insert b {a}</code>, not <code>insert a {b}</code>. I think, it would be nice to change this but my knowledge of lean notation syntax is not good enough.</p>

<a name="190140798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/190140798" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/61273bundlingsubgroupskernel.html#190140798">Mario Carneiro (Mar 10 2020 at 04:02)</a>:</h4>
<p>This is an easy change to core, although it will cause lots of breakage</p>

<a name="190140816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/190140816" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/61273bundlingsubgroupskernel.html#190140816">Mario Carneiro (Mar 10 2020 at 04:03)</a>:</h4>
<p>Oh! The notation for <code>{a, ..., z}</code> is actually never declared, it is lean magic</p>

<a name="190140823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/190140823" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/61273bundlingsubgroupskernel.html#190140823">Mario Carneiro (Mar 10 2020 at 04:03)</a>:</h4>
<p>so it would require changes to the C++</p>

<a name="190140874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/190140874" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/61273bundlingsubgroupskernel.html#190140874">Mario Carneiro (Mar 10 2020 at 04:05)</a>:</h4>
<p>in a way that's a good thing since I'm not sure it's possible to define <code>{} = empty</code> and <code>{a, b, c} = insert a (insert b (singleton c))</code> as proposed in another thread using the lean 3 <code>notation</code> syntax, which is quite limited</p>

<a name="190141114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/190141114" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/61273bundlingsubgroupskernel.html#190141114">Mario Carneiro (Mar 10 2020 at 04:13)</a>:</h4>
<p>Actually, it looks like lean already does the case distinction between empty and nonempty cases. Look what happens if I make my own prelude:</p>
<div class="codehilite"><pre><span></span><span class="n">prelude</span>

<span class="n">def</span> <span class="n">has_emptyc</span><span class="bp">.</span><span class="n">emptyc</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="n">def</span> <span class="n">singleton</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="n">def</span> <span class="n">has_insert</span><span class="bp">.</span><span class="n">insert</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">{}</span>  <span class="c1">-- has_emptyc.emptyc ?M_1 : ?M_1</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">{</span><span class="n">a</span><span class="o">}</span> <span class="c1">-- singleton a : Type</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">{</span><span class="n">a</span><span class="o">}</span> <span class="c1">-- singleton a : Type</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">{</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">}</span> <span class="c1">-- has_insert.insert b (singleton a) : singleton a</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">{</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">}</span> <span class="c1">-- has_insert.insert c (has_insert.insert b (singleton a)) : Type</span>
</pre></div>


<p>The built in notation parser doesn't actually know what the functions <code>has_insert.insert</code> and <code>singleton</code> are, it just writes these expressions down and hands them off to the elaborator. So really all that is necessary is to remove the definition of <code>singleton</code> and replace it with a typeclass to enable the <code>{0} = {x | x = 0}</code> defeq. However as you can see the order is still flipped; the C++ has to be changed to fix this</p>

<a name="190141180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/190141180" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/61273bundlingsubgroupskernel.html#190141180">Mario Carneiro (Mar 10 2020 at 04:15)</a>:</h4>
<p>(If you are wondering why <code>{a, ..., z}</code> is baked into lean like this, while <code>[a, ... z]</code> is not, it's because lean has to disambiguate the various notations that start with <code>{</code>, e.g. <code>{x // p x}</code>, <code>{x | p x}</code> and <code>{x, y}</code>, and this requires more lookahead than the normal notation parser can tolerate.)</p>


{% endraw %}

{% include archive_update.html %}