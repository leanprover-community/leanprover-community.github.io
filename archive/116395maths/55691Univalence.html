---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/116395maths/55691Univalence.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html">Univalence</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="190027207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190027207" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190027207">Bas Spitters (Mar 08 2020 at 20:40)</a>:</h4>
<p>I believe univalence can consistently be added to lean, since classical logic is valid in the simplicial set model<br>
(<a href="https://www.math.uwo.ca/faculty/kapulkin/notes/LEM_in_sSet.pdf" target="_blank" title="https://www.math.uwo.ca/faculty/kapulkin/notes/LEM_in_sSet.pdf">https://www.math.uwo.ca/faculty/kapulkin/notes/LEM_in_sSet.pdf</a>).<br>
Moreover, that model also interprets strict propositions.<br>
One would of course need to disable UIP for universes. Would that be possible?</p>

<a name="190027361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190027361" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190027361">Chris Hughes (Mar 08 2020 at 20:46)</a>:</h4>
<p>Have you seen <a href="https://github.com/gebner/hott3" target="_blank" title="https://github.com/gebner/hott3">https://github.com/gebner/hott3</a> ?</p>

<a name="190027386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190027386" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190027386">Kevin Buzzard (Mar 08 2020 at 20:46)</a>:</h4>
<p>I thought that the issue was that <code>bool = bool</code> was a singleton in Lean but <code>bool \equiv bool</code> was not.</p>

<a name="190027394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190027394" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190027394">Chris Hughes (Mar 08 2020 at 20:47)</a>:</h4>
<p>That's why you have to disable <code>Prop</code>, or at least large elimination from <code>Prop</code>s</p>

<a name="190027398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190027398" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190027398">Chris Hughes (Mar 08 2020 at 20:47)</a>:</h4>
<p>And redefine equality to be a <code>Type</code></p>

<a name="190027403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190027403" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190027403">Kevin Buzzard (Mar 08 2020 at 20:47)</a>:</h4>
<p>and this breaks all of mathlib immediately, right?</p>

<a name="190027405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190027405" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190027405">Chris Hughes (Mar 08 2020 at 20:47)</a>:</h4>
<p>Yes</p>

<a name="190027659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190027659" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190027659">Kevin Buzzard (Mar 08 2020 at 20:56)</a>:</h4>
<p>and also it means that it would be much harder to make it all again, because the cool tricks we can get away with because any two terms of type P : Prop are equal won't work any more, so it might not even be possible to make parts of mathlib again if we have univalence.</p>

<a name="190030722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190030722" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190030722">Reid Barton (Mar 08 2020 at 22:33)</a>:</h4>
<p>I understand why equality can't be a Prop but once that is changed I don't understand why Prop itself causes any problems.</p>

<a name="190030917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190030917" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190030917">Mario Carneiro (Mar 08 2020 at 22:38)</a>:</h4>
<p>If <code>eq : A -&gt; A -&gt; Prop</code> exists then you can prove that <code>eq' : A -&gt; A -&gt; Type</code> is equivalent to it and hence also satisfies UIP</p>

<a name="190030918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190030918" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190030918">Chris Hughes (Mar 08 2020 at 22:38)</a>:</h4>
<p>Because this is inconsistent right?</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">eq2</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">refl</span> <span class="o">:</span> <span class="n">eq2</span> <span class="n">a</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h₁</span> <span class="n">h₂</span> <span class="o">:</span> <span class="n">eq2</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">eq2</span> <span class="n">h₁</span> <span class="n">h₂</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">cases</span> <span class="n">h₁</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">h₂</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">eq2</span><span class="bp">.</span><span class="n">refl</span>  <span class="bp">_</span>
</pre></div>

<a name="190030928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190030928" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190030928">Mario Carneiro (Mar 08 2020 at 22:39)</a>:</h4>
<p>which is basically what Chris's proof does, because <code>cases</code> is implicitly using <code>eq</code></p>

<a name="190031311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190031311" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190031311">Reid Barton (Mar 08 2020 at 22:51)</a>:</h4>
<p>I was going to say maybe this just means you need to adjust the rules for large elimination of Props to not allow smuggling in eq, but possibly that eliminates all interesting uses?</p>

<a name="190031324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190031324" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190031324">Mario Carneiro (Mar 08 2020 at 22:51)</a>:</h4>
<p>If prop looked like type there wouldn't be any issues</p>

<a name="190031367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190031367" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190031367">Reid Barton (Mar 08 2020 at 22:52)</a>:</h4>
<p>Well then it might as well not exist, right?</p>

<a name="190031376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190031376" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190031376">Mario Carneiro (Mar 08 2020 at 22:53)</a>:</h4>
<p>I am not sure if the impredicativity is also bad but if you don't have UIP in prop then I think it would be bad</p>

<a name="190031378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190031378" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190031378">Reid Barton (Mar 08 2020 at 22:53)</a>:</h4>
<p>I guess the question is how much stuff can you put into a definitionally proof-irrelevant Prop while remaining consistent with univalence, and is that amount enough to be useful</p>

<a name="190031422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190031422" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190031422">Mario Carneiro (Mar 08 2020 at 22:54)</a>:</h4>
<p>You could remove all large elimination. just have all inductive types act like <code>exists</code></p>

<a name="190031426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190031426" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190031426">Mario Carneiro (Mar 08 2020 at 22:54)</a>:</h4>
<p>then Prop becomes a one-way path so it can't cause problems... I hope</p>

<a name="190031431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190031431" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190031431">Reid Barton (Mar 08 2020 at 22:55)</a>:</h4>
<p>Right, I should go back to: how permissive can the large elimination rules be</p>

<a name="190031435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190031435" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190031435">Reid Barton (Mar 08 2020 at 22:55)</a>:</h4>
<p>E.g. I imagine that large elimination for <code>true</code> is ok</p>

<a name="190031438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190031438" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190031438">Reid Barton (Mar 08 2020 at 22:55)</a>:</h4>
<p>But it's also not that exciting</p>

<a name="190031441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190031441" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190031441">Mario Carneiro (Mar 08 2020 at 22:55)</a>:</h4>
<p>Some large elimination principles are provable without assuming them, like <code>and</code></p>

<a name="190031468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190031468" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190031468">Reid Barton (Mar 08 2020 at 22:56)</a>:</h4>
<p>There's surely going to be issues with propext next, I guess</p>

<a name="190031483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190031483" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190031483">Mario Carneiro (Mar 08 2020 at 22:56)</a>:</h4>
<p>but those are basically the only okay ones</p>

<a name="190031536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190031536" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190031536">Reid Barton (Mar 08 2020 at 22:58)</a>:</h4>
<p>Oh maybe there is no issue with propext as long as its type itself doesn't have large elimination</p>

<a name="190031542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190031542" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190031542">Mario Carneiro (Mar 08 2020 at 22:58)</a>:</h4>
<p>propext is actually univalence for propositions</p>

<a name="190031735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190031735" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190031735">Reid Barton (Mar 08 2020 at 23:03)</a>:</h4>
<p>Ok, I think what I was imagining is not a real issue</p>

<a name="190031834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190031834" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190031834">Reid Barton (Mar 08 2020 at 23:06)</a>:</h4>
<p>I guess if you can track the h-levels of types syntactically then you can also allow large elimination when appropriate. Is this what Arend does?</p>

<a name="190031839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190031839" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190031839">Reid Barton (Mar 08 2020 at 23:06)</a>:</h4>
<p>Hmm this isn't very obvious actually</p>

<a name="190032414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190032414" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190032414">Kevin Buzzard (Mar 08 2020 at 23:27)</a>:</h4>
<p>This theorising is all well and good but you seem to be saying "if lean's core logic is changed a bit then it would be interesting to see what still works" and I'm merely pointing out that it might be much much harder to develop a proper maths library, which is my impression of what happens the moment you go univalent: you can compute homotopy types of synthetic spheres and then the only thing you can do is higher topos theory</p>

<a name="190032456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190032456" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190032456">Kevin Buzzard (Mar 08 2020 at 23:28)</a>:</h4>
<p>Because you can't use <code>cases</code> any more</p>

<a name="190033516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190033516" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190033516">Mario Carneiro (Mar 09 2020 at 00:06)</a>:</h4>
<p>in principle, lean tactics could be modified to be less HoTT-unfriendly. In practice, the people who are capable of doing a good job of it are not interested</p>

<a name="190049505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190049505" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190049505">Bas Spitters (Mar 09 2020 at 08:50)</a>:</h4>
<p><span class="user-mention" data-user-id="110044">@Chris Hughes</span> Thanks. Does one still have classical logic?<br>
Instead of singleton elimination, I guess one wants this: <span class="user-mention" data-user-id="243878">@Gaëtan Gilbert</span> is also involved in that.<br>
<a href="https://jesper.sikanda.be/files/definitional-proof-irrelevance-without-K.pdf" target="_blank" title="https://jesper.sikanda.be/files/definitional-proof-irrelevance-without-K.pdf">https://jesper.sikanda.be/files/definitional-proof-irrelevance-without-K.pdf</a></p>

<a name="190049784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190049784" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190049784">Bas Spitters (Mar 09 2020 at 08:56)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> Most of basic maths happens at the lowest type level, so things wouldn't change much. Only the first universe becomes a groupoid, the second a 2-groupoid, etc.<br>
One would notice it when formalizing presheaves, and there I would expect it to be the more natural thing to do. Unless one is "evil":<br>
<a href="https://ncatlab.org/nlab/show/principle+of+equivalence" target="_blank" title="https://ncatlab.org/nlab/show/principle+of+equivalence">https://ncatlab.org/nlab/show/principle+of+equivalence</a></p>

<a name="190051752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190051752" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190051752">Kevin Buzzard (Mar 09 2020 at 09:28)</a>:</h4>
<p>Presheaves are just a fancy word for functors and I'm sure there will be no problems with functors in a HoTT theory. I want to go much further than this. I want to see the proof that the presheaf of rings on an affine scheme is a sheaf, ie not just a definition of presheaves but a proof that they can be used. This took a team of complete amateurs a few months in Lean -- we were all mathematicians who knew nothing about computer proof systems or type theory one year earlier. I genuinely don't know whether the reason this isn't done in any computer HoTT system is because the systems aren't capable or because there just isn't anyone interested in doing it. I believe that there are classical hypotheses everywhere in the argument.</p>

<a name="190052297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190052297" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190052297">Kevin Buzzard (Mar 09 2020 at 09:37)</a>:</h4>
<p>The reason I am banging on about this is that if your original assertion is supposed to imply that adding univalence does not in theory break anything, then I am pointing at an explicit piece of MSc level mathematics whose proof will be completely broken by it and am trying to ask the question "is there any evidence that it can actually be fixed in practice?". I am arguing that it took a team of amateurs a few months to make this proof in Lean in their spare time, so it does not seem like an unreasonable practical challenge. In my mind, one of the main things lean has going for it is a whole bunch of examples of mathematics at MSc level and above being done with relative ease by the community -- a proof that the proof assistant is usable in practice to do "fashionable mathematics".</p>
<p>However this might well be a long way from the point you were trying to make originally and so I'll now stop banging on about this on this thread. Sorry to derail. </p>
<p>I think Chris' original comment on Gabriel's work on HoTT in Lean 3 is the place to start. Both he and Floris van Doorn are experts in doing HoTT in Lean, but currently I don't think either of them are doing any, and perhaps this is only because the community is not there yet.</p>

<a name="190052547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190052547" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190052547">Kevin Buzzard (Mar 09 2020 at 09:41)</a>:</h4>
<p>I could envisage someone setting an undergraduate project on doing some HoTT formalisation in Lean using Gabriel's library and then a stream being set up here for HoTT In Lean and one could just see how easy it is to do mathematics in practice in this mode. It would definitely be an interesting and worthwhile project. One could imagine the UniMath library and the HoTT book as being useful resources and one could ask whether this Lean framework is easier to use than the corresponding Coq framework</p>

<a name="190054327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190054327" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190054327">Bas Spitters (Mar 09 2020 at 10:08)</a>:</h4>
<p>Of course, I would start from the HoTT library, not UniMath. It is better engineered and doesn't have the imho arbitrary restriction on the use of e.g. record types.<br>
<a href="https://github.com/HoTT/HoTT" target="_blank" title="https://github.com/HoTT/HoTT">https://github.com/HoTT/HoTT</a></p>

<a name="190056901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190056901" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190056901">Kevin Buzzard (Mar 09 2020 at 10:45)</a>:</h4>
<p>Thanks for reminding me of this library! I see that it is actively growing too :D People are currently thinking about groups, judging by recent commits. Can you state Sylow's theorems? Can you prove them?</p>
<p>To give you some sort of data point for comparison, when I arrived at Lean they had in their maths library a theory of groups, rings and topological spaces, and a good theory of finite sets. They had the naturals, integers, rationals and reals, and perhaps not too much more of interest to a "working mathematician" (although my memory might be inaccurate). This was definitely enough to get me interested though. Within a year Chris Hughes had proved Sylow's theorems, and he was a 1st year undergraduate mathematician with training in computer proof systems; Kenny Lau had set up a theory of localisation of rings, and he was also a 1st year undergraduate mathematician with no prior training in computer proof systems, and the three of us had proved this result about schemes. The reason I'm mentioning it is that one could ask what the "bare minimum"is that one needs to get mathematicians involved. And in my experience it's undergraduate mathematicians you can start with, especially when you say to them "hey there's this cool system and there's a whole bunch of undergraduate level maths in it which you can do and which we need". </p>
<p>Are you considering the possibility of porting this library to Lean? Is that the question you're really asking -- whether the logics of the systems are sufficiently compatible?</p>

<a name="190057399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190057399" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190057399">Chris Hughes (Mar 09 2020 at 10:52)</a>:</h4>
<p>Impredicativity isn't compatible with HoTT right? This is something that seems quite important to do normal maths.</p>

<a name="190058144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190058144" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190058144">Mario Carneiro (Mar 09 2020 at 11:03)</a>:</h4>
<p>Actually, impredicativity can be done in HoTT but it doesn't look the same. There is a well known result that says that two impredicative universes is inconsistent, and one impredicative universe is System F which does not have the "standard semantics" we like to have for function types and such. In the standard HoTT foundations you can define what it means for a type to be a proposition, but you end up with a subset of the universe at each level that are propositions, and there may be "more propositions" at the higher levels; this is what we mean by predicativity.</p>
<p>In order to reflect these propositions down to the lowest level to get something more impredicative, there is Voevodsky's "universe resizing" rule. IIRC it says that if <code>A : Type u</code> and <code>is_prop A</code> (which we would render as <code>subsingleton A</code>), then there exists <code>A' : Type 0</code> such that <code>equiv A A'</code> (and a forteriori <code>is_prop A'</code> as well).</p>

<a name="190058447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190058447" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190058447">Mario Carneiro (Mar 09 2020 at 11:07)</a>:</h4>
<p>In classical logic, this is trivial, because every proposition is either true or false and both true and false can be found in the lowest universe.</p>

<a name="190058840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190058840" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190058840">Bas Spitters (Mar 09 2020 at 11:12)</a>:</h4>
<p><span class="user-mention" data-user-id="110044">@Chris Hughes</span> <br>
Impredicativity is called the resizing axiom in the HoTT book. It holds in most (classical) models of HoTT, e.g. simplicial sets.</p>

<a name="190059013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190059013" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190059013">Mario Carneiro (Mar 09 2020 at 11:15)</a>:</h4>
<p>But it is an axiom, yes? This by contrast to the way lean's impredicativity works, by a different typing rule for the Pi</p>

<a name="190059015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190059015" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190059015">Bas Spitters (Mar 09 2020 at 11:15)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> In the simplicial set model, the hProps are not the booleans, so the issue is somewhat more subtle:<br>
Any contractible type is equivalent to a point (e.g. the unit type in the lowest universe)</p>

<a name="190059083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190059083" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190059083">Mario Carneiro (Mar 09 2020 at 11:16)</a>:</h4>
<p>I suspect that Kevin et al really want the hProps to be equivalent to bool</p>

<a name="190059192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190059192" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190059192">Bas Spitters (Mar 09 2020 at 11:18)</a>:</h4>
<p>One could use strict propositions for that, as developed by <span class="user-mention" data-user-id="243878">@Gaëtan Gilbert</span> in Coq</p>

<a name="190059326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190059326" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190059326">Mario Carneiro (Mar 09 2020 at 11:20)</a>:</h4>
<p>is there a motivating example for why hProp can't be bool, in a classical HoTT model?</p>

<a name="190059371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190059371" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190059371">Mario Carneiro (Mar 09 2020 at 11:21)</a>:</h4>
<p>I would have thought equality would be an example but it's not even an hProp unless the type is a hSet</p>

<a name="190059487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190059487" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190059487">Mario Carneiro (Mar 09 2020 at 11:23)</a>:</h4>
<p>I'm not really sure how strict propositions (by which I assume you mean Coq's SProp) differs from lean's Prop, and in particular what they do to avoid the exact same constructions shown by Chris above that trivialize the equality relation</p>

<a name="190060309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190060309" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190060309">Bas Spitters (Mar 09 2020 at 11:38)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> <span class="user-mention" data-user-id="110044">@Chris Hughes</span>  Indeed, with classical logic, hProp ~ bool. Cor 4 of:<br>
<a href="https://www.math.uwo.ca/faculty/kapulkin/notes/LEM_in_sSet.pdf" target="_blank" title="https://www.math.uwo.ca/faculty/kapulkin/notes/LEM_in_sSet.pdf">https://www.math.uwo.ca/faculty/kapulkin/notes/LEM_in_sSet.pdf</a></p>

<a name="190060582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190060582" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190060582">Johan Commelin (Mar 09 2020 at 11:44)</a>:</h4>
<p><span class="user-mention" data-user-id="259452">@Bas Spitters</span> Does this mean that we can assume all types (or at least all types <code>X</code> with <code>is_Set X</code>) are either empty or have a term?</p>

<a name="190063579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190063579" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190063579">Bas Spitters (Mar 09 2020 at 12:34)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> Yes, that should be provable. Assuming classical logic and choice, hSets form a model of Lawvere's structural set theory.</p>

<a name="190063618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190063618" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190063618">Johan Commelin (Mar 09 2020 at 12:35)</a>:</h4>
<p>Maybe with the new tooling it becomes easier to switch back and forth between mathlib and the hott3 project...</p>

<a name="190063622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190063622" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190063622">Johan Commelin (Mar 09 2020 at 12:35)</a>:</h4>
<p>I wouldn't mind playing with it.</p>

<a name="190063720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190063720" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190063720">Bas Spitters (Mar 09 2020 at 12:37)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Consider a huge type what paths between all terms. This is contractible, so an hprop, but this is obviously not a boolean.</p>

<a name="190063746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190063746" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190063746">Mario Carneiro (Mar 09 2020 at 12:37)</a>:</h4>
<p>isn't it equivalent to true?</p>

<a name="190063777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190063777" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190063777">Mario Carneiro (Mar 09 2020 at 12:37)</a>:</h4>
<p>what makes it "huge"?</p>

<a name="190063844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190063844" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190063844">Mario Carneiro (Mar 09 2020 at 12:38)</a>:</h4>
<p>or are you saying it has higher structure like loops or something</p>

<a name="190064048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190064048" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190064048">Bas Spitters (Mar 09 2020 at 12:42)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> We can also consider the universe of strict sets. Here is a constructive development, which will not be easy to read, but may give an idea of the type theory.<br>
<a href="http://www.cse.chalmers.se/~coquand/bishop.pdf" target="_blank" title="http://www.cse.chalmers.se/~coquand/bishop.pdf">http://www.cse.chalmers.se/~coquand/bishop.pdf</a></p>

<a name="190064117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190064117" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190064117">Johan Commelin (Mar 09 2020 at 12:43)</a>:</h4>
<p>What is the difference between an hSet and a strict set?</p>

<a name="190064223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190064223" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190064223">Mario Carneiro (Mar 09 2020 at 12:45)</a>:</h4>
<p>two equalities of fixed values in a strict set are defeq</p>

<a name="190064233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190064233" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190064233">Mario Carneiro (Mar 09 2020 at 12:45)</a>:</h4>
<p>in other words, lean types</p>

<a name="190064355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190064355" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190064355">Johan Commelin (Mar 09 2020 at 12:46)</a>:</h4>
<p>Aha... but can you have those in a HoTT system?</p>

<a name="190064390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190064390" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190064390">Mario Carneiro (Mar 09 2020 at 12:47)</a>:</h4>
<p>that is based on skimming Bas's link</p>

<a name="190064420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190064420" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190064420">Mario Carneiro (Mar 09 2020 at 12:47)</a>:</h4>
<p>I don't think that type theory is classical, although probably you can just throw that in</p>

<a name="190064517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190064517" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190064517">Mario Carneiro (Mar 09 2020 at 12:49)</a>:</h4>
<p>but the upshot of all this is still not clear to me. It sounds like you are offering most of the features lean has already. What are we giving up? Clearly something has to give since univalence in lean is disprovable</p>

<a name="190064721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190064721" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190064721">Mario Carneiro (Mar 09 2020 at 12:52)</a>:</h4>
<p>the stuff about simplicial sets or cubical set models is not relevant for the lean user, since we are working <em>in</em> the theory not <em>on</em> the theory. (Formalizing type theories would be a worthy project but quite independent of tweaks to lean foundations.)</p>

<a name="190072108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190072108" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190072108">Bas Spitters (Mar 09 2020 at 14:08)</a>:</h4>
<p>One would have a type theory with two kinds of propositions, strict ones and hProps.<br>
set level mathematics should go through at the bottom universe, but the other universes can be univalent.<br>
So one would need to give up UIP for the higher universes.</p>

<a name="190134462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190134462" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190134462">Mario Carneiro (Mar 10 2020 at 01:12)</a>:</h4>
<p>Wait, so the lowest universe is not univalent in this scheme? Isn't that where all the interesting maths would go? For example, I guess one desideratum would be to have <code>real = real x {0}</code> be provable, as well as similar statements for the corresponding elements of a fully bundled type <code>Ring := Sigma (A : Type 0) (mul : A -&gt; A -&gt; A), ...</code>. As I understand it this is the main selling point of having univalence around, but these objects are h-sets, possibly strict sets if you prefer, and live in the bottom universe. (<code>Ring</code> lives in the next universe but equality of rings, which should mean ring isomorphism, depends on equality in <code>Type 0</code>, and so needs the bottom universe to be univalent.)</p>

<a name="190134631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190134631" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190134631">Mario Carneiro (Mar 10 2020 at 01:16)</a>:</h4>
<p>While UIP is tremendously convenient, it doesn't actually enable any particular kind of maths, as long as you can obtain the (non-judgmental) equality by other means. It would still require a lot of engineering effort to recover the same level of ease of use that you get with UIP, but at least in principle I can see giving it up provided that things like the resizing axiom are around to allow us to do long well founded recursions and such.</p>

<a name="190134746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190134746" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190134746">Reid Barton (Mar 10 2020 at 01:19)</a>:</h4>
<p>I think <code>@eq A a b</code> is a Prop if <code>A : Type 0</code>. That doesn't prevent <code>Type</code> itself from satisfying univalence</p>

<a name="190492274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190492274" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190492274">Bas Spitters (Mar 13 2020 at 11:24)</a>:</h4>
<p>We could have a universe of strict sets, and a universe of hSets living side by side.<br>
<span class="user-mention" data-user-id="243878">@Gaëtan Gilbert</span> has been working on the type theory for this. Some things will simplify in the classical model of simplicial sets, but I'm not sure anyone has gone through the details. It will be a simplification of Thierry's note.</p>

<a name="190492409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190492409" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190492409">Johan Commelin (Mar 13 2020 at 11:26)</a>:</h4>
<p>What would "living side by side" mean in practice? Would it be easy to transport data and properties from one side to the other? Or would the gap be about as big as the gap between two different libraries right now (e.g., mathcomp and mathlib)?</p>

<a name="190492425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190492425" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190492425">Bas Spitters (Mar 13 2020 at 11:26)</a>:</h4>
<p>This paper discusses a decade long research program on implementing transfer in proof assistants (Coq, Isabelle,...)<br>
The Marriage of Univalence and Parametricity<br>
<a href="https://arxiv.org/abs/1909.05027" target="_blank" title="https://arxiv.org/abs/1909.05027">https://arxiv.org/abs/1909.05027</a><br>
and claims that the approach using HoTT is most convenient. It would be interesting to know whether there are any initiatives to implement transfer in lean.</p>

<a name="190492489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190492489" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190492489">Johan Commelin (Mar 13 2020 at 11:27)</a>:</h4>
<p><span class="user-mention" data-user-id="110193">@Cyril Cohen</span> has been working on this about a year ago.</p>

<a name="190492540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190492540" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190492540">Bas Spitters (Mar 13 2020 at 11:28)</a>:</h4>
<p>Reference?</p>

<a name="190492541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190492541" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190492541">Johan Commelin (Mar 13 2020 at 11:28)</a>:</h4>
<p>But so far we don't have any usable tools.</p>

<a name="190492576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190492576" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190492576">Johan Commelin (Mar 13 2020 at 11:28)</a>:</h4>
<p><a href="https://github.com/CohenCyril/mathlib/commits/param" target="_blank" title="https://github.com/CohenCyril/mathlib/commits/param">https://github.com/CohenCyril/mathlib/commits/param</a></p>

<a name="190492846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190492846" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190492846">Bas Spitters (Mar 13 2020 at 11:32)</a>:</h4>
<p>I guess that is the CoqEAL approach? Has it been proved to work with classical logic? I don't recall seeing that result explicitly.</p>

<a name="190493069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190493069" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190493069">Johan Commelin (Mar 13 2020 at 11:35)</a>:</h4>
<p>I really don't know.</p>

<a name="190493079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190493079" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190493079">Johan Commelin (Mar 13 2020 at 11:35)</a>:</h4>
<p>This is stuff that I never thought about as a mathematician</p>

<a name="190493093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190493093" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190493093">Johan Commelin (Mar 13 2020 at 11:35)</a>:</h4>
<p>It's just an extremely annoying problem that you discover once you start using ITP's</p>

<a name="190493172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190493172" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190493172">Bas Spitters (Mar 13 2020 at 11:36)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> I don't think the type theory has been worked out. It would be somewhat like the interaction of sProp and Prop in Coq and agda.<br>
Semantically, we can check what is going on by looking at the classical groupoid model.</p>

<a name="190493309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190493309" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190493309">Bas Spitters (Mar 13 2020 at 11:38)</a>:</h4>
<p>Strange, I would imagine you would know about Artin gluing<br>
<a href="https://drops.dagstuhl.de/opus/volltexte/2019/10532/pdf/LIPIcs-FSCD-2019-25.pdf" target="_blank" title="https://drops.dagstuhl.de/opus/volltexte/2019/10532/pdf/LIPIcs-FSCD-2019-25.pdf">https://drops.dagstuhl.de/opus/volltexte/2019/10532/pdf/LIPIcs-FSCD-2019-25.pdf</a></p>

<a name="190493332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190493332" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190493332">Johan Commelin (Mar 13 2020 at 11:39)</a>:</h4>
<p>I think it would be very helpful if some HoTT library would demonstrate that it's useful for maths that doesn't look like homotopy theory. It doesn't have to be perfectoid spaces. But something like the Hilbert basis theorem, or even better fundamental theorem of calculus. Those are low-level from a maths point of view, but my impression is that they are currently challenging for HoTT libs.</p>

<a name="190493335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190493335" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190493335">Johan Commelin (Mar 13 2020 at 11:39)</a>:</h4>
<p>Hmmm... let me check that link</p>

<a name="190493446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190493446" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190493446">Bas Spitters (Mar 13 2020 at 11:40)</a>:</h4>
<p>Unary, binary and machine integers low level enough for you :-)<br>
That's the examples they look at in the univalent parametricity paper.</p>

<a name="190493458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190493458" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190493458">Johan Commelin (Mar 13 2020 at 11:41)</a>:</h4>
<p><span class="user-mention" data-user-id="259452">@Bas Spitters</span> Ok, I've heard of things like gluing sheaves or topoi, or what not. But (for a simple mathematician) it's not clear how that helps us with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> are isomorphic semirings, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> is a noetherian integral domain, hence <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> is as well.</p>

<a name="190493486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190493486" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190493486">Johan Commelin (Mar 13 2020 at 11:41)</a>:</h4>
<p>And mathematicians completely don't know what you need to do to prove such a statement. They only know a 1-word proof: "Obvious".</p>

<a name="190493566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190493566" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190493566">Johan Commelin (Mar 13 2020 at 11:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="259452">Bas Spitters</span> <a href="#narrow/stream/116395-maths/topic/Univalence/near/190493446" title="#narrow/stream/116395-maths/topic/Univalence/near/190493446">said</a>:</p>
<blockquote>
<p>Unary, binary and machine integers low level enough for you :-)<br>
That's the examples they look at in the univalent parametricity paper.</p>
</blockquote>
<p>No, that won't do. We need to know that the maths that appears in bachelor courses is at least as easy in HoTT as it is in DTT like Lean.</p>

<a name="190493580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190493580" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190493580">Bas Spitters (Mar 13 2020 at 11:42)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> There was a smiley missing in my last comment. I just wanted to point out that the "annoying problem" actually hides beautiful maths that you know well.</p>

<a name="190493597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190493597" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190493597">Johan Commelin (Mar 13 2020 at 11:43)</a>:</h4>
<p>So it has to be some calculus or commutative algebra or something. Binary integers are too low level.</p>

<a name="190493642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190493642" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190493642">Johan Commelin (Mar 13 2020 at 11:43)</a>:</h4>
<p>Sure... but I'm talking about the public relations / advertisement side of things. To get things rolling you need an eye-catching result.</p>

<a name="190493926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190493926" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190493926">Bas Spitters (Mar 13 2020 at 11:47)</a>:</h4>
<p>Here are some examples from algebra:<br>
<a href="http://www.cse.chalmers.se/~nad/publications/coquand-danielsson-isomorphism-is-equality.pdf" target="_blank" title="http://www.cse.chalmers.se/~nad/publications/coquand-danielsson-isomorphism-is-equality.pdf">http://www.cse.chalmers.se/~nad/publications/coquand-danielsson-isomorphism-is-equality.pdf</a><br>
We are currently working on a formalization of universal algebra in HoTT. The isomorphism theorems become "identification theorems".</p>

<a name="190495413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190495413" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190495413">Kevin Buzzard (Mar 13 2020 at 12:08)</a>:</h4>
<p>This is not what is taught in 1st year undergraduate classes. What Johan and I are trying to say is this: if HoTT is supposed to be able to do mathematics, let's see some mathematics which are taught in standard undergraduate mathematics classes. Where is quadratic reciprocity in any HoTT theory? The proof of this is not straightforward. You need a robust theory of finite sets. You need to be able to count. Where is the proof of Lagrange's theorem? Where is "normal mathematics"? machine integers and universal algebra etc are exactly what we are <em>not</em> talking about.</p>

<a name="190495566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190495566" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190495566">Kevin Buzzard (Mar 13 2020 at 12:10)</a>:</h4>
<p>Navel-gazing about equality is something else which is not done at all in a mathematics department, away from esoteric coursees.</p>

<a name="190497429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190497429" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190497429">Bas Spitters (Mar 13 2020 at 12:36)</a>:</h4>
<p>We may be talking past eachother, but I am saying that in HoTT we can prove <span class="user-mention" data-user-id="112680">@Johan Commelin</span> s statement about integral domains by univalent transfer. Since, A and B are ismorphic algebraic structures, the record types are equal, and hence we can transport the property of being a noetherian integral domain.</p>

<a name="190497662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190497662" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190497662">Johan Commelin (Mar 13 2020 at 12:39)</a>:</h4>
<p>Exactly! And that is why HoTT is so enticing!</p>

<a name="190497686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190497686" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190497686">Johan Commelin (Mar 13 2020 at 12:39)</a>:</h4>
<p>But if that is the "only" thing it can do... it's no good (of course I'm exagerating with "only").</p>

<a name="190497765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190497765" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190497765">Johan Commelin (Mar 13 2020 at 12:40)</a>:</h4>
<p>We need a system that gives us a powerful transfer. But we also need a system that gives us quadratic reciprocity, fund.thm.calc., lagrange, hilbert basis, and all the rest.</p>

<a name="190497820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190497820" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190497820">Johan Commelin (Mar 13 2020 at 12:41)</a>:</h4>
<p>So far we have all the classical (not in the logic sense, but in temporal sense) systems that struggle with transfer, and we have HoTT which doesn't.<br>
But HoTT isn't proving that you can do the "classical" theorems of mathematics in it.</p>

<a name="190497873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190497873" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190497873">Johan Commelin (Mar 13 2020 at 12:42)</a>:</h4>
<p>Universal algebra is nice. But can it be applied?</p>

<a name="190497920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190497920" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190497920">Johan Commelin (Mar 13 2020 at 12:42)</a>:</h4>
<p>If you can give me a formalisation of quadratic reciprocity as a 10 line consequence of universal algebra. Sure, then I will be very excited about the universal algebra library.</p>

<a name="190497934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190497934" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190497934">Johan Commelin (Mar 13 2020 at 12:43)</a>:</h4>
<p>Especially if the fundamental theorem of calculus is another 30-line consequence</p>

<a name="190497942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190497942" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190497942">Johan Commelin (Mar 13 2020 at 12:43)</a>:</h4>
<p>But I doubt that that is true.</p>

<a name="190497952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190497952" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190497952">Johan Commelin (Mar 13 2020 at 12:43)</a>:</h4>
<p>To use some categorical language: we want the pushout of HoTT and mathlib.</p>

<a name="190498165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190498165" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190498165">Johan Commelin (Mar 13 2020 at 12:46)</a>:</h4>
<p>We need another paper "The marriage of univalence and material set theory".</p>

<a name="190498186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190498186" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190498186">Bas Spitters (Mar 13 2020 at 12:47)</a>:</h4>
<p>I am aware universal algebra is close to logic/CS. I.e. it's use in effectful computation.<br>
My PhD-student Andreas has been working on integrating math-comp and HoTT.<br>
This is currently stuck on universe polymorphism:<br>
<a href="https://github.com/coq/coq/issues/10513" target="_blank" title="https://github.com/coq/coq/issues/10513">https://github.com/coq/coq/issues/10513</a><br>
Perhaps Coq is trying to be too clever, and the more conservative approach of lean would work better. Also, there is less legacy code in lean.</p>

<a name="190498546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190498546" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190498546">Bas Spitters (Mar 13 2020 at 12:50)</a>:</h4>
<p>Theorem 10.1.15 of the HoTT book: <br>
 If the axiom of choice holds then the category Set is a well-pointed boolean elementary topos with choice.</p>
<p>This is called Lawver set theory. What else do you want from set theory?</p>

<a name="190498838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190498838" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190498838">Johan Commelin (Mar 13 2020 at 12:54)</a>:</h4>
<p>I think that's good. That's good enough for the theoretical foundations. What we need to see is that it's usable in practice.</p>

<a name="190498894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190498894" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190498894">Johan Commelin (Mar 13 2020 at 12:55)</a>:</h4>
<p>How many lines of code does mathlib use to prove quadratic reciprocity? (I dunno, but we can find out.)<br>
Can we do a 1-1 translation to HoTT?</p>

<a name="190498919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190498919" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190498919">Johan Commelin (Mar 13 2020 at 12:55)</a>:</h4>
<p>If not 1-to-1, what is the factor that proofs scale by? Should we expect less lines of code, or more?</p>

<a name="190498976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190498976" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190498976">Johan Commelin (Mar 13 2020 at 12:56)</a>:</h4>
<p>That's the kind of question that Kevin and I are interested in.</p>

<a name="190499039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190499039" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190499039">Johan Commelin (Mar 13 2020 at 12:57)</a>:</h4>
<p>Of course we could try to figure this out ourselves. But we are also wondering why HoTT experts are not figuring this out.</p>

<a name="190499090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190499090" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190499090">Johan Commelin (Mar 13 2020 at 12:57)</a>:</h4>
<p>(Also, unfortunately I need to spend lots of time on paper maths projects, and diving into developing a theory of finite sets in HoTT would not make my boss happy.)</p>

<a name="190499556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190499556" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190499556">Sebastien Gouezel (Mar 13 2020 at 13:02)</a>:</h4>
<p>I have the following analogy. It is consistent with ZF to assume that every set of the real line is measurable. Then, one can add this axiom, and do all measure theory in an extremely nice way (much nicer than what is usually done because you won't need to check measurability any time). Except that then you can not integrate this measure theory library with other traditional parts of maths that require choice (for instance the existence of the algebraic closure), as assuming measurability of everything is contradictory with choice. In this situation, it seems to me that doing measure theory in this way would be cheating, and mostly useless to build a whole library of mathematics.</p>
<p>As to whether this is a good analogy with HOTT, I won't say anything, because I don't understand anything to HOTT.</p>

<a name="190499786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190499786" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190499786">Bas Spitters (Mar 13 2020 at 13:05)</a>:</h4>
<p>Unless, I am overlooking something, lean is already consistent with HoTT under this translation (which uses --indices-matter)( <span class="user-mention" data-user-id="243878">@Gaëtan Gilbert</span> ?)<br>
<a href="https://coq.discourse.group/t/alpha-announcement-coq-is-a-lean-typechecker/581" target="_blank" title="https://coq.discourse.group/t/alpha-announcement-coq-is-a-lean-typechecker/581">https://coq.discourse.group/t/alpha-announcement-coq-is-a-lean-typechecker/581</a><br>
Of course, that does not directly give univalence, but it embeds lean in the strict propositions that we discussed before.</p>

<a name="190499904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190499904" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190499904">Mario Carneiro (Mar 13 2020 at 13:06)</a>:</h4>
<p>Yes but Coq isn't HoTT, it's some poorly defined union of a bunch of type theory extensions</p>

<a name="190499997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190499997" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190499997">Bas Spitters (Mar 13 2020 at 13:07)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Coq implements pcuic. What do you mean?</p>

<a name="190500077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190500077" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190500077">Mario Carneiro (Mar 13 2020 at 13:08)</a>:</h4>
<p>Coq doesn't "just" implement pcuic, it has extra stuff</p>

<a name="190500109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190500109" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190500109">Mario Carneiro (Mar 13 2020 at 13:08)</a>:</h4>
<p>I have literally never seen a definition of Coq that didn't finish "oh and there's also some other stuff we won't go into here"</p>

<a name="190500444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190500444" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190500444">Mario Carneiro (Mar 13 2020 at 13:11)</a>:</h4>
<p>I'm not 100% positive I know what the exact theory you are calling PCUIC is (usually people call "that thing Coq implements" CIC instead) but I think that SProp is not mentioned in it</p>

<a name="190500717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190500717" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190500717">Gaëtan Gilbert (Mar 13 2020 at 13:14)</a>:</h4>
<blockquote>
<p>Unless, I am overlooking something, lean is already consistent with HoTT under this translation (which uses --indices-matter)( @Gaëtan Gilbert ?)</p>
</blockquote>
<p>I'm pretty sure the translation breaks when using -indices-matter<br>
Lean can't be consistent with HoTT since Lean has UIP</p>

<a name="190500791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190500791" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190500791">Bas Spitters (Mar 13 2020 at 13:15)</a>:</h4>
<p><span class="user-mention" data-user-id="243878">@Gaëtan Gilbert</span> What is the status of strict sets?</p>

<a name="190501023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190501023" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190501023">Bas Spitters (Mar 13 2020 at 13:17)</a>:</h4>
<p>Pcuic:<br>
<a href="https://hal.inria.fr/hal-01615123v2/document" target="_blank" title="https://hal.inria.fr/hal-01615123v2/document">https://hal.inria.fr/hal-01615123v2/document</a><br>
SProp is a recent addition described in Gaetan's thesis.</p>

<a name="190501149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190501149" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190501149">Mario Carneiro (Mar 13 2020 at 13:18)</a>:</h4>
<p>I know</p>

<a name="190501175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190501175" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190501175">Mario Carneiro (Mar 13 2020 at 13:18)</a>:</h4>
<p>hence my claim that it's the union of a bunch of type theory extensions that have not all been examined as a whole</p>

<a name="190501247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190501247" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190501247">Mario Carneiro (Mar 13 2020 at 13:19)</a>:</h4>
<p>I really sincerely don't understand why there isn't some reference linked from the coq manual or something that defines the whole axiomatic system and stays up to date with new versions</p>

<a name="190501249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190501249" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190501249">Bas Spitters (Mar 13 2020 at 13:20)</a>:</h4>
<p><span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> First, besides your point, measure theory should be developed algebraically/categorically e.g. in line with the theory of von Neumann algebras. See the remarks by people like Rota and Tao.<br>
But to address your point, which axiom would you like to add that is inconsistent with lawvere set theory ?</p>

<a name="190501498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190501498" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190501498">Johan Commelin (Mar 13 2020 at 13:22)</a>:</h4>
<p>All this talk about foundations is nice and well. My question remains: suppose that all of mathlib were translated by magic to HoTT. Would it be longer or shorter?</p>

<a name="190501771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190501771" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190501771">Bas Spitters (Mar 13 2020 at 13:25)</a>:</h4>
<p>It should be shorter, as we have more axioms (UA) at our disposal. However, I cannot completely gauge the influence of strict equality at the moment.</p>

<a name="190501946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190501946" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190501946">Johan Commelin (Mar 13 2020 at 13:27)</a>:</h4>
<p>The number of axioms is not the only factor. We lose definitional proof irrelevance. Will automation apply it for us instead? How often will I need to prove that my type is an hSet? Or is that automated? Is there type class inference? Is there a simplifier? Do they work?</p>

<a name="190502058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190502058" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190502058">Mario Carneiro (Mar 13 2020 at 13:28)</a>:</h4>
<p>for that argument to work, you have to be able to mimic/model/implement every single one of lean's axioms and defeqs. The "coq is a lean typechecker" suggests that this is very nearly possible, but it seems like you still have to give up some things, like lean's strong form of the axiom of choice</p>

<a name="190502111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190502111" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190502111">Johan Commelin (Mar 13 2020 at 13:28)</a>:</h4>
<p>But "coq is a lean typechecker" was not a univalent coq, was it?</p>

<a name="190502134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190502134" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190502134">Mario Carneiro (Mar 13 2020 at 13:29)</a>:</h4>
<p>no</p>

<a name="190502189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190502189" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190502189">Mario Carneiro (Mar 13 2020 at 13:29)</a>:</h4>
<p>I think Bas is claiming that there is a way to have both strict sets and univalence in the same system</p>

<a name="190502229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190502229" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190502229">Mario Carneiro (Mar 13 2020 at 13:30)</a>:</h4>
<p>but I'm pretty sure that <code>nonempty A -&gt; A</code> breaks everything</p>

<a name="190502395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190502395" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190502395">Mario Carneiro (Mar 13 2020 at 13:31)</a>:</h4>
<p>the hott version of the axiom of choice is much more guarded, something like <code>(Pi x, nonempty (A x)) -&gt; nonempty (Pi x, A x)</code></p>

<a name="190503253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190503253" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190503253">Sebastien Gouezel (Mar 13 2020 at 13:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="259452">Bas Spitters</span> <a href="#narrow/stream/116395-maths/topic/Univalence/near/190501249" title="#narrow/stream/116395-maths/topic/Univalence/near/190501249">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110050">Sebastien Gouezel</span> First, besides your point, measure theory should be developed algebraically/categorically e.g. in line with the theory of von Neumann algebras. See the remarks by people like Rota and Tao.</p>
</blockquote>
<p>It definitely shouldn't. The von Neumann algebra point of view is interesting, but there are many statements of down to earth measure theory that are just not true in this generality.</p>

<a name="190503415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190503415" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190503415">Sebastien Gouezel (Mar 13 2020 at 13:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="259452">Bas Spitters</span> <a href="#narrow/stream/116395-maths/topic/Univalence/near/190501249" title="#narrow/stream/116395-maths/topic/Univalence/near/190501249">said</a>:</p>
<blockquote>
<p>But to address your point, which axiom would you like to add that is inconsistent with lawvere set theory ?</p>
</blockquote>
<p>As I was saying, I don't know anything about HOTT. But my impression as an outsider is that you have to sacrifice some versions of choice, which is not an option for me. I would be happy to be proven wrong!</p>

<a name="190503700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190503700" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190503700">Mario Carneiro (Mar 13 2020 at 13:43)</a>:</h4>
<p>By the way, lean's version of the axiom of choice isn't even ok in ZFC. It's known as "global choice", positing the existence of a proper class function that is a choice function on every set</p>

<a name="190503749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190503749" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190503749">Mario Carneiro (Mar 13 2020 at 13:43)</a>:</h4>
<p>The actual axiom of choice only allows you to choose from set-many nonempty sets at once</p>

<a name="190503967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190503967" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190503967">Mario Carneiro (Mar 13 2020 at 13:45)</a>:</h4>
<p>However, in set theory you do have definable definite description, so unlike lean you don't have to use choice to define things like <code>lim</code> when the limit is unique</p>

<a name="190504047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190504047" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190504047">Gabriel Ebner (Mar 13 2020 at 13:46)</a>:</h4>
<p>I'm not sure this is true though since a Lean term can only talk about finitely many choice constants.  Lean has a <code>choice.{u}</code> constant for every universe <code>u</code>.  There is no relation between <code>choice.{u}</code> and <code>choice.{u+1}</code> (except for what you get out of the type).  And each <code>choice.{u}</code> is definable in ZFC + enough inaccessibles.</p>

<a name="190504068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190504068" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190504068">Mario Carneiro (Mar 13 2020 at 13:46)</a>:</h4>
<p>Oh, that's an interesting point</p>

<a name="190504213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190504213" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190504213">Mario Carneiro (Mar 13 2020 at 13:48)</a>:</h4>
<p>Still, <code>choice.{-}</code> has a bit of a peculiar status as a family then, since it will not be uniformly definable</p>

<a name="190504301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190504301" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190504301">Gabriel Ebner (Mar 13 2020 at 13:48)</a>:</h4>
<p>Is <code>Type.{-}</code> uniformly definable?</p>

<a name="190504382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190504382" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190504382">Mario Carneiro (Mar 13 2020 at 13:49)</a>:</h4>
<p>In all the models that I've considered for lean in set theory, yes. It's usually an explicitly agreed upon sequence, or perhaps the sequence "the n-th inaccessible"</p>

<a name="190504668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190504668" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190504668">Mario Carneiro (Mar 13 2020 at 13:52)</a>:</h4>
<p>I guess it's not really that different from the choice constants though. At some point this sequence breaks down - it's well defined but no longer points at anything because you've run out of inaccessibles in the outer model, say - and you can do something similar with the choice sequence where you start with an assumption that gives you the first 42 choice constants and the rest of them are just nonsense</p>

<a name="190504720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190504720" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190504720">Bas Spitters (Mar 13 2020 at 13:53)</a>:</h4>
<p><span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> lawvere set theory includes choice...</p>

<a name="190505151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190505151" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190505151">Sebastien Gouezel (Mar 13 2020 at 13:58)</a>:</h4>
<p>Great!</p>

<a name="190505171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190505171" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190505171">Mario Carneiro (Mar 13 2020 at 13:58)</a>:</h4>
<p>which choice?</p>

<a name="190505410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190505410" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190505410">Bas Spitters (Mar 13 2020 at 14:00)</a>:</h4>
<p><a href="https://ncatlab.org/nlab/show/ETCS" target="_blank" title="https://ncatlab.org/nlab/show/ETCS">https://ncatlab.org/nlab/show/ETCS</a><br>
<a href="https://ncatlab.org/nlab/show/fully+formal+ETCS#the_theory_etcs" target="_blank" title="https://ncatlab.org/nlab/show/fully+formal+ETCS#the_theory_etcs">https://ncatlab.org/nlab/show/fully+formal+ETCS#the_theory_etcs</a></p>

<a name="190506562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190506562" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190506562">Gaëtan Gilbert (Mar 13 2020 at 14:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/116395-maths/topic/Univalence/near/190501247" title="#narrow/stream/116395-maths/topic/Univalence/near/190501247">said</a>:</p>
<blockquote>
<p>I really sincerely don't understand why there isn't some reference linked from the coq manual or something that defines the whole axiomatic system and stays up to date with new versions</p>
</blockquote>
<p>what about <a href="https://coq.inria.fr/distrib/current/refman/language/cic.html" target="_blank" title="https://coq.inria.fr/distrib/current/refman/language/cic.html">https://coq.inria.fr/distrib/current/refman/language/cic.html</a> ?</p>

<a name="190506594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190506594" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190506594">Gaëtan Gilbert (Mar 13 2020 at 14:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="259452">Bas Spitters</span> <a href="#narrow/stream/116395-maths/topic/Univalence/near/190500791" title="#narrow/stream/116395-maths/topic/Univalence/near/190500791">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="243878">Gaëtan Gilbert</span> What is the status of strict sets?</p>
</blockquote>
<p>I'm not working on them</p>

<a name="190507184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190507184" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190507184">Assia Mahboubi (Mar 13 2020 at 14:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/116395-maths/topic/Univalence/near/190501247" title="#narrow/stream/116395-maths/topic/Univalence/near/190501247">said</a>:</p>
<blockquote>
<p>I really sincerely don't understand why there isn't some reference linked from the coq manual or something that defines the whole axiomatic system and stays up to date with new versions</p>
</blockquote>
<p>I guess  is related to the fact that the first released version of Coq is more than 30 years old. Nit-picking:  other  parts of a proof assistant, for which a paper description is seldom available, have at least as much impact on users and on their act of faith in formal statements. E.g. the elaborator, the parser etc. Since I am more interested in maths than in immediate applications in, e.g., security, I am not too worried though :).</p>

<a name="190507524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190507524" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190507524">Mario Carneiro (Mar 13 2020 at 14:21)</a>:</h4>
<p>I am interested in specification for those aspects as well, but I think the logical foundation is the first stage, and in principle should be the easiest to obtain, being as well studied as it is</p>

<a name="190507762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190507762" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190507762">Mario Carneiro (Mar 13 2020 at 14:23)</a>:</h4>
<p><span class="user-mention" data-user-id="243878">@Gaëtan Gilbert</span> That is a nice link. It is a bit tutorial-like though, and in particular the propensity to defer more complex aspects of the system until later makes it unclear when the description of the axioms is "done"</p>

<a name="190507871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190507871" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190507871">Mario Carneiro (Mar 13 2020 at 14:24)</a>:</h4>
<p>I don't think you could write a Coq typechecker from that description</p>

<a name="190507962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190507962" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190507962">Bas Spitters (Mar 13 2020 at 14:25)</a>:</h4>
<p><span class="user-mention" data-user-id="110172">@Assia Mahboubi</span> I'm interested in both math and security and that's why I think it's important that the logical foundations are well specified.<br>
I believe the information is there for the Coq system, but they could be collected in a more central place.</p>

<a name="190508347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190508347" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190508347">Mario Carneiro (Mar 13 2020 at 14:28)</a>:</h4>
<p>I am willing to believe that every piece of Coq foundations has been described in some paper written over the past 30 years. But there are also probably some bits of black magic in the ML code that never got air-time in a paper, and also the lack of central description means a lack of (proof of) global coherence, which is of course critical for soundness</p>

<a name="190509170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190509170" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190509170">Bas Spitters (Mar 13 2020 at 14:34)</a>:</h4>
<p><span class="user-mention" data-user-id="110172">@Assia Mahboubi</span> Do you happen to know more about the parametricity plugin for lean and how it relates to classical logic?</p>

<a name="190509198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190509198" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190509198">Mario Carneiro (Mar 13 2020 at 14:34)</a>:</h4>
<p>from <a href="https://coq.inria.fr/distrib/current/refman/language/cic.html" target="_blank" title="https://coq.inria.fr/distrib/current/refman/language/cic.html">the coq CIC manual</a>:</p>
<blockquote>
<p>the terms structurally smaller than <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> are:</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="sans-serif">c</mi><mi mathvariant="sans-serif">a</mi><mi mathvariant="sans-serif">s</mi><mi mathvariant="sans-serif">e</mi></mrow><mo stretchy="false">(</mo><mi>c</mi><mo separator="true">,</mo><mi>P</mi><mo separator="true">,</mo><msub><mi>f</mi><mn>1</mn></msub><mo>…</mo><msub><mi>f</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathsf{case}(c,P,f_1\dots f_n)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathsf">c</span><span class="mord mathsf">a</span><span class="mord mathsf">s</span><span class="mord mathsf">e</span></span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> when each <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is structurally smaller than <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>.</li>
</ul>
</blockquote>
<p>Isn't this the rule that caused a Coq soundness bug a while back?</p>

<a name="190509645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190509645" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190509645">Mario Carneiro (Mar 13 2020 at 14:37)</a>:</h4>
<p><a href="https://sympa.inria.fr/sympa/arc/coq-club/2013-12/msg00119.html" target="_blank" title="https://sympa.inria.fr/sympa/arc/coq-club/2013-12/msg00119.html">this one</a></p>

<a name="190510238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190510238" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190510238">Mario Carneiro (Mar 13 2020 at 14:42)</a>:</h4>
<p><span class="user-mention" data-user-id="259452">@Bas Spitters</span> The parametricity plugin written by Cyril will prove the parametricity theorem for "any lean term". It works by recursion over the term syntax of the language, but it can get stuck when it gets to certain things. For axioms, there is nowhere to recurse so you have to manually provide a proof of parametricity. And <code>choice</code> simply doesn't satisfy the parametricity theorem, so any terms built using <code>choice</code> (and there are a lot of them) are similarly blocked. There are also complications in some inductive types, but last I saw there were no real theoretical barriers.</p>

<a name="190510363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190510363" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190510363">Pierre-Marie Pédrot (Mar 13 2020 at 14:43)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Strictly speaking, this was not a soundness bug. It made Coq inconsistent with the standard Set model, which is indeed pretty bad, but doesn't allow to derive False either.</p>

<a name="190510526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190510526" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190510526">Mario Carneiro (Mar 13 2020 at 14:45)</a>:</h4>
<p>I realize that another way to phrase this is "Coq is anti-classical", and that is what is done in the thread itself. But for all the lean users and mathematicians around here, that's basically just proving false things.</p>

<a name="190510649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190510649" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190510649">Mario Carneiro (Mar 13 2020 at 14:46)</a>:</h4>
<p>Stated another way, it allows you to derive False in Coq + axioms that everyone wants to have and are unwilling to give up</p>

<a name="190510709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190510709" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190510709">Bas Spitters (Mar 13 2020 at 14:46)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> so, that approach to Transfer does not seem to be very suitable for lean...</p>

<a name="190511194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190511194" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190511194">Mario Carneiro (Mar 13 2020 at 14:51)</a>:</h4>
<p>Right, somehow the pure "abstract nonsense" proof of parametricity doesn't work in practice because <code>choice</code> is too deeply ingrained. But for more engineering minded folks like myself the news isn't all bad. Although we use <code>choice</code> a lot to do proofs, it's not like we have choicy functions all over the place. Mathematicians by and large tend to avoid constructions that are not "canonical" in some sense and this means that "random functions" are quite rare. So one might hope to blockade the region around <code>choice</code> by proving, by alternate means, the parametricity theorem for certain terms that use <code>choice</code> in their definition, and then being able to stop the recursion when you get there rather than peeking into the definition and getting stuck on <code>choice</code>.</p>
<p>In particular, much of our usage of <code>choice</code> comes via <code>classical.em</code>, which I think satisfies the parametricity theorem because of proof irrelevance</p>

<a name="190511479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190511479" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190511479">Pierre-Marie Pédrot (Mar 13 2020 at 14:53)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> I am not sure what you refer to, but <em>anti-classical</em> has a well-defined meaning and this doesn't apply to Coq. Coq is compatible with classical logic, but it doesn't imply it. So, parametricity breaks in presence of classical logic, but that's not preventing the extension of Coq with classical principles. Furthermore, adding effects to a language just weakens parametricity, there are still weaker presentations that can be salvaged.</p>

<a name="190511622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190511622" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190511622">Mario Carneiro (Mar 13 2020 at 14:54)</a>:</h4>
<p>When I talk about proving soundness of Coq, it may not be obvious but I don't mean "no axioms Coq", I mean "all common axioms Coq"</p>

<a name="190511733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190511733" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190511733">Mario Carneiro (Mar 13 2020 at 14:55)</a>:</h4>
<p>I'm pretty sure there is a file in the coq standard library called <code>Axioms.v</code> or something like that containing a bunch of things commonly believed to be ok. I want those to all be consistent with Coq</p>

<a name="190511869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190511869" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190511869">Pierre-Marie Pédrot (Mar 13 2020 at 14:56)</a>:</h4>
<p>This is ill-defined, people do use conflicting "common" axioms. Is UIP common? Is univalence common?</p>

<a name="190512007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190512007" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190512007">Mario Carneiro (Mar 13 2020 at 14:57)</a>:</h4>
<p>If there are mutually incompatible supported subsets, they should be explicitly determined and the (probably quite distinct) proofs of consistency of each maximal consistent subset should be shown</p>

<a name="190512064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190512064" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190512064">Mario Carneiro (Mar 13 2020 at 14:57)</a>:</h4>
<p>And also there should be GIANT WARNING FLAGS on these axioms to prevent someone from accidentally using both in the same development</p>

<a name="190512099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190512099" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190512099">Pierre-Marie Pédrot (Mar 13 2020 at 14:57)</a>:</h4>
<p>This doesn't make sense, by Gödel's theorem there is no maximally consistent extension...</p>

<a name="190512176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190512176" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190512176">Mario Carneiro (Mar 13 2020 at 14:58)</a>:</h4>
<p>The set of axioms in the coq standard library is finite</p>

<a name="190512221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190512221" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190512221">Pierre-Marie Pédrot (Mar 13 2020 at 14:58)</a>:</h4>
<p>There is a nice graph somewhere in the doc, for set-theoretic axioms. Let me find it.</p>

<a name="190512307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190512307" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190512307">Mario Carneiro (Mar 13 2020 at 14:59)</a>:</h4>
<p>I would have hoped that all the axioms taken together are consistent. Univalence is not in the coq standard library, I think</p>

<a name="190512309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190512309" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190512309">Pierre-Marie Pédrot (Mar 13 2020 at 14:59)</a>:</h4>
<p>You can have a look at <a href="https://github.com/coq/coq/wiki/The-Logic-of-Coq" target="_blank" title="https://github.com/coq/coq/wiki/The-Logic-of-Coq">https://github.com/coq/coq/wiki/The-Logic-of-Coq</a> and <a href="https://github.com/coq/coq/wiki/CoqAndAxioms" target="_blank" title="https://github.com/coq/coq/wiki/CoqAndAxioms">https://github.com/coq/coq/wiki/CoqAndAxioms</a>.</p>

<a name="190512420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190512420" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190512420">Mario Carneiro (Mar 13 2020 at 15:00)</a>:</h4>
<p>All 7 axioms on that page are consistent with each other in lean, and I hope in Coq as well</p>

<a name="190512431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190512431" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190512431">Pierre-Marie Pédrot (Mar 13 2020 at 15:00)</a>:</h4>
<p>There is no such thing as "true mathematics" so it doesn't make sense to ask our users to abide to a specific set of axioms.</p>

<a name="190512573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190512573" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190512573">Pierre-Marie Pédrot (Mar 13 2020 at 15:01)</a>:</h4>
<p>Compatibility is a strength. But if you like sets, you can throw in whatever set-theoretical axiom you fancy.</p>

<a name="190512837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190512837" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190512837">Pierre-Marie Pédrot (Mar 13 2020 at 15:02)</a>:</h4>
<p>And I am not a crazy intuitionist, I would actually like to have some extension of CIC to classical reasoning that preserves its good computational properties. But it's far from being an easy task. And no, I don't consider that what Lean does is the right way.</p>

<a name="190512859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190512859" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190512859">Mario Carneiro (Mar 13 2020 at 15:03)</a>:</h4>
<p>As long as the union of all provided axioms is still consistent, it's not so bad to work with subsets. You can choose not to use any of them, or just one, or just a different one, and all the libraries are compatible. As soon as you throw in an axiom that is inconsistent with the others, you bifurcate the libraries and the community</p>

<a name="190513015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190513015" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190513015">Pierre-Marie Pédrot (Mar 13 2020 at 15:04)</a>:</h4>
<p>So what? There are people writing thread-safe code in C++, that doesn't mean that you can't also write code that is thread-unsafe.</p>

<a name="190513023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190513023" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190513023">Mario Carneiro (Mar 13 2020 at 15:04)</a>:</h4>
<p>I actually don't particularly like lean's approach to axioms either. There are 3 axioms, and for almost all work you basically are forced to accept them all. There is very little room for playing with subsets</p>

<a name="190513282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190513282" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190513282">Mario Carneiro (Mar 13 2020 at 15:06)</a>:</h4>
<p>In metamath there are something like 20-25 axioms, and while many of the subsets are not interesting, you can still play with avoiding the axiom of choice, or the axiom of foundation, or replacement, or first order logic, or intuitionistic logic.</p>

<a name="190513452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190513452" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190513452">Mario Carneiro (Mar 13 2020 at 15:07)</a>:</h4>
<p>However, the union of all available axioms is TG set theory which is rather strong but still believed to be consistent</p>

<a name="190513492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190513492" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190513492">Mario Carneiro (Mar 13 2020 at 15:07)</a>:</h4>
<p>so you don't need to have two separate libraries</p>

<a name="190513607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190513607" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190513607">Pierre-Marie Pédrot (Mar 13 2020 at 15:08)</a>:</h4>
<p>This may look like an alien statement to the mathematicians around here, but I do think this kind of belief of "the one metatheory to rule them all" is 19th century thinking. If you accept proof-as-programs, then it makes sense to have several programming languages enforcing contradictory invariants. And this has nothing to do with the old feud between intuitionistic crackpots and the rest of the mathematical community, this is just about accepting the world as it is.</p>

<a name="190513686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190513686" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190513686">Johan Commelin (Mar 13 2020 at 15:09)</a>:</h4>
<p>Who cares? If you want to get mathematicians on board, you'll have to accept that they don't care about foundations and just want to prove their theorems.</p>

<a name="190513724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190513724" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190513724">Johan Commelin (Mar 13 2020 at 15:09)</a>:</h4>
<p>I know many mathematicians who really don't care about foundations. (I can't even list the axioms of ZFC myself.)</p>

<a name="190513729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190513729" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190513729">Pierre-Marie Pédrot (Mar 13 2020 at 15:09)</a>:</h4>
<p>... or maybe we can teach the mathematicians about computer science to make them understand it's not a sterile debate?</p>

<a name="190513748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190513748" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190513748">Mario Carneiro (Mar 13 2020 at 15:09)</a>:</h4>
<p>I'm all for supporting multiple foundations, but I also want to avoid erecting walls between formal developments</p>

<a name="190513752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190513752" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190513752">Johan Commelin (Mar 13 2020 at 15:09)</a>:</h4>
<p>They don't care about correctness either. As long as proofs converge within a reasonable amount of time, that's fine.</p>

<a name="190513757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190513757" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190513757">Mario Carneiro (Mar 13 2020 at 15:10)</a>:</h4>
<p>so compatibility is key</p>

<a name="190513810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190513810" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190513810">Johan Commelin (Mar 13 2020 at 15:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260981">Pierre-Marie Pédrot</span> <a href="#narrow/stream/116395-maths/topic/Univalence/near/190513729" title="#narrow/stream/116395-maths/topic/Univalence/near/190513729">said</a>:</p>
<blockquote>
<p>... or maybe we can teach the mathematicians about computer science to make them understand it's not a sterile debate?</p>
</blockquote>
<p>They aren't interested in that either.</p>

<a name="190513833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190513833" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190513833">Johan Commelin (Mar 13 2020 at 15:10)</a>:</h4>
<p>I don't say you should change. But in that case, don't get your hopes up on having mathematicians among your users.</p>

<a name="190513850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190513850" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190513850">Pierre-Marie Pédrot (Mar 13 2020 at 15:10)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> the situation is not as dire as you think from the point of view of foundations in the Coq community, there are mainly the Set people and the HoTT people.</p>

<a name="190513859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190513859" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190513859">Johan Commelin (Mar 13 2020 at 15:10)</a>:</h4>
<p>What I am interested in is a proof assistant that helps me do research in arithmetic geometry.</p>

<a name="190513913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190513913" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190513913">Johan Commelin (Mar 13 2020 at 15:11)</a>:</h4>
<p>Currently no such a thing exists.</p>

<a name="190513917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190513917" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190513917">Pierre-Marie Pédrot (Mar 13 2020 at 15:11)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> technical issues regarding the design choices of libraries are a much bigger issue than foundations.</p>

<a name="190513942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190513942" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190513942">Johan Commelin (Mar 13 2020 at 15:11)</a>:</h4>
<p>And as long as I need to spend brain power on foundational issues, it won't happen either.</p>

<a name="190513946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190513946" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190513946">Mario Carneiro (Mar 13 2020 at 15:11)</a>:</h4>
<p>Again, compatibility is key</p>

<a name="190513956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190513956" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190513956">Mario Carneiro (Mar 13 2020 at 15:11)</a>:</h4>
<p>This is why mathlib is a monorepo</p>

<a name="190514321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190514321" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190514321">Pierre-Marie Pédrot (Mar 13 2020 at 15:14)</a>:</h4>
<p>Once again, I think we should turn to programming engineering to draw inspiration. It is not uncommon to see various styles emerge. Then people tend to turn this state of affairs in the dreaded "platform" thingy so that you effectively get another programming language atop of the base one, enforcing more constraints like style and whatnot. If you need to make interact two libraries using different platforms, then you're toast.</p>

<a name="190514387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190514387" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190514387">Mario Carneiro (Mar 13 2020 at 15:14)</a>:</h4>
<p>If it really is the Set people and the HoTT people, then asking mathematicians to use HoTT is like asking them to jump over the wall. And they very reasonably point out that they like the things on this side of the wall and don't want to give them up, even though there are some cool things on the other side too.</p>

<a name="190514449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190514449" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190514449">Mario Carneiro (Mar 13 2020 at 15:15)</a>:</h4>
<p>At least there is the C ABI for interop when it comes to cross library compatibility in software</p>

<a name="190514473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190514473" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190514473">Pierre-Marie Pédrot (Mar 13 2020 at 15:15)</a>:</h4>
<p>You can do Set theory in HoTT, but this is more like bondage than anything else.</p>

<a name="190514506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190514506" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190514506">Pierre-Marie Pédrot (Mar 13 2020 at 15:15)</a>:</h4>
<p>As for C ABI, this is not a magical entity that happened overnight, this is the result of history and social interaction.</p>

<a name="190514602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190514602" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190514602">Pierre-Marie Pédrot (Mar 13 2020 at 15:16)</a>:</h4>
<p>My personal belief is that MLTT plus or minus is a rather good minimal system.</p>

<a name="190514661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190514661" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190514661">Mario Carneiro (Mar 13 2020 at 15:16)</a>:</h4>
<p>but you can't actually share results in a base theory, because the theorems need more than the base theory</p>

<a name="190514688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190514688" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190514688">Pierre-Marie Pédrot (Mar 13 2020 at 15:16)</a>:</h4>
<p>There are French people believing that you should do everything via λΠ-modulo.</p>

<a name="190514774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190514774" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190514774">Mario Carneiro (Mar 13 2020 at 15:17)</a>:</h4>
<p>If everyone worked in MLTT then they could be "universal donors" but there is no industrial strength implementation of MLTT</p>

<a name="190514785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190514785" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190514785">Pierre-Marie Pédrot (Mar 13 2020 at 15:17)</a>:</h4>
<p>Well, so what? So be it. If I have code that uses threads, then it will break libraries relying on the absence of threads. That's life.</p>

<a name="190514884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190514884" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190514884">Pierre-Marie Pédrot (Mar 13 2020 at 15:18)</a>:</h4>
<p>You don't consider Coq to implement MLTT, or that it's not industrial-strength?</p>

<a name="190514995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190514995" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190514995">Johan Commelin (Mar 13 2020 at 15:19)</a>:</h4>
<p><span class="user-mention" data-user-id="260981">@Pierre-Marie Pédrot</span> Here is a result that I find extremely interesting: <a href="https://en.wikipedia.org/wiki/Resolution_of_singularities" target="_blank" title="https://en.wikipedia.org/wiki/Resolution_of_singularities">https://en.wikipedia.org/wiki/Resolution_of_singularities</a><br>
I would like to know what you think is the shortest path to getting such a statement and proof in a computer proof assistent. I have all the reason to believe that Lean is currently the proof assistant that is moving in that direction the fastest.</p>

<a name="190515019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190515019" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190515019">Mario Carneiro (Mar 13 2020 at 15:19)</a>:</h4>
<p>Coq implements a too strong theory, hence it cannot export results elsewhere</p>

<a name="190515122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190515122" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190515122">Mario Carneiro (Mar 13 2020 at 15:20)</a>:</h4>
<p>The reason "Coq is a Lean typechecker" and not the other way around is because Coq is stronger. Strength is not a strength</p>

<a name="190515156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190515156" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190515156">Pierre-Marie Pédrot (Mar 13 2020 at 15:20)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> foundation-wise, there is no real difference between Lean and Coq. Anything you can do with one, you can do with the other. <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> well, but nobody prevents you to define subsystems.</p>

<a name="190515215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190515215" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190515215">Pierre-Marie Pédrot (Mar 13 2020 at 15:20)</a>:</h4>
<p>Coq is not stronger than Lean, <span class="user-mention" data-user-id="243878">@Gaëtan Gilbert</span> had to specifically use unsafe features to implement Lean.</p>

<a name="190515275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190515275" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190515275">Mario Carneiro (Mar 13 2020 at 15:21)</a>:</h4>
<p>It's very difficult to have subsystems of Coq where it matters. Can you turn off inductive types? Fancy pattern matches? Type n for n &gt; 3?</p>

<a name="190515287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190515287" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190515287">Pierre-Marie Pédrot (Mar 13 2020 at 15:21)</a>:</h4>
<p>If anything, modulo implemementation details, Lean is an extension of Coq.</p>

<a name="190515435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190515435" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190515435">Pierre-Marie Pédrot (Mar 13 2020 at 15:22)</a>:</h4>
<p>What system do you want to get? As far as I am concerned, if you remove stuff like SProp, modules and template polymorphic inductive types, and only use eliminators, I get a reasonable foundation.</p>

<a name="190515446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190515446" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190515446">Mario Carneiro (Mar 13 2020 at 15:22)</a>:</h4>
<p>The truth is that neither Coq or Lean is a subsystem of the other because DTT is too sensitive to minor differences</p>

<a name="190515515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190515515" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190515515">Mario Carneiro (Mar 13 2020 at 15:22)</a>:</h4>
<p>Can I do something with equivalent axiomatic strength to HOL in Coq?</p>

<a name="190515587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190515587" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190515587">Mario Carneiro (Mar 13 2020 at 15:23)</a>:</h4>
<p>Or at least not surpassing ZFC (without going intuitionistic / predicative)?</p>

<a name="190515639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190515639" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190515639">Pierre-Marie Pédrot (Mar 13 2020 at 15:23)</a>:</h4>
<p>Coq is conjectured to be strictly weaker than ZFC + ω universes btw.</p>

<a name="190515698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190515698" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190515698">Mario Carneiro (Mar 13 2020 at 15:24)</a>:</h4>
<p>you are talking no axioms coq though</p>

<a name="190515735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190515735" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190515735">Pierre-Marie Pédrot (Mar 13 2020 at 15:24)</a>:</h4>
<p>At the risk of repeating myself, there is no such thing as "Coq + Axioms".</p>

<a name="190515744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190515744" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190515744">Mario Carneiro (Mar 13 2020 at 15:24)</a>:</h4>
<p>I want all the axioms on that page</p>

<a name="190515813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190515813" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190515813">Mario Carneiro (Mar 13 2020 at 15:24)</a>:</h4>
<p>Coq + those axioms</p>

<a name="190515814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190515814" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190515814">Pierre-Marie Pédrot (Mar 13 2020 at 15:24)</a>:</h4>
<p>Yes, but then you get a crappy theory.</p>

<a name="190515871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190515871" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190515871">Mario Carneiro (Mar 13 2020 at 15:25)</a>:</h4>
<p>Why? It's the theory mathematicians are used to</p>

<a name="190515892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190515892" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190515892">Pierre-Marie Pédrot (Mar 13 2020 at 15:25)</a>:</h4>
<p>It's not a programming language anymore.</p>

<a name="190515911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190515911" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190515911">Mario Carneiro (Mar 13 2020 at 15:25)</a>:</h4>
<p>or at least, the best approximation you can get to it within the constraints of dependent type theory</p>

<a name="190515929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190515929" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190515929">Pierre-Marie Pédrot (Mar 13 2020 at 15:25)</a>:</h4>
<p>Having axioms in SProp does look like a promising way though.</p>

<a name="190516047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190516047" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190516047">Mario Carneiro (Mar 13 2020 at 15:26)</a>:</h4>
<p>You know, I don't think saying "it's not a programming language anymore" will get you much sympathy around here. We don't want a programming language, we want a proof language</p>

<a name="190516063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190516063" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190516063">Pierre-Marie Pédrot (Mar 13 2020 at 15:26)</a>:</h4>
<p>As for HOL, the Dedukti people wrote a few translators from various systems. You could try playing with it.</p>

<a name="190516082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190516082" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190516082">Mario Carneiro (Mar 13 2020 at 15:26)</a>:</h4>
<p>You can always use computable things if you want to compute</p>

<a name="190516152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190516152" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190516152">Pierre-Marie Pédrot (Mar 13 2020 at 15:27)</a>:</h4>
<p>This is why Coq has the distinction Prop / Type. Add you proof axioms in Prop, compute in Type.</p>

<a name="190516263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190516263" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190516263">Mario Carneiro (Mar 13 2020 at 15:28)</a>:</h4>
<p>Sure, and none of those axioms interferes with this AFAIK</p>

<a name="190516346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190516346" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190516346">Pierre-Marie Pédrot (Mar 13 2020 at 15:28)</a>:</h4>
<p>And FTR I don't really care about the sympathy of mathematicians. I have enough "real math" friends of mine who make fun of type theory and computer assistants. It's a social issue, not a technical one.</p>

<a name="190516422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190516422" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190516422">Mario Carneiro (Mar 13 2020 at 15:29)</a>:</h4>
<p>I just don't see why they have to be at odds</p>

<a name="190516430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190516430" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190516430">Pierre-Marie Pédrot (Mar 13 2020 at 15:29)</a>:</h4>
<p>Lean Santa Claus version of choice "inhabited A -&gt; A" is very bad in the Prop / Type distinction though.</p>

<a name="190516499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190516499" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190516499">Mario Carneiro (Mar 13 2020 at 15:30)</a>:</h4>
<p>Sure, it's <code>noncomputable</code></p>

<a name="190516541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190516541" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190516541">Mario Carneiro (Mar 13 2020 at 15:30)</a>:</h4>
<p>The cool thing is that if you use it only in proofs it becomes computable again</p>

<a name="190516556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190516556" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190516556">Mario Carneiro (Mar 13 2020 at 15:30)</a>:</h4>
<p>that is, <code>classical.em</code> is <code>computable</code></p>

<a name="190516611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190516611" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190516611">Pierre-Marie Pédrot (Mar 13 2020 at 15:30)</a>:</h4>
<p>Well, breaking SR, strong normalization and whatnot.</p>

<a name="190516655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190516655" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190516655">Pierre-Marie Pédrot (Mar 13 2020 at 15:31)</a>:</h4>
<p>I am afraid this is a dealbreaker.</p>

<a name="190516698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190516698" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190516698">Pierre-Marie Pédrot (Mar 13 2020 at 15:31)</a>:</h4>
<p>But anyways, if a development uses choice, then will you consider this as valid?</p>

<a name="190516709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190516709" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190516709">Mario Carneiro (Mar 13 2020 at 15:31)</a>:</h4>
<p>Axioms don't break SR, proof irrelevance and large elimination does</p>

<a name="190516714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190516714" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190516714">Pierre-Marie Pédrot (Mar 13 2020 at 15:31)</a>:</h4>
<p>In a noncomputable way, I mean?</p>

<a name="190516731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190516731" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190516731">Mario Carneiro (Mar 13 2020 at 15:31)</a>:</h4>
<p>strong normalization doesn't matter</p>

<a name="190516749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190516749" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190516749">Pierre-Marie Pédrot (Mar 13 2020 at 15:32)</a>:</h4>
<p>(You can't shift the blame one one axiom, it's the whole interaction of rules.)</p>

<a name="190516807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190516807" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190516807">Mario Carneiro (Mar 13 2020 at 15:32)</a>:</h4>
<p>That concerns the behavior of <code>#reduce</code> which we literally never use because it's impractically slow on almost all examples</p>

<a name="190516823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190516823" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190516823">Pierre-Marie Pédrot (Mar 13 2020 at 15:32)</a>:</h4>
<blockquote>
<p>strong normalization doesn't matter</p>
</blockquote>

<a name="190516841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190516841" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190516841">Pierre-Marie Pédrot (Mar 13 2020 at 15:32)</a>:</h4>
<p>for some people it does</p>

<a name="190516902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190516902" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190516902">Pierre-Marie Pédrot (Mar 13 2020 at 15:33)</a>:</h4>
<p>so, please answer the question: assuming some subcommunity wants to restrict to computable functions</p>

<a name="190516919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190516919" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190516919">Pierre-Marie Pédrot (Mar 13 2020 at 15:33)</a>:</h4>
<p>for some reason, doesn't matter</p>

<a name="190516934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190516934" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190516934">Pierre-Marie Pédrot (Mar 13 2020 at 15:33)</a>:</h4>
<p>what does mathlib tell them?</p>

<a name="190516954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190516954" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190516954">Mario Carneiro (Mar 13 2020 at 15:33)</a>:</h4>
<p>What matters is evaluating computable functions that were written to be computable, not evaluating all terms anywhere in the proof assistant including proofs and stuff</p>

<a name="190517096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190517096" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190517096">Pierre-Marie Pédrot (Mar 13 2020 at 15:34)</a>:</h4>
<p>OK, this foundation stuff is a red herring. Let me put it another way. Assume there are people deciding to go ssr-style in Lean.</p>

<a name="190517116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190517116" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190517116">Pierre-Marie Pédrot (Mar 13 2020 at 15:35)</a>:</h4>
<p>What happens? A fork?</p>

<a name="190517139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190517139" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190517139">Pierre-Marie Pédrot (Mar 13 2020 at 15:35)</a>:</h4>
<p>That's essentially what happened to Coq a long time ago.</p>

<a name="190517321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190517321" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190517321">Mario Carneiro (Mar 13 2020 at 15:36)</a>:</h4>
<p>Lean has a marker, called <code>noncomputable</code>, that you are required to put on any definition that cannot be executed. There is a way to put this at the start of your file to say "I don't care about computability", and most mathematicians do this for their theories of category theory, commutative algebra and whatnot. If you care about computability, you write computable defs, which don't have this marking, and lean will generate bytecode on the spot. These functions can be called via <code>#eval</code> with concrete arguments and you get values out just like any programming language.</p>

<a name="190517480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190517480" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190517480">Pierre-Marie Pédrot (Mar 13 2020 at 15:37)</a>:</h4>
<p>Right, right. But my point is about the existence of diverging design choices in library in software.</p>

<a name="190517506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190517506" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190517506">Pierre-Marie Pédrot (Mar 13 2020 at 15:37)</a>:</h4>
<p>Doesn't even have to be Lean.</p>

<a name="190517577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190517577" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190517577">Mario Carneiro (Mar 13 2020 at 15:38)</a>:</h4>
<p>Moreover, there are ways to compute even with noncomputable terms, using tactics, and this is in fact the preferred method (by comparison to proofs by reflection). This is exemplified in tactics like <code>norm_num</code> that will prove things like <code>100 + 100 = 200</code> by cobbling proofs together, even though yes, you could prove it by <code>rfl</code>, the proof takes too long</p>

<a name="190517588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190517588" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190517588">Pierre-Marie Pédrot (Mar 13 2020 at 15:38)</a>:</h4>
<p>Invariably, there will be people disagreeing with whatever choice done in mathlib.</p>

<a name="190517682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190517682" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190517682">Pierre-Marie Pédrot (Mar 13 2020 at 15:39)</a>:</h4>
<blockquote>
<p>the proof takes too long</p>
</blockquote>
<p>really? this sounds suspicious to me</p>

<a name="190517710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190517710" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190517710">Mario Carneiro (Mar 13 2020 at 15:39)</a>:</h4>
<p>It unfolds into unary. It's bad</p>

<a name="190517750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190517750" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190517750">Pierre-Marie Pédrot (Mar 13 2020 at 15:39)</a>:</h4>
<p>yes, but tactics will have to generate similarly big proof terms</p>

<a name="190517822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190517822" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190517822">Pierre-Marie Pédrot (Mar 13 2020 at 15:40)</a>:</h4>
<p>doesn't it mean that the reduction machine is not really optimized in Lean?</p>

<a name="190517859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190517859" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190517859">Mario Carneiro (Mar 13 2020 at 15:40)</a>:</h4>
<p>The short story is that in Lean the tactics are fast and the kernel reduction (plus elaborator reduction) is comparatively slow. In Coq it is the other way around and the cost benefit analysis goes the other way</p>

<a name="190517895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190517895" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190517895">Pierre-Marie Pédrot (Mar 13 2020 at 15:41)</a>:</h4>
<p>OK, this is surprising.</p>

<a name="190517914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190517914" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190517914">Mario Carneiro (Mar 13 2020 at 15:41)</a>:</h4>
<p>Checking big proof terms is not that bad, as long as the types all line up</p>

<a name="190518045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190518045" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190518045">Pierre-Marie Pédrot (Mar 13 2020 at 15:42)</a>:</h4>
<p>well, type-checking is at least linear in the size of the term</p>

<a name="190518075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190518075" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190518075">Mario Carneiro (Mar 13 2020 at 15:42)</a>:</h4>
<p>yes, that's fast if the term is small</p>

<a name="190518180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190518180" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190518180">Pierre-Marie Pédrot (Mar 13 2020 at 15:43)</a>:</h4>
<p>yeah but I fail to see how you can build a reasonable proof of "100 + 100 = 200" that is not generating a term requiring more work than mere evaluation, in unary that is</p>

<a name="190518294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190518294" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190518294">Mario Carneiro (Mar 13 2020 at 15:44)</a>:</h4>
<p>Note also that if you provide a proof term you have a lot of flexibility in how to do the computation. For example when <code>norm_num</code> proves or disproves primality, the first thing it does is find out if the number is actually prime, and if not, it has a very short proof of the negation. A reduction based proof would have to do the whole primality thing even in the composite case</p>

<a name="190518346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190518346" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190518346">Pierre-Marie Pédrot (Mar 13 2020 at 15:44)</a>:</h4>
<p>depends how you write it</p>

<a name="190518357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190518357" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190518357">Mario Carneiro (Mar 13 2020 at 15:44)</a>:</h4>
<p>You can produce a proof of <code>100 + 100 = 200</code> in size linear in the size of the expression, which is written in binary after the parser has had a go</p>

<a name="190518372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190518372" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190518372">Pierre-Marie Pédrot (Mar 13 2020 at 15:45)</a>:</h4>
<p>the ssr people are very good at this kind of stuff</p>

<a name="190518373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190518373" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190518373">Reid Barton (Mar 13 2020 at 15:45)</a>:</h4>
<p>The literal "100" itself is not in unary, as a term</p>

<a name="190518570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190518570" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190518570">Bas Spitters (Mar 13 2020 at 15:46)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> <span class="user-mention" data-user-id="112680">@Johan Commelin</span> Is it possible that what mathematicians in lean are really using is Lawvere's version of choice as in ECTS, and not Hilbert epsilon which is non-structural.</p>

<a name="190518702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190518702" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190518702">Mario Carneiro (Mar 13 2020 at 15:48)</a>:</h4>
<p>Let's suppose you want to reduce <code>prime N</code> to true or false where <code>N</code> is some big number, say 50 digits. You have no choice but to push the kernel through a bunch of states to test the primality, while a tactic can just call GMP or mathematica to first factorize it and then prove the correctness of this untrusted guess</p>

<a name="190518854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190518854" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190518854">Pierre-Marie Pédrot (Mar 13 2020 at 15:49)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> that's assuming you go full reflection, but precisely the ssr people are argueing for interleaved computation with tactics.</p>

<a name="190519001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190519001" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190519001">Mario Carneiro (Mar 13 2020 at 15:50)</a>:</h4>
<p>Is that so? I didn't realize that. I usually have a tough time being able to insert a proof term in the middle of a defeq computation</p>

<a name="190519157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190519157" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190519157">Pierre-Marie Pédrot (Mar 13 2020 at 15:51)</a>:</h4>
<p>I am probably not qualified enough to talk about this but this is precisely the whole story of the "small-scale" nature of this approach. I'd recommend asking <span class="user-mention" data-user-id="110172">@Assia Mahboubi</span> for instance.</p>

<a name="190519456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190519456" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190519456">Mario Carneiro (Mar 13 2020 at 15:53)</a>:</h4>
<p><span class="user-mention" data-user-id="259452">@Bas Spitters</span> In a literal sense, of course they are not; lean provides one choice axiom and they are using it. But more likely you mean that they would be equally happy with a Lawvere style axiom of choice, and I'm not sure this is true. Among other things, we use <code>choice</code> to do definite descriptions. So things like <code>sum (f : nat -&gt; real) : real</code> will be defined using <code>choice</code>. (It would also be used here to do an outer if statement: if the sum is not defined then return 0 else return the unique sum of the sequence.)</p>

<a name="190519652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190519652" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190519652">Reid Barton (Mar 13 2020 at 15:55)</a>:</h4>
<p>I think this "naked <code>choice</code>" is potentially problematic even just in the context of Lean itself. For example (as noted earlier, I think) it blocks automatic syntax-directed proofs of parametricity.</p>

<a name="190519766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190519766" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190519766">Reid Barton (Mar 13 2020 at 15:55)</a>:</h4>
<p>It would be better to split off <code>axiom_of_choice</code> (the Prop version) and <code>unique_choice</code> into separate axioms</p>

<a name="190519957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190519957" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190519957">Bas Spitters (Mar 13 2020 at 15:57)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> I am not an expert on this topic, but the people in constructive/computer algebra have considered this topic. E.g.<br>
<a href="https://arxiv.org/abs/1304.6770" target="_blank" title="https://arxiv.org/abs/1304.6770">https://arxiv.org/abs/1304.6770</a><br>
What is interesting is that the same abstractions are useful in topos theory (Coste, Roy, Lombardi, Wraith, ...) and in computer algebra (magma,GAP, ...)<br>
<span class="user-mention" data-user-id="110172">@Assia Mahboubi</span> may know more. <br>
I would imagine that a more algebraic development is more suitable for formalization. However, it is possible that we do not have all the right abstractions yet.</p>

<a name="190520052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190520052" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190520052">Reid Barton (Mar 13 2020 at 15:57)</a>:</h4>
<p>Then some definitions like (hypothetically, I don't think this is the actual mathlib definition) the dimension of a vector space as "pick a basis, and take its cardinality" can be formulated in terms of <code>unique_choice</code>, but it requires proving that the result is independent of the choice. Which is also the rule in ordinary math.</p>

<a name="190520216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190520216" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190520216">Reid Barton (Mar 13 2020 at 15:58)</a>:</h4>
<p>(I think the actual mathlib definition is "the smallest cardinality of a basis"? but surely there are other examples)</p>

<a name="190520437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190520437" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190520437">Mario Carneiro (Mar 13 2020 at 16:00)</a>:</h4>
<p><code>sum</code> mentioned above is an example. There are two uses of choice in that definition, and they are both definite descriptions</p>

<a name="190520466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190520466" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190520466">Gabriel Ebner (Mar 13 2020 at 16:00)</a>:</h4>
<p>I'm not sure how the dimension of a (real) vector space could ever be computable.  What is the dimension of the span of a real number <code>x</code>?  This requires computing whether <code>x</code> is nonzero.  But alas, that's noncomutable.</p>

<a name="190520501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190520501" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190520501">Mario Carneiro (Mar 13 2020 at 16:00)</a>:</h4>
<p>It's not computable, <code>unique_choice</code> would still be an axiom</p>

<a name="190520660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190520660" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190520660">Gabriel Ebner (Mar 13 2020 at 16:02)</a>:</h4>
<p>Ah, sorry didn't follow the discussion too much.  <code>unique_choice [subsingleton A] : nonempty A -&gt; A</code> then?</p>

<a name="190520706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190520706" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190520706">Reid Barton (Mar 13 2020 at 16:02)</a>:</h4>
<p>This also fits better with my mental model of the semantics--I want to say you get a model of Lean from a model of ZFC+omega inaccessibles, not from such a model together with some specific choice of choice functions.</p>

<a name="190520770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190520770" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190520770">Reid Barton (Mar 13 2020 at 16:02)</a>:</h4>
<p>Of course full <code>choice</code> would probably be needed/convenient for some purposes, but at least you could track it separately</p>

<a name="190520942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190520942" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190520942">Mario Carneiro (Mar 13 2020 at 16:04)</a>:</h4>
<p>You can also do <code>unique_choice : unique A -&gt; A</code></p>

<a name="190521103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190521103" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190521103">Gabriel Ebner (Mar 13 2020 at 16:05)</a>:</h4>
<p>This version of <code>unique_choice</code> doesn't require an axiom though, since <code>unique</code> extends <code>inhabited</code>.</p>

<a name="190521255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190521255" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190521255">Mario Carneiro (Mar 13 2020 at 16:06)</a>:</h4>
<p>oh</p>

<a name="190521285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190521285" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190521285">Mario Carneiro (Mar 13 2020 at 16:06)</a>:</h4>
<p><code>nonempty (unique A) -&gt; A</code>? Doesn't have the same ring</p>

<a name="190521312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190521312" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190521312">Bas Spitters (Mar 13 2020 at 16:06)</a>:</h4>
<p>Corollary 3.9.2 (The principle of unique choice). Suppose a type family P : A → U such that<br>
(i) For each x, the type P(x ) is a mere proposition, and<br>
(ii) For each x we have || P( x)||.<br>
Then we have ∏( x:A ) P( x).</p>

<a name="190521500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190521500" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190521500">Mario Carneiro (Mar 13 2020 at 16:08)</a>:</h4>
<p>The use of a type family there seems superfluous</p>

<a name="190521581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190521581" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190521581">Mario Carneiro (Mar 13 2020 at 16:09)</a>:</h4>
<p>Note that lean's <code>choice</code> used to be more complicated, and it was simplified to the current <code>nonempty A -&gt; A</code></p>

<a name="190521696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190521696" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190521696">Mario Carneiro (Mar 13 2020 at 16:10)</a>:</h4>
<p>I think the original axiom was <code>indefinite_description {α : Sort u} (p : α → Prop) : (∃ x, p x) → {x // p x}</code></p>

<a name="190522702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190522702" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190522702">Mario Carneiro (Mar 13 2020 at 16:17)</a>:</h4>
<p>If I ignore the thing about the type family (set A = unit), then it seems that the HoTT version reduces to what Gabriel posted</p>

<a name="190523605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190523605" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190523605">Gabriel Ebner (Mar 13 2020 at 16:23)</a>:</h4>
<p>The Lean version of unique choice is pretty strong since we have more subsingletons, e.g. it implies that all types have decidable equality.  Does the HoTT version allow you to write <code>λ x : ℝ, if x = 0 then tt else ff</code>?</p>

<a name="190523827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190523827" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190523827">Bas Spitters (Mar 13 2020 at 16:25)</a>:</h4>
<p><span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> I believe so in the presence of PEM. Since the term is definable in ECTS using unique choice.</p>

<a name="190523906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190523906" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190523906">Mario Carneiro (Mar 13 2020 at 16:26)</a>:</h4>
<p>I think the proof of unique choice in HoTT is similar to the lean proof of <code>[subsingleton A] : trunc A -&gt; A</code></p>

<a name="190528705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190528705" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190528705">Kevin Buzzard (Mar 13 2020 at 17:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260981">Pierre-Marie Pédrot</span> <a href="#narrow/stream/116395-maths/topic/Univalence/near/190512431" title="#narrow/stream/116395-maths/topic/Univalence/near/190512431">said</a>:</p>
<blockquote>
<p>There is no such thing as "true mathematics" so it doesn't make sense to ask our users to abide to a specific set of axioms.</p>
</blockquote>
<p><span class="user-mention" data-user-id="260981">@Pierre-Marie Pédrot</span> in my department the vast majority of us think ZFC is true mathematics, and I am certain that many other mathematics departments think the same way. The fact that logicians and computer scientists have invented a whole bunch more options and then decide to call them mathematics is problematic, because it means that discussions can degenerate into axiomatic issues which <em>as far as a mathematician is concerned</em> are completely solved. The axiom of choice is an axiom of maths as practiced in mathematics departments. Johan is absolutely right when he says that mathematicians are not interested in this stuff. You say</p>
<blockquote>
<p>... or maybe we can teach the mathematicians about computer science to make them understand it's not a sterile debate?</p>
</blockquote>
<p>but it is much <em>worse</em> than that -- it is not a sterile debate -- we finished debating 100 years ago and decided what mathematics was, and the fact that you guys are still arguing over it is of no interest to us. From your point of view this debate is very important, because if you want to design a new computer proof system than of course foundations are absolutely a major issue. But from a mathematician's point of view, ZFC works, constructivism doesn't work, ZF doesn't work, and these topics are not being studied in mathematics departments other than by a small niche group of people. We mathematicians are looking for a system where we can <em>reason the way we reason on paper</em> and having tried several systems I currently believe that Lean 3 is the closest we have to this; I can name explicit problems with every other system, either of the form "not enough foundations yet" or "can't do some part of modern mathematics in a way which is practical". For Coq it is "quotients", which are absolutely everywhere in modern mathematics.</p>
<blockquote>
<p>Once again, I think we should turn to programming engineering to draw inspiration. </p>
</blockquote>
<p>We mathematicians cannot turn to programming languages to draw inspiration because for you guys it's really important to have lots of different programming languages, because different languages are good at different things. We are attempting to make one coherent body of mathematics, and it's really important that everything is compatible with everything else. In particular every paper in number theory has to be accessible to me if I am a number theorist so it's really important that they all have the same foundations, and these foundations are decided -- they are ZFC -- and sure, add universes if you like, it doesn't matter, because it turns out that the kind of mathematics we do can sometimes be made easier with universes but we actually know tricks to get it back into ZFC. But we will not settle for anything less. LEM and AC are <em>embedded</em>. We are not going back.</p>
<blockquote>
<p>And FTR I don't really care about the sympathy of mathematicians. I have enough "real math" friends of mine who make fun of type theory and computer assistants. It's a social issue, not a technical one.</p>
</blockquote>
<p>What I am trying to do in Lean is to bring mathematicians in and get them using this software. In particular I need to <em>hide</em> type theory if I want to get them to use computer assistants. It is a social issue and it is one which I think is extremely important, but we as proof assistant users need to tread carefully when attracting mathematicians into the area. I simply tell mathematicians that a type is a set where the elements aren't necessarily sets any more but could just be "atoms", and suggest that actually this is the way they think about stuff they call sets. </p>
<p>I want to meet computer scientists "half way" and so I can have some dialogue with them about the future of these sytems -- but there are some ground rules, and AC and LEM and noncomputability are part of them. Any suggestion that a system which doesn't have them can be used to do modern mathematics is ridiculous to our ears, so the conversation cannot even start. This is why I use Lean and this is why I tell other mathematicians to use Lean.</p>

<a name="190536491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190536491" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190536491">Pierre-Marie Pédrot (Mar 13 2020 at 18:06)</a>:</h4>
<blockquote>
<p>LEM and AC are embedded. We are not going back.</p>
</blockquote>
<p>This is great, because that's what some people in the community are trying to provide in type theory in a way that <em>actually works</em>. Disclaimer: I am one of those, and I am not advocating against EM + AC. I am just constantly disappointed by the lack of consideration from mathematicians on the topic of foundations. And I am not saying that anybody should turn into a type theorist, but at least that they should be <em>listened</em> to, which is very different.</p>
<p>So far, the logical choices of Lean are the dependent type theory equivalent of PHP. Yes, it <em>kind of works</em>, until you reach the size of Facebook and realize that you wrote your stuff on quicksand, and that disregard for foundational issues have a long term cost you'll only realize at that point. And now, they're switching parts of their code to ReasonML because the trade-off is long overdue.</p>
<blockquote>
<p>What I am trying to do in Lean is to bring mathematicians in and get them using this software.</p>
</blockquote>
<p>I am not complaining about that. It is better to use whatever proof assistant than nothing, and the state of a few areas of mathematics is depressing. Needing a Fields medal to dismiss a broken proof is not a great situation, if you ask me.</p>
<blockquote>
<p>What I am trying to do in Lean is to bring mathematicians in and get them using this software. In particular I need to hide type theory if I want to get them to use computer assistants. [...] actually this is the way they think about stuff they call sets.</p>
</blockquote>
<p>There is wide evidence that no mathematician ever uses ZFC anyways, so I don't think it's very hard to make them forget about sets, except maybe for some weird hilbertian fetichism.</p>
<blockquote>
<p>For Coq it is "quotients", which are absolutely everywhere in modern mathematics.</p>
</blockquote>
<p>I will call your bluff, because you keep spreading this lie around, and I am starting to be slightly annoyed. As demonstrated by <span class="user-mention" data-user-id="243878">@Gaëtan Gilbert</span> , it is perfectly possible to get quotients in Coq with the very same rules, if you opt-in for a broken feature that is hardwired in Lean. Even Santa Claus choice can be obtained by similar tricks. I have actually heard rumours that you didn't even try Coq thoroughly, and I even believe there is a written account of that. You don't have indeed to try everything out there to settle for a tool, and it's nice to see math users playing around with any type-theoretic proof assistant.</p>
<p>Yet, I am a type theorist and I would never not making random claims in some arbitrary area of mathematics.</p>
<p>But once again, I claim the minimal divergence of foundations between Lean and Coq are of little relevance to formalization of mathematics. From what I gather, Lean has not reached Gonthier's famous <em>wall of complexity</em>. By that, he means that a lot of a priori ridiculous technical impediments are paving the way to mathematical formalization. I am genuinely willing to see an actual large mathematical development in Lean, to satisfy my own computer scientist fetichism, namely <em>scalability</em>. It might be changing, but Coq proofs are still a cottage industry. Can Lean do better?</p>

<a name="190537829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190537829" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190537829">Sebastien Gouezel (Mar 13 2020 at 18:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260981">Pierre-Marie Pédrot</span> <a href="#narrow/stream/116395-maths/topic/Univalence/near/190536491" title="#narrow/stream/116395-maths/topic/Univalence/near/190536491">said</a>:</p>
<blockquote>
<p>As demonstrated by <span class="user-mention silent" data-user-id="243878">Gaëtan Gilbert</span> , it is perfectly possible to get quotients in Coq with the very same rules, if you opt-in for a broken feature that is hardwired in Lean. Even Santa Claus choice can be obtained by similar tricks.</p>
</blockquote>
<p>I don't think the question is whether they can be constructed in Coq. To an outsider to type theory like me, the systems are sufficiently similar that I have little doubt that something natural that can be made with one can be made with the other. The question is rather whether they are used in the libraries, i.e., if the main libraries with the software try to use a constructivist point of view, or don't care and go full classical right away. Here I can see a really different approach currently with the Coq and Lean communities. I think it is very healthy that different viewpoints are tried and put forward, but mathematicians will be more easily attracted to libraries that use choice and LEM from the very beginning, because it will sound more familiar to them.</p>

<a name="190537881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190537881" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190537881">Kevin Buzzard (Mar 13 2020 at 18:19)</a>:</h4>
<p>You are right about my Coq experience. I heard about this "setoid hell" from various people but I am certainly not an experienced Coq user. I will try and get some more concrete facts.</p>
<p>Mathematicians are <em>terrible</em> about foundations. It is not regarded as an interesting topic by most people, because "all the interesting questions were solved when forcing was invented" or something :-/ You are also right that we don't use ZFC in practice, however it is true that there is a general belief that whatever it is that we <em>are</em> doing, it is possible to translate it down to ZFC (and classical logic) in theory. My impression is that in the areas I am interested in (number theory, arithmetic geometry) it is possible to find people (they are rare, but they exist) who actually know how to do this, but it is not something which is deemed particularly important. Somehow the workers in each area know the API, and then a few people know how to get from the API to the foundations, but what is taught is the API.</p>
<p>I am not necessarily saying that Lean is the solution to everything. But I think it is close enough to being able to simulate the kind of mathematics done by mathematicians that it might be enough to get people interested in the theory in general. My general line of thought is this. Which system is best for modern mathematics? We don't really know. So let's try and get mathematicians actually making mathematics in as many systems as possible, because my impression is that when we get stuck the computer scientists are able to understand what the problem is and try to solve it. You know we have some typeclass problems in Lean 3, which I think were basically discovered because of mathematicians trying to push the system? Hopefully these will be fixed in Lean 4.</p>
<p>I guess it will take time before we have a large development. I guess we are working on mathlib as being this development?</p>

<a name="190538570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190538570" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190538570">Pierre-Marie Pédrot (Mar 13 2020 at 18:25)</a>:</h4>
<blockquote>
<p>mathematicians will be more easily attracted to libraries that use choice and LEM from the very beginning, because it will sound more familiar to them.</p>
</blockquote>
<p>I don't know why Coq has this aura of knife-between-their-teeth intuitionists in the mathematical community. Just as mathematicians, most computer scientists don't care at all about their foundations. Most serious computer science Coq developments I know of actually use classical axioms everywhere.</p>

<a name="190538936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190538936" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190538936">Kenny Lau (Mar 13 2020 at 18:28)</a>:</h4>
<p>Is knife-between-their-teeth a French phrase?</p>

<a name="190538946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190538946" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190538946">Kevin Buzzard (Mar 13 2020 at 18:29)</a>:</h4>
<p>It's clear what is meant :-)</p>

<a name="190539008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190539008" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190539008">Kenny Lau (Mar 13 2020 at 18:30)</a>:</h4>
<p>I actually wasn't able to infer it from context</p>

<a name="190539178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190539178" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190539178">Kevin Buzzard (Mar 13 2020 at 18:31)</a>:</h4>
<p>I remember one of the first things I noticed when reading the Coq odd order paper was that they said that the result was proved constructively, and I thought "what does that even _mean_?" (this was a few years ago before I knew the definition). And then later on they started explaining about how they couldn't use the complex numbers and I was totally speechless. I think it is more the issue that constructivism is simply not taught in mathematics departments, so we find anyone who talks about it slightly scary.</p>

<a name="190539317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190539317" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190539317">Kevin Buzzard (Mar 13 2020 at 18:32)</a>:</h4>
<p>I literally had no idea 5 years ago that the complex numbers were somehow illegal for some people.</p>

<a name="190539739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190539739" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190539739">Pierre-Marie Pédrot (Mar 13 2020 at 18:36)</a>:</h4>
<p>It's strange, because I am fairly sure mathcomp uses classical logic locally. Dually to Lean, they mark classical statements by quantifying over a proof of EM. Anyway, AFAIR it does not even matter for the odd order theorem since it's a negative statement, which are essentially equivalent in intuitionistic and classical logic.</p>

<a name="190539909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190539909" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190539909">Kevin Buzzard (Mar 13 2020 at 18:37)</a>:</h4>
<p>I guess the point is that all the constructions they used in the proof were also constructive.</p>

<a name="190539957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190539957" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190539957">Pierre-Marie Pédrot (Mar 13 2020 at 18:38)</a>:</h4>
<p>See Chapter 3.3 of <a href="https://math-comp.github.io/mcb/book.pdf" target="_blank" title="https://math-comp.github.io/mcb/book.pdf">https://math-comp.github.io/mcb/book.pdf</a>.</p>

<a name="190540204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190540204" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190540204">Sebastien Gouezel (Mar 13 2020 at 18:40)</a>:</h4>
<p>When I started with proof assistants (I wanted to do some measure theory), I tried both Coq and Isabelle and I gave up very quickly with Coq, one of the reasons being that in the standard library many files talking about the reals start with the word "Constructive".</p>

<a name="190540272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190540272" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190540272">Kevin Buzzard (Mar 13 2020 at 18:41)</a>:</h4>
<p>The link is just the sort of thing that mathematicians find intimidating. We do not teach decidability in any serious way; I think I met it once in the 2nd year logic course and then it was never mentioned again (and I am certain that my 3rd year lecturers did not know what it was). I learnt very quickly when talking to mathematicians about Lean that the moment you start mentioning these things they think you've become some kind of crank.</p>

<a name="190540494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190540494" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190540494">Kevin Buzzard (Mar 13 2020 at 18:43)</a>:</h4>
<p>I think this is the main reason I am so edgy about the univalence axiom. It starts with a discussion of univalence, and within minutes the conversation has either turned to elementary topoi (about which mathematicians know nothing), or constructivism (about which mathematicians know nothing), or some discussion about how things can be equal in more than one way (which just sounds like complete craziness). It is so far from what happens in practice in maths departments.</p>

<a name="190540708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190540708" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190540708">Pierre-Marie Pédrot (Mar 13 2020 at 18:45)</a>:</h4>
<blockquote>
<p>many files talking about the reals start with the word "Constructive"</p>
</blockquote>
<p>This is funny because precisely the Coq real library from stdlib is classical, to please the mathematicians. I guess merely uttering the word "constructive" is enough to deter mathematicians then...</p>

<a name="190541078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190541078" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190541078">Sebastien Gouezel (Mar 13 2020 at 18:48)</a>:</h4>
<p>Absolutely. Because it means, at some point, you will have to make some effort to stay constructive (otherwise, you wouldn't put the word constructive in the file name). So, the definition starts with some constructive stuff, and then goes classical. To me, if you can express a statement or a proof by remaining constructive but it requires 1% effort more, then it should be avoided (both for the library builder, and for the user who will have to skim the library), simply because there's no point. Maybe I am a little extreme there, but I think it is pretty reasonable in fact.</p>

<a name="190541281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190541281" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190541281">Johan Commelin (Mar 13 2020 at 18:50)</a>:</h4>
<p>On this forum, I can say that I see value of constructive maths (for example, constructive maths holds in any topos). But when I'm having lunch with my colleagues, they don't want to hear anything about giving up the C in ZFC. So yes:</p>
<blockquote>
<p>I guess merely uttering the word "constructive" is enough to deter mathematicians then...</p>
</blockquote>
<p>My goal is to get them engaged with proof assistants. And for that, mentioning the word "constructive" is quite often an unfortunate obstacle.</p>

<a name="190541439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190541439" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190541439">Pierre-Marie Pédrot (Mar 13 2020 at 18:52)</a>:</h4>
<p><span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> well, until very recently Coq reals were fully axiomatic, so there was not even a hint of constructivism in there. Now they're trying to have some subsystem that's constructive in order to plug into C-CoRN.</p>

<a name="190541485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190541485" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190541485">Bas Spitters (Mar 13 2020 at 18:52)</a>:</h4>
<p>Georges seem to take it as a matter of pride to make a constructive proof. Georges has a deep appreciation for the use of computation to proof mathematical theorems.</p>

<a name="190541631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190541631" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190541631">Kevin Buzzard (Mar 13 2020 at 18:54)</a>:</h4>
<p>I am wondering whether the mathlib people take pride in the fact that the development is 100% axiom-free. Sure we use Lean's inbuilt axioms (because this is just "maths mode") but there are no instances where we build a mathematical object by just adding axioms.</p>

<a name="190541639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190541639" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190541639">Pierre-Marie Pédrot (Mar 13 2020 at 18:54)</a>:</h4>
<p>Somewhat unrelated to the discussion, but <span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> we could try to have more discussions on the topic in person, we're just one building away IIUC... (when they reopen the uni, that is.)</p>

<a name="190541801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190541801" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190541801">Bas Spitters (Mar 13 2020 at 18:56)</a>:</h4>
<p>There is now a substantial development of constructive measure theory in Coq. Following Bishop, who was a great functional analyst.<br>
<a href="https://github.com/coq/coq/pull/9185" target="_blank" title="https://github.com/coq/coq/pull/9185">https://github.com/coq/coq/pull/9185</a><br>
The classical theorems are then derived quickly from the constructive ones. One does not <em>need</em> to do it that way, but some people appreciate it.</p>

<a name="190541924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190541924" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190541924">Pierre-Marie Pédrot (Mar 13 2020 at 18:57)</a>:</h4>
<blockquote>
<p>they don't want to hear anything about giving up the C in ZFC.</p>
</blockquote>
<p>One of the advantages of type theory is that they are finer-grained than sets, and that it's easier to understand what is what. The usual joke on the understandability of choice vs. Zorn vs. well-ordering makes sense there. CIC validates choice phrased as "you can pick elements of existentials".</p>

<a name="190542453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190542453" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190542453">Sebastien Gouezel (Mar 13 2020 at 19:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260981">Pierre-Marie Pédrot</span> <a href="#narrow/stream/116395-maths/topic/Univalence/near/190541639" title="#narrow/stream/116395-maths/topic/Univalence/near/190541639">said</a>:</p>
<blockquote>
<p>Somewhat unrelated to the discussion, but <span class="user-mention silent" data-user-id="110050">Sebastien Gouezel</span> we could try to have more discussions on the topic in person, we're just one building away IIUC... (when they reopen the uni, that is.)</p>
</blockquote>
<p>Definitely! In May or June, maybe :-)</p>

<a name="190542603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190542603" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190542603">Johan Commelin (Mar 13 2020 at 19:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260981">Pierre-Marie Pédrot</span> <a href="#narrow/stream/116395-maths/topic/Univalence/near/190541924" title="#narrow/stream/116395-maths/topic/Univalence/near/190541924">said</a>:</p>
<blockquote>
<p>One of the advantages of type theory is that they are finer-grained than sets, and that it's easier to understand what is what. The usual joke on the understandability of choice vs. Zorn vs. well-ordering makes sense there. CIC validates choice phrased as "you can pick elements of existentials".</p>
</blockquote>
<p>That's a good point. Thanks for pointing it out! Still, it's only useful for mathematicians if you can also have transport (not only along equiv's, but also other isos) and have a sizable library of "basic maths".</p>

<a name="190542731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190542731" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190542731">Bas Spitters (Mar 13 2020 at 19:05)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> Peter Johnstone once wrote an apology for locale theory, and the benefits of working classically, but without choice.<br>
The point of pointless topology<br>
<a href="https://projecteuclid.org/euclid.bams/1183550014" target="_blank" title="https://projecteuclid.org/euclid.bams/1183550014">https://projecteuclid.org/euclid.bams/1183550014</a><br>
Choice is only used to construct the points of a locale. The locale it self can be constructed without choice. The use of the axiom of choice is a choice.<br>
This has applications in e.g. functional analysis.</p>

<a name="190543323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190543323" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190543323">Bas Spitters (Mar 13 2020 at 19:12)</a>:</h4>
<p><span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> I had a quick look at your homepage. <br>
<a href="https://www.math.sciences.univ-nantes.fr/~gouezel/" target="_blank" title="https://www.math.sciences.univ-nantes.fr/~gouezel/">https://www.math.sciences.univ-nantes.fr/~gouezel/</a><br>
You seem to be working in a beautiful part of analysis that is not very structural, i.e. somewhat distanced from say functional analysis.<br>
Moreover, does not seem to be very computational/numerical.<br>
So, constructive methods may be less natural to you.</p>

<a name="190543609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190543609" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190543609">Patrick Massot (Mar 13 2020 at 19:14)</a>:</h4>
<p><span aria-label="open mouth" class="emoji emoji-1f62e" role="img" title="open mouth">:open_mouth:</span>  I think this is the first I see anyone claiming to know which part of mathematics Sébastien works in.</p>

<a name="190543694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190543694" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190543694">Bas Spitters (Mar 13 2020 at 19:15)</a>:</h4>
<p>About the Hausdorff metric. My PhD-student once used it to make a 1980-style graphical calculator which was provably correct. The printing of graphs of functions was done using the Coq notation system.<br>
<a href="https://www3.risc.jku.at/publications/download/risc_3448/SCSS2008_Proceedings.pdf" target="_blank" title="https://www3.risc.jku.at/publications/download/risc_3448/SCSS2008_Proceedings.pdf">https://www3.risc.jku.at/publications/download/risc_3448/SCSS2008_Proceedings.pdf</a><br>
Russell O’Connor. A Computer Verified Theory of Compact Sets. SCSS 2008, RISC-Linz Report Series 08–08: 148–162, Jul 2008, Proceedings</p>

<a name="190543823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190543823" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190543823">Sebastien Gouezel (Mar 13 2020 at 19:16)</a>:</h4>
<p>I use a lot of functional analysis (in the sense of operator theory on spaces of functions, so with concrete applications to other problems in mind), but not on the abstract side of things (I know what a trace on a C^* algebra is, but I don't use them in my research). So, I am away from the finite world (where decidable methods are appealing because they can let you compute for free on examples), and away from the more abstract sides (higher homotopy theory for instance) where foundational discussions become relevant. So yes, I am definitely biased away from these questions. But I guess that this is also the case of maybe 90% working mathematicians.</p>

<a name="190543885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190543885" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190543885">Bas Spitters (Mar 13 2020 at 19:17)</a>:</h4>
<p>While I'm at it. One can use constructive analysis to do certified computation with classical real numbers:<br>
Cezary Kaliszyk and Russell O’Connor. Computing with Classical Real Numbers. Journal of Formalized Reasoning, Vol. 2, No. 1, 2009, Pages 27–29<br>
<a href="http://jfr.cib.unibo.it/article/view/1411/932" target="_blank" title="http://jfr.cib.unibo.it/article/view/1411/932">http://jfr.cib.unibo.it/article/view/1411/932</a></p>
<p>How does one prove in lean that:<br>
pi ~ 3.14159265359  ?</p>

<a name="190543958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190543958" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190543958">Johan Commelin (Mar 13 2020 at 19:18)</a>:</h4>
<p>We can only do the first 4 digits (-;</p>

<a name="190544021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190544021" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190544021">Johan Commelin (Mar 13 2020 at 19:18)</a>:</h4>
<p>Maybe we pushed till 7 digits, on last years Pi-day</p>

<a name="190544039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190544039" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190544039">Bas Spitters (Mar 13 2020 at 19:19)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> So, that's one reason you should have used constructive reals :-)</p>

<a name="190544183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190544183" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190544183">Johan Commelin (Mar 13 2020 at 19:20)</a>:</h4>
<p>Or we just need some tactic that can spit out proofs.</p>

<a name="190544206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190544206" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190544206">Bas Spitters (Mar 13 2020 at 19:20)</a>:</h4>
<p>Arguably, one can also connect with interval computation "by hand", as in the impressive work by Fabian Immler in Isabelle to prove that the Lorentz attractor is chaotic</p>

<a name="190544266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190544266" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190544266">Patrick Massot (Mar 13 2020 at 19:21)</a>:</h4>
<p>I really don't understand that bit. Say I prove some series <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">\sum a_n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> of rational numbers converges to pi. I can do this 100% classically. And then I prove an estimate on the remainder <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∑</mo><mrow><mi>n</mi><mo>≥</mo><mi>N</mi></mrow></msub><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">\sum_{n\geq N} a_n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.144889em;vertical-align:-0.39488900000000005em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.17862099999999992em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mrel mtight">≥</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.39488900000000005em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>. Then I can prove the first <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> digits are correct. Where do I need anything constructive as long as I can prove all this and compute with rational numbers?</p>

<a name="190545052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190545052" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190545052">Bas Spitters (Mar 13 2020 at 19:28)</a>:</h4>
<p>For most of basic analysis such proofs would be naturally constructive, and one would combine the proof of convergence with the estimate on the remainder.<br>
You are right, it is not needed to do so.</p>

<a name="190545122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190545122" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190545122">Sebastien Gouezel (Mar 13 2020 at 19:29)</a>:</h4>
<p>In Isabelle, which is completely non-constructive but more mature, you would prove it with</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">ineq3</span><span class="o">:</span>
  <span class="s2">&quot;(pi :: real) ≤ 3.141592658&quot;</span>
<span class="k">by</span> <span class="o">(</span><span class="n">approximation</span> <span class="mi">40</span><span class="o">)</span>
</pre></div>


<p>where <code>approximation</code> is a tactic that will do all the dirty interval arithmetic for you.</p>

<a name="190546148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190546148" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190546148">Chris Hughes (Mar 13 2020 at 19:38)</a>:</h4>
<p>So my understanding is that if I had a constructive proof of convergence of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">\sum a_n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, then given some <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span> I could compute <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>, such that the sum of the first <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> terms was within <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span>. But the problem with this is that it means whenever I do a continuity proof or a convergence proof I will have to think about providing a minimal <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span></span></span></span> or a minimal <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>, in order to make sure the computation time was reasonable, but often with the standard proofs, you'll end up computing an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> way bigger than it really needs to be and not really practical to compute with.</p>
<p>Does an unfolded proof of convergence actually provide a practical way of approximating the limit most of the time?</p>

<a name="190546360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190546360" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190546360">Bas Spitters (Mar 13 2020 at 19:40)</a>:</h4>
<p><span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> Coq has a similar package:<br>
<a href="http://coq-interval.gforge.inria.fr/" target="_blank" title="http://coq-interval.gforge.inria.fr/">http://coq-interval.gforge.inria.fr/</a></p>

<a name="190546551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190546551" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190546551">Sebastien Gouezel (Mar 13 2020 at 19:42)</a>:</h4>
<p>Yes I am not surprised: Coq and Isabelle are much more mature than Lean, so most things that should be there are already there.</p>

<a name="190546873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190546873" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190546873">Bas Spitters (Mar 13 2020 at 19:45)</a>:</h4>
<p><span class="user-mention" data-user-id="110044">@Chris Hughes</span>  With a bit of engineering this can be made practical. However, with epsilon-delta proofs one is computing backwards from the precision of the result to the precision of the input.<br>
For optimal speed, one wants to compute forwards: start with a small interval see whether the result is precise enough. If not, start over with double precision. This is what IRRAM does:<br>
<a href="https://github.com/norbert-mueller/iRRAM" target="_blank" title="https://github.com/norbert-mueller/iRRAM">https://github.com/norbert-mueller/iRRAM</a><br>
I believe mathematica does something similar.</p>

<a name="190555005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Univalence/near/190555005" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55691Univalence.html#190555005">Bas Spitters (Mar 13 2020 at 21:08)</a>:</h4>
<p>Hoping I wasn't too zealous, I just wanted to point out that constructive mathematics has its uses in the formalization of mathematics, even if one is not a diehard constructivist.</p>


{% endraw %}

{% include archive_update.html %}