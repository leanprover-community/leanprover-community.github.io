---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/116395maths/96400quotientsandliftsforfunctionsofarbitraryarity.html
---

## Stream: [maths](index.html)
### Topic: [quotients and lifts for functions of arbitrary arity](96400quotientsandliftsforfunctionsofarbitraryarity.html)

---


{% raw %}
#### [ William DeMeo (Dec 02 2018 at 05:31)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotients%20and%20lifts%20for%20functions%20of%20arbitrary%20arity/near/150709555):
<p>I'm trying to learn how to implement general quotient structures.  Unfortunately, I've only been able to figure out how to lift unary operations.  How does one lift operations of arbitrary arity?</p>
<p>More specifically, here's what I'm trying to do. </p>
<p>Given a type <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.0037em;">α</span></span></span></span>, and an "arity" type <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ρ</mi></mrow><annotation encoding="application/x-tex">\rho</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit">ρ</span></span></span></span>, an operation on <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.0037em;">α</span></span></span></span> of arity <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ρ</mi></mrow><annotation encoding="application/x-tex">\rho</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit">ρ</span></span></span></span> has the following type signature:<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>:</mo><mo>(</mo><mi>ρ</mi><mo>→</mo><mi>α</mi><mo>)</mo><mo>→</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">f : (\rho \to \alpha) \to \alpha</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mrel">:</span><span class="mopen">(</span><span class="mord mathit">ρ</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.0037em;">α</span><span class="mclose">)</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.0037em;">α</span></span></span></span>. </p>
<p>Now suppose I have an equivalence relation <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>:</mo><mi>α</mi><mo>→</mo><mi>α</mi><mo>→</mo><mrow><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">r</mi><mi mathvariant="sans-serif">o</mi><mi mathvariant="sans-serif">p</mi></mrow></mrow><annotation encoding="application/x-tex">r : \alpha \to \alpha \to \mathsf{Prop}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mrel">:</span><span class="mord mathit" style="margin-right:0.0037em;">α</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.0037em;">α</span><span class="mrel">→</span><span class="mord"><span class="mord mathsf">P</span><span class="mord mathsf" style="margin-right:0.01389em;">r</span><span class="mord mathsf">o</span><span class="mord mathsf">p</span></span></span></span></span>, and I want to lift <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span></span> to a <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ρ</mi></mrow><annotation encoding="application/x-tex">\rho</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit">ρ</span></span></span></span>-ary operation <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><mi>f</mi></mrow><mo>~</mo></mover><mo>:</mo><mo>(</mo><mi>ρ</mi><mo>→</mo><mi>α</mi><mi mathvariant="normal">/</mi><mi>r</mi><mo>)</mo><mo>→</mo><mi>α</mi><mi mathvariant="normal">/</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">\tilde{f} : (\rho \to \alpha/r) \to \alpha/r</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.9312999999999998em;"></span><span class="strut bottom" style="height:1.1812999999999998em;vertical-align:-0.25em;"></span><span class="base"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9312999999999998em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span><span style="top:-3.61344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="margin-left:0.33334em;"><span>~</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"></span></span></span></span><span class="mrel">:</span><span class="mopen">(</span><span class="mord mathit">ρ</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.0037em;">α</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.0037em;">α</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.02778em;">r</span></span></span></span>.  That is, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><mi>f</mi></mrow><mo>~</mo></mover></mrow><annotation encoding="application/x-tex">\tilde{f}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.9312999999999998em;"></span><span class="strut bottom" style="height:1.1257399999999997em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9312999999999998em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span><span style="top:-3.61344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="margin-left:0.33334em;"><span>~</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"></span></span></span></span></span></span></span> should be a <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ρ</mi></mrow><annotation encoding="application/x-tex">\rho</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit">ρ</span></span></span></span>-ary operation on the quotient <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi><mi mathvariant="normal">/</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">\alpha / r</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.0037em;">α</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.02778em;">r</span></span></span></span>.  It's obvious how to express this mathematically:</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><mi>f</mi></mrow><mo>~</mo></mover><mo>(</mo><mi>a</mi><mi mathvariant="normal">/</mi><mo>[</mo><mo>[</mo><mi>r</mi><mo>]</mo><mo>]</mo><mo>)</mo><mo>=</mo><mo>(</mo><mi>f</mi><mi>a</mi><mo>)</mo><mi mathvariant="normal">/</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">\tilde{f} (a/[[r]]) = (f a)/r</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.9312999999999998em;"></span><span class="strut bottom" style="height:1.1812999999999998em;vertical-align:-0.25em;"></span><span class="base"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9312999999999998em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span><span style="top:-3.61344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="margin-left:0.33334em;"><span>~</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"></span></span></span></span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mord mathrm">/</span><span class="mopen">[</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mclose">]</span><span class="mclose">)</span><span class="mrel">=</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mathit">a</span><span class="mclose">)</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.02778em;">r</span></span></span></span>,</p>
<p>where <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mo>[</mo><mi>r</mi><mo>]</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">[[ r ]]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">[</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mclose">]</span></span></span></span> is the binary relation on <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ρ</mi><mo>→</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">\rho \to \alpha</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit">ρ</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.0037em;">α</span></span></span></span> induced by <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">r</span></span></span></span>.  That is, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mstyle><mo>[</mo><mo>[</mo><mi>r</mi><mo>]</mo><mo>]</mo></mstyle><mi>b</mi></mrow><annotation encoding="application/x-tex">a \mathrel{[[ r ]]} b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">a</span><span class="mrel"><span class="mopen">[</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mclose">]</span></span><span class="mord mathit">b</span></span></span></span> iff <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∀</mi><mi>i</mi><mo separator="true">,</mo><mo>(</mo><mi>a</mi><mi>i</mi><mo>)</mo><mstyle><mi>r</mi></mstyle><mo>(</mo><mi>b</mi><mi>i</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\forall i, (a i) \mathrel{r} (b i)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathrm">∀</span><span class="mord mathit">i</span><span class="mpunct">,</span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mord mathit">i</span><span class="mclose">)</span><span class="mrel"><span class="mord mathit" style="margin-right:0.02778em;">r</span></span><span class="mopen">(</span><span class="mord mathit">b</span><span class="mord mathit">i</span><span class="mclose">)</span></span></span></span>.  </p>
<p>For example, if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span></span> is <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">n</span></span></span></span>-ary, then <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><mi>f</mi></mrow><mo>~</mo></mover></mrow><annotation encoding="application/x-tex">\tilde{f}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.9312999999999998em;"></span><span class="strut bottom" style="height:1.1257399999999997em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9312999999999998em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span><span style="top:-3.61344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="margin-left:0.33334em;"><span>~</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"></span></span></span></span></span></span></span> maps an <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">n</span></span></span></span>-tuple <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>a</mi><mn>0</mn></msub><mi mathvariant="normal">/</mi><mi>r</mi><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>a</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mi mathvariant="normal">/</mi><mi>r</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(a_0/r, \ldots, a_{n-1}/r)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">(</span><span class="mord"><span class="mord mathit">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="minner">…</span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">n</span><span class="mbin mtight">−</span><span class="mord mathrm mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"></span></span></span></span></span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span> of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">r</span></span></span></span>-classes to the <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">r</span></span></span></span>-class <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><msub><mi>a</mi><mn>0</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>a</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>)</mo><mi mathvariant="normal">/</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">f(a_0, \ldots, a_{n-1})/r</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mpunct">,</span><span class="minner">…</span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">n</span><span class="mbin mtight">−</span><span class="mord mathrm mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"></span></span></span></span></span><span class="mclose">)</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.02778em;">r</span></span></span></span>.</p>
<p>I got this to work when <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span></span> is unary (so, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>:</mo><mi>α</mi><mo>→</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">f : \alpha \to \alpha</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mrel">:</span><span class="mord mathit" style="margin-right:0.0037em;">α</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.0037em;">α</span></span></span></span>), by first defining the projection <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>π</mi><mi>f</mi><mo>:</mo><mi>α</mi><mo>→</mo><mi>α</mi><mi mathvariant="normal">/</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">\pi f : \alpha \to \alpha/r</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.03588em;">π</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mrel">:</span><span class="mord mathit" style="margin-right:0.0037em;">α</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.0037em;">α</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.02778em;">r</span></span></span></span> as <code>quot.mk r (f a)</code>, and then using the built in <code>quot.lift</code>, defined in quot.lean of the standard library.  (The code for that is below, but it's not pretty.)</p>
<p>Unfortunately, this doesn't work for higher arity operations because quot.lift expects a relation <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>:</mo><mi>α</mi><mo>→</mo><mi>α</mi><mo>→</mo><mrow><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">r</mi><mi mathvariant="sans-serif">o</mi><mi mathvariant="sans-serif">p</mi></mrow></mrow><annotation encoding="application/x-tex">r : \alpha \to \alpha \to \mathsf{Prop}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mrel">:</span><span class="mord mathit" style="margin-right:0.0037em;">α</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.0037em;">α</span><span class="mrel">→</span><span class="mord"><span class="mord mathsf">P</span><span class="mord mathsf" style="margin-right:0.01389em;">r</span><span class="mord mathsf">o</span><span class="mord mathsf">p</span></span></span></span></span> and a proof of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∀</mi><mi>a</mi><mi>b</mi><mo separator="true">,</mo><mi>a</mi><mstyle><mi>r</mi></mstyle><mi>b</mi><mo>→</mo><mo>(</mo><mi>f</mi><mi>a</mi><mo>)</mo><mi mathvariant="normal">/</mi><mi>r</mi><mo>=</mo><mo>(</mo><mi>f</mi><mi>b</mi><mo>)</mo><mi mathvariant="normal">/</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">\forall a b,  a \mathrel{ r } b \to (f a)/r = (f b)/r</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathrm">∀</span><span class="mord mathit">a</span><span class="mord mathit">b</span><span class="mpunct">,</span><span class="mord mathit">a</span><span class="mrel"><span class="mord mathit" style="margin-right:0.02778em;">r</span></span><span class="mord mathit">b</span><span class="mrel">→</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mathit">a</span><span class="mclose">)</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mrel">=</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mathit">b</span><span class="mclose">)</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.02778em;">r</span></span></span></span>.  But in the higher arity case, to say that the operation  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>:</mo><mo>(</mo><mi>ρ</mi><mo>→</mo><mi>α</mi><mo>)</mo><mo>→</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">f : (\rho \to \alpha) \to \alpha</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mrel">:</span><span class="mopen">(</span><span class="mord mathit">ρ</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.0037em;">α</span><span class="mclose">)</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.0037em;">α</span></span></span></span> "respects" <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">r</span></span></span></span> means the following:</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∀</mi><mo>(</mo><mi>a</mi><mi>b</mi><mo>:</mo><mi>ρ</mi><mo>→</mo><mi>α</mi><mo>)</mo><mo separator="true">,</mo><mo>(</mo><mi mathvariant="normal">∀</mi><mi>i</mi><mo separator="true">,</mo><mi>r</mi><mo>(</mo><mi>a</mi><mi>i</mi><mo>)</mo><mo>(</mo><mi>b</mi><mi>i</mi><mo>)</mo><mo>)</mo><mo>→</mo><mo>(</mo><mi>f</mi><mi>a</mi><mo>)</mo><mi mathvariant="normal">/</mi><mi>r</mi><mo>=</mo><mo>(</mo><mi>f</mi><mi>b</mi><mo>)</mo><mi mathvariant="normal">/</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">\forall (a b : \rho \to \alpha), (\forall i, r (a i) (b i)) \to (f a)/r = (f b)/r</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathrm">∀</span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mord mathit">b</span><span class="mrel">:</span><span class="mord mathit">ρ</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.0037em;">α</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mopen">(</span><span class="mord mathrm">∀</span><span class="mord mathit">i</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mord mathit">i</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathit">b</span><span class="mord mathit">i</span><span class="mclose">)</span><span class="mclose">)</span><span class="mrel">→</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mathit">a</span><span class="mclose">)</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mrel">=</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mathit">b</span><span class="mclose">)</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.02778em;">r</span></span></span></span></p>
<p>If you provide quot.lift with that as the proof of "respecting r", the resulting lift will not be what we want.</p>
<p>Any ideas, pointers, suggestions would be much appreciated.  Thanks!</p>
<p>Here's the code for the unary case.  There's probably an easier way to do this, and suggestions are welcome... but I'm more interested in the general case.</p>
<div class="codehilite"><pre><span></span>  <span class="kn">parameters</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">ρ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="n">local</span> <span class="kn">notation</span> <span class="n">a</span><span class="bp">`/`</span><span class="n">r</span> <span class="o">:=</span> <span class="n">quot</span><span class="bp">.</span><span class="n">mk</span> <span class="n">r</span> <span class="n">a</span>

  <span class="n">def</span> <span class="n">π</span><span class="err">ᵤ</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">quot</span> <span class="n">r</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="bp">/</span> <span class="n">r</span>

  <span class="n">def</span> <span class="n">compatible_unary</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">r</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">r</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">b</span><span class="o">)</span>

  <span class="kn">lemma</span> <span class="n">resp_proj_of_compatible_unary</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">compatible_unary</span> <span class="n">f</span> <span class="n">r</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">r</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">→</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span><span class="bp">/</span><span class="n">r</span> <span class="bp">=</span> <span class="o">(</span><span class="n">f</span> <span class="n">b</span><span class="o">)</span><span class="bp">/</span><span class="n">r</span> <span class="o">:=</span>
  <span class="k">assume</span> <span class="n">a</span> <span class="n">b</span> <span class="o">(</span><span class="n">h₀</span> <span class="o">:</span> <span class="n">r</span> <span class="n">a</span> <span class="n">b</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">h₃</span> <span class="o">:</span> <span class="n">r</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">b</span><span class="o">),</span> <span class="k">from</span> <span class="n">h</span> <span class="n">a</span> <span class="n">b</span> <span class="n">h₀</span><span class="o">,</span>
  <span class="k">show</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span><span class="bp">/</span><span class="n">r</span> <span class="bp">=</span> <span class="o">(</span><span class="n">f</span> <span class="n">b</span><span class="o">)</span><span class="bp">/</span><span class="n">r</span><span class="o">,</span> <span class="k">from</span> <span class="n">quot</span><span class="bp">.</span><span class="n">sound</span> <span class="n">h₃</span>

  <span class="n">def</span> <span class="n">lift_proj</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">compatible_unary</span> <span class="n">f</span> <span class="n">r</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">quot</span> <span class="n">r</span> <span class="bp">→</span> <span class="n">quot</span> <span class="n">r</span> <span class="o">:=</span>
  <span class="n">quot</span><span class="bp">.</span><span class="n">lift</span> <span class="o">(</span><span class="n">π</span><span class="err">ᵤ</span>  <span class="n">f</span> <span class="n">r</span><span class="o">)</span> <span class="o">(</span><span class="n">resp_proj_of_compatible_unary</span> <span class="n">f</span> <span class="n">r</span> <span class="n">h</span><span class="o">)</span>
</pre></div>

#### [ Chris Hughes (Dec 02 2018 at 07:17)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotients%20and%20lifts%20for%20functions%20of%20arbitrary%20arity/near/150712210):
<p>One way of doing this is to put a relation on <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ρ</mi><mo>→</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">\rho \rightarrow \alpha</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit">ρ</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.0037em;">α</span></span></span></span> defined as <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>λ</mi><mi>x</mi><mi>y</mi><mo separator="true">,</mo><mi mathvariant="normal">∀</mi><mi>a</mi><mo>:</mo><mi>α</mi><mo separator="true">,</mo><mi>r</mi><mo>(</mo><mi>x</mi><mo>(</mo><mi>a</mi><mo>)</mo><mo>)</mo><mo>(</mo><mi>y</mi><mo>(</mo><mi>a</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">\lambda x y, \forall a : \alpha, r (x (a)) (y( a))</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">λ</span><span class="mord mathit">x</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mord mathrm">∀</span><span class="mord mathit">a</span><span class="mrel">:</span><span class="mord mathit" style="margin-right:0.0037em;">α</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mclose">)</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>. I don't think you can define a function of this type <code>quotient.lift_onₙ (x : Π a : α, quotient (s a)) 
  (f : (Π a : α, β a) → γ) (h : ∀ x₁ x₂ : Π a, β a, 
  (∀ a, x₁ a ≈ x₂ a) → f x₁ = f x₂) : γ</code> without choice though. There is something in <code>data.fintype</code> that let's you do it computably when your indexing type is finite, but the fact that that's only defined on fintypes suggestsit might not be possible on infinite types.</p>

#### [ Reid Barton (Dec 02 2018 at 16:08)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotients%20and%20lifts%20for%20functions%20of%20arbitrary%20arity/near/150725987):
<p><span class="user-mention" data-user-id="111050">@William DeMeo</span> You can use <code>quotient.choice</code> in mathlib to turn a product of quotients into a quotient of the product, and then <code>lift</code> on that to define a function.</p>

#### [ Reid Barton (Dec 02 2018 at 16:09)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotients%20and%20lifts%20for%20functions%20of%20arbitrary%20arity/near/150725999):
<p>As far as I know you can't do this computably/without axioms, though it would be possible to implement by extending Lean.</p>

#### [ Kevin Buzzard (Dec 02 2018 at 16:11)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotients%20and%20lifts%20for%20functions%20of%20arbitrary%20arity/near/150726048):
<p>By "without axioms" you just mean "without some standard axioms which are inbuilt into Lean but which break computability", right?</p>

#### [ Reid Barton (Dec 02 2018 at 16:12)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotients%20and%20lifts%20for%20functions%20of%20arbitrary%20arity/near/150726086):
<p>Yes</p>

#### [ William DeMeo (Dec 02 2018 at 17:07)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotients%20and%20lifts%20for%20functions%20of%20arbitrary%20arity/near/150727665):
<p><span class="user-mention" data-user-id="110044">@Chris Hughes</span> Great, thanks for the hints!  I will look at data.fintype.  I'd like to be able to do this <em>computably</em> at least for finitary operations.  (By the way, just to be sure I understand your suggestions, I think you meant to put <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ρ</mi></mrow><annotation encoding="application/x-tex">\rho</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit">ρ</span></span></span></span> in place of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.0037em;">α</span></span></span></span> in the two places where <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.0037em;">α</span></span></span></span> appears... correct?)  Thanks again for your help!</p>

#### [ Chris Hughes (Dec 02 2018 at 17:08)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotients%20and%20lifts%20for%20functions%20of%20arbitrary%20arity/near/150727708):
<p>Yes I did mean to put rho instead of alpha</p>

#### [ William DeMeo (Dec 02 2018 at 17:11)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotients%20and%20lifts%20for%20functions%20of%20arbitrary%20arity/near/150727794):
<blockquote>
<p><span class="user-mention" data-user-id="111050">@William DeMeo</span> You can use <code>quotient.choice</code> in mathlib to turn a product of quotients into a quotient of the product, and then <code>lift</code> on that to define a function.</p>
</blockquote>
<p>Thanks <span class="user-mention" data-user-id="110032">@Reid Barton</span> , maybe I'll try that if after I get it to work computably for fintype.</p>

#### [ Reid Barton (Dec 02 2018 at 17:12)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotients%20and%20lifts%20for%20functions%20of%20arbitrary%20arity/near/150727839):
<p><a href="https://github.com/leanprover/mathlib/commit/ddbb81389b6d6cd3d0395f474896dcd59e1ed9e4" target="_blank" title="https://github.com/leanprover/mathlib/commit/ddbb81389b6d6cd3d0395f474896dcd59e1ed9e4">https://github.com/leanprover/mathlib/commit/ddbb81389b6d6cd3d0395f474896dcd59e1ed9e4</a></p>

#### [ Reid Barton (Dec 02 2018 at 17:12)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotients%20and%20lifts%20for%20functions%20of%20arbitrary%20arity/near/150727841):
<p>added both <code>quotient.choice</code> and a computable <code>finset</code> version</p>

#### [ William DeMeo (Dec 02 2018 at 18:07)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotients%20and%20lifts%20for%20functions%20of%20arbitrary%20arity/near/150729558):
<blockquote>
<p>added both <code>quotient.choice</code> and a computable <code>finset</code> version</p>
</blockquote>
<p>Awesome!  Thanks <span class="user-mention" data-user-id="110032">@Reid Barton</span>  I'll see if I can use those types to do exactly what I want.  If not, I'll have to roll my own, but it's good to see these examples that show how things should be done.</p>


{% endraw %}
