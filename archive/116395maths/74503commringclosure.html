---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/116395maths/74503commringclosure.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html">comm_ring.closure</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="135495590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135495590" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135495590">Patrick Massot (Oct 09 2018 at 20:16)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> Do you secretely have <code>comm_ring.closure</code> with a <code>subring</code> instance somewhere in your repositories?</p>

<a name="135495611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135495611" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135495611">Kenny Lau (Oct 09 2018 at 20:16)</a>:</h4>
<p>I don't think so.</p>

<a name="135495859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135495859" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135495859">Patrick Massot (Oct 09 2018 at 20:19)</a>:</h4>
<p>Too bad. Do you want to sprint through it?</p>

<a name="135495873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135495873" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135495873">Kenny Lau (Oct 09 2018 at 20:19)</a>:</h4>
<p>sure</p>

<a name="135495989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135495989" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135495989">Patrick Massot (Oct 09 2018 at 20:20)</a>:</h4>
<p>I began with</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">subring</span>

<span class="kn">namespace</span> <span class="n">group</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">α</span><span class="o">]</span>
<span class="kn">theorem</span> <span class="n">exists_list_of_mem_closure</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">closure</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∃</span><span class="n">l</span><span class="o">:</span><span class="n">list</span> <span class="n">α</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span><span class="n">x</span><span class="err">∈</span><span class="n">l</span><span class="o">,</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">s</span> <span class="bp">∨</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="err">∈</span> <span class="n">s</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">l</span><span class="bp">.</span><span class="n">prod</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">induction</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">case</span> <span class="n">in_closure</span><span class="bp">.</span><span class="n">basic</span> <span class="o">:</span> <span class="n">a</span> <span class="n">ha</span> <span class="o">{</span> <span class="n">existsi</span> <span class="o">([</span><span class="n">a</span><span class="o">]),</span> <span class="n">simp</span> <span class="o">[</span><span class="n">ha</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">case</span> <span class="n">in_closure</span><span class="bp">.</span><span class="n">one</span> <span class="o">{</span> <span class="n">existsi</span> <span class="o">([]),</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="n">case</span> <span class="n">in_closure</span><span class="bp">.</span><span class="n">mul</span> <span class="o">:</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">ha</span> <span class="n">hb</span> <span class="o">{</span>
    <span class="n">rcases</span> <span class="n">ha</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">la</span><span class="o">,</span> <span class="n">ha</span><span class="o">,</span> <span class="n">eqa</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">hb</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">lb</span><span class="o">,</span> <span class="n">hb</span><span class="o">,</span> <span class="n">eqb</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">existsi</span> <span class="o">(</span><span class="n">la</span> <span class="bp">++</span> <span class="n">lb</span><span class="o">),</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">eqa</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span> <span class="n">eqb</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span> <span class="n">or_imp_distrib</span><span class="o">],</span>
    <span class="n">exact</span> <span class="k">assume</span> <span class="n">a</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">ha</span> <span class="n">a</span><span class="o">,</span> <span class="n">hb</span> <span class="n">a</span><span class="bp">⟩</span>
  <span class="o">},</span>
  <span class="n">case</span> <span class="n">in_closure</span><span class="bp">.</span><span class="n">inv</span> <span class="o">:</span> <span class="n">a</span> <span class="n">a_in_clo</span> <span class="n">hlist</span> <span class="o">{</span>
    <span class="n">rcases</span> <span class="n">hlist</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">la</span><span class="o">,</span> <span class="n">ha</span><span class="o">,</span> <span class="n">eqa</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">existsi</span> <span class="o">(</span><span class="n">la</span><span class="bp">.</span><span class="n">reverse</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="bp">⁻¹</span><span class="o">)),</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">x</span> <span class="n">x_in</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">list</span><span class="bp">.</span><span class="n">mem_map</span> <span class="n">at</span> <span class="n">x_in</span><span class="o">,</span>
      <span class="n">rcases</span> <span class="n">x_in</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">b_in</span><span class="o">,</span> <span class="n">hb</span><span class="bp">⟩</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">list</span><span class="bp">.</span><span class="n">mem_reverse</span> <span class="n">at</span> <span class="n">b_in</span><span class="o">,</span>
      <span class="n">specialize</span> <span class="n">ha</span> <span class="n">b</span> <span class="n">b_in</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">hb&#39;</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">x</span><span class="bp">⁻¹</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="err">←</span><span class="n">hb</span> <span class="bp">;</span> <span class="n">simp</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">hb</span><span class="o">,</span> <span class="n">hb&#39;</span><span class="o">]</span> <span class="n">at</span> <span class="n">ha</span><span class="o">,</span>
      <span class="n">cc</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="err">←</span><span class="n">eqa</span><span class="o">,</span> <span class="n">inv_prod</span> <span class="n">la</span><span class="o">]</span> <span class="o">}</span> <span class="o">}</span>
<span class="kn">end</span>
<span class="kn">end</span> <span class="n">group</span>

<span class="kn">namespace</span> <span class="n">add_group</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_group</span> <span class="n">α</span><span class="o">]</span>

<span class="kn">theorem</span> <span class="n">exists_list_of_mem_closure</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">closure</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∃</span><span class="n">l</span><span class="o">:</span><span class="n">list</span> <span class="n">α</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span><span class="n">x</span><span class="err">∈</span><span class="n">l</span><span class="o">,</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">s</span> <span class="bp">∨</span> <span class="bp">-</span><span class="n">x</span> <span class="err">∈</span> <span class="n">s</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">l</span><span class="bp">.</span><span class="n">sum</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">sorry</span>
<span class="kn">end</span> <span class="n">add_group</span>

<span class="kn">namespace</span> <span class="n">comm_ring</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>

<span class="n">def</span> <span class="n">closure</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span> <span class="n">add_group</span><span class="bp">.</span><span class="n">closure</span> <span class="o">(</span><span class="n">monoid</span><span class="bp">.</span><span class="n">closure</span> <span class="n">s</span><span class="o">)</span>

<span class="kn">instance</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">R</span><span class="o">}</span> <span class="o">:</span> <span class="n">is_subring</span> <span class="o">(</span><span class="n">closure</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">dunfold</span> <span class="n">closure</span><span class="o">,</span>
  <span class="n">exact</span>
    <span class="o">{</span> <span class="n">zero_mem</span> <span class="o">:=</span> <span class="n">is_add_submonoid</span><span class="bp">.</span><span class="n">zero_mem</span> <span class="bp">_</span><span class="o">,</span>
      <span class="n">add_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ha</span> <span class="n">hb</span><span class="o">,</span> <span class="n">is_add_submonoid</span><span class="bp">.</span><span class="n">add_mem</span> <span class="n">ha</span> <span class="n">hb</span><span class="o">,</span>
      <span class="n">neg_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">h</span><span class="o">,</span> <span class="n">is_add_subgroup</span><span class="bp">.</span><span class="n">neg_mem</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">one_mem</span> <span class="o">:=</span> <span class="n">add_group</span><span class="bp">.</span><span class="n">mem_closure</span> <span class="o">(</span><span class="n">is_submonoid</span><span class="bp">.</span><span class="n">one_mem</span> <span class="bp">_</span><span class="o">),</span>
      <span class="n">mul_mem</span> <span class="o">:=</span> <span class="k">begin</span>
        <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span> <span class="n">a_in</span> <span class="n">b_in</span><span class="o">,</span>
        <span class="n">rcases</span> <span class="n">add_group</span><span class="bp">.</span><span class="n">exists_list_of_mem_closure</span> <span class="n">a_in</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">la</span><span class="o">,</span> <span class="n">hla</span><span class="o">,</span> <span class="n">sum_a</span><span class="bp">⟩</span><span class="o">,</span>
        <span class="n">rcases</span> <span class="n">add_group</span><span class="bp">.</span><span class="n">exists_list_of_mem_closure</span> <span class="n">b_in</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">lb</span><span class="o">,</span> <span class="n">hlb</span><span class="o">,</span> <span class="n">sum_b</span><span class="bp">⟩</span><span class="o">,</span>
        <span class="n">rw</span> <span class="o">[</span><span class="err">←</span><span class="n">sum_a</span><span class="o">,</span> <span class="err">←</span><span class="n">sum_b</span><span class="o">],</span>
        <span class="n">sorry</span><span class="o">,</span>
      <span class="kn">end</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="kn">end</span> <span class="n">comm_ring</span>
</pre></div>

<a name="135496035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135496035" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135496035">Patrick Massot (Oct 09 2018 at 20:21)</a>:</h4>
<p>But I lost courage because of <a href="#narrow/stream/116395-maths/subject/to_additive.20multiplicative/near/135470227" title="#narrow/stream/116395-maths/subject/to_additive.20multiplicative/near/135470227">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/subject/to_additive.20multiplicative/near/135470227</a> and sum manipulations</p>

<a name="135496067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135496067" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135496067">Patrick Massot (Oct 09 2018 at 20:21)</a>:</h4>
<p>The trouble is that the big_operator stuff in mathlib is all about sums over finset, not lists</p>

<a name="135496121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135496121" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135496121">Patrick Massot (Oct 09 2018 at 20:22)</a>:</h4>
<p>(here I mean the trouble with the final sorry, the <code>to_additive</code> stuff is simply total mystery)</p>

<a name="135497365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135497365" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135497365">Kenny Lau (Oct 09 2018 at 20:40)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">subring</span>

<span class="kn">universe</span> <span class="n">u</span>

<span class="bp">@</span><span class="o">[</span><span class="n">elab_as_eliminator</span><span class="o">]</span>
<span class="kn">theorem</span> <span class="n">add_monoid</span><span class="bp">.</span><span class="n">in_closure</span><span class="bp">.</span><span class="n">rec_on</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>
  <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">add_monoid</span><span class="bp">.</span><span class="n">closure</span> <span class="n">s</span><span class="o">)</span>
  <span class="o">(</span><span class="n">H1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">},</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">H2</span> <span class="o">:</span> <span class="n">C</span> <span class="mi">0</span><span class="o">)</span>
  <span class="o">(</span><span class="n">H3</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">},</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">add_monoid</span><span class="bp">.</span><span class="n">closure</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">b</span> <span class="err">∈</span> <span class="n">add_monoid</span><span class="bp">.</span><span class="n">closure</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">C</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">C</span> <span class="n">a</span> <span class="o">:=</span>
<span class="n">monoid</span><span class="bp">.</span><span class="n">in_closure</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">H</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">H1</span><span class="o">)</span> <span class="n">H2</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">H3</span><span class="o">)</span>

<span class="bp">@</span><span class="o">[</span><span class="n">elab_as_eliminator</span><span class="o">]</span>
<span class="kn">theorem</span> <span class="n">add_group</span><span class="bp">.</span><span class="n">in_closure</span><span class="bp">.</span><span class="n">rec_on</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">add_group</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>
  <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">add_group</span><span class="bp">.</span><span class="n">closure</span> <span class="n">s</span><span class="o">)</span>
  <span class="o">(</span><span class="n">H1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">},</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">H2</span> <span class="o">:</span> <span class="n">C</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">H3</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">},</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">add_group</span><span class="bp">.</span><span class="n">closure</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">C</span> <span class="o">(</span><span class="bp">-</span><span class="n">a</span><span class="o">))</span>
  <span class="o">(</span><span class="n">H4</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">},</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">add_group</span><span class="bp">.</span><span class="n">closure</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">b</span> <span class="err">∈</span> <span class="n">add_group</span><span class="bp">.</span><span class="n">closure</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">C</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">C</span> <span class="n">a</span> <span class="o">:=</span>
<span class="n">group</span><span class="bp">.</span><span class="n">in_closure</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">H</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">H1</span><span class="o">)</span> <span class="n">H2</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">H3</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">H4</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">comm_ring</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>

<span class="n">def</span> <span class="n">closure</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span> <span class="n">add_group</span><span class="bp">.</span><span class="n">closure</span> <span class="o">(</span><span class="n">monoid</span><span class="bp">.</span><span class="n">closure</span> <span class="n">s</span><span class="o">)</span>

<span class="n">local</span> <span class="n">attribute</span> <span class="o">[</span><span class="kn">reducible</span><span class="o">]</span> <span class="n">closure</span>

<span class="kn">instance</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">R</span><span class="o">}</span> <span class="o">:</span> <span class="n">is_subring</span> <span class="o">(</span><span class="n">closure</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">zero_mem</span> <span class="o">:=</span> <span class="n">is_add_submonoid</span><span class="bp">.</span><span class="n">zero_mem</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">add_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ha</span> <span class="n">hb</span><span class="o">,</span> <span class="n">is_add_submonoid</span><span class="bp">.</span><span class="n">add_mem</span> <span class="n">ha</span> <span class="n">hb</span><span class="o">,</span>
  <span class="n">neg_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">h</span><span class="o">,</span> <span class="n">is_add_subgroup</span><span class="bp">.</span><span class="n">neg_mem</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">one_mem</span> <span class="o">:=</span> <span class="n">add_group</span><span class="bp">.</span><span class="n">mem_closure</span> <span class="o">(</span><span class="n">is_submonoid</span><span class="bp">.</span><span class="n">one_mem</span> <span class="bp">_</span><span class="o">),</span>
  <span class="n">mul_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ha</span> <span class="n">hb</span><span class="o">,</span> <span class="n">add_group</span><span class="bp">.</span><span class="n">in_closure</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">hb</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span> <span class="n">hb</span><span class="o">,</span> <span class="n">add_group</span><span class="bp">.</span><span class="n">in_closure</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">ha</span>
      <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">ha</span><span class="o">,</span> <span class="n">add_group</span><span class="bp">.</span><span class="n">subset_closure</span> <span class="o">(</span><span class="n">is_submonoid</span><span class="bp">.</span><span class="n">mul_mem</span> <span class="n">ha</span> <span class="n">hb</span><span class="o">))</span>
      <span class="o">((</span><span class="n">zero_mul</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">▸</span> <span class="n">is_add_submonoid</span><span class="bp">.</span><span class="n">zero_mem</span> <span class="bp">_</span><span class="o">)</span>
      <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">ha</span> <span class="n">hab</span><span class="o">,</span> <span class="o">(</span><span class="n">neg_mul_eq_neg_mul</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="bp">▸</span> <span class="n">is_add_subgroup</span><span class="bp">.</span><span class="n">neg_mem</span> <span class="n">hab</span><span class="o">)</span>
      <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">c</span> <span class="n">ha</span> <span class="n">hc</span> <span class="n">hab</span> <span class="n">hcb</span><span class="o">,</span> <span class="o">(</span><span class="n">add_mul</span> <span class="n">a</span> <span class="n">c</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">▸</span> <span class="n">is_add_submonoid</span><span class="bp">.</span><span class="n">add_mem</span> <span class="n">hab</span> <span class="n">hcb</span><span class="o">))</span>
    <span class="o">((</span><span class="n">mul_zero</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">▸</span> <span class="n">is_add_submonoid</span><span class="bp">.</span><span class="n">zero_mem</span> <span class="bp">_</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span> <span class="n">hb</span> <span class="n">hab</span><span class="o">,</span> <span class="o">(</span><span class="n">neg_mul_eq_mul_neg</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="bp">▸</span> <span class="n">is_add_subgroup</span><span class="bp">.</span><span class="n">neg_mem</span> <span class="n">hab</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span> <span class="n">c</span> <span class="n">hb</span> <span class="n">hc</span> <span class="n">hab</span> <span class="n">hac</span><span class="o">,</span> <span class="o">(</span><span class="n">mul_add</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">▸</span> <span class="n">is_add_submonoid</span><span class="bp">.</span><span class="n">add_mem</span> <span class="n">hab</span> <span class="n">hac</span><span class="o">)</span> <span class="o">}</span>

<span class="kn">end</span> <span class="n">comm_ring</span>
</pre></div>

<a name="135497371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135497371" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135497371">Kenny Lau (Oct 09 2018 at 20:40)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span></p>

<a name="135497490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135497490" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135497490">Patrick Massot (Oct 09 2018 at 20:42)</a>:</h4>
<p>Thanks!</p>

<a name="135497506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135497506" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135497506">Patrick Massot (Oct 09 2018 at 20:42)</a>:</h4>
<p>Could we still get the list statements analogue to what is already in mathlib for monoids?</p>

<a name="135497537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135497537" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135497537">Patrick Massot (Oct 09 2018 at 20:43)</a>:</h4>
<p>Is the reducible attribute purely intended to save a couple of <code>dunfold</code> in the instance building?</p>

<a name="135497735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135497735" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135497735">Kenny Lau (Oct 09 2018 at 20:46)</a>:</h4>
<blockquote>
<p>Is the reducible attribute purely intended to save a couple of <code>dunfold</code> in the instance building?</p>
</blockquote>
<p>yes</p>

<a name="135497881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135497881" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135497881">Patrick Massot (Oct 09 2018 at 20:49)</a>:</h4>
<p>Why do you get <code>monoid.in_closure.rec_on</code> for free when defining <code>monoid.in_closure</code> but need to write <code>add_monoid.in_closure.rec_on</code>?</p>

<a name="135497906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135497906" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135497906">Patrick Massot (Oct 09 2018 at 20:49)</a>:</h4>
<p>Is it because of the multiplicative to additive magic?</p>

<a name="135497918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135497918" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135497918">Patrick Massot (Oct 09 2018 at 20:49)</a>:</h4>
<p>which is not magic enough?</p>

<a name="135498021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135498021" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135498021">Kenny Lau (Oct 09 2018 at 20:51)</a>:</h4>
<p>because <code>add_monoid.closure</code> is not defined using <code>to_additive</code></p>

<a name="135498278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135498278" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135498278">Patrick Massot (Oct 09 2018 at 20:55)</a>:</h4>
<p>And why isn't it defined using <code>to_additive</code>?</p>

<a name="135498343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135498343" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135498343">Patrick Massot (Oct 09 2018 at 20:56)</a>:</h4>
<p>The definition is really weird. At some point earlier Lean was completely confused and asked me to prove stuff involving 1 in an additive context</p>

<a name="135498464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135498464" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135498464">Patrick Massot (Oct 09 2018 at 20:58)</a>:</h4>
<p>I would have never thought of proving that instance using these nested inductions. The real world proof manipulating sums is so easy, it seems beyond masochistic to write your proof.</p>

<a name="135498625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135498625" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135498625">Kenny Lau (Oct 09 2018 at 21:01)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">exists_list_of_mem_closure</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">closure</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∃</span><span class="n">l</span><span class="o">:</span><span class="n">list</span> <span class="n">α</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span><span class="n">x</span><span class="err">∈</span><span class="n">l</span><span class="o">,</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">s</span> <span class="bp">∨</span> <span class="bp">-</span><span class="n">x</span> <span class="err">∈</span> <span class="n">s</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">l</span><span class="bp">.</span><span class="n">sum</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">group</span><span class="bp">.</span><span class="n">exists_list_of_mem_closure</span> <span class="n">h</span>
</pre></div>

<a name="135498664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135498664" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135498664">Patrick Massot (Oct 09 2018 at 21:01)</a>:</h4>
<p>this is even more confusing</p>

<a name="135498756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135498756" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135498756">Patrick Massot (Oct 09 2018 at 21:03)</a>:</h4>
<p>I thought you would be using your custom recursor</p>

<a name="135498770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135498770" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135498770">Kenny Lau (Oct 09 2018 at 21:03)</a>:</h4>
<p>me too</p>

<a name="135498777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135498777" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135498777">Kenny Lau (Oct 09 2018 at 21:03)</a>:</h4>
<p>and halfway I realized</p>

<a name="135498839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135498839" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135498839">Patrick Massot (Oct 09 2018 at 21:04)</a>:</h4>
<p>Do you understand what's going on with this way of turning multiplicative stuff into additive one?</p>

<a name="135498846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135498846" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135498846">Kenny Lau (Oct 09 2018 at 21:04)</a>:</h4>
<p>somewhat.</p>

<a name="135500038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135500038" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135500038">Patrick Massot (Oct 09 2018 at 21:22)</a>:</h4>
<p>What about the <code>exists_lists_of_mem_closure</code> in the ring case?</p>

<a name="135500057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135500057" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135500057">Patrick Massot (Oct 09 2018 at 21:22)</a>:</h4>
<p>something like</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">exists_list_of_mem_closure</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">R</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">R</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">closure</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∃</span> <span class="n">L</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">R</span><span class="o">),</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">l</span> <span class="err">∈</span> <span class="n">L</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">l</span><span class="o">,</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">s</span> <span class="bp">∨</span> <span class="bp">-</span><span class="n">x</span> <span class="err">∈</span> <span class="n">s</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">map</span> <span class="n">list</span><span class="bp">.</span><span class="n">prod</span> <span class="n">L</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
</pre></div>

<a name="135500098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135500098" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135500098">Patrick Massot (Oct 09 2018 at 21:23)</a>:</h4>
<p>I guess I would try to use the previous theorems but you'll run crazy inductions...</p>

<a name="135500174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135500174" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135500174">Kenny Lau (Oct 09 2018 at 21:24)</a>:</h4>
<p>why do we need <code>list (list R)</code>?</p>

<a name="135500189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135500189" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135500189">Kenny Lau (Oct 09 2018 at 21:24)</a>:</h4>
<p>ah I see</p>

<a name="135500217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135500217" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135500217">Kenny Lau (Oct 09 2018 at 21:25)</a>:</h4>
<p>maybe we should prove the recursor for comm_ring.closure first</p>

<a name="135500248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135500248" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135500248">Patrick Massot (Oct 09 2018 at 21:25)</a>:</h4>
<p>of course the maths proof is not at all by induction</p>

<a name="135500297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135500297" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135500297">Patrick Massot (Oct 09 2018 at 21:26)</a>:</h4>
<p>but in Lean it would probably be easier by induction</p>

<a name="135500313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135500313" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135500313">Kenny Lau (Oct 09 2018 at 21:26)</a>:</h4>
<p>oh how do you prove it in maths?</p>

<a name="135500454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135500454" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135500454">Patrick Massot (Oct 09 2018 at 21:28)</a>:</h4>
<p>The maths proof starts with <code>  rcases add_group.exists_list_of_mem_closure h with ⟨L1, hL1, L1sum⟩,</code></p>

<a name="135500482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135500482" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135500482">Patrick Massot (Oct 09 2018 at 21:29)</a>:</h4>
<p>Then you need to apply <code>monoid.exists_list_of_mem_closure</code> everywhere you see monoid.closure in hL1</p>

<a name="135500500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135500500" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135500500">Patrick Massot (Oct 09 2018 at 21:29)</a>:</h4>
<p>of course it's already beyond my Lean fu, because of the binder</p>

<a name="135500566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135500566" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135500566">Patrick Massot (Oct 09 2018 at 21:30)</a>:</h4>
<p>and this get you get your list of lists</p>

<a name="135500573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135500573" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135500573">Patrick Massot (Oct 09 2018 at 21:30)</a>:</h4>
<p>except for the substractions</p>

<a name="135500579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135500579" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135500579">Patrick Massot (Oct 09 2018 at 21:30)</a>:</h4>
<p>I guess my statement is wrong</p>

<a name="135500610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135500610" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135500610">Patrick Massot (Oct 09 2018 at 21:31)</a>:</h4>
<p>no, it's ok</p>

<a name="135500677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135500677" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135500677">Reid Barton (Oct 09 2018 at 21:32)</a>:</h4>
<p>I think it is wrong, because of -1. <code>s</code> could even be empty.</p>

<a name="135500702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135500702" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135500702">Patrick Massot (Oct 09 2018 at 21:32)</a>:</h4>
<p>edge cases...</p>

<a name="135500707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135500707" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135500707">Patrick Massot (Oct 09 2018 at 21:32)</a>:</h4>
<p>who cares about those?</p>

<a name="135500809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135500809" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135500809">Patrick Massot (Oct 09 2018 at 21:35)</a>:</h4>
<p>I clearly need to sleep though. I'm sure the <code>Kenny</code> tactic can fix the statement while writing the proof</p>

<a name="135500845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135500845" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135500845">Kenny Lau (Oct 09 2018 at 21:35)</a>:</h4>
<p>of what?</p>

<a name="135501115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/135501115" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#135501115">Patrick Massot (Oct 09 2018 at 21:40)</a>:</h4>
<p><code>ring.exists_list_of_mem_closure</code></p>

<a name="136534435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/136534435" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#136534435">Kenny Lau (Oct 26 2018 at 09:00)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">subring</span>

<span class="kn">universe</span> <span class="n">u</span>

<span class="bp">@</span><span class="o">[</span><span class="n">elab_as_eliminator</span><span class="o">]</span>
<span class="kn">theorem</span> <span class="n">add_monoid</span><span class="bp">.</span><span class="n">in_closure</span><span class="bp">.</span><span class="n">rec_on</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>
  <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">add_monoid</span><span class="bp">.</span><span class="n">closure</span> <span class="n">s</span><span class="o">)</span>
  <span class="o">(</span><span class="n">H1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">},</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">H2</span> <span class="o">:</span> <span class="n">C</span> <span class="mi">0</span><span class="o">)</span>
  <span class="o">(</span><span class="n">H3</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">},</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">add_monoid</span><span class="bp">.</span><span class="n">closure</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">b</span> <span class="err">∈</span> <span class="n">add_monoid</span><span class="bp">.</span><span class="n">closure</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">C</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">C</span> <span class="n">a</span> <span class="o">:=</span>
<span class="n">monoid</span><span class="bp">.</span><span class="n">in_closure</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">H</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">H1</span><span class="o">)</span> <span class="n">H2</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">H3</span><span class="o">)</span>

<span class="bp">@</span><span class="o">[</span><span class="n">elab_as_eliminator</span><span class="o">]</span>
<span class="kn">theorem</span> <span class="n">add_group</span><span class="bp">.</span><span class="n">in_closure</span><span class="bp">.</span><span class="n">rec_on</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">add_group</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>
  <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">add_group</span><span class="bp">.</span><span class="n">closure</span> <span class="n">s</span><span class="o">)</span>
  <span class="o">(</span><span class="n">H1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">},</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">H2</span> <span class="o">:</span> <span class="n">C</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">H3</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">},</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">add_group</span><span class="bp">.</span><span class="n">closure</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">C</span> <span class="o">(</span><span class="bp">-</span><span class="n">a</span><span class="o">))</span>
  <span class="o">(</span><span class="n">H4</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">},</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">add_group</span><span class="bp">.</span><span class="n">closure</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">b</span> <span class="err">∈</span> <span class="n">add_group</span><span class="bp">.</span><span class="n">closure</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">C</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">C</span> <span class="n">a</span> <span class="o">:=</span>
<span class="n">group</span><span class="bp">.</span><span class="n">in_closure</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">H</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">H1</span><span class="o">)</span> <span class="n">H2</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">H3</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">H4</span><span class="o">)</span>

<span class="kn">instance</span> <span class="n">int</span><span class="bp">.</span><span class="n">cast_hom</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">is_ring_hom</span> <span class="o">(</span><span class="n">int</span><span class="bp">.</span><span class="n">cast</span> <span class="o">:</span> <span class="bp">ℤ</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨</span><span class="n">int</span><span class="bp">.</span><span class="n">cast_one</span><span class="o">,</span> <span class="n">int</span><span class="bp">.</span><span class="n">cast_mul</span><span class="o">,</span> <span class="n">int</span><span class="bp">.</span><span class="n">cast_add</span><span class="bp">⟩</span>

<span class="kn">instance</span> <span class="n">int</span><span class="bp">.</span><span class="n">coe_hom</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">is_ring_hom</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="bp">ℤ</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨</span><span class="n">int</span><span class="bp">.</span><span class="n">cast_one</span><span class="o">,</span> <span class="n">int</span><span class="bp">.</span><span class="n">cast_mul</span><span class="o">,</span> <span class="n">int</span><span class="bp">.</span><span class="n">cast_add</span><span class="bp">⟩</span>

<span class="kn">namespace</span> <span class="n">comm_ring</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>

<span class="n">def</span> <span class="n">closure</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span> <span class="n">add_group</span><span class="bp">.</span><span class="n">closure</span> <span class="o">(</span><span class="n">monoid</span><span class="bp">.</span><span class="n">closure</span> <span class="n">s</span><span class="o">)</span>

<span class="n">local</span> <span class="n">attribute</span> <span class="o">[</span><span class="kn">reducible</span><span class="o">]</span> <span class="n">closure</span>

<span class="kn">theorem</span> <span class="n">exists_list_of_mem_closure</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">R</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">R</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">closure</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∃</span> <span class="n">L</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">R</span><span class="o">),</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">l</span> <span class="err">∈</span> <span class="n">L</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">l</span><span class="o">,</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">s</span> <span class="bp">∨</span> <span class="bp">-</span><span class="n">x</span> <span class="err">∈</span> <span class="n">s</span> <span class="bp">∨</span> <span class="n">x</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">-</span><span class="mi">1</span><span class="o">:</span><span class="n">R</span><span class="o">))</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">L</span><span class="bp">.</span><span class="n">map</span> <span class="n">list</span><span class="bp">.</span><span class="n">prod</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">add_group</span><span class="bp">.</span><span class="n">in_closure</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">h</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="k">match</span> <span class="n">x</span><span class="o">,</span> <span class="n">monoid</span><span class="bp">.</span><span class="n">exists_list_of_mem_closure</span> <span class="n">hx</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="bp">_</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">L</span><span class="o">,</span> <span class="n">h1</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="o">[</span><span class="n">L</span><span class="o">],</span> <span class="n">list</span><span class="bp">.</span><span class="n">forall_mem_singleton</span><span class="bp">.</span><span class="mi">2</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">r</span> <span class="n">hr</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="o">(</span><span class="n">h1</span> <span class="n">r</span> <span class="n">hr</span><span class="o">)),</span> <span class="n">zero_add</span> <span class="bp">_⟩</span>
    <span class="kn">end</span><span class="o">)</span>
  <span class="bp">⟨</span><span class="o">[],</span> <span class="n">list</span><span class="bp">.</span><span class="n">forall_mem_nil</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span> <span class="bp">_</span> <span class="n">ih</span><span class="o">,</span> <span class="k">match</span> <span class="n">b</span><span class="o">,</span> <span class="n">ih</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="bp">_</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">L1</span><span class="o">,</span> <span class="n">h1</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">L1</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">cons</span> <span class="o">(</span><span class="bp">-</span><span class="mi">1</span><span class="o">)),</span>
      <span class="bp">λ</span> <span class="n">L2</span> <span class="n">h2</span><span class="o">,</span> <span class="k">match</span> <span class="n">L2</span><span class="o">,</span> <span class="n">list</span><span class="bp">.</span><span class="n">mem_map</span><span class="bp">.</span><span class="mi">1</span> <span class="n">h2</span> <span class="k">with</span>
        <span class="bp">|</span> <span class="bp">_</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">L3</span><span class="o">,</span> <span class="n">h3</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">list</span><span class="bp">.</span><span class="n">forall_mem_cons</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">⟨</span><span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="err">$</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">h1</span> <span class="n">L3</span> <span class="n">h3</span><span class="bp">⟩</span>
        <span class="kn">end</span><span class="o">,</span>
      <span class="k">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">list</span><span class="bp">.</span><span class="n">map_map</span><span class="o">,</span> <span class="o">(</span><span class="err">∘</span><span class="o">),</span> <span class="n">list</span><span class="bp">.</span><span class="n">prod_cons</span><span class="o">,</span> <span class="n">neg_one_mul</span><span class="o">]</span><span class="bp">;</span>
      <span class="n">exact</span> <span class="n">list</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">L1</span> <span class="n">neg_zero</span><span class="bp">.</span><span class="n">symm</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hd</span> <span class="n">tl</span> <span class="n">ih</span><span class="o">,</span>
        <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">list</span><span class="bp">.</span><span class="n">map_cons</span><span class="o">,</span> <span class="n">list</span><span class="bp">.</span><span class="n">sum_cons</span><span class="o">,</span> <span class="n">ih</span><span class="o">,</span> <span class="n">list</span><span class="bp">.</span><span class="n">map_cons</span><span class="o">,</span> <span class="n">list</span><span class="bp">.</span><span class="n">sum_cons</span><span class="o">,</span> <span class="n">neg_add</span><span class="o">])</span><span class="bp">⟩</span>
    <span class="kn">end</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">r1</span> <span class="n">r2</span> <span class="n">hr1</span> <span class="n">hr2</span> <span class="n">ih1</span> <span class="n">ih2</span><span class="o">,</span> <span class="k">match</span> <span class="n">r1</span><span class="o">,</span> <span class="n">r2</span><span class="o">,</span> <span class="n">ih1</span><span class="o">,</span> <span class="n">ih2</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="bp">_</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">L1</span><span class="o">,</span> <span class="n">h1</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">L2</span><span class="o">,</span> <span class="n">h2</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">L1</span> <span class="bp">++</span> <span class="n">L2</span><span class="o">,</span> <span class="n">list</span><span class="bp">.</span><span class="n">forall_mem_append</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">⟨</span><span class="n">h1</span><span class="o">,</span> <span class="n">h2</span><span class="bp">⟩</span><span class="o">,</span>
      <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">list</span><span class="bp">.</span><span class="n">map_append</span><span class="o">,</span> <span class="n">list</span><span class="bp">.</span><span class="n">sum_append</span><span class="o">]</span><span class="bp">⟩</span>
    <span class="kn">end</span><span class="o">)</span>

<span class="kn">instance</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">R</span><span class="o">}</span> <span class="o">:</span> <span class="n">is_subring</span> <span class="o">(</span><span class="n">closure</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">zero_mem</span> <span class="o">:=</span> <span class="n">is_add_submonoid</span><span class="bp">.</span><span class="n">zero_mem</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">add_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ha</span> <span class="n">hb</span><span class="o">,</span> <span class="n">is_add_submonoid</span><span class="bp">.</span><span class="n">add_mem</span> <span class="n">ha</span> <span class="n">hb</span><span class="o">,</span>
  <span class="n">neg_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">h</span><span class="o">,</span> <span class="n">is_add_subgroup</span><span class="bp">.</span><span class="n">neg_mem</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">one_mem</span> <span class="o">:=</span> <span class="n">add_group</span><span class="bp">.</span><span class="n">mem_closure</span> <span class="o">(</span><span class="n">is_submonoid</span><span class="bp">.</span><span class="n">one_mem</span> <span class="bp">_</span><span class="o">),</span>
  <span class="n">mul_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ha</span> <span class="n">hb</span><span class="o">,</span> <span class="n">add_group</span><span class="bp">.</span><span class="n">in_closure</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">hb</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span> <span class="n">hb</span><span class="o">,</span> <span class="n">add_group</span><span class="bp">.</span><span class="n">in_closure</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">ha</span>
      <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">ha</span><span class="o">,</span> <span class="n">add_group</span><span class="bp">.</span><span class="n">subset_closure</span> <span class="o">(</span><span class="n">is_submonoid</span><span class="bp">.</span><span class="n">mul_mem</span> <span class="n">ha</span> <span class="n">hb</span><span class="o">))</span>
      <span class="o">((</span><span class="n">zero_mul</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">▸</span> <span class="n">is_add_submonoid</span><span class="bp">.</span><span class="n">zero_mem</span> <span class="bp">_</span><span class="o">)</span>
      <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">ha</span> <span class="n">hab</span><span class="o">,</span> <span class="o">(</span><span class="n">neg_mul_eq_neg_mul</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="bp">▸</span> <span class="n">is_add_subgroup</span><span class="bp">.</span><span class="n">neg_mem</span> <span class="n">hab</span><span class="o">)</span>
      <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">c</span> <span class="n">ha</span> <span class="n">hc</span> <span class="n">hab</span> <span class="n">hcb</span><span class="o">,</span> <span class="o">(</span><span class="n">add_mul</span> <span class="n">a</span> <span class="n">c</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">▸</span> <span class="n">is_add_submonoid</span><span class="bp">.</span><span class="n">add_mem</span> <span class="n">hab</span> <span class="n">hcb</span><span class="o">))</span>
    <span class="o">((</span><span class="n">mul_zero</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">▸</span> <span class="n">is_add_submonoid</span><span class="bp">.</span><span class="n">zero_mem</span> <span class="bp">_</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span> <span class="n">hb</span> <span class="n">hab</span><span class="o">,</span> <span class="o">(</span><span class="n">neg_mul_eq_mul_neg</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="bp">▸</span> <span class="n">is_add_subgroup</span><span class="bp">.</span><span class="n">neg_mem</span> <span class="n">hab</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span> <span class="n">c</span> <span class="n">hb</span> <span class="n">hc</span> <span class="n">hab</span> <span class="n">hac</span><span class="o">,</span> <span class="o">(</span><span class="n">mul_add</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">▸</span> <span class="n">is_add_submonoid</span><span class="bp">.</span><span class="n">add_mem</span> <span class="n">hab</span> <span class="n">hac</span><span class="o">)</span> <span class="o">}</span>

<span class="kn">end</span> <span class="n">comm_ring</span>
</pre></div>

<a name="136534452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/136534452" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#136534452">Kenny Lau (Oct 26 2018 at 09:01)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> will you PR this?</p>

<a name="136534702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/136534702" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#136534702">Patrick Massot (Oct 26 2018 at 09:07)</a>:</h4>
<p>I can do it if you don't want to do it</p>

<a name="136534707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/136534707" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#136534707">Patrick Massot (Oct 26 2018 at 09:07)</a>:</h4>
<p>But it would make more sense if you do it yourself</p>

<a name="136534710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/136534710" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#136534710">Patrick Massot (Oct 26 2018 at 09:07)</a>:</h4>
<p>otherwise git won't credit you</p>

<a name="136534715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/136534715" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#136534715">Kenny Lau (Oct 26 2018 at 09:07)</a>:</h4>
<p>where should I put it?</p>

<a name="136534762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/136534762" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#136534762">Patrick Massot (Oct 26 2018 at 09:08)</a>:</h4>
<p>Maybe in the subgroup and subring files?</p>

<a name="136534767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/136534767" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#136534767">Kenny Lau (Oct 26 2018 at 09:08)</a>:</h4>
<p>maybe it'll just go to limbo like <a href="https://github.com/leanprover/mathlib/pull/425" target="_blank" title="https://github.com/leanprover/mathlib/pull/425">https://github.com/leanprover/mathlib/pull/425</a></p>

<a name="136534791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/136534791" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#136534791">Patrick Massot (Oct 26 2018 at 09:09)</a>:</h4>
<p>This is much smaller scope</p>

<a name="136534800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/136534800" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#136534800">Patrick Massot (Oct 26 2018 at 09:09)</a>:</h4>
<p>It should be an easy merge</p>

<a name="136646441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/136646441" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#136646441">Kenny Lau (Oct 28 2018 at 10:29)</a>:</h4>
<p><a href="https://github.com/leanprover/mathlib/pull/444" target="_blank" title="https://github.com/leanprover/mathlib/pull/444">https://github.com/leanprover/mathlib/pull/444</a></p>

<a name="136646444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/comm_ring.closure/near/136646444" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/74503commringclosure.html#136646444">Kenny Lau (Oct 28 2018 at 10:29)</a>:</h4>
<p>done <span class="user-mention" data-user-id="110031">@Patrick Massot</span></p>


{% endraw %}
