---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/116395maths/19198functorextlemma.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/19198functorextlemma.html">functor ext lemma?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="184052269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/functor%20ext%20lemma%3F/near/184052269" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19198functorextlemma.html#184052269">Kevin Buzzard (Dec 22 2019 at 12:16)</a>:</h4>
<p>Is this just what I'm stuck with in dependent type theory? I want to prove two functors are equal.</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">functor</span>
<span class="kn">import</span> <span class="n">topology</span><span class="bp">.</span><span class="n">opens</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">structure functor (C : Type u‚ÇÅ) [category.{v‚ÇÅ} C] (D : Type u‚ÇÇ) [category.{v‚ÇÇ} D] :</span>
<span class="cm">  Type (max v‚ÇÅ v‚ÇÇ u‚ÇÅ u‚ÇÇ) :=</span>
<span class="cm">(obj       : C ‚Üí D)</span>
<span class="cm">(map       : Œ† {X Y : C}, (X ‚ü∂ Y) ‚Üí ((obj X) ‚ü∂ (obj Y)))</span>
<span class="cm">(map_id&#39;   : ‚àÄ (X : C), map (ùüô X) = ùüô (obj X) . obviously)</span>
<span class="cm">(map_comp&#39; : ‚àÄ {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z), map (f ‚â´ g) = (map f) ‚â´ (map g) . obviously)</span>

<span class="cm">infixr ` ‚•§ `:26 := functor       -- type as \func --</span>
<span class="cm">-/</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span>

<span class="kn">open</span> <span class="n">topological_space</span>

<span class="n">def</span> <span class="n">res_functor</span> <span class="o">{</span><span class="n">Y‚ÇÅ</span> <span class="n">Y‚ÇÇ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">hY</span> <span class="o">:</span> <span class="n">Y‚ÇÇ</span> <span class="err">‚äÜ</span> <span class="n">Y‚ÇÅ</span><span class="o">)</span> <span class="o">:</span>
    <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span> <span class="bp">//</span> <span class="n">Y‚ÇÅ</span> <span class="err">‚äÜ</span> <span class="n">V</span><span class="o">}</span> <span class="err">‚•§</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span> <span class="bp">//</span> <span class="n">Y‚ÇÇ</span> <span class="err">‚äÜ</span> <span class="n">V</span><span class="o">}</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">obj</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">V</span><span class="o">,</span> <span class="bp">‚ü®</span><span class="n">V</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">subset</span><span class="bp">.</span><span class="n">trans</span> <span class="n">hY</span> <span class="n">V</span><span class="bp">.</span><span class="mi">2</span><span class="bp">‚ü©</span><span class="o">,</span>
  <span class="n">map</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">id</span><span class="o">}</span>

<span class="c1">-- is this supposed to be a such a kerfuffle</span>
<span class="kn">example</span> <span class="o">(</span><span class="n">Y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">res_functor</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">subset</span><span class="bp">.</span><span class="n">refl</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">ùü≠</span> <span class="bp">_</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">unfold</span> <span class="n">res_functor</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">functor</span><span class="bp">.</span><span class="n">id</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">functor</span><span class="bp">.</span><span class="n">mk</span><span class="bp">.</span><span class="n">inj_eq</span><span class="o">,</span> <span class="c1">-- is there an ext lemma missing?</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">ext</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">eq</span><span class="o">,</span>
    <span class="n">refl</span><span class="o">},</span>
  <span class="o">{</span> <span class="c1">-- aargh I have heqs</span>
    <span class="n">apply</span> <span class="n">heq_of_eq</span><span class="o">,</span>
    <span class="n">ext</span><span class="o">}</span>
<span class="kn">end</span>
</pre></div>

<a name="184052467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/functor%20ext%20lemma%3F/near/184052467" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19198functorextlemma.html#184052467">Kevin Buzzard (Dec 22 2019 at 12:22)</a>:</h4>
<p>The reason I get <code>heq</code>s is I guess because <code>(obj X) ‚ü∂ (obj Y)</code> changes when I change <code>obj</code> to something equal to <code>obj</code>. I would be happy with some kind of procedure where I am first asked to prove that the two <code>obj</code> maps are equal and then after that I'm asked to prove that the <code>map</code> maps are equal (rather than hequal). Does that even make sense in Lean's type theory?</p>

<a name="184052626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/functor%20ext%20lemma%3F/near/184052626" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19198functorextlemma.html#184052626">Kevin Buzzard (Dec 22 2019 at 12:27)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> <span class="user-mention" data-user-id="110087">@Scott Morrison</span> <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> to do the kind of algebraic geometry I want to do, I really want to make this category theory stuff work. But I still don't really understand the limitations of dependent type theory in this context. It's clear as an end user what I want to do here -- the objs are the same, the maps are the same, so the functors are the same. The above example is distilled from some proof that pushforwards and pullbacks for sheaves of objects in a category are adjoint functors, and it's what is stopping automation from taking over in some diagram chase. <a href="https://github.com/ramonfmir/lean-scheme/blob/sheaves_of_categories/src/sheaves_of_categories/pushforward.lean" target="_blank" title="https://github.com/ramonfmir/lean-scheme/blob/sheaves_of_categories/src/sheaves_of_categories/pushforward.lean">Here's what I'm doing</a> in case anyone is interested.</p>

<a name="184052814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/functor%20ext%20lemma%3F/near/184052814" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19198functorextlemma.html#184052814">Alex J. Best (Dec 22 2019 at 12:32)</a>:</h4>
<p>I don't know what the "correct" way is but </p>
<div class="codehilite"><pre><span></span>  <span class="n">unfold</span> <span class="n">res_functor</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">functor</span><span class="bp">.</span><span class="n">id</span><span class="o">,</span>
  <span class="n">tidy</span>
</pre></div>


<p>is a lot easier on the eye (and brain)!</p>

<a name="184052832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/functor%20ext%20lemma%3F/near/184052832" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19198functorextlemma.html#184052832">Kevin Buzzard (Dec 22 2019 at 12:33)</a>:</h4>
<p>I tidied too early! I just try tidy and obviously (not really knowing what they do yet) and then go back to first principles. I think I need some crash course in when to use <code>tidy</code>. Thanks!</p>

<a name="184052836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/functor%20ext%20lemma%3F/near/184052836" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19198functorextlemma.html#184052836">Alex J. Best (Dec 22 2019 at 12:33)</a>:</h4>
<p>Oh but "tidy says" just</p>
<div class="codehilite"><pre><span></span>  <span class="n">simp</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
  <span class="n">refl</span><span class="o">,</span>
</pre></div>

<a name="184052887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/functor%20ext%20lemma%3F/near/184052887" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19198functorextlemma.html#184052887">Alex J. Best (Dec 22 2019 at 12:35)</a>:</h4>
<p>Yeah I'm also slightly surprised that tidy doesn't work if unfolding needs doing in this case</p>

<a name="184052908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/functor%20ext%20lemma%3F/near/184052908" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19198functorextlemma.html#184052908">Kevin Buzzard (Dec 22 2019 at 12:35)</a>:</h4>
<p>There's maybe either a missing simp lemma or a missing ext lemma, but I'm too much of a beginner in this area to know how to fix this properly.</p>

<a name="184053330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/functor%20ext%20lemma%3F/near/184053330" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19198functorextlemma.html#184053330">Kevin Buzzard (Dec 22 2019 at 12:46)</a>:</h4>
<p>I can't rewrite this lemma in my application anyway :-( (motive is not type correct, and neither <code>erw</code> nor <code>simp only</code> fixes it). Am I not supposed to be proving that functors are equal? Functors are terms not types, I thought equality would be a good idea...</p>

<a name="184053746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/functor%20ext%20lemma%3F/near/184053746" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19198functorextlemma.html#184053746">Alex J. Best (Dec 22 2019 at 12:58)</a>:</h4>
<p>Can you get away with just constructing a natural isomorphism of your functors?</p>

<a name="184053763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/functor%20ext%20lemma%3F/near/184053763" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19198functorextlemma.html#184053763">Patrick Massot (Dec 22 2019 at 12:59)</a>:</h4>
<p>Yes, that's the standard answer in category theory: do you really mean <em>equal</em> here?</p>

<a name="184053925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/functor%20ext%20lemma%3F/near/184053925" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19198functorextlemma.html#184053925">Alex J. Best (Dec 22 2019 at 13:03)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">Y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">res_functor</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">subset</span><span class="bp">.</span><span class="n">refl</span> <span class="n">Y</span><span class="o">)</span> <span class="err">‚âÖ</span> <span class="mi">ùü≠</span> <span class="bp">_</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">obviously</span>
</pre></div>

<a name="184056088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/functor%20ext%20lemma%3F/near/184056088" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19198functorextlemma.html#184056088">Kevin Buzzard (Dec 22 2019 at 14:08)</a>:</h4>
<p>I am a mere mathematician and hence don't understand equality properly, but for two functors from C to D to be equal I mean that F(o) = G(o) for all objects o of C and F(f) = G(f) for all morphisms (this makes sense only because of the condition on the objects). Is this a bad notion of equality in Lean's set-up of category theory? Is it a mathematically irrelevant notion?</p>

<a name="184056432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/functor%20ext%20lemma%3F/near/184056432" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19198functorextlemma.html#184056432">Kevin Buzzard (Dec 22 2019 at 14:19)</a>:</h4>
<p>I am trying to do a very mundane thing -- pull back a presheaf. I want to prove that pullback is a functor and checking that it sends identities to identities involves checking that two morphisms are equal. However constructing the morphisms involves constructing maps between colimits if one is pulling back presheaves and this involves limit cones which are made from functors. I wanted to argue that two functors were equal to proceed but perhaps this is not the right approach</p>

<a name="184056822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/functor%20ext%20lemma%3F/near/184056822" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19198functorextlemma.html#184056822">Alex J. Best (Dec 22 2019 at 14:31)</a>:</h4>
<p>It looks like there is precedent for using natural iso even if equality holds in fact: in line 62 of category_theory/precedent.lean <span class="user-mention" data-user-id="110032">@Reid Barton</span>  wrote about two constant functors "These are actually equal, of course, but not definitionally equal (the equality requires F.map (ùüô _) = ùüô _). A natural isomorphism is  more convenient than an equality between functors"</p>

<a name="184057107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/functor%20ext%20lemma%3F/near/184057107" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19198functorextlemma.html#184057107">Kevin Buzzard (Dec 22 2019 at 14:40)</a>:</h4>
<p>Oh good catch Alex. I will then consider switching to nat isos. Here are some more details of why I thought I needed this. I type them as much for myself as for anyone else. Trying to define pullback of presheaves (taking values in a general category e.g. cat of comm rings) on a top space. Have <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>‚Üí</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f:X\to Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">‚Üí</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> continuous. Definition is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo>‚àó</mo></msup><mi mathvariant="script">F</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mo><mi>lim</mi><mo>‚Å°</mo></mo><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo><mo>‚äÜ</mo><mi>V</mi></mrow></msub><mi mathvariant="script">F</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f^*\mathcal{F}(U)=\lim_{f(U)\subseteq V}\mathcal{F}(V)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">‚àó</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathcal" style="margin-right:0.09931em;">F</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3551999999999999em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">U</span><span class="mclose mtight">)</span><span class="mrel mtight">‚äÜ</span><span class="mord mathdefault mtight" style="margin-right:0.22222em;">V</span></span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.09931em;">F</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span> where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>lim</mi><mo>‚Å°</mo></mrow><annotation encoding="application/x-tex">\lim</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mop">lim</span></span></span></span> is a (filtered) colimit. Need to check it's a presheaf, so need to check that the restriction map from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo>‚àó</mo></msup><mi mathvariant="script">F</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f^*\mathcal{F}(U)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">‚àó</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathcal" style="margin-right:0.09931em;">F</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mclose">)</span></span></span></span> to itself is equal to the identity map. This is a map between colimits and I defined it using</p>
<div class="codehilite"><pre><span></span>limits.colimit.pre :
  Œ† {J K : Type u_1} [_inst_1 : small_category J] [_inst_2 : small_category K] {C : Type u_2}
  [ùíû : category_theory.category C] (F : J ‚•§ C) [_inst_3 : limits.has_colimit F] (E : K ‚•§ J)
  [_inst_4 : limits.has_colimit (E ‚ãô F)], limits.colimit (E ‚ãô F) ‚ü∂ limits.colimit F
</pre></div>


<p>What I have in my situation is a functor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span> which is "equal" to the identity functor in the sense that it is a functor from a small category to itself which is equal to the identity functor whichever way you look at it: with notation above, <code>J</code> and <code>K</code> are both the category of open subsets of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> which contain <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(U)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mclose">)</span></span></span></span> and <code>E</code> is a functor which should be equal to the identity functor but which I can quite believe is not defeq to the identity functor (indeed <code>rfl</code> fails).</p>

<a name="184057314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/functor%20ext%20lemma%3F/near/184057314" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19198functorextlemma.html#184057314">Kevin Buzzard (Dec 22 2019 at 14:47)</a>:</h4>
<p>One last thing before I stop randomly posting my thoughts and actually go away and think: I am specifically avoiding all mentions of categories for <code>opens X</code> and the definition of a presheaf; the only category in sight is the one where the presheaf is taking values:</p>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">topological_space</span><span class="bp">.</span><span class="n">presheaf</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span>
  <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="err">ùíû</span> <span class="o">:</span> <span class="n">category</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">C</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">val</span> <span class="o">:</span> <span class="bp">Œ†</span> <span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">),</span> <span class="n">C</span><span class="o">)</span> <span class="c1">-- ‚Ñ±</span>
<span class="o">(</span><span class="n">res</span>   <span class="o">:</span> <span class="bp">‚àÄ</span> <span class="o">(</span><span class="n">U</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">HVU</span> <span class="o">:</span> <span class="n">V</span> <span class="err">‚äÜ</span> <span class="n">U</span><span class="o">),</span> <span class="n">val</span> <span class="n">U</span> <span class="err">‚ü∂</span> <span class="n">val</span> <span class="n">V</span><span class="o">)</span>
<span class="o">(</span><span class="n">Hid</span>   <span class="o">:</span> <span class="bp">‚àÄ</span> <span class="o">(</span><span class="n">U</span><span class="o">),</span> <span class="n">res</span> <span class="n">U</span> <span class="n">U</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">subset</span><span class="bp">.</span><span class="n">refl</span> <span class="n">U</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">ùüô</span> <span class="o">(</span><span class="n">val</span> <span class="n">U</span><span class="o">))</span>
<span class="o">(</span><span class="n">Hcomp</span> <span class="o">:</span> <span class="bp">‚àÄ</span> <span class="o">(</span><span class="n">U</span> <span class="n">V</span> <span class="n">W</span><span class="o">)</span> <span class="o">(</span><span class="n">HWV</span> <span class="o">:</span> <span class="n">W</span> <span class="err">‚äÜ</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">HVU</span> <span class="o">:</span> <span class="n">V</span> <span class="err">‚äÜ</span> <span class="n">U</span><span class="o">),</span>
  <span class="n">res</span> <span class="n">U</span> <span class="n">W</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">subset</span><span class="bp">.</span><span class="n">trans</span> <span class="n">HWV</span> <span class="n">HVU</span><span class="o">)</span> <span class="bp">=</span> <span class="n">res</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="err">‚â´</span> <span class="n">res</span> <span class="n">V</span> <span class="n">W</span> <span class="n">HWV</span><span class="o">)</span>
</pre></div>


<p>I am doing it because people have experimented with the definition of a presheaf as a functor on the category whose objects are opens (these definitions are already in mathlib I believe) but I find this approach hard to work with because one is immediately launched head first into the category theory library. With this more mundane method the category theory is more limited and there is more of a separation of concerns (there is only one category involved, for example), and I've found it much easier to learn how to use the limits library etc. It's as much a learning exercise as anything else, and as you can see from the above I still have plenty to learn. I'm not suggesting we should do it like this in mathlib, but it seems to me to be a great set-up for experimentation and trying to work out what works and what doesn't work.</p>

<a name="184076783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/functor%20ext%20lemma%3F/near/184076783" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19198functorextlemma.html#184076783">Kevin Buzzard (Dec 23 2019 at 01:05)</a>:</h4>
<blockquote>
<p>It looks like there is precedent for using natural iso even if equality holds in fact: in line 62 of category_theory/precedent.lean <span class="user-mention silent" data-user-id="110032">Reid Barton</span>  wrote about two constant functors "These are actually equal, of course, but not definitionally equal (the equality requires F.map (ùüô _) = ùüô _). A natural isomorphism is  more convenient than an equality between functors"</p>
</blockquote>
<p><a href="#narrow/stream/116395-maths/topic/Category.20theory/near/148666324" title="#narrow/stream/116395-maths/topic/Category.20theory/near/148666324">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category.20theory/near/148666324</a></p>

<a name="184078039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/functor%20ext%20lemma%3F/near/184078039" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19198functorextlemma.html#184078039">Kevin Buzzard (Dec 23 2019 at 01:51)</a>:</h4>
<p>OK so there is something going on which I don't understand.</p>
<p>I'm trying to prove that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo>‚àó</mo></msup></mrow><annotation encoding="application/x-tex">f^*</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">‚àó</span></span></span></span></span></span></span></span></span></span></span> is a functor from (<code>ùíû</code>-valued) presheaves on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> to presheaves on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> with notation as above. The restriction map is as follows: if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mn>1</mn></msub><mo>‚äÜ</mo><msub><mi>U</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">U_1\subseteq U_2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">‚äÜ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> then there's a (forgetful) functor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span> from the category of open subsets <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span> of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>U</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>‚äÜ</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">f(U_2)\subseteq V</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">‚äÜ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span> to the category of open subsets <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span> of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>U</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>‚äÜ</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">f(U_1)\subseteq V</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">‚äÜ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span>. In <code>category_theory/limits/limits.lean</code> there is <code>colimit.pre</code> which defines a morphism from the colimit of <code>E ‚ãô F</code> to the colimit of <code>F</code> and this is what I used for the restiction map for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo>‚àó</mo></msup><mi mathvariant="script">F</mi></mrow><annotation encoding="application/x-tex">f^*\mathcal{F}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">‚àó</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathcal" style="margin-right:0.09931em;">F</span></span></span></span></span>. Now say <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mn>1</mn></msub><mo>=</mo><msub><mi>U</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">U_1=U_2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>. Then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span> equals the identity functor, except that apparently this is not what we are supposed to say. OK so Alex above noted that <code>obviously</code> proves that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span> is isomorphic to the identity functor, and everyone is telling me that this is the correct thing to say. But I'm trying to prove that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo>‚àó</mo></msup><mi mathvariant="script">F</mi></mrow><annotation encoding="application/x-tex">f^*\mathcal{F}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">‚àó</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathcal" style="margin-right:0.09931em;">F</span></span></span></span></span> is a sheaf, and axiom <code>Hid</code> for sheaves says that restriction from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span></span> has to be equal to the identity map. However if I only know that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span> is isomorphic to the identity functor then I can only deduce that <code>E ‚ãô F</code> is isomorphic to <code>F</code> and so their colimits will only be isomorphic and have no reason to be equal; hence I can't even talk about the identity map between these things. </p>
<p>I want to conclude that in this case I <em>have</em> to prove that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span> is equal to, not just isomorphic to, the identity functor, flying in the face of much of what has gone before.</p>

<a name="184078095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/functor%20ext%20lemma%3F/near/184078095" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19198functorextlemma.html#184078095">Kevin Buzzard (Dec 23 2019 at 01:53)</a>:</h4>
<p>Am I allowed to prove that functors from a small category to itself are equal?</p>

<a name="184078203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/functor%20ext%20lemma%3F/near/184078203" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19198functorextlemma.html#184078203">Kevin Buzzard (Dec 23 2019 at 01:58)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">Y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">res_functor</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">subset</span><span class="bp">.</span><span class="n">refl</span> <span class="n">Y</span><span class="o">)</span> <span class="err">‚âÖ</span> <span class="mi">ùü≠</span> <span class="bp">_</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="c">/-</span><span class="cm"> `tidy` says -/</span>
  <span class="n">fsplit</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">fsplit</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">intros</span> <span class="n">X_1</span><span class="o">,</span> <span class="n">cases</span> <span class="n">X_1</span><span class="o">,</span> <span class="n">cases</span> <span class="n">X_1_val</span><span class="o">,</span> <span class="n">dsimp</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span> <span class="n">fsplit</span><span class="o">,</span> <span class="n">dsimp</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span> <span class="n">fsplit</span><span class="o">,</span> <span class="n">intros</span> <span class="n">a</span> <span class="n">a_1</span><span class="o">,</span> <span class="n">assumption</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">intros</span> <span class="n">X_1</span> <span class="n">Y_1</span> <span class="n">f</span><span class="o">,</span> <span class="n">refl</span><span class="o">}},</span>
    <span class="o">{</span> <span class="n">fsplit</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">intros</span> <span class="n">X_1</span><span class="o">,</span> <span class="n">cases</span> <span class="n">X_1</span><span class="o">,</span> <span class="n">cases</span> <span class="n">X_1_val</span><span class="o">,</span> <span class="n">dsimp</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span> <span class="n">fsplit</span><span class="o">,</span> <span class="n">dsimp</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span> <span class="n">fsplit</span><span class="o">,</span> <span class="n">intros</span> <span class="n">a</span> <span class="n">a_1</span><span class="o">,</span> <span class="n">assumption</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">intros</span> <span class="n">X_1</span> <span class="n">Y_1</span> <span class="n">f</span><span class="o">,</span> <span class="n">refl</span> <span class="o">}},</span>
      <span class="o">{</span> <span class="n">apply_auto_param</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">apply_auto_param</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">Y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">res_functor</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">subset</span><span class="bp">.</span><span class="n">refl</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">ùü≠</span> <span class="bp">_</span> <span class="o">:=</span> <span class="k">begin</span>
  <span class="n">unfold</span> <span class="n">res_functor</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">functor</span><span class="bp">.</span><span class="n">id</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p><code>tidy</code> makes a meal of proving they're isomorphic but has little trouble proving they're equal after the <code>unfold</code> hint.</p>

<a name="184078332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/functor%20ext%20lemma%3F/near/184078332" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19198functorextlemma.html#184078332">Kevin Buzzard (Dec 23 2019 at 02:00)</a>:</h4>
<p>In short, the issue is that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo>‚àó</mo></msup><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f^*(U)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">‚àó</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mclose">)</span></span></span></span> is a colimit of a functor, and if I replace the functor with an isomorphic functor (e.g. because I replace <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span></span> with an equal <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>U</mi><mo lspace="0em" mathvariant="normal" rspace="0em">‚Ä≤</mo></msup></mrow><annotation encoding="application/x-tex">U'</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">‚Ä≤</span></span></span></span></span></span></span></span></span></span></span></span>) then the colimit gets (presumably) replaced by an isomorphic colimit, so it no longer makes sense to talk about a map between the two colimits being equal to the identity map, which is what one of the axioms of a presheaf is.</p>

<a name="184078432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/functor%20ext%20lemma%3F/near/184078432" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19198functorextlemma.html#184078432">Kevin Buzzard (Dec 23 2019 at 02:04)</a>:</h4>
<p>I cannot see any way of proceeding short of proving that the functors are equal.</p>

<a name="184078511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/functor%20ext%20lemma%3F/near/184078511" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19198functorextlemma.html#184078511">Kevin Buzzard (Dec 23 2019 at 02:07)</a>:</h4>
<p>AARGH MY MOTIVE IS NOT TYPE CORRECT</p>

<a name="184078519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/functor%20ext%20lemma%3F/near/184078519" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19198functorextlemma.html#184078519">Chris Hughes (Dec 23 2019 at 02:07)</a>:</h4>
<p>You only need equality of the objects for everything else to work, not the homs right? So maybe that's the in between that you need?</p>

<a name="184078562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/functor%20ext%20lemma%3F/near/184078562" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19198functorextlemma.html#184078562">Kevin Buzzard (Dec 23 2019 at 02:08)</a>:</h4>
<p>I need that two colimits are equal and that a map between them is the identity</p>

<a name="184078576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/functor%20ext%20lemma%3F/near/184078576" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19198functorextlemma.html#184078576">Kevin Buzzard (Dec 23 2019 at 02:09)</a>:</h4>
<p>The problem is that one is the colimit of a functor F and the other is the colimit of <code>E &gt;&gt;&gt; F</code> where <code>E</code> is (not definitionally) equal to the identity functor.</p>

<a name="184078639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/functor%20ext%20lemma%3F/near/184078639" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19198functorextlemma.html#184078639">Kevin Buzzard (Dec 23 2019 at 02:11)</a>:</h4>
<p>Maybe I should try to make <code>E</code> defeq to the identity functor :-/</p>

<a name="184078692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/functor%20ext%20lemma%3F/near/184078692" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19198functorextlemma.html#184078692">Chris Hughes (Dec 23 2019 at 02:12)</a>:</h4>
<p>That looks impossible.</p>

<a name="184078699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/functor%20ext%20lemma%3F/near/184078699" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19198functorextlemma.html#184078699">Kevin Buzzard (Dec 23 2019 at 02:13)</a>:</h4>
<p>My proof of equality uses <code>subtype.eta</code></p>

<a name="184078874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/functor%20ext%20lemma%3F/near/184078874" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19198functorextlemma.html#184078874">Kevin Buzzard (Dec 23 2019 at 02:19)</a>:</h4>
<div class="codehilite"><pre><span></span>h : res_functor _ = ùü≠ {V // f &#39;&#39; U.val ‚äÜ ‚ÜëV}
‚ä¢ limits.colimit.pre (to_aux_functor ‚Ñ± (f &#39;&#39; U.val)) (res_functor _) = ùüô (aux_colimit ‚Ñ± (f &#39;&#39; ‚ÜëU))
</pre></div>


<p>I can't <code>rw h</code> or <code>erw h</code> or <code>simp only [h]</code>. So I can't work with equality and I can't work with isomorphism :-/</p>

<a name="184078986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/functor%20ext%20lemma%3F/near/184078986" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19198functorextlemma.html#184078986">Chris Hughes (Dec 23 2019 at 02:23)</a>:</h4>
<p>The standard way to do this is to prove the rewrite you want to do except with <code>res_functor _</code> replaced with a variable so <code>subst</code> works, and then apply it to this case.</p>

<a name="184079026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/functor%20ext%20lemma%3F/near/184079026" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19198functorextlemma.html#184079026">Chris Hughes (Dec 23 2019 at 02:24)</a>:</h4>
<p>No idea if this is a sustainable strategy.</p>

<a name="184079250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/functor%20ext%20lemma%3F/near/184079250" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19198functorextlemma.html#184079250">Kevin Buzzard (Dec 23 2019 at 02:32)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">{</span><span class="n">J</span> <span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="bp">_</span><span class="n">inst_1</span> <span class="o">:</span> <span class="n">small_category</span> <span class="n">J</span><span class="o">]</span>
<span class="o">[</span><span class="n">small_category</span> <span class="n">K</span><span class="o">]</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="err">ùíû</span> <span class="o">:</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">category</span> <span class="n">C</span><span class="o">]</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">J</span> <span class="err">‚•§</span> <span class="n">C</span><span class="o">)</span>
<span class="o">[</span><span class="n">limits</span><span class="bp">.</span><span class="n">has_colimit</span> <span class="n">F</span><span class="o">]</span> <span class="o">(</span><span class="n">E‚ÇÅ</span> <span class="n">E‚ÇÇ</span> <span class="o">:</span> <span class="n">K</span> <span class="err">‚•§</span> <span class="n">J</span><span class="o">)</span> <span class="o">[</span><span class="n">limits</span><span class="bp">.</span><span class="n">has_colimit</span> <span class="o">(</span><span class="n">E‚ÇÅ</span> <span class="err">‚ãô</span> <span class="n">F</span><span class="o">)]</span> <span class="o">[</span><span class="n">limits</span><span class="bp">.</span><span class="n">has_colimit</span> <span class="o">(</span><span class="n">E‚ÇÇ</span> <span class="err">‚ãô</span> <span class="n">F</span><span class="o">)]</span>
<span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">E‚ÇÅ</span> <span class="bp">=</span> <span class="n">E‚ÇÇ</span><span class="o">)</span> <span class="o">:</span> <span class="n">limits</span><span class="bp">.</span><span class="n">colimit</span><span class="bp">.</span><span class="n">pre</span> <span class="n">F</span> <span class="n">E‚ÇÅ</span> <span class="bp">=</span> <span class="n">limits</span><span class="bp">.</span><span class="n">colimit</span><span class="bp">.</span><span class="n">pre</span> <span class="n">F</span> <span class="n">E‚ÇÇ</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>


<p>doesn't compile: Lean complains that they can't be equal because they have different types :-/ </p>
<div class="codehilite"><pre><span></span>type mismatch at application
  limits.colimit.pre F E‚ÇÅ = limits.colimit.pre F E‚ÇÇ
term
  limits.colimit.pre F E‚ÇÇ
has type
  limits.colimit (E‚ÇÇ ‚ãô F) ‚ü∂ limits.colimit F
but is expected to have type
  limits.colimit (E‚ÇÅ ‚ãô F) ‚ü∂ limits.colimit F
</pre></div>

<a name="184079313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/functor%20ext%20lemma%3F/near/184079313" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19198functorextlemma.html#184079313">Kevin Buzzard (Dec 23 2019 at 02:35)</a>:</h4>
<p>[note that <code>‚ü∂</code> is a category theory hom]</p>

<a name="184079479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/functor%20ext%20lemma%3F/near/184079479" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19198functorextlemma.html#184079479">Kevin Buzzard (Dec 23 2019 at 02:40)</a>:</h4>
<p><a href="https://gist.github.com/kbuzzard/ef4d927b65359221488eb55ad298e9bb" target="_blank" title="https://gist.github.com/kbuzzard/ef4d927b65359221488eb55ad298e9bb">self-contained gist</a></p>


{% endraw %}

{% include archive_update.html %}