---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/116395maths/19426wellorderingprinciple.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html">well-ordering principle</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="188423358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188423358" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188423358">Nicholas McConnell (Feb 18 2020 at 04:41)</a>:</h4>
<p>Does mathlib have a builtin well-ordering principle?  If not, here is my attempt to create one: how should I start?</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">WOP</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">k</span><span class="o">,</span> <span class="n">f</span><span class="o">(</span><span class="n">k</span><span class="o">))</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">k</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">k</span><span class="o">)</span> <span class="bp">→</span> <span class="n">k</span> <span class="bp">≥</span> <span class="n">n</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>

<a name="188423515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188423515" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188423515">Chris Hughes (Feb 18 2020 at 04:46)</a>:</h4>
<p><code>nat.find </code> will compute this <code>n</code> for you.</p>

<a name="188423521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188423521" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188423521">Nicholas McConnell (Feb 18 2020 at 04:47)</a>:</h4>
<p>Ah okay thanks</p>

<a name="188423644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188423644" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188423644">Nicholas McConnell (Feb 18 2020 at 04:51)</a>:</h4>
<p>I'm not sure how to use it?</p>

<a name="188427457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188427457" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188427457">Johan Commelin (Feb 18 2020 at 06:51)</a>:</h4>
<p>If you hit <code>Ctrl</code>-<code>Shift</code>-<code>p</code> in VScode, and then type <code>#nat.find</code> you'll find all the lemmas about it.</p>

<a name="188431362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188431362" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188431362">Kevin Buzzard (Feb 18 2020 at 08:20)</a>:</h4>
<p>(and yes, mathlib has a bunch of stuff about general well-orderings as well, although in the case of nat there is more)</p>

<a name="188432471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188432471" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188432471">Kevin Buzzard (Feb 18 2020 at 08:43)</a>:</h4>
<p>PS <code>k ≥ n</code> is the same as <code>n ≤ k</code> and as a general convention we stick to <code>≤</code> because e.g. then you don't have to state every lemma involving <code>≤</code> twice.</p>

<a name="188432727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188432727" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188432727">Kevin Buzzard (Feb 18 2020 at 08:49)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="n">def</span> <span class="n">yadayadayada</span> <span class="o">:=</span> <span class="mi">37</span>

<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kn">lemma</span> <span class="n">WOP</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">k</span><span class="o">,</span> <span class="n">f</span><span class="o">(</span><span class="n">k</span><span class="o">))</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">k</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">k</span><span class="o">)</span> <span class="bp">→</span> <span class="n">k</span> <span class="bp">≥</span> <span class="n">n</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">use</span> <span class="n">nat</span><span class="bp">.</span><span class="n">find</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">find_spec</span> <span class="n">h</span><span class="o">},</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">k</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">find_min&#39;</span> <span class="n">h</span><span class="o">}</span>
<span class="kn">end</span>
</pre></div>

<a name="188514768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188514768" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188514768">Nicholas McConnell (Feb 19 2020 at 04:19)</a>:</h4>
<p>My point is that I'm confused about this:</p>
<div class="codehilite"><pre><span></span><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">nat</span><span class="bp">.</span><span class="n">find</span> <span class="n">prime</span>
<span class="n">term</span>
  <span class="n">prime</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="err">?</span><span class="n">m_1</span> <span class="n">n</span> <span class="o">:</span> <span class="kt">Prop</span>
</pre></div>


<p>What on earth is the type named via an existential quantifier?</p>

<a name="188514828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188514828" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188514828">Mario Carneiro (Feb 19 2020 at 04:21)</a>:</h4>
<p>You have to provide a proof that some prime exists, and it returns the least prime</p>

<a name="188514834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188514834" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188514834">Nicholas McConnell (Feb 19 2020 at 04:21)</a>:</h4>
<p>Oh okay...</p>

<a name="188514948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188514948" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188514948">Nicholas McConnell (Feb 19 2020 at 04:24)</a>:</h4>
<p>I tried this with a proof that some k exists with k % 4 = 2, but I doubt this is the way to find the smallest such k</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">someK</span> <span class="o">:</span> <span class="bp">∃</span><span class="o">(</span><span class="n">k</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">),</span> <span class="n">k</span> <span class="err">%</span> <span class="mi">4</span> <span class="bp">=</span> <span class="mi">2</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">use</span> <span class="mi">10</span><span class="o">,</span>
<span class="n">ring</span><span class="o">,</span>
<span class="kn">end</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">nat</span><span class="bp">.</span><span class="n">find</span><span class="o">(</span><span class="n">someK</span><span class="o">)</span>
</pre></div>

<a name="188514972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188514972" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188514972">Alex J. Best (Feb 19 2020 at 04:25)</a>:</h4>
<p>Try <code>#eval nat.find someK</code> it will return 2 so looks like it does the right thing to me.</p>

<a name="188514975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188514975" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188514975">Nicholas McConnell (Feb 19 2020 at 04:25)</a>:</h4>
<p>Ah thanks</p>

<a name="188515611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188515611" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188515611">Nicholas McConnell (Feb 19 2020 at 04:46)</a>:</h4>
<p>In here, I feel like I'm supposed to change "0 &lt; a * a" in the goal to "a * 0 &lt; a * a" and then use mul_lt_mul_of_pos_left, but I'm not sure how to...</p>
<div class="codehilite"><pre><span></span><span class="mi">2</span> <span class="n">goals</span>
<span class="n">a</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">,</span>
<span class="n">p</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">a</span>
<span class="err">⊢</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">a</span>
</pre></div>

<a name="188516111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188516111" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188516111">Alex J. Best (Feb 19 2020 at 05:00)</a>:</h4>
<p>Using the library <code>library_search</code> tactic I found <code>exact mul_pos' p p</code></p>

<a name="188516128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188516128" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188516128">Scott Morrison (Feb 19 2020 at 05:01)</a>:</h4>
<p>haha, I was seconds behind:</p>
<div class="codehilite"><pre><span></span>example (n : ℤ) (a : 0 &lt; n) : 0 &lt; n * n := by library_search
</pre></div>

<a name="188516142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188516142" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188516142">Alex J. Best (Feb 19 2020 at 05:01)</a>:</h4>
<p>the strategy you wanted you can achieve via</p>
<div class="codehilite"><pre><span></span> <span class="n">rw</span> <span class="o">[</span><span class="err">←</span><span class="o">(</span> <span class="n">int</span><span class="bp">.</span><span class="n">mul_zero</span> <span class="n">a</span><span class="o">)],</span>
 <span class="n">exact</span> <span class="n">mul_lt_mul_of_pos_left</span> <span class="n">p</span> <span class="n">p</span><span class="o">,</span>
</pre></div>

<a name="188597781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188597781" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188597781">Nicholas McConnell (Feb 19 2020 at 23:45)</a>:</h4>
<p>Thanks</p>

<a name="188598891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188598891" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188598891">Nicholas McConnell (Feb 20 2020 at 00:01)</a>:</h4>
<p>Another general question, is there any way to use a lemma statement?</p>
<p>For example, is there a command which can use lt_trichotomy to turn this</p>
<div class="codehilite"><pre><span></span><span class="mi">1</span> <span class="n">goal</span>
<span class="n">a</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">,</span>
<span class="n">p</span> <span class="o">:</span> <span class="bp">¬</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">a</span>
<span class="err">⊢</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="err">^</span> <span class="mi">2</span>
</pre></div>


<p>into this?</p>
<div class="codehilite"><pre><span></span><span class="mi">1</span> <span class="n">goal</span>
<span class="n">a</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">,</span>
<span class="n">p</span> <span class="o">:</span> <span class="bp">¬</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">a</span>
<span class="n">q</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="bp">∨</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">∨</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="mi">0</span>
<span class="err">⊢</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="err">^</span> <span class="mi">2</span>
</pre></div>

<a name="188599461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188599461" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188599461">Mario Carneiro (Feb 20 2020 at 00:12)</a>:</h4>
<p><code>have q := lt_trichotomy 0 a</code> will do that</p>

<a name="188606372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188606372" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188606372">Nicholas McConnell (Feb 20 2020 at 02:54)</a>:</h4>
<p>Thanks.  Sorry if I'm overwhelming you guys with questions, I am totally new to Lean</p>

<a name="188607397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188607397" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188607397">Nicholas McConnell (Feb 20 2020 at 03:25)</a>:</h4>
<p>(deleted)</p>

<a name="188608048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188608048" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188608048">Nicholas McConnell (Feb 20 2020 at 03:45)</a>:</h4>
<p>In proving this, I just need to be able to use p &gt; 0 to get 0 ≠ ↑p (something I can apply s to).  What's the <em>best</em> way you know to do this?  [I feel like I could come up with one myself but it would be unnecessarily overwhelming]</p>
<div class="codehilite"><pre><span></span><span class="mi">1</span> <span class="n">goal</span>
<span class="n">a</span> <span class="n">p</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span>
<span class="n">hp</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span>
<span class="n">q</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="err">↑</span><span class="n">a</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">a</span><span class="o">,</span>
<span class="n">r</span> <span class="o">:</span> <span class="err">↑</span><span class="n">p</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">p</span> <span class="bp">≤</span> <span class="err">↑</span><span class="n">a</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">a</span> <span class="bp">+</span> <span class="err">↑</span><span class="n">p</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">p</span><span class="o">,</span>
<span class="n">s</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≠</span> <span class="err">↑</span><span class="n">p</span> <span class="bp">→</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="err">↑</span><span class="n">p</span> <span class="err">^</span> <span class="mi">2</span>
<span class="err">⊢</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="err">↑</span><span class="n">a</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">a</span> <span class="bp">+</span> <span class="err">↑</span><span class="n">p</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">p</span>
</pre></div>

<a name="188609703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188609703" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188609703">Alex J. Best (Feb 20 2020 at 04:34)</a>:</h4>
<p>Not that it matters too much to the answer but : What is the cast <code>↑</code> to? Integers, reals? I.e. what is the actual lemma statement you are proving ?</p>

<a name="188609775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188609775" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188609775">Mario Carneiro (Feb 20 2020 at 04:36)</a>:</h4>
<p>Seems like <code>norm_cast</code> will help a lot to clean that up</p>

<a name="188610115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188610115" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188610115">Nicholas McConnell (Feb 20 2020 at 04:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="127136">Alex J. Best</span> <a href="#narrow/stream/116395-maths/topic/well-ordering.20principle/near/188609703" title="#narrow/stream/116395-maths/topic/well-ordering.20principle/near/188609703">said</a>:</p>
<blockquote>
<p>Not that it matters too much to the answer but : What is the cast <code>↑</code> to? Integers, reals? I.e. what is the actual lemma statement you are proving ?</p>
</blockquote>
<p>Integers.  I confess that I didn't know ↑ had multiple meanings</p>

<a name="188610176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188610176" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188610176">Alex J. Best (Feb 20 2020 at 04:47)</a>:</h4>
<p>It means cast in general, so it could be casting nats to reals or rationals or whatever and it will just be printed in the same way. As mario says, whenever you have such a cast the tactic norm_cast can often reduce you back to the case where there are none.</p>

<a name="188610295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188610295" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188610295">Alex J. Best (Feb 20 2020 at 04:50)</a>:</h4>
<p>Don't know if you wanted a full answer or not, but here is one way of concluding:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">p</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="o">(</span><span class="err">↑</span><span class="n">a</span> <span class="o">:</span><span class="bp">ℤ</span><span class="o">)</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="o">(</span><span class="err">↑</span><span class="n">p</span><span class="o">:</span><span class="bp">ℤ</span><span class="o">)</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">p</span> <span class="bp">≤</span> <span class="err">↑</span><span class="n">a</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">a</span> <span class="bp">+</span> <span class="err">↑</span><span class="n">p</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≠</span> <span class="o">(</span><span class="err">↑</span><span class="n">p</span><span class="o">:</span><span class="bp">ℤ</span><span class="o">)</span> <span class="bp">→</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="err">↑</span><span class="n">p</span> <span class="err">^</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="err">↑</span><span class="n">a</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">a</span> <span class="bp">+</span> <span class="err">↑</span><span class="n">p</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">p</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">norm_cast</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
<span class="n">specialize</span> <span class="n">s</span> <span class="o">(</span><span class="n">ne_of_lt</span> <span class="n">hp</span><span class="o">),</span>
<span class="n">rw</span> <span class="o">[</span><span class="n">nat</span><span class="bp">.</span><span class="n">pow_two</span><span class="o">]</span> <span class="n">at</span> <span class="n">s</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">lt_of_lt_of_le</span> <span class="n">s</span> <span class="n">r</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>

<a name="188610363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188610363" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188610363">Alex J. Best (Feb 20 2020 at 04:52)</a>:</h4>
<p>And the exact same proof still applies even if we started with reals or whatever as after norm_cast we end up in the same state.</p>

<a name="188611419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188611419" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188611419">Nicholas McConnell (Feb 20 2020 at 05:27)</a>:</h4>
<p>Thank you greatly.  I am learning Lean slowly but surely</p>

<a name="188617880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188617880" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188617880">Patrick Massot (Feb 20 2020 at 08:18)</a>:</h4>
<blockquote>
<p><code>have q := lt_trichotomy 0 a</code> will do that</p>
</blockquote>
<p>This works but doesn't teach Nicholas what he should have done. <span class="user-mention" data-user-id="263857">@Nicholas McConnell</span> what you wanted here was to type:</p>
<div class="codehilite"><pre><span></span><span class="k">have</span> <span class="n">q</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="bp">∨</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">∨</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="mi">0</span><span class="o">,</span>
  <span class="n">library_search</span><span class="o">,</span>
</pre></div>


<p>and look at the messages view.</p>

<a name="188618183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188618183" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188618183">Kevin Buzzard (Feb 20 2020 at 08:25)</a>:</h4>
<p>I know from experience of watching students that this one is hard to find because you have to get the three terms in the right order and I think &lt; vs &gt; might also matter</p>

<a name="188619030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188619030" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188619030">Patrick Massot (Feb 20 2020 at 08:43)</a>:</h4>
<p>Nicholas had the right statement!</p>

<a name="188619069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188619069" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188619069">Patrick Massot (Feb 20 2020 at 08:43)</a>:</h4>
<p>But it's true that library_search would find the variations. That would be a job for Gabriel.</p>

<a name="188656833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188656833" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188656833">Nicholas McConnell (Feb 20 2020 at 17:09)</a>:</h4>
<p><a href="/user_uploads/3121/KNUIIBNpeX8YqZtMhhe9pVR4/bandicam-2020-02-20-12-06-47-319.mp4" target="_blank" title="bandicam-2020-02-20-12-06-47-319.mp4">bandicam-2020-02-20-12-06-47-319.mp4</a> </p>
<p>So I tried using nat.find.  You say I'm supposed to pass in a proposition that a natural number satisfying a certain property exists, and then it'll return the smallest one.  I thought in the general case, it would return a new variable and adjoin conditions "it satisfies it" and "nothing smaller satisfies it."  But this is happening instead.  What should I really do?</p>

<a name="188657112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188657112" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188657112">Kevin Buzzard (Feb 20 2020 at 17:12)</a>:</h4>
<p>I can't watch the video on my phone because of download issues but iirc nat.find just produces a natural, and then lean also supplies the theorems saying that nat.find h satisfies all the things you want it to satisfy</p>

<a name="188657147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188657147" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188657147">Kevin Buzzard (Feb 20 2020 at 17:12)</a>:</h4>
<p>But the theorems are a different part of the api</p>

<a name="188658806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188658806" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188658806">Floris van Doorn (Feb 20 2020 at 17:31)</a>:</h4>
<p>You want to write <code>open_locale classical</code> near the top of your file (but not directly after the <code>import</code> statements). Then Lean will stop complaining about predicates being decidable.</p>

<a name="188658898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188658898" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188658898">Floris van Doorn (Feb 20 2020 at 17:32)</a>:</h4>
<p>Also, you want to use <code>let ds := nat.find d</code>, not <code>have</code>. <code>have</code> is for proofs of propositions, and Lean will forget how you proved them. <code>let</code> is for data, and Lean will remember how you defined them.</p>

<a name="188658969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188658969" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188658969">Floris van Doorn (Feb 20 2020 at 17:33)</a>:</h4>
<p><code>nat.find</code> itself will only give you the natural number. You can then use <code>nat.find_spec</code> and <code>nat.find_min</code> (or <code>nat.find_min'</code>) to know the properties about this natural number.</p>

<a name="188945210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188945210" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188945210">Nicholas McConnell (Feb 24 2020 at 17:07)</a>:</h4>
<p>Now I'm wondering if there's a way to convert, e.g., ↑(a+b*c) to ↑a + ↑b * ↑c, using the casting from naturals to integers<br>
Because I think I know how to carry on in this case.  [I just tried "ring" on expressions involving integers and it worked.]</p>

<a name="188945240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188945240" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188945240">Patrick Massot (Feb 24 2020 at 17:08)</a>:</h4>
<p><code>norm_cast</code></p>

<a name="188945576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188945576" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188945576">Nicholas McConnell (Feb 24 2020 at 17:11)</a>:</h4>
<p>I've tried that, but all I've seen it do is eliminate unnecessary ↑'s, such as changing the goal from ↑(a+b) * ↑c = ↑d to (a+b) * c = d</p>

<a name="188945658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188945658" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188945658">Nicholas McConnell (Feb 24 2020 at 17:12)</a>:</h4>
<p>I'm talking about expressions with subtraction, that you can't just do that do, but you can still distribute ↑ over + and *.</p>

<a name="188945718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188945718" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188945718">Alex J. Best (Feb 24 2020 at 17:12)</a>:</h4>
<p><code>push_cast</code>?</p>

<a name="188945741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188945741" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188945741">Nicholas McConnell (Feb 24 2020 at 17:13)</a>:</h4>
<p>Alright, let me try that</p>

<a name="188945749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188945749" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188945749">Nicholas McConnell (Feb 24 2020 at 17:13)</a>:</h4>
<p>Thanks Alex!</p>

<a name="188945773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188945773" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188945773">Nicholas McConnell (Feb 24 2020 at 17:13)</a>:</h4>
<p>I guess I'll mostly be here asking what commands are called. XD There are (presumed hyperbole) zillions of commands, as someone else pointed out</p>

<a name="188946252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188946252" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188946252">Patrick Massot (Feb 24 2020 at 17:19)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/tactics.html" target="_blank" title="https://leanprover-community.github.io/mathlib_docs/tactics.html">https://leanprover-community.github.io/mathlib_docs/tactics.html</a></p>

<a name="188946567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188946567" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188946567">Kevin Buzzard (Feb 24 2020 at 17:23)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#norm_cast" target="_blank" title="https://leanprover-community.github.io/mathlib_docs/tactics.html#norm_cast">https://leanprover-community.github.io/mathlib_docs/tactics.html#norm_cast</a> is where you want to look. <code>norm_cast</code> goes the other way to what you want -- <code>push_cast</code> goes the right way.</p>

<a name="188946898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188946898" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188946898">Johan Commelin (Feb 24 2020 at 17:27)</a>:</h4>
<p>Should <code>norm_cast</code> be renamed to <code>pull_cast</code>? <span aria-label="grinning face with smiling eyes" class="emoji emoji-1f601" role="img" title="grinning face with smiling eyes">:grinning_face_with_smiling_eyes:</span></p>

<a name="188946908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188946908" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188946908">Patrick Massot (Feb 24 2020 at 17:27)</a>:</h4>
<p>I'd be ready to bet that, if we could see the whole proof, we would end up using <code>norm_cast</code>.</p>

<a name="188947084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188947084" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188947084">Kevin Buzzard (Feb 24 2020 at 17:28)</a>:</h4>
<p>It is true that people usually want <code>norm_cast</code> rather than <code>push_cast</code>.  The fewer coercions the better!</p>

<a name="188947280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188947280" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188947280">Kevin Buzzard (Feb 24 2020 at 17:31)</a>:</h4>
<p>For an expression with subtraction there is <code>omega</code>. For example <code>example (n m : ℕ) : m + n - m = n := by omega</code> works, but <code>ring</code> fails because of natural number subtraction. On the other hand <code>omega</code> doesn't work with multiplication of two non-constant terms.</p>

<a name="188955042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188955042" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188955042">Mario Carneiro (Feb 24 2020 at 19:01)</a>:</h4>
<p>I think <code>simp</code> will also work to push down casts in most cases</p>

<a name="188955115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188955115" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188955115">Mario Carneiro (Feb 24 2020 at 19:02)</a>:</h4>
<p>which I think is the real reason <code>push_cast</code> doesn't see much use</p>

<a name="188955188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188955188" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188955188">Mario Carneiro (Feb 24 2020 at 19:02)</a>:</h4>
<p>that probably would have been my first step on Nicholas's goal</p>

<a name="188967952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188967952" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188967952">Nicholas McConnell (Feb 24 2020 at 21:27)</a>:</h4>
<p>push_cast isn't changing the goal from "↑(d * q + r) - ↑d * ↑q = ↑r" to "(↑d * ↑q + ↑r) - ↑d * ↑q = ↑r"... how should I do this?</p>

<a name="188968015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188968015" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188968015">Patrick Massot (Feb 24 2020 at 21:28)</a>:</h4>
<p>MWE?</p>

<a name="188968020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188968020" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188968020">Kevin Buzzard (Feb 24 2020 at 21:28)</a>:</h4>
<p>post some code?</p>

<a name="188968068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188968068" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188968068">Kevin Buzzard (Feb 24 2020 at 21:29)</a>:</h4>
<p>Do you actually want to make this change, or do you just want to prove the result?</p>

<a name="188968309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188968309" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188968309">Kevin Buzzard (Feb 24 2020 at 21:31)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">d</span> <span class="n">q</span> <span class="n">r</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">((</span><span class="n">d</span> <span class="bp">*</span> <span class="n">q</span> <span class="bp">+</span> <span class="n">r</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">-</span> <span class="n">d</span> <span class="bp">*</span> <span class="n">q</span> <span class="bp">=</span> <span class="n">r</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">push_cast</span><span class="o">,</span> <span class="n">ring</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>

<a name="188968392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188968392" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188968392">Nicholas McConnell (Feb 24 2020 at 21:32)</a>:</h4>
<p>Just want to prove the result</p>

<a name="188968418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188968418" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188968418">Kevin Buzzard (Feb 24 2020 at 21:32)</a>:</h4>
<p><code>push_cast</code> changed the goal to <code>⊢ ↑d * ↑q + ↑r - ↑d * ↑q = ↑r</code> for me, so you'll need to give some more clues</p>

<a name="188968573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188968573" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188968573">Nicholas McConnell (Feb 24 2020 at 21:34)</a>:</h4>
<p>If it helps, here's my topmost goal:</p>
<div class="codehilite"><pre><span></span><span class="mi">12</span> <span class="n">goals</span>
<span class="n">a</span> <span class="n">p</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span>
<span class="n">ha</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">divides</span> <span class="n">p</span> <span class="n">a</span><span class="o">,</span>
<span class="n">hp1</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">&lt;</span> <span class="n">p</span><span class="o">,</span>
<span class="n">hp2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">divides</span> <span class="n">k</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">k</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∨</span> <span class="n">k</span> <span class="bp">=</span> <span class="n">p</span><span class="o">,</span>
<span class="n">zero_lt_one</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="mi">1</span><span class="o">,</span>
<span class="n">p_pos</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">p</span><span class="o">,</span>
<span class="n">dh</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">d</span> <span class="bp">∧</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">),</span> <span class="n">x</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">a</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">p</span> <span class="bp">=</span> <span class="err">↑</span><span class="n">d</span><span class="o">,</span>
<span class="n">d</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">find</span> <span class="n">dh</span><span class="o">,</span>
<span class="n">dm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">d&#39;</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">d&#39;</span> <span class="bp">∧</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">),</span> <span class="n">x</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">a</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">p</span> <span class="bp">=</span> <span class="err">↑</span><span class="n">d&#39;</span><span class="o">)</span> <span class="bp">→</span> <span class="n">d</span> <span class="bp">≤</span> <span class="n">d&#39;</span><span class="o">,</span>
<span class="n">dx1</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">d</span><span class="o">,</span>
<span class="n">h1</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">&lt;</span> <span class="n">d</span><span class="o">,</span>
<span class="n">r</span> <span class="n">q</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span>
<span class="n">hq1</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">d</span> <span class="bp">*</span> <span class="n">q</span> <span class="bp">+</span> <span class="n">r</span><span class="o">,</span>
<span class="n">hq2</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">&lt;</span> <span class="n">d</span><span class="o">,</span>
<span class="n">x_ex</span> <span class="n">y_ex</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">,</span>
<span class="n">hy</span> <span class="o">:</span> <span class="n">x_ex</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">a</span> <span class="bp">+</span> <span class="n">y_ex</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">p</span> <span class="bp">=</span> <span class="err">↑</span><span class="n">d</span><span class="o">,</span>
<span class="n">thing</span> <span class="o">:</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">r</span> <span class="bp">∧</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">),</span> <span class="n">x</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">a</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">p</span> <span class="bp">=</span> <span class="err">↑</span><span class="n">r</span><span class="o">)</span> <span class="bp">→</span> <span class="n">d</span> <span class="bp">≤</span> <span class="n">r</span><span class="o">,</span>
<span class="n">htr1</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">r</span>
<span class="err">⊢</span> <span class="err">↑</span><span class="o">(</span><span class="n">d</span> <span class="bp">*</span> <span class="n">q</span> <span class="bp">+</span> <span class="n">r</span><span class="o">)</span> <span class="bp">-</span> <span class="err">↑</span><span class="n">d</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">q</span> <span class="bp">=</span> <span class="err">↑</span><span class="n">r</span>
</pre></div>


<p>push_cast is doing absolutely nothing for me</p>

<a name="188968729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188968729" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188968729">Kevin Buzzard (Feb 24 2020 at 21:36)</a>:</h4>
<p>This is no good, I can't tell what the uparrows mean.</p>

<a name="188968759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188968759" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188968759">Nicholas McConnell (Feb 24 2020 at 21:36)</a>:</h4>
<p>Casting from natural number to integer</p>

<a name="188968771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188968771" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188968771">Kevin Buzzard (Feb 24 2020 at 21:37)</a>:</h4>
<p>Can't you just post a working example of some code that I can just cut and paste so I can get into the same situation as you?</p>

<a name="188968791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188968791" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188968791">Kevin Buzzard (Feb 24 2020 at 21:37)</a>:</h4>
<p>I can't diagnose it just from the tactic state.</p>

<a name="188968841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188968841" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188968841">Kevin Buzzard (Feb 24 2020 at 21:37)</a>:</h4>
<p>PS I am impressed by the number of goals. There are tricks you can do with brackets which keeps this sort of thing under control.</p>

<a name="188968921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188968921" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188968921">Nicholas McConnell (Feb 24 2020 at 21:38)</a>:</h4>
<p>You gotta forgive me for being new to Lean! (<em>sniffs</em>)</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">universe</span> <span class="n">u</span>
<span class="n">local</span> <span class="n">attribute</span> <span class="o">[</span><span class="kn">instance</span><span class="o">]</span> <span class="n">classical</span><span class="bp">.</span><span class="n">prop_decidable</span>

<span class="kn">lemma</span> <span class="n">bezout</span> <span class="o">(</span><span class="n">a</span> <span class="n">p</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">prime</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">divides</span> <span class="n">p</span> <span class="n">a</span><span class="o">))</span> <span class="o">:</span>
  <span class="bp">∃</span><span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="bp">ℤ</span><span class="o">),</span> <span class="o">(</span><span class="bp">∃</span><span class="o">(</span><span class="n">y</span><span class="o">:</span><span class="bp">ℤ</span><span class="o">),</span> <span class="o">(</span><span class="n">x</span><span class="bp">*</span><span class="n">a</span> <span class="bp">+</span> <span class="n">y</span><span class="bp">*</span><span class="n">p</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">rw</span> <span class="n">prime</span> <span class="n">at</span> <span class="n">hp</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">hp</span> <span class="k">with</span> <span class="n">hp1</span> <span class="n">hp2</span><span class="o">,</span>
<span class="k">have</span> <span class="n">zero_lt_one</span> <span class="o">:=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">lt_succ_self</span> <span class="mi">0</span><span class="o">,</span>
<span class="k">have</span> <span class="n">p_pos</span> <span class="o">:=</span> <span class="n">lt_trans</span> <span class="n">zero_lt_one</span> <span class="n">hp1</span><span class="o">,</span>
<span class="k">have</span> <span class="n">dh</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">d</span> <span class="bp">∧</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">),</span> <span class="n">x</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">a</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">p</span> <span class="bp">=</span> <span class="err">↑</span><span class="n">d</span> <span class="o">:=</span> <span class="n">LCex</span> <span class="n">a</span> <span class="n">p</span> <span class="n">p_pos</span><span class="o">,</span>
<span class="k">let</span> <span class="n">d</span> <span class="o">:=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">find</span><span class="o">(</span><span class="n">dh</span><span class="o">),</span>
<span class="k">have</span> <span class="n">dx</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">d</span> <span class="bp">∧</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">),</span> <span class="n">x</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">a</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">p</span> <span class="bp">=</span> <span class="err">↑</span><span class="n">d</span> <span class="o">:=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">find_spec</span> <span class="n">dh</span><span class="o">,</span>
<span class="k">have</span> <span class="n">dm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">d&#39;</span><span class="o">,</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">d&#39;</span> <span class="bp">∧</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">),</span> <span class="n">x</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">a</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">p</span> <span class="bp">=</span> <span class="err">↑</span><span class="n">d&#39;</span><span class="o">)</span> <span class="bp">→</span> <span class="n">d</span> <span class="bp">≤</span> <span class="n">d&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">d&#39;</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">find_min&#39;</span> <span class="n">dh</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">dx</span> <span class="k">with</span> <span class="n">dx1</span> <span class="n">dx2</span><span class="o">,</span>
<span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">lt_trichotomy</span> <span class="mi">1</span> <span class="n">d</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span>
<span class="k">have</span> <span class="n">r1</span> <span class="o">:=</span> <span class="n">div_alg</span> <span class="n">a</span> <span class="n">d</span> <span class="n">dx1</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">r1</span> <span class="k">with</span> <span class="n">r</span> <span class="n">hr</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">hr</span> <span class="k">with</span> <span class="n">q</span> <span class="n">hq</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">hq</span> <span class="k">with</span> <span class="n">hq1</span> <span class="n">hq2</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">dx2</span> <span class="k">with</span> <span class="n">x_ex</span> <span class="n">hx</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">hx</span> <span class="k">with</span> <span class="n">y_ex</span> <span class="n">hy</span><span class="o">,</span>
<span class="k">have</span> <span class="n">thing</span> <span class="o">:=</span> <span class="n">dm</span> <span class="n">r</span><span class="o">,</span>
<span class="k">have</span> <span class="n">htr</span> <span class="o">:=</span> <span class="n">lt_trichotomy</span> <span class="mi">0</span> <span class="n">r</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">htr</span> <span class="k">with</span> <span class="n">htr1</span> <span class="n">htr2</span><span class="o">,</span>
<span class="k">have</span> <span class="n">claim</span> <span class="o">:</span> <span class="o">(</span><span class="mi">1</span><span class="bp">-</span><span class="n">x_ex</span><span class="bp">*</span><span class="n">q</span><span class="o">)</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">a</span> <span class="bp">+</span> <span class="o">(</span><span class="bp">-</span><span class="n">y_ex</span><span class="bp">*</span><span class="n">q</span><span class="o">)</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">p</span> <span class="bp">=</span> <span class="err">↑</span><span class="n">r</span><span class="o">,</span>
<span class="k">have</span> <span class="n">claim2</span> <span class="o">:</span> <span class="err">↑</span><span class="n">a</span><span class="bp">-</span><span class="err">↑</span><span class="n">d</span><span class="bp">*</span><span class="err">↑</span><span class="n">q</span> <span class="bp">=</span> <span class="err">↑</span><span class="n">r</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">hq1</span><span class="o">,</span>
<span class="n">push_cast</span><span class="o">,</span>

<span class="c1">-- ...</span>
<span class="kn">end</span>
</pre></div>

<a name="188968931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188968931" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188968931">Kevin Buzzard (Feb 24 2020 at 21:38)</a>:</h4>
<p>Alternatively type <code>set_option pp.all true</code> before your code and just post the goal (if you can find it ;-) )</p>

<a name="188968978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188968978" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188968978">Kevin Buzzard (Feb 24 2020 at 21:39)</a>:</h4>
<p>It doesn't run for me. Are you missing some imports or opens or something?</p>

<a name="188969058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188969058" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188969058">Nicholas McConnell (Feb 24 2020 at 21:40)</a>:</h4>
<p>Added them</p>
<p>(Also I omitted LCex and div_alg so you may as well change them to "sorry")</p>

<a name="188969098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188969098" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188969098">Kevin Buzzard (Feb 24 2020 at 21:40)</a>:</h4>
<p>It still doesn't run for me. Cut and paste what you're posting into a new file called <code>scratch.lean</code> or whatever and get it running.</p>

<a name="188969130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188969130" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188969130">Kevin Buzzard (Feb 24 2020 at 21:41)</a>:</h4>
<p>The optimal way to get help here is to make other people's lives easier.</p>

<a name="188969228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188969228" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188969228">Nicholas McConnell (Feb 24 2020 at 21:42)</a>:</h4>
<p>I did that and there's the same result</p>

<a name="188969240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188969240" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188969240">Nicholas McConnell (Feb 24 2020 at 21:42)</a>:</h4>
<p>Should I... upload the file to my drive so you can see it or something?</p>

<a name="188969320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188969320" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188969320">Scott Morrison (Feb 24 2020 at 21:43)</a>:</h4>
<p>Try minimising the file for a bit, and then copy and paste it here.</p>

<a name="188969327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188969327" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188969327">Kevin Buzzard (Feb 24 2020 at 21:43)</a>:</h4>
<p>Which Lean are you using? Which mathlib? With the latest Lean and mathlib I get</p>
<div class="codehilite"><pre><span></span>unknown identifier &#39;prime&#39;

unknown identifier &#39;divides&#39;
</pre></div>

<a name="188969393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188969393" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188969393">Nicholas McConnell (Feb 24 2020 at 21:44)</a>:</h4>
<p>Oh my bad, I mentioned div_alg but forgot I also defined my own "prime" and "divides"</p>

<a name="188969414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188969414" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188969414">Floris van Doorn (Feb 24 2020 at 21:44)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">example</span> <span class="o">(</span><span class="n">d</span> <span class="n">q</span> <span class="n">r</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">((</span><span class="n">d</span> <span class="bp">*</span> <span class="n">q</span> <span class="bp">+</span> <span class="n">r</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">-</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">q</span>  <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">r</span>  <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">push_cast</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>

<a name="188969446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188969446" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188969446">Kevin Buzzard (Feb 24 2020 at 21:44)</a>:</h4>
<p>OK so I say again: make a completely new file. Paste what you're pasting here into the new file. Make it work. Then post here.</p>

<a name="188969479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188969479" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188969479">Kevin Buzzard (Feb 24 2020 at 21:45)</a>:</h4>
<p>Doesn't matter if it's super-long. But neither Floris nor I can see the problem yet.</p>

<a name="188969497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188969497" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188969497">Nicholas McConnell (Feb 24 2020 at 21:45)</a>:</h4>
<p>Alright, that's what I'm about to do.  (Just a few minutes ago I was <em>very</em> unwilling to)</p>

<a name="188969593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188969593" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188969593">Nicholas McConnell (Feb 24 2020 at 21:46)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">universe</span> <span class="n">u</span>
<span class="n">local</span> <span class="n">attribute</span> <span class="o">[</span><span class="kn">instance</span><span class="o">]</span> <span class="n">classical</span><span class="bp">.</span><span class="n">prop_decidable</span>

<span class="n">def</span> <span class="n">ex1</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">*</span> <span class="n">z</span>

<span class="n">def</span> <span class="n">even</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="n">k</span><span class="o">,</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">2</span><span class="bp">*</span><span class="n">k</span>
<span class="n">def</span> <span class="n">odd</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="n">k</span><span class="o">,</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span>

<span class="n">def</span> <span class="n">divides</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="n">k</span><span class="o">,</span> <span class="n">n</span><span class="bp">*</span><span class="n">k</span> <span class="bp">=</span> <span class="n">m</span>
<span class="n">def</span> <span class="n">prime</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="mi">1</span> <span class="bp">&lt;</span> <span class="n">p</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">k</span><span class="o">,</span> <span class="o">(</span><span class="n">divides</span> <span class="n">k</span> <span class="n">p</span> <span class="bp">→</span> <span class="o">(</span><span class="n">k</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∨</span> <span class="n">k</span> <span class="bp">=</span> <span class="n">p</span><span class="o">)))</span>

<span class="kn">lemma</span> <span class="n">square_eq_times_itself</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span><span class="err">^</span><span class="mi">2</span> <span class="bp">=</span> <span class="n">a</span><span class="bp">*</span><span class="n">a</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">rw</span> <span class="n">pow_succ</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">pow_succ</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">pow_zero</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">mul_one</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">nonzero_square_pos</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≠</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">a</span><span class="err">^</span><span class="mi">2</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">sorry</span> <span class="c1">-- to make things easier to read</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">square_nonneg</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;=</span> <span class="n">a</span><span class="err">^</span><span class="mi">2</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">sorry</span> <span class="c1">-- to make things easier to read</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">LCex</span> <span class="o">(</span><span class="n">a</span> <span class="n">p</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span><span class="o">(</span><span class="n">d</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">),</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">d</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∃</span><span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="bp">ℤ</span><span class="o">),</span> <span class="o">(</span><span class="bp">∃</span><span class="o">(</span><span class="n">y</span><span class="o">:</span><span class="bp">ℤ</span><span class="o">),</span> <span class="o">(</span><span class="n">x</span><span class="bp">*</span><span class="n">a</span> <span class="bp">+</span> <span class="n">y</span><span class="bp">*</span><span class="n">p</span> <span class="bp">=</span> <span class="n">d</span><span class="o">)))</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">sorry</span> <span class="c1">-- to make things easier to read</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">div_alg</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span><span class="o">(</span><span class="n">r</span> <span class="n">q</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="o">(</span><span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="bp">*</span><span class="n">q</span><span class="bp">+</span><span class="n">r</span> <span class="bp">∧</span> <span class="n">r</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">sorry</span> <span class="c1">-- to make things easier to read</span>
<span class="kn">end</span>

<span class="n">def</span> <span class="n">isLC</span> <span class="o">(</span><span class="n">a</span> <span class="n">p</span> <span class="n">d</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">d</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∃</span><span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="bp">ℤ</span><span class="o">),</span> <span class="o">(</span><span class="bp">∃</span><span class="o">(</span><span class="n">y</span><span class="o">:</span><span class="bp">ℤ</span><span class="o">),</span> <span class="o">(</span><span class="n">x</span><span class="bp">*</span><span class="n">a</span> <span class="bp">+</span> <span class="n">y</span><span class="bp">*</span><span class="n">p</span> <span class="bp">=</span> <span class="n">d</span><span class="o">)))</span>

<span class="kn">lemma</span> <span class="n">bezout</span> <span class="o">(</span><span class="n">a</span> <span class="n">p</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">prime</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">divides</span> <span class="n">p</span> <span class="n">a</span><span class="o">))</span> <span class="o">:</span>
  <span class="bp">∃</span><span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="bp">ℤ</span><span class="o">),</span> <span class="o">(</span><span class="bp">∃</span><span class="o">(</span><span class="n">y</span><span class="o">:</span><span class="bp">ℤ</span><span class="o">),</span> <span class="o">(</span><span class="n">x</span><span class="bp">*</span><span class="n">a</span> <span class="bp">+</span> <span class="n">y</span><span class="bp">*</span><span class="n">p</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">rw</span> <span class="n">prime</span> <span class="n">at</span> <span class="n">hp</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">hp</span> <span class="k">with</span> <span class="n">hp1</span> <span class="n">hp2</span><span class="o">,</span>
<span class="k">have</span> <span class="n">zero_lt_one</span> <span class="o">:=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">lt_succ_self</span> <span class="mi">0</span><span class="o">,</span>
<span class="k">have</span> <span class="n">p_pos</span> <span class="o">:=</span> <span class="n">lt_trans</span> <span class="n">zero_lt_one</span> <span class="n">hp1</span><span class="o">,</span>
<span class="k">have</span> <span class="n">dh</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">d</span> <span class="bp">∧</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">),</span> <span class="n">x</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">a</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">p</span> <span class="bp">=</span> <span class="err">↑</span><span class="n">d</span> <span class="o">:=</span> <span class="n">LCex</span> <span class="n">a</span> <span class="n">p</span> <span class="n">p_pos</span><span class="o">,</span>
<span class="k">let</span> <span class="n">d</span> <span class="o">:=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">find</span><span class="o">(</span><span class="n">dh</span><span class="o">),</span>
<span class="k">have</span> <span class="n">dx</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">d</span> <span class="bp">∧</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">),</span> <span class="n">x</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">a</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">p</span> <span class="bp">=</span> <span class="err">↑</span><span class="n">d</span> <span class="o">:=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">find_spec</span> <span class="n">dh</span><span class="o">,</span>
<span class="k">have</span> <span class="n">dm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">d&#39;</span><span class="o">,</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">d&#39;</span> <span class="bp">∧</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">),</span> <span class="n">x</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">a</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">p</span> <span class="bp">=</span> <span class="err">↑</span><span class="n">d&#39;</span><span class="o">)</span> <span class="bp">→</span> <span class="n">d</span> <span class="bp">≤</span> <span class="n">d&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">d&#39;</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">find_min&#39;</span> <span class="n">dh</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">dx</span> <span class="k">with</span> <span class="n">dx1</span> <span class="n">dx2</span><span class="o">,</span>
<span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">lt_trichotomy</span> <span class="mi">1</span> <span class="n">d</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span>
<span class="k">have</span> <span class="n">r1</span> <span class="o">:=</span> <span class="n">div_alg</span> <span class="n">a</span> <span class="n">d</span> <span class="n">dx1</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">r1</span> <span class="k">with</span> <span class="n">r</span> <span class="n">hr</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">hr</span> <span class="k">with</span> <span class="n">q</span> <span class="n">hq</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">hq</span> <span class="k">with</span> <span class="n">hq1</span> <span class="n">hq2</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">dx2</span> <span class="k">with</span> <span class="n">x_ex</span> <span class="n">hx</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">hx</span> <span class="k">with</span> <span class="n">y_ex</span> <span class="n">hy</span><span class="o">,</span>
<span class="k">have</span> <span class="n">thing</span> <span class="o">:=</span> <span class="n">dm</span> <span class="n">r</span><span class="o">,</span>
<span class="k">have</span> <span class="n">htr</span> <span class="o">:=</span> <span class="n">lt_trichotomy</span> <span class="mi">0</span> <span class="n">r</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">htr</span> <span class="k">with</span> <span class="n">htr1</span> <span class="n">htr2</span><span class="o">,</span>
<span class="k">have</span> <span class="n">claim</span> <span class="o">:</span> <span class="o">(</span><span class="mi">1</span><span class="bp">-</span><span class="n">x_ex</span><span class="bp">*</span><span class="n">q</span><span class="o">)</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">a</span> <span class="bp">+</span> <span class="o">(</span><span class="bp">-</span><span class="n">y_ex</span><span class="bp">*</span><span class="n">q</span><span class="o">)</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">p</span> <span class="bp">=</span> <span class="err">↑</span><span class="n">r</span><span class="o">,</span>
<span class="k">have</span> <span class="n">claim2</span> <span class="o">:</span> <span class="err">↑</span><span class="n">a</span><span class="bp">-</span><span class="err">↑</span><span class="n">d</span><span class="bp">*</span><span class="err">↑</span><span class="n">q</span> <span class="bp">=</span> <span class="err">↑</span><span class="n">r</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">hq1</span><span class="o">,</span>
<span class="n">push_cast</span><span class="o">,</span>

<span class="c1">-- ...</span>
<span class="kn">end</span>
</pre></div>

<a name="188969597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188969597" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188969597">Scott Morrison (Feb 24 2020 at 21:46)</a>:</h4>
<p>(And while Kevin says it doesn't matter if it's super-long, learning how to generate a _minimal_ example of the problem you're encountering is a great skill -- more often than not you solve the problem yourself while minimising.)</p>

<a name="188969642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188969642" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188969642">Nicholas McConnell (Feb 24 2020 at 21:47)</a>:</h4>
<p>Oh yeah, I minimized it by replacing all the unimportant bodies to "sorry"</p>

<a name="188969656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188969656" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188969656">Nicholas McConnell (Feb 24 2020 at 21:47)</a>:</h4>
<p>When I did that, the push_cast still had the same result for me</p>

<a name="188969760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188969760" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188969760">Floris van Doorn (Feb 24 2020 at 21:48)</a>:</h4>
<p>Replace the line with <code>claim2</code> to <code>have claim2 : (a : ℤ)-↑d*↑q = ↑r,</code></p>

<a name="188969785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188969785" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188969785">Floris van Doorn (Feb 24 2020 at 21:49)</a>:</h4>
<p>You didn't actually tell Lean what the target of the <code>↑</code>'s were.</p>

<a name="188969794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188969794" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188969794">Kevin Buzzard (Feb 24 2020 at 21:49)</a>:</h4>
<p>Yes, they are not integers after all.</p>

<a name="188969820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188969820" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188969820">Kevin Buzzard (Feb 24 2020 at 21:49)</a>:</h4>
<p>They are just "some coercion from naturals to any old thing"</p>

<a name="188969828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188969828" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188969828">Scott Morrison (Feb 24 2020 at 21:49)</a>:</h4>
<p>Generally, you don't ever want to type <code>↑</code> yourself: always use the <code>(x : T)</code> mechanism.</p>

<a name="188969831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188969831" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188969831">Nicholas McConnell (Feb 24 2020 at 21:49)</a>:</h4>
<p>Ohh, I finally get it.</p>
<p>And you're finally glad I posted that MWE, huh.</p>

<a name="188969926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188969926" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188969926">Kevin Buzzard (Feb 24 2020 at 21:50)</a>:</h4>
<p>In fact you can probably write <code>claim2 : (a : ℤ) - d * q = r</code> because Lean will  figure out all the coercions itself once you explicitly tell it the first one.</p>

<a name="188970020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188970020" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188970020">Kevin Buzzard (Feb 24 2020 at 21:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="263857">Nicholas McConnell</span> <a href="#narrow/stream/116395-maths/topic/well-ordering.20principle/near/188969831" title="#narrow/stream/116395-maths/topic/well-ordering.20principle/near/188969831">said</a>:</p>
<blockquote>
<p>And you're finally glad I posted that MWE, huh.</p>
</blockquote>
<p>In the sense that I wasted some time trying to diagnose your problem when you were withholding information, but the moment you posted a MWE the answer was clear, yes.</p>

<a name="188970300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188970300" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188970300">Nicholas McConnell (Feb 24 2020 at 21:54)</a>:</h4>
<p>Alright, my apologies for that.</p>

<a name="188971547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188971547" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188971547">Kevin Buzzard (Feb 24 2020 at 22:08)</a>:</h4>
<p>I guess the other thing worth saying is that once you learn how to post MWEs and not just WEs, you start stripping away the irrelevant stuff and you then often end up solving your own problems. If you had done that here, you would see that the goal was created by <code>claim2</code> and once everything else was stripped away you would have ended up with</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">lemma</span> <span class="n">MWE</span> <span class="o">(</span><span class="n">a</span> <span class="n">d</span> <span class="n">q</span> <span class="n">r</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hq1</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">d</span> <span class="bp">*</span> <span class="n">q</span> <span class="bp">+</span> <span class="n">r</span><span class="o">)</span>
  <span class="o">:</span> <span class="n">false</span> <span class="c1">-- irrelevant goal</span>
  <span class="o">:=</span>
<span class="k">begin</span>
<span class="k">have</span> <span class="n">claim2</span> <span class="o">:</span> <span class="err">↑</span><span class="n">a</span><span class="bp">-</span><span class="err">↑</span><span class="n">d</span><span class="bp">*</span><span class="err">↑</span><span class="n">q</span> <span class="bp">=</span> <span class="err">↑</span><span class="n">r</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">hq1</span><span class="o">,</span>
<span class="n">push_cast</span><span class="o">,</span>
<span class="n">repeat</span> <span class="o">{</span><span class="n">sorry</span><span class="o">}</span>
<span class="kn">end</span>
</pre></div>


<p>You could have made that yourself. Now look at what happens after <code>claim2</code> -- the number of goals goes from 1 to 9. So now you can see where the problem probably is.</p>

<a name="188972512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188972512" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188972512">Kevin Buzzard (Feb 24 2020 at 22:20)</a>:</h4>
<p>Other notes: <code>square_eq_times_itself</code> is already in mathlib and is called <code>pow_two</code>. Of course it's very good practice for a beginner to prove these things themselves, but don't forget <code>library_search</code>. We have <code>mul_self_pos</code> and <code>mul_self_nonneg</code> as well, which will make some of those sorrys easy to remove. The rule of thumb is: if it's obvious, it's already there.</p>

<a name="188974255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188974255" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188974255">Nicholas McConnell (Feb 24 2020 at 22:43)</a>:</h4>
<p>(deleted)</p>

<a name="188974572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188974572" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188974572">Kevin Buzzard (Feb 24 2020 at 22:48)</a>:</h4>
<p>In tactic mode you can just do this:</p>
<div class="codehilite"><pre><span></span><span class="kn">variable</span> <span class="o">(</span><span class="n">foo</span> <span class="o">:</span> <span class="bp">ℤ</span> <span class="bp">→</span> <span class="bp">ℤ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="kn">lemma</span> <span class="n">test</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="bp">∀</span><span class="o">(</span><span class="n">x</span> <span class="n">y</span><span class="o">:</span><span class="bp">ℤ</span><span class="o">),(</span><span class="n">foo</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">x</span><span class="bp">+</span><span class="n">y</span><span class="bp">=</span><span class="mi">0</span><span class="o">))</span> <span class="o">:</span> <span class="bp">∀</span><span class="o">(</span><span class="n">x</span> <span class="n">y</span><span class="o">:</span><span class="bp">ℤ</span><span class="o">),(</span><span class="n">foo</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">y</span><span class="bp">+</span><span class="n">x</span><span class="bp">=</span><span class="mi">0</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span> <span class="n">x</span> <span class="n">y</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">add_comm</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">hp</span> <span class="n">x</span> <span class="n">y</span> <span class="n">h</span>
<span class="kn">end</span>
</pre></div>


<p>In term mode you can use the stupid triangle which I can never get to work.</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">test&#39;</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="bp">∀</span><span class="o">(</span><span class="n">x</span> <span class="n">y</span><span class="o">:</span><span class="bp">ℤ</span><span class="o">),(</span><span class="n">foo</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">x</span><span class="bp">+</span><span class="n">y</span><span class="bp">=</span><span class="mi">0</span><span class="o">))</span> <span class="o">:</span> <span class="bp">∀</span><span class="o">(</span><span class="n">x</span> <span class="n">y</span><span class="o">:</span><span class="bp">ℤ</span><span class="o">),(</span><span class="n">foo</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">y</span><span class="bp">+</span><span class="n">x</span><span class="bp">=</span><span class="mi">0</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">h</span><span class="o">,</span> <span class="n">add_comm</span> <span class="bp">▸</span> <span class="n">hp</span> <span class="n">x</span> <span class="n">y</span> <span class="n">h</span> <span class="c1">-- doesn&#39;t work</span>
</pre></div>


<div class="codehilite"><pre><span></span>
</pre></div>

<a name="188974635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188974635" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188974635">Kevin Buzzard (Feb 24 2020 at 22:48)</a>:</h4>
<p>oh I got it:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">test&#39;</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="bp">∀</span><span class="o">(</span><span class="n">x</span> <span class="n">y</span><span class="o">:</span><span class="bp">ℤ</span><span class="o">),(</span><span class="n">foo</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">x</span><span class="bp">+</span><span class="n">y</span><span class="bp">=</span><span class="mi">0</span><span class="o">))</span> <span class="o">:</span> <span class="bp">∀</span><span class="o">(</span><span class="n">x</span> <span class="n">y</span><span class="o">:</span><span class="bp">ℤ</span><span class="o">),(</span><span class="n">foo</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">y</span><span class="bp">+</span><span class="n">x</span><span class="bp">=</span><span class="mi">0</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">h</span><span class="o">,</span> <span class="n">add_comm</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">▸</span> <span class="n">hp</span> <span class="n">x</span> <span class="n">y</span> <span class="n">h</span>
</pre></div>

<a name="188974644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188974644" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188974644">Kevin Buzzard (Feb 24 2020 at 22:48)</a>:</h4>
<p>I always forget it's not as smart as <code>rw</code></p>

<a name="188974649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188974649" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188974649">Nicholas McConnell (Feb 24 2020 at 22:48)</a>:</h4>
<p>Thanks, even though I figured it out</p>

<a name="189086513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/189086513" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#189086513">Nicholas McConnell (Feb 26 2020 at 05:03)</a>:</h4>
<p>How do I change a hypothesis from 0 ≤ 2 * r to 0 ≤ 2 * ↑r (involving integers)?  I don't see how to use norm_cast while specifying I want it to go to integers.</p>
<p>In other words, given</p>
<div class="codehilite"><pre><span></span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span>
<span class="n">b_pos</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="o">,</span>
<span class="n">ho</span> <span class="o">:</span> <span class="n">odd</span> <span class="n">b</span><span class="o">,</span>
<span class="n">r</span> <span class="n">q</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span>
<span class="n">tri1</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">r</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="o">,</span>
<span class="n">divq1</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">q</span> <span class="bp">+</span> <span class="n">r</span><span class="o">,</span>
<span class="n">divq2</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="o">,</span>
<span class="n">thing</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">r</span>
</pre></div>


<p>how can I get thing2 : 0 ≤ 2 * ↑r ?</p>

<a name="189086524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/189086524" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#189086524">Nicholas McConnell (Feb 26 2020 at 05:03)</a>:</h4>
<p>[I trust that since this is not a problem-diagnosing question I don't need to put an MWE]</p>

<a name="189086632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/189086632" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#189086632">Nicholas McConnell (Feb 26 2020 at 05:06)</a>:</h4>
<p>By the way, my ambition is to prove that (-2) * ↑r ≤ 0</p>

<a name="189086824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/189086824" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#189086824">Bryan Gin-ge Chen (Feb 26 2020 at 05:14)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">lemma</span> <span class="n">foo</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">thing</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">r</span><span class="o">)</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">have</span> <span class="n">thing2</span> <span class="o">:</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">≤</span> <span class="mi">2</span> <span class="bp">*</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">))</span> <span class="o">:=</span>
    <span class="k">by</span> <span class="o">{</span> <span class="n">norm_cast</span><span class="o">,</span> <span class="n">exact</span> <span class="n">thing</span> <span class="o">},</span>
  <span class="n">trivial</span>
<span class="kn">end</span>
</pre></div>


<p>[MWEs are always preferable because it's easier to give a good suggestion when we can quickly check whether it works. Very few of us can emulate Lean + mathlib perfectly in our heads.]</p>

<a name="189086938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/189086938" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#189086938">Nicholas McConnell (Feb 26 2020 at 05:17)</a>:</h4>
<p>Thanks.  Also, I'll keep that in mind.</p>


{% endraw %}

{% include archive_update.html %}