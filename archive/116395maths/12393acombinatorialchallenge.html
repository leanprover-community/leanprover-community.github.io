---
layout: archive
title: Lean Prover Zulip Chat Archive 
permalink: archive/116395maths/12393acombinatorialchallenge.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html">a combinatorial challenge</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="157604832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157604832" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157604832">Johan Commelin (Feb 05 2019 at 13:05)</a>:</h4>
<p>Here is a nice little challenge that I don't really know how to formalise.<br>
We need graphs. What is a graph? In this case it will be a bunch of nodes and edges. No multiple edges, no self-loops, no directed edges.<br>
If <code>g</code> is a node, then <code>N(g)</code> is the set of its neighbouring nodes, so <code>{g' : G | (g,g') ∈ E(G)}</code>.</p>
<p>Let <code>G</code> be a finite connected graph. And let <code>w : G → pnat</code> be a function that labels the nodes of <code>G</code> with positive natural numbers. We say that <code>(G, w)</code> is <em>good</em> if it satisfies the following condition: for all <code>g : G</code> we have <code>2 * w(g) = sum_{g' ∈ N(g)} w(g')</code>.</p>
<p>Challenge: enumerate all good finite connected labeled graphs <code>(G, w)</code>.</p>

<a name="157606026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157606026" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157606026">Chris Hughes (Feb 05 2019 at 13:26)</a>:</h4>
<p>Define "enumerate"</p>

<a name="157606386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157606386" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157606386">Mario Carneiro (Feb 05 2019 at 13:33)</a>:</h4>
<p>ah, this is a step in the CFSG I think</p>

<a name="157606392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157606392" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157606392">Mario Carneiro (Feb 05 2019 at 13:33)</a>:</h4>
<p>these are dynkin diagrams?</p>

<a name="157608176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157608176" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157608176">Johan Commelin (Feb 05 2019 at 14:02)</a>:</h4>
<p>Bingo! Now how do we put that in Lean?</p>

<a name="157608200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157608200" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157608200">Johan Commelin (Feb 05 2019 at 14:03)</a>:</h4>
<p>(Note, you don't get all Dynkin diagrams. Only the ones without multi-edges. And you'll also miss <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">A_1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span>.)</p>

<a name="157608351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157608351" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157608351">Mario Carneiro (Feb 05 2019 at 14:05)</a>:</h4>
<p>The list is pretty short, right? I thought it was a simple counting argument, but I doubt some general enumeration mechanism will help</p>

<a name="157608413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157608413" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157608413">Johan Commelin (Feb 05 2019 at 14:06)</a>:</h4>
<p>Should Dynkin diagrams be some sort of inductive type?</p>

<a name="157608422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157608422" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157608422">Johan Commelin (Feb 05 2019 at 14:06)</a>:</h4>
<p>I have no idea how to do graph theory in Lean.</p>

<a name="157608431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157608431" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157608431">Mario Carneiro (Feb 05 2019 at 14:06)</a>:</h4>
<p>Actually I'm thinking more about the math part here</p>

<a name="157608450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157608450" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157608450">Mario Carneiro (Feb 05 2019 at 14:07)</a>:</h4>
<p>the representation depends on how you intend to argue it</p>

<a name="157608541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157608541" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157608541">Johan Commelin (Feb 05 2019 at 14:08)</a>:</h4>
<p>I guess I agree with "a simple counting argument".</p>

<a name="157608666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157608666" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157608666">Mario Carneiro (Feb 05 2019 at 14:10)</a>:</h4>
<p>Do you know why the list is finite or how you argue for this?</p>

<a name="157608667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157608667" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157608667">Johan Commelin (Feb 05 2019 at 14:10)</a>:</h4>
<p>But what does that mean for formalising this?</p>

<a name="157608671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157608671" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157608671">Johan Commelin (Feb 05 2019 at 14:10)</a>:</h4>
<p>The list isn't exactly finite.</p>

<a name="157608690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157608690" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157608690">Mario Carneiro (Feb 05 2019 at 14:10)</a>:</h4>
<p>do you know why it's tightly constrained</p>

<a name="157608693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157608693" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157608693">Johan Commelin (Feb 05 2019 at 14:10)</a>:</h4>
<p>Yes</p>

<a name="157608783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157608783" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157608783">Johan Commelin (Feb 05 2019 at 14:12)</a>:</h4>
<p>First you have to bound <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">#</mi><mi>N</mi><mo>(</mo><mi>g</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\# N(g)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathrm">#</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mclose">)</span></span></span></span>.</p>

<a name="157608807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157608807" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157608807">Johan Commelin (Feb 05 2019 at 14:12)</a>:</h4>
<p>After that you need a little argument with arithmetic progressions (of very short length).</p>

<a name="157609065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157609065" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157609065">Mario Carneiro (Feb 05 2019 at 14:17)</a>:</h4>
<p>So I guess you have an arbitrary graph, on an arbitrary type, and you produce a bijection to some known graph by cases</p>

<a name="157609086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157609086" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157609086">Mario Carneiro (Feb 05 2019 at 14:17)</a>:</h4>
<p>the graph itself can be represented by a symmetric irreflexive edge relation like you said</p>

<a name="157609400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157609400" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157609400">Mario Carneiro (Feb 05 2019 at 14:23)</a>:</h4>
<p>To prove graph isomorphism formally seems a little tedious. One general method: If you have an injective function on vertices, you know all the degrees of the vertices, and you have a list of edges that are mapped to the other graph, which matches the degrees, then you can prove that the map is a graph isomorphism</p>

<a name="157609467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157609467" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157609467">Mario Carneiro (Feb 05 2019 at 14:24)</a>:</h4>
<p>(I hate doing graphs formally, there's no great method)</p>

<a name="157609552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157609552" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157609552">Johan Commelin (Feb 05 2019 at 14:25)</a>:</h4>
<blockquote>
<p>(I hate doing graphs formally, there's no great method)</p>
</blockquote>
<p>That's discouraging.</p>

<a name="157609604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157609604" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157609604">Mario Carneiro (Feb 05 2019 at 14:26)</a>:</h4>
<p>well, general graphs are fine, but small finite graphs are a pain</p>

<a name="157609630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157609630" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157609630">Mario Carneiro (Feb 05 2019 at 14:26)</a>:</h4>
<p>just like small finite anything</p>

<a name="157609659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157609659" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157609659">Mario Carneiro (Feb 05 2019 at 14:27)</a>:</h4>
<p>the less concretely you have to talk about the stuff, the better</p>

<a name="157609765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157609765" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157609765">Mario Carneiro (Feb 05 2019 at 14:28)</a>:</h4>
<p>so in this case you might be able to avoid doing graph isomorphism entirely, and instead say something like "there is a vertex of degree 3 attached to vertices of degree 2, there is a path to such and such with this pattern, etc"</p>

<a name="157609796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157609796" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157609796">Mario Carneiro (Feb 05 2019 at 14:28)</a>:</h4>
<p>and maybe that's good enough for whatever purpose you need this classification</p>

<a name="157614420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157614420" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157614420">Johan Commelin (Feb 05 2019 at 15:29)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">graph</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">E</span>     <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">symm</span>  <span class="o">:</span> <span class="bp">∀</span> <span class="n">g₁</span> <span class="n">g₂</span><span class="o">,</span> <span class="n">E</span> <span class="n">g₁</span> <span class="n">g₂</span> <span class="bp">↔</span> <span class="n">E</span> <span class="n">g₂</span> <span class="n">g₁</span><span class="o">)</span>
<span class="o">(</span><span class="n">irref</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">g</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">E</span> <span class="n">g</span> <span class="n">g</span><span class="o">)</span>

<span class="n">def</span> <span class="n">graph</span><span class="bp">.</span><span class="n">unit</span> <span class="o">:</span> <span class="n">graph</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">E</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span>
  <span class="n">symm</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">iff</span><span class="bp">.</span><span class="n">rfl</span><span class="o">,</span>
  <span class="n">irref</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">id</span> <span class="o">}</span>

<span class="n">def</span> <span class="n">graph</span><span class="bp">.</span><span class="n">glue</span> <span class="o">{</span><span class="n">G₁</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">gr₁</span> <span class="o">:</span> <span class="n">graph</span> <span class="n">G₁</span><span class="o">)</span> <span class="o">{</span><span class="n">G₂</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">gr₂</span> <span class="o">:</span> <span class="n">graph</span> <span class="n">G₂</span><span class="o">)</span> <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="n">G₁</span> <span class="bp">→</span> <span class="n">G₂</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">graph</span> <span class="o">(</span><span class="n">G₁</span> <span class="err">⊕</span> <span class="n">G₂</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">E</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span> <span class="n">g&#39;</span><span class="o">,</span>
  <span class="k">begin</span>
    <span class="n">cases</span> <span class="n">g</span> <span class="k">with</span> <span class="n">g₁</span> <span class="n">g₂</span><span class="bp">;</span>
    <span class="n">cases</span> <span class="n">g&#39;</span> <span class="k">with</span> <span class="n">g₁&#39;</span> <span class="n">g₂&#39;</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">gr₁</span><span class="bp">.</span><span class="n">E</span> <span class="n">g₁</span> <span class="n">g₁&#39;</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">E</span> <span class="n">g₁</span> <span class="n">g₂&#39;</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">E</span> <span class="n">g₁&#39;</span> <span class="n">g₂</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">gr₂</span><span class="bp">.</span><span class="n">E</span> <span class="n">g₂</span> <span class="n">g₂&#39;</span> <span class="o">}</span>
  <span class="kn">end</span><span class="o">,</span>
  <span class="n">symm</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span> <span class="n">g&#39;</span><span class="o">,</span>
  <span class="k">begin</span>
    <span class="n">cases</span> <span class="n">g</span> <span class="k">with</span> <span class="n">g₁</span> <span class="n">g₂</span><span class="bp">;</span>
    <span class="n">cases</span> <span class="n">g&#39;</span> <span class="k">with</span> <span class="n">g₁&#39;</span> <span class="n">g₂&#39;</span><span class="bp">;</span>
    <span class="n">try</span> <span class="o">{</span> <span class="n">exact</span> <span class="n">graph</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">}</span><span class="bp">;</span>
    <span class="n">try</span> <span class="o">{</span> <span class="n">exact</span> <span class="n">iff</span><span class="bp">.</span><span class="n">rfl</span> <span class="o">}</span>
  <span class="kn">end</span><span class="o">,</span>
  <span class="n">irref</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span><span class="o">,</span>
  <span class="k">begin</span>
    <span class="n">cases</span> <span class="n">g</span> <span class="k">with</span> <span class="n">g₁</span> <span class="n">g₂</span><span class="bp">;</span>
    <span class="n">exact</span> <span class="n">graph</span><span class="bp">.</span><span class="n">irref</span> <span class="bp">_</span> <span class="bp">_</span>
  <span class="kn">end</span> <span class="o">}</span>

<span class="kn">namespace</span> <span class="n">Dynkin</span>

<span class="n">def</span> <span class="n">A</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">graph</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">E</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">j</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="n">i</span><span class="bp">.</span><span class="n">val</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">∨</span> <span class="n">i</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="n">j</span><span class="bp">.</span><span class="n">val</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">symm</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">or</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">symm</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">irref</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span> <span class="n">h</span><span class="o">,</span> <span class="k">by</span> <span class="n">cases</span> <span class="n">h</span><span class="bp">;</span>
    <span class="o">{</span> <span class="n">conv</span> <span class="n">at</span> <span class="n">h</span> <span class="o">{</span> <span class="n">to_lhs</span><span class="o">,</span> <span class="n">rw</span> <span class="err">←</span> <span class="n">nat</span><span class="bp">.</span><span class="n">add_zero</span> <span class="n">i</span><span class="bp">.</span><span class="n">val</span> <span class="o">},</span>
      <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">no_confusion</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">add_left_cancel</span> <span class="n">h</span><span class="o">)</span> <span class="o">}</span> <span class="o">}</span>

<span class="n">def</span> <span class="n">D_type</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="mi">0</span>     <span class="o">:=</span> <span class="n">fin</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">fin</span> <span class="n">n</span> <span class="err">⊕</span> <span class="n">unit</span>

<span class="n">def</span> <span class="n">D</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">graph</span> <span class="o">(</span><span class="n">D_type</span> <span class="n">n</span><span class="o">)</span>
<span class="bp">|</span> <span class="mi">0</span>     <span class="o">:=</span> <span class="n">A</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">A</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">glue</span> <span class="n">graph</span><span class="bp">.</span><span class="n">unit</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="bp">_</span><span class="o">,</span> <span class="n">i</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span>

<span class="kn">end</span> <span class="n">Dynkin</span>
</pre></div>

<a name="157614468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157614468" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157614468">Johan Commelin (Feb 05 2019 at 15:29)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Does it make sense to do something like this. Or is this asking for trouble somewhere down the road?</p>

<a name="157614998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157614998" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157614998">Johan Commelin (Feb 05 2019 at 15:35)</a>:</h4>
<p>One can also do E6, E7, and E8 by gluing. But I guess these are better done as inductive types, to allow easy case bashing.</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">E6_type</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">fin</span> <span class="mi">4</span> <span class="err">⊕</span> <span class="n">fin</span> <span class="mi">2</span>

<span class="n">def</span> <span class="n">E7_type</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">fin</span> <span class="mi">4</span> <span class="err">⊕</span> <span class="n">fin</span> <span class="mi">3</span>

<span class="n">def</span> <span class="n">E8_type</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">fin</span> <span class="mi">4</span> <span class="err">⊕</span> <span class="n">fin</span> <span class="mi">4</span>

<span class="n">def</span> <span class="n">E6</span> <span class="o">:</span> <span class="n">graph</span> <span class="n">E6_type</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">A</span> <span class="mi">4</span><span class="o">)</span><span class="bp">.</span><span class="n">glue</span> <span class="o">(</span><span class="n">A</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">i</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">∧</span> <span class="n">j</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>

<span class="n">def</span> <span class="n">E7</span> <span class="o">:</span> <span class="n">graph</span> <span class="n">E7_type</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">A</span> <span class="mi">4</span><span class="o">)</span><span class="bp">.</span><span class="n">glue</span> <span class="o">(</span><span class="n">A</span> <span class="mi">3</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">i</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">∧</span> <span class="n">j</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>

<span class="n">def</span> <span class="n">E8</span> <span class="o">:</span> <span class="n">graph</span> <span class="n">E8_type</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">A</span> <span class="mi">4</span><span class="o">)</span><span class="bp">.</span><span class="n">glue</span> <span class="o">(</span><span class="n">A</span> <span class="mi">4</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">i</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">∧</span> <span class="n">j</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>
</pre></div>

<a name="157615667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157615667" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157615667">Mario Carneiro (Feb 05 2019 at 15:44)</a>:</h4>
<p>I think there is a good case for bundling here, it would allow you to skip the <code>D</code> and <code>D_type</code> thing</p>

<a name="157615683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157615683" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157615683">Mario Carneiro (Feb 05 2019 at 15:45)</a>:</h4>
<p>at least based on these few examples</p>

<a name="157615790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157615790" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157615790">Mario Carneiro (Feb 05 2019 at 15:46)</a>:</h4>
<p>Probably <code>graph.symm</code> should be unidirectional</p>

<a name="157615809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157615809" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157615809">Johan Commelin (Feb 05 2019 at 15:46)</a>:</h4>
<p>Can you explain why? I'd like to get a better understanding for that kind of issues.</p>

<a name="157615847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157615847" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157615847">Mario Carneiro (Feb 05 2019 at 15:47)</a>:</h4>
<p>well, all of the constructions you have done so far have to come in two parts</p>

<a name="157615858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157615858" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157615858">Chris Hughes (Feb 05 2019 at 15:47)</a>:</h4>
<p>Because it's equivalent and easier to prove.</p>

<a name="157615865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157615865" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157615865">Mario Carneiro (Feb 05 2019 at 15:48)</a>:</h4>
<p>and the type doesn't have much more semantic information than "the vertex type of the graph"</p>

<a name="157615974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157615974" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157615974">Mario Carneiro (Feb 05 2019 at 15:49)</a>:</h4>
<p>There are other ways to use a data structure like this for which unbundled might make sense, but for building and manipulating small graphs I think it's more natural to bundle here</p>

<a name="157616053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157616053" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157616053">Johan Commelin (Feb 05 2019 at 15:50)</a>:</h4>
<p>Aah, sorry for the confusion. I was asking about the unidirectional thing.</p>

<a name="157616069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157616069" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157616069">Mario Carneiro (Feb 05 2019 at 15:50)</a>:</h4>
<p>well, it's equivalent, but easier to prove</p>

<a name="157616094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157616094" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157616094">Johan Commelin (Feb 05 2019 at 15:51)</a>:</h4>
<p>Ok</p>

<a name="157616111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157616111" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157616111">Mario Carneiro (Feb 05 2019 at 15:51)</a>:</h4>
<p>you want the thing in the structure to be the weakest constraint since that's what you have to show in constructions</p>

<a name="157616119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157616119" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157616119">Johan Commelin (Feb 05 2019 at 15:51)</a>:</h4>
<p>Aah, of course</p>

<a name="157616140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157616140" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157616140">Mario Carneiro (Feb 05 2019 at 15:51)</a>:</h4>
<p>you can prove the bidirectional version as a theorem</p>

<a name="157616318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157616318" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157616318">Mario Carneiro (Feb 05 2019 at 15:54)</a>:</h4>
<p>now you still have to define a weight on G, and show that these guys have good weights</p>

<a name="157616337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157616337" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157616337">Reid Barton (Feb 05 2019 at 15:54)</a>:</h4>
<p>will bundling make it awkward to prove theorems valid only for finite graphs?</p>

<a name="157616346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157616346" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157616346">Mario Carneiro (Feb 05 2019 at 15:55)</a>:</h4>
<p>there will be a typeclass for finite graph</p>

<a name="157616403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157616403" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157616403">Mario Carneiro (Feb 05 2019 at 15:55)</a>:</h4>
<p>which should include some kind of computational content to work with the graph, like an adjacency list</p>

<a name="157616529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157616529" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157616529">Mario Carneiro (Feb 05 2019 at 15:57)</a>:</h4>
<p>unless you just want to say finite in the abstract, but you can still use <code>fintype G.V</code> or whatever</p>

<a name="157616619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157616619" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157616619">Johan Commelin (Feb 05 2019 at 15:58)</a>:</h4>
<p>This is what I have now (after bundling):</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">fin</span>

<span class="kn">structure</span> <span class="n">graph</span>
<span class="o">(</span><span class="n">V</span>     <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
<span class="o">(</span><span class="n">E</span>     <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">symm</span>  <span class="o">:</span> <span class="bp">∀</span> <span class="n">v₁</span> <span class="n">v₂</span><span class="o">,</span> <span class="n">E</span> <span class="n">v₁</span> <span class="n">v₂</span> <span class="bp">→</span> <span class="n">E</span> <span class="n">v₂</span> <span class="n">v₁</span><span class="o">)</span>
<span class="o">(</span><span class="n">irref</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">v</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">E</span> <span class="n">v</span> <span class="n">v</span><span class="o">)</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_coe_to_sort</span> <span class="n">graph</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">S</span> <span class="o">:=</span> <span class="kt">Type</span><span class="o">,</span>
  <span class="n">coe</span> <span class="o">:=</span> <span class="n">graph</span><span class="bp">.</span><span class="n">V</span> <span class="o">}</span>

<span class="n">def</span> <span class="n">graph</span><span class="bp">.</span><span class="n">unit</span> <span class="o">:</span> <span class="n">graph</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">V</span> <span class="o">:=</span> <span class="n">unit</span><span class="o">,</span>
  <span class="n">E</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span>
  <span class="n">symm</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">id</span><span class="o">,</span>
  <span class="n">irref</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">id</span> <span class="o">}</span>

<span class="n">def</span> <span class="n">graph</span><span class="bp">.</span><span class="n">glue</span> <span class="o">(</span><span class="n">G₁</span> <span class="o">:</span> <span class="n">graph</span><span class="o">)</span> <span class="o">(</span><span class="n">G₂</span> <span class="o">:</span> <span class="n">graph</span><span class="o">)</span> <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="n">G₁</span> <span class="bp">→</span> <span class="n">G₂</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">graph</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">V</span> <span class="o">:=</span> <span class="n">G₁</span> <span class="err">⊕</span> <span class="n">G₂</span><span class="o">,</span>
  <span class="n">E</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">v</span> <span class="n">v&#39;</span><span class="o">,</span>
  <span class="k">begin</span>
    <span class="n">cases</span> <span class="n">v</span> <span class="k">with</span> <span class="n">v</span> <span class="n">v</span><span class="bp">;</span>
    <span class="n">cases</span> <span class="n">v&#39;</span> <span class="k">with</span> <span class="n">v&#39;</span> <span class="n">v&#39;</span><span class="bp">;</span>
    <span class="n">try</span> <span class="o">{</span> <span class="n">exact</span> <span class="n">graph</span><span class="bp">.</span><span class="n">E</span> <span class="bp">_</span> <span class="n">v</span> <span class="n">v&#39;</span> <span class="o">}</span><span class="bp">;</span>
    <span class="n">try</span> <span class="o">{</span> <span class="n">exact</span> <span class="n">E</span> <span class="err">‹</span><span class="n">G₁</span><span class="err">›</span> <span class="err">‹</span><span class="n">G₂</span><span class="err">›</span> <span class="o">},</span>
  <span class="kn">end</span><span class="o">,</span>
  <span class="n">symm</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">v</span> <span class="n">v&#39;</span><span class="o">,</span>
  <span class="k">begin</span>
    <span class="n">cases</span> <span class="n">v</span> <span class="k">with</span> <span class="n">v₁</span> <span class="n">v₂</span><span class="bp">;</span>
    <span class="n">cases</span> <span class="n">v&#39;</span> <span class="k">with</span> <span class="n">v₁&#39;</span> <span class="n">v₂&#39;</span><span class="bp">;</span>
    <span class="n">try</span> <span class="o">{</span> <span class="n">exact</span> <span class="n">graph</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">}</span><span class="bp">;</span>
    <span class="n">try</span> <span class="o">{</span> <span class="n">exact</span> <span class="n">id</span> <span class="o">}</span>
  <span class="kn">end</span><span class="o">,</span>
  <span class="n">irref</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">v</span><span class="o">,</span>
  <span class="k">begin</span>
    <span class="n">cases</span> <span class="n">v</span> <span class="k">with</span> <span class="n">v₁</span> <span class="n">v₂</span><span class="bp">;</span>
    <span class="n">exact</span> <span class="n">graph</span><span class="bp">.</span><span class="n">irref</span> <span class="bp">_</span> <span class="bp">_</span>
  <span class="kn">end</span> <span class="o">}</span>

<span class="kn">namespace</span> <span class="n">Dynkin</span>

<span class="n">def</span> <span class="n">A</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">graph</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">V</span> <span class="o">:=</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">E</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">j</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="n">i</span><span class="bp">.</span><span class="n">val</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">∨</span> <span class="n">i</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="n">j</span><span class="bp">.</span><span class="n">val</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">symm</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
  <span class="n">irref</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span> <span class="n">h</span><span class="o">,</span> <span class="k">by</span> <span class="n">cases</span> <span class="n">h</span><span class="bp">;</span>
    <span class="o">{</span> <span class="n">conv</span> <span class="n">at</span> <span class="n">h</span> <span class="o">{</span> <span class="n">to_lhs</span><span class="o">,</span> <span class="n">rw</span> <span class="err">←</span> <span class="n">nat</span><span class="bp">.</span><span class="n">add_zero</span> <span class="n">i</span><span class="bp">.</span><span class="n">val</span> <span class="o">},</span>
      <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">no_confusion</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">add_left_cancel</span> <span class="n">h</span><span class="o">)</span> <span class="o">}</span> <span class="o">}</span>

<span class="n">def</span> <span class="n">D</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">graph</span>
<span class="bp">|</span> <span class="mi">0</span>     <span class="o">:=</span> <span class="n">A</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">A</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">glue</span> <span class="n">graph</span><span class="bp">.</span><span class="n">unit</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="bp">_</span><span class="o">,</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">i</span><span class="bp">.</span><span class="n">val</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span>

<span class="n">def</span> <span class="n">E6</span> <span class="o">:</span> <span class="n">graph</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">A</span> <span class="mi">4</span><span class="o">)</span><span class="bp">.</span><span class="n">glue</span> <span class="o">(</span><span class="n">A</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">i</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">∧</span> <span class="n">j</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>

<span class="n">def</span> <span class="n">E7</span> <span class="o">:</span> <span class="n">graph</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">A</span> <span class="mi">4</span><span class="o">)</span><span class="bp">.</span><span class="n">glue</span> <span class="o">(</span><span class="n">A</span> <span class="mi">3</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">i</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">∧</span> <span class="n">j</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>

<span class="n">def</span> <span class="n">E8</span> <span class="o">:</span> <span class="n">graph</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">A</span> <span class="mi">4</span><span class="o">)</span><span class="bp">.</span><span class="n">glue</span> <span class="o">(</span><span class="n">A</span> <span class="mi">4</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">i</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">∧</span> <span class="n">j</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>

<span class="kn">end</span> <span class="n">Dynkin</span>
</pre></div>

<a name="157618530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157618530" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157618530">Andrew Ashworth (Feb 05 2019 at 16:22)</a>:</h4>
<p>is the coq graph library no good? (sorry, didn't read all of the thread yet: <a href="https://github.com/coq-contribs/graph-basics" target="_blank" title="https://github.com/coq-contribs/graph-basics">https://github.com/coq-contribs/graph-basics</a>)</p>

<a name="157618844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157618844" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157618844">Johan Commelin (Feb 05 2019 at 16:27)</a>:</h4>
<p>Probably it is. But it needs to be ported <span aria-label="grinning face with smiling eyes" class="emoji emoji-1f601" role="img" title="grinning face with smiling eyes">:grinning_face_with_smiling_eyes:</span></p>

<a name="157622568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157622568" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157622568">Bryan Gin-ge Chen (Feb 05 2019 at 17:21)</a>:</h4>
<p>That Coq library is LGPL licensed, which could complicate the incorporation of any port of it into mathlib. (not a lawyer and all that of course...)</p>

<a name="157623720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157623720" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157623720">Johan Commelin (Feb 05 2019 at 17:36)</a>:</h4>
<p>which is why I am a very big fan of <a href="https://unlicense.org/" target="_blank" title="https://unlicense.org/">https://unlicense.org/</a></p>

<a name="157633904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157633904" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157633904">Jesse Michael Han (Feb 05 2019 at 19:36)</a>:</h4>
<p>Floris has started on <a href="https://github.com/formalabstracts/formalabstracts/commit/d6585457c6ca68c3ee359c3b45dac26c5a81d212" target="_blank" title="https://github.com/formalabstracts/formalabstracts/commit/d6585457c6ca68c3ee359c3b45dac26c5a81d212">Dynkin diagrams</a> for the formal abstract of the classification of finite simple groups. Many of the sporadics can be defined as a quotient of a generalized Coxeter-type presentation, for which we have <a href="https://github.com/formalabstracts/formalabstracts/blob/b8f31dfe7c1ecc3b87347241b7c7c81ba84cc2d2/src/group_theory/presentation.lean#L103" target="_blank" title="https://github.com/formalabstracts/formalabstracts/blob/b8f31dfe7c1ecc3b87347241b7c7c81ba84cc2d2/src/group_theory/presentation.lean#L103">Coxeter Y-diagrams</a>.</p>

<a name="157635199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157635199" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157635199">Johan Commelin (Feb 05 2019 at 19:53)</a>:</h4>
<p>Aah, that's good to know. Thanks for the heads up!</p>

<a name="157637155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157637155" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157637155">Floris van Doorn (Feb 05 2019 at 20:18)</a>:</h4>
<p>Thanks, Jesse, for pointing to my file. It is very much WIP. My (current) definition of Dynkin diagram (with directed multiple edges and undirected single edges) is</p>
<div class="codehilite"><pre><span></span>structure dynkin_diagram :=
  (vertex : Type v)
  (edge : vertex → vertex → Prop)
  (annotation : Π{{x y}}, edge x y → ℕ+)
  (directed : Π{{x y}} (e : edge x y), annotation e = 1 ↔ edge y x)
</pre></div>


<p>If you want to talk about undirected graphs, I think you should index them by unordered pairs of distinct elements:</p>
<div class="codehilite"><pre><span></span>/-- unordered pairs of distinct elements -/
def upair (α : Type u) : Type u := {s : finset α // s.card = 2}
</pre></div>


<p>This would require some scaffolding to set up a library for these creatures, but after that I think it would be more convenient to work with these "undirected graphs" as opposed to "symmetric directed graphs". I was also considering this approach for Dynkin diagrams, but since <em>some</em> edges in Dynkin diagrams are directed, I decided to use a (mostly symmetric) directed graph.</p>

<a name="157637571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157637571" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157637571">Floris van Doorn (Feb 05 2019 at 20:24)</a>:</h4>
<p>When thinking a bit about this <code>upair</code> object, I was wondering the following. <code>upair</code> is a subtype (of a subtype) of a quotient. Is it formalized in Lean that a subtype of a quotient is equivalent to a quotient of a subtype? That would probably be useful when reasoning about <code>upair</code>: they would correspond to (lists of length 2 with no duplicates) quotiented by permutation.</p>


{% endraw %}
