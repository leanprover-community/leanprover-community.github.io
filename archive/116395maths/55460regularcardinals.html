---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/116395maths/55460regularcardinals.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html">regular cardinals</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="133571077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133571077" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133571077">Reid Barton (Sep 08 2018 at 15:06)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> I want to show that if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span> is a regular cardinal, then the sum of fewer than <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span> cardinals smaller than <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span> is less than <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>. Is there an easy way to do this from what's already there about regular cardinals?</p>

<a name="133585985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133585985" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133585985">Mario Carneiro (Sep 08 2018 at 23:25)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> added</p>

<a name="133586025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133586025" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133586025">Kevin Buzzard (Sep 08 2018 at 23:26)</a>:</h4>
<blockquote>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> I want to show that if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span> is a regular cardinal, then the sum of fewer than <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span> cardinals smaller than <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span> is less than <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>. Is there an easy way to do this from what's already there about regular cardinals?</p>
</blockquote>
<p>yeah, you can ask Mario to do it</p>

<a name="133586031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133586031" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133586031">Kenny Lau (Sep 08 2018 at 23:27)</a>:</h4>
<p>Do strong inaccessible cardinals exist in Lean?</p>

<a name="133586033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133586033" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133586033">Mario Carneiro (Sep 08 2018 at 23:27)</a>:</h4>
<p>The answer was basically "yes, once you prove a few more basic facts"</p>

<a name="133586035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133586035" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133586035">Kevin Buzzard (Sep 08 2018 at 23:27)</a>:</h4>
<p>That's not even right because that's not what you did -- you can mention it when Mario is within earshot is what I meant to say</p>

<a name="133586087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133586087" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133586087">Kevin Buzzard (Sep 08 2018 at 23:28)</a>:</h4>
<p>How close is <code>Type 1</code> from being one of these large cardinals?</p>

<a name="133586090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133586090" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133586090">Kevin Buzzard (Sep 08 2018 at 23:28)</a>:</h4>
<p>If alpha is a type, is homs from alpha to bool still the same type? No, we went up a level in the universe hierarchy, right?</p>

<a name="133586096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133586096" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133586096">Kenny Lau (Sep 08 2018 at 23:29)</a>:</h4>
<p>It's still the same type. Grothendieck universe is closed under power set</p>

<a name="133586099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133586099" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133586099">Mario Carneiro (Sep 08 2018 at 23:29)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> yes, <code>is_inacessible</code> means strongly inaccessible</p>

<a name="133586163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133586163" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133586163">Mario Carneiro (Sep 08 2018 at 23:30)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> Yes, <code>univ_inaccessible</code> asserts that a universe cardinal is inaccessible</p>

<a name="133586167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133586167" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133586167">Kenny Lau (Sep 08 2018 at 23:30)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="c">/-</span><span class="cm"> Lean&#39;s foundations prove the existence of ω many inaccessible</span>
<span class="cm">   cardinals -/</span>
<span class="kn">theorem</span> <span class="n">univ_inaccessible</span> <span class="o">:</span> <span class="n">is_inaccessible</span> <span class="o">(</span><span class="n">univ</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span> <span class="n">v</span><span class="o">})</span> <span class="o">:=</span>
<span class="n">is_inaccessible</span><span class="bp">.</span><span class="n">mk</span>
  <span class="o">(</span><span class="k">by</span> <span class="n">simpa</span> <span class="kn">using</span> <span class="n">lift_lt_univ&#39;</span> <span class="n">omega</span><span class="o">)</span>
  <span class="o">(</span><span class="k">by</span> <span class="n">simp</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">c</span> <span class="n">h</span><span class="o">,</span> <span class="k">begin</span>
    <span class="n">rcases</span> <span class="n">lt_univ&#39;</span><span class="bp">.</span><span class="mi">1</span> <span class="n">h</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">rw</span> <span class="err">←</span> <span class="n">lift_two_power</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span> <span class="o">(</span><span class="n">max</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">v</span><span class="o">)},</span>
    <span class="n">apply</span> <span class="n">lift_lt_univ&#39;</span>
  <span class="kn">end</span><span class="o">)</span>
</pre></div>

<a name="133586169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133586169" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133586169">Kenny Lau (Sep 08 2018 at 23:30)</a>:</h4>
<p>cool!</p>

<a name="133586235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133586235" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133586235">Kevin Buzzard (Sep 08 2018 at 23:32)</a>:</h4>
<p>I never remember the difference between all these large cardinal axioms and I've never thought about how they interact with type theory either. I'm not sure that "normal mathematicians" care about them (in set theory or in type theory).</p>

<a name="133586239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133586239" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133586239">Kevin Buzzard (Sep 08 2018 at 23:32)</a>:</h4>
<p>(by which I mean geometers topologists analysts number theorists algebraists etc)</p>

<a name="133602032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133602032" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133602032">Reid Barton (Sep 09 2018 at 09:33)</a>:</h4>
<p>Thanks Mario! I see you also added a bunch of other statements that I was looking for while trying to figure out how to prove this.<br>
I'm really grateful that so much cardinal arithmetic is already in mathlib--if I hadn't seen that we already had regular cardinals I probably wouldn't have started down this road towards locally presentable categories.</p>

<a name="133602168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133602168" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133602168">Reid Barton (Sep 09 2018 at 09:37)</a>:</h4>
<p>Kevin I've only ever needed regular and inaccessible cardinals. Regular cardinals are just what I wrote above, the union of a small family of small sets is again small, where "small" means cardinality <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo><mi>κ</mi></mrow><annotation encoding="application/x-tex">&lt; \kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base"><span class="mrel">&lt;</span><span class="mord mathit">κ</span></span></span></span>. It's useful for controlling a construction by transfinite induction up to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>. If we replace <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo><mi>κ</mi></mrow><annotation encoding="application/x-tex">&lt; \kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base"><span class="mrel">&lt;</span><span class="mord mathit">κ</span></span></span></span> with <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≤</mo><mi>κ</mi></mrow><annotation encoding="application/x-tex">\le \kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.63597em;"></span><span class="strut bottom" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="base"><span class="mrel">≤</span><span class="mord mathit">κ</span></span></span></span> then this condition would automatically be satisfied, so every successor cardinal is regular. So regularity is not really a "largeness" condition but rather a way to rule out certain cardinals we don't like, the first example being <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">ℵ</mi><mi>ω</mi></msub><mo>=</mo><msub><mi mathvariant="normal">ℵ</mi><mn>0</mn></msub><mo>+</mo><msub><mi mathvariant="normal">ℵ</mi><mn>1</mn></msub><mo>+</mo><msub><mi mathvariant="normal">ℵ</mi><mn>2</mn></msub><mo>+</mo><mo>⋯</mo></mrow><annotation encoding="application/x-tex">\aleph_\omega = \aleph_0 + \aleph_1 + \aleph_2 + \cdots</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathrm">ℵ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.03588em;">ω</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mrel">=</span><span class="mord"><span class="mord mathrm">ℵ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathrm">ℵ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathrm">ℵ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mbin">+</span><span class="minner">⋯</span></span></span></span>.</p>
<p>Inaccessible cardinals also have the same property with "product" in place of "union", and they are the cardinalities of Grothendieck universes, so you could say they bound the cardinality of <em>any</em> construction.</p>

<a name="133604572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133604572" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133604572">Reid Barton (Sep 09 2018 at 11:00)</a>:</h4>
<p>By the way, is it intentional that <code>cardinal.mk</code> is not <code>protected</code>? I don't really mind at the moment, but it is a little odd to see just <code>mk</code> in my goals. If there's going to be a non-<code>protected</code> name for taking the cardinality of a type, maybe something like <code>card</code> would be better.<br>
(I think this came up earlier, when people were looking for functions named <code>mk</code> which were not <code>protected</code>, for some reason.)</p>

<a name="133604671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133604671" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133604671">Kevin Buzzard (Sep 09 2018 at 11:03)</a>:</h4>
<p>I think I once grepped through all of mathlib looking for unprotected <code>mk</code>s and that was the only one, and at the time people said it was an error but I didn't know enough about how PR's etc worked to be able to fix it.</p>

<a name="133605106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133605106" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133605106">Kevin Buzzard (Sep 09 2018 at 11:16)</a>:</h4>
<p>That's not true, it was another function not <code>mk</code>. I can't find the thread now though; might have been on gitter.</p>

<a name="133609354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133609354" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133609354">Kevin Buzzard (Sep 09 2018 at 13:31)</a>:</h4>
<p>Why do you need it? I used to think this stuff was really cool when I was a graduate student but then I realised that it never seems to actually be any use in my area</p>

<a name="133609462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133609462" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133609462">Kevin Buzzard (Sep 09 2018 at 13:34)</a>:</h4>
<p>[phone posting stuff three times]</p>

<a name="133609699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133609699" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133609699">Reid Barton (Sep 09 2018 at 13:43)</a>:</h4>
<p>One place you need the notion of regular cardinal is in the small object argument, which is a generalization of the kind of argument where you approximate a space <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07847em;">X</span></span></span></span> by building up a cell complex where at each stage, you attach a cell <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∂</mi><msup><mi>D</mi><mi>n</mi></msup><mo>→</mo><msup><mi>D</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\partial D^n \to D^n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord mathrm" style="margin-right:0.05556em;">∂</span><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">n</span></span></span></span></span></span></span></span><span class="mrel">→</span><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">n</span></span></span></span></span></span></span></span></span></span></span> for every way to map <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∂</mi><msup><mi>D</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\partial D^n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord mathrm" style="margin-right:0.05556em;">∂</span><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">n</span></span></span></span></span></span></span></span></span></span></span> to your complex so far and every way to extend it to a map <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>D</mi><mi>n</mi></msup><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">D^n \to X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">n</span></span></span></span></span></span></span></span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.07847em;">X</span></span></span></span>. More generally, we could do this for any <em>set</em> of "cell" maps in any (let's say cocomplete) category. We're going to repeat this <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span> times and in the end, we're going to want to know that any map from the domain of one of our cell maps to the end result factors through the thing we produced at stage <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.0037em;">α</span></span></span></span> for some <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi><mo>&lt;</mo><mi>κ</mi></mrow><annotation encoding="application/x-tex">\alpha &lt; \kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.0037em;">α</span><span class="mrel">&lt;</span><span class="mord mathit">κ</span></span></span></span>.</p>

<a name="133609755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133609755" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133609755">Reid Barton (Sep 09 2018 at 13:44)</a>:</h4>
<p>To conclude this, we need two things.</p>
<ul>
<li>The domains of the cell maps are <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>-presentable, so homs out of them commute with <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>-filtered colimits. This is a kind of smallness condition. For example, if a set <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span></span> has cardinality less than <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>, then a map from <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span></span> into a <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>-filtered colimit factors through some object in the colimit.</li>
<li>The ordered set of ordinals less than <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span> is <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>-filtered -- this is saying that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span> is a regular cardinal.</li>
</ul>

<a name="133609778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133609778" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133609778">Reid Barton (Sep 09 2018 at 13:45)</a>:</h4>
<p>Why do we need actual regular cardinals bigger than <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ω</mi></mrow><annotation encoding="application/x-tex">\omega</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.03588em;">ω</span></span></span></span>? Probably hard to give an example off-hand.</p>

<a name="133609948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133609948" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133609948">Kevin Buzzard (Sep 09 2018 at 13:49)</a>:</h4>
<p>I see. Thanks. So I guess even using transfinite induction is somehow beyond what I ever seen in practice in my area. Do you only need transfinite induction because you're trying to work with random categories?</p>

<a name="133610023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133610023" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133610023">Reid Barton (Sep 09 2018 at 13:50)</a>:</h4>
<p>No, there are actual "applied" settings like constructing localizations with respect to homology theories, where it's not easy to bound the cardinals that show up, or at least the ones which appear are bigger than <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ω</mi></mrow><annotation encoding="application/x-tex">\omega</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.03588em;">ω</span></span></span></span>.</p>

<a name="133610042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133610042" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133610042">Kevin Buzzard (Sep 09 2018 at 13:51)</a>:</h4>
<p>Wow, that is what topology has become?</p>

<a name="133610097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133610097" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133610097">Reid Barton (Sep 09 2018 at 13:52)</a>:</h4>
<p>Homotopy theorists study spaces one prime at a time, didn't you know? :)</p>

<a name="133610099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133610099" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133610099">Kevin Buzzard (Sep 09 2018 at 13:52)</a>:</h4>
<p>So are there actual set-theoretic problems if you try to set this stuff up in ZFC? (in the sense that you can't actually do it?)</p>

<a name="133610102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133610102" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133610102">Reid Barton (Sep 09 2018 at 13:52)</a>:</h4>
<p>No, because there's lots of regular cardinals.</p>

<a name="133610113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133610113" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133610113">Kevin Buzzard (Sep 09 2018 at 13:52)</a>:</h4>
<p>Oh so you only need regular, not some crazy inaccessibles.</p>

<a name="133610128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133610128" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133610128">Reid Barton (Sep 09 2018 at 13:53)</a>:</h4>
<p>Yes. You could probably get by without explicitly using the notion and just taking successor cardinals in various places, but it's nicer to keep track of what you actually need.</p>

<a name="133610310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133610310" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133610310">Reid Barton (Sep 09 2018 at 13:57)</a>:</h4>
<p>That said, it is of course nice to set up the theory to work with "random" categories, or at least ones which are controlled in some sense by an arbitrary regular cardinal <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span> (these are the locally presentable categories), and so you end up with this regular cardinal assumption baked in from the start. I'm expecting to find out exactly where it is and isn't used :)</p>

<a name="133612459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133612459" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133612459">Reid Barton (Sep 09 2018 at 14:43)</a>:</h4>
<p>In fact it would do no real damage to the theory to just replace "regular cardinal" by "successor cardinal" everywhere, particularly in view of the fact that any limit cardinal that you can "write down" (like <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">ℵ</mi><mi>ω</mi></msub></mrow><annotation encoding="application/x-tex">\aleph_\omega</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathrm">ℵ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.03588em;">ω</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span>) cannot be regular. The point is just that "regular cardinal" (sum of fewer than <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span> cardinals below <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span> is smaller than <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>) is the actual property you need to make the theory work.</p>

<a name="133621586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133621586" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133621586">Mario Carneiro (Sep 09 2018 at 19:17)</a>:</h4>
<p>I'm worried that this is not the usual way we handle "size issues" in lean. Do you have an example where replacing kappa-somethings with somethings everywhere causes problems?</p>

<a name="133623381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133623381" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133623381">Reid Barton (Sep 09 2018 at 20:20)</a>:</h4>
<p>So one of the themes in this area is that we have certain constructions in which we'd like to form large (co)limits and/or do transfinite induction over all ordinals. We cannot do these constructions in ZFC and so we prove somewhat complicated theorems to show that we can replace the needed (co)limits/transfinite inductions by small ones. But, even if we assume the existence of universes so that we could perform the construction in a higher universe, we would still want to know that the resulting object belongs to the original universe when it does.</p>

<a name="133623392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133623392" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133623392">Mario Carneiro (Sep 09 2018 at 20:21)</a>:</h4>
<p>Right, in type theory the "size issue" manifests as making sure your construction is still in <code>Type u</code> given that your inputs are in <code>Type u</code></p>

<a name="133623396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133623396" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133623396">Mario Carneiro (Sep 09 2018 at 20:21)</a>:</h4>
<p>But we don't do transfinite induction very often in type theory; the substitute is the use of a complicated inductive type</p>

<a name="133623440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133623440" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133623440">Mario Carneiro (Sep 09 2018 at 20:22)</a>:</h4>
<p>which is why I think having a regular cardinal may not be as useful as you think</p>

<a name="133623441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133623441" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133623441">Reid Barton (Sep 09 2018 at 20:22)</a>:</h4>
<p>Maybe the simplest example would be something like this. If you have a poset with least upper bounds for any subset, then it has a maximum element which you can obtain by taking the least upper bound of everything. But in category theory, we cannot obtain a terminal object in Set by taking the colimit of the identity diagram Set -&gt; Set. I mean it is the colimit, but we do not know a priori that it exists because we only know that we can form colimits of small diagrams and Set itself is a large category.</p>

<a name="133623496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133623496" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133623496">Mario Carneiro (Sep 09 2018 at 20:24)</a>:</h4>
<p>Right, we can only take a colimit of a type in Type u</p>

<a name="133623510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133623510" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133623510">Mario Carneiro (Sep 09 2018 at 20:25)</a>:</h4>
<p>but where do regular cardinals enter the picture?</p>

<a name="133623626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133623626" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133623626">Reid Barton (Sep 09 2018 at 20:29)</a>:</h4>
<p>So, (obviously this is way overkill for this particular problem but) you can pick a regular cardinal <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>, define what it means for a set to be "<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>-compact" (in this case just that its cardinality is less than <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>), show there is only a set of isomorphism classes of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>-compact sets (in this case, all the cardinalities less than <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>), and pick one member from each class and form the full subcategory on those and form the colimit of that <em>small</em> diagram. Then you do more work to show that the colimit  is a terminal object not just as seen by <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>-compact sets, but as seen by every set.</p>

<a name="133623701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133623701" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133623701">Reid Barton (Sep 09 2018 at 20:31)</a>:</h4>
<p>This also works in the category of models of any algebraic theory--here <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span> has to be chosen larger than the arity of any operation in the theory</p>

<a name="133623817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133623817" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133623817">Reid Barton (Sep 09 2018 at 20:34)</a>:</h4>
<p>I agree that the kinds of constructions that you can do in Set by this method overlap with what you can do directly with inductive types in type theory. In this language the fact that you can form the initial fixed point of a strictly positive functor comes down to the fact that it preserves <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>-filtered colimits for some <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span> (which has to be bigger than the cardinalities of any types which appear as "exponents" in the functor)</p>

<a name="133623828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133623828" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133623828">Reid Barton (Sep 09 2018 at 20:34)</a>:</h4>
<p>Then you can form the fixed point by transfinite composition up to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span> and the fact that the functor commutes with the <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>-filtered colimit you just wrote down is what tells you that you got a fixed point.</p>

<a name="133623843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133623843" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133623843">Reid Barton (Sep 09 2018 at 20:35)</a>:</h4>
<p>I don't see how this helps me if I want to do some arbitrary transfinite composition construction in the category of simplicial rings or whatever, though.</p>

<a name="133623894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133623894" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133623894">Reid Barton (Sep 09 2018 at 20:37)</a>:</h4>
<p>I actually am very curious when I do get to transfinite composition constructions what you have to say about representing them in Lean, because it seems like the kind of thing that Lean would be good at in some non-obvious (to me) way.</p>

<a name="133624002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133624002" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133624002">Mario Carneiro (Sep 09 2018 at 20:40)</a>:</h4>
<blockquote>
<p>So, (obviously this is way overkill for this particular problem but) you can pick a regular cardinal <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>, define what it means for a set to be "<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>-compact" (in this case just that its cardinality is less than <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>), show there is only a set of isomorphism classes of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>-compact sets (in this case, all the cardinalities less than <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>), and pick one member from each class and form the full subcategory on those and form the colimit of that <em>small</em> diagram. Then you do more work to show that the colimit  is a terminal object not just as seen by <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>-compact sets, but as seen by every set.</p>
</blockquote>
<p>Okay, so here is how I think you would do this in types: We know that we can take a colimit over any set (aka thing in <code>Type u</code>), or possibly any set satisfying some condition that is easy to satisfy. This substitutes for all the work up to the last sentence. Then we obtain an approximate colimit of Set, and we now need to show that there is some choice of type that makes the approximation a true colimit. This will require some particular "size argument" specific to the problem, but often involves constructing an inductive type larger than everything in sight</p>

<a name="133624003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133624003" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133624003">Reid Barton (Sep 09 2018 at 20:40)</a>:</h4>
<p>A less trivial (but basically still the same) theorem is the adjoint functor theorem for locally presentable categories: any functor between locally presentable categories which preserves colimits has a right adjoint</p>

<a name="133624060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133624060" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133624060">Reid Barton (Sep 09 2018 at 20:42)</a>:</h4>
<p>Right so the size argument is specific to the problem, but it's not specific to the choice of locally presentable category (in this case I picked Set, but it could have been Ring or whatever).</p>

<a name="133624063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133624063" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133624063">Mario Carneiro (Sep 09 2018 at 20:42)</a>:</h4>
<p>what is a locally presentable category?</p>

<a name="133624066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133624066" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133624066">Reid Barton (Sep 09 2018 at 20:42)</a>:</h4>
<p>And to make that size argument in general, you need to talk about cardinals</p>

<a name="133624068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133624068" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133624068">Mario Carneiro (Sep 09 2018 at 20:42)</a>:</h4>
<p>You can talk about types instead</p>

<a name="133624074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133624074" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133624074">Mario Carneiro (Sep 09 2018 at 20:43)</a>:</h4>
<p>of course types are cardinals of themselves</p>

<a name="133624075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133624075" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133624075">Mario Carneiro (Sep 09 2018 at 20:43)</a>:</h4>
<p>so you can use type variables as proxies for cardinal numbers</p>

<a name="133624076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133624076" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133624076">Reid Barton (Sep 09 2018 at 20:43)</a>:</h4>
<p>There are a bunch of equivalent formulations, but we can say that it's the category of models of an essentially algebraic theory (which means the operations might have equality preconditions, like the composition in a category).</p>

<a name="133624128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133624128" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133624128">Reid Barton (Sep 09 2018 at 20:44)</a>:</h4>
<p>There's no restriction on the number or arity of the operations, except that everything involved must be a set</p>

<a name="133624184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133624184" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133624184">Mario Carneiro (Sep 09 2018 at 20:46)</a>:</h4>
<p>that seems messy to work with</p>

<a name="133624199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133624199" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133624199">Reid Barton (Sep 09 2018 at 20:47)</a>:</h4>
<p>Another one is: a category which is cocomplete and for some <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>, it has a set of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>-compact objects which generate the whole category under <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>-filtered colimits</p>

<a name="133624248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133624248" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133624248">Mario Carneiro (Sep 09 2018 at 20:49)</a>:</h4>
<p>I'm reading that on nlab now, and now I need to figure out what <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>-compact and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>-filtered colimit mean</p>

<a name="133624253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133624253" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133624253">Reid Barton (Sep 09 2018 at 20:49)</a>:</h4>
<p>I can give you three equivalent definitions in Lean :)</p>

<a name="133624255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133624255" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133624255">Reid Barton (Sep 09 2018 at 20:49)</a>:</h4>
<p>For <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>-filtered categories, that is</p>

<a name="133624316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133624316" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133624316">Reid Barton (Sep 09 2018 at 20:51)</a>:</h4>
<p>I guess it's kind of hard to explain how <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>-filtered colimits arise except that they give a good theory of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>-compact objects.<br>
If you want, you can substitute <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>-directed which is a bit simpler technically.</p>

<a name="133624368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133624368" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133624368">Mario Carneiro (Sep 09 2018 at 20:52)</a>:</h4>
<p>Maybe you can tell me what goes wrong if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span> is not a regular cardinal?</p>

<a name="133624383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133624383" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133624383">Reid Barton (Sep 09 2018 at 20:53)</a>:</h4>
<p>Well it's no longer true that a <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>-small colimit of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>-compact objects is <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>-compact (because in Set, this is basically the fact I asked you for).</p>

<a name="133624433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133624433" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133624433">Mario Carneiro (Sep 09 2018 at 20:54)</a>:</h4>
<p>Is there an inductive closure condition that would ensure this works?</p>

<a name="133624435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133624435" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133624435">Reid Barton (Sep 09 2018 at 20:54)</a>:</h4>
<p>You might want to take a quick look at <a href="https://ncatlab.org/nlab/show/arity+class" target="_blank" title="https://ncatlab.org/nlab/show/arity+class">https://ncatlab.org/nlab/show/arity+class</a></p>

<a name="133624446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133624446" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133624446">Reid Barton (Sep 09 2018 at 20:55)</a>:</h4>
<p>Actually, maybe I misunderstood but that page may be somehow relevant.</p>

<a name="133624450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133624450" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133624450">Reid Barton (Sep 09 2018 at 20:55)</a>:</h4>
<p>I think you want to build up the class of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>-compact objects in some inductive fashion?</p>

<a name="133624493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133624493" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133624493">Reid Barton (Sep 09 2018 at 20:56)</a>:</h4>
<p>Or, there is another description again of locally presentable categories.</p>

<a name="133624494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133624494" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133624494">Mario Carneiro (Sep 09 2018 at 20:56)</a>:</h4>
<p>You start from some initial objects, and want to close it to a suitably large cardinal</p>

<a name="133624498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133624498" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133624498">Reid Barton (Sep 09 2018 at 20:56)</a>:</h4>
<p>Start with <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span> and a <em>small</em> category which admits <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>-small colimits.</p>

<a name="133624506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133624506" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133624506">Reid Barton (Sep 09 2018 at 20:57)</a>:</h4>
<p>Then, you can "freely adjoin" all <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>-filtered colimits and this gives you a general locally <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>-presentable category.</p>

<a name="133624514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133624514" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133624514">Mario Carneiro (Sep 09 2018 at 20:57)</a>:</h4>
<p>Although I don't think "regular cardinal" is an inductive condition</p>

<a name="133624579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133624579" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133624579">Reid Barton (Sep 09 2018 at 20:59)</a>:</h4>
<p>Actually in some of these cases, you can say exactly what goes wrong if you don't assume <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span> is regular.<br>
Typically you get the same notion as if you had replaced <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span> by its cofinality.</p>

<a name="133624585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133624585" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133624585">Reid Barton (Sep 09 2018 at 20:59)</a>:</h4>
<p>So, a regular cardinal <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span> is really "standing in" for the class of all cardinals of cofinality <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>, from this point of view</p>

<a name="133624656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133624656" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133624656">Reid Barton (Sep 09 2018 at 21:01)</a>:</h4>
<p>But it's better to work only with regular ones, because for example a locally <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>-presentable category is also locally <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">λ</span></span></span></span>-presentable for <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi><mo>≤</mo><mi>λ</mi></mrow><annotation encoding="application/x-tex">\kappa \le \lambda</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="base"><span class="mord mathit">κ</span><span class="mrel">≤</span><span class="mord mathit">λ</span></span></span></span>, but if you were to ignore the condition that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">λ</span></span></span></span> be regular, then it might no longer be true (because the cofinality of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">λ</span></span></span></span> could be less than <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>).</p>

<a name="133624792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133624792" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133624792">Reid Barton (Sep 09 2018 at 21:06)</a>:</h4>
<p>In the end, the point is really that it's a large class of categories in which you can do a large class of constructions in a uniform way (once you know this parameter <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>).</p>

<a name="133624889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133624889" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133624889">Reid Barton (Sep 09 2018 at 21:08)</a>:</h4>
<p>And a lot of the constructions involve this somewhat involved reasoning about cardinalities, so it's worth it to not have to do them more than once</p>

<a name="133624895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133624895" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133624895">Reid Barton (Sep 09 2018 at 21:08)</a>:</h4>
<p>For example, the construction of free objects</p>

<a name="133624968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133624968" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133624968">Reid Barton (Sep 09 2018 at 21:11)</a>:</h4>
<p>I guess one other point is that to build a free object as an inductive type, you need Lean to be able to see syntactically that the functor involved is strictly positive.</p>

<a name="133625020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133625020" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133625020">Reid Barton (Sep 09 2018 at 21:12)</a>:</h4>
<p>But to do the same construction even in Set using this regular cardinal kind of machinery, you only have to prove a theorem about how it commutes with sufficiently highly filtered colimits</p>

<a name="133625027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133625027" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133625027">Mario Carneiro (Sep 09 2018 at 21:12)</a>:</h4>
<p>I think there is usually a way to make this work by writing the functor differently</p>

<a name="133625042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133625042" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133625042">Mario Carneiro (Sep 09 2018 at 21:13)</a>:</h4>
<p>I have no sense of how easy "you only have to prove a theorem about how it commutes with sufficiently highly filtered colimits" is</p>

<a name="133625101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133625101" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133625101">Reid Barton (Sep 09 2018 at 21:15)</a>:</h4>
<p>Sure, but proving a theorem is more flexible than having to produce something that satisfies a judgment. And you can abstract over an accessible functor, but you can't abstract over a strictly positive type constructor.</p>

<a name="133625150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133625150" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133625150">Mario Carneiro (Sep 09 2018 at 21:16)</a>:</h4>
<p>But you can usually write something that is obviously positive but not obviously the same as your functor</p>

<a name="133625162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133625162" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133625162">Mario Carneiro (Sep 09 2018 at 21:16)</a>:</h4>
<p>and then the theorem is shifted to proving this equality</p>

<a name="133625231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133625231" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133625231">Reid Barton (Sep 09 2018 at 21:18)</a>:</h4>
<p>Well it depends on what the functor is of course :)<br>
For FX = X^S, proving that F commutes with <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>-filtered colimits -- or we can take <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>-directed colimits for simplicity -- is checking that if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07847em;">I</span></span></span></span> is a <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>-directed poset and for each <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>∈</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">s \in S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="base"><span class="mord mathit">s</span><span class="mrel">∈</span><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span></span>, we have an element in some <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mrow><mi>i</mi><mo>(</mo><mi>s</mi><mo>)</mo></mrow></msub></mrow><annotation encoding="application/x-tex">A_{i(s)}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="base"><span class="mord"><span class="mord mathit">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">i</span><span class="mopen mtight">(</span><span class="mord mathit mtight">s</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"></span></span></span></span></span></span></span></span>, then we can map them all into some common <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><msup><mi>i</mi><mo mathvariant="normal">′</mo></msup></msub></mrow><annotation encoding="application/x-tex">A_{i'}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32797999999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathit mtight">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828285714285715em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathrm mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> -- and this is the definition of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span>-directed for <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi><mo>&gt;</mo><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">\kappa &gt; |S|</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">κ</span><span class="mrel">&gt;</span><span class="mord mathrm">∣</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathrm">∣</span></span></span></span>.</p>

<a name="133625237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133625237" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133625237">Reid Barton (Sep 09 2018 at 21:18)</a>:</h4>
<p>What if my functor is something like FX = the set of unordered pairs of elements of X?</p>

<a name="133625257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133625257" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133625257">Reid Barton (Sep 09 2018 at 21:19)</a>:</h4>
<p>Anyways I think the ability to abstract over "an accessible functor" is the more interesting thing</p>

<a name="133625488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133625488" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133625488">Reid Barton (Sep 09 2018 at 21:25)</a>:</h4>
<p>Just to give you a taste, in the theory of model categories all this machinery is used heavily. One of the most important ways to construct model categories is <a href="https://ncatlab.org/nlab/show/combinatorial+model+category#SmithTheorem" target="_blank" title="https://ncatlab.org/nlab/show/combinatorial+model+category#SmithTheorem">https://ncatlab.org/nlab/show/combinatorial+model+category#SmithTheorem</a> and if you just look at the hypotheses it should give you some sense of how this stuff gets used. It's actually quite difficult to construct any interesting examples of model categories, so this is a major result.</p>

<a name="133625739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/regular%20cardinals/near/133625739" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/55460regularcardinals.html#133625739">Reid Barton (Sep 09 2018 at 21:34)</a>:</h4>
<p>(My secret plan is to formalize the proof of this theorem.)</p>


{% endraw %}

{% include archive_update.html %}