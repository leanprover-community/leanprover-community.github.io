---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/116395maths/25416inducedneighborhoods.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html">induced neighborhoods</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="169041614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169041614" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169041614">Patrick Massot (Jun 26 2019 at 15:29)</a>:</h4>
<p>What should we do with the duplication <a href="https://github.com/leanprover-community/mathlib/blob/master/src/topology/order.lean#L557-L558" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/src/topology/order.lean#L557-L558">https://github.com/leanprover-community/mathlib/blob/master/src/topology/order.lean#L557-L558</a> vs <a href="https://github.com/leanprover-community/mathlib/blob/master/src/topology/order.lean#L862" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/src/topology/order.lean#L862">https://github.com/leanprover-community/mathlib/blob/master/src/topology/order.lean#L862</a>?</p>

<a name="169043080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169043080" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169043080">Patrick Massot (Jun 26 2019 at 15:45)</a>:</h4>
<p>And where is the corresponding lemma for the coinduced topology?</p>

<a name="169043416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169043416" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169043416">Patrick Massot (Jun 26 2019 at 15:49)</a>:</h4>
<p>maybe it's wrong actually</p>

<a name="169043423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169043423" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169043423">Patrick Massot (Jun 26 2019 at 15:49)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span>?</p>

<a name="169043776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169043776" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169043776">Reid Barton (Jun 26 2019 at 15:53)</a>:</h4>
<p>I guess just delete the second one and update its uses to use the first one</p>

<a name="169043801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169043801" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169043801">Reid Barton (Jun 26 2019 at 15:53)</a>:</h4>
<p>I don't think we need to preserve the name</p>

<a name="169043961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169043961" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169043961">Patrick Massot (Jun 26 2019 at 15:55)</a>:</h4>
<p>What about the coinduced topology?</p>

<a name="169046330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169046330" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169046330">Kevin Buzzard (Jun 26 2019 at 16:21)</a>:</h4>
<p>The function and the element are explicit in one, implicit in the other. Which is "right"?</p>

<a name="169046359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169046359" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169046359">Mario Carneiro (Jun 26 2019 at 16:21)</a>:</h4>
<p>explicit</p>

<a name="169046435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169046435" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169046435">Kevin Buzzard (Jun 26 2019 at 16:22)</a>:</h4>
<p>And what's the algorithm for working this out? Both f and a are determined by the type of the conclusion.</p>

<a name="169046466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169046466" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169046466">Mario Carneiro (Jun 26 2019 at 16:22)</a>:</h4>
<p>you don't use the type of the conclusion in the accounting, just other hypotheses</p>

<a name="169046497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169046497" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169046497">Mario Carneiro (Jun 26 2019 at 16:23)</a>:</h4>
<p>One way to put it: if you write <code>have := my_thm a b c h1 h2</code> with all explicit variables filled in, then there should be no metavariables remaining</p>

<a name="169046550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169046550" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169046550">Kevin Buzzard (Jun 26 2019 at 16:24)</a>:</h4>
<p>Thanks.</p>

<a name="169046595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169046595" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169046595">Mario Carneiro (Jun 26 2019 at 16:24)</a>:</h4>
<p>The rule for iff's is a bit different though; it is sufficient that <code>(my_iff a).1 h</code> and <code>(my_iff a).2 h'</code> have no metavariables</p>

<a name="169046826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169046826" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169046826">Kevin Buzzard (Jun 26 2019 at 16:28)</a>:</h4>
<blockquote>
<p>What about the coinduced topology?</p>
</blockquote>
<p>Is the corresponding lemma still about comaps, or about maps? Or are they the same?</p>

<a name="169046896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169046896" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169046896">Patrick Massot (Jun 26 2019 at 16:28)</a>:</h4>
<p>The tempting statement uses <code>map</code>, but it looks wrong</p>

<a name="169046970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169046970" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169046970">Mario Carneiro (Jun 26 2019 at 16:29)</a>:</h4>
<p>It may be missing because there isn't a nice statement</p>

<a name="169046998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169046998" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169046998">Kevin Buzzard (Jun 26 2019 at 16:29)</a>:</h4>
<p>Can we guess statements and then somehow try them out on all topological spaces with at most three elements?</p>

<a name="169047064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169047064" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169047064">Kevin Buzzard (Jun 26 2019 at 16:30)</a>:</h4>
<p>I ran into that issue yesterday. It would be really cool to be able to formalise a guess and then just try it</p>

<a name="169047096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169047096" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169047096">Patrick Massot (Jun 26 2019 at 16:30)</a>:</h4>
<p>Where is this nuchaku thing again?</p>

<a name="169047118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169047118" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169047118">Kevin Buzzard (Jun 26 2019 at 16:30)</a>:</h4>
<p>In fact Lean should have an option where it occasionally tests your goal with random values for the variables and then prints a little message saying "by the way your goal is false right now" if it finds a counterexample</p>

<a name="169047307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169047307" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169047307">Patrick Massot (Jun 26 2019 at 16:33)</a>:</h4>
<p><a href="https://github.com/nunchaku-inria/nunchaku" target="_blank" title="https://github.com/nunchaku-inria/nunchaku">https://github.com/nunchaku-inria/nunchaku</a></p>

<a name="169047332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169047332" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169047332">Patrick Massot (Jun 26 2019 at 16:33)</a>:</h4>
<p>I don't know how far it is from being usable</p>

<a name="169047430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169047430" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169047430">Mario Carneiro (Jun 26 2019 at 16:34)</a>:</h4>
<p>or how far it is from lean</p>

<a name="169047563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169047563" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169047563">Mario Carneiro (Jun 26 2019 at 16:35)</a>:</h4>
<p><span class="user-mention" data-user-id="121058">@Jasmin Blanchette</span> Help us! Where is leanchaku?</p>

<a name="169047666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169047666" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169047666">Kevin Buzzard (Jun 26 2019 at 16:36)</a>:</h4>
<p>Even something like this <a href="#narrow/stream/113489-new-members/topic/noob.20question%28s%29/near/168891798" title="#narrow/stream/113489-new-members/topic/noob.20question%28s%29/near/168891798">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/noob.20question%28s%29/near/168891798</a> would be cool.</p>

<a name="169047721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169047721" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169047721">Mario Carneiro (Jun 26 2019 at 16:37)</a>:</h4>
<p>That requires your goal be computable though</p>

<a name="169047722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169047722" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169047722">Kevin Buzzard (Jun 26 2019 at 16:37)</a>:</h4>
<p>You just guess</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">nhds_coinduced</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">T</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">@</span><span class="n">nhds</span> <span class="n">β</span> <span class="o">(</span><span class="n">topological_space</span><span class="bp">.</span><span class="n">coinduced</span> <span class="n">f</span> <span class="n">T</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">map</span> <span class="n">f</span> <span class="o">(</span><span class="n">nhds</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
</pre></div>


<p>randomly and fire a bunch of topological spaces at it and see.</p>

<a name="169047740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169047740" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169047740">Mario Carneiro (Jun 26 2019 at 16:37)</a>:</h4>
<p>most top space stuff isn't computable</p>

<a name="169047755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169047755" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169047755">Kevin Buzzard (Jun 26 2019 at 16:37)</a>:</h4>
<p>Even if they only have 3 elements?</p>

<a name="169047817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169047817" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169047817">Mario Carneiro (Jun 26 2019 at 16:38)</a>:</h4>
<p>it's not a computable statement - it's not written in terms of computable functions</p>

<a name="169047830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169047830" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169047830">Mario Carneiro (Jun 26 2019 at 16:38)</a>:</h4>
<p>it's just some thing about sets</p>

<a name="169047843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169047843" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169047843">Kevin Buzzard (Jun 26 2019 at 16:38)</a>:</h4>
<p>can we enumerate all subsets of a decidable finset?</p>

<a name="169047851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169047851" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169047851">Mario Carneiro (Jun 26 2019 at 16:39)</a>:</h4>
<p>Sure it's possible to algorithmically determine the answer on small finite sets but we would need a decision procedure</p>

<a name="169047874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169047874" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169047874">Kevin Buzzard (Jun 26 2019 at 16:39)</a>:</h4>
<p>"just check everything"?</p>

<a name="169047955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169047955" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169047955">Mario Carneiro (Jun 26 2019 at 16:40)</a>:</h4>
<p>And many of the facts aren't even over computable types, e.g. you might have to check whether {1} = {2, 3} as elements of <code>set nat</code></p>

<a name="169047992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169047992" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169047992">Kevin Buzzard (Jun 26 2019 at 16:40)</a>:</h4>
<p>I want to stick to finite decidable types.</p>

<a name="169048041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169048041" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169048041">Mario Carneiro (Jun 26 2019 at 16:41)</a>:</h4>
<p>even then</p>

<a name="169048063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169048063" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169048063">Mario Carneiro (Jun 26 2019 at 16:41)</a>:</h4>
<p>even if it said <code>set (fin 4)</code> there it wouldn't work</p>

<a name="169048083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169048083" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169048083">Mario Carneiro (Jun 26 2019 at 16:41)</a>:</h4>
<p>because you can't have a decidable_eq for set</p>

<a name="169048087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169048087" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169048087">Kevin Buzzard (Jun 26 2019 at 16:41)</a>:</h4>
<p>I saw Kenny do this once. Someone said "is it true that every commutative binary relation is associative" and a couple of minutes later Kenny said "no, here is a random two element set and a random commutative binary relation which is not associative"</p>

<a name="169048155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169048155" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169048155">Kevin Buzzard (Jun 26 2019 at 16:42)</a>:</h4>
<p>which he found by using a tool which searched for counterexamples</p>

<a name="169048196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169048196" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169048196">Mario Carneiro (Jun 26 2019 at 16:42)</a>:</h4>
<p>It's possible to make computable versions of all the functions in the statement, but I don't think you can get that to happen automatically by inferring a decidable instance</p>

<a name="169048213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169048213" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169048213">Kevin Buzzard (Jun 26 2019 at 16:43)</a>:</h4>
<blockquote>
<p>because you can't have a decidable_eq for set</p>
</blockquote>
<p>What if they're decidable sets or something? There must be a way around this.</p>

<a name="169048243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169048243" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169048243">Kevin Buzzard (Jun 26 2019 at 16:43)</a>:</h4>
<p>I just want to let A and B be sets of size 3 and put a random topology on A and choose a random element and test the proposition.</p>

<a name="169048299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169048299" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169048299">Mario Carneiro (Jun 26 2019 at 16:44)</a>:</h4>
<p>I think you can prove <code>decidable (s = t)</code> if <code>decidable_pred s</code> and <code>decidable_pred t</code> and <code>s t : set A</code> where <code>fintype A</code></p>

<a name="169048313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169048313" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169048313">Kevin Buzzard (Jun 26 2019 at 16:44)</a>:</h4>
<p>Is there <code>decidable_pred_set A</code>?</p>

<a name="169048323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169048323" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169048323">Mario Carneiro (Jun 26 2019 at 16:44)</a>:</h4>
<p>that's called <code>A -&gt; bool</code></p>

<a name="169048346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169048346" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169048346">Kevin Buzzard (Jun 26 2019 at 16:45)</a>:</h4>
<p>Fair comment.</p>

<a name="169048380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169048380" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169048380">Mario Carneiro (Jun 26 2019 at 16:45)</a>:</h4>
<p>If you encoded topologies as <code>(A -&gt; bool) -&gt; bool</code> you could get most things to compute</p>

<a name="169048427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169048427" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169048427">Kevin Buzzard (Jun 26 2019 at 16:46)</a>:</h4>
<p>Patrick, do you fancy refactoring topology again?</p>

<a name="169048511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169048511" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169048511">Mario Carneiro (Jun 26 2019 at 16:47)</a>:</h4>
<p>There is also <code>data.analysis.topology</code> which has "computational realizers" for topologies and filters</p>

<a name="169048528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169048528" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169048528">Mario Carneiro (Jun 26 2019 at 16:48)</a>:</h4>
<p>basically a computable top basis</p>

<a name="169048576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169048576" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169048576">Mario Carneiro (Jun 26 2019 at 16:48)</a>:</h4>
<p>which works even on "real world" topologies like the reals</p>

<a name="169079178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169079178" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169079178">Kevin Buzzard (Jun 26 2019 at 20:56)</a>:</h4>
<p>I've just come back to this. So I think</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">nhds_coinduced</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">T</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">@</span><span class="n">nhds</span> <span class="n">β</span> <span class="o">(</span><span class="n">topological_space</span><span class="bp">.</span><span class="n">coinduced</span> <span class="n">f</span> <span class="n">T</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">map</span> <span class="n">f</span> <span class="o">(</span><span class="n">nhds</span> <span class="n">a</span><span class="o">)</span>
</pre></div>


<p>is false, because a subset <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.22222em;">Y</span></span></span></span> of <code>beta</code> is in the LHS iff <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>a</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(a)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mclose">)</span></span></span></span> is in the interior of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.22222em;">Y</span></span></span></span>, and is in the RHS iff <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">a</span></span></span></span> is in the interior of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>f</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>(</mo><mi>Y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f^{-1}(Y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathrm mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span>. The first of these implies the second, but if I only know that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">a</span></span></span></span> is in the interior of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>f</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>(</mo><mi>Y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f^{-1}(Y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathrm mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span> I can't deduce that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>a</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(a)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mclose">)</span></span></span></span> is in the interior of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.22222em;">Y</span></span></span></span> (consider a closed embedding with <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.22222em;">Y</span></span></span></span> equal to the image and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">a</span></span></span></span> not in the interior of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.22222em;">Y</span></span></span></span> computed in <code>beta</code>).</p>

<a name="169112503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169112503" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169112503">Kevin Buzzard (Jun 27 2019 at 08:06)</a>:</h4>
<p>Oh darn it I can't just consider a closed embedding because f is not just continuous, I need to find an example where beta has the coinduced topology. So I still think it's false. Here are my thoughts. It's really annoying not being able to write beta in Zulip without copy-paste so I'm going to call it <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span>, and similarly <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">A</span></span></span></span> for <code>\alpha</code>.</p>
<p>So an arbitrary subset <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi><mo>⊆</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">Y\subseteq B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.22222em;">Y</span><span class="mrel">⊆</span><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span> is in the LHS if there's some <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi><mo>⊆</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">V\subseteq B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mrel">⊆</span><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span> open such that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>a</mi><mo>)</mo><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">f(a)\in V</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mclose">)</span><span class="mrel">∈</span><span class="mord mathit" style="margin-right:0.22222em;">V</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi><mo>⊆</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">V\subseteq Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mrel">⊆</span><span class="mord mathit" style="margin-right:0.22222em;">Y</span></span></span></span>. The definition of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.22222em;">V</span></span></span></span> being open in <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span> is simply that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi><mo>:</mo><mo>=</mo><msup><mi>f</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>(</mo><mi>V</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">U := f^{-1}(V)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="mrel">:</span><span class="mrel">=</span><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathrm mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span> is open in <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">A</span></span></span></span>. </p>
<p>So <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.22222em;">Y</span></span></span></span> is in the LHS iff there exists some <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi><mo>⊆</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">U\subseteq A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="mrel">⊆</span><span class="mord mathit">A</span></span></span></span> open and a pre-image under <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span></span>, such that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>∈</mo><mi>U</mi><mo>⊆</mo><msup><mi>f</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>(</mo><mi>Y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">a\in U\subseteq f^{-1}(Y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">a</span><span class="mrel">∈</span><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="mrel">⊆</span><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathrm mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span>. And <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.22222em;">Y</span></span></span></span> is in the RHS iff there exists some <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi><mo>⊆</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">U\subseteq A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="mrel">⊆</span><span class="mord mathit">A</span></span></span></span> open (but not necessarily a preimage under <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span></span>) such that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>∈</mo><mi>U</mi><mo>⊆</mo><msup><mi>f</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>(</mo><mi>Y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">a\in U\subseteq f^{-1}(Y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">a</span><span class="mrel">∈</span><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="mrel">⊆</span><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathrm mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span>.</p>
<p>So now this is all about whether subsets are pre-images or not, so we can throw away <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span> and just put an equivalence relation on <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">A</span></span></span></span> (and let <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span> be the quotient and <code>f=mk</code>). And now the question is: come up with an example of a topological space <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">A</span></span></span></span> and a random equivalence relation on it which has nothing to do with the topology,  with the property that there's a union <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07847em;">X</span></span></span></span> of equivalence classes <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msup><mi>f</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>(</mo><mi>Y</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">(f^{-1}(Y))</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathrm mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> and an element <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a\in A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="base"><span class="mord mathit">a</span><span class="mrel">∈</span><span class="mord mathit">A</span></span></span></span> and an open subset <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10903em;">U</span></span></span></span> of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">A</span></span></span></span> with <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>∈</mo><mi>U</mi><mo>⊆</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">a\in U\subseteq X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="base"><span class="mord mathit">a</span><span class="mrel">∈</span><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="mrel">⊆</span><span class="mord mathit" style="margin-right:0.07847em;">X</span></span></span></span>, but where there is no <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>U</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">U'</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:0.751892em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> satisfying the same properties and also being a union of equivalence classes. </p>
<p>The simplest way to do this would be to just have two equivalence classes, one of them being not open, and set-theoretically the disjoint union of an open set and a point, and the other one being the rest. </p>
<p>So it seems to me that the simplest counterexample is this. Let <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>:</mo><mo>=</mo><mo>{</mo><mi>s</mi><mo separator="true">,</mo><mi>η</mi><mo>}</mo></mrow><annotation encoding="application/x-tex">S:=\{s,\eta\}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mrel">:</span><span class="mrel">=</span><span class="mopen">{</span><span class="mord mathit">s</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">η</span><span class="mclose">}</span></span></span></span> be the top space with two elements, a closed (non-open) point <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">s</span></span></span></span> and an open point <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>η</mi></mrow><annotation encoding="application/x-tex">\eta</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.03588em;">η</span></span></span></span> (is this called Sierpinski space or something?). Let <code>alpha</code> be the disjoint union of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span></span> and a discrete one point space <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>{</mo><mi>a</mi><mo>}</mo></mrow><annotation encoding="application/x-tex">\{a\}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">{</span><span class="mord mathit">a</span><span class="mclose">}</span></span></span></span>, as a topological space. Let <code>beta</code> be <code>bool</code> and define a map <code>alpha -&gt; beta</code> by sending <code>s</code> and <code>a</code> to <code>tt</code> and <code>eta</code> to <code>ff</code>. </p>
<p>If I've got this calculation right, and I may not have, then this should be a counterexample, with the subset <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>{</mo><mi>s</mi><mo separator="true">,</mo><mi>a</mi><mo>}</mo></mrow><annotation encoding="application/x-tex">\{s,a\}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">{</span><span class="mord mathit">s</span><span class="mpunct">,</span><span class="mord mathit">a</span><span class="mclose">}</span></span></span></span> being in the right hand side but not the left hand side.</p>
<p>How best to get Lean to check my working?</p>

<a name="169112962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169112962" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169112962">Mario Carneiro (Jun 27 2019 at 08:14)</a>:</h4>
<p>I think that <code>alpha := option Prop</code> and <code>f := is_some</code> will work to get that</p>

<a name="169113935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169113935" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169113935">Kevin Buzzard (Jun 27 2019 at 08:28)</a>:</h4>
<p>In writing down a proof I just had to write <code>existsi subset.trans _ hY</code> because <code>use (subset.trans _ hY)</code> gave me the cool error</p>
<div class="codehilite"><pre><span></span>failed to instantiate goal with subset.trans 6._.104 hY
</pre></div>

<a name="169113975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169113975" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169113975">Mario Carneiro (Jun 27 2019 at 08:29)</a>:</h4>
<p>I have had issues with <code>use</code> in the past as well... it's not a total replacement of <code>existsi</code></p>

<a name="169115302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169115302" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169115302">Kevin Buzzard (Jun 27 2019 at 08:50)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">nhds_coinduced</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">T</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">comap</span> <span class="n">f</span> <span class="o">(</span><span class="bp">@</span><span class="n">nhds</span> <span class="n">β</span> <span class="o">(</span><span class="n">topological_space</span><span class="bp">.</span><span class="n">coinduced</span> <span class="n">f</span> <span class="n">T</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">))</span> <span class="bp">=</span> <span class="o">(</span><span class="n">nhds</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
</pre></div>


<p>I think this theorem is also false, for exactly the same reasons. Are the theorems equivalent? Just shows how little I know about filters. I'm working through examples like this because I've realised that actually I have had very little experience working with filters and lattices in Lean; my abysmal efforts at 3am last Sat trying to make instances of lattice classes where I found that I didn't even know how to create the structures let alone use them, has somehow woken me up a bit.</p>

<a name="169115366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169115366" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169115366">Kevin Buzzard (Jun 27 2019 at 08:51)</a>:</h4>
<blockquote>
<p>I think that <code>alpha := option Prop</code> and <code>f := is_some</code> will work to get that</p>
</blockquote>
<p>I wanted <code>option Sierpinski_space</code>. This feels different. Is it? If Prop = bool then...I'm assuming the top on bool is the discrete top. Am I wrong?</p>

<a name="169115585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169115585" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169115585">Kevin Buzzard (Jun 27 2019 at 08:54)</a>:</h4>
<div class="codehilite"><pre><span></span>@[instance]
protected def bool.topological_space : topological_space bool :=
⊤
</pre></div>


<p>You don't want "truth to be an open condition, falsehood to be a closed one" or something? Oh, is the point that the map Prop -&gt; bool is noncomputable and hence not continuous?</p>

<a name="169115761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169115761" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169115761">Mario Carneiro (Jun 27 2019 at 08:57)</a>:</h4>
<p>The topology on Prop is sierpinski, the topology on bool is discrete</p>

<a name="169115776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169115776" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169115776">Mario Carneiro (Jun 27 2019 at 08:57)</a>:</h4>
<p>Those two theorems are not equivalent</p>

<a name="169115784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169115784" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169115784">Mario Carneiro (Jun 27 2019 at 08:58)</a>:</h4>
<p>(well I guess they are equivalent if they are both false)</p>

<a name="169115785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169115785" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169115785">Kevin Buzzard (Jun 27 2019 at 08:58)</a>:</h4>
<p>And the map from bool to Prop is continuous, and the noncomputable map from Prop to bool is not.</p>

<a name="169115868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169115868" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169115868">Mario Carneiro (Jun 27 2019 at 08:58)</a>:</h4>
<p>I'm not totally convinced that the sierpinski topology on Prop is the "right" one, but it is convenient in this case</p>

<a name="169115881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169115881" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169115881">Kevin Buzzard (Jun 27 2019 at 08:59)</a>:</h4>
<blockquote>
<p>Those two theorems are not equivalent</p>
</blockquote>
<p>Right. I asked because it seemed to me that at the end of the day they were both asking the same question, which surprised me a little.</p>

<a name="169115893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169115893" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169115893">Kevin Buzzard (Jun 27 2019 at 08:59)</a>:</h4>
<p>Are either of map o comap or comap o map the identity?</p>

<a name="169115951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169115951" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169115951">Kevin Buzzard (Jun 27 2019 at 09:00)</a>:</h4>
<p>aah</p>

<a name="169115959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169115959" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169115959">Mario Carneiro (Jun 27 2019 at 09:00)</a>:</h4>
<p>not in general, with these sort of galois connections things</p>

<a name="169115976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169115976" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169115976">Kevin Buzzard (Jun 27 2019 at 09:00)</a>:</h4>
<p>I can just look in the library for theorems whose names contain <code>map_comap</code> etc, and see examples of conditions which force it. So I can see that neither is true in general (as I suspected).</p>

<a name="169116018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169116018" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169116018">Kevin Buzzard (Jun 27 2019 at 09:01)</a>:</h4>
<p>I think that for at least one of those theorems, it's true in general iff it's true for surjections, and perhaps for surjections you can do something.</p>

<a name="169116111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169116111" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169116111">Kevin Buzzard (Jun 27 2019 at 09:02)</a>:</h4>
<p>But this isn't my point. I just want to say to Lean "hey Lean, just go through your database of small topological spaces and find counterexamples for me please". The fact that there is a counterexample with alpha having three elements makes me think that this is possible. Your suggestion with <code>option Prop</code> is somehow not going in the way I want this to go.</p>

<a name="169116163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169116163" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169116163">Kevin Buzzard (Jun 27 2019 at 09:03)</a>:</h4>
<p>It also makes me have to learn what the topology on <code>option X</code> is</p>

<a name="169116246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169116246" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169116246">Mario Carneiro (Jun 27 2019 at 09:04)</a>:</h4>
<p>Turns out there isn't one yet</p>

<a name="169116275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169116275" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169116275">Mario Carneiro (Jun 27 2019 at 09:05)</a>:</h4>
<p>I'm trying to prove this too; here's my prelude so far</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">topology</span><span class="bp">.</span><span class="n">order</span>

<span class="kn">open</span> <span class="n">filter</span>

<span class="kn">namespace</span> <span class="n">topological_space</span>

<span class="kn">instance</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">t</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="o">(</span><span class="n">option</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">coinduced</span> <span class="n">option</span><span class="bp">.</span><span class="n">some</span> <span class="n">t</span>

<span class="kn">theorem</span> <span class="n">nhds_coinduced</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">T</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">@</span><span class="n">nhds</span> <span class="n">β</span> <span class="o">(</span><span class="n">topological_space</span><span class="bp">.</span><span class="n">coinduced</span> <span class="n">f</span> <span class="n">T</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">map</span> <span class="n">f</span> <span class="o">(</span><span class="n">nhds</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">end</span> <span class="n">topological_space</span>

<span class="n">def</span> <span class="n">sierp</span> <span class="o">:=</span> <span class="n">bool</span>
<span class="kn">instance</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">sierp</span> <span class="o">:=</span> <span class="n">topological_space</span><span class="bp">.</span><span class="n">generate_from</span> <span class="o">{{</span><span class="n">tt</span><span class="o">}}</span>

<span class="kn">theorem</span> <span class="n">is_open_sierp</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">sierp</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">is_open</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span><span class="n">a</span><span class="o">}</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="n">tt</span> <span class="err">∈</span> <span class="n">s</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">induction</span> <span class="n">h</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rcases</span> <span class="n">h_H</span> <span class="k">with</span> <span class="n">rfl</span><span class="bp">|⟨⟨⟩⟩</span><span class="o">,</span> <span class="n">exact</span> <span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="n">rfl</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">trivial</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="bp">⟨</span><span class="n">h_ih_a</span> <span class="n">ha</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span> <span class="n">h_ih_a_1</span> <span class="n">ha</span><span class="bp">.</span><span class="mi">2</span><span class="bp">⟩</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rcases</span> <span class="n">ha</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">s</span><span class="o">,</span> <span class="n">h₁</span><span class="o">,</span> <span class="n">h₂</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">exact</span> <span class="bp">⟨</span><span class="n">s</span><span class="o">,</span> <span class="n">h₁</span><span class="o">,</span> <span class="n">h_ih</span> <span class="bp">_</span> <span class="n">h₁</span> <span class="n">h₂</span><span class="bp">⟩</span> <span class="o">}</span>
<span class="kn">end</span>
</pre></div>

<a name="169116672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169116672" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169116672">Mario Carneiro (Jun 27 2019 at 09:10)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">f</span> <span class="o">:</span> <span class="n">option</span> <span class="n">sierp</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">some</span> <span class="n">tt</span><span class="o">)</span> <span class="o">:=</span> <span class="n">tt</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">ff</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="n">le_of_eq</span> <span class="o">(</span><span class="n">topological_space</span><span class="bp">.</span><span class="n">nhds_coinduced</span> <span class="n">f</span> <span class="n">none</span><span class="o">),</span>
  <span class="n">replace</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">this</span> <span class="o">{</span><span class="n">x</span> <span class="bp">|</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">ff</span><span class="o">}</span> <span class="o">(</span><span class="n">mem_map</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">_</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">mem_nhds_sets_iff</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">this</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">s</span><span class="o">,</span> <span class="n">h₁</span><span class="o">,</span> <span class="n">h₂</span><span class="o">,</span> <span class="n">h₃</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">is_open_coinduced</span><span class="o">,</span> <span class="n">is_open_coinduced</span><span class="o">]</span> <span class="n">at</span> <span class="n">h₂</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">h₁</span> <span class="o">(</span><span class="bp">@</span><span class="n">is_open_sierp</span> <span class="bp">_</span> <span class="n">h₂</span> <span class="n">ff</span> <span class="n">h₃</span><span class="o">)</span> <span class="o">},</span>
  <span class="n">refine</span> <span class="n">mem_nhds_sets_iff</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">⟨</span><span class="o">{</span><span class="n">none</span><span class="o">},</span> <span class="bp">_</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="bp">_</span> <span class="o">(</span><span class="n">rfl</span><span class="bp">|⟨⟨⟩⟩</span><span class="o">),</span> <span class="n">exact</span> <span class="n">rfl</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">is_open_coinduced</span><span class="o">,</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">set</span><span class="bp">.</span><span class="n">eq_empty_iff_forall_not_mem</span> <span class="bp">_</span> <span class="o">(</span><span class="n">some</span> <span class="bp">⁻¹</span><span class="err">&#39;</span> <span class="o">{</span><span class="n">none</span><span class="o">}))</span><span class="bp">.</span><span class="mi">2</span><span class="o">],</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">rintro</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">⟨⟨⟩⟩|⟨⟨⟩⟩</span><span class="o">)</span>
<span class="kn">end</span>
</pre></div>

<a name="169116970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169116970" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169116970">Kevin Buzzard (Jun 27 2019 at 09:14)</a>:</h4>
<p>I reduced the (false) theorem</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">nhds_coinduced</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">T</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">comap</span> <span class="n">f</span> <span class="o">(</span><span class="bp">@</span><span class="n">nhds</span> <span class="n">β</span> <span class="o">(</span><span class="n">topological_space</span><span class="bp">.</span><span class="n">coinduced</span> <span class="n">f</span> <span class="n">T</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">))</span> <span class="bp">=</span> <span class="o">(</span><span class="n">nhds</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
</pre></div>


<p>to</p>
<div class="codehilite"><pre><span></span>1 goal
α β : Type,
T : topological_space α,
f : α → β,
a : α,
X : set α,
hX : X ∈ (nhds a).sets
⊢ ∃ (t : set β) (H : t ∈ nhds (f a)), f ⁻¹&#39; t ⊆ X
</pre></div>

<a name="169117133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169117133" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169117133">Mario Carneiro (Jun 27 2019 at 09:16)</a>:</h4>
<p>reduced in what direction?</p>

<a name="169117143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169117143" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169117143">Mario Carneiro (Jun 27 2019 at 09:17)</a>:</h4>
<p>Are you saying that goal implies the theorem or vice versa?</p>

<a name="169117155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169117155" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169117155">Kevin Buzzard (Jun 27 2019 at 09:17)</a>:</h4>
<p>This seems to say that an arbitrary neighbourhood of a should be contained within a neighbourhood which is a preimage. Exactly the same false statement. In fact this should be perhaps thought of as the criterion under which one can deduce both of these theorems <span class="user-mention" data-user-id="110031">@Patrick Massot</span> ; it looks to me like it's equivalent. Does it have some more natural interpretation? I think the goal I just posted above, when considered as a hypothesis, is basically equivalent to both the theorems.</p>

<a name="169117161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169117161" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169117161">Kevin Buzzard (Jun 27 2019 at 09:17)</a>:</h4>
<p>I am saying that I started with the false theorem, tried to prove it, and that's where I'm stuck.</p>

<a name="169117177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169117177" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169117177">Kevin Buzzard (Jun 27 2019 at 09:17)</a>:</h4>
<p>However I am not sure I actually did anything non-reversible.</p>

<a name="169117298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169117298" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169117298">Mario Carneiro (Jun 27 2019 at 09:19)</a>:</h4>
<p>Here's a different question. What <em>is</em> an expression for <code>@nhds β (topological_space.coinduced f T) (f a)</code>?</p>

<a name="169117322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169117322" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169117322">Kevin Buzzard (Jun 27 2019 at 09:20)</a>:</h4>
<p>I've been thinking about it as some sort of sub-filter of  <code>nhds a</code></p>

<a name="169117376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169117376" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169117376">Mario Carneiro (Jun 27 2019 at 09:20)</a>:</h4>
<p>So there is at least one inequality that can be proved then</p>

<a name="169117401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169117401" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169117401">Kevin Buzzard (Jun 27 2019 at 09:20)</a>:</h4>
<p>It's not really a sub-filter, because it also contains a bunch of junk coming from points in beta which aren't in the image of f</p>

<a name="169117414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169117414" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169117414">Kevin Buzzard (Jun 27 2019 at 09:21)</a>:</h4>
<p>I don't really know how to think about filters.</p>

<a name="169117416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169117416" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169117416">Mario Carneiro (Jun 27 2019 at 09:21)</a>:</h4>
<p>You will notice that in the proof of false above the first thing I do is use <code>le_of_eq</code> on the false theorem, so maybe the other inequality holds</p>

<a name="169117426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169117426" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169117426">Kevin Buzzard (Jun 27 2019 at 09:21)</a>:</h4>
<p>Oh yeah, I proved inclusions for both false theorems</p>

<a name="169117453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169117453" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169117453">Kevin Buzzard (Jun 27 2019 at 09:21)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">nhds_coinduced</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">T</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">comap</span> <span class="n">f</span> <span class="o">(</span><span class="bp">@</span><span class="n">nhds</span> <span class="n">β</span> <span class="o">(</span><span class="n">topological_space</span><span class="bp">.</span><span class="n">coinduced</span> <span class="n">f</span> <span class="n">T</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">))</span> <span class="bp">=</span> <span class="o">(</span><span class="n">nhds</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">apply</span> <span class="n">filter</span><span class="bp">.</span><span class="n">ext</span><span class="o">,</span>
  <span class="n">dsimp</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">X</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
    <span class="n">rintro</span> <span class="bp">⟨</span><span class="n">Y</span><span class="o">,</span> <span class="n">H</span><span class="o">,</span> <span class="n">hY</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">mem_nhds_sets_iff</span> <span class="n">at</span> <span class="n">H</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">H</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">V</span><span class="o">,</span> <span class="n">HVY</span><span class="o">,</span> <span class="n">HV</span><span class="o">,</span> <span class="n">HaV</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">mem_nhds_sets_iff</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">f</span> <span class="bp">⁻¹</span><span class="err">&#39;</span> <span class="n">V</span><span class="o">,</span>
    <span class="n">existsi</span> <span class="o">(</span><span class="n">subset</span><span class="bp">.</span><span class="n">trans</span> <span class="bp">_</span> <span class="n">hY</span><span class="o">),</span>
      <span class="n">split</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">HV</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">HaV</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="n">exact</span> <span class="n">HVY</span> <span class="n">hx</span><span class="o">,</span>
  <span class="c1">-- bad way</span>
  <span class="n">intro</span> <span class="n">hX</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">mem_comap_sets</span><span class="o">,</span>
  <span class="n">sorry</span> <span class="c1">--goal is false</span>
<span class="kn">end</span>
</pre></div>

<a name="169117563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169117563" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169117563">Kevin Buzzard (Jun 27 2019 at 09:22)</a>:</h4>
<p>I didn't formalise the other proof but it's equally easy.</p>

<a name="169117598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169117598" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169117598">Kevin Buzzard (Jun 27 2019 at 09:23)</a>:</h4>
<p>I have no feeling for what should go in the library (or whether something is already there).</p>

<a name="169117616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169117616" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169117616">Mario Carneiro (Jun 27 2019 at 09:23)</a>:</h4>
<p>usually it is <code>comap f L' &lt;= L</code> and <code>L' &lt;= map f L</code> that are the strong/ false properties; the other inequalities <code>L &lt;= comap f L'</code> and <code>map f L &lt;= L'</code> are equivalent to each other (they are the adjunction) and are equivalent to a tendsto</p>

<a name="169118157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169118157" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169118157">Mario Carneiro (Jun 27 2019 at 09:31)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">nhds_coinduced_comap</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">T</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">nhds</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">comap</span> <span class="n">f</span> <span class="o">(</span><span class="bp">@</span><span class="n">nhds</span> <span class="n">β</span> <span class="o">(</span><span class="n">topological_space</span><span class="bp">.</span><span class="n">coinduced</span> <span class="n">f</span> <span class="n">T</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">tendsto_iff_comap</span><span class="bp">.</span><span class="mi">1</span> <span class="err">$</span>
<span class="k">by</span> <span class="n">apply</span> <span class="n">continuous</span><span class="bp">.</span><span class="n">tendsto</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">continuous_coinduced_rng</span>
</pre></div>

<a name="169118259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169118259" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169118259">Kevin Buzzard (Jun 27 2019 at 09:32)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">nhds_coinduced</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">T</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">map</span> <span class="n">f</span> <span class="o">(</span><span class="n">nhds</span> <span class="n">a</span><span class="o">)</span> <span class="bp">≤</span> <span class="bp">@</span><span class="n">nhds</span> <span class="n">β</span> <span class="o">(</span><span class="n">topological_space</span><span class="bp">.</span><span class="n">coinduced</span> <span class="n">f</span> <span class="n">T</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">Y</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">HY</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">mem_nhds_sets_iff</span> <span class="n">at</span> <span class="n">HY</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">HY</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">V</span><span class="o">,</span> <span class="n">HV</span><span class="o">,</span> <span class="n">HOV</span><span class="o">,</span> <span class="n">HaV</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">mem_map</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">mem_nhds_sets_iff</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">f</span> <span class="bp">⁻¹</span><span class="err">&#39;</span> <span class="n">V</span><span class="o">,</span>
  <span class="n">existsi</span> <span class="bp">_</span><span class="o">,</span> <span class="n">swap</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="n">apply</span> <span class="n">HV</span><span class="o">,</span> <span class="n">exact</span> <span class="n">hx</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span> <span class="n">exact</span> <span class="n">HOV</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">HaV</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>

<a name="169118267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169118267" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169118267">Kevin Buzzard (Jun 27 2019 at 09:32)</a>:</h4>
<p>Aah but you can just do that one with the Galois connection thing I guess.</p>

<a name="169118296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169118296" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169118296">Kevin Buzzard (Jun 27 2019 at 09:32)</a>:</h4>
<p>I'm assuming it works that way around :-)</p>

<a name="169118320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169118320" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169118320">Mario Carneiro (Jun 27 2019 at 09:33)</a>:</h4>
<p>yes, it's even easier because this is the definition of tendsto:</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">nhds_coinduced_map</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">T</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">map</span> <span class="n">f</span> <span class="o">(</span><span class="n">nhds</span> <span class="n">a</span><span class="o">)</span> <span class="bp">≤</span> <span class="bp">@</span><span class="n">nhds</span> <span class="n">β</span> <span class="o">(</span><span class="n">topological_space</span><span class="bp">.</span><span class="n">coinduced</span> <span class="n">f</span> <span class="n">T</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">apply</span> <span class="n">continuous</span><span class="bp">.</span><span class="n">tendsto</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">continuous_coinduced_rng</span>
</pre></div>

<a name="169118450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169118450" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169118450">Kevin Buzzard (Jun 27 2019 at 09:35)</a>:</h4>
<p>So now the only question left is whether that goal I posted above is a sufficiently interesting precondition to get the other inequalities. I'm having trouble visualising it in some conceptual way. Once one has visualised it in a conceptual way, it might simply turn into literally the statement of the inequality in the other direction.</p>

<a name="169118465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169118465" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169118465">Mario Carneiro (Jun 27 2019 at 09:35)</a>:</h4>
<p>I suspect this has something to do with being a quotient map</p>

<a name="169118484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169118484" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169118484">Mario Carneiro (Jun 27 2019 at 09:35)</a>:</h4>
<p>because <code>topological_space.coinduced</code> is basically the quotient topology</p>

<a name="169132521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169132521" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169132521">Patrick Massot (Jun 27 2019 at 13:05)</a>:</h4>
<p>Thank you very much Kevin and Mario. I didn't think that question would trigger so many messages in my absence. I should have written more assertively I thought the obvious nice formula was wrong (even if I don't have a counter-example).</p>

<a name="169149573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169149573" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169149573">Kevin Buzzard (Jun 27 2019 at 16:18)</a>:</h4>
<p>What I found frustrating is that I still don't really understand why we can't just say "test this on all surjections from topological spaces with at most three elements". Is the fact that an open set is a map to Prop and not bool enough to actually stop this happening?</p>

<a name="169150094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169150094" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169150094">Chris Hughes (Jun 27 2019 at 16:24)</a>:</h4>
<p>It's enough to make it more difficult.</p>

<a name="169150284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169150284" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169150284">Johan Commelin (Jun 27 2019 at 16:27)</a>:</h4>
<p>If only we had some tactic that would transform maps to <code>Prop</code> into maps to the equivalent <code>bool</code>...</p>

<a name="169150418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169150418" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169150418">Johan Commelin (Jun 27 2019 at 16:29)</a>:</h4>
<p>Should we define <code>toboological_space</code>? Define some <code>transfer</code> relations? Would it be easy to test Kevin's question on <code>toboological_space</code>s with at most 3 elements? Or would this still require a significant amount of work?</p>

<a name="169151278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169151278" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169151278">Kevin Buzzard (Jun 27 2019 at 16:39)</a>:</h4>
<p>I just like doing little exercises like this, I need to learn more about how to use filters and lattices and the like.</p>

<a name="169151483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169151483" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169151483">Reid Barton (Jun 27 2019 at 16:42)</a>:</h4>
<p>The fact that we have to deal with <code>set (set X)</code> and not just <code>set X</code> also makes it a bit more difficult</p>

<a name="169151498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169151498" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169151498">Kevin Buzzard (Jun 27 2019 at 16:42)</a>:</h4>
<p>I couldn't get <code>f ⁻¹' ⁻¹'</code> to work :-)</p>

<a name="169151548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169151548" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169151548">Kevin Buzzard (Jun 27 2019 at 16:43)</a>:</h4>
<p>That's the definition of filter.map</p>

<a name="169152366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169152366" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169152366">Reid Barton (Jun 27 2019 at 16:54)</a>:</h4>
<p>maybe <code>((f ⁻¹') ⁻¹')</code>?</p>

<a name="169173895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169173895" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169173895">Kevin Buzzard (Jun 27 2019 at 20:47)</a>:</h4>
<p>I couldn't get that to work</p>


{% endraw %}
