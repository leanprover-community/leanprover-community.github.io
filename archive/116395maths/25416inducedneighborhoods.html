---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/116395maths/25416inducedneighborhoods.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html">induced neighborhoods</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="169041614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169041614" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169041614">Patrick Massot (Jun 26 2019 at 15:29)</a>:</h4>
<p>What should we do with the duplication <a href="https://github.com/leanprover-community/mathlib/blob/master/src/topology/order.lean#L557-L558" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/src/topology/order.lean#L557-L558">https://github.com/leanprover-community/mathlib/blob/master/src/topology/order.lean#L557-L558</a> vs <a href="https://github.com/leanprover-community/mathlib/blob/master/src/topology/order.lean#L862" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/src/topology/order.lean#L862">https://github.com/leanprover-community/mathlib/blob/master/src/topology/order.lean#L862</a>?</p>

<a name="169043080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169043080" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169043080">Patrick Massot (Jun 26 2019 at 15:45)</a>:</h4>
<p>And where is the corresponding lemma for the coinduced topology?</p>

<a name="169043416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169043416" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169043416">Patrick Massot (Jun 26 2019 at 15:49)</a>:</h4>
<p>maybe it's wrong actually</p>

<a name="169043423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169043423" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169043423">Patrick Massot (Jun 26 2019 at 15:49)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span>?</p>

<a name="169043776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169043776" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169043776">Reid Barton (Jun 26 2019 at 15:53)</a>:</h4>
<p>I guess just delete the second one and update its uses to use the first one</p>

<a name="169043801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169043801" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169043801">Reid Barton (Jun 26 2019 at 15:53)</a>:</h4>
<p>I don't think we need to preserve the name</p>

<a name="169043961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169043961" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169043961">Patrick Massot (Jun 26 2019 at 15:55)</a>:</h4>
<p>What about the coinduced topology?</p>

<a name="169046330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169046330" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169046330">Kevin Buzzard (Jun 26 2019 at 16:21)</a>:</h4>
<p>The function and the element are explicit in one, implicit in the other. Which is "right"?</p>

<a name="169046359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169046359" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169046359">Mario Carneiro (Jun 26 2019 at 16:21)</a>:</h4>
<p>explicit</p>

<a name="169046435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169046435" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169046435">Kevin Buzzard (Jun 26 2019 at 16:22)</a>:</h4>
<p>And what's the algorithm for working this out? Both f and a are determined by the type of the conclusion.</p>

<a name="169046466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169046466" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169046466">Mario Carneiro (Jun 26 2019 at 16:22)</a>:</h4>
<p>you don't use the type of the conclusion in the accounting, just other hypotheses</p>

<a name="169046497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169046497" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169046497">Mario Carneiro (Jun 26 2019 at 16:23)</a>:</h4>
<p>One way to put it: if you write <code>have := my_thm a b c h1 h2</code> with all explicit variables filled in, then there should be no metavariables remaining</p>

<a name="169046550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169046550" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169046550">Kevin Buzzard (Jun 26 2019 at 16:24)</a>:</h4>
<p>Thanks.</p>

<a name="169046595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169046595" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169046595">Mario Carneiro (Jun 26 2019 at 16:24)</a>:</h4>
<p>The rule for iff's is a bit different though; it is sufficient that <code>(my_iff a).1 h</code> and <code>(my_iff a).2 h'</code> have no metavariables</p>

<a name="169046826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169046826" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169046826">Kevin Buzzard (Jun 26 2019 at 16:28)</a>:</h4>
<blockquote>
<p>What about the coinduced topology?</p>
</blockquote>
<p>Is the corresponding lemma still about comaps, or about maps? Or are they the same?</p>

<a name="169046896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169046896" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169046896">Patrick Massot (Jun 26 2019 at 16:28)</a>:</h4>
<p>The tempting statement uses <code>map</code>, but it looks wrong</p>

<a name="169046970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169046970" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169046970">Mario Carneiro (Jun 26 2019 at 16:29)</a>:</h4>
<p>It may be missing because there isn't a nice statement</p>

<a name="169046998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169046998" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169046998">Kevin Buzzard (Jun 26 2019 at 16:29)</a>:</h4>
<p>Can we guess statements and then somehow try them out on all topological spaces with at most three elements?</p>

<a name="169047064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169047064" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169047064">Kevin Buzzard (Jun 26 2019 at 16:30)</a>:</h4>
<p>I ran into that issue yesterday. It would be really cool to be able to formalise a guess and then just try it</p>

<a name="169047096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169047096" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169047096">Patrick Massot (Jun 26 2019 at 16:30)</a>:</h4>
<p>Where is this nuchaku thing again?</p>

<a name="169047118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169047118" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169047118">Kevin Buzzard (Jun 26 2019 at 16:30)</a>:</h4>
<p>In fact Lean should have an option where it occasionally tests your goal with random values for the variables and then prints a little message saying "by the way your goal is false right now" if it finds a counterexample</p>

<a name="169047307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169047307" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169047307">Patrick Massot (Jun 26 2019 at 16:33)</a>:</h4>
<p><a href="https://github.com/nunchaku-inria/nunchaku" target="_blank" title="https://github.com/nunchaku-inria/nunchaku">https://github.com/nunchaku-inria/nunchaku</a></p>

<a name="169047332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169047332" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169047332">Patrick Massot (Jun 26 2019 at 16:33)</a>:</h4>
<p>I don't know how far it is from being usable</p>

<a name="169047430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169047430" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169047430">Mario Carneiro (Jun 26 2019 at 16:34)</a>:</h4>
<p>or how far it is from lean</p>

<a name="169047563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169047563" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169047563">Mario Carneiro (Jun 26 2019 at 16:35)</a>:</h4>
<p><span class="user-mention" data-user-id="121058">@Jasmin Blanchette</span> Help us! Where is leanchaku?</p>

<a name="169047666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169047666" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169047666">Kevin Buzzard (Jun 26 2019 at 16:36)</a>:</h4>
<p>Even something like this <a href="#narrow/stream/113489-new-members/topic/noob.20question%28s%29/near/168891798" title="#narrow/stream/113489-new-members/topic/noob.20question%28s%29/near/168891798">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/noob.20question%28s%29/near/168891798</a> would be cool.</p>

<a name="169047721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169047721" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169047721">Mario Carneiro (Jun 26 2019 at 16:37)</a>:</h4>
<p>That requires your goal be computable though</p>

<a name="169047722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169047722" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169047722">Kevin Buzzard (Jun 26 2019 at 16:37)</a>:</h4>
<p>You just guess</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">nhds_coinduced</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">T</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">@</span><span class="n">nhds</span> <span class="n">β</span> <span class="o">(</span><span class="n">topological_space</span><span class="bp">.</span><span class="n">coinduced</span> <span class="n">f</span> <span class="n">T</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">map</span> <span class="n">f</span> <span class="o">(</span><span class="n">nhds</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
</pre></div>


<p>randomly and fire a bunch of topological spaces at it and see.</p>

<a name="169047740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169047740" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169047740">Mario Carneiro (Jun 26 2019 at 16:37)</a>:</h4>
<p>most top space stuff isn't computable</p>

<a name="169047755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169047755" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169047755">Kevin Buzzard (Jun 26 2019 at 16:37)</a>:</h4>
<p>Even if they only have 3 elements?</p>

<a name="169047817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169047817" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169047817">Mario Carneiro (Jun 26 2019 at 16:38)</a>:</h4>
<p>it's not a computable statement - it's not written in terms of computable functions</p>

<a name="169047830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169047830" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169047830">Mario Carneiro (Jun 26 2019 at 16:38)</a>:</h4>
<p>it's just some thing about sets</p>

<a name="169047843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169047843" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169047843">Kevin Buzzard (Jun 26 2019 at 16:38)</a>:</h4>
<p>can we enumerate all subsets of a decidable finset?</p>

<a name="169047851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169047851" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169047851">Mario Carneiro (Jun 26 2019 at 16:39)</a>:</h4>
<p>Sure it's possible to algorithmically determine the answer on small finite sets but we would need a decision procedure</p>

<a name="169047874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169047874" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169047874">Kevin Buzzard (Jun 26 2019 at 16:39)</a>:</h4>
<p>"just check everything"?</p>

<a name="169047955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169047955" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169047955">Mario Carneiro (Jun 26 2019 at 16:40)</a>:</h4>
<p>And many of the facts aren't even over computable types, e.g. you might have to check whether {1} = {2, 3} as elements of <code>set nat</code></p>

<a name="169047992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169047992" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169047992">Kevin Buzzard (Jun 26 2019 at 16:40)</a>:</h4>
<p>I want to stick to finite decidable types.</p>

<a name="169048041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169048041" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169048041">Mario Carneiro (Jun 26 2019 at 16:41)</a>:</h4>
<p>even then</p>

<a name="169048063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169048063" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169048063">Mario Carneiro (Jun 26 2019 at 16:41)</a>:</h4>
<p>even if it said <code>set (fin 4)</code> there it wouldn't work</p>

<a name="169048083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169048083" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169048083">Mario Carneiro (Jun 26 2019 at 16:41)</a>:</h4>
<p>because you can't have a decidable_eq for set</p>

<a name="169048087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169048087" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169048087">Kevin Buzzard (Jun 26 2019 at 16:41)</a>:</h4>
<p>I saw Kenny do this once. Someone said "is it true that every commutative binary relation is associative" and a couple of minutes later Kenny said "no, here is a random two element set and a random commutative binary relation which is not associative"</p>

<a name="169048155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169048155" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169048155">Kevin Buzzard (Jun 26 2019 at 16:42)</a>:</h4>
<p>which he found by using a tool which searched for counterexamples</p>

<a name="169048196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169048196" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169048196">Mario Carneiro (Jun 26 2019 at 16:42)</a>:</h4>
<p>It's possible to make computable versions of all the functions in the statement, but I don't think you can get that to happen automatically by inferring a decidable instance</p>

<a name="169048213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169048213" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169048213">Kevin Buzzard (Jun 26 2019 at 16:43)</a>:</h4>
<blockquote>
<p>because you can't have a decidable_eq for set</p>
</blockquote>
<p>What if they're decidable sets or something? There must be a way around this.</p>

<a name="169048243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169048243" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169048243">Kevin Buzzard (Jun 26 2019 at 16:43)</a>:</h4>
<p>I just want to let A and B be sets of size 3 and put a random topology on A and choose a random element and test the proposition.</p>

<a name="169048299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169048299" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169048299">Mario Carneiro (Jun 26 2019 at 16:44)</a>:</h4>
<p>I think you can prove <code>decidable (s = t)</code> if <code>decidable_pred s</code> and <code>decidable_pred t</code> and <code>s t : set A</code> where <code>fintype A</code></p>

<a name="169048313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169048313" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169048313">Kevin Buzzard (Jun 26 2019 at 16:44)</a>:</h4>
<p>Is there <code>decidable_pred_set A</code>?</p>

<a name="169048323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169048323" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169048323">Mario Carneiro (Jun 26 2019 at 16:44)</a>:</h4>
<p>that's called <code>A -&gt; bool</code></p>

<a name="169048346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169048346" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169048346">Kevin Buzzard (Jun 26 2019 at 16:45)</a>:</h4>
<p>Fair comment.</p>

<a name="169048380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169048380" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169048380">Mario Carneiro (Jun 26 2019 at 16:45)</a>:</h4>
<p>If you encoded topologies as <code>(A -&gt; bool) -&gt; bool</code> you could get most things to compute</p>

<a name="169048427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169048427" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169048427">Kevin Buzzard (Jun 26 2019 at 16:46)</a>:</h4>
<p>Patrick, do you fancy refactoring topology again?</p>

<a name="169048511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169048511" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169048511">Mario Carneiro (Jun 26 2019 at 16:47)</a>:</h4>
<p>There is also <code>data.analysis.topology</code> which has "computational realizers" for topologies and filters</p>

<a name="169048528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169048528" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169048528">Mario Carneiro (Jun 26 2019 at 16:48)</a>:</h4>
<p>basically a computable top basis</p>

<a name="169048576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169048576" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169048576">Mario Carneiro (Jun 26 2019 at 16:48)</a>:</h4>
<p>which works even on "real world" topologies like the reals</p>

<a name="169079178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169079178" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169079178">Kevin Buzzard (Jun 26 2019 at 20:56)</a>:</h4>
<p>I've just come back to this. So I think</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">nhds_coinduced</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">T</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">@</span><span class="n">nhds</span> <span class="n">β</span> <span class="o">(</span><span class="n">topological_space</span><span class="bp">.</span><span class="n">coinduced</span> <span class="n">f</span> <span class="n">T</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">map</span> <span class="n">f</span> <span class="o">(</span><span class="n">nhds</span> <span class="n">a</span><span class="o">)</span>
</pre></div>


<p>is false, because a subset <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.22222em;">Y</span></span></span></span> of <code>beta</code> is in the LHS iff <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>a</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(a)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mclose">)</span></span></span></span> is in the interior of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.22222em;">Y</span></span></span></span>, and is in the RHS iff <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">a</span></span></span></span> is in the interior of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>f</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>(</mo><mi>Y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f^{-1}(Y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathrm mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span>. The first of these implies the second, but if I only know that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">a</span></span></span></span> is in the interior of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>f</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>(</mo><mi>Y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f^{-1}(Y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathrm mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span> I can't deduce that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>a</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(a)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mclose">)</span></span></span></span> is in the interior of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.22222em;">Y</span></span></span></span> (consider a closed embedding with <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.22222em;">Y</span></span></span></span> equal to the image and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">a</span></span></span></span> not in the interior of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.22222em;">Y</span></span></span></span> computed in <code>beta</code>).</p>

<a name="169112503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169112503" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169112503">Kevin Buzzard (Jun 27 2019 at 08:06)</a>:</h4>
<p>Oh darn it I can't just consider a closed embedding because f is not just continuous, I need to find an example where beta has the coinduced topology. So I still think it's false. Here are my thoughts. It's really annoying not being able to write beta in Zulip without copy-paste so I'm going to call it <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span>, and similarly <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">A</span></span></span></span> for <code>\alpha</code>.</p>
<p>So an arbitrary subset <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi><mo>⊆</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">Y\subseteq B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.22222em;">Y</span><span class="mrel">⊆</span><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span> is in the LHS if there's some <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi><mo>⊆</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">V\subseteq B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mrel">⊆</span><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span> open such that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>a</mi><mo>)</mo><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">f(a)\in V</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mclose">)</span><span class="mrel">∈</span><span class="mord mathit" style="margin-right:0.22222em;">V</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi><mo>⊆</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">V\subseteq Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mrel">⊆</span><span class="mord mathit" style="margin-right:0.22222em;">Y</span></span></span></span>. The definition of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.22222em;">V</span></span></span></span> being open in <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span> is simply that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi><mo>:</mo><mo>=</mo><msup><mi>f</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>(</mo><mi>V</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">U := f^{-1}(V)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="mrel">:</span><span class="mrel">=</span><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathrm mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span> is open in <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">A</span></span></span></span>. </p>
<p>So <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.22222em;">Y</span></span></span></span> is in the LHS iff there exists some <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi><mo>⊆</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">U\subseteq A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="mrel">⊆</span><span class="mord mathit">A</span></span></span></span> open and a pre-image under <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span></span>, such that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>∈</mo><mi>U</mi><mo>⊆</mo><msup><mi>f</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>(</mo><mi>Y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">a\in U\subseteq f^{-1}(Y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">a</span><span class="mrel">∈</span><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="mrel">⊆</span><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathrm mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span>. And <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.22222em;">Y</span></span></span></span> is in the RHS iff there exists some <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi><mo>⊆</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">U\subseteq A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="mrel">⊆</span><span class="mord mathit">A</span></span></span></span> open (but not necessarily a preimage under <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span></span>) such that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>∈</mo><mi>U</mi><mo>⊆</mo><msup><mi>f</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>(</mo><mi>Y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">a\in U\subseteq f^{-1}(Y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">a</span><span class="mrel">∈</span><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="mrel">⊆</span><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathrm mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span>.</p>
<p>So now this is all about whether subsets are pre-images or not, so we can throw away <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span> and just put an equivalence relation on <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">A</span></span></span></span> (and let <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span> be the quotient and <code>f=mk</code>). And now the question is: come up with an example of a topological space <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">A</span></span></span></span> and a random equivalence relation on it which has nothing to do with the topology,  with the property that there's a union <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07847em;">X</span></span></span></span> of equivalence classes <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msup><mi>f</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>(</mo><mi>Y</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">(f^{-1}(Y))</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathrm mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> and an element <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a\in A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="base"><span class="mord mathit">a</span><span class="mrel">∈</span><span class="mord mathit">A</span></span></span></span> and an open subset <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10903em;">U</span></span></span></span> of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">A</span></span></span></span> with <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>∈</mo><mi>U</mi><mo>⊆</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">a\in U\subseteq X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="base"><span class="mord mathit">a</span><span class="mrel">∈</span><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="mrel">⊆</span><span class="mord mathit" style="margin-right:0.07847em;">X</span></span></span></span>, but where there is no <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>U</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">U'</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:0.751892em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> satisfying the same properties and also being a union of equivalence classes. </p>
<p>The simplest way to do this would be to just have two equivalence classes, one of them being not open, and set-theoretically the disjoint union of an open set and a point, and the other one being the rest. </p>
<p>So it seems to me that the simplest counterexample is this. Let <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>:</mo><mo>=</mo><mo>{</mo><mi>s</mi><mo separator="true">,</mo><mi>η</mi><mo>}</mo></mrow><annotation encoding="application/x-tex">S:=\{s,\eta\}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mrel">:</span><span class="mrel">=</span><span class="mopen">{</span><span class="mord mathit">s</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">η</span><span class="mclose">}</span></span></span></span> be the top space with two elements, a closed (non-open) point <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">s</span></span></span></span> and an open point <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>η</mi></mrow><annotation encoding="application/x-tex">\eta</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.03588em;">η</span></span></span></span> (is this called Sierpinski space or something?). Let <code>alpha</code> be the disjoint union of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span></span> and a discrete one point space <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>{</mo><mi>a</mi><mo>}</mo></mrow><annotation encoding="application/x-tex">\{a\}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">{</span><span class="mord mathit">a</span><span class="mclose">}</span></span></span></span>, as a topological space. Let <code>beta</code> be <code>bool</code> and define a map <code>alpha -&gt; beta</code> by sending <code>s</code> and <code>a</code> to <code>tt</code> and <code>eta</code> to <code>ff</code>. </p>
<p>If I've got this calculation right, and I may not have, then this should be a counterexample, with the subset <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>{</mo><mi>s</mi><mo separator="true">,</mo><mi>a</mi><mo>}</mo></mrow><annotation encoding="application/x-tex">\{s,a\}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">{</span><span class="mord mathit">s</span><span class="mpunct">,</span><span class="mord mathit">a</span><span class="mclose">}</span></span></span></span> being in the right hand side but not the left hand side.</p>
<p>How best to get Lean to check my working?</p>

<a name="169112962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169112962" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169112962">Mario Carneiro (Jun 27 2019 at 08:14)</a>:</h4>
<p>I think that <code>alpha := option Prop</code> and <code>f := is_some</code> will work to get that</p>

<a name="169113935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169113935" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169113935">Kevin Buzzard (Jun 27 2019 at 08:28)</a>:</h4>
<p>In writing down a proof I just had to write <code>existsi subset.trans _ hY</code> because <code>use (subset.trans _ hY)</code> gave me the cool error</p>
<div class="codehilite"><pre><span></span>failed to instantiate goal with subset.trans 6._.104 hY
</pre></div>

<a name="169113975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169113975" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169113975">Mario Carneiro (Jun 27 2019 at 08:29)</a>:</h4>
<p>I have had issues with <code>use</code> in the past as well... it's not a total replacement of <code>existsi</code></p>

<a name="169115302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169115302" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169115302">Kevin Buzzard (Jun 27 2019 at 08:50)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">nhds_coinduced</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">T</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">comap</span> <span class="n">f</span> <span class="o">(</span><span class="bp">@</span><span class="n">nhds</span> <span class="n">β</span> <span class="o">(</span><span class="n">topological_space</span><span class="bp">.</span><span class="n">coinduced</span> <span class="n">f</span> <span class="n">T</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">))</span> <span class="bp">=</span> <span class="o">(</span><span class="n">nhds</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
</pre></div>


<p>I think this theorem is also false, for exactly the same reasons. Are the theorems equivalent? Just shows how little I know about filters. I'm working through examples like this because I've realised that actually I have had very little experience working with filters and lattices in Lean; my abysmal efforts at 3am last Sat trying to make instances of lattice classes where I found that I didn't even know how to create the structures let alone use them, has somehow woken me up a bit.</p>

<a name="169115366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169115366" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169115366">Kevin Buzzard (Jun 27 2019 at 08:51)</a>:</h4>
<blockquote>
<p>I think that <code>alpha := option Prop</code> and <code>f := is_some</code> will work to get that</p>
</blockquote>
<p>I wanted <code>option Sierpinski_space</code>. This feels different. Is it? If Prop = bool then...I'm assuming the top on bool is the discrete top. Am I wrong?</p>

<a name="169115585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169115585" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169115585">Kevin Buzzard (Jun 27 2019 at 08:54)</a>:</h4>
<div class="codehilite"><pre><span></span>@[instance]
protected def bool.topological_space : topological_space bool :=
⊤
</pre></div>


<p>You don't want "truth to be an open condition, falsehood to be a closed one" or something? Oh, is the point that the map Prop -&gt; bool is noncomputable and hence not continuous?</p>

<a name="169115761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169115761" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169115761">Mario Carneiro (Jun 27 2019 at 08:57)</a>:</h4>
<p>The topology on Prop is sierpinski, the topology on bool is discrete</p>

<a name="169115776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169115776" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169115776">Mario Carneiro (Jun 27 2019 at 08:57)</a>:</h4>
<p>Those two theorems are not equivalent</p>

<a name="169115784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169115784" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169115784">Mario Carneiro (Jun 27 2019 at 08:58)</a>:</h4>
<p>(well I guess they are equivalent if they are both false)</p>

<a name="169115785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169115785" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169115785">Kevin Buzzard (Jun 27 2019 at 08:58)</a>:</h4>
<p>And the map from bool to Prop is continuous, and the noncomputable map from Prop to bool is not.</p>

<a name="169115868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169115868" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169115868">Mario Carneiro (Jun 27 2019 at 08:58)</a>:</h4>
<p>I'm not totally convinced that the sierpinski topology on Prop is the "right" one, but it is convenient in this case</p>

<a name="169115881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169115881" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169115881">Kevin Buzzard (Jun 27 2019 at 08:59)</a>:</h4>
<blockquote>
<p>Those two theorems are not equivalent</p>
</blockquote>
<p>Right. I asked because it seemed to me that at the end of the day they were both asking the same question, which surprised me a little.</p>

<a name="169115893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/induced%20neighborhoods/near/169115893" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/25416inducedneighborhoods.html#169115893">Kevin Buzzard (Jun 27 2019 at 08:59)</a>:</h4>
<p>Are either of map o comap or comap o map the identity?</p>


{% endraw %}
