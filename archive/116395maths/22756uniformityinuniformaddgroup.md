---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/116395maths/22756uniformityinuniformaddgroup.html
---

## Stream: [maths](index.html)
### Topic: [uniformity in uniform add group](22756uniformityinuniformaddgroup.html)

---


{% raw %}
#### [ Patrick Massot (Dec 19 2018 at 21:12)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/uniformity%20in%20uniform%20add%20group/near/152209408):
<p>I guess this question is mostly for <span class="user-mention" data-user-id="110294">@Johannes Hölzl</span>, but everyone is welcome to participate. Remember that, given an additive group structure and a uniform structure on a type <code>a</code>, the Prop-valued class <code>uniform_add_group a</code> states that substraction is uniformly continuous. The key lemma about such groups is <a href="https://github.com/leanprover/mathlib/blob/master/analysis/topology/topological_structures.lean#L343" target="_blank" title="https://github.com/leanprover/mathlib/blob/master/analysis/topology/topological_structures.lean#L343">https://github.com/leanprover/mathlib/blob/master/analysis/topology/topological_structures.lean#L343</a> stating <code>uniformity = comap (λx:α×α, x.2 - x.1) (nhds (0:α))</code>. The key technical ingredient is:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">mem_uniformity_of_uniform_continuous_invarant</span> <span class="o">[</span><span class="n">uniform_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">s</span><span class="o">:</span><span class="n">set</span> <span class="o">(</span><span class="n">α</span><span class="bp">×</span><span class="n">α</span><span class="o">)}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">uniform_continuous</span> <span class="o">(</span><span class="bp">λ</span><span class="n">p</span><span class="o">:</span><span class="n">α</span><span class="bp">×</span><span class="n">α</span><span class="o">,</span> <span class="n">f</span> <span class="n">p</span><span class="bp">.</span><span class="mi">1</span> <span class="n">p</span><span class="bp">.</span><span class="mi">2</span><span class="o">))</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">s</span> <span class="err">∈</span> <span class="o">(</span><span class="bp">@</span><span class="n">uniformity</span> <span class="n">α</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="n">sets</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span><span class="n">u</span><span class="err">∈</span><span class="o">(</span><span class="bp">@</span><span class="n">uniformity</span> <span class="n">α</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="n">sets</span><span class="o">,</span> <span class="bp">∀</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="err">∈</span> <span class="n">u</span> <span class="bp">→</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span> <span class="n">c</span><span class="o">,</span> <span class="n">f</span> <span class="n">b</span> <span class="n">c</span><span class="o">)</span> <span class="err">∈</span> <span class="n">s</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">uniform_continuous</span><span class="o">,</span> <span class="n">uniformity_prod_eq_prod</span><span class="o">,</span> <span class="n">tendsto_map&#39;_iff</span><span class="o">,</span> <span class="o">(</span><span class="err">∘</span><span class="o">)]</span> <span class="n">at</span> <span class="n">hf</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">mem_map_sets_iff</span><span class="bp">.</span><span class="mi">1</span> <span class="o">(</span><span class="n">hf</span> <span class="n">hs</span><span class="o">)</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">t</span><span class="o">,</span> <span class="n">ht</span><span class="o">,</span> <span class="n">hts</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">clear</span> <span class="n">hf</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">mem_prod_iff</span><span class="bp">.</span><span class="mi">1</span> <span class="n">ht</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">u</span><span class="o">,</span> <span class="n">hu</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="n">hv</span><span class="o">,</span> <span class="n">huvt</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">clear</span> <span class="n">ht</span><span class="o">,</span>
  <span class="n">refine</span> <span class="bp">⟨</span><span class="n">u</span><span class="o">,</span> <span class="n">hu</span><span class="o">,</span> <span class="k">assume</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">hab</span><span class="o">,</span> <span class="n">hts</span> <span class="err">$</span> <span class="o">(</span><span class="n">mem_image</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">⟨⟨⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">c</span><span class="bp">⟩⟩</span><span class="o">,</span> <span class="n">huvt</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span> <span class="bp">_⟩⟩</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">hab</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">refl_mem_uniformity</span> <span class="n">hv</span><span class="o">,</span>
  <span class="n">refl</span>
<span class="kn">end</span>
</pre></div>


<p>which secretely says that if <code>f : α → α → α</code> is uniformly continuous then its partial evaluations <code>λ a, f a c</code> are uniformly continuous uniformly in <code>c</code>. The key lemma uses this both for substraction and for addition (whose uniform continuity follows from uniform continuity of substraction). </p>
<p>Both the key technical ingredient and the key technical lemma use members of uniformities <span class="emoji emoji-1f615" title="oh no">:oh_no:</span> I spent some time today trying to get rid of this shameful proof. I managed to get the member-free version of the technical ingredient (also generalized to three different uniform spaces, because why not?):</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">partial_ev_uniformly_uniform_continuous</span> <span class="o">[</span><span class="n">uniform_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">uniform_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">uniform_space</span> <span class="n">γ</span><span class="o">]</span>
<span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">}</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">uniform_continuous</span> <span class="o">(</span><span class="bp">λ</span><span class="n">p</span><span class="o">:</span><span class="n">α</span><span class="bp">×</span><span class="n">β</span><span class="o">,</span> <span class="n">f</span> <span class="n">p</span><span class="bp">.</span><span class="mi">1</span> <span class="n">p</span><span class="bp">.</span><span class="mi">2</span><span class="o">))</span> <span class="o">:</span>
<span class="k">let</span> <span class="n">π_α</span> <span class="o">:</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="bp">×</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">α</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="o">(</span><span class="n">p</span><span class="bp">.</span><span class="mi">1</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span> <span class="n">p</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">1</span><span class="o">),</span>
    <span class="n">π_β</span> <span class="o">:</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="bp">×</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">×</span> <span class="n">β</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="o">(</span><span class="n">p</span><span class="bp">.</span><span class="mi">1</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span> <span class="n">p</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">2</span><span class="o">),</span>
    <span class="n">F</span>   <span class="o">:</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="bp">×</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="bp">→</span> <span class="n">γ</span> <span class="bp">×</span> <span class="n">γ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">p</span><span class="bp">.</span><span class="mi">1</span><span class="bp">.</span><span class="mi">1</span> <span class="n">p</span><span class="bp">.</span><span class="mi">1</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span> <span class="n">f</span> <span class="n">p</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">1</span> <span class="n">p</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span> <span class="k">in</span>
  <span class="n">map</span> <span class="n">F</span> <span class="o">(</span><span class="n">comap</span> <span class="n">π_α</span> <span class="n">uniformity</span> <span class="err">⊓</span> <span class="n">comap</span> <span class="n">π_β</span> <span class="o">(</span><span class="n">principal</span> <span class="n">id_rel</span><span class="o">))</span> <span class="bp">≤</span> <span class="n">uniformity</span> <span class="o">:=</span>
<span class="n">le_trans</span> <span class="o">(</span><span class="n">map_mono</span> <span class="err">$</span> <span class="n">inf_le_inf</span> <span class="o">(</span><span class="n">le_refl</span> <span class="bp">_</span><span class="o">)</span> <span class="err">$</span> <span class="n">comap_mono</span> <span class="n">refl_le_uniformity</span><span class="o">)</span> <span class="o">(</span><span class="n">uniform_continuous₂_iff</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hf</span><span class="o">)</span>
</pre></div>


<p>which starts from the criterion of the above thread, and percolates the fact that, by definition of uniform structures,  <code>principal id_rel ≤ uniformity</code>.</p>
<p>Going from this statement to the technical ingredient is all about unpacking membership for map, inf and <code>principal id_rel</code>:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">mem_partial_ev_uniformly_uniform_continuous</span> <span class="o">[</span><span class="n">uniform_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">uniform_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">uniform_space</span> <span class="n">γ</span><span class="o">]</span>
  <span class="o">{</span><span class="n">s</span><span class="o">:</span><span class="n">set</span> <span class="o">(</span><span class="n">γ</span><span class="bp">×</span><span class="n">γ</span><span class="o">)}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">}</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">uniform_continuous</span> <span class="o">(</span><span class="bp">λ</span><span class="n">p</span><span class="o">:</span><span class="n">α</span><span class="bp">×</span><span class="n">β</span><span class="o">,</span> <span class="n">f</span> <span class="n">p</span><span class="bp">.</span><span class="mi">1</span> <span class="n">p</span><span class="bp">.</span><span class="mi">2</span><span class="o">))</span>
  <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">s</span> <span class="err">∈</span> <span class="o">(</span><span class="bp">@</span><span class="n">uniformity</span> <span class="n">γ</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="n">sets</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">u</span> <span class="err">∈</span> <span class="o">(</span><span class="bp">@</span><span class="n">uniformity</span> <span class="n">α</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="n">sets</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">a&#39;</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">a&#39;</span><span class="o">)</span> <span class="err">∈</span> <span class="n">u</span> <span class="bp">→</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">f</span> <span class="n">a&#39;</span> <span class="n">b</span><span class="o">)</span> <span class="err">∈</span> <span class="n">s</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">have</span> <span class="n">key</span> <span class="o">:=</span> <span class="n">mem_inf_sets</span><span class="bp">.</span><span class="mi">1</span> <span class="o">(</span><span class="n">mem_map</span><span class="bp">.</span><span class="mi">1</span> <span class="err">$</span> <span class="n">partial_ev_uniformly_uniform_continuous</span> <span class="n">hf</span> <span class="n">hs</span><span class="o">),</span>
  <span class="n">rcases</span> <span class="n">key</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">t</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">u</span><span class="o">,</span> <span class="n">hu</span><span class="o">,</span> <span class="n">hut</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">w</span><span class="o">,</span> <span class="n">hw</span><span class="o">,</span> <span class="n">hwv</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">htv</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">use</span> <span class="o">[</span><span class="n">u</span><span class="o">,</span> <span class="n">hu</span><span class="o">],</span>
  <span class="n">intros</span> <span class="n">a</span> <span class="n">a&#39;</span> <span class="n">b</span> <span class="n">haa&#39;</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">mem_principal_sets</span><span class="o">,</span> <span class="n">id_rel_subset</span><span class="o">]</span> <span class="n">at</span> <span class="n">hw</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">),</span> <span class="o">(</span><span class="n">a&#39;</span><span class="o">,</span> <span class="n">b</span><span class="o">))</span> <span class="err">∈</span> <span class="n">t</span> <span class="err">∩</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">split</span> <span class="bp">;</span> <span class="n">tauto</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">htv</span> <span class="n">this</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p>I also rewrote the main lemma in order to do everything directly using substraction, and without juggling with the map and comap adjunction. I also stated explicitly the key steps. The result is:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">uniformity_eq_comap_nhds_zero</span> <span class="o">:</span> <span class="n">uniformity</span> <span class="bp">=</span> <span class="n">comap</span> <span class="o">(</span><span class="bp">λ</span><span class="n">x</span><span class="o">:</span><span class="n">α</span><span class="bp">×</span><span class="n">α</span><span class="o">,</span> <span class="n">x</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">-</span> <span class="n">x</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">nhds</span> <span class="o">(</span><span class="mi">0</span><span class="o">:</span><span class="n">α</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">suffices</span> <span class="o">:</span> <span class="n">uniformity</span> <span class="bp">=</span> <span class="n">comap</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">α</span><span class="o">),</span> <span class="o">((</span><span class="mi">0</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">x</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">-</span> <span class="n">x</span><span class="bp">.</span><span class="mi">1</span><span class="o">))</span> <span class="n">uniformity</span><span class="o">,</span>
  <span class="k">by</span> <span class="n">rwa</span> <span class="o">[</span><span class="n">nhds_eq_comap_uniformity</span><span class="o">,</span> <span class="n">filter</span><span class="bp">.</span><span class="n">comap_comap_comp</span><span class="o">],</span>
  <span class="n">apply</span> <span class="n">le_antisymm</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">s</span> <span class="n">hs</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">mem_comap_sets</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hs</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">u</span><span class="o">,</span> <span class="n">hu</span><span class="o">,</span> <span class="n">hus</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">mem_uniformity_of_uniform_continuous_invarant</span> <span class="n">uniform_continuous_sub&#39;</span> <span class="n">hu</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">t</span><span class="o">,</span> <span class="n">ht</span><span class="o">,</span> <span class="n">hts</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">key</span> <span class="o">:</span> <span class="n">t</span> <span class="err">⊆</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">α</span><span class="o">),</span> <span class="o">((</span><span class="mi">0</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">x</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">-</span> <span class="n">x</span><span class="bp">.</span><span class="mi">1</span><span class="o">))</span> <span class="bp">⁻¹</span><span class="err">&#39;</span> <span class="n">u</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">subset_def</span><span class="o">,</span>
      <span class="n">rintros</span> <span class="bp">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="bp">⟩</span> <span class="n">ab_in</span><span class="o">,</span>
      <span class="n">simpa</span> <span class="kn">using</span> <span class="n">hts</span> <span class="n">a</span> <span class="n">b</span> <span class="n">a</span> <span class="n">ab_in</span><span class="o">,</span> <span class="o">},</span>
    <span class="n">exact</span> <span class="n">mem_sets_of_superset</span> <span class="o">(</span><span class="n">mem_sets_of_superset</span> <span class="n">ht</span> <span class="n">key</span><span class="o">)</span> <span class="n">hus</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">s</span> <span class="n">hs</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">mem_uniformity_of_uniform_continuous_invarant</span> <span class="n">uniform_continuous_sub&#39;</span> <span class="n">hs</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">t</span><span class="o">,</span> <span class="n">ht</span><span class="o">,</span> <span class="n">hts</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">key</span> <span class="o">:</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">α</span><span class="o">),</span> <span class="o">((</span><span class="mi">0</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">x</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">-</span> <span class="n">x</span><span class="bp">.</span><span class="mi">1</span><span class="o">))</span> <span class="bp">⁻¹</span><span class="err">&#39;</span> <span class="n">t</span> <span class="err">⊆</span> <span class="n">s</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">subset_def</span><span class="o">,</span>
      <span class="n">rintros</span> <span class="bp">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="bp">⟩</span> <span class="n">ab_in</span><span class="o">,</span>
      <span class="n">simpa</span> <span class="kn">using</span> <span class="n">hts</span> <span class="mi">0</span> <span class="o">(</span><span class="n">b</span><span class="bp">-</span><span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="bp">-</span><span class="n">a</span><span class="o">)</span> <span class="n">ab_in</span> <span class="o">},</span>
    <span class="n">exact</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="n">ht</span><span class="o">,</span> <span class="n">key</span><span class="bp">⟩</span> <span class="o">}</span>
<span class="kn">end</span>
</pre></div>


<p>But I couldn't get rid of members and use directly the abstract version of the key ingredient. Any idea?</p>


{% endraw %}
