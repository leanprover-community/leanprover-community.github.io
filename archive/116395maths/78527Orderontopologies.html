---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/116395maths/78527Orderontopologies.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html">Order on topologies</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="167570928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167570928" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167570928">Patrick Massot (Jun 07 2019 at 12:15)</a>:</h4>
<p>I already asked this question in the middle of another thread and got no answer, let me try again:</p>
<p>Is the order relation on topological_space and uniform_space open for debate? Currently we have incompatibility with the order on filters, as seen in <a href="https://github.com/leanprover-community/mathlib/blob/master/src/topology/order.lean#L147-L148" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/src/topology/order.lean#L147-L148">https://github.com/leanprover-community/mathlib/blob/master/src/topology/order.lean#L147-L148</a> and <a href="https://github.com/leanprover-community/mathlib/blob/master/src/topology/uniform_space/basic.lean#L472" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/src/topology/uniform_space/basic.lean#L472">https://github.com/leanprover-community/mathlib/blob/master/src/topology/uniform_space/basic.lean#L472</a>, generating things like <a href="https://github.com/leanprover-community/mathlib/blob/master/src/topology/uniform_space/basic.lean#L542" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/src/topology/uniform_space/basic.lean#L542">https://github.com/leanprover-community/mathlib/blob/master/src/topology/uniform_space/basic.lean#L542</a> and generating a push-forward which is right-adjoint to pull-back<br>
 As far as I can see, real world never write <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>≤</mo><msub><mi>t</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">t_1 \leq t_2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.63597em;"></span><span class="strut bottom" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mrel">≤</span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> for topologies <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">t_1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.61508em;"></span><span class="strut bottom" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">t_2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.61508em;"></span><span class="strut bottom" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> but write sentences randomly using either the "finer than" or "coarser than" relation.</p>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> <span class="user-mention" data-user-id="110032">@Reid Barton</span> <span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span></p>

<a name="167571503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167571503" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167571503">Sebastien Gouezel (Jun 07 2019 at 12:23)</a>:</h4>
<p>I would agree to switch the order. I don't have strong opinion either way, but coherence over the different concepts is a valuable goal.</p>

<a name="167571553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167571553" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167571553">Chris Hughes (Jun 07 2019 at 12:24)</a>:</h4>
<p>That's because the order on filters is silly, not the order on topologies.</p>

<a name="167573035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167573035" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167573035">Reid Barton (Jun 07 2019 at 12:45)</a>:</h4>
<p>If you believe the reasonable-looking statement<br>
(*) The identity map <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>X</mi><mo separator="true">,</mo><msub><mi>T</mi><mn>1</mn></msub><mo>)</mo><mo>→</mo><mo>(</mo><mi>X</mi><mo separator="true">,</mo><msub><mi>T</mi><mn>2</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(X, T_1) \to (X, T_2)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mclose">)</span><span class="mrel">→</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mclose">)</span></span></span></span> is continuous iff <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub><mo>≤</mo><msub><mi>T</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">T_1 \le T_2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mrel">≤</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span><br>
then you should use Patrick's order, with the discrete topology at the bottom and the indiscrete topology at the top.</p>

<a name="167573114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167573114" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167573114">Reid Barton (Jun 07 2019 at 12:46)</a>:</h4>
<p>However in algebraic geometry there is an "op" inserted between the morphisms of schemes and the morphisms of their structure sheaves, so perhaps one should not believe (*), I'm not sure.</p>

<a name="167573815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167573815" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167573815">Reid Barton (Jun 07 2019 at 12:56)</a>:</h4>
<p>I wouldn't be against reversing the order of topologies, though it looks like a fair amount of work</p>

<a name="167574022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167574022" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167574022">Patrick Massot (Jun 07 2019 at 12:59)</a>:</h4>
<p>Chris, the order on filters is nice because it makes <code>principal</code> monotone <a href="https://github.com/leanprover-community/mathlib/blob/master/src/order/filter/basic.lean#L358" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/src/order/filter/basic.lean#L358">https://github.com/leanprover-community/mathlib/blob/master/src/order/filter/basic.lean#L358</a> and because it makes push forward left adjoint to pull back, and not the other way around.</p>

<a name="167574220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167574220" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167574220">Reid Barton (Jun 07 2019 at 13:01)</a>:</h4>
<p>What about</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">to_topological_space_mono</span> <span class="o">{</span><span class="n">u₁</span> <span class="n">u₂</span> <span class="o">:</span> <span class="n">uniform_space</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">u₁</span> <span class="bp">≤</span> <span class="n">u₂</span><span class="o">)</span> <span class="o">:</span>
<span class="bp">@</span><span class="n">uniform_space</span><span class="bp">.</span><span class="n">to_topological_space</span> <span class="bp">_</span> <span class="n">u₁</span> <span class="bp">≤</span> <span class="bp">@</span><span class="n">uniform_space</span><span class="bp">.</span><span class="n">to_topological_space</span> <span class="bp">_</span> <span class="n">u₂</span> <span class="o">:=</span>

<span class="kn">lemma</span> <span class="n">uniform_continuous_iff</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">[</span><span class="n">uα</span> <span class="o">:</span> <span class="n">uniform_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">uβ</span> <span class="o">:</span> <span class="n">uniform_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
<span class="n">uniform_continuous</span> <span class="n">f</span> <span class="bp">↔</span> <span class="n">uβ</span><span class="bp">.</span><span class="n">comap</span> <span class="n">f</span> <span class="bp">≤</span> <span class="n">uα</span> <span class="o">:=</span>
</pre></div>

<a name="167574389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167574389" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167574389">Patrick Massot (Jun 07 2019 at 13:03)</a>:</h4>
<p>The first lemma means you can't change the order on topologies without changing the order on uniform structures.</p>

<a name="167574395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167574395" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167574395">Reid Barton (Jun 07 2019 at 13:03)</a>:</h4>
<p>Or wait, were you going to reverse the order on <code>uniform_space</code> too?</p>

<a name="167574408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167574408" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167574408">Reid Barton (Jun 07 2019 at 13:03)</a>:</h4>
<p>Okay, I missed that <span aria-label="+1" class="emoji emoji-1f44d" role="img" title="+1">:+1:</span></p>

<a name="167574413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167574413" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167574413">Patrick Massot (Jun 07 2019 at 13:03)</a>:</h4>
<p>Yes, see the first message</p>

<a name="167574521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167574521" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167574521">Patrick Massot (Jun 07 2019 at 13:04)</a>:</h4>
<p>The second lemma means the order on uniform spaces currently doesn't play nicely with the order on filters</p>

<a name="167575692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167575692" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167575692">Patrick Massot (Jun 07 2019 at 13:20)</a>:</h4>
<blockquote>
<p>Chris, the order on filters is nice because it makes <code>principal</code> monotone <a href="https://github.com/leanprover-community/mathlib/blob/master/src/order/filter/basic.lean#L358" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/src/order/filter/basic.lean#L358">https://github.com/leanprover-community/mathlib/blob/master/src/order/filter/basic.lean#L358</a> and because it makes push forward left adjoint to pull back, and not the other way around.</p>
</blockquote>
<p>I guess this is only one argument. I like push-forward to be the left adjoint because this is what happens for functions acting on subsets. But of course sheaves are the other way around.</p>

<a name="167576054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167576054" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167576054">Kevin Buzzard (Jun 07 2019 at 13:25)</a>:</h4>
<p>This is sort of like saying "wouldn't it be great if all -1's were +1's?". It's not so clear that there's a perfect answer here. I guess I mean that it is clear that there is not a perfect answer here.</p>

<a name="167576133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167576133" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167576133">Patrick Massot (Jun 07 2019 at 13:26)</a>:</h4>
<p>We don't want a perfect answer here. We want something consistent across filters, topology and uniform structures</p>

<a name="167576146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167576146" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167576146">Patrick Massot (Jun 07 2019 at 13:26)</a>:</h4>
<p>Currently it is not consistent in mathlib</p>

<a name="167576199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167576199" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167576199">Patrick Massot (Jun 07 2019 at 13:27)</a>:</h4>
<p>And if we add the constraint that <code>principal</code> is monotone then we get that the correct order is the one we currently have on filters (unless we want to reverse the orderings on subsets...)</p>

<a name="167576204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167576204" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167576204">Kevin Buzzard (Jun 07 2019 at 13:27)</a>:</h4>
<p>Is it <em>possible</em> for everything to be consistent? Or are you just focussed on some small subset of inconsistent things, and if you change to make it consistent that then some other small subset will be inconsistent?</p>

<a name="167576231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167576231" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167576231">Patrick Massot (Jun 07 2019 at 13:27)</a>:</h4>
<p>What would be a bigger set here?</p>

<a name="167576336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167576336" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167576336">Chris Hughes (Jun 07 2019 at 13:29)</a>:</h4>
<p><code>filter.sets</code> isn't monotone.</p>

<a name="167577532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167577532" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167577532">Patrick Massot (Jun 07 2019 at 13:45)</a>:</h4>
<p>Who cares? The goal of the theory is to hide this function as much as possible</p>

<a name="167582788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167582788" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167582788">Reid Barton (Jun 07 2019 at 14:43)</a>:</h4>
<p>We can't make everything consistent, but it doesn't mean that every possible convention is equally good</p>

<a name="167584317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167584317" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167584317">Patrick Massot (Jun 07 2019 at 15:00)</a>:</h4>
<p>What should we do then?</p>

<a name="167584618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167584618" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167584618">Reid Barton (Jun 07 2019 at 15:04)</a>:</h4>
<p>I'm happy with the change you suggested--as long as I don't have to be the one to implement it</p>

<a name="167787562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167787562" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167787562">Patrick Massot (Jun 10 2019 at 19:15)</a>:</h4>
<p>I just discovered a flaw in this plan: <a href="https://github.com/leanprover-community/mathlib/blob/master/src/topology/order.lean#L110-L111" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/src/topology/order.lean#L110-L111">https://github.com/leanprover-community/mathlib/blob/master/src/topology/order.lean#L110-L111</a></p>

<a name="167787639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167787639" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167787639">Patrick Massot (Jun 10 2019 at 19:16)</a>:</h4>
<p>I'm afraid the Galois insertion involving the topology generated by a collection of subset is the motivation behind the weird order on topologies</p>

<a name="167788092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167788092" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167788092">Johan Commelin (Jun 10 2019 at 19:22)</a>:</h4>
<p>I suppose you could use <code>order_dual</code> and <code>copy</code>, if you really want...</p>

<a name="167788118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167788118" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167788118">Patrick Massot (Jun 10 2019 at 19:22)</a>:</h4>
<p>Maybe we should do antitone Galois connections as well</p>

<a name="167788147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167788147" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167788147">Patrick Massot (Jun 10 2019 at 19:23)</a>:</h4>
<p>At some point we'll have to face the fact that fundamental theorem of Galois theory is not a Galois connection, as currently defined in mathlib</p>

<a name="167788612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167788612" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167788612">Kevin Buzzard (Jun 10 2019 at 19:28)</a>:</h4>
<blockquote>
<p>At some point we'll have to face the fact that fundamental theorem of Galois theory is not a Galois connection, as currently defined in mathlib</p>
</blockquote>
<p>it's OK, we can just define the order on subgroups to be <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mo>≤</mo><mi>K</mi><mspace width="0.277778em"></mspace><mo>⟺</mo><mspace width="0.277778em"></mspace><mi>K</mi><mo>⊆</mo><mi>H</mi></mrow><annotation encoding="application/x-tex">H\leq K\iff K\subseteq H</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.08125em;">H</span><span class="mrel">≤</span><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="mrel"><span class="mspace thickspace"></span><span class="mrel">⟺</span></span><span class="mord mathit"><span class="mspace thickspace"></span><span class="mord mathit" style="margin-right:0.07153em;">K</span></span><span class="mrel">⊆</span><span class="mord mathit" style="margin-right:0.08125em;">H</span></span></span></span></p>

<a name="167788647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167788647" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167788647">Kevin Buzzard (Jun 10 2019 at 19:29)</a>:</h4>
<p>Probably that's what the order is in mathlib anyway :P</p>

<a name="167789433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167789433" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167789433">Kevin Buzzard (Jun 10 2019 at 19:39)</a>:</h4>
<p>But don't do it on the subfields as well ;-)</p>

<a name="168055681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/168055681" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#168055681">Patrick Massot (Jun 13 2019 at 15:28)</a>:</h4>
<p>I tried using <code>order_dual</code> to change the partial order on topologies but still have a Galois insertion, so that I can list the complete lattice instance from <code>set (set a)</code>.  But then of course the <code>has_top</code> instance is still the wrong one. Is this the issue the <code>copy</code> is meant to solve? I don't understand at all this copy thing in <code>order.fiilter.basic</code>. The beginning of the story looks like:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">topology</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">open</span> <span class="n">set</span> <span class="n">filter</span> <span class="n">lattice</span> <span class="n">classical</span>
<span class="n">local</span> <span class="n">attribute</span> <span class="o">[</span><span class="kn">instance</span><span class="o">]</span> <span class="n">prop_decidable</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span>

<span class="kn">namespace</span> <span class="n">topological_space</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>

<span class="c">/-</span><span class="cm">- The least topology containing a collection of basic sets. -/</span>
<span class="kn">inductive</span> <span class="n">generate_open</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">))</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">basic</span>  <span class="o">:</span> <span class="bp">∀</span><span class="n">s</span><span class="err">∈</span><span class="n">g</span><span class="o">,</span> <span class="n">generate_open</span> <span class="n">s</span>
<span class="bp">|</span> <span class="n">univ</span>   <span class="o">:</span> <span class="n">generate_open</span> <span class="n">univ</span>
<span class="bp">|</span> <span class="n">inter</span>  <span class="o">:</span> <span class="bp">∀</span><span class="n">s</span> <span class="n">t</span><span class="o">,</span> <span class="n">generate_open</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">generate_open</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">generate_open</span> <span class="o">(</span><span class="n">s</span> <span class="err">∩</span> <span class="n">t</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">sUnion</span> <span class="o">:</span> <span class="bp">∀</span><span class="n">k</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span><span class="n">s</span><span class="err">∈</span><span class="n">k</span><span class="o">,</span> <span class="n">generate_open</span> <span class="n">s</span><span class="o">)</span> <span class="bp">→</span> <span class="n">generate_open</span> <span class="o">(</span><span class="err">⋃₀</span> <span class="n">k</span><span class="o">)</span>

<span class="c">/-</span><span class="cm">- The smallest topological space containing the collection `g` of basic sets -/</span>
<span class="n">def</span> <span class="n">generate_from</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">))</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">is_open</span>        <span class="o">:=</span> <span class="n">generate_open</span> <span class="n">g</span><span class="o">,</span>
  <span class="n">is_open_univ</span>   <span class="o">:=</span> <span class="n">generate_open</span><span class="bp">.</span><span class="n">univ</span> <span class="n">g</span><span class="o">,</span>
  <span class="n">is_open_inter</span>  <span class="o">:=</span> <span class="n">generate_open</span><span class="bp">.</span><span class="n">inter</span><span class="o">,</span>
  <span class="n">is_open_sUnion</span> <span class="o">:=</span> <span class="n">generate_open</span><span class="bp">.</span><span class="n">sUnion</span>  <span class="o">}</span>

<span class="kn">end</span> <span class="n">topological_space</span>

<span class="kn">section</span> <span class="n">lattice</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">partial_order</span> <span class="o">(</span><span class="n">topological_space</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">le</span>          <span class="o">:=</span> <span class="bp">λ</span> <span class="n">t</span> <span class="n">s</span><span class="o">,</span> <span class="n">s</span><span class="bp">.</span><span class="n">is_open</span> <span class="bp">≤</span> <span class="n">t</span><span class="bp">.</span><span class="n">is_open</span><span class="o">,</span>
  <span class="n">le_antisymm</span> <span class="o">:=</span> <span class="k">assume</span> <span class="n">t</span> <span class="n">s</span> <span class="n">h₁</span> <span class="n">h₂</span><span class="o">,</span> <span class="n">topological_space_eq</span> <span class="err">$</span> <span class="n">le_antisymm</span> <span class="n">h₂</span> <span class="n">h₁</span><span class="o">,</span>
  <span class="n">le_refl</span>     <span class="o">:=</span> <span class="k">assume</span> <span class="n">t</span><span class="o">,</span> <span class="n">le_refl</span> <span class="n">t</span><span class="bp">.</span><span class="n">is_open</span><span class="o">,</span>
  <span class="n">le_trans</span>    <span class="o">:=</span> <span class="k">assume</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">h₁</span> <span class="n">h₂</span><span class="o">,</span> <span class="n">le_trans</span> <span class="n">h₂</span> <span class="n">h₁</span> <span class="o">}</span>

<span class="kn">lemma</span> <span class="n">le_generate_from_iff_subset_is_open</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)}</span> <span class="o">{</span><span class="n">t</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">t</span> <span class="bp">≤</span> <span class="n">topological_space</span><span class="bp">.</span><span class="n">generate_from</span> <span class="n">g</span> <span class="bp">↔</span> <span class="n">g</span> <span class="err">⊆</span> <span class="o">{</span><span class="n">s</span> <span class="bp">|</span> <span class="n">t</span><span class="bp">.</span><span class="n">is_open</span> <span class="n">s</span><span class="o">}</span> <span class="o">:=</span>
<span class="n">iff</span><span class="bp">.</span><span class="n">intro</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">ht</span> <span class="n">s</span> <span class="n">hs</span><span class="o">,</span> <span class="n">ht</span> <span class="bp">_</span> <span class="err">$</span> <span class="n">topological_space</span><span class="bp">.</span><span class="n">generate_open</span><span class="bp">.</span><span class="n">basic</span> <span class="n">s</span> <span class="n">hs</span><span class="o">)</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">hg</span> <span class="n">s</span> <span class="n">hs</span><span class="o">,</span> <span class="n">hs</span><span class="bp">.</span><span class="n">rec_on</span> <span class="o">(</span><span class="k">assume</span> <span class="n">v</span> <span class="n">hv</span><span class="o">,</span> <span class="n">hg</span> <span class="n">hv</span><span class="o">)</span>
    <span class="n">t</span><span class="bp">.</span><span class="n">is_open_univ</span> <span class="o">(</span><span class="k">assume</span> <span class="n">u</span> <span class="n">v</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">t</span><span class="bp">.</span><span class="n">is_open_inter</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="k">assume</span> <span class="n">k</span> <span class="bp">_</span><span class="o">,</span> <span class="n">t</span><span class="bp">.</span><span class="n">is_open_sUnion</span> <span class="n">k</span><span class="o">))</span>

<span class="kn">protected</span> <span class="n">def</span> <span class="n">mk_of_closure</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">))</span>
  <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="o">{</span><span class="n">u</span> <span class="bp">|</span> <span class="o">(</span><span class="n">topological_space</span><span class="bp">.</span><span class="n">generate_from</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">is_open</span> <span class="n">u</span><span class="o">}</span> <span class="bp">=</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">is_open</span>        <span class="o">:=</span> <span class="bp">λ</span><span class="n">u</span><span class="o">,</span> <span class="n">u</span> <span class="err">∈</span> <span class="n">s</span><span class="o">,</span>
  <span class="n">is_open_univ</span>   <span class="o">:=</span> <span class="n">hs</span> <span class="bp">▸</span> <span class="n">topological_space</span><span class="bp">.</span><span class="n">generate_open</span><span class="bp">.</span><span class="n">univ</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">is_open_inter</span>  <span class="o">:=</span> <span class="n">hs</span> <span class="bp">▸</span> <span class="n">topological_space</span><span class="bp">.</span><span class="n">generate_open</span><span class="bp">.</span><span class="n">inter</span><span class="o">,</span>
  <span class="n">is_open_sUnion</span> <span class="o">:=</span> <span class="n">hs</span> <span class="bp">▸</span> <span class="n">topological_space</span><span class="bp">.</span><span class="n">generate_open</span><span class="bp">.</span><span class="n">sUnion</span> <span class="o">}</span>

<span class="kn">lemma</span> <span class="n">mk_of_closure_sets</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)}</span>
  <span class="o">{</span><span class="n">hs</span> <span class="o">:</span> <span class="o">{</span><span class="n">u</span> <span class="bp">|</span> <span class="o">(</span><span class="n">topological_space</span><span class="bp">.</span><span class="n">generate_from</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">is_open</span> <span class="n">u</span><span class="o">}</span> <span class="bp">=</span> <span class="n">s</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">mk_of_closure</span> <span class="n">s</span> <span class="n">hs</span> <span class="bp">=</span> <span class="n">topological_space</span><span class="bp">.</span><span class="n">generate_from</span> <span class="n">s</span> <span class="o">:=</span>
<span class="n">topological_space_eq</span> <span class="n">hs</span><span class="bp">.</span><span class="n">symm</span>

<span class="n">def</span> <span class="n">gi_generate_from</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">@</span><span class="n">galois_insertion</span> <span class="bp">_</span> <span class="o">(</span><span class="n">order_dual</span> <span class="err">$</span> <span class="n">topological_space</span> <span class="n">α</span><span class="o">)</span> <span class="bp">_</span> <span class="bp">_</span>
    <span class="n">topological_space</span><span class="bp">.</span><span class="n">generate_from</span> <span class="o">(</span><span class="bp">λ</span><span class="n">t</span><span class="o">:</span><span class="n">topological_space</span> <span class="n">α</span><span class="o">,</span> <span class="o">{</span><span class="n">s</span> <span class="bp">|</span> <span class="n">t</span><span class="bp">.</span><span class="n">is_open</span> <span class="n">s</span><span class="o">}):=</span>
<span class="o">{</span> <span class="n">gc</span>        <span class="o">:=</span> <span class="k">assume</span> <span class="n">t</span> <span class="n">g</span><span class="o">,</span> <span class="n">le_generate_from_iff_subset_is_open</span><span class="o">,</span>
  <span class="n">le_l_u</span>    <span class="o">:=</span> <span class="k">assume</span> <span class="n">t</span> <span class="n">s</span> <span class="n">hs</span><span class="o">,</span> <span class="n">topological_space</span><span class="bp">.</span><span class="n">generate_open</span><span class="bp">.</span><span class="n">basic</span> <span class="n">s</span> <span class="n">hs</span><span class="o">,</span>
  <span class="n">choice</span>    <span class="o">:=</span> <span class="bp">λ</span><span class="n">g</span> <span class="n">hg</span><span class="o">,</span> <span class="n">mk_of_closure</span> <span class="n">g</span>
    <span class="o">(</span><span class="n">subset</span><span class="bp">.</span><span class="n">antisymm</span> <span class="n">hg</span> <span class="err">$</span>  <span class="n">le_generate_from_iff_subset_is_open</span><span class="bp">.</span><span class="mi">1</span> <span class="err">$</span> <span class="n">le_refl</span> <span class="bp">_</span><span class="o">),</span>
  <span class="n">choice_eq</span> <span class="o">:=</span> <span class="k">assume</span> <span class="n">s</span> <span class="n">hs</span><span class="o">,</span> <span class="n">mk_of_closure_sets</span> <span class="o">}</span>

<span class="kn">instance</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">:</span> <span class="n">complete_lattice</span> <span class="o">(</span><span class="n">topological_space</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">gi_generate_from</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">lift_complete_lattice</span>
</pre></div>


<p>This is accepted by Lean, but then I still have the discrete topology at top. I'm sorry this conversation is very sparse, but I'm at a conference, with very little Lean time.</p>

<a name="168055999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/168055999" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#168055999">Johan Commelin (Jun 13 2019 at 15:31)</a>:</h4>
<p>Maybe the definition of the lattice structure on <code>opens X</code> helps? It uses Galois insertions, dual, and copy.</p>

<a name="168056422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/168056422" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#168056422">Patrick Massot (Jun 13 2019 at 15:35)</a>:</h4>
<p>Did you write that?</p>

<a name="168056428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/168056428" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#168056428">Patrick Massot (Jun 13 2019 at 15:35)</a>:</h4>
<p>Do you understand what's going on?</p>

<a name="168056546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/168056546" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#168056546">Patrick Massot (Jun 13 2019 at 15:36)</a>:</h4>
<p>I don't understand why it seems to involve additional proofs in <code>copy</code> on top of the Galois insertion. How can there be any mathematical content?</p>

<a name="168056555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/168056555" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#168056555">Patrick Massot (Jun 13 2019 at 15:36)</a>:</h4>
<p>I only want to reverse the order</p>

<a name="168057911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/168057911" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#168057911">Mario Carneiro (Jun 13 2019 at 15:51)</a>:</h4>
<p>I think the galois insertion should be between <code>(topological_space α)</code> and <code>(order_dual $ set α)</code>, not <code>(order_dual $ topological_space α)</code> and <code>(set α)</code></p>

<a name="168067490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/168067490" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#168067490">Johan Commelin (Jun 13 2019 at 17:41)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> I wrote it with help of Johannes. I think <code>copy</code> allows you to redefine the data parts of the structure, for better defeqs. But then you get proof obligations that the data is provably equal to what you get out of the duality. (That's what my memory tells me.) Maybe <span class="user-mention" data-user-id="110294">@Johannes Hölzl</span> can enlighten us.</p>

<a name="168078138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/168078138" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#168078138">Patrick Massot (Jun 13 2019 at 19:35)</a>:</h4>
<blockquote>
<p>I think the galois insertion should be between <code>(topological_space α)</code> and <code>(order_dual $ set α)</code>, not <code>(order_dual $ topological_space α)</code> and <code>(set α)</code></p>
</blockquote>
<p>Isn't this ruining the <code>le_l_u</code> axiom of Galois insertions?</p>

<a name="168078313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/168078313" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#168078313">Patrick Massot (Jun 13 2019 at 19:37)</a>:</h4>
<p>This is really weird, it looks like, starting from a Galois insertion, if you switch order on both sides you don't get a Galois insertion in the other direction</p>

<a name="168078321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/168078321" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#168078321">Patrick Massot (Jun 13 2019 at 19:37)</a>:</h4>
<p>I must have messed up something</p>

<a name="168078582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/168078582" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#168078582">Reid Barton (Jun 13 2019 at 19:40)</a>:</h4>
<blockquote>
<p>This is really weird, it looks like, starting from a Galois insertion, if you switch order on both sides you don't get a Galois insertion in the other direction</p>
</blockquote>
<p>I haven't been following today's discussion but this is indeed not the case</p>

<a name="168078610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/168078610" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#168078610">Reid Barton (Jun 13 2019 at 19:40)</a>:</h4>
<p>You get a Galois coinsertion (if that's a real word) instead</p>

<a name="168078659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/168078659" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#168078659">Patrick Massot (Jun 13 2019 at 19:41)</a>:</h4>
<p>Yes, it looks like a coinsertion</p>

<a name="168078689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/168078689" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#168078689">Patrick Massot (Jun 13 2019 at 19:41)</a>:</h4>
<p>You get <code>u l = id</code> instead of <code>l u = id</code></p>

<a name="168078749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/168078749" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#168078749">Patrick Massot (Jun 13 2019 at 19:42)</a>:</h4>
<p>But it should be enough to lift complete lattice instances</p>

<a name="168078755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/168078755" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#168078755">Reid Barton (Jun 13 2019 at 19:42)</a>:</h4>
<p>Yes</p>

<a name="168078772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/168078772" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#168078772">Patrick Massot (Jun 13 2019 at 19:42)</a>:</h4>
<p>This is all so silly. I simply want to reverse my partial order which is already known to be a complete lattice.</p>

<a name="168078786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/168078786" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#168078786">Kevin Buzzard (Jun 13 2019 at 19:43)</a>:</h4>
<p>You could use the fact that the dual is a Galois nnection.</p>

<a name="168078812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/168078812" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#168078812">Patrick Massot (Jun 13 2019 at 19:43)</a>:</h4>
<p>Maybe I should keep the current Galois insertion as a local instance and then use <code>order_dual.complete_lattice</code> or something</p>

<a name="168079905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/168079905" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#168079905">Patrick Massot (Jun 13 2019 at 19:56)</a>:</h4>
<p>import topology.basic</p>
<p>open set filter lattice <br>
universes u v w</p>
<p>namespace topological_space<br>
variables {α : Type u}</p>
<p>/-- The least topology containing a collection of basic sets. -/<br>
inductive generate_open (g : set (set α)) : set α → Prop<br>
| basic  : ∀s∈g, generate_open s<br>
| univ   : generate_open univ<br>
| inter  : ∀s t, generate_open s → generate_open t → generate_open (s ∩ t)<br>
| sUnion : ∀k, (∀s∈k, generate_open s) → generate_open (⋃₀ k)</p>
<p>/-- The smallest topological space containing the collection <code>g</code> of basic sets -/<br>
def generate_from (g : set (set α)) : topological_space α :=<br>
{ is_open        := generate_open g,<br>
  is_open_univ   := generate_open.univ g,<br>
  is_open_inter  := generate_open.inter,<br>
  is_open_sUnion := generate_open.sUnion  }</p>
<p>section lattice</p>
<p>def old_order : partial_order (topological_space α) :=<br>
{ le          := λt s, t.is_open ≤ s.is_open,<br>
  le_antisymm := assume t s h₁ h₂, topological_space_eq $ le_antisymm h₁ h₂,<br>
  le_refl     := assume t, le_refl t.is_open,<br>
  le_trans    := assume a b c h₁ h₂, @le_trans _ _ a.is_open b.is_open c.is_open h₁ h₂ }</p>
<p>local attribute [instance] old_order</p>
<p>lemma generate_from_le_iff_subset_is_open {g : set (set α)} {t : topological_space α} :<br>
  topological_space.generate_from g ≤ t ↔ g ⊆ {s | t.is_open s} :=<br>
iff.intro<br>
  (assume ht s hs, ht _ $ topological_space.generate_open.basic s hs)<br>
  (assume hg s hs, hs.rec_on (assume v hv, hg hv)<br>
    t.is_open_univ (assume u v _ _, t.is_open_inter u v) (assume k _, t.is_open_sUnion k))</p>
<p>protected def mk_of_closure (s : set (set α))<br>
  (hs : {u | (topological_space.generate_from s).is_open u} = s) : topological_space α :=<br>
{ is_open        := λu, u ∈ s,<br>
  is_open_univ   := hs ▸ topological_space.generate_open.univ _,<br>
  is_open_inter  := hs ▸ topological_space.generate_open.inter,<br>
  is_open_sUnion := hs ▸ topological_space.generate_open.sUnion }</p>
<p>lemma mk_of_closure_sets {s : set (set α)}<br>
  {hs : {u | (topological_space.generate_from s).is_open u} = s} :<br>
  topological_space.mk_of_closure s hs = topological_space.generate_from s :=<br>
topological_space_eq hs.symm</p>
<p>def gi_generate_from (α : Type*) :<br>
  galois_insertion topological_space.generate_from (λt:topological_space α, {s | t.is_open s}) :=<br>
{ gc        := assume g t, generate_from_le_iff_subset_is_open,<br>
  le_l_u    := assume ts s hs, topological_space.generate_open.basic s hs,<br>
  choice    := λg hg, topological_space.mk_of_closure g<br>
    (subset.antisymm hg $ generate_from_le_iff_subset_is_open.1 $ le_refl _),<br>
  choice_eq := assume s hs, mk_of_closure_sets }</p>
<p>lemma generate_from_mono {α} {g₁ g₂ : set (set α)} (h : g₁ ⊆ g₂) :<br>
  topological_space.generate_from g₁ ≤ topological_space.generate_from g₂ :=<br>
(gi_generate_from _).gc.monotone_l h</p>
<p>def old_complete_lattice {α : Type u} : complete_lattice (topological_space α) :=<br>
(gi_generate_from α).lift_complete_lattice<br>
end lattice</p>
<p>instance : partial_order (topological_space α) :=<br>
{ le          := λ t s, s.is_open ≤ t.is_open,<br>
  le_antisymm := assume t s h₁ h₂, topological_space_eq $ le_antisymm h₂ h₁,<br>
  le_refl     := assume t, le_refl t.is_open,<br>
  le_trans    := assume a b c h₁ h₂, le_trans h₂ h₁ }</p>
<p>instance : complete_lattice (topological_space α) :=<br>
@order_dual.lattice.complete_lattice _ old_complete_lattice<br>
end topological_space</p>
<p>class discrete_topology (α : Type*) [t : topological_space α] : Prop :=<br>
(eq_top : t = ⊥)</p>
<p>@[simp] lemma is_open_discrete {α : Type*} [topological_space α] [discrete_topology α] (s : set α) :<br>
  is_open s :=<br>
(discrete_topology.eq_top α).symm ▸ trivial</p>
<div class="codehilite"><pre><span></span>
</pre></div>

<a name="168080086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/168080086" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#168080086">Reid Barton (Jun 13 2019 at 20:01)</a>:</h4>
<p>Patrick did you crash zulip</p>

<a name="168134728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/168134728" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#168134728">Patrick Massot (Jun 14 2019 at 13:28)</a>:</h4>
<blockquote>
<p>Patrick did you crash zulip</p>
</blockquote>
<p>Indeed Zulip crashed while I was editing my message. And then talks resumed, and discussions, and dinner and wasn't able to return to here before bed. Anyway, I wanted to say that the code above seems to work.</p>

<a name="168380292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/168380292" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#168380292">Patrick Massot (Jun 18 2019 at 08:35)</a>:</h4>
<p>Done in <a href="https://github.com/leanprover-community/mathlib/pull/1138" target="_blank" title="https://github.com/leanprover-community/mathlib/pull/1138">https://github.com/leanprover-community/mathlib/pull/1138</a></p>


{% endraw %}
