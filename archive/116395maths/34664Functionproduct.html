---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/116395maths/34664Functionproduct.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/34664Functionproduct.html">Function product</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="168969326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Function%20product/near/168969326" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/34664Functionproduct.html#168969326">Sebastien Gouezel (Jun 25 2019 at 19:30)</a>:</h4>
<p>I can't find the name of the direct product of two functions. Is it defined somewhere in mathlib?</p>

<a name="168969476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Function%20product/near/168969476" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/34664Functionproduct.html#168969476">Kenny Lau (Jun 25 2019 at 19:32)</a>:</h4>
<p>what does that mean?</p>

<a name="168969680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Function%20product/near/168969680" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/34664Functionproduct.html#168969680">Johan Commelin (Jun 25 2019 at 19:34)</a>:</h4>
<p>I guess: given <code>f : X1 → X2</code> and <code>g : Y1 → Y2</code> you form <code>(f,g) : X1 × Y1 → X2 × Y2</code>.</p>

<a name="168969860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Function%20product/near/168969860" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/34664Functionproduct.html#168969860">Kenny Lau (Jun 25 2019 at 19:37)</a>:</h4>
<p>the category theorist comes</p>

<a name="168969878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Function%20product/near/168969878" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/34664Functionproduct.html#168969878">Kenny Lau (Jun 25 2019 at 19:37)</a>:</h4>
<p>anyway in that case it's probably shortest just to define it manually</p>

<a name="168970014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Function%20product/near/168970014" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/34664Functionproduct.html#168970014">Sebastien Gouezel (Jun 25 2019 at 19:39)</a>:</h4>
<p>Yes, sorry, that's what I mean. And no, I am definitely not a category theorist :) Of course it can be defined by hand as a lambda, but there are potentially many useful simp lemmas about ranges, preimages and so on for this kind of objects. And it shows up often. So I was gessing it should have a name somewhere in mathlib. Otherwise, I will just use the plain lambda.</p>

<a name="168970522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Function%20product/near/168970522" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/34664Functionproduct.html#168970522">Johan Commelin (Jun 25 2019 at 19:45)</a>:</h4>
<p>I guess that initially products where avoided as much as possible...</p>

<a name="168970567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Function%20product/near/168970567" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/34664Functionproduct.html#168970567">Johan Commelin (Jun 25 2019 at 19:46)</a>:</h4>
<p>But Patrick has recently also been needing them.</p>

<a name="168970579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Function%20product/near/168970579" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/34664Functionproduct.html#168970579">Johan Commelin (Jun 25 2019 at 19:46)</a>:</h4>
<p>So I guess that the API is lacking a bit, but that there might be good reason to develop it.</p>

<a name="168970604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Function%20product/near/168970604" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/34664Functionproduct.html#168970604">Johan Commelin (Jun 25 2019 at 19:46)</a>:</h4>
<p>I'm not saying you should do that. It might be a nice project for a beginner. Maybe we should file it in a github issue.</p>

<a name="168974173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Function%20product/near/168974173" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/34664Functionproduct.html#168974173">Patrick Massot (Jun 25 2019 at 20:28)</a>:</h4>
<p>The variant I needed was <code>prod.mk</code> which is already in core (but with the wrong definition).</p>

<a name="168988833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Function%20product/near/168988833" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/34664Functionproduct.html#168988833">Alistair Tucker (Jun 26 2019 at 00:01)</a>:</h4>
<p>prod.map?<br>
<a href="https://github.com/leanprover/lean/blob/ceacfa7445953cbc8860ddabc55407430a9ca5c3/library/init/data/prod.lean#L45" target="_blank" title="https://github.com/leanprover/lean/blob/ceacfa7445953cbc8860ddabc55407430a9ca5c3/library/init/data/prod.lean#L45">https://github.com/leanprover/lean/blob/ceacfa7445953cbc8860ddabc55407430a9ca5c3/library/init/data/prod.lean#L45</a><br>
<a href="https://github.com/leanprover-community/mathlib/blob/60efaec1b2bae0b6ff22ebd889f26606c8648924/src/data/prod.lean#L19" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/60efaec1b2bae0b6ff22ebd889f26606c8648924/src/data/prod.lean#L19">https://github.com/leanprover-community/mathlib/blob/60efaec1b2bae0b6ff22ebd889f26606c8648924/src/data/prod.lean#L19</a></p>

<a name="169003379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Function%20product/near/169003379" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/34664Functionproduct.html#169003379">Sebastien Gouezel (Jun 26 2019 at 06:21)</a>:</h4>
<p>Thanks!</p>

<a name="169004449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Function%20product/near/169004449" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/34664Functionproduct.html#169004449">Sebastien Gouezel (Jun 26 2019 at 06:48)</a>:</h4>
<p>Except that the definition is bad as <code>prod.map f g p</code> is not defeq to <code>(f (p.fst), g (p.snd))</code>. Indeed, it is defined as</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="o">{</span><span class="n">u₁</span> <span class="n">u₂</span> <span class="n">v₁</span> <span class="n">v₂</span><span class="o">}</span> <span class="n">prod</span><span class="bp">.</span><span class="n">map</span> <span class="o">{</span><span class="n">α₁</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₁</span><span class="o">}</span> <span class="o">{</span><span class="n">α₂</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₂</span><span class="o">}</span> <span class="o">{</span><span class="n">β₁</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v₁</span><span class="o">}</span> <span class="o">{</span><span class="n">β₂</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v₂</span><span class="o">}</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α₁</span> <span class="bp">→</span> <span class="n">α₂</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">β₁</span> <span class="bp">→</span> <span class="n">β₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">α₁</span> <span class="bp">×</span> <span class="n">β₁</span> <span class="bp">→</span> <span class="n">α₂</span> <span class="bp">×</span> <span class="n">β₂</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">,</span> <span class="n">g</span> <span class="n">b</span><span class="o">)</span>
</pre></div>


<p>which unfolds to something in terms of <code>prod.cases_on</code>. And it is in core...</p>

<a name="169007477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Function%20product/near/169007477" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/34664Functionproduct.html#169007477">Alistair Tucker (Jun 26 2019 at 07:52)</a>:</h4>
<p>I'm not sure what defeq means, but I remember that before I could use actually prod.map I had to write map_def:<br>
<a href="https://github.com/leanprover-community/mathlib/blob/60efaec1b2bae0b6ff22ebd889f26606c8648924/src/data/prod.lean#L36" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/60efaec1b2bae0b6ff22ebd889f26606c8648924/src/data/prod.lean#L36">https://github.com/leanprover-community/mathlib/blob/60efaec1b2bae0b6ff22ebd889f26606c8648924/src/data/prod.lean#L36</a></p>

<a name="169008897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Function%20product/near/169008897" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/34664Functionproduct.html#169008897">Kenny Lau (Jun 26 2019 at 08:19)</a>:</h4>
<p>just PR core :P</p>

<a name="169011700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Function%20product/near/169011700" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/34664Functionproduct.html#169011700">Sebastien Gouezel (Jun 26 2019 at 09:07)</a>:</h4>
<p>Yes, that's the way it should be defined. Otherwise, it makes things pointlessly painful. For my use case, direct definition with lambda turns out to be better because of this problem in the definition.</p>

<a name="169011763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Function%20product/near/169011763" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/34664Functionproduct.html#169011763">Patrick Massot (Jun 26 2019 at 09:08)</a>:</h4>
<p>The file I have in front of me starts with</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">prod</span><span class="bp">.</span><span class="n">map&#39;</span> <span class="o">{</span><span class="n">α₁</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">α₂</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β₁</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β₂</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α₁</span> <span class="bp">→</span> <span class="n">α₂</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">β₁</span> <span class="bp">→</span> <span class="n">β₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">α₁</span> <span class="bp">×</span> <span class="n">β₁</span> <span class="bp">→</span> <span class="n">α₂</span> <span class="bp">×</span> <span class="n">β₂</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">p</span> <span class="o">:</span> <span class="n">α₁</span> <span class="bp">×</span> <span class="n">β₁</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">f</span> <span class="n">p</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span> <span class="n">g</span> <span class="n">p</span><span class="bp">.</span><span class="mi">2</span><span class="bp">⟩</span>

<span class="n">local</span> <span class="kn">infix</span> <span class="bp">`</span><span class="err">⨯</span><span class="bp">`</span><span class="o">:</span><span class="mi">90</span> <span class="o">:=</span> <span class="n">prod</span><span class="bp">.</span><span class="n">map&#39;</span>
</pre></div>

<a name="169016698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Function%20product/near/169016698" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/34664Functionproduct.html#169016698">Kevin Buzzard (Jun 26 2019 at 10:33)</a>:</h4>
<p><span class="user-mention" data-user-id="111433">@Alistair Tucker</span> </p>
<blockquote>
<p>I'm not sure what defeq means, but I remember that before I could use actually prod.map I had to write map_def:<br>
<a href="https://github.com/leanprover-community/mathlib/blob/60efaec1b2bae0b6ff22ebd889f26606c8648924/src/data/prod.lean#L36" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/60efaec1b2bae0b6ff22ebd889f26606c8648924/src/data/prod.lean#L36">https://github.com/leanprover-community/mathlib/blob/60efaec1b2bae0b6ff22ebd889f26606c8648924/src/data/prod.lean#L36</a></p>
</blockquote>
<p>I could never follow these conversations about this sort of thing, for months and months. And the problem was precisely because I didn't know what definitional equality (defeq) meant. The idea is that sometimes you can prove <code>X = Y</code> by <code>rfl</code>, and sometimes you can't -- sometimes it's a theorem. For example if we define addition on the naturals by <code>a+0:=a</code> and <code>a+S(b):=S(a+b)</code> then <code>x+0=x</code> is true by definition, whereas to prove <code>0+x=x</code> you need to use induction on <code>x</code>. In the first example, if you simplify both things as much as you can, then you get <code>x=x</code>. Whereas <code>0+x</code> <em>cannot be simplified</em>; you have to split into the cases x=0 and x=successor before you can simplify the term further (so basically you have to apply the function <code>nat.rec</code>). So <code>0+x=x</code> but this is not true by definition; the terms are not defeq.</p>
<p>Definitional equality is a super-powerful concept. I've proved [huge term] = [huge term] by <code>rfl</code> before. After a while it gets quite addictive -- if you make your definitions just right then there's more of a chance that <code>rfl</code> will work.</p>
<p>The problem with </p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="o">{</span><span class="n">u₁</span> <span class="n">u₂</span> <span class="n">v₁</span> <span class="n">v₂</span><span class="o">}</span> <span class="n">prod</span><span class="bp">.</span><span class="n">map</span> <span class="o">{</span><span class="n">α₁</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₁</span><span class="o">}</span> <span class="o">{</span><span class="n">α₂</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₂</span><span class="o">}</span> <span class="o">{</span><span class="n">β₁</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v₁</span><span class="o">}</span> <span class="o">{</span><span class="n">β₂</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v₂</span><span class="o">}</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α₁</span> <span class="bp">→</span> <span class="n">α₂</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">β₁</span> <span class="bp">→</span> <span class="n">β₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">α₁</span> <span class="bp">×</span> <span class="n">β₁</span> <span class="bp">→</span> <span class="n">α₂</span> <span class="bp">×</span> <span class="n">β₂</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">,</span> <span class="n">g</span> <span class="n">b</span><span class="o">)</span>
</pre></div>


<p>is that the definition is by cases -- like the definition of <code>0 + x</code>. So <code>prod.map f g x</code> is never going to be defeq to anything other than more complicated things which reduce to it; you can't reduce it any further. The moment you say "well x has type alpha x beta so WLOG it's of the form (a,b)" you are applying a function, probably called something like prod.map.rec or prod.map.cases_on, and changing the term. <br>
This can be avoided by defining <code>prod.map f g x</code> to be <code>(f x.fst, g x.snd)</code>. Now we don't have to do cases on <code>x</code>, these things are equal by definition. </p>
<div class="codehilite"><pre><span></span>
</pre></div>


{% endraw %}

{% include archive_update.html %}