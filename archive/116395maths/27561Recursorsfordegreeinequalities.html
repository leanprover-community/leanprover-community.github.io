---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/116395maths/27561Recursorsfordegreeinequalities.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/27561Recursorsfordegreeinequalities.html">Recursors for degree inequalities</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="147942053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Recursors%20for%20degree%20inequalities/near/147942053" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/27561Recursorsfordegreeinequalities.html#147942053">Chris Hughes (Nov 19 2018 at 14:10)</a>:</h4>
<p>Today I wrote two proofs of the following lemma, about nonconstant polynomials. They illustrate a use of recursive propositions. For the second proof, I defined <code>nonconstant</code> as a recursive Proposition, instead of <code>degree p &gt; 0</code>, and it was a much easier proof that didn't have any of the faffing around with degree. Is this sort of stuff worth having in the library. I'm experimenting with finding a useful recursor for <code>degree p &lt; degree q</code>.</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">polynomial_tendsto_infinity</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">ℂ</span><span class="o">},</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">degree</span> <span class="n">p</span> <span class="bp">→</span>
  <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">r</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">,</span> <span class="n">r</span> <span class="bp">&lt;</span> <span class="n">z</span><span class="bp">.</span><span class="n">abs</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">p</span><span class="bp">.</span><span class="kn">eval</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">abs</span>
</pre></div>


<p>The first is this very long ugly one. 49 lines</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">polynomial_tendsto_infinity</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">ℂ</span><span class="o">},</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">degree</span> <span class="n">p</span> <span class="bp">→</span>
  <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">r</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">,</span> <span class="n">r</span> <span class="bp">&lt;</span> <span class="n">z</span><span class="bp">.</span><span class="n">abs</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">p</span><span class="bp">.</span><span class="kn">eval</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">abs</span>
<span class="bp">|</span> <span class="n">p</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">hp</span> <span class="n">x</span><span class="o">,</span> <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">degree</span> <span class="n">p</span> <span class="bp">=</span> <span class="mi">1</span>
<span class="k">then</span>
  <span class="k">let</span> <span class="bp">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">hn</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">archimedean</span><span class="bp">.</span><span class="n">arch</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span>
    <span class="o">(</span><span class="k">show</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">abs</span> <span class="o">(</span><span class="n">leading_coeff</span> <span class="n">p</span><span class="o">),</span>
      <span class="k">from</span> <span class="n">abs_pos</span><span class="bp">.</span><span class="mi">2</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hp0</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span> <span class="bp">*</span> <span class="n">at</span> <span class="bp">*;</span> <span class="n">contradiction</span><span class="o">))</span> <span class="k">in</span>
  <span class="bp">⟨</span><span class="err">↑</span><span class="n">n</span> <span class="bp">*</span> <span class="n">abs</span> <span class="o">(</span><span class="n">p</span><span class="bp">.</span><span class="kn">eval</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">*</span> <span class="o">(</span><span class="bp">_</span><span class="n">root_</span><span class="bp">.</span><span class="n">abs</span> <span class="n">x</span><span class="o">),</span> <span class="bp">λ</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
    <span class="k">calc</span> <span class="n">x</span> <span class="bp">≤</span> <span class="bp">_</span><span class="n">root_</span><span class="bp">.</span><span class="n">abs</span> <span class="n">x</span> <span class="o">:</span> <span class="n">le_abs_self</span> <span class="bp">_</span>
    <span class="bp">...</span> <span class="bp">&lt;</span> <span class="n">abs</span> <span class="o">(</span><span class="n">p</span><span class="bp">.</span><span class="kn">eval</span> <span class="n">z</span><span class="o">)</span> <span class="o">:</span> <span class="n">lt_of_mul_lt_mul_left</span>
      <span class="o">(</span><span class="k">calc</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">*</span> <span class="bp">_</span><span class="n">root_</span><span class="bp">.</span><span class="n">abs</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">abs</span> <span class="n">z</span> <span class="bp">-</span> <span class="n">n</span> <span class="bp">*</span> <span class="n">abs</span> <span class="o">(</span><span class="kn">eval</span> <span class="mi">0</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span>
          <span class="n">lt_sub_iff_add_lt&#39;</span><span class="bp">.</span><span class="mi">2</span> <span class="n">hz</span>
        <span class="bp">...</span> <span class="bp">≤</span> <span class="n">n</span> <span class="bp">*</span> <span class="n">abs</span> <span class="o">(</span><span class="n">leading_coeff</span> <span class="n">p</span> <span class="bp">*</span> <span class="n">z</span><span class="o">)</span> <span class="bp">-</span> <span class="n">n</span> <span class="bp">*</span> <span class="n">abs</span> <span class="o">(</span><span class="n">p</span><span class="bp">.</span><span class="kn">eval</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
          <span class="n">sub_le_sub_right</span> <span class="o">(</span><span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">complex</span><span class="bp">.</span><span class="n">abs_mul</span><span class="o">,</span> <span class="err">←</span> <span class="n">mul_assoc</span><span class="o">]</span><span class="bp">;</span>
          <span class="n">exact</span> <span class="n">le_mul_of_ge_one_left</span> <span class="o">(</span><span class="n">complex</span><span class="bp">.</span><span class="n">abs_nonneg</span> <span class="bp">_</span><span class="o">)</span>
            <span class="o">(</span><span class="k">by</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">mul_comm</span><span class="o">,</span> <span class="n">add_monoid</span><span class="bp">.</span><span class="n">smul_eq_mul</span><span class="o">]</span> <span class="kn">using</span> <span class="n">hn</span><span class="o">))</span> <span class="bp">_</span>
        <span class="bp">...</span> <span class="bp">=</span> <span class="err">↑</span><span class="n">n</span> <span class="bp">*</span> <span class="o">(</span><span class="n">abs</span> <span class="o">(</span><span class="n">leading_coeff</span> <span class="n">p</span> <span class="bp">*</span> <span class="n">z</span><span class="o">)</span> <span class="bp">-</span> <span class="n">abs</span> <span class="o">(</span><span class="bp">-</span><span class="kn">eval</span> <span class="mi">0</span> <span class="n">p</span><span class="o">))</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">mul_add</span><span class="o">]</span>
        <span class="bp">...</span> <span class="bp">≤</span> <span class="err">↑</span><span class="n">n</span> <span class="bp">*</span> <span class="o">(</span><span class="n">abs</span> <span class="o">(</span><span class="n">leading_coeff</span> <span class="n">p</span> <span class="bp">*</span> <span class="n">z</span> <span class="bp">-</span> <span class="bp">-</span><span class="kn">eval</span> <span class="mi">0</span> <span class="n">p</span><span class="o">))</span> <span class="o">:</span>
          <span class="n">mul_le_mul_of_nonneg_left</span>
            <span class="o">(</span><span class="n">le_trans</span> <span class="o">(</span><span class="n">le_abs_self</span> <span class="bp">_</span><span class="o">)</span> <span class="o">(</span><span class="n">complex</span><span class="bp">.</span><span class="n">abs_abs_sub_le_abs_sub</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">))</span>
            <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">cast_nonneg</span> <span class="n">n</span><span class="o">)</span>
        <span class="bp">...</span> <span class="bp">=</span> <span class="err">↑</span><span class="n">n</span> <span class="bp">*</span> <span class="n">abs</span> <span class="o">(</span><span class="n">p</span><span class="bp">.</span><span class="kn">eval</span> <span class="n">z</span><span class="o">)</span> <span class="o">:</span>
          <span class="k">by</span> <span class="n">conv_rhs</span> <span class="o">{</span><span class="n">rw</span> <span class="n">degree_eq_one</span> <span class="n">h</span><span class="o">}</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">coeff_zero_eq_eval_zero</span><span class="o">])</span>
      <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">cast_nonneg</span> <span class="n">n</span><span class="o">)</span><span class="bp">⟩</span>
<span class="k">else</span>
  <span class="k">have</span> <span class="n">wf</span> <span class="o">:</span> <span class="n">degree</span> <span class="o">(</span><span class="n">p</span> <span class="bp">/</span><span class="err">ₘ</span> <span class="n">X</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">degree</span> <span class="n">p</span><span class="o">,</span>
    <span class="k">from</span> <span class="n">degree_div_by_monic_lt</span> <span class="bp">_</span> <span class="n">monic_X</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hp0</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span> <span class="bp">*</span> <span class="n">at</span> <span class="bp">*</span><span class="o">)</span>
      <span class="o">(</span><span class="k">by</span> <span class="n">rw</span> <span class="n">degree_X</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">dec_trivial</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">hp</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">&lt;</span> <span class="n">degree</span> <span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="k">match</span> <span class="n">degree</span> <span class="n">p</span><span class="o">,</span> <span class="n">hp</span><span class="o">,</span> <span class="n">h</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="n">none</span>    <span class="o">:=</span> <span class="n">dec_trivial</span>
    <span class="bp">|</span> <span class="o">(</span><span class="n">some</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h0</span> <span class="n">h1</span><span class="o">,</span> <span class="n">lt_of_le_of_ne</span> <span class="o">(</span><span class="n">with_bot</span><span class="bp">.</span><span class="n">coe_le_coe</span><span class="bp">.</span><span class="mi">2</span> <span class="o">(</span><span class="n">with_bot</span><span class="bp">.</span><span class="n">coe_lt_coe</span><span class="bp">.</span><span class="mi">1</span> <span class="n">h0</span><span class="o">))</span> <span class="o">(</span><span class="n">ne</span><span class="bp">.</span><span class="n">symm</span> <span class="n">h1</span><span class="o">)</span>
    <span class="kn">end</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hXp</span> <span class="o">:</span> <span class="n">degree</span> <span class="n">X</span> <span class="bp">≤</span> <span class="n">degree</span> <span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="n">le_of_lt</span> <span class="o">(</span><span class="k">by</span> <span class="n">rw</span> <span class="bp">@</span><span class="n">degree_X</span> <span class="n">ℂ</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">hp</span><span class="o">),</span>
  <span class="k">let</span> <span class="bp">⟨</span><span class="n">r</span><span class="o">,</span> <span class="n">hr</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">polynomial_tendsto_infinity</span> <span class="o">(</span><span class="n">p</span> <span class="bp">/</span><span class="err">ₘ</span> <span class="n">X</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">lt_of_add_lt_add_left&#39;</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">with_bot</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="bp">_</span> <span class="bp">_</span>
      <span class="o">(</span><span class="k">calc</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">with_bot</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">degree</span> <span class="n">p</span> <span class="o">:</span> <span class="n">hp</span>
        <span class="bp">...</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">degree</span> <span class="o">(</span><span class="n">p</span> <span class="bp">/</span><span class="err">ₘ</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="err">←</span> <span class="bp">@</span><span class="n">degree_X</span> <span class="n">ℂ</span><span class="o">,</span> <span class="n">degree_add_div_by_monic</span> <span class="n">monic_X</span> <span class="n">hXp</span><span class="o">]))</span>
  <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="o">(</span><span class="n">p</span><span class="bp">.</span><span class="kn">eval</span> <span class="mi">0</span><span class="o">)</span><span class="bp">.</span><span class="n">abs</span><span class="o">)</span> <span class="k">in</span>
  <span class="bp">⟨</span><span class="n">max</span> <span class="mi">1</span> <span class="o">(</span><span class="n">r</span> <span class="bp">+</span> <span class="o">(</span><span class="n">p</span><span class="bp">.</span><span class="kn">eval</span> <span class="mi">0</span><span class="o">)</span><span class="bp">.</span><span class="n">abs</span><span class="o">),</span> <span class="bp">λ</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
    <span class="k">calc</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">abs</span> <span class="o">(</span><span class="kn">eval</span> <span class="n">z</span> <span class="o">(</span><span class="n">p</span> <span class="bp">/</span><span class="err">ₘ</span> <span class="n">X</span><span class="o">))</span> <span class="bp">-</span> <span class="n">abs</span> <span class="o">(</span><span class="kn">eval</span> <span class="mi">0</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span>
      <span class="n">lt_sub_iff_add_lt</span><span class="bp">.</span><span class="mi">2</span> <span class="o">(</span><span class="n">hr</span> <span class="n">z</span> <span class="o">(</span><span class="n">lt_of_le_of_lt</span> <span class="o">(</span><span class="n">le_add_of_nonneg_right</span> <span class="o">(</span><span class="n">complex</span><span class="bp">.</span><span class="n">abs_nonneg</span> <span class="bp">_</span><span class="o">))</span>
        <span class="o">(</span><span class="n">lt_of_le_of_lt</span> <span class="o">(</span><span class="n">le_max_right</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="n">hz</span><span class="o">)))</span>
    <span class="bp">...</span> <span class="bp">≤</span> <span class="n">abs</span> <span class="n">z</span> <span class="bp">*</span> <span class="n">abs</span> <span class="o">(</span><span class="kn">eval</span> <span class="n">z</span> <span class="o">(</span><span class="n">p</span> <span class="bp">/</span><span class="err">ₘ</span> <span class="n">X</span><span class="o">))</span> <span class="bp">-</span> <span class="n">abs</span> <span class="o">(</span><span class="kn">eval</span> <span class="mi">0</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span>
      <span class="n">sub_le_sub_right</span> <span class="o">(</span><span class="n">le_mul_of_ge_one_left</span> <span class="o">(</span><span class="n">complex</span><span class="bp">.</span><span class="n">abs_nonneg</span> <span class="bp">_</span><span class="o">)</span> <span class="o">(</span><span class="n">le_trans</span> <span class="o">(</span><span class="n">le_max_left</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="o">(</span><span class="n">le_of_lt</span> <span class="n">hz</span><span class="o">)))</span> <span class="bp">_</span>
    <span class="bp">...</span> <span class="bp">≤</span> <span class="bp">_</span><span class="n">root_</span><span class="bp">.</span><span class="n">abs</span> <span class="o">(</span><span class="n">abs</span> <span class="o">(</span><span class="n">z</span> <span class="bp">*</span> <span class="kn">eval</span> <span class="n">z</span> <span class="o">(</span><span class="n">p</span> <span class="bp">/</span><span class="err">ₘ</span> <span class="n">X</span><span class="o">))</span> <span class="bp">-</span> <span class="n">abs</span> <span class="o">(</span><span class="bp">-</span><span class="kn">eval</span> <span class="mi">0</span> <span class="n">p</span><span class="o">))</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">complex</span><span class="bp">.</span><span class="n">abs_neg</span><span class="o">,</span> <span class="err">←</span> <span class="n">complex</span><span class="bp">.</span><span class="n">abs_mul</span><span class="o">]</span><span class="bp">;</span>
      <span class="n">exact</span> <span class="n">le_abs_self</span> <span class="bp">_</span>
    <span class="bp">...</span> <span class="bp">≤</span> <span class="n">abs</span> <span class="o">(</span><span class="n">z</span> <span class="bp">*</span> <span class="kn">eval</span> <span class="n">z</span> <span class="o">(</span><span class="n">p</span> <span class="bp">/</span><span class="err">ₘ</span> <span class="n">X</span><span class="o">)</span> <span class="bp">-</span> <span class="bp">-</span><span class="kn">eval</span> <span class="mi">0</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">abs_abs_sub_le_abs_sub</span> <span class="bp">_</span> <span class="bp">_</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">abs</span> <span class="o">(</span><span class="kn">eval</span> <span class="n">z</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">conv_rhs</span> <span class="o">{</span><span class="n">rw</span> <span class="err">←</span> <span class="n">mod_by_monic_add_div</span> <span class="n">p</span> <span class="n">monic_X</span><span class="o">}</span><span class="bp">;</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">coeff_zero_eq_eval_zero</span><span class="o">,</span> <span class="n">mod_by_monic_X</span><span class="o">]</span><span class="bp">⟩</span>
<span class="n">using_well_founded</span> <span class="o">{</span><span class="n">dec_tac</span> <span class="o">:=</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">assumption</span><span class="o">}</span>
</pre></div>


<p>The second is this much shorter one.</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">nonconstant</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">ℂ</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">X</span>   <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span><span class="o">},</span> <span class="n">a</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">nonconstant</span> <span class="o">(</span><span class="n">C</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">X</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">p</span><span class="o">},</span> <span class="n">nonconstant</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">nonconstant</span> <span class="o">(</span><span class="n">p</span> <span class="bp">*</span> <span class="n">X</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">p</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span><span class="o">),</span> <span class="n">nonconstant</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">nonconstant</span> <span class="o">(</span><span class="n">p</span> <span class="bp">+</span> <span class="n">C</span> <span class="n">a</span><span class="o">)</span>

<span class="kn">lemma</span> <span class="n">nonconstant_of_degree_pos</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">ℂ</span><span class="o">},</span>
  <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">degree</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">nonconstant</span> <span class="n">p</span>
<span class="bp">|</span> <span class="n">p</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span>
<span class="k">have</span> <span class="n">wf</span> <span class="o">:</span> <span class="n">degree</span> <span class="o">(</span><span class="n">p</span> <span class="bp">/</span><span class="err">ₘ</span> <span class="n">X</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">degree</span> <span class="n">p</span><span class="o">,</span>
  <span class="k">from</span> <span class="n">degree_div_by_monic_lt</span> <span class="bp">_</span> <span class="n">monic_X</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">hp0</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hp0</span><span class="o">,</span> <span class="n">lt_irrefl</span><span class="o">,</span> <span class="bp">*</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span><span class="o">)</span>
  <span class="o">(</span><span class="k">by</span> <span class="n">rw</span> <span class="n">degree_X</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">dec_trivial</span><span class="o">),</span>
<span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="err">←</span> <span class="n">mod_by_monic_add_div</span> <span class="n">p</span> <span class="n">monic_X</span><span class="o">,</span>
  <span class="n">add_comm</span><span class="o">,</span> <span class="n">mod_by_monic_X</span><span class="o">,</span> <span class="n">mul_comm</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*;</span>
<span class="n">exact</span> <span class="n">nonconstant</span><span class="bp">.</span><span class="n">add</span> <span class="bp">_</span>
  <span class="o">(</span><span class="k">if</span> <span class="n">hpX</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">degree</span> <span class="o">(</span><span class="n">p</span> <span class="bp">/</span><span class="err">ₘ</span> <span class="n">X</span><span class="o">)</span>
    <span class="k">then</span> <span class="n">nonconstant</span><span class="bp">.</span><span class="n">mul</span> <span class="o">(</span><span class="n">nonconstant_of_degree_pos</span> <span class="n">hpX</span><span class="o">)</span>
    <span class="k">else</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">eq_C_of_degree_le_zero</span> <span class="o">(</span><span class="n">not_lt</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hpX</span><span class="o">)]</span> <span class="n">at</span> <span class="bp">*;</span>
      <span class="n">exact</span> <span class="k">if</span> <span class="n">hc</span> <span class="o">:</span> <span class="n">coeff</span> <span class="o">(</span><span class="n">p</span> <span class="bp">/</span><span class="err">ₘ</span> <span class="n">X</span><span class="o">)</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span>
        <span class="k">then</span> <span class="k">by</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">hc</span><span class="o">,</span> <span class="n">not_lt_of_ge</span> <span class="n">degree_C_le</span><span class="o">]</span> <span class="kn">using</span> <span class="n">h</span>
        <span class="k">else</span> <span class="n">nonconstant</span><span class="bp">.</span><span class="n">X</span> <span class="n">hc</span><span class="o">)</span>
<span class="n">using_well_founded</span> <span class="o">{</span><span class="n">dec_tac</span> <span class="o">:=</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">assumption</span><span class="o">}</span>

<span class="kn">lemma</span> <span class="n">polynomial_tendsto_infinity&#39;</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">ℂ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">degree</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">r</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">,</span> <span class="n">r</span> <span class="bp">&lt;</span> <span class="n">z</span><span class="bp">.</span><span class="n">abs</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">p</span><span class="bp">.</span><span class="kn">eval</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">abs</span> <span class="o">:=</span>
<span class="n">nonconstant</span><span class="bp">.</span><span class="n">rec_on</span> <span class="o">(</span><span class="n">nonconstant_of_degree_pos</span> <span class="n">h</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">ha</span> <span class="n">x</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">x</span> <span class="bp">/</span> <span class="n">a</span><span class="bp">.</span><span class="n">abs</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
    <span class="k">by</span> <span class="n">simpa</span> <span class="o">[(</span><span class="n">div_lt_iff&#39;</span> <span class="o">(</span><span class="n">complex</span><span class="bp">.</span><span class="n">abs_pos</span><span class="bp">.</span><span class="mi">2</span> <span class="n">ha</span><span class="o">))</span><span class="bp">.</span><span class="n">symm</span><span class="o">]</span><span class="bp">⟩</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span> <span class="n">hp</span> <span class="n">ih</span> <span class="n">x</span><span class="o">,</span> <span class="k">let</span> <span class="bp">⟨</span><span class="n">r</span><span class="o">,</span> <span class="n">hr</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">ih</span> <span class="n">x</span> <span class="k">in</span>
    <span class="bp">⟨</span><span class="n">max</span> <span class="n">r</span> <span class="mi">1</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">eval_mul</span><span class="o">,</span> <span class="n">eval_X</span><span class="o">,</span> <span class="n">complex</span><span class="bp">.</span><span class="n">abs_mul</span><span class="o">]</span><span class="bp">;</span>
        <span class="n">exact</span> <span class="n">lt_of_lt_of_le</span> <span class="o">(</span><span class="n">hr</span> <span class="n">z</span> <span class="o">(</span><span class="n">lt_of_le_of_lt</span> <span class="o">(</span><span class="n">le_max_left</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="n">hz</span><span class="o">))</span>
          <span class="o">(</span><span class="n">le_mul_of_ge_one_right</span> <span class="o">(</span><span class="n">complex</span><span class="bp">.</span><span class="n">abs_nonneg</span> <span class="bp">_</span><span class="o">)</span>
            <span class="o">(</span><span class="n">le_trans</span> <span class="o">(</span><span class="n">le_max_right</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="o">(</span><span class="n">le_of_lt</span> <span class="n">hz</span><span class="o">)))</span><span class="bp">⟩</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span> <span class="n">a</span> <span class="n">hp</span> <span class="n">ih</span> <span class="n">x</span><span class="o">,</span> <span class="k">let</span> <span class="bp">⟨</span><span class="n">r</span><span class="o">,</span> <span class="n">hr</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">ih</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">a</span><span class="bp">.</span><span class="n">abs</span><span class="o">)</span> <span class="k">in</span>
    <span class="bp">⟨</span><span class="n">r</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">eval_add</span><span class="o">,</span> <span class="n">eval_C</span><span class="o">,</span> <span class="err">←</span> <span class="n">sub_neg_eq_add</span><span class="o">]</span><span class="bp">;</span>
      <span class="n">exact</span> <span class="n">lt_of_lt_of_le</span> <span class="o">(</span><span class="n">lt_sub_iff_add_lt</span><span class="bp">.</span><span class="mi">2</span>
        <span class="o">(</span><span class="k">by</span> <span class="n">rw</span> <span class="n">complex</span><span class="bp">.</span><span class="n">abs_neg</span><span class="bp">;</span> <span class="n">exact</span> <span class="o">(</span><span class="n">hr</span> <span class="n">z</span> <span class="n">hz</span><span class="o">)))</span>
        <span class="o">(</span><span class="n">le_trans</span> <span class="o">(</span><span class="n">le_abs_self</span> <span class="bp">_</span><span class="o">)</span> <span class="o">(</span><span class="n">complex</span><span class="bp">.</span><span class="n">abs_abs_sub_le_abs_sub</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">))</span><span class="bp">⟩</span><span class="o">)</span>
</pre></div>

<a name="147946548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Recursors%20for%20degree%20inequalities/near/147946548" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/27561Recursorsfordegreeinequalities.html#147946548">Johan Commelin (Nov 19 2018 at 16:38)</a>:</h4>
<p>Hey, that's a smart approach I think. I think the lemma should be <code>nonconstant_iff_degree_pos</code>, so that you can go back and forth.</p>

<a name="147946661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Recursors%20for%20degree%20inequalities/near/147946661" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/27561Recursorsfordegreeinequalities.html#147946661">Mario Carneiro (Nov 19 2018 at 16:43)</a>:</h4>
<p>another way to express this is to write a "recursor" for <code>degree p &gt; 0</code> along these lines</p>

<a name="147946725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Recursors%20for%20degree%20inequalities/near/147946725" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/27561Recursorsfordegreeinequalities.html#147946725">Mario Carneiro (Nov 19 2018 at 16:45)</a>:</h4>
<p>that recursor is equivalent to the theorem <code>nonconstant_of_degree_pos</code> but doesn't require defining a new predicate</p>

<a name="147951339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Recursors%20for%20degree%20inequalities/near/147951339" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/27561Recursorsfordegreeinequalities.html#147951339">Moses Schönfinkel (Nov 19 2018 at 19:08)</a>:</h4>
<p>I love the way you avoid the clunky <code>using_well_founded</code> construct :).</p>

<a name="147952836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Recursors%20for%20degree%20inequalities/near/147952836" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/27561Recursorsfordegreeinequalities.html#147952836">Kevin Buzzard (Nov 19 2018 at 19:50)</a>:</h4>
<p>Vaguely related: when I was working on Hilbert Basis (before module refactoring), I found using degree very hard; there were often case splits. <code>deg(X)=1</code> was only true if the ring wasn't the zero ring, <code>deg(f) * c = deg(f)</code> was only true when c*leading_coeff(f) was non-zero, <code>deg(f+g)</code> was a mass of case splits, and so on. It was only later on that I realised that the natural condition was "deg &lt;= n" not "deg = n"; for "deg &lt;= n" (which produces a sub-R-module of R[X]) all the lemmas are very natural. "Non-constant" is the negation of "deg &lt;= 0" but I don't know if this has anything to do with the obstructions that Chris was running into.</p>

<a name="147953494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Recursors%20for%20degree%20inequalities/near/147953494" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/27561Recursorsfordegreeinequalities.html#147953494">Patrick Massot (Nov 19 2018 at 20:09)</a>:</h4>
<p>I'm sure it would be good to have nicer recursors for polynomial but, for the purpose of this properness proof, what is missing in order to write an efficient proof is the big O library (I should resume work on that). As far as I understand, the best formal proofs are sequences of lemmas with three lines long proofs. Here there is a very clear path where you prove <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><msup><mi>X</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">aX^ n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">a</span><span class="mord"><span class="mord mathit" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">n</span></span></span></span></span></span></span></span></span></span></span> is <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>X</mi><mi>n</mi></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(X^n)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> then <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>X</mi><mi>n</mi></msup><mo>=</mo><mi>o</mi><mo>(</mo><msup><mi>X</mi><mi>k</mi></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">X^n = o(X^k)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.849108em;"></span><span class="strut bottom" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">n</span></span></span></span></span></span></span></span><span class="mrel">=</span><span class="mord mathit">o</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span> bigger than <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">n</span></span></span></span>, then  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>f</mi><mo>)</mo><mo>+</mo><mi>O</mi><mo>(</mo><mi>f</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>f</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(f) + O(f) = O(f)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span> (this one is already in our WIP I think!) then <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>=</mo><mi>O</mi><mo>(</mo><msup><mi>X</mi><mrow><mi>d</mi><mi>e</mi><mi>g</mi><mi>P</mi></mrow></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">P = O(X^{deg P})</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8491079999999999em;"></span><span class="strut bottom" style="height:1.0991079999999998em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">d</span><span class="mord mathit mtight">e</span><span class="mord mathit mtight" style="margin-right:0.03588em;">g</span><span class="mord mathit mtight" style="margin-right:0.13889em;">P</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, then <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span></span> proper implies <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>+</mo><mi>o</mi><mo>(</mo><mi>f</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f + o(f)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mbin">+</span><span class="mord mathit">o</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span> proper and then $X^n$ is proper for positive <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">n</span></span></span></span>. Maybe I missed one or two lemmas, but you get the idea. This will be a string of reusable 2 lines long proofs lemmas, and will match the paper and pen proof.</p>

<a name="147953617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Recursors%20for%20degree%20inequalities/near/147953617" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/27561Recursorsfordegreeinequalities.html#147953617">Patrick Massot (Nov 19 2018 at 20:12)</a>:</h4>
<p>Also the story about the projective line is a bit misleading here, since we don't need any structure on <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>P</mi><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">P^1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">1</span></span></span></span></span></span></span></span></span></span></span> in this discussion, except maybe topological. We need filters stuff for sure, maybe also Alexandrov compactification if we want</p>


{% endraw %}
