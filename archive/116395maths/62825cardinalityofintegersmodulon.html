---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/116395maths/62825cardinalityofintegersmodulon.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html">cardinality of integers modulo n</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="155093729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155093729" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155093729">Joey van Langen (Jan 14 2019 at 15:58)</a>:</h4>
<p>I am trying to prove the following result</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">ideal</span><span class="bp">.</span><span class="n">quotient</span> <span class="o">(</span><span class="n">ideal</span><span class="bp">.</span><span class="n">span</span> <span class="o">{(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)})</span> <span class="err">≃</span> <span class="n">fin</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>


<p>This seems a simple result in math, but I am having a lot of trouble making a simple proof in lean. Anyone got any suggestions?</p>

<a name="155093930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155093930" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155093930">Johan Commelin (Jan 14 2019 at 16:02)</a>:</h4>
<p>I don't think you want that <code>fintype</code> there.</p>

<a name="155093986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155093986" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155093986">Johan Commelin (Jan 14 2019 at 16:02)</a>:</h4>
<p><code>fintype</code> means as much as "Hey Lean, this type is finite".</p>

<a name="155094056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155094056" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155094056">Joey van Langen (Jan 14 2019 at 16:03)</a>:</h4>
<p>That is right, I first wanted to split proving finite and the exact cardinality separately, but realized I could combine the two</p>

<a name="155094142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155094142" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155094142">Johan Commelin (Jan 14 2019 at 16:04)</a>:</h4>
<p>If you want to construct a map from <code>ideal.quotient ...</code> to the right, look for things called <code>lift</code> in the file of ideal quotients.</p>

<a name="155094197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155094197" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155094197">Johan Commelin (Jan 14 2019 at 16:05)</a>:</h4>
<p>Maybe the easiest way would be to compute the kernel of the <code>cast : int → zmod n</code></p>

<a name="155094207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155094207" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155094207">Johan Commelin (Jan 14 2019 at 16:05)</a>:</h4>
<p>And then use the isomorphism theorem (that we probably don't have <span class="emoji emoji-1f923" title="rolling on the floor laughing">:rolling_on_the_floor_laughing:</span>)</p>

<a name="155094270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155094270" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155094270">Joey van Langen (Jan 14 2019 at 16:06)</a>:</h4>
<p>We don't have an isomorphism theorem. At least not for rings</p>

<a name="155094320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155094320" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155094320">Joey van Langen (Jan 14 2019 at 16:07)</a>:</h4>
<p><code>zmod</code> may also be <code>fin</code> since I am not necessarily interested in the ring structure of it</p>

<a name="155094395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155094395" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155094395">Chris Hughes (Jan 14 2019 at 16:08)</a>:</h4>
<p>There is already a construction of <code>zmod n</code> in <code>data.zmod.basic</code></p>

<a name="155094448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155094448" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155094448">Joey van Langen (Jan 14 2019 at 16:09)</a>:</h4>
<p>But there it is not constructed using the integers. The thing on the left naturally arises from a problem I have and I want to relate the two</p>

<a name="155094468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155094468" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155094468">Joey van Langen (Jan 14 2019 at 16:09)</a>:</h4>
<p>Or at least get the necessary result about cardinality of the quotient on the left</p>

<a name="155094806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155094806" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155094806">Johan Commelin (Jan 14 2019 at 16:14)</a>:</h4>
<p>I agree that the lemma you state should be proven at some point. So we might as well do it now.</p>

<a name="155094821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155094821" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155094821">Joey van Langen (Jan 14 2019 at 16:14)</a>:</h4>
<p>This is what I have thus far:</p>
<div class="codehilite"><pre><span></span><span class="k">let</span> <span class="n">nℤ</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">span</span> <span class="bp">ℤ</span> <span class="bp">_</span> <span class="o">{(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)}</span> <span class="k">in</span>
<span class="k">let</span> <span class="bp">ℤ</span><span class="n">modnℤ</span> <span class="o">:=</span> <span class="n">ideal</span><span class="bp">.</span><span class="n">quotient</span> <span class="n">nℤ</span> <span class="k">in</span>
<span class="k">have</span> <span class="n">g</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="bp">ℤ</span><span class="n">modnℤ</span><span class="o">,</span> <span class="k">from</span> <span class="bp">λ</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">ideal</span><span class="bp">.</span><span class="n">quotient</span><span class="bp">.</span><span class="n">mk</span> <span class="n">nℤ</span> <span class="err">$</span> <span class="n">of_nat</span> <span class="err">$</span> <span class="n">m</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span>
<span class="k">have</span> <span class="n">f</span> <span class="o">:</span> <span class="bp">ℤ</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="k">from</span> <span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">val</span> <span class="o">:=</span> <span class="n">nat_abs</span> <span class="o">(</span><span class="n">x</span> <span class="err">%</span> <span class="n">n</span><span class="o">),</span>
    <span class="n">is_lt</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">},</span>
<span class="k">have</span> <span class="n">f&#39;</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="n">modnℤ</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="k">from</span> <span class="n">sorry</span>
</pre></div>

<a name="155094902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155094902" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155094902">Johan Commelin (Jan 14 2019 at 16:15)</a>:</h4>
<p>I think it is better to prove the isomorphism theorem. Because you will need that time and again</p>

<a name="155094956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155094956" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155094956">Johan Commelin (Jan 14 2019 at 16:16)</a>:</h4>
<p><span class="user-mention" data-user-id="110044">@Chris Hughes</span> <span class="user-mention" data-user-id="110064">@Kenny Lau</span>  Do you have anything in that direction?</p>

<a name="155094967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155094967" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155094967">Chris Hughes (Jan 14 2019 at 16:16)</a>:</h4>
<p>I'm not sure on your application, but I think the best way to do quotient rings in Lean is to not prove things about the <code>quotient</code> construction, but prove lemmas about quotient rings for any quotient, even if it isn't constructed using the <code>quot</code> constant. For example, <code>ideal.lift</code>, should have been defined with a type like this.</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">lift</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">γ</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">[</span><span class="n">is_ring_hom</span> <span class="n">f</span><span class="o">]</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span> <span class="o">[</span><span class="n">is_ring_hom</span> <span class="n">q</span><span class="o">]</span> <span class="o">(</span><span class="n">hq</span> <span class="o">:</span> <span class="n">surjective</span> <span class="n">q</span><span class="o">)</span>
  <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">q</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">γ</span> <span class="bp">→</span> <span class="n">β</span> <span class="o">:=</span>
</pre></div>


<p>Would refactoring the library like this help?</p>

<a name="155095011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155095011" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155095011">Chris Hughes (Jan 14 2019 at 16:17)</a>:</h4>
<p>For the cardinality, all you need is the isomorphism theorem on groups, which is already there.</p>

<a name="155095086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155095086" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155095086">Johan Commelin (Jan 14 2019 at 16:18)</a>:</h4>
<p>Aah, if we have it for groups, then proving it for rings shouldn't be too hard. But I agree that we don't need it for the cardinality result.</p>

<a name="155095132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155095132" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155095132">Joey van Langen (Jan 14 2019 at 16:19)</a>:</h4>
<p>So working with the predefined group structure on <code>zmod n</code> should do the trick</p>

<a name="155095145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155095145" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155095145">Joey van Langen (Jan 14 2019 at 16:19)</a>:</h4>
<p>I will try to make that work</p>

<a name="155095283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155095283" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155095283">Johan Commelin (Jan 14 2019 at 16:21)</a>:</h4>
<p><span class="user-mention" data-user-id="110044">@Chris Hughes</span> Don't you need your <code>q</code> to be a ring hom as well?</p>

<a name="155095362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155095362" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155095362">Johan Commelin (Jan 14 2019 at 16:22)</a>:</h4>
<p>I mean, you can probably define this... But then you can't really prove things about it.</p>

<a name="155095375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155095375" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155095375">Johan Commelin (Jan 14 2019 at 16:22)</a>:</h4>
<p>... without extra assumptions</p>

<a name="155095395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155095395" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155095395">Chris Hughes (Jan 14 2019 at 16:23)</a>:</h4>
<p>Yes, I missed that out.</p>

<a name="155095676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155095676" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155095676">Joey van Langen (Jan 14 2019 at 16:27)</a>:</h4>
<blockquote>
<p>Would refactoring the library like this help?</p>
</blockquote>
<p>I think the current version of lift is fine, as you most often want maps from a quotient</p>

<a name="155095796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155095796" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155095796">Chris Hughes (Jan 14 2019 at 16:28)</a>:</h4>
<p>Why do you need to construct <code>ℤmodnℤ</code> using <code>quotient</code> instead of using <code>zmod n</code>?</p>

<a name="155095933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155095933" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155095933">Joey van Langen (Jan 14 2019 at 16:30)</a>:</h4>
<p>For finite fields, to show that they are field extensions of some field with p elements, I make use of the natural map from <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="double-struck">Z</mi></mrow></mrow><annotation encoding="application/x-tex">\mathbb{Z}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68889em;"></span><span class="strut bottom" style="height:0.68889em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span> to the field which factors over a quotient of that form.</p>

<a name="155096132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155096132" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155096132">Chris Hughes (Jan 14 2019 at 16:33)</a>:</h4>
<p>So if you had <code>lift</code> with the type I suggested, you could show the field homomorphism directly from <code>zmodp p hp</code> instead of mentioning <code>ideal.quotient</code> right?</p>

<a name="155096375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155096375" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155096375">Joey van Langen (Jan 14 2019 at 16:36)</a>:</h4>
<p>I would need to prove that the map to <code>zmod p hp</code> is surjective, which is I think the difficult part of the proof I want</p>

<a name="155096447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155096447" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155096447">Joey van Langen (Jan 14 2019 at 16:37)</a>:</h4>
<p>A priori you do not know that there is a map from <code>zmod p hp</code> to the field</p>

<a name="155096521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155096521" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155096521">Chris Hughes (Jan 14 2019 at 16:38)</a>:</h4>
<p>There's a proof somewhere that <code>fin.val</code> is a one-sided inverse of <code>int.cast</code> or perhaps only <code>nat.cast</code></p>

<a name="155097440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155097440" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155097440">Neil Strickland (Jan 14 2019 at 16:50)</a>:</h4>
<p>I vote in favour of <span class="user-mention" data-user-id="110044">@Chris Hughes</span> 's suggestion for refactoring.  I have thought about the technicalities of formalizing a number of arguments, both for arbitrary commutative rings and for rings arising in algebraic topology, and it is clear that the more flexible form of the lift construction will be much more convenient in many places.  The same applies for localisations: instead of a theorem about homomorphisms $A[S^{-1}]\to B$ , there should be an <code>is_localization</code> predicate for maps $A\to A'$ and a theorem about maps $A'\to B$ when that predicate is satisfied.</p>

<a name="155100374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155100374" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155100374">Kevin Buzzard (Jan 14 2019 at 17:27)</a>:</h4>
<p>I don't quite understand this yet, but I'd like to [NB <code>$$ A\to A'$$</code>for maths mode on Zulip]. Currently given a commutative ring <code>A</code> and a submonoid <code>S</code> of <code>A</code> we have some localisation type <code>loc A S</code>plus a proof it's a ring, and the universal property theorems. </p>
<p>This approach gave me trouble. I was a Lean amateur at the time. I wanted to prove things like <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>[</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>f</mi><mo>]</mo><mo>[</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>g</mi><mo>]</mo><mo>=</mo><mi>A</mi><mo>[</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>f</mi><mi>g</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">A[1/f][1/g]=A[1/fg]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">A</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mclose">]</span><span class="mrel">=</span><span class="mord mathit">A</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mclose">]</span></span></span></span> (that's the mathematician's "=" there -- "canonical isomorphism" if you'd rather) from the universal property and if I remember correctly there was a lot of kerfuffle. See <a href="https://github.com/kbuzzard/lean-stacks-project/blob/ad816148cd9292f9205efd2674e180418d2680ec/src/localization_UMP.lean#L230" target="_blank" title="https://github.com/kbuzzard/lean-stacks-project/blob/ad816148cd9292f9205efd2674e180418d2680ec/src/localization_UMP.lean#L230">https://github.com/kbuzzard/lean-stacks-project/blob/ad816148cd9292f9205efd2674e180418d2680ec/src/localization_UMP.lean#L230</a> for example.  In fact <a href="https://github.com/kbuzzard/lean-stacks-project/blob/ad816148cd9292f9205efd2674e180418d2680ec/src/localization_UMP.lean#L288" target="_blank" title="https://github.com/kbuzzard/lean-stacks-project/blob/ad816148cd9292f9205efd2674e180418d2680ec/src/localization_UMP.lean#L288">https://github.com/kbuzzard/lean-stacks-project/blob/ad816148cd9292f9205efd2674e180418d2680ec/src/localization_UMP.lean#L288</a> was even worse -- I briefly explain what I was trying to do in the comments above. I was hoping <span class="user-mention" data-user-id="132858">@Ramon Fernandez Mir</span> would refactor all this, this month.</p>
<p>Is the idea instead that if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">f:A\to B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mrel">:</span><span class="mord mathit">A</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>⊆</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">S\subseteq A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mrel">⊆</span><span class="mord mathit">A</span></span></span></span> then we have a predicate which mathematically means that the induced <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">A</span></span></span></span>-algebra structure on <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span> is isomorphic to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>[</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>S</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">A[1/S]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">A</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mclose">]</span></span></span></span>?</p>

<a name="155110131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155110131" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155110131">Patrick Massot (Jan 14 2019 at 19:37)</a>:</h4>
<p>Compare with <a href="https://github.com/leanprover/mathlib/blob/19e7b1f574d813b9b305b41f8c0820c01bf99c84/analysis/topology/continuity.lean#L379-L382" target="_blank" title="https://github.com/leanprover/mathlib/blob/19e7b1f574d813b9b305b41f8c0820c01bf99c84/analysis/topology/continuity.lean#L379-L382">https://github.com/leanprover/mathlib/blob/19e7b1f574d813b9b305b41f8c0820c01bf99c84/analysis/topology/continuity.lean#L379-L382</a> and how it appears in different statements, including <a href="https://github.com/leanprover/mathlib/blob/19e7b1f574d813b9b305b41f8c0820c01bf99c84/analysis/topology/continuity.lean#L934" target="_blank" title="https://github.com/leanprover/mathlib/blob/19e7b1f574d813b9b305b41f8c0820c01bf99c84/analysis/topology/continuity.lean#L934">https://github.com/leanprover/mathlib/blob/19e7b1f574d813b9b305b41f8c0820c01bf99c84/analysis/topology/continuity.lean#L934</a>  but not only</p>

<a name="155121156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155121156" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155121156">Kenny Lau (Jan 14 2019 at 21:35)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">ideals</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">ideal</span><span class="bp">.</span><span class="n">quotient</span> <span class="o">(</span><span class="n">ideal</span><span class="bp">.</span><span class="n">span</span> <span class="o">({</span><span class="n">n</span><span class="o">}</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">ℤ</span><span class="o">))</span> <span class="err">≃</span> <span class="n">fin</span> <span class="n">n</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">lift_on&#39;</span> <span class="n">x</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="bp">⟨</span><span class="n">int</span><span class="bp">.</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">i</span><span class="err">%</span><span class="n">n</span><span class="o">),</span>
      <span class="n">int</span><span class="bp">.</span><span class="n">coe_nat_lt</span><span class="bp">.</span><span class="mi">1</span> <span class="err">$</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">int</span><span class="bp">.</span><span class="n">nat_abs_of_nonneg</span> <span class="o">(</span><span class="n">int</span><span class="bp">.</span><span class="n">mod_nonneg</span> <span class="bp">_</span> <span class="o">(</span><span class="n">int</span><span class="bp">.</span><span class="n">coe_nat_ne_zero</span><span class="bp">.</span><span class="mi">2</span> <span class="n">h</span><span class="o">))]</span><span class="bp">;</span> <span class="n">exact</span>
      <span class="n">int</span><span class="bp">.</span><span class="n">mod_lt_of_pos</span> <span class="bp">_</span> <span class="o">(</span><span class="n">int</span><span class="bp">.</span><span class="n">coe_nat_pos</span><span class="bp">.</span><span class="mi">2</span> <span class="err">$</span> <span class="n">nat</span><span class="bp">.</span><span class="n">pos_of_ne_zero</span> <span class="n">h</span><span class="o">)</span><span class="bp">⟩</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">))</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span> <span class="n">hij</span><span class="o">,</span> <span class="k">let</span> <span class="bp">⟨</span><span class="n">k</span><span class="o">,</span> <span class="n">hk</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">ideal</span><span class="bp">.</span><span class="n">mem_span_singleton</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hij</span> <span class="k">in</span> <span class="n">fin</span><span class="bp">.</span><span class="n">eq_of_veq</span> <span class="err">$</span> <span class="k">show</span> <span class="n">int</span><span class="bp">.</span><span class="n">nat_abs</span> <span class="bp">_</span> <span class="bp">=</span> <span class="n">int</span><span class="bp">.</span><span class="n">nat_abs</span> <span class="bp">_</span><span class="o">,</span>
      <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">eq_add_of_sub_eq</span> <span class="n">hk</span><span class="o">,</span> <span class="n">add_comm</span><span class="o">,</span> <span class="n">int</span><span class="bp">.</span><span class="n">add_mul_mod_self_left</span><span class="o">]),</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">k</span><span class="o">,</span> <span class="n">ideal</span><span class="bp">.</span><span class="n">quotient</span><span class="bp">.</span><span class="n">mk</span> <span class="bp">_</span> <span class="n">k</span><span class="o">,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">induction_on&#39;</span> <span class="n">x</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">sound&#39;</span> <span class="err">$</span> <span class="n">ideal</span><span class="bp">.</span><span class="n">mem_span_singleton&#39;</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">⟨_</span><span class="o">,</span>
    <span class="k">show</span> <span class="bp">_</span> <span class="bp">=</span> <span class="err">↑</span><span class="o">(</span><span class="n">int</span><span class="bp">.</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">i</span><span class="err">%</span><span class="n">n</span><span class="o">))</span> <span class="bp">-</span> <span class="n">i</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">int</span><span class="bp">.</span><span class="n">nat_abs_of_nonneg</span> <span class="o">(</span><span class="n">int</span><span class="bp">.</span><span class="n">mod_nonneg</span> <span class="bp">_</span> <span class="o">(</span><span class="n">int</span><span class="bp">.</span><span class="n">coe_nat_ne_zero</span><span class="bp">.</span><span class="mi">2</span> <span class="n">h</span><span class="o">)),</span>
      <span class="n">int</span><span class="bp">.</span><span class="n">mod_def</span><span class="o">,</span> <span class="n">sub_sub</span><span class="o">,</span> <span class="n">add_comm</span><span class="o">,</span> <span class="n">sub_add_eq_sub_sub</span><span class="o">,</span> <span class="n">sub_self</span><span class="o">,</span> <span class="n">zero_sub</span><span class="o">,</span> <span class="n">neg_mul_eq_mul_neg</span><span class="o">,</span> <span class="n">mul_comm</span><span class="o">]</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">k</span><span class="o">,</span> <span class="n">fin</span><span class="bp">.</span><span class="n">eq_of_veq</span> <span class="err">$</span> <span class="k">show</span> <span class="n">int</span><span class="bp">.</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">k</span><span class="bp">.</span><span class="mi">1</span><span class="err">%</span><span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">_</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="err">←</span> <span class="n">int</span><span class="bp">.</span><span class="n">coe_nat_mod</span><span class="o">,</span> <span class="n">int</span><span class="bp">.</span><span class="n">nat_abs_of_nat</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">mod_eq_of_lt</span> <span class="n">k</span><span class="bp">.</span><span class="mi">2</span><span class="o">]</span> <span class="o">}</span>
</pre></div>

<a name="155132489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155132489" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155132489">Mario Carneiro (Jan 15 2019 at 00:17)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> Yes, this is the idea. Something just like it came up during the mathlib maintenance discussion at lean together, where we had an equality theorem <code>quotient (separation_setoid A) = (\bot : ideal A).quotient</code>, IIRC. If we could say that something is a quotient rather than having a quotient construction, then this typal equality could be avoided</p>

<a name="155132583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155132583" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155132583">Mario Carneiro (Jan 15 2019 at 00:18)</a>:</h4>
<p>Topology already has the notion of a "quotient map" that is already performing this exact thing, we just need to extend it to quotient maps of rings, groups, etc, as well as localization maps and maps for other kinds of constructions</p>

<a name="155132712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155132712" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155132712">Mario Carneiro (Jan 15 2019 at 00:20)</a>:</h4>
<p>Of course we still want the construction - it's no good having theorems about quotient maps if we can't prove they exist - but being able to quantify over things isomorphic to a particular construction is actually a really powerful way to avoid DTT hell</p>

<a name="155132787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155132787" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155132787">Mario Carneiro (Jan 15 2019 at 00:21)</a>:</h4>
<p>I think we've also talked about having a <code>euclidean_space A</code> typeclass that basically means "isomorphic to R^n" which seems silly but is useful for exactly this kind of thing - you don't want to build in a dependence on the precise way a type is constructed</p>

<a name="155152420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155152420" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155152420">Patrick Massot (Jan 15 2019 at 07:59)</a>:</h4>
<p>Yes, this is exactly why I posted the cryptic link in my previous message in this thread.</p>

<a name="155152528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155152528" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155152528">Patrick Massot (Jan 15 2019 at 08:01)</a>:</h4>
<p>And I wanted to mention this <code>quotient (separation_setoid A) = (\bot : ideal A).quotient</code> (which is <a href="https://github.com/leanprover/mathlib/blob/19e7b1f574d813b9b305b41f8c0820c01bf99c84/analysis/topology/quotient_topological_structures.lean#L189" target="_blank" title="https://github.com/leanprover/mathlib/blob/19e7b1f574d813b9b305b41f8c0820c01bf99c84/analysis/topology/quotient_topological_structures.lean#L189">here</a>) in my Amsterdam talk but I didn't have time. Note that I did find a workaround in the mean time, but we should still do something more systematic.</p>

<a name="155152826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155152826" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155152826">Kevin Buzzard (Jan 15 2019 at 08:07)</a>:</h4>
<p>One big difference between localisations and Euclidean space is that if the <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">A</span></span></span></span>-algebra <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span> is isomorphic to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>[</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>S</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">A[1/S]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">A</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mclose">]</span></span></span></span> as an <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">A</span></span></span></span>-algebra then it's uniquely isomorphic to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>[</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>S</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">A[1/S]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">A</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mclose">]</span></span></span></span> as an <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">A</span></span></span></span>-algebra. However if a space is isomorphic to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi mathvariant="double-struck">R</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\mathbb{R}^n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68889em;"></span><span class="strut bottom" style="height:0.68889em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">n</span></span></span></span></span></span></span></span></span></span></span> as an <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="double-struck">R</mi></mrow></mrow><annotation encoding="application/x-tex">\mathbb{R}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68889em;"></span><span class="strut bottom" style="height:0.68889em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathbb">R</span></span></span></span></span>-vector space, then there is in general more than one isomorphism, and you may or may not want to keep track of an isomorphism I guess, depending on what you're doing.</p>

<a name="155155008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155155008" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155155008">Kevin Buzzard (Jan 15 2019 at 09:00)</a>:</h4>
<blockquote>
<p>Is the idea instead that if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">f:A\to B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mrel">:</span><span class="mord mathit">A</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>⊆</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">S\subseteq A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mrel">⊆</span><span class="mord mathit">A</span></span></span></span> then we have a predicate which mathematically means that the induced <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">A</span></span></span></span>-algebra structure on <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span> is isomorphic to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>[</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>S</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">A[1/S]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">A</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mclose">]</span></span></span></span>?</p>
</blockquote>
<p>Aah! The penny has just dropped. Instead of the definition of the predicate being "B is isomorphic to the A[1/S] we constructed", it says "B satisfies the universal property we want". Is that the idea? We have predicates for universal properties?</p>

<a name="155155081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155155081" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155155081">Kenny Lau (Jan 15 2019 at 09:02)</a>:</h4>
<p>Are all isomorphisms isomorphic?</p>

<a name="155155095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155155095" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155155095">Kenny Lau (Jan 15 2019 at 09:02)</a>:</h4>
<p>but universal property is not a property... it is a function and has data right</p>

<a name="155155118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155155118" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155155118">Kevin Buzzard (Jan 15 2019 at 09:03)</a>:</h4>
<p>Given f:A-&gt;B and S in A, the universal property just says that for all A -&gt; C sending S to units, there's a unique B -&gt; C making the diagram commute. Does this have data?</p>

<a name="155155163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155155163" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155155163">Kevin Buzzard (Jan 15 2019 at 09:04)</a>:</h4>
<p>Universal property is more than isomorphism, it's unique isomorphism.</p>

<a name="155155170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155155170" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155155170">Kenny Lau (Jan 15 2019 at 09:04)</a>:</h4>
<p>of course this has data</p>

<a name="155155174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155155174" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155155174">Kevin Buzzard (Jan 15 2019 at 09:04)</a>:</h4>
<p>?</p>

<a name="155155178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155155178" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155155178">Johan Commelin (Jan 15 2019 at 09:04)</a>:</h4>
<p>But modulo <code>choice</code> it doesn't</p>

<a name="155155929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155155929" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155155929">Reid Barton (Jan 15 2019 at 09:21)</a>:</h4>
<p>The data is the unique B -&gt; C that fits</p>

<a name="155155952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155155952" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155155952">Reid Barton (Jan 15 2019 at 09:21)</a>:</h4>
<p>Right, it's constructively data but classically a property, because we also assert that it is unique</p>

<a name="155155996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155155996" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155155996">Kenny Lau (Jan 15 2019 at 09:22)</a>:</h4>
<p>I think we really need a typeclass that is nonempty + subsingleton</p>

<a name="155156002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155156002" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155156002">Kenny Lau (Jan 15 2019 at 09:22)</a>:</h4>
<p>and another that is inhabited+subsingleton</p>

<a name="155156144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155156144" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155156144">Kevin Buzzard (Jan 15 2019 at 09:25)</a>:</h4>
<p>You can't make the map constructively unless you have an explicit inverse for your units. I am unclear about whether as a mathematician I should even care about this discussion. For sure I want something that works if I just know abstractly that something is a unit</p>

<a name="155156216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155156216" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155156216">Kevin Buzzard (Jan 15 2019 at 09:26)</a>:</h4>
<p>Generalising Kenny's argument one should have two definitions of unit as well -- existence of an inverse, and the inverse</p>

<a name="155156249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155156249" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155156249">Johan Commelin (Jan 15 2019 at 09:27)</a>:</h4>
<blockquote>
<p>Generalising Kenny's argument one should have two definitions of unit as well -- existence of an inverse, and the inverse</p>
</blockquote>
<p>We do... there is <code>units</code> and <code>is_unit</code>, if I'm not mistaken.</p>

<a name="155156625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155156625" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155156625">Reid Barton (Jan 15 2019 at 09:34)</a>:</h4>
<p>Good point about needing to have an actual inverse in order to construct the induced map constructively.<br>
The good news is that any constructively reasonable definition will also be at least usable classically, because you can always conjure up the witness you need using <code>choice</code>. The question is what is most convenient.</p>

<a name="155156657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155156657" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155156657">Reid Barton (Jan 15 2019 at 09:35)</a>:</h4>
<p><code>is_unit a</code> is defined as <code>∃u:units α, a = u</code>, the other version would be with a sigma instead of an exists</p>

<a name="155156939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155156939" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155156939">Reid Barton (Jan 15 2019 at 09:40)</a>:</h4>
<blockquote>
<blockquote>
<p>Is the idea instead that if $f:A\to B$ and $S\subseteq A$ then we have a predicate which mathematically means that the induced $A$-algebra structure on $B$ is isomorphic to $A[1/S]$?</p>
</blockquote>
<p>Aah! The penny has just dropped. Instead of the definition of the predicate being "B is isomorphic to the A[1/S] we constructed", it says "B satisfies the universal property we want". Is that the idea? We have predicates for universal properties?</p>
</blockquote>
<p>In general this is the idea but in some cases you can also give an equivalent but more hands-on description of the predicate, e.g., R -&gt; S being a quotient map of rings can be defined either in terms of a universal property or just as a surjective map.</p>

<a name="155157804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155157804" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155157804">Reid Barton (Jan 15 2019 at 09:58)</a>:</h4>
<p>Another way of looking at this is that a map being of the form R -&gt; R/I is something that is either true by definition or not, while a map being a quotient map is a theorem you can <em>prove</em> using any methods at your disposal.<br>
The tradeoff is that it's not quite as convenient to use the quotient map hypothesis because you need to pass it to the place it is used, while Lean "just knows" when a ring is defined as a quotient ring.</p>

<a name="155159954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155159954" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155159954">Kevin Buzzard (Jan 15 2019 at 10:38)</a>:</h4>
<p>The analogue of <code>is_surjective</code> in the localisation situation is not something I think I can write down without simply saying something like "image of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span></span> lands in the units, and induced map from concrete localisation is a bijection". Is such a predicate useful?</p>

<a name="155162195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155162195" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155162195">Mario Carneiro (Jan 15 2019 at 11:27)</a>:</h4>
<p>You can't directly use the universal property as the definition, because of universe issues (it can't quantify over all universes), so you have to find an "internal" characterization roughly equivalent to the construction itself</p>

<a name="155162213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155162213" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155162213">Kevin Buzzard (Jan 15 2019 at 11:27)</a>:</h4>
<p><em>boggle</em></p>

<a name="155162265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155162265" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155162265">Kevin Buzzard (Jan 15 2019 at 11:28)</a>:</h4>
<p>How about "is isomorphic to Kenny's explicit construction" then?</p>

<a name="155162268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155162268" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155162268">Chris Hughes (Jan 15 2019 at 11:28)</a>:</h4>
<p>The <code>is_quotient </code> class could include a truncated inverse to the quotient map.</p>

<a name="155162293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155162293" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155162293">Kevin Buzzard (Jan 15 2019 at 11:29)</a>:</h4>
<p>I don't even want to use universes. How about I make everything in Type?</p>

<a name="155162297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155162297" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155162297">Mario Carneiro (Jan 15 2019 at 11:29)</a>:</h4>
<p>I think for localization it is something like "there is a surjective map from A x S and some additional about it"</p>

<a name="155162301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155162301" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155162301">Kevin Buzzard (Jan 15 2019 at 11:30)</a>:</h4>
<p>It's much worse than that</p>

<a name="155162351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155162351" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155162351">Kevin Buzzard (Jan 15 2019 at 11:30)</a>:</h4>
<p>It's "it's what Kenny wrote when he defined localisation"</p>

<a name="155162361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155162361" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155162361">Mario Carneiro (Jan 15 2019 at 11:30)</a>:</h4>
<p>you don't need the proofs though</p>

<a name="155162376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155162376" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155162376">Kevin Buzzard (Jan 15 2019 at 11:31)</a>:</h4>
<p>but you probably need to spell out the equivalence relation again</p>

<a name="155162385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155162385" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155162385">Mario Carneiro (Jan 15 2019 at 11:31)</a>:</h4>
<p>you may need the equivalence relation</p>

<a name="155162392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155162392" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155162392">Mario Carneiro (Jan 15 2019 at 11:31)</a>:</h4>
<p>but there may also be a way to characterize it via ideals or something</p>

<a name="155162393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155162393" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155162393">Kevin Buzzard (Jan 15 2019 at 11:31)</a>:</h4>
<p>Kenny's definition of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>[</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>S</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">A[1/S]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">A</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mclose">]</span></span></span></span> is a quotient of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>×</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">A\times S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="base"><span class="mord mathit">A</span><span class="mbin">×</span><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span></span> by an equivalence relation.</p>

<a name="155162394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155162394" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155162394">Mario Carneiro (Jan 15 2019 at 11:31)</a>:</h4>
<p>so that it looks more like a universal property</p>

<a name="155162441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155162441" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155162441">Kevin Buzzard (Jan 15 2019 at 11:32)</a>:</h4>
<p>So the predicate we need is "it satisfies the universal property that the quotient by an equivalence relation satisfies"</p>

<a name="155162453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155162453" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155162453">Mario Carneiro (Jan 15 2019 at 11:32)</a>:</h4>
<p>that is <code>is_quotient</code> the way we are going</p>

<a name="155162454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155162454" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155162454">Kevin Buzzard (Jan 15 2019 at 11:32)</a>:</h4>
<p>Here <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>×</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">A\times S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="base"><span class="mord mathit">A</span><span class="mbin">×</span><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span></span> is little more than a monoid</p>

<a name="155162485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155162485" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155162485">Mario Carneiro (Jan 15 2019 at 11:33)</a>:</h4>
<p>you might also be able to get away with just maps from A -&gt; loc and S -&gt; loc since it's a ring</p>

<a name="155162542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155162542" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155162542">Mario Carneiro (Jan 15 2019 at 11:34)</a>:</h4>
<p>or just what you said - a ring hom A -&gt; loc and an assertion that the image of S are units</p>

<a name="155162773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155162773" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155162773">Mario Carneiro (Jan 15 2019 at 11:39)</a>:</h4>
<p>oh but you still have to say surjective using a map from A x S</p>

<a name="155163051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155163051" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155163051">Mario Carneiro (Jan 15 2019 at 11:45)</a>:</h4>
<p>If you have that situation, and <code>(s₁ * r₂ - s₂ * r₁) * t = 0</code> where <code>t \in S</code>, then mapping across <code>f : A -&gt; loc</code>, you have <code>(f s₁ * f r₂ - f s₂ * f r₁) * f t = 0</code> and <code>f t</code> is invertible so <code>f s₁ * f r₂ = f s₂ * f r₁</code>, and <code>f s₁</code> and <code>f s₂</code> are invertible so <code>f r₁ / f s₁ = f r₂ / f s₂</code>. So this direction is already provable. The other direction can be asserted: if <code>f r₁ / f s₁ = f r₂ / f s₂</code> then there exists <code>t \in S</code> such that <code>(s₁ * r₂ - s₂ * r₁) * t = 0</code></p>

<a name="155179691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155179691" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155179691">Neil Strickland (Jan 15 2019 at 15:49)</a>:</h4>
<p>I have put some stuff about localization at <br>
<a href="https://github.com/NeilStrickland/lean_comm_alg/blob/master/src/localization.lean" target="_blank" title="https://github.com/NeilStrickland/lean_comm_alg/blob/master/src/localization.lean">https://github.com/NeilStrickland/lean_comm_alg/blob/master/src/localization.lean</a><br>
It is not finished, but I would be interested in comments on the general architecture.<br>
The idea is to set things up so that you can make computable maps out of a localisation <br>
if you have enough data, and you can make non-computable maps if you only have<br>
existence statements, and as much stuff as possible is shared between the two cases.</p>

<a name="155182495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155182495" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155182495">Kevin Buzzard (Jan 15 2019 at 16:19)</a>:</h4>
<p>So in your definition of <code>is_localization</code> you do <em>not</em> write "it satisfies the universal property", you instead write down some explicit ring-theoretic criterion following Mario's suggestion that such a criterion should exist.</p>

<a name="155182632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155182632" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155182632">Kevin Buzzard (Jan 15 2019 at 16:21)</a>:</h4>
<p>Whilst I am no Lean expert, I am slightly worried about lines 102-120 because you are defining data in tactic mode, and I think that data constructed in this way usually turns out to be very unwieldy because tactic mode was not really designed for this. Possibly.</p>

<a name="155182775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155182775" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155182775">Patrick Massot (Jan 15 2019 at 16:22)</a>:</h4>
<p>This is totally fake tactic mode, it could be rewritten as a term without any effort.</p>

<a name="155182791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155182791" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155182791">Patrick Massot (Jan 15 2019 at 16:23)</a>:</h4>
<p>I think it also means that writing it as Neil did should be harmless</p>

<a name="155182932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155182932" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155182932">Kevin Buzzard (Jan 15 2019 at 16:24)</a>:</h4>
<p>I totally agree that it's fake tactic mode. I was less sure than you about whether writing it as Neil did would be harmless.</p>

<a name="155182978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155182978" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155182978">Kevin Buzzard (Jan 15 2019 at 16:24)</a>:</h4>
<p>I checked the maths and it seems to me that this does indeed characterise rings isomorphic to the localisation.</p>

<a name="155183026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155183026" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155183026">Kevin Buzzard (Jan 15 2019 at 16:25)</a>:</h4>
<p>I am still a bit unclear as to why one can't just write "it satisfies the universal property", but I've seen this sort of thing be problematic before.</p>

<a name="155183133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155183133" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155183133">Kevin Buzzard (Jan 15 2019 at 16:26)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">submonoid_ann</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">A</span><span class="o">)</span> <span class="o">[</span><span class="n">is_submonoid</span> <span class="n">S</span><span class="o">]</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">A</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">carrier</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">as</span> <span class="o">:</span> <span class="n">ann_aux</span> <span class="n">S</span><span class="o">,</span> <span class="n">as</span><span class="bp">.</span><span class="mi">1</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">=</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">zero</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">ann_aux</span><span class="bp">.</span><span class="n">zero</span> <span class="n">S</span><span class="o">,</span><span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">add</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">⟨⟨⟨</span><span class="n">a</span><span class="o">,</span><span class="n">s</span><span class="bp">⟩</span><span class="o">,</span><span class="n">ea0</span><span class="bp">⟩</span><span class="o">,</span><span class="n">rfl</span><span class="bp">⟩</span> <span class="bp">⟨⟨⟨</span><span class="n">b</span><span class="o">,</span><span class="n">t</span><span class="bp">⟩</span><span class="o">,</span><span class="n">eb0</span><span class="bp">⟩</span><span class="o">,</span><span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">ann_aux</span><span class="bp">.</span><span class="n">add</span> <span class="n">S</span> <span class="bp">⟨⟨</span><span class="n">a</span><span class="o">,</span><span class="n">s</span><span class="bp">⟩</span><span class="o">,</span><span class="n">ea0</span><span class="bp">⟩</span> <span class="bp">⟨⟨</span><span class="n">b</span><span class="o">,</span><span class="n">t</span><span class="bp">⟩</span><span class="o">,</span><span class="n">eb0</span><span class="bp">⟩</span><span class="o">,</span><span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="bp">_</span> <span class="bp">⟨⟨⟨</span><span class="n">b</span><span class="o">,</span><span class="n">t</span><span class="bp">⟩</span><span class="o">,</span><span class="n">eb0</span><span class="bp">⟩</span><span class="o">,</span><span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">ann_aux</span><span class="bp">.</span><span class="n">smul</span> <span class="n">S</span> <span class="n">a</span> <span class="bp">⟨⟨</span><span class="n">b</span><span class="o">,</span><span class="n">t</span><span class="bp">⟩</span><span class="o">,</span><span class="n">eb0</span><span class="bp">⟩</span><span class="o">,</span><span class="k">begin</span> <span class="n">rw</span> <span class="n">ann_aux</span><span class="bp">.</span><span class="n">smul</span><span class="o">,</span><span class="n">refl</span><span class="o">,</span><span class="kn">end</span><span class="bp">⟩</span>
<span class="o">}</span>
</pre></div>

<a name="155183311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155183311" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155183311">Kevin Buzzard (Jan 15 2019 at 16:29)</a>:</h4>
<p>Oh, everything other than <code>carrier</code> is a prop anyway, so i'm really fussing about nothing.</p>

<a name="155183871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155183871" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155183871">Mario Carneiro (Jan 15 2019 at 16:36)</a>:</h4>
<p>By the way, regarding getting this <code>is_localization</code> information around, it can easily be a typeclass (with a not so interesting search problem) and so get this data to where it needs to be</p>

<a name="155184036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155184036" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155184036">Mario Carneiro (Jan 15 2019 at 16:38)</a>:</h4>
<p>Note that <code>has_denom_data</code> is a bit problematic because it is not a subsingleton</p>

<a name="155184467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155184467" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155184467">Kevin Buzzard (Jan 15 2019 at 16:45)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">is_localization_initial</span>
 <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">is_localization_data</span> <span class="n">S</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">C</span><span class="o">)</span> <span class="o">[</span><span class="n">is_ring_hom</span> <span class="n">g</span><span class="o">]</span> <span class="o">(</span><span class="n">hg</span> <span class="o">:</span> <span class="n">inverts_data</span> <span class="n">S</span> <span class="n">g</span><span class="o">)</span>
 <span class="o">:</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">C</span> <span class="o">:=</span>
<span class="k">begin</span>
 <span class="n">intro</span> <span class="n">b</span><span class="o">,</span>
 <span class="n">rcases</span> <span class="o">(</span><span class="n">hf</span><span class="bp">.</span><span class="n">has_denom</span> <span class="n">b</span><span class="o">)</span> <span class="k">with</span> <span class="bp">⟨⟨</span><span class="n">s</span><span class="o">,</span><span class="n">a</span><span class="bp">⟩</span><span class="o">,</span><span class="n">e</span><span class="bp">⟩</span><span class="o">,</span>
 <span class="n">rcases</span> <span class="o">(</span><span class="n">hg</span> <span class="n">s</span><span class="o">)</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">gsi</span><span class="o">,</span><span class="n">e3</span><span class="bp">⟩</span><span class="o">,</span>
 <span class="n">exact</span> <span class="o">(</span><span class="n">g</span> <span class="n">a</span><span class="o">)</span> <span class="bp">*</span> <span class="n">gsi</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p>Here's another place (the only other place?) where Neil uses tactics to define data.</p>

<a name="155184701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155184701" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155184701">Patrick Massot (Jan 15 2019 at 16:49)</a>:</h4>
<p>This is even more fake tactic</p>

<a name="155184944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155184944" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155184944">Neil Strickland (Jan 15 2019 at 16:52)</a>:</h4>
<p>I hadn't heard this kind of deprecation of tactics-for-data before.  It seems to me to be a very natural translation of how I would write definitions in ordinary mathematics.  Is there something that I am missing?</p>

<a name="155185025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155185025" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155185025">Mario Carneiro (Jan 15 2019 at 16:53)</a>:</h4>
<p>tactics tend to produce ugly proof terms, which is fine for proofs (well not really, but that's another discussion) and causes problems for defs, because defs are later unfolded and their definitions matter</p>

<a name="155185094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155185094" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155185094">Mario Carneiro (Jan 15 2019 at 16:54)</a>:</h4>
<p>Some tactics are fine and produce exactly what you expect, like <code>exact</code> and <code>intro</code>, while things like <code>rw</code> and <code>simp</code> are hell to work with</p>

<a name="155185103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155185103" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155185103">Kevin Buzzard (Jan 15 2019 at 16:54)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">is_localization_initial&#39;</span>
 <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">is_localization_data</span> <span class="n">S</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">C</span><span class="o">)</span> <span class="o">[</span><span class="n">is_ring_hom</span> <span class="n">g</span><span class="o">]</span> <span class="o">(</span><span class="n">hg</span> <span class="o">:</span> <span class="n">inverts_data</span> <span class="n">S</span> <span class="n">g</span><span class="o">)</span>
 <span class="o">:</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">C</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">b</span><span class="o">,</span> <span class="n">g</span> <span class="o">(</span><span class="n">hf</span><span class="bp">.</span><span class="n">has_denom</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">*</span> <span class="o">(</span><span class="n">hg</span> <span class="o">(</span><span class="n">hf</span><span class="bp">.</span><span class="n">has_denom</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span>
</pre></div>


<p>This is what I would have written. But I don't understand things well enough to know whether it makes a difference.</p>

<a name="155185125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155185125" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155185125">Kevin Buzzard (Jan 15 2019 at 16:55)</a>:</h4>
<p>Because Neil only used <code>intro</code>, <code>rcases</code> and <code>exact</code> maybe it doesn't matter.</p>

<a name="155185196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155185196" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155185196">Mario Carneiro (Jan 15 2019 at 16:56)</a>:</h4>
<p><code>rcases</code> and <code>cases</code> will use the corresponding <code>cases_on</code> recursor, which is sometimes what you want and sometimes not. We often prefer to use projections when applicable, as in Kevin's version</p>

<a name="155185251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155185251" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155185251">Kevin Buzzard (Jan 15 2019 at 16:57)</a>:</h4>
<p>Neil -- the bottom line is that the sorries you have at the end of the file -- if they are easier to fill in using my suggestion then this is why my suggestion is better, and if they aren't then I'm talking nonsense :-)</p>

<a name="155185363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155185363" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155185363">Mario Carneiro (Jan 15 2019 at 16:58)</a>:</h4>
<p>You could also use <code>let ⟨⟨s,a⟩,e⟩ := hf.has_denom b in ...</code> in place of the <code>rcases</code> application, which is more or less the same but produces an auxiliary definition that you can unfold on command. Sometimes this is good, sometimes not</p>

<a name="155185377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155185377" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155185377">Patrick Massot (Jan 15 2019 at 16:58)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">is_localization_initial</span>
 <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">is_localization_data</span> <span class="n">S</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">C</span><span class="o">)</span> <span class="o">[</span><span class="n">is_ring_hom</span> <span class="n">g</span><span class="o">]</span> <span class="o">(</span><span class="n">hg</span> <span class="o">:</span> <span class="n">inverts_data</span> <span class="n">S</span> <span class="n">g</span><span class="o">)</span>
 <span class="o">:</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">C</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">b</span><span class="o">,</span> <span class="k">let</span> <span class="bp">⟨⟨</span><span class="n">s</span><span class="o">,</span><span class="n">a</span><span class="bp">⟩</span><span class="o">,</span><span class="n">e</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="o">(</span><span class="n">hf</span><span class="bp">.</span><span class="n">has_denom</span> <span class="n">b</span><span class="o">),</span>
         <span class="bp">⟨</span><span class="n">gsi</span><span class="o">,</span><span class="n">e3</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">hg</span> <span class="n">s</span> <span class="k">in</span> <span class="o">(</span><span class="n">g</span> <span class="n">a</span><span class="o">)</span> <span class="bp">*</span> <span class="n">gsi</span>
</pre></div>

<a name="155185387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155185387" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155185387">Patrick Massot (Jan 15 2019 at 16:58)</a>:</h4>
<p>Arg, Mario was faster</p>

<a name="155185412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155185412" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155185412">Patrick Massot (Jan 15 2019 at 16:59)</a>:</h4>
<p><code>set_option eqn_compiler.zeta true</code></p>

<a name="155185527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155185527" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155185527">Patrick Massot (Jan 15 2019 at 17:00)</a>:</h4>
<p>You can also put underscores instead of creating names you won't use</p>

<a name="155185627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155185627" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155185627">Kevin Buzzard (Jan 15 2019 at 17:01)</a>:</h4>
<p>My definition unfolds to <code> g (((hf.has_denom b).val).snd) * (hg (((hf.has_denom b).val).fst)).val</code>, Neil's to</p>
<div class="codehilite"><pre><span></span>subtype.cases_on (hf.has_denom b)
    (λ (val : ↥S × A) (e : f ↑(val.fst) * b = f (val.snd)),
       prod.cases_on val
         (λ (s : ↥S) (a : A) (e : f ↑((s, a).fst) * b = f ((s, a).snd)),
            subtype.cases_on (hg s) (λ (gsi : C) (e3 : g ↑s * gsi = 1), g a * gsi))
         e)
</pre></div>

<a name="155185828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155185828" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155185828">Kevin Buzzard (Jan 15 2019 at 17:04)</a>:</h4>
<p>Patrick's becomes </p>
<div class="codehilite"><pre><span></span> <span class="n">is_localization_initial</span><span class="bp">._</span><span class="n">match_2</span> <span class="n">S</span> <span class="n">f</span> <span class="n">g</span> <span class="n">hg</span> <span class="n">b</span> <span class="o">(</span><span class="n">hf</span><span class="bp">.</span><span class="n">has_denom</span> <span class="n">b</span><span class="o">)</span>
</pre></div>


<p>and <code>is_localization_initial._match_2</code> becomes </p>
<div class="codehilite"><pre><span></span> subtype.cases_on _a
    (λ (val : ↥S × A) (property : f ↑(val.fst) * b = f (val.snd)),
       prod.cases_on val
         (λ (val_fst : ↥S) (val_snd : A) (property : f ↑((val_fst, val_snd).fst) * b = f ((val_fst, val_snd).snd)),
            id_rhs C (is_localization_initial&#39;&#39;._match_1 S g val_fst val_snd (hg val_fst)))
         property)
</pre></div>

<a name="155186036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155186036" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155186036">Patrick Massot (Jan 15 2019 at 17:07)</a>:</h4>
<p>What about the defeq equivalence classes?</p>

<a name="155186066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155186066" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155186066">Mario Carneiro (Jan 15 2019 at 17:07)</a>:</h4>
<p>Patrick's and Neil's definitions should be defeq, but Kevin's is different</p>

<a name="155186115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155186115" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155186115">Neil Strickland (Jan 15 2019 at 17:08)</a>:</h4>
<p>So I have some visible instances of <code>cases_on</code> and you don't.  My guess is that the framework for structures effectively defines  <code>fst</code> and <code>snd</code> in terms of <code>cases_on</code>.  But perhaps that's wrong.  And even if it's right, perhaps it is somehow better to bury the call to <code>cases_on</code> deeper down.  I don't feel that I understand the issues very well here.</p>

<a name="155186134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155186134" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155186134">Kevin Buzzard (Jan 15 2019 at 17:08)</a>:</h4>
<p>Me neither, that's why I brought it up here.</p>

<a name="155186162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155186162" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155186162">Mario Carneiro (Jan 15 2019 at 17:09)</a>:</h4>
<p>Technically the projections are defined in terms of cases_on, but they are buried really deep and lean has special support for them</p>

<a name="155186224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155186224" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155186224">Kevin Buzzard (Jan 15 2019 at 17:09)</a>:</h4>
<p>The <code>rcases</code> tactic is getting from <code>&lt;b,c&gt;</code> to <code>b</code> and <code>c</code> using <code>cases_on</code>, whereas my direct approach is going from <code>a:=&lt;b,c&gt;</code> to <code>b</code> using <code>a.1</code>. But you're saying that <code>a.1</code> is defined using <code>cases_on</code> anyway?</p>

<a name="155186273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155186273" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155186273">Mario Carneiro (Jan 15 2019 at 17:10)</a>:</h4>
<p>But it is useful to do the cases late rather than at the beginning because then you can prove things about the shape of the expression even when it's not a pair or whatever</p>

<a name="155186357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155186357" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155186357">Mario Carneiro (Jan 15 2019 at 17:11)</a>:</h4>
<p>To take a simpler example, we've discussed the difference between the definitions </p>
<div class="codehilite"><pre><span></span>prod.map (f : A -&gt; C) (g : B -&gt; D) : A x B -&gt; C x D | &lt;a, b&gt; := &lt;f a, g b&gt;
</pre></div>


<p>and</p>
<div class="codehilite"><pre><span></span>prod.map (f : A -&gt; C) (g : B -&gt; D) : A x B -&gt; C x D := \lam p : A x B, &lt;f p.1, g p.2&gt;
</pre></div>

<a name="155186509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155186509" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155186509">Mario Carneiro (Jan 15 2019 at 17:13)</a>:</h4>
<p>The advantage of the second definition is that <code>prod.map f g p</code> already unfolds to a pair, while the first definition does not</p>

<a name="155186541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155186541" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155186541">Mario Carneiro (Jan 15 2019 at 17:13)</a>:</h4>
<p>In both cases <code>prod.map f g &lt;a, b&gt; = &lt;f a, g b&gt;</code> is definitional</p>

<a name="155186643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155186643" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155186643">Mario Carneiro (Jan 15 2019 at 17:14)</a>:</h4>
<p>So as an application <code>(prod.map f g p).1 = f p.1</code> is definitional only with the second definition</p>

<a name="155188586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155188586" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155188586">Kevin Buzzard (Jan 15 2019 at 17:43)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">instance</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">is_localization_data</span> <span class="n">S</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">C</span><span class="o">)</span> <span class="o">[</span><span class="n">is_ring_hom</span> <span class="n">g</span><span class="o">]</span> <span class="o">(</span><span class="n">hg</span> <span class="o">:</span> <span class="n">inverts_data</span> <span class="n">S</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span>
 <span class="n">is_ring_hom</span> <span class="o">(</span><span class="n">is_localization_initial</span> <span class="n">S</span> <span class="n">f</span> <span class="n">hf</span> <span class="n">g</span> <span class="n">hg</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">map_one</span> <span class="o">:=</span> <span class="k">begin</span>
    <span class="n">unfold</span> <span class="n">is_localization_initial</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="o">(</span><span class="n">hf</span><span class="bp">.</span><span class="n">has_denom</span> <span class="mi">1</span><span class="o">)</span> <span class="k">with</span> <span class="bp">⟨⟨</span><span class="n">s</span><span class="o">,</span><span class="n">a</span><span class="bp">⟩</span><span class="o">,</span><span class="n">h</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="k">show</span> <span class="n">g</span> <span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="n">hg</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">,</span>
    <span class="n">change</span> <span class="n">f</span> <span class="n">s</span> <span class="bp">*</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">a</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">mul_one</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h2</span> <span class="o">:=</span> <span class="o">(</span><span class="n">hg</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">property</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h3</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">-</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">ker</span> <span class="n">f</span><span class="o">,</span>
      <span class="k">show</span> <span class="n">f</span> <span class="o">(</span><span class="n">a</span> <span class="bp">-</span> <span class="n">s</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">is_ring_hom</span><span class="bp">.</span><span class="n">map_sub</span> <span class="n">f</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">sub_self</span><span class="o">,</span>
    <span class="n">suffices</span> <span class="o">:</span> <span class="n">g</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">g</span> <span class="n">s</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">this</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">h2</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h4</span> <span class="o">:=</span> <span class="n">hf</span><span class="bp">.</span><span class="n">ker_eq</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">h4</span> <span class="n">at</span> <span class="n">h3</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">h3</span> <span class="k">with</span> <span class="n">t</span> <span class="n">Ht</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">t</span> <span class="k">with</span> <span class="bp">⟨⟨</span><span class="n">b</span><span class="o">,</span><span class="n">t</span><span class="bp">⟩</span><span class="o">,</span><span class="n">h5</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">change</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">-</span> <span class="n">s</span> <span class="n">at</span> <span class="n">Ht</span><span class="o">,</span>
    <span class="n">change</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">t</span> <span class="bp">=</span> <span class="mi">0</span> <span class="n">at</span> <span class="n">h5</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">Ht</span> <span class="n">at</span> <span class="n">h5</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">sub_mul</span> <span class="n">at</span> <span class="n">h5</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">sub_eq_zero</span> <span class="n">at</span> <span class="n">h5</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h6</span> <span class="o">:</span> <span class="n">g</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">t</span><span class="o">)</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">(</span><span class="n">s</span> <span class="bp">*</span> <span class="n">t</span><span class="o">),</span>
      <span class="n">rw</span> <span class="n">h5</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">is_ring_hom</span><span class="bp">.</span><span class="n">map_mul</span> <span class="n">g</span> <span class="n">at</span> <span class="n">h6</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">is_ring_hom</span><span class="bp">.</span><span class="n">map_mul</span> <span class="n">g</span> <span class="n">at</span> <span class="n">h6</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">hg</span> <span class="n">t</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">u</span><span class="o">,</span><span class="n">hu</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="k">calc</span> <span class="n">g</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">g</span> <span class="n">a</span> <span class="bp">*</span> <span class="mi">1</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">mul_one</span>
    <span class="bp">...</span>      <span class="bp">=</span> <span class="n">g</span> <span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="n">g</span> <span class="n">t</span> <span class="bp">*</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">hu</span>
    <span class="bp">...</span>      <span class="bp">=</span> <span class="o">(</span><span class="n">g</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">g</span> <span class="n">t</span><span class="o">)</span> <span class="bp">*</span> <span class="n">u</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">mul_assoc</span>
    <span class="bp">...</span>      <span class="bp">=</span> <span class="o">(</span><span class="n">g</span> <span class="n">s</span> <span class="bp">*</span> <span class="n">g</span> <span class="n">t</span><span class="o">)</span> <span class="bp">*</span> <span class="n">u</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">h6</span>
    <span class="bp">...</span>      <span class="bp">=</span> <span class="n">g</span> <span class="n">s</span> <span class="bp">*</span> <span class="o">(</span><span class="n">g</span> <span class="n">t</span> <span class="bp">*</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">mul_assoc</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">g</span> <span class="n">s</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">hu</span><span class="o">,</span><span class="n">mul_one</span><span class="o">]</span>
  <span class="kn">end</span><span class="o">,</span>
<span class="bp">...</span>
</pre></div>


<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> can you do any better?</p>

<a name="155188663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155188663" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155188663">Patrick Massot (Jan 15 2019 at 17:44)</a>:</h4>
<p>My bet: yes.</p>

<a name="155188685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155188685" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155188685">Kevin Buzzard (Jan 15 2019 at 17:44)</a>:</h4>
<p>I wondered whether he would just answer "yes" and leave it at that :-)</p>

<a name="155188753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155188753" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155188753">Chris Hughes (Jan 15 2019 at 17:45)</a>:</h4>
<blockquote>
<p>Technically the projections are defined in terms of cases_on, but they are buried really deep and lean has special support for them</p>
</blockquote>
<p>Why doesn't this work?</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span><span class="bp">.</span><span class="n">fst</span> <span class="bp">=</span> <span class="n">prod</span><span class="bp">.</span><span class="n">rec</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">-- doesn&#39;t work</span>
</pre></div>

<a name="155188758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155188758" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155188758">Kevin Buzzard (Jan 15 2019 at 17:45)</a>:</h4>
<p>The question boils down to proving that if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>a</mi><mo>)</mo><mo>=</mo><mi>f</mi><mo>(</mo><mi>s</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(a)=f(s)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">s</span><span class="mclose">)</span></span></span></span> then <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>(</mo><mi>a</mi><mo>)</mo><mo>=</mo><mi>g</mi><mo>(</mo><mi>s</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">g(a)=g(s)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathit">s</span><span class="mclose">)</span></span></span></span>, which looks suspicious until you realise that we know something about the kernel of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span></span>, namely that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>(</mo><mi>a</mi><mo>−</mo><mi>s</mi><mo>)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">t(a-s)=0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">t</span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mbin">−</span><span class="mord mathit">s</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathrm">0</span></span></span></span> for some <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>∈</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">t\in S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="base"><span class="mord mathit">t</span><span class="mrel">∈</span><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span></span>; the fact that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>(</mo><mi>t</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">g(t)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathit">t</span><span class="mclose">)</span></span></span></span> is also a unit is what gets us home.</p>

<a name="155188921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155188921" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155188921">Kevin Buzzard (Jan 15 2019 at 17:47)</a>:</h4>
<p>Actually I think Kenny would far rather refactor my proof than write his own.</p>

<a name="155190260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155190260" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155190260">Gabriel Ebner (Jan 15 2019 at 18:06)</a>:</h4>
<p><span class="user-mention" data-user-id="110044">@Chris Hughes</span> Lean has two type checkers: the kernel and the type context.  The kernel is the small low-level one, and the type context is the high-level one used for tactics, etc., which also supports unification, type class inference, etc.  The kernel only does the final check when you add a theorem to the environment.  Now, the kernel knows that prod.fst is defined in terms of rec, but the type context pretends projections are opaque definitions that only reduce when applied to the <code>mk</code> constructor.  With a bit of creativity (i.e., circumventing the type context), you can still prove your example using just rfl:</p>
<div class="codehilite"><pre><span></span><span class="n">run_cmd</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">add_decl</span> <span class="err">$</span> <span class="n">declaration</span><span class="bp">.</span><span class="n">thm</span> <span class="bp">`</span><span class="n">prod</span><span class="bp">.</span><span class="n">fst_def</span> <span class="o">[]</span>
    <span class="bp">`</span><span class="o">(</span><span class="bp">∀</span> <span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">,</span> <span class="n">x</span><span class="bp">.</span><span class="n">fst</span> <span class="bp">=</span> <span class="n">prod</span><span class="bp">.</span><span class="n">rec</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span> <span class="n">x</span><span class="o">)</span>
    <span class="o">(</span><span class="n">pure</span> <span class="bp">`</span><span class="o">(</span><span class="bp">λ</span> <span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">,</span> <span class="n">eq</span><span class="bp">.</span><span class="n">refl</span> <span class="n">x</span><span class="bp">.</span><span class="n">fst</span><span class="o">))</span>
<span class="n">attribute</span> <span class="o">[</span><span class="bp">_</span><span class="n">refl_lemma</span><span class="o">]</span> <span class="n">prod</span><span class="bp">.</span><span class="n">fst_def</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">prod</span><span class="bp">.</span><span class="n">fst_def</span>
</pre></div>

<a name="155190559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155190559" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155190559">Kenny Lau (Jan 15 2019 at 18:10)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> mwe?</p>

<a name="155190610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155190610" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155190610">Kevin Buzzard (Jan 15 2019 at 18:11)</a>:</h4>
<p>Ramon and me just isolated a lemma, and we now know how to prove <code>is_ring_hom (is_localization_initial S f hf g hg)</code></p>

<a name="155191027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155191027" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155191027">Kevin Buzzard (Jan 15 2019 at 18:16)</a>:</h4>
<p>The lemma is that if <code>is_localization_data S f</code> and <code>inverts_data S g</code> then <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>a</mi><mo>)</mo><mo>=</mo><mi>f</mi><mo>(</mo><mi>b</mi><mo>)</mo><mspace width="0.277778em"></mspace><mo>⟹</mo><mspace width="0.277778em"></mspace><mi>g</mi><mo>(</mo><mi>a</mi><mo>)</mo><mo>=</mo><mi>g</mi><mo>(</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(a)=f(b)\implies g(a)=g(b)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">b</span><span class="mclose">)</span><span class="mrel"><span class="mspace thickspace"></span><span class="mrel">⟹</span></span><span class="mord mathit"><span class="mspace thickspace"></span><span class="mord mathit" style="margin-right:0.03588em;">g</span></span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathit">b</span><span class="mclose">)</span></span></span></span></p>

<a name="155191153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155191153" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155191153">Kevin Buzzard (Jan 15 2019 at 18:18)</a>:</h4>
<p>and the proof is that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>−</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a-b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="base"><span class="mord mathit">a</span><span class="mbin">−</span><span class="mord mathit">b</span></span></span></span> is in the kernel of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span></span> so by <code>ker_eq</code> on <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span></span> we know <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>(</mo><mi>a</mi><mo>−</mo><mi>b</mi><mo>)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">s(a-b)=0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">s</span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mbin">−</span><span class="mord mathit">b</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathrm">0</span></span></span></span> for some <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>∈</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">s\in S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="base"><span class="mord mathit">s</span><span class="mrel">∈</span><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span></span>; hence <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>(</mo><mi>s</mi><mi>a</mi><mo>)</mo><mo>=</mo><mi>g</mi><mo>(</mo><mi>s</mi><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">g(sa)=g(sb)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathit">s</span><span class="mord mathit">a</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathit">s</span><span class="mord mathit">b</span><span class="mclose">)</span></span></span></span>, but we can cancel <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>(</mo><mi>s</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">g(s)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathit">s</span><span class="mclose">)</span></span></span></span> because of <code>inverts_data S</code></p>

<a name="155191167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155191167" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155191167">Kevin Buzzard (Jan 15 2019 at 18:18)</a>:</h4>
<p>Everything now follows after some algebra</p>

<a name="155194135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155194135" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155194135">Kevin Buzzard (Jan 15 2019 at 18:54)</a>:</h4>
<blockquote>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> mwe?</p>
</blockquote>
<p><a href="https://gist.github.com/kbuzzard/b40f8501b311ada3e42b1314f2c0426c" target="_blank" title="https://gist.github.com/kbuzzard/b40f8501b311ada3e42b1314f2c0426c">https://gist.github.com/kbuzzard/b40f8501b311ada3e42b1314f2c0426c</a></p>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span>  -- what is going on here is that Neil has defined a predicate <code>is_localisation f S</code> where <code>f:A -&gt; B</code> and <code>S : set A</code>; the predicate is true iff B is isomorphic to A[1/S]. I just wanted to write the universal property (for all C, if I have h:A -&gt; C such that h(s) is invertible for all s then there's a unique B -&gt; C making the diagram commute) but Mario seems to think that there are universe issues with this approach. Neil has taken a completely different approach, noting that given f : A -&gt; B and the hypothesis that f(s) is a unit for all s in S implies that there's a map A x S - &gt;B sending (a,s) to f(a)/f(s). The claim is that B = A[1/S] in the maths sense iff this map A x S -&gt; B is surjective and the kernel of f : A -&gt; B is the a such that there's s with a*s=0. This is not proved in the file but looks OK to me -- the hypothesis gives a map A[1/S] -&gt; B, the surjectivity claim implies it's surjective, and the kernel claim implies that it's injective.</p>

<a name="155194402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155194402" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155194402">Kevin Buzzard (Jan 15 2019 at 18:57)</a>:</h4>
<p>I think <span class="user-mention" data-user-id="132858">@Ramon Fernandez Mir</span> might fill in the proofs. I guess we also need that <code>A -&gt; loc A S</code> satisfies the predicate -- this might be something which would be easier for you to do.</p>

<a name="155194489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155194489" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155194489">Chris Hughes (Jan 15 2019 at 18:58)</a>:</h4>
<p>The universal property is actually more like (forall u: universe, forall C : Type u, ...), but this predicate isn't definable in Lean, so you have to find an equivalent things that doesn't quantify over universes.</p>

<a name="155194523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155194523" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155194523">Kevin Buzzard (Jan 15 2019 at 18:59)</a>:</h4>
<p>Right -- so I just want to quantify over the universe that A and S are in.</p>

<a name="155194567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155194567" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155194567">Kevin Buzzard (Jan 15 2019 at 18:59)</a>:</h4>
<p>Because that's what I do in real live maths in ZFC with no universes -- this "stick to one universe" approach doesn't usually cause me problems.</p>

<a name="155195578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155195578" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155195578">Reid Barton (Jan 15 2019 at 19:12)</a>:</h4>
<p>Surely we can prove that the universal property for one universe (if chosen correctly) implies it for all universes, which is a statement we can write down because it only involves prefix quantification of universes, and we can apply it wherever needed when applying the universal property.<br>
(The proof can be that we already constructed the localization within the original universe, so another candidate which has the universal property within that universe must be isomorphic to it, and we know the localization we constructed actually has the universal property for all universes.)</p>

<a name="155196737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155196737" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155196737">Kevin Buzzard (Jan 15 2019 at 19:25)</a>:</h4>
<p>I just came here to say the same thing. What is wrong with this strategy? Somehow Neil's version seems cleaner though.</p>

<a name="155197181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155197181" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155197181">Reid Barton (Jan 15 2019 at 19:31)</a>:</h4>
<p>The test case would be to prove that a composition of <code>is_localization</code> maps is <code>is_localization</code></p>

<a name="155197249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155197249" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155197249">Reid Barton (Jan 15 2019 at 19:32)</a>:</h4>
<p>which should be easy with the universal property</p>

<a name="155197619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155197619" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155197619">Neil Strickland (Jan 15 2019 at 19:38)</a>:</h4>
<p>Here are some basic test cases:<br>
1. Can we identity <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>[</mo><msup><mi>a</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>]</mo><mo>[</mo><msup><mi>b</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>]</mo></mrow><annotation encoding="application/x-tex">A[a^{-1}][b^{-1}]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">A</span><span class="mopen">[</span><span class="mord"><span class="mord mathit">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathrm mtight">1</span></span></span></span></span></span></span></span></span><span class="mclose">]</span><span class="mopen">[</span><span class="mord"><span class="mord mathit">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathrm mtight">1</span></span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> with <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>[</mo><mo>(</mo><mi>a</mi><mi>b</mi><msup><mo>)</mo><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>]</mo></mrow><annotation encoding="application/x-tex">A[(ab)^{-1}]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">A</span><span class="mopen">[</span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mord mathit">b</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathrm mtight">1</span></span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>?<br>
2. If <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>e</mi><mn>2</mn></msup><mo>=</mo><mi>e</mi></mrow><annotation encoding="application/x-tex">e^2=e</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathit">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">2</span></span></span></span></span></span></span></span><span class="mrel">=</span><span class="mord mathit">e</span></span></span></span>, can we identify <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>[</mo><msup><mi>e</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>]</mo></mrow><annotation encoding="application/x-tex">A[e^{-1}]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">A</span><span class="mopen">[</span><span class="mord"><span class="mord mathit">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathrm mtight">1</span></span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> with <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi mathvariant="normal">/</mi><mo>(</mo><mn>1</mn><mo>−</mo><mi>e</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">A/(1-e)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">A</span><span class="mord mathrm">/</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mbin">−</span><span class="mord mathit">e</span><span class="mclose">)</span></span></span></span>?<br>
3. If we define <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="double-struck">Z</mi><mrow><mo>(</mo><mi>p</mi><mo>)</mo></mrow></msub></mrow><annotation encoding="application/x-tex">\mathbb{Z}_{(p)}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68889em;"></span><span class="strut bottom" style="height:1.04409em;vertical-align:-0.3551999999999999em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathbb">Z</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathit mtight">p</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"></span></span></span></span></span></span></span></span> as a subring of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="double-struck">Q</mi></mrow></mrow><annotation encoding="application/x-tex">\mathbb{Q}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68889em;"></span><span class="strut bottom" style="height:0.85556em;vertical-align:-0.16667em;"></span><span class="base"><span class="mord"><span class="mord mathbb">Q</span></span></span></span></span>, can we produce the ring map <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="double-struck">Z</mi><mrow><mo>(</mo><mi>p</mi><mo>)</mo></mrow></msub><mo>→</mo><mrow><mi mathvariant="double-struck">Z</mi></mrow><mi mathvariant="normal">/</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}_{(p)}\to\mathbb{Z}/p</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.1052em;vertical-align:-0.3551999999999999em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathbb">Z</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathit mtight">p</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"></span></span></span></span></span><span class="mrel">→</span><span class="mord"><span class="mord mathbb">Z</span></span><span class="mord mathrm">/</span><span class="mord mathit">p</span></span></span></span>?<br>
I think that all of the maps implicit in these examples should be computable under very mild assumptions.</p>

<a name="155198610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155198610" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155198610">Mario Carneiro (Jan 15 2019 at 19:51)</a>:</h4>
<p>there is nothing wrong with Reid's strategy, it's just less direct and possibly leads to worse defeqs</p>

<a name="155198991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155198991" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155198991">Kevin Buzzard (Jan 15 2019 at 19:57)</a>:</h4>
<p>Neil's test 1 came up a lot in the schemes repo.</p>
<p>I guess the idea that everything should be proved constructively and then we just deduce the classical stuff from it.</p>

<a name="155198995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155198995" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155198995">Reid Barton (Jan 15 2019 at 19:57)</a>:</h4>
<p>Yeah, if you want the constructive version then it's not as nice.</p>

<a name="155199105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155199105" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155199105">Mario Carneiro (Jan 15 2019 at 19:58)</a>:</h4>
<p>Do we care about being constructive here? At the very least I would want any constructive version to be a subsingleton like <code>fintype</code></p>

<a name="155199157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155199157" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155199157">Mario Carneiro (Jan 15 2019 at 19:59)</a>:</h4>
<p>also, why the sudden focus on localization? I think the quotient case is far more prevalent and pressing</p>

<a name="155199480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155199480" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155199480">Mario Carneiro (Jan 15 2019 at 20:03)</a>:</h4>
<p>I think the constructive version should use an indexed family rather than a set S</p>

<a name="155199591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155199591" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155199591">Mario Carneiro (Jan 15 2019 at 20:04)</a>:</h4>
<p>That is, <code>S</code> should be the image of a monoid hom rather than a submonoid</p>

<a name="155199598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155199598" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155199598">Kevin Buzzard (Jan 15 2019 at 20:04)</a>:</h4>
<p>because we're refactoring the schemes repo and we had just been trying to make sense of the stuff I wrote about universal properties of localisation, that's why I jumped on this. I had arranged to meet Ramon at 4pm today and Neil's post arrived shortly beforehand so I thought it was a really good time to understand this alternative approach. I think it's beautiful!</p>

<a name="155199631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155199631" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155199631">Kevin Buzzard (Jan 15 2019 at 20:05)</a>:</h4>
<p>I think that S should be an arbitrary set, and we should localise at the monoid generated by S.</p>

<a name="155199727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155199727" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155199727">Mario Carneiro (Jan 15 2019 at 20:06)</a>:</h4>
<p>I mean that for constructive purposes you want S to be enumerated by a concrete structure (the domain of the monoid hom). Predicates have no data</p>

<a name="155199740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155199740" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155199740">Kevin Buzzard (Jan 15 2019 at 20:06)</a>:</h4>
<p>Neil was already doing this with <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>[</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>a</mi><mi>b</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">A[1/ab]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">A</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mord mathrm">/</span><span class="mord mathit">a</span><span class="mord mathit">b</span><span class="mclose">]</span></span></span></span> etc. When I was doing schemes I had <code>loc A S</code> and then <code>loc A (powers f)</code> came up so much that Kenny made a bunch of lemmas for it. I am now beginning to wonder whether we should be working in this generality in general.</p>

<a name="155199766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155199766" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155199766">Mario Carneiro (Jan 15 2019 at 20:06)</a>:</h4>
<p>Of course for <code>powers f</code> the indexing monoid is just N</p>

<a name="155199803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155199803" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155199803">Kevin Buzzard (Jan 15 2019 at 20:07)</a>:</h4>
<p>I think that demanding that S is a monoid is a pain, because Neil wants me to check that f(s) is invertible for all s in S, and in the case S=&lt;x&gt; I only want to check that f(x) is invertible.</p>

<a name="155199821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155199821" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155199821">Kevin Buzzard (Jan 15 2019 at 20:07)</a>:</h4>
<p>Sorry for over-use of f there.</p>

<a name="155199903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155199903" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155199903">Mario Carneiro (Jan 15 2019 at 20:08)</a>:</h4>
<p>If S = &lt;x&gt; then the analogous monoid hom is <code>\lam n, add_monoid.smul n x</code> (which we know is a monoid hom, I think)</p>

<a name="155199988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155199988" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155199988">Kevin Buzzard (Jan 15 2019 at 20:09)</a>:</h4>
<p>It also occurred to me that we could just set everything up with monoids, and then write different functions for arbitrary subsets. Mario is suggesting a different generalisation though.</p>

<a name="155200767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155200767" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155200767">Mario Carneiro (Jan 15 2019 at 20:19)</a>:</h4>
<p>I think if we actually want to do this we should forget about computation for now, or until we have an actual application</p>

<a name="155201534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155201534" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155201534">Reid Barton (Jan 15 2019 at 20:30)</a>:</h4>
<p>By the way, what happens in the noncommutative case? Is there anything to write down simpler than "the map from the localization is an isomorphism"?</p>

<a name="155203076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155203076" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155203076">Patrick Massot (Jan 15 2019 at 20:50)</a>:</h4>
<p>The real test case for localization is decimal numbers. Can mathlib handle schoolkid maths?</p>

<a name="155203475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155203475" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155203475">Mario Carneiro (Jan 15 2019 at 20:55)</a>:</h4>
<p>noncommutative fields of fractions are really complicated</p>

<a name="155203525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155203525" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155203525">Mario Carneiro (Jan 15 2019 at 20:56)</a>:</h4>
<p>see <a href="https://en.wikipedia.org/wiki/Ore_condition" target="_blank" title="https://en.wikipedia.org/wiki/Ore_condition">https://en.wikipedia.org/wiki/Ore_condition</a></p>

<a name="155206004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155206004" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155206004">Kevin Buzzard (Jan 15 2019 at 21:29)</a>:</h4>
<p>Eew yeah. We number theorists had to learn this stuff about a decade ago when non-commutative Iwasawa theory became a thing.</p>

<a name="155231190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155231190" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155231190">Kenny Lau (Jan 16 2019 at 06:04)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> <a href="https://github.com/kckennylau/Lean/blob/master/localization_alt.lean" target="_blank" title="https://github.com/kckennylau/Lean/blob/master/localization_alt.lean">https://github.com/kckennylau/Lean/blob/master/localization_alt.lean</a></p>

<a name="155241502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155241502" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155241502">Patrick Massot (Jan 16 2019 at 10:00)</a>:</h4>
<p>Neil, your file has been Kennied™.</p>

<a name="155242270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155242270" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155242270">Neil Strickland (Jan 16 2019 at 10:14)</a>:</h4>
<p>That's great, thanks to <span class="user-mention" data-user-id="110064">@Kenny Lau</span> .  I am also working on a slightly different framework which I will report on later.</p>

<a name="155245575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/155245575" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#155245575">Kevin Buzzard (Jan 16 2019 at 11:13)</a>:</h4>
<p>Many thanks <span class="user-mention" data-user-id="110064">@Kenny Lau</span> ! Neil, you might either find it instructive to see how Kenny rewired your code, or intimidating, depending on how much you can make sense of it I guess. Kenny will have liked your approach because he is at heart a constructivist.</p>

<a name="157621262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/157621262" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#157621262">Kevin Buzzard (Feb 05 2019 at 17:03)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> <span class="user-mention" data-user-id="130308">@Neil Strickland</span> I think that demanding that S is a submonoid of A is too restrictive. When I told Kenny to develop the theory of localisations of rings at multiplicative sets it was something like November 2017 and I knew nothing about Lean. I told him to assume S was multiplicative because that's what it says in the books. But I can localise A at an arbitrary subset S, just by localising at the monoid generated by S. </p>
<p>Kenny, when I delete <code>is_submonoid S</code> your code above breaks :-)</p>

<a name="157622801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cardinality%20of%20integers%20modulo%20n/near/157622801" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/62825cardinalityofintegersmodulon.html#157622801">Neil Strickland (Feb 05 2019 at 17:24)</a>:</h4>
<p>You can see the version that I am working on sporadically at <a href="https://github.com/NeilStrickland/lean_comm_alg/blob/master/src/localization_b.lean" target="_blank" title="https://github.com/NeilStrickland/lean_comm_alg/blob/master/src/localization_b.lean">https://github.com/NeilStrickland/lean_comm_alg/blob/master/src/localization_b.lean</a></p>
<ul>
<li>I did it for semirings rather than rings.  There are some applications of that kind of thing in stable homotopy theory.</li>
<li>I have a monoid <code>S</code> with a map <code>i</code> to the multiplicative monoid of <code>R</code>, rather than a submonoid.  That's a structure that you want for log geometry anyway, and seems more natural for some other reasons as well.  </li>
<li>We can regard <code>R × S</code> as the set of unreduced fractions.  This already has commutative and associative addition and multiplication, and the distributive laws fail in a well-controlled way.  To make everything as computable as possible, there are some advantages to setting up this structure explicitly.  So I do that.</li>
<li>I did everything in a very bundled way.  I felt forced to do that because of some technical issue about the way that things depend on the map <code>i : S → R</code>, but I'm not sure I can reconstruct the details of that.</li>
<li>If you want to localise with respect to something that is not a monoid, I think that it is better to do that as a separate construction layered on top of the monoid case.</li>
</ul>
<p>There is plenty left to do but I haven't had time to look at it for a while.  However, we will start running a working group in Sheffield next week, so I can maybe get some more people involved.</p>


{% endraw %}

{% include archive_update.html %}