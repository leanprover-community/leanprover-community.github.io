---
layout: archive
title: Lean Prover Zulip Chat Archive 
permalink: archive/116395maths/46336CauchyrealsDedekindreals.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html">Cauchy reals = Dedekind reals?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="169220141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169220141" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169220141">Kevin Buzzard (Jun 28 2019 at 12:29)</a>:</h4>
<p>Is the equivalence between reals as Cauchy sequences and reals as Dedekind cuts computable?</p>

<a name="169220337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169220337" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169220337">Chris Hughes (Jun 28 2019 at 12:31)</a>:</h4>
<p>You can go from Cauchy sequences to Dedekind, but not the other way.</p>

<a name="169220533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169220533" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169220533">Mario Carneiro (Jun 28 2019 at 12:34)</a>:</h4>
<p>Why this should be "obvious": A cauchy sequence is a function <code>N -&gt; Q</code> (with some properties, under a quotient), which is a computable thing. A dedekind cut is a <code>set Q</code> (with some properties), which has no computable content. So one should expect to be able to go from cauchy to dedekind but not the other way, and more generally there are <em>no</em> computable functions on dedekind cuts that produce any interesting data (like a boolean value)</p>

<a name="169220588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169220588" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169220588">Kevin Buzzard (Jun 28 2019 at 12:35)</a>:</h4>
<p>Yeah I don't follow this argument at all yet. I'm still clearly not thinking about computability in the right way.</p>

<a name="169220675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169220675" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169220675">Kevin Buzzard (Jun 28 2019 at 12:36)</a>:</h4>
<p>If you'd said that a Cauchy Sequence is a function N -&gt; Q which has no computable content, and a Dedekind cut is a set Q which is a computable thing, I would be equally accepting.</p>

<a name="169220701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169220701" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169220701">Kevin Buzzard (Jun 28 2019 at 12:36)</a>:</h4>
<p>I have no idea what "computable content" means.</p>

<a name="169220702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169220702" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169220702">Mario Carneiro (Jun 28 2019 at 12:36)</a>:</h4>
<p>A function N -&gt; Q has a VM representation. You can call it on 42 to get some actual number</p>

<a name="169220722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169220722" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169220722">Kevin Buzzard (Jun 28 2019 at 12:37)</a>:</h4>
<p>Aah, the VM. This will be why I have no idea what you're talking about. I have no idea what the VM is.</p>

<a name="169220728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169220728" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169220728">Mario Carneiro (Jun 28 2019 at 12:37)</a>:</h4>
<p>Given a different function, you could call it on 42 to get a different number</p>

<a name="169220762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169220762" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169220762">Mario Carneiro (Jun 28 2019 at 12:37)</a>:</h4>
<p>so it has to track these things</p>

<a name="169220770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169220770" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169220770">Kevin Buzzard (Jun 28 2019 at 12:37)</a>:</h4>
<p>I understand now that functions can eliminate to data.</p>

<a name="169220779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169220779" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169220779">Mario Carneiro (Jun 28 2019 at 12:37)</a>:</h4>
<p>so functions are data</p>

<a name="169220838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169220838" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169220838">Mario Carneiro (Jun 28 2019 at 12:38)</a>:</h4>
<p>But functions that eliminate to Prop are not data</p>

<a name="169220842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169220842" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169220842">Kevin Buzzard (Jun 28 2019 at 12:38)</a>:</h4>
<blockquote>
<p>so functions are data</p>
</blockquote>
<p>I guess so. They have type <code>X -&gt; Y</code> which has type <code>Type u</code> for some u</p>

<a name="169220856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169220856" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169220856">Mario Carneiro (Jun 28 2019 at 12:38)</a>:</h4>
<p>so <code>set Q = Q -&gt; Prop</code> is not data</p>

<a name="169220863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169220863" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169220863">Mario Carneiro (Jun 28 2019 at 12:38)</a>:</h4>
<p>even though classically it's nontrivial</p>

<a name="169220886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169220886" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169220886">Kevin Buzzard (Jun 28 2019 at 12:38)</a>:</h4>
<p>I can't ever get a number out of a Dedekind cut?</p>

<a name="169220891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169220891" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169220891">Mario Carneiro (Jun 28 2019 at 12:39)</a>:</h4>
<p>no</p>

<a name="169220905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169220905" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169220905">Kevin Buzzard (Jun 28 2019 at 12:39)</a>:</h4>
<p>Hold on, I need to play with <code>#check</code> for a second.</p>

<a name="169220913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169220913" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169220913">Mario Carneiro (Jun 28 2019 at 12:39)</a>:</h4>
<p>I mean you can get 42 out but if you do then every other real will also give 42</p>

<a name="169220980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169220980" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169220980">Mario Carneiro (Jun 28 2019 at 12:40)</a>:</h4>
<p>there is no "distinguishable" data in a Prop, or a Q -&gt; Prop, or a subtype of Q -&gt; Prop, or a quotient of a subtype of Q -&gt; Prop</p>

<a name="169220981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169220981" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169220981">Kevin Buzzard (Jun 28 2019 at 12:40)</a>:</h4>
<p><code>ℕ → Prop : Type</code></p>

<a name="169221006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169221006" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169221006">Mario Carneiro (Jun 28 2019 at 12:40)</a>:</h4>
<p>Yet it's in <code>Type</code></p>

<a name="169221013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169221013" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169221013">Kevin Buzzard (Jun 28 2019 at 12:40)</a>:</h4>
<p><code>ℕ → ℕ : Type</code></p>

<a name="169221021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169221021" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169221021">Mario Carneiro (Jun 28 2019 at 12:40)</a>:</h4>
<p>Lean thinks there's data in there</p>

<a name="169221028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169221028" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169221028">Mario Carneiro (Jun 28 2019 at 12:40)</a>:</h4>
<p>you can prove it's not a singleton</p>

<a name="169221032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169221032" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169221032">Mario Carneiro (Jun 28 2019 at 12:40)</a>:</h4>
<p>but you can't compute with it</p>

<a name="169221044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169221044" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169221044">Kevin Buzzard (Jun 28 2019 at 12:41)</a>:</h4>
<p>So knowing where in the "type hierarchy" something lives is not good enough for me to figure out whether something "has computable content".</p>

<a name="169221054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169221054" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169221054">Mario Carneiro (Jun 28 2019 at 12:41)</a>:</h4>
<p>Unfortunately no</p>

<a name="169221066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169221066" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169221066">Mario Carneiro (Jun 28 2019 at 12:41)</a>:</h4>
<p>You can derive this fairly simply from the type though</p>

<a name="169221138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169221138" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169221138">Mario Carneiro (Jun 28 2019 at 12:42)</a>:</h4>
<p>If it is a type or a proof then it has no content, and if it is a function whose codomain has no content then the function type also has no content; inductive types have content</p>

<a name="169221169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169221169" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169221169">Mario Carneiro (Jun 28 2019 at 12:43)</a>:</h4>
<p>And a quotient A has content iff A has content</p>

<a name="169221187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169221187" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169221187">Kevin Buzzard (Jun 28 2019 at 12:43)</a>:</h4>
<p>Even if we quotient out by the always-true equivalence relation?</p>

<a name="169221191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169221191" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169221191">Mario Carneiro (Jun 28 2019 at 12:43)</a>:</h4>
<p>yes</p>

<a name="169221197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169221197" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169221197">Kevin Buzzard (Jun 28 2019 at 12:43)</a>:</h4>
<p>And this is the point of <code>trunc</code></p>

<a name="169221251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169221251" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169221251">Mario Carneiro (Jun 28 2019 at 12:44)</a>:</h4>
<p>This is why <code>trunc</code> and <code>nonempty</code> are the same in the logic (aka classically equivalent) but have different computational behavior</p>

<a name="169221262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169221262" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169221262">Kevin Buzzard (Jun 28 2019 at 12:44)</a>:</h4>
<p>Thanks for explaining this point. And if I understood the VM  I would somehow see all this very clearly, because things like types and proofs are not represented in the VM at all, whatever that means.</p>

<a name="169221273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169221273" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169221273">Mario Carneiro (Jun 28 2019 at 12:44)</a>:</h4>
<p>I actually use the VM only as a rhetorical device here</p>

<a name="169221285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169221285" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169221285">Mario Carneiro (Jun 28 2019 at 12:45)</a>:</h4>
<p>you don't need to know anything at all about bytecodes to get this</p>

<a name="169221287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169221287" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169221287">Kevin Buzzard (Jun 28 2019 at 12:45)</a>:</h4>
<p>So do I write <code>let D : set Q := ...</code> or <code>have D : set Q := ...</code>?</p>

<a name="169221304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169221304" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169221304">Kevin Buzzard (Jun 28 2019 at 12:45)</a>:</h4>
<p>I would write <code>let</code></p>

<a name="169221307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169221307" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169221307">Mario Carneiro (Jun 28 2019 at 12:45)</a>:</h4>
<p>you just need to picture sort of generally what a computer would have to do to deal with this stuff</p>

<a name="169221384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169221384" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169221384">Mario Carneiro (Jun 28 2019 at 12:46)</a>:</h4>
<p>You still write <code>let</code> for anything that's a <code>Type</code> because it doesn't have proof irrelevance</p>

<a name="169221404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169221404" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169221404">Mario Carneiro (Jun 28 2019 at 12:46)</a>:</h4>
<p>The reason proofs can use <code>have</code> is because the type theory says the stuff that filled the type doesn't matter</p>

<a name="169221489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169221489" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169221489">Mario Carneiro (Jun 28 2019 at 12:48)</a>:</h4>
<p>Nevertheless, because <code>D</code> is "VM-irrelevant", it's impossible for the computer to branch an if statement based on some property of <code>D</code>, like whether it has cardinality 2. You can predict that any such function will be noncomputable</p>

<a name="169221786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169221786" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169221786">Neil Strickland (Jun 28 2019 at 12:54)</a>:</h4>
<p>I don't think you can compute from Cauchy to Dedekind, according to my understanding of what computation means.  Suppose you have a computable Cauchy sequence <code>(x_n)</code>, with computable bounds on the rate of convergence, and a rational number <code>q</code>, and you want to know whether <code>q</code> is in the corresponding Dedekind cut.  If <code>q</code> is not equal to the limit, then you will be able to prove that it is either above or below, after inspecting a finite number of terms (but the number is not known a priori).  However, if it happens that the limit of the sequence is equal to <code>q</code>, then you won't be able to determine that by a finite computation.</p>
<p>On the other hand, suppose you have a computable Dedekind cut, so you know a number <code>a</code> in the lower set and a number <code>b</code> in the upper set, and for any given rational <code>q</code> you can decide whether it lies in either set.  Then you can take <code>n</code> equally spaced points between <code>a</code> and <code>b</code>, decide which if them are in the upper and lower sets, and thus get <code>x_n</code> within <code>1/n</code> of the corresponding real; this gives a Cauchy sequence.</p>

<a name="169221901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169221901" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169221901">Mario Carneiro (Jun 28 2019 at 12:55)</a>:</h4>
<p>The reason Cauchy -&gt; Dedekind here is "computable" is for the trivial reason that a Dedekind real is basically a set; you only have to <em>write down</em> the membership predicate, you don't have to decide it</p>

<a name="169221928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169221928" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169221928">Mario Carneiro (Jun 28 2019 at 12:55)</a>:</h4>
<p>If we had dedekind real being <code>Q -&gt; bool</code> it would be a different matter</p>

<a name="169222182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169222182" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169222182">Mario Carneiro (Jun 28 2019 at 12:59)</a>:</h4>
<p>I agree that if a dedekind real is defined as two bounding values and a decidable predicate then you can make a computable function to Cauchy</p>

<a name="169222287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169222287" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169222287">Mario Carneiro (Jun 28 2019 at 13:01)</a>:</h4>
<p>I am assuming the definition is as a predicate (not necessarily decidable) together with <em>proofs</em> (not data) that the predicate is neither always true or always false, and monotone (and with no maximum)</p>

<a name="169229366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169229366" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169229366">François G. Dorais (Jun 28 2019 at 14:29)</a>:</h4>
<p>There are lots of choices here and the answers depend on these choices. This is very well studied, for example, see this paper by Jeff Hirst &lt;<a href="http://www.appstate.edu/~hirstjl/bib/pdf/rrepsproof.pdf" target="_blank" title="http://www.appstate.edu/~hirstjl/bib/pdf/rrepsproof.pdf">http://www.appstate.edu/~hirstjl/bib/pdf/rrepsproof.pdf</a>&gt; which discusses various representations from a very classical perspective, or Klaus Weihrauch's book on Computable Analysis &lt;<a href="https://www.springer.com/gp/book/9783540668176" target="_blank" title="https://www.springer.com/gp/book/9783540668176">https://www.springer.com/gp/book/9783540668176</a>&gt; for how to make judicious choices and prove things with them.</p>
<p>First, assuming the Axiom of Choice, the equivalence of any two of the usual representations of real numbers are provably equivalent, regardless of choices made.</p>
<p>What do you need to make a Dedekind cut for a real number x? All you need is to determine whether a rational number q is in the cut or not. That is you need to know whether or not q &lt; x (or q ≤ x, if your cuts can have a max). So if you have <code>has_lt</code> for your real number x, then you're set to compute the set { q : q &lt; x }. If your Dedekind cuts are also decidable (bool-valued instead of Prop-valued), then you need a decidable <code>has_lt</code> (or slightly less as discussed below).</p>
<p>The problem with mathlib's Cauchy reals was spotted by <span class="user-mention" data-user-id="130308">@Neil Strickland</span>: there is no attached modulus of convergence. This is useless for computation. Even if I know my Cauchy sequence for a real number x starts 3.1, 3.14, 3.141, then I have no information about x whatsoever. It could be that x = π as one might expect, or the sequence could continue after the 10^42-nd term to become constant with value 42. With a modulus of convergence though, I do know something about my real number. If my modulus says that all terms are within 1/10 of the first term then I know that 3 ≤ x ≤ 3.2. In Computable Analysis, real numbers are equivalence classes of Cauchy sequences with an attached modulus of convergence.</p>
<p>Even with a modulus of convergence, the ordering of reals is not computable. The Brouwerian counterexample to this is as follows. I might be thinking of a natural number, and I will definitely tell you if you're right when you guess correctly. From this, you can define the real number x which is the sum of the sequence (-1)^n a(n)/2^n where a(n) = 1 if n is my number and a(n) = 0 if n is not my number. Notice that there is an obvious Cauchy sequence for x given by partial sums and it has a predictable modulus of convergence regardless of my number. Also note that deciding x ≤ 0 or x ≥0 amounts to guessing whether my number is even or odd (with both answers correct if I wasn't thinking of a number at all), so this requires divination.</p>
<p>The "most computable" version of Dedekind reals is to take all monotone non-constant functions <code>Q -&gt; bool</code> and take a quotient to merge the two different cuts corresponding to a rational number. To compute one of these for a real number x, I don't need to decide whether or not x &lt; q, I have the milder choice of deciding x ≤ q or x ≥ q, with both answers valid when x = q. Sadly this is still not computable for Cauchy sequences, even with a modulus, as the Brouwerian counterexample above shows. However, the decision process is much milder and  deciding x ≤ q or x ≥ q for all q is known equivalent to finding a path through an infinite computable binary tree rather than solving the halting problem.</p>

<a name="169230203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169230203" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169230203">Kevin Buzzard (Jun 28 2019 at 14:40)</a>:</h4>
<p>So actually my problem is not well specified. I should formalise precisely what I mean by these notions I'm talking about, because the answer depends on the details.</p>

<a name="169230509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169230509" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169230509">Johan Commelin (Jun 28 2019 at 14:43)</a>:</h4>
<p>Kevin, are you trying to make Lean (and its community) just as constructivistic as all the other theorem proving communities? <span aria-label="cold sweat" class="emoji emoji-1f630" role="img" title="cold sweat">:cold_sweat:</span></p>

<a name="169230628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169230628" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169230628">Kevin Buzzard (Jun 28 2019 at 14:44)</a>:</h4>
<p>No, I'm just trying to understand it properly. I am writing an article about Lean for mathematicians and I want to make sure I don't say anything stupid.</p>

<a name="169230954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169230954" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169230954">Johan Commelin (Jun 28 2019 at 14:48)</a>:</h4>
<p>Ok, that's fine.</p>

<a name="169231053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169231053" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169231053">Johan Commelin (Jun 28 2019 at 14:49)</a>:</h4>
<p>Will you explicitly say that the Lean community doesn't care about these issues?</p>

<a name="169231113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169231113" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169231113">Kevin Buzzard (Jun 28 2019 at 14:50)</a>:</h4>
<p>Yes</p>

<a name="169231119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169231119" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169231119">Johan Commelin (Jun 28 2019 at 14:50)</a>:</h4>
<p>Great!</p>

<a name="169231145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169231145" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169231145">Kevin Buzzard (Jun 28 2019 at 14:50)</a>:</h4>
<p>More precisely I'll say that Lean doesn't care about these issues.</p>

<a name="169231207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169231207" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169231207">Johan Commelin (Jun 28 2019 at 14:51)</a>:</h4>
<blockquote>
<p>So actually my problem is not well specified. I should formalise precisely what I mean by these notions I'm talking about, because the answer depends on the details.</p>
</blockquote>
<p>It would be really great if Lean wouldn't even allow you to formalise precisely the constructively different notions that we've been talking about.</p>

<a name="169231228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169231228" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169231228">Johan Commelin (Jun 28 2019 at 14:51)</a>:</h4>
<p>But I'm afraid that you can still be very constructive in Lean if you want to.</p>

<a name="169231356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169231356" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169231356">Kevin Buzzard (Jun 28 2019 at 14:52)</a>:</h4>
<p>I am sure that  Leo wants to cater to constructive people. But he wants to cater to mathematicians too.</p>

<a name="169232051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169232051" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169232051">Chris Hughes (Jun 28 2019 at 15:00)</a>:</h4>
<p>By attaching a modulus of convergence, does that mean turning the Exists in the <code>∀ ε &gt; 0, ∃ N, ...</code> into a subtype?</p>

<a name="169232083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169232083" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169232083">Kevin Buzzard (Jun 28 2019 at 15:01)</a>:</h4>
<p>It might mean supplying the function which turns the epsilon into an N.</p>

<a name="169235679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169235679" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169235679">Marc Huisinga (Jun 28 2019 at 15:42)</a>:</h4>
<blockquote>
<p>It would be really great if Lean wouldn't even allow you to formalise precisely the constructively different notions that we've been talking about.</p>
</blockquote>
<p>why?</p>

<a name="169235726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169235726" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169235726">Kevin Buzzard (Jun 28 2019 at 15:42)</a>:</h4>
<p>I'm not sure Johan was being too serious! The issue is that for mathematicians all these notions are "the same", so we find it hard to tell between them.</p>

<a name="169235783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169235783" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169235783">Kevin Buzzard (Jun 28 2019 at 15:43)</a>:</h4>
<p>[and hence we do not really want to be bothered about having to distinguish between them, which was indeed what I did in my first post]</p>

<a name="169237145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169237145" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169237145">Marc Huisinga (Jun 28 2019 at 15:59)</a>:</h4>
<p>but surely at least some constructive proofs are useful to people that apply math.<br>
for instance, the constructive proof of the chinese remainder theorem allows (naughty) people to break textbook RSA encryption when the same message has been encrypted multiple times with the same parameter e ;)</p>

<a name="169237316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169237316" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169237316">Kevin Buzzard (Jun 28 2019 at 16:00)</a>:</h4>
<p>Sure -- but Johan and I do "blue sky research" maths and it is surprising how irrelevant computability is for us. We spend most of our time reasoning about objects, not computing them. Even when we do say we're doing "computations", this is not what a computer scientists means by the word.</p>

<a name="169238387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169238387" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169238387">Marc Huisinga (Jun 28 2019 at 16:11)</a>:</h4>
<p>yes, i agree. most of that research likely won't ever need an algorithm. and if it ever does, "cs people" are likely to be better suited for coming up with an efficient algorithm, not just any constructive proof.</p>

<a name="169238625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169238625" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169238625">Kevin Buzzard (Jun 28 2019 at 16:13)</a>:</h4>
<p>To give some indication as to the way we think about mathematics, Johan, Patrick Massot and I defined a perfectoid space in Lean and we are still months away from being able to define a single explicit example; however we will soon get back to working on the project and trying to prove lemmas about perfectoid spaces, untroubled by this issue.</p>

<a name="169246347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169246347" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169246347">Johan Commelin (Jun 28 2019 at 17:45)</a>:</h4>
<blockquote>
<p>I'm not sure Johan was being too serious! The issue is that for mathematicians all these notions are "the same", so we find it hard to tell between them.</p>
</blockquote>
<p>He indeed wasn't too serious. I'm pretty sure that he was trolling the constructivist CS crowd, just to make a point.</p>
<p>I think that a lot of people on this chat don't realise that 9 out of 10 mathematicians really have no clue at all what "classical" mathematics is. (This time Johan is actually very serious!)</p>
<p>In my field of research (arithmetic geometry) working "classicaly" means that you work over an algebraically closed field. That is what everyone understands the term to mean. (And this is not some exotic subfield of maths. It is tightly linked to number theory, complex analysis, algebraic topology, and all sorts of other major research areas.)</p>
<p>Seriously: 99% of the mathematicians work classical. And 90% will be extremely confused when you start talking about constructive vs classical arguments. It is a distinction they have never heard of, and if it is somehow an important distinction to make when working with a theorem prover, than you've just lost another person's attention.</p>

<a name="169247747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169247747" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169247747">Johan Commelin (Jun 28 2019 at 18:01)</a>:</h4>
<p>It is true that most mathematicians actually do have a <code>meta</code> constructive overlay or something like that. We are extremely good at doing little computations with finite sets, even though we never think about implementing them in terms of <code>list</code> and whatever. We know how to compute with them (by implicitly choosing an order, blah blah). And mathematicians really don't even realise that at that very moment they are "computing".</p>

<a name="169249428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169249428" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169249428">Marc Huisinga (Jun 28 2019 at 18:22)</a>:</h4>
<p>excuse my ignorance, is there any significant automation that lean can only provide if you're working constructively? other than that, i see no reason for the distinction to be anything other than a choice of priorities and possibly ideological preference.<br>
i haven't been here for a long time, but i've had the impression that most people on this chat agree with you. as far as i can tell, even the majority of cs people work non-constructively and only invest time into finding a good algorithm when there's something to be gained from it.<br>
as for other communities, i think that many people are well aware that most mathematicians don't care about constructive vs. non-constructive maths, but they're still trying to convince you to care. i personally don't think that there is much to be gained from this, either.<br>
the most recent example of this i've seen was the twitter convo that resulted from kevin's "proofs are not programs" blog post, and i honestly found that convo to be pretty hard to read.</p>

<a name="169249602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169249602" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169249602">Johan Commelin (Jun 28 2019 at 18:24)</a>:</h4>
<p>Currently no such automation exists.</p>

<a name="169249672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169249672" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169249672">Johan Commelin (Jun 28 2019 at 18:25)</a>:</h4>
<p>One could imagine a tactic that ports constructive proofs in algebra over to proofs of the analogous statements in an arbitrary topos. That would be a pretty cool and impressive thing to do.</p>

<a name="169258583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169258583" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169258583">Mario Carneiro (Jun 28 2019 at 20:12)</a>:</h4>
<p>The "significant automation" that lean provides when working constructively is called <code>rfl</code></p>

<a name="169258788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169258788" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169258788">Mario Carneiro (Jun 28 2019 at 20:15)</a>:</h4>
<p>I actually got caught on this issue in the other direction recently. I wrote "Lean is primarily classical but allows you to prove intuitionistic theorems" or something similar in a paper, and a reviewer complained about this line. They argued that because Lean is based on CIC it is no more or less classical than Coq</p>

<a name="169259697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169259697" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169259697">Chris Hughes (Jun 28 2019 at 20:30)</a>:</h4>
<p>I guess the library is more classical though right.</p>

<a name="169261104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169261104" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169261104">Mario Carneiro (Jun 28 2019 at 20:52)</a>:</h4>
<p>Right. I should mention I wasn't convinced by the argument</p>

<a name="169261210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169261210" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169261210">Mario Carneiro (Jun 28 2019 at 20:53)</a>:</h4>
<p>If the library uses choice from the start, then even if you want to avoid choice it's not really a practical option. It actually matters a lot what the library does for this kind of thing</p>

<a name="169267371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169267371" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169267371">François G. Dorais (Jun 28 2019 at 22:24)</a>:</h4>
<p>The significant difference between Lean and Coq is quotients, which is brilliant for everyone but frightening for constructivists.</p>

<a name="169270385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169270385" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169270385">matt rice (Jun 28 2019 at 23:14)</a>:</h4>
<blockquote>
<p>If it is a type or a proof then it has no content, and if it is a function whose codomain has no content then the function type also has no content; inductive types have content</p>
</blockquote>
<p>Don't inductives like the following need some caveat here as well?</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">Void</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">:</span> <span class="n">Void</span>  <span class="bp">→</span> <span class="n">Void</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">Void</span><span class="bp">.</span><span class="n">mk</span> <span class="o">(</span><span class="n">Void</span><span class="bp">.</span><span class="n">mk</span> <span class="bp">_</span><span class="o">)</span> <span class="c1">-- this is fine.</span>
<span class="bp">#</span><span class="kn">eval</span> <span class="n">Void</span><span class="bp">.</span><span class="n">mk</span> <span class="o">(</span><span class="bp">_</span><span class="o">)</span> <span class="c1">-- don&#39;t know how to synthesize placeholder type</span>
</pre></div>

<a name="169281722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169281722" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169281722">Mario Carneiro (Jun 29 2019 at 04:45)</a>:</h4>
<p>No, this is a computationally relevant type; it's just empty</p>

<a name="169281764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169281764" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169281764">Mario Carneiro (Jun 29 2019 at 04:46)</a>:</h4>
<p>The problem with your example is you didn't give <code>#eval</code> a complete term. You can't eval a metavariable</p>

<a name="169299776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169299776" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169299776">matt rice (Jun 29 2019 at 14:33)</a>:</h4>
<p>Are you saying that I can replace the _ with e.g. some tactic (<code>repeat</code>?) which will build up an infinitely long term, and while the <code>#eval</code> never returns it computes each step of the construction?</p>

<a name="169300334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169300334" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169300334">Mario Carneiro (Jun 29 2019 at 14:47)</a>:</h4>
<p>No. You can only <code>#eval</code> a finitely large term, because there is no such thing as an infinitely large term - elaboration would never terminate if you tried something like that so it would never get around to the evaluation part</p>

<a name="169300340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169300340" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169300340">Mario Carneiro (Jun 29 2019 at 14:47)</a>:</h4>
<p>However, there are tricks for constructing general recursive terms to inhabit <code>Void</code></p>

<a name="169300405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169300405" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169300405">Mario Carneiro (Jun 29 2019 at 14:49)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">meta</span> <span class="n">def</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">Void</span> <span class="o">:=</span> <span class="n">Void</span><span class="bp">.</span><span class="n">mk</span> <span class="n">foo</span>
<span class="bp">#</span><span class="kn">eval</span> <span class="n">foo</span>
</pre></div>


<p>the evaluation of <code>foo</code> will not halt</p>

<a name="169300579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cauchy%20reals%20%3D%20Dedekind%20reals%3F/near/169300579" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/46336CauchyrealsDedekindreals.html#169300579">matt rice (Jun 29 2019 at 14:53)</a>:</h4>
<p>Thank you for clarifying.</p>


{% endraw %}
