---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/116395maths/84919Commutativediagrams.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/84919Commutativediagrams.html">Commutative diagrams</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="187846947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Commutative%20diagrams/near/187846947" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/84919Commutativediagrams.html#187846947">Chris Hughes (Feb 10 2020 at 19:00)</a>:</h4>
<p>We've got a bit of a problem at the moment with dealing with commutative diagrams. If I have a theorem about a chain of fields <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>M</mi><mo>:</mo><mi>L</mi><mo>:</mo><mi>K</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[M:L:K]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mclose">]</span></span></span></span>, then assuming that the "canonical map" from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span> is by definition the composition of the maps from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>→</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">K \to L</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>→</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">L \to M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span> would make it hard to apply this theorem to say <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi><mo>:</mo><mi mathvariant="double-struck">R</mi><mo>:</mo><mi mathvariant="double-struck">Q</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}: \mathbb{R}:\mathbb{Q}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">C</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85556em;vertical-align:-0.16667em;"></span><span class="mord"><span class="mord mathbb">Q</span></span></span></span></span>. So we have to assume that there are three maps and include the assumption that they commute. However, supposing we have more than three fields in a row, then there are a lot of commutativity assumptions.</p>
<p>One solution to this that is used in Coq, and has been suggested to me is to assume everything is a subset of some bigger field, or everything is a subgroup of some bigger group. However, this approach has two downsides, one of which is that is makes theorems hard to apply when the objects in question are not defined to be subfields, for example to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Q</mi></mrow><annotation encoding="application/x-tex">\mathbb{Q}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.85556em;vertical-align:-0.16667em;"></span><span class="mord"><span class="mord mathbb">Q</span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\mathbb{R}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">C</span></span></span></span></span>. The other downside is that it forces all the maps in the diagram to be injective, which isn't a problem if the objects in my diagram are fields, but is a problem in other categories.</p>
<p>The better solution would be to have an indexing Type <code>iota</code>, which should be a preorder and a functor from this type into my category (a functor, but not necessarily an actual term of type <code>category_theory.functor</code>). This gets rid of the second downside of the subfield approach, and lessens the effect of the first downside, although I would still have to construct an explicit <code>fin 3 → Type</code> which would be a little awkward, but not as bad as tranferring theorems from <code>set.range rat.cast</code> back to <code>ℚ</code>. </p>
<p>Is this a good approach? Are there any downsides of this versus using subgroups/subfields?</p>

<a name="187859991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Commutative%20diagrams/near/187859991" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/84919Commutativediagrams.html#187859991">Kevin Buzzard (Feb 10 2020 at 21:27)</a>:</h4>
<p>In the category theory library there are explicit (very) small categories containing just a couple of objects and arrows; one could use such an object instead of <code>fin 3</code> and then define the maps using the equation compiler. It's not as if there are hundreds of theorems about <code>fin 3</code> which we want to access easily. I think this approach sounds nicer than the "everything is a subthing of an artificial big thing" approach. In my thesis I had to deal with commutative diagrams with 8 or more objects in and I wasn't doing anything particularly abstract, I was just working with objects defined over a base.</p>

<a name="187884444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Commutative%20diagrams/near/187884444" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/84919Commutativediagrams.html#187884444">Johan Commelin (Feb 11 2020 at 05:16)</a>:</h4>
<p>I think that <span class="user-mention" data-user-id="110044">@Chris Hughes</span> is pointing at one of the big hurdles for moving commutative algebra forward. Like he says, putting everything as subobject of a big ambient object is problematic as soon as you want to reason about general homomorphisms (for example quotients).<br>
Does anyone know of a comparison article (e.g. by the Coq community) that discusses possible approaches. Any "no-go" results would be valuable to know.<br>
I've been thinking we might want to create some hideous data structure that is not fit for human consumption, but that registers commutativity of bunch of maps (maybe "aka diagram"). It should come with a companion tactic <code>commutes</code>, and this should discharge proof obligations with <code>(by commutes)</code>. I have no idea if something like that would work, but I know that we are at a serious impasse right now. Nobody has defined predicates on ring morphisms (<code>flat</code>, <code>finite</code>, <code>finite_type</code>, <code>etale</code>, <code>unramified</code>, <code>finite_presentation</code>, <code>smooth</code>) etc. Nobody has put a <code>B</code>-module structure on <code>B \otimes[A] M</code>. Nobody has defined a construction that turns a ring hom between <code>A</code>-algebras into a ringhom between <code>B</code>-algebras by extension of scalar.<br>
And I think it is mostly because of this issue. Because as soon as you write down a first lemma about these objects, you want all sorts of commutativity constraints. And currently it's really awkward to write those down, or provide proof that they are satisfied.</p>

<a name="187884456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Commutative%20diagrams/near/187884456" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/84919Commutativediagrams.html#187884456">Johan Commelin (Feb 11 2020 at 05:17)</a>:</h4>
<p>If we develop such a hideous data structure, it can use some <code>iota</code> under the hood. But whether this is <code>fin 3</code> or not, should be completely transparent to the user.</p>

<a name="187891027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Commutative%20diagrams/near/187891027" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/84919Commutativediagrams.html#187891027">Kevin Buzzard (Feb 11 2020 at 08:08)</a>:</h4>
<p>These predicates are very natural things to want. Our MSc commutative algebra course deals with about half of them and the moment you go into modern algebraic geometry you need all of them. Flatness is a great place to start. There is an API of standard results about flat modules which is very well-known to mathematicians and it works be very interesting to try to get it into lean and see where the problems are</p>

<a name="187901425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Commutative%20diagrams/near/187901425" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/84919Commutativediagrams.html#187901425">Rob Lewis (Feb 11 2020 at 10:53)</a>:</h4>
<blockquote>
<p>Does anyone know of a comparison article (e.g. by the Coq community) that discusses possible approaches. Any "no-go" results would be valuable to know.</p>
</blockquote>
<p>I don't know of a particular algorithm, but it's absolutely worth talking to e.g. some of the math-comp people about this. (Sounds like maybe Chris has already?) It's not a new question and they've definitely gone through the possibilities.</p>


{% endraw %}

{% include archive_update.html %}