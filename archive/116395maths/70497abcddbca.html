---
layout: archive
title: Lean Prover Zulip Chat Archive 
permalink: archive/116395maths/70497abcddbca.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/70497abcddbca.html">(a * b) * c * d = (d * (b * c)) * a</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="158049932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28a%20%2A%20b%29%20%2A%20c%20%2A%20d%20%3D%20%28d%20%2A%20%28b%20%2A%20c%29%29%20%2A%20a/near/158049932" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/70497abcddbca.html#158049932">Johan Commelin (Feb 11 2019 at 17:54)</a>:</h4>
<p>What is the fastest way to prove such a statement in an arbitrary structure with associative and commutative multiplication? I am currently in a <code>with_zero G</code> where <code>G</code> is a comm_group. That prevents me from using <code>abel</code> or such.</p>

<a name="158050012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28a%20%2A%20b%29%20%2A%20c%20%2A%20d%20%3D%20%28d%20%2A%20%28b%20%2A%20c%29%29%20%2A%20a/near/158050012" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/70497abcddbca.html#158050012">Johan Commelin (Feb 11 2019 at 17:55)</a>:</h4>
<p>I guess there is room for a <code>perm</code> tactic that takes a assoc comm operator, and proves that two permutations are equal.</p>

<a name="158050502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28a%20%2A%20b%29%20%2A%20c%20%2A%20d%20%3D%20%28d%20%2A%20%28b%20%2A%20c%29%29%20%2A%20a/near/158050502" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/70497abcddbca.html#158050502">Chris Hughes (Feb 11 2019 at 18:02)</a>:</h4>
<p><code>simp [mul_comm, mul_assoc, mul_left_comm]</code> is fairly reliable.</p>

<a name="158050655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28a%20%2A%20b%29%20%2A%20c%20%2A%20d%20%3D%20%28d%20%2A%20%28b%20%2A%20c%29%29%20%2A%20a/near/158050655" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/70497abcddbca.html#158050655">Kevin Buzzard (Feb 11 2019 at 18:05)</a>:</h4>
<p>When Kenny and I were faced with stuff like this we were doing cases on it; if a = 0 then both sides are 0 and if not then a = some a; now case on b and kill the zero case; etc. When all zero cases are killed, <code>change</code> to <code>some ((a * b) * c * d) = ...</code>, apply injectivity of <code>some</code> and then use <code>abel</code>. But if Chris' technique works that would be great. I guess your monoid isn't even cancellative though.</p>

<a name="158051519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28a%20%2A%20b%29%20%2A%20c%20%2A%20d%20%3D%20%28d%20%2A%20%28b%20%2A%20c%29%29%20%2A%20a/near/158051519" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/70497abcddbca.html#158051519">Johan Commelin (Feb 11 2019 at 18:18)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="110044">@Chris Hughes</span>! That works like a charm!</p>


{% endraw %}
