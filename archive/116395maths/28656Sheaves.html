---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/116395maths/28656Sheaves.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html">Sheaves</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="167766087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167766087" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167766087">Kevin Buzzard (Jun 10 2019 at 14:55)</a>:</h4>
<p>Kenny and I have been playing about with the schemes repo; I've been trying to glue sheaves together on subspaces. I realise when doing this work that there are big design decisions that need to be made. A sheaf in maths is just some assignment of a type to each open subset of a topological space, modulo a bit of extra structure and some axioms. I'd been working with <code>opens X</code> but now I'm working with sheaves on open subsets of X I am forever wrestling with <code>opens U</code> with <code>U : opens X</code> and having to dig through subtypes of subtypes etc. Sure I could write a bunch of API for <code>opens U</code>. On the other hand I could just try and avoid subtypes completely -- this was <span class="user-mention" data-user-id="110064">@Kenny Lau</span> 's suggestion -- and even go so far as to define a sheaf on an open subspace of a topological space just to be pair (U,F) where U is open, F is a sheaf on all of X, and the values of F are irrelevant if we evaluate on a set that isn't an open subset of U. This seems to be leading to some sort of "how to do this sort of thing optimally in dependent type theory" conversation and it reminds me a lot of <span class="user-mention" data-user-id="110172">@Assia Mahboubi</span> using subgroups instead of groups in Coq (the rooster and the butterfly) and so on. Doing it like this, the restriction of F to an open subspace is very very easy indeed.</p>
<p>On the other hand, my plan has always been to use <span class="user-mention" data-user-id="110087">@Scott Morrison</span> 's category theory work to do sheaves, as this is the language which is used in practice by mathematicians. However in some sense I now feel that this would drift even further from the "very easy" approach and force me to write even more API. I do not object to writing more API. But I'm just confused about the best approach to take. Scott's approach seems to be far closer to what a mathematician would do, and Kenny's to what a computer scientist would do. I don't know which one I want to be though, in this context. I somehow get the feeling that it matters though.</p>

<a name="167766197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167766197" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167766197">Kenny Lau (Jun 10 2019 at 14:56)</a>:</h4>
<p>I'm proud of my construction :P</p>

<a name="167766554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167766554" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167766554">Kevin Buzzard (Jun 10 2019 at 15:00)</a>:</h4>
<p>It makes no mathematical sense :P</p>

<a name="167766608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167766608" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167766608">Kevin Buzzard (Jun 10 2019 at 15:01)</a>:</h4>
<p>It feels a bit like this weird idea of defining a subset to be compact instead of defining what it means for a top space to be compact.</p>

<a name="167766928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167766928" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167766928">Reid Barton (Jun 10 2019 at 15:05)</a>:</h4>
<p>I don't know how feasible this is in this case but maybe you can pick an application which needs gluing of sheaves--fiber products maybe--and imagine (if not actually carry out) the construction using the interface you intend to provide</p>

<a name="167767030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167767030" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167767030">Reid Barton (Jun 10 2019 at 15:06)</a>:</h4>
<p>Well I guess gluing schemes is a bit more work than gluing sheaves</p>

<a name="167770880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167770880" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167770880">Simon Pepin Lehalleur (Jun 10 2019 at 15:53)</a>:</h4>
<blockquote>
<p>It makes no mathematical sense :P</p>
</blockquote>
<p>Couldn't you identify a sheaf on U with either its extension by zero or push-forward to X? They both make a lot of mathematical sense , and they are fully faithful functors so that you don't lose any information.</p>

<a name="167771662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167771662" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167771662">Kevin Buzzard (Jun 10 2019 at 16:02)</a>:</h4>
<p>Indeed! But in this game people might equally want to just say "what is going on outside U is junk". The extension by zero would be hard to work with in Lean -- the definition would then be "if V is a subset of U then the correct thing, else 0", and you would forever be splitting ifs. The pushforward is easier because its value on V is the correct value on V intersect U, so you are just having to invoke the fact that the intersection of two opens is open occasionally, which sounds nicer. What I am frustrated about is that both of them seem to be slightly artificial workarounds for the thing I want to have, which is the sheaf on U and nothing more. My question is whether I should bite the bullet and work with the thing that seems right to me or make these artificial extensions. Even with the extensions one has to choose whether to prove that the sheaf axiom holds for the extension or just check it on U.</p>
<p>Hmm. Here's another issue. What I want to be easy is this: given X a top space, and F a sheaf on U (an open subset of X) and V an open subset of U, I want the restriction of F to V. With my suggestion ("junk outside U") I can literally use F again, With either the pushforward (they call it <code>map</code> here) or extension by zero one would have to change F. What I have no real feeling about is whether the convenience of being able to recycle F is worth anything, or whether I should just bite the bullet, write some code which does what I want "properly" (i.e. a sheaf on U is just a function on the open subsets of U and hang the other open subsets of X) and then just figure out the API I need. I might need a lot of API. But this is not a mathematical issue, it is a tedious implementation issue.</p>

<a name="167773695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167773695" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167773695">Johan Commelin (Jun 10 2019 at 16:29)</a>:</h4>
<p><span class="user-mention" data-user-id="224267">@Simon Pepin Lehalleur</span> Welcome on the chat!</p>

<a name="167774114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167774114" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167774114">Simon Pepin Lehalleur (Jun 10 2019 at 16:35)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> Thanks! I saw the mathoverflow question and I got curious...</p>

<a name="167777925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167777925" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167777925">Kenny Lau (Jun 10 2019 at 17:25)</a>:</h4>
<p>I don't believe "extension by zero" makes sense mathematically.</p>

<a name="167778039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167778039" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167778039">Kevin Buzzard (Jun 10 2019 at 17:27)</a>:</h4>
<p>I've just spent another 20 minutes struggling to even write down the definition of glueing sheaves. The mathematical argument is: you have a topological space <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07847em;">X</span></span></span></span> covered by opens <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>U</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">U_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span>, and for each <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.65952em;"></span><span class="strut bottom" style="height:0.65952em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">i</span></span></span></span> you have a sheaf <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="script">F</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\mathcal{F}_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.09931em;">F</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> on <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>U</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">U_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span>. Say you have isomorphisms <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ϕ</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>:</mo><msub><mi mathvariant="script">F</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><mo>(</mo><msub><mi>U</mi><mi>i</mi></msub><mo>∩</mo><msub><mi>U</mi><mi>j</mi></msub><mo>)</mo><mo>→</mo><msub><mi mathvariant="script">F</mi><mi>j</mi></msub><mi mathvariant="normal">∣</mi><mo>(</mo><msub><mi>U</mi><mi>i</mi></msub><mo>∩</mo><msub><mi>U</mi><mi>j</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">\phi_{ij}:\mathcal{F}_i|(U_i\cap U_j)\to\mathcal{F}_j|(U_i\cap U_j)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="base"><span class="mord"><span class="mord mathit">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">i</span><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"></span></span></span></span></span><span class="mrel">:</span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.09931em;">F</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord mathrm">∣</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mbin">∩</span><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"></span></span></span></span></span><span class="mclose">)</span><span class="mrel">→</span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.09931em;">F</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"></span></span></span></span></span><span class="mord mathrm">∣</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mbin">∩</span><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"></span></span></span></span></span><span class="mclose">)</span></span></span></span> of sheaves satisfying the cocycle condition <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ϕ</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><mo>=</mo><msub><mi>ϕ</mi><mrow><mi>j</mi><mi>k</mi></mrow></msub><mo>∘</mo><msub><mi>ϕ</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\phi_{ik}=\phi_{jk}\circ\phi_{ij}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="base"><span class="mord"><span class="mord mathit">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">i</span><span class="mord mathit mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mrel">=</span><span class="mord"><span class="mord mathit">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span><span class="mord mathit mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"></span></span></span></span></span><span class="mbin">∘</span><span class="mord"><span class="mord mathit">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">i</span><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"></span></span></span></span></span></span></span></span> as maps of sheaves on <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>U</mi><mi>i</mi></msub><mo>∩</mo><msub><mi>U</mi><mi>j</mi></msub><mo>∩</mo><msub><mi>U</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">U_i\cap U_j\cap U_k</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mbin">∩</span><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"></span></span></span></span></span><span class="mbin">∩</span><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span>, and such that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ϕ</mi><mrow><mi>i</mi><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\phi_{ii}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord"><span class="mord mathit">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">i</span><span class="mord mathit mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> is the identity. Then we want a sheaf on all of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07847em;">X</span></span></span></span>.</p>
<p>Even writing down the definition of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="script">F</mi></mrow><mo>(</mo><mi>U</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{F}(U)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathcal" style="margin-right:0.09931em;">F</span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="mclose">)</span></span></span></span> is a pain. It involves taking the elements <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>t</mi><mi>i</mi></msub><mo>)</mo><mo>∈</mo><msub><mo>∏</mo><mi>i</mi></msub><mrow><msub><mi mathvariant="script">F</mi><mi>i</mi></msub></mrow><mo>(</mo><mi>U</mi><mo>∩</mo><msub><mi>U</mi><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(t_i)\in\prod_i\mathcal{F_i}(U\cap U_i)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.0497100000000001em;vertical-align:-0.29971000000000003em;"></span><span class="base"><span class="mopen">(</span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mclose">)</span><span class="mrel">∈</span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16195399999999993em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.09931em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.09931em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="mbin">∩</span><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mclose">)</span></span></span></span> which agree on overlaps; however the way <span class="user-mention" data-user-id="132858">@Ramon Fernandez Mir</span> has set up sheaves is with categories in mind, so we have <code>U: opens X</code> and so to make the <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">t_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.61508em;"></span><span class="strut bottom" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> we need <code>U ∩ U_i : opens U_i</code> and then to say "agree on overlaps" it becomes a bit of a nightmare.</p>

<a name="167778073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167778073" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167778073">Kevin Buzzard (Jun 10 2019 at 17:27)</a>:</h4>
<blockquote>
<p>I don't believe "extension by zero" makes sense mathematically.</p>
</blockquote>
<p>Sure it does; it's a sheaf, not vector bundle. Its fibre is 0 outside <code>U</code>.</p>

<a name="167778133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167778133" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167778133">Kenny Lau (Jun 10 2019 at 17:28)</a>:</h4>
<p>what does "agree on overlaps" even mean in the Hartshorn exercise?</p>

<a name="167778144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167778144" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167778144">Kenny Lau (Jun 10 2019 at 17:28)</a>:</h4>
<blockquote>
<blockquote>
<p>I don't believe "extension by zero" makes sense mathematically.</p>
</blockquote>
<p>Sure it does; it's a sheaf, not vector bundle. Its fibre is 0 outside <code>U</code>.</p>
</blockquote>
<p>then isn't it just the same as the pushforward</p>

<a name="167778175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167778175" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167778175">Kevin Buzzard (Jun 10 2019 at 17:28)</a>:</h4>
<p>No -- the pushforward you're allowed poles outside U.</p>

<a name="167778360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167778360" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167778360">Kevin Buzzard (Jun 10 2019 at 17:30)</a>:</h4>
<p>Agree on overlaps: mathematically it's easy to say. I want <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ϕ</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\phi_{ij}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="base"><span class="mord"><span class="mord mathit">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">i</span><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"></span></span></span></span></span></span></span></span> to send (the restriction of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">t_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.61508em;"></span><span class="strut bottom" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi><mo>∩</mo><msub><mi>U</mi><mi>i</mi></msub><mo>∩</mo><msub><mi>U</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">U\cap U_i\cap U_j</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="mbin">∩</span><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mbin">∩</span><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"></span></span></span></span></span></span></span></span>) to (the restriction of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">t_j</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.61508em;"></span><span class="strut bottom" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="base"><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"></span></span></span></span></span></span></span></span> to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi><mo>∩</mo><msub><mi>U</mi><mi>i</mi></msub><mo>∩</mo><msub><mi>U</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">U\cap U_i\cap U_j</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="mbin">∩</span><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mbin">∩</span><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"></span></span></span></span></span></span></span></span>)</p>

<a name="167778418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167778418" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167778418">Kenny Lau (Jun 10 2019 at 17:31)</a>:</h4>
<p>but isn't it also a philosophy in maths that we don't talk about equality / subset relations between two unrelated sets / groups / rings?</p>

<a name="167778440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167778440" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167778440">Kevin Buzzard (Jun 10 2019 at 17:31)</a>:</h4>
<p>I'm using <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ϕ</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\phi_{ij}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="base"><span class="mord"><span class="mord mathit">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">i</span><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"></span></span></span></span></span></span></span></span> -- that's the glue.</p>

<a name="167778511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167778511" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167778511">Kenny Lau (Jun 10 2019 at 17:32)</a>:</h4>
<p>oh right we're gluing along an isomorphism</p>

<a name="167778526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167778526" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167778526">Kevin Buzzard (Jun 10 2019 at 17:32)</a>:</h4>
<p>the problem with formalising all this in Lean is that I have all these terms of type <code>open A</code> and I want them to be of type <code>open B</code> so I seem to be forever writing explicit results going from one random open set in some space to another random open set in another space.</p>

<a name="167778559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167778559" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167778559">Kevin Buzzard (Jun 10 2019 at 17:33)</a>:</h4>
<p>On the tube home I tried implementing your solution Kenny, but this seems to involve rewriting all definitions of sheaves and presheaves.</p>

<a name="167778645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167778645" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167778645">Kevin Buzzard (Jun 10 2019 at 17:34)</a>:</h4>
<p>Because now I want to talk about a top space X, and an open subset U, and a sheaf-on-U, which takes as input an open subset of X and a proof that it's a subset of U, and spits out a ring, and now the sheaf axiom etc all need to be redone in this context.</p>

<a name="167778662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167778662" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167778662">Kenny Lau (Jun 10 2019 at 17:34)</a>:</h4>
<p><a href="/user_uploads/3121/P49Gh-JrLfgrKr0Ov-ZTms65/2019-06-10-2.png" target="_blank" title="2019-06-10-2.png">gluing-vs-glueing</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/P49Gh-JrLfgrKr0Ov-ZTms65/2019-06-10-2.png" target="_blank" title="gluing-vs-glueing"><img src="/user_uploads/3121/P49Gh-JrLfgrKr0Ov-ZTms65/2019-06-10-2.png"></a></div>

<a name="167778670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167778670" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167778670">Kenny Lau (Jun 10 2019 at 17:34)</a>:</h4>
<p>Also maybe it's time to care about spelling</p>

<a name="167778673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167778673" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167778673">Kevin Buzzard (Jun 10 2019 at 17:34)</a>:</h4>
<p>As I said before, it feels very much like Assia's approach to proving Zassenhaus by having every group living in a bigger group</p>

<a name="167778685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167778685" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167778685">Kenny Lau (Jun 10 2019 at 17:35)</a>:</h4>
<p>ok I'll try formulating the statement</p>

<a name="167778712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167778712" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167778712">Kevin Buzzard (Jun 10 2019 at 17:35)</a>:</h4>
<p>In which context?</p>

<a name="167778720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167778720" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167778720">Kevin Buzzard (Jun 10 2019 at 17:35)</a>:</h4>
<p>It seems to me that there is a big design decision to be made here.</p>

<a name="167778802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167778802" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167778802">Kevin Buzzard (Jun 10 2019 at 17:36)</a>:</h4>
<p>Sheaves-on-an-open-subset, or go full category, or this type-theory-friendly approach which involves defining "sheaf on U" as "sheaf on X except not quite"</p>

<a name="167778861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167778861" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167778861">Kenny Lau (Jun 10 2019 at 17:37)</a>:</h4>
<p>well I still stand by my approach :P</p>

<a name="167778868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167778868" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167778868">Kevin Buzzard (Jun 10 2019 at 17:37)</a>:</h4>
<p>I suspect you want to do the type-theory-friendly approach, but in some sense this brings into question Ramon's very definition of a sheaf.</p>

<a name="167778991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167778991" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167778991">Kevin Buzzard (Jun 10 2019 at 17:38)</a>:</h4>
<p>Does one then have two definitions of a sheaf? Sheaf-on-a-subset and then you define sheaf to be sheaf-on-a-subset-but-the-subset-is-X? And then you have to supply lots of proofs of X \subseteq X  everywhere?</p>

<a name="167779012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167779012" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167779012">Kenny Lau (Jun 10 2019 at 17:38)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">sheaf_on_open_subset</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="o">(</span><span class="n">v</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">sheaf</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span> <span class="n">v</span><span class="o">}</span> <span class="n">X</span>
</pre></div>

<a name="167779612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167779612" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167779612">Kevin Buzzard (Jun 10 2019 at 17:46)</a>:</h4>
<p>You'll get laughed at in the maths department</p>

<a name="167780167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167780167" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167780167">Kenny Lau (Jun 10 2019 at 17:52)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">sheaves</span><span class="bp">.</span><span class="n">sheaf</span>

<span class="n">universes</span> <span class="n">v</span> <span class="n">u</span> <span class="n">w</span>

<span class="kn">open</span> <span class="n">topological_space</span>

<span class="n">def</span> <span class="n">sheaf_on_opens</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="o">(</span><span class="n">v</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">sheaf</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span> <span class="n">v</span><span class="o">}</span> <span class="n">X</span>

<span class="kn">namespace</span> <span class="n">sheaf_on_opens</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">{</span><span class="n">U</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">}</span>

<span class="n">def</span> <span class="kn">eval</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">sheaf_on_opens</span> <span class="n">X</span> <span class="n">U</span><span class="o">)</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">HVU</span> <span class="o">:</span> <span class="n">V</span> <span class="err">⊆</span> <span class="n">U</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span> <span class="o">:=</span>
<span class="n">presheaf</span><span class="bp">.</span><span class="n">F</span> <span class="o">(</span><span class="n">sheaf</span><span class="bp">.</span><span class="n">F</span> <span class="n">F</span><span class="o">)</span> <span class="n">V</span>

<span class="n">def</span> <span class="n">res</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">sheaf_on_opens</span> <span class="n">X</span> <span class="n">U</span><span class="o">)</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">HVU</span> <span class="o">:</span> <span class="n">V</span> <span class="err">⊆</span> <span class="n">U</span><span class="o">)</span> <span class="o">(</span><span class="n">W</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">HWU</span> <span class="o">:</span> <span class="n">W</span> <span class="err">⊆</span> <span class="n">U</span><span class="o">)</span> <span class="o">(</span><span class="n">HWV</span> <span class="o">:</span> <span class="n">W</span> <span class="err">⊆</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">F</span><span class="bp">.</span><span class="kn">eval</span> <span class="n">V</span> <span class="n">HVU</span> <span class="bp">→</span> <span class="n">F</span><span class="bp">.</span><span class="kn">eval</span> <span class="n">W</span> <span class="n">HWU</span> <span class="o">:=</span>
<span class="n">presheaf</span><span class="bp">.</span><span class="n">res</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">HWV</span>

<span class="n">def</span> <span class="n">res_subset</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">sheaf_on_opens</span> <span class="n">X</span> <span class="n">U</span><span class="o">)</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">HVU</span> <span class="o">:</span> <span class="n">V</span> <span class="err">⊆</span> <span class="n">U</span><span class="o">)</span> <span class="o">:</span> <span class="n">sheaf_on_opens</span> <span class="n">X</span> <span class="n">V</span> <span class="o">:=</span>
<span class="n">F</span>

<span class="kn">structure</span> <span class="n">morphism</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">sheaf_on_opens</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">X</span> <span class="n">U</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">sheaf_on_opens</span><span class="bp">.</span><span class="o">{</span><span class="n">w</span><span class="o">}</span> <span class="n">X</span> <span class="n">U</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">map</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">V</span> <span class="err">⊆</span> <span class="n">U</span><span class="o">,</span> <span class="n">F</span><span class="bp">.</span><span class="kn">eval</span> <span class="n">V</span> <span class="n">H</span> <span class="bp">→</span> <span class="n">G</span><span class="bp">.</span><span class="kn">eval</span> <span class="n">V</span> <span class="n">H</span><span class="o">)</span>
<span class="o">(</span><span class="n">commutes</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">HV</span> <span class="o">:</span> <span class="n">V</span> <span class="err">⊆</span> <span class="n">U</span><span class="o">)</span> <span class="o">(</span><span class="n">W</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">HW</span> <span class="o">:</span> <span class="n">W</span> <span class="err">⊆</span> <span class="n">U</span><span class="o">)</span> <span class="o">(</span><span class="n">HWV</span> <span class="o">:</span> <span class="n">W</span> <span class="err">⊆</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span><span class="o">),</span>
  <span class="n">map</span> <span class="n">W</span> <span class="n">HW</span> <span class="o">(</span><span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">V</span> <span class="n">HV</span> <span class="n">W</span> <span class="n">HW</span> <span class="n">HWV</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">G</span><span class="bp">.</span><span class="n">res</span> <span class="n">V</span> <span class="n">HV</span> <span class="n">W</span> <span class="n">HW</span> <span class="n">HWV</span> <span class="o">(</span><span class="n">map</span> <span class="n">V</span> <span class="n">HV</span> <span class="n">x</span><span class="o">))</span>

<span class="kn">end</span> <span class="n">sheaf_on_opens</span>
</pre></div>

<a name="167780190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167780190" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167780190">Kenny Lau (Jun 10 2019 at 17:53)</a>:</h4>
<blockquote>
<p>You'll get laughed at in the maths department</p>
</blockquote>
<p>so maybe I should LaTeX the whole thing instead</p>

<a name="167780216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167780216" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167780216">Kevin Buzzard (Jun 10 2019 at 17:53)</a>:</h4>
<p>rofl. Hey, I would recommend not using two universes. Why not just use one?</p>

<a name="167823735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167823735" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167823735">Johan Commelin (Jun 11 2019 at 06:42)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> Can you prove that <code>f _*</code> and <code>f ^*</code> are adjoint (with or without using <code>category_theory/</code>)?</p>

<a name="167823754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167823754" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167823754">Kevin Buzzard (Jun 11 2019 at 06:43)</a>:</h4>
<p>We don't even have f^* apart from for open maps.</p>

<a name="167823775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167823775" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167823775">Johan Commelin (Jun 11 2019 at 06:44)</a>:</h4>
<p>Sure... but a sheaves API without this adjunction is quite incomplete.</p>

<a name="167823804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167823804" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167823804">Kevin Buzzard (Jun 11 2019 at 06:44)</a>:</h4>
<p>(maybe even only for open immersions)</p>

<a name="167823833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167823833" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167823833">Johan Commelin (Jun 11 2019 at 06:44)</a>:</h4>
<p>Any decent approach to sheaves should at least give us sheafification and this adjunction.</p>

<a name="167823843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167823843" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167823843">Kevin Buzzard (Jun 11 2019 at 06:44)</a>:</h4>
<p>And if we did it for sheaves of types you'd say it was incomplete because we didn't have it for sheaves of groups, rings, modules...</p>

<a name="167823855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167823855" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167823855">Kevin Buzzard (Jun 11 2019 at 06:45)</a>:</h4>
<p>There's still loads to do.</p>

<a name="167823859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167823859" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167823859">Johan Commelin (Jun 11 2019 at 06:45)</a>:</h4>
<p>In the end, I don't care how we get there. (Implementation details, like you say.)</p>

<a name="167823879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167823879" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167823879">Johan Commelin (Jun 11 2019 at 06:45)</a>:</h4>
<blockquote>
<p>And if we did it for sheaves of types you'd say it was incomplete because we didn't have it for sheaves of groups, rings, modules...</p>
</blockquote>
<p>No, not really. I can kind of see how we would bolt that on afterwards.</p>


{% endraw %}

{% include archive_update.html %}