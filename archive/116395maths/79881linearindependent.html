---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/116395maths/79881linearindependent.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html">linear_independent</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="159603444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159603444" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159603444">Johan Commelin (Feb 28 2019 at 10:36)</a>:</h4>
<p>If my goal is <code>linear_independent K s</code>,<br>
how do I turn this into the statement that the coefficient <code>a_i</code> is zero if <code>sum a_i s_i = 0</code>?<br>
This part of the API seems to do lots of abstract stuff, but I'm missing this down to earth condition.</p>

<a name="159603459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159603459" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159603459">Johan Commelin (Feb 28 2019 at 10:37)</a>:</h4>
<p>Maybe it is hidden in 5 layers of defeqs, but that doesn't seem user friendly to me.</p>

<a name="159604575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159604575" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159604575">Johan Commelin (Feb 28 2019 at 10:56)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> Any hints?</p>

<a name="159604804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159604804" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159604804">Kenny Lau (Feb 28 2019 at 11:00)</a>:</h4>
<p>oh no</p>

<a name="159604835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159604835" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159604835">Kenny Lau (Feb 28 2019 at 11:01)</a>:</h4>
<p>iirc the lemma isn’t there</p>

<a name="159606747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159606747" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159606747">Johannes Hölzl (Feb 28 2019 at 11:35)</a>:</h4>
<p>There is <code>linear_independent_iff</code>and <code>lc.total</code> is the sum operator</p>

<a name="159606764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159606764" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159606764">Johannes Hölzl (Feb 28 2019 at 11:36)</a>:</h4>
<p>by the way, I'm working on adding the linear structure on the function (pi) space &amp; for finsupp if you need this</p>

<a name="159620546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159620546" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159620546">Johan Commelin (Feb 28 2019 at 14:56)</a>:</h4>
<p>I'm feeling really miserable today. People have said that it is a sobering thought that Lean does not know complex analysis. Well, as far as I know Lean also doesn't know anything about finite-dimensional vector spaces. And that's quite depressing.<br>
I've tried to prove that V and its dual have the same dimension, and I get stuck in a maze of complicated definitions that don't fit in my brain-RAM. It probably means that I haven't understood the API for linear maps and modules... I'm not sure if that says something about me, or about the API.</p>

<a name="159623030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159623030" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159623030">Mario Carneiro (Feb 28 2019 at 15:24)</a>:</h4>
<p>Do we have the dual vector space?</p>

<a name="159623171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159623171" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159623171">Patrick Massot (Feb 28 2019 at 15:26)</a>:</h4>
<p>If we have linear maps and the instance saying that a field is a vector space over itself then we have duals, right?</p>

<a name="159623219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159623219" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159623219">Mario Carneiro (Feb 28 2019 at 15:27)</a>:</h4>
<p>right. I'm trying to reconstruct the proof Johan is talking about</p>

<a name="159623313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159623313" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159623313">Mario Carneiro (Feb 28 2019 at 15:28)</a>:</h4>
<p>what's the basis for the dual space?</p>

<a name="159623329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159623329" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159623329">Patrick Massot (Feb 28 2019 at 15:28)</a>:</h4>
<p>I agree that the status of linear algebra in mathlib is much more depressing than the status of complex analysis. But we need to make choices, we can't work on everything at the same time</p>

<a name="159623346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159623346" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159623346">Patrick Massot (Feb 28 2019 at 15:28)</a>:</h4>
<p>If you have a basis for the original space then you get the dual basis</p>

<a name="159623347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159623347" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159623347">Mario Carneiro (Feb 28 2019 at 15:28)</a>:</h4>
<p>do you have to invent an inner product to define the dual basis</p>

<a name="159623352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159623352" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159623352">Patrick Massot (Feb 28 2019 at 15:28)</a>:</h4>
<p>no</p>

<a name="159623408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159623408" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159623408">Patrick Massot (Feb 28 2019 at 15:29)</a>:</h4>
<p>If the basis is (e_1, ..., e_n) then the dual basis is defined by l_i(e_j) = 1 if i =j, 0 otherwise</p>

<a name="159623427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159623427" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159623427">Patrick Massot (Feb 28 2019 at 15:29)</a>:</h4>
<p>You need to know that a linear map can be specified by specifying it on a basis</p>

<a name="159623489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159623489" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159623489">Mario Carneiro (Feb 28 2019 at 15:30)</a>:</h4>
<p>okay. We have that though</p>

<a name="159623503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159623503" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159623503">Mario Carneiro (Feb 28 2019 at 15:30)</a>:</h4>
<p>I think it's called <code>constr</code></p>

<a name="159623527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159623527" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159623527">Mario Carneiro (Feb 28 2019 at 15:30)</a>:</h4>
<p>But this isn't always a basis, right? in infinite dimensions it breaks down</p>

<a name="159623582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159623582" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159623582">Patrick Massot (Feb 28 2019 at 15:31)</a>:</h4>
<p>You don't talk about basis in infinite dimension, this would be a bad idea</p>

<a name="159623595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159623595" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159623595">Mario Carneiro (Feb 28 2019 at 15:31)</a>:</h4>
<p>So we have a <code>dual_basis</code> function that takes any basis and makes a lin ind set in the dual space</p>

<a name="159623632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159623632" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159623632">Mario Carneiro (Feb 28 2019 at 15:31)</a>:</h4>
<p>and if the original space is f.d then it's also a basis</p>

<a name="159623681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159623681" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159623681">Patrick Massot (Feb 28 2019 at 15:32)</a>:</h4>
<p>yes</p>

<a name="159623791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159623791" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159623791">Patrick Massot (Feb 28 2019 at 15:33)</a>:</h4>
<p>In infinite dimensions the dual tends to be bigger than the original space</p>

<a name="159623804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159623804" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159623804">Mario Carneiro (Feb 28 2019 at 15:33)</a>:</h4>
<p>oh right, I just remembered that I had plans to redo <code>linear_independent</code> because it uses sets instead of families</p>

<a name="159623823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159623823" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159623823">Patrick Massot (Feb 28 2019 at 15:33)</a>:</h4>
<p>ooh</p>

<a name="159623884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159623884" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159623884">Patrick Massot (Feb 28 2019 at 15:34)</a>:</h4>
<p>That would be nice</p>

<a name="159623916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159623916" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159623916">Mario Carneiro (Feb 28 2019 at 15:34)</a>:</h4>
<p>it's a lot more natural for everything except zorn's lemma</p>

<a name="159623931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159623931" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159623931">Mario Carneiro (Feb 28 2019 at 15:34)</a>:</h4>
<p>but that's just one proof</p>

<a name="159623996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159623996" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159623996">Patrick Massot (Feb 28 2019 at 15:35)</a>:</h4>
<p>Let's do more elementary maths since Jeremy opened the way with calculus. But not too elementary, I just spend one hour teaching how to "prove" the equivalence of five definitions of "convex polygon", I will never ever try to Lean that "proof"</p>

<a name="159624107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159624107" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159624107">Patrick Massot (Feb 28 2019 at 15:36)</a>:</h4>
<p>I makes me think we need a Johannes countdown topic. I think we are getting dangerously close, and we still don't have integrals</p>

<a name="159626245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159626245" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159626245">Johan Commelin (Feb 28 2019 at 15:57)</a>:</h4>
<p>Sorry, I was away for a while, because someone entered my office. Now I need to catch a train, so I will just dump the contents of my depression in this chat:</p>
<div class="codehilite"><pre><span></span><span class="c">/-</span><span class="cm"></span>
<span class="cm">Copyright (c) 2019 Johan Commelin. All rights reserved.</span>
<span class="cm">Released under Apache 2.0 license as described in the file LICENSE.</span>
<span class="cm">Authors: Johan Commelin</span>
<span class="cm">-/</span>

<span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">dimension</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">tensor_product</span>
<span class="kn">import</span> <span class="n">set_theory</span><span class="bp">.</span><span class="n">ordinal</span>
<span class="n">noncomputable</span> <span class="n">theory</span>

<span class="n">local</span> <span class="n">attribute</span> <span class="o">[</span><span class="kn">instance</span><span class="o">]</span> <span class="n">classical</span><span class="bp">.</span><span class="n">prop_decidable</span>

<span class="kn">section</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="kn">variables</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>

<span class="n">def</span> <span class="n">module</span><span class="bp">.</span><span class="n">dual</span> <span class="o">:=</span> <span class="n">M</span> <span class="bp">→</span><span class="err">ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">R</span>

<span class="kn">open</span> <span class="n">module</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">add_comm_group</span> <span class="o">(</span><span class="n">dual</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">delta</span> <span class="n">dual</span><span class="bp">;</span> <span class="n">apply_instance</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">module</span> <span class="n">R</span> <span class="o">(</span><span class="n">dual</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">delta</span> <span class="n">dual</span><span class="bp">;</span> <span class="n">apply_instance</span>

<span class="n">def</span> <span class="kn">eval</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span><span class="err">ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">dual</span> <span class="n">R</span> <span class="o">(</span><span class="n">dual</span> <span class="n">R</span> <span class="n">M</span><span class="o">))</span> <span class="o">:=</span> <span class="n">linear_map</span><span class="bp">.</span><span class="n">id</span><span class="bp">.</span><span class="n">flip</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">R</span><span class="o">}</span> <span class="o">{</span><span class="n">M</span><span class="o">}</span>
<span class="n">def</span> <span class="n">pairing</span> <span class="o">:</span> <span class="o">(</span><span class="n">dual</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">R</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span><span class="err">ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">R</span><span class="o">)</span> <span class="n">m</span><span class="o">,</span> <span class="n">f</span> <span class="n">m</span>

<span class="kn">end</span>

<span class="kn">namespace</span> <span class="n">is_basis</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
<span class="kn">variables</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">K</span> <span class="n">V</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">is_basis</span> <span class="n">K</span> <span class="n">B</span><span class="o">)</span>
<span class="n">include</span> <span class="n">h</span>
<span class="kn">open</span> <span class="n">vector_space</span> <span class="n">module</span> <span class="n">submodule</span> <span class="n">linear_map</span> <span class="n">cardinal</span>

<span class="n">def</span> <span class="n">dual</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">module</span><span class="bp">.</span><span class="n">dual</span> <span class="n">K</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span><span class="err">ₗ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">v</span> <span class="err">∈</span> <span class="n">B</span><span class="o">,</span> <span class="n">f</span> <span class="n">v</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">w</span> <span class="err">∈</span> <span class="n">B</span><span class="o">,</span> <span class="n">w</span> <span class="bp">≠</span> <span class="n">v</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">w</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">}</span>

<span class="n">def</span> <span class="n">dual_elem</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">module</span><span class="bp">.</span><span class="n">dual</span> <span class="n">K</span> <span class="n">V</span> <span class="o">:=</span>
<span class="n">h</span><span class="bp">.</span><span class="n">constr</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">w</span><span class="o">,</span> <span class="k">if</span> <span class="n">w</span> <span class="bp">=</span> <span class="n">v</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span>

<span class="kn">lemma</span> <span class="n">dual_elem_mem</span> <span class="o">(</span><span class="n">v</span> <span class="err">∈</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">h</span><span class="bp">.</span><span class="n">dual_elem</span> <span class="n">v</span> <span class="err">∈</span> <span class="n">h</span><span class="bp">.</span><span class="n">dual</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">use</span> <span class="o">[</span><span class="n">v</span><span class="o">,</span><span class="n">H</span><span class="o">],</span>
  <span class="n">split</span><span class="bp">;</span> <span class="n">intros</span><span class="bp">;</span> <span class="n">erw</span> <span class="o">[</span><span class="n">constr_basis</span><span class="o">]</span><span class="bp">;</span> <span class="n">simp</span> <span class="bp">*</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">mem_dual_iff</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">module</span><span class="bp">.</span><span class="n">dual</span> <span class="n">K</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f</span> <span class="err">∈</span> <span class="n">h</span><span class="bp">.</span><span class="n">dual</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">v</span> <span class="err">∈</span> <span class="n">B</span><span class="o">,</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">h</span><span class="bp">.</span><span class="n">dual_elem</span> <span class="n">v</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">split</span><span class="bp">;</span> <span class="n">intro</span> <span class="n">H</span><span class="bp">;</span> <span class="n">rcases</span> <span class="n">H</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">hv</span><span class="o">,</span> <span class="n">H</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">use</span> <span class="o">[</span><span class="n">v</span><span class="o">,</span><span class="n">hv</span><span class="o">],</span>
    <span class="n">apply</span> <span class="n">h</span><span class="bp">.</span><span class="n">ext</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">w</span> <span class="n">hw</span><span class="o">,</span>
    <span class="n">erw</span> <span class="o">[</span><span class="n">constr_basis</span> <span class="bp">_</span> <span class="n">hw</span><span class="o">],</span>
    <span class="n">split_ifs</span> <span class="k">with</span> <span class="n">hwv</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">hwv</span><span class="o">,</span> <span class="n">exact</span> <span class="n">H</span><span class="bp">.</span><span class="mi">1</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">apply</span> <span class="n">H</span><span class="bp">.</span><span class="mi">2</span> <span class="n">w</span> <span class="n">hw</span> <span class="n">hwv</span><span class="o">,</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">H</span><span class="o">,</span> <span class="n">apply</span> <span class="n">h</span><span class="bp">.</span><span class="n">dual_elem_mem</span> <span class="n">v</span> <span class="n">hv</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">dual_elem_eq_repr</span> <span class="o">(</span><span class="n">v</span> <span class="err">∈</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">pairing</span> <span class="o">(</span><span class="n">h</span><span class="bp">.</span><span class="n">dual_elem</span> <span class="n">v</span><span class="o">)</span> <span class="n">w</span> <span class="bp">=</span> <span class="n">h</span><span class="bp">.</span><span class="n">repr</span> <span class="n">w</span> <span class="n">v</span> <span class="o">:=</span>
<span class="bp">_</span>

<span class="n">def</span> <span class="n">to_dual</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span><span class="err">ₗ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">module</span><span class="bp">.</span><span class="n">dual</span> <span class="n">K</span> <span class="n">V</span> <span class="o">:=</span>
<span class="n">h</span><span class="bp">.</span><span class="n">constr</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">v</span><span class="o">,</span> <span class="n">h</span><span class="bp">.</span><span class="n">dual_elem</span> <span class="n">v</span>

<span class="kn">lemma</span> <span class="n">to_dual_ker</span> <span class="o">:</span> <span class="n">h</span><span class="bp">.</span><span class="n">to_dual</span><span class="bp">.</span><span class="n">ker</span> <span class="bp">=</span> <span class="err">⊥</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">ext</span> <span class="n">v</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">mem_ker</span><span class="o">,</span> <span class="n">mem_bot</span><span class="o">],</span>
    <span class="n">intro</span> <span class="n">hv</span><span class="o">,</span>
    <span class="n">sorry</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">mem_bot</span><span class="o">,</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">],</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="c1">-- lemma lc_dual_elem (l : lc K (module.dual K V))</span>
<span class="c1">-- (hl : ∀ (f : module.dual K V), f ∉ h.dual → l f = 0)</span>
<span class="c1">-- (v : V) (hv : v ∈ B) :</span>
<span class="c1">--   l (h.dual_elem v hv) = (pairing K V).to_fun</span>
<span class="c1">--     ((lc.total K (module.dual K V)).to_fun l) v :=</span>
<span class="c1">-- begin</span>
<span class="c1">--   have := lc.total_apply l,</span>
<span class="c1">--   change ((lc.total K (module.dual K V)).to_fun l) = _ at this,</span>
<span class="c1">--   erw this, clear this,</span>
<span class="c1">--   erw finsupp.apply_sum,</span>
<span class="c1">--   revert hl,</span>
<span class="c1">--   apply finsupp.induction l,</span>
<span class="c1">--   { intro hl,</span>
<span class="c1">--     rw [finsupp.zero_apply, finsupp.sum_zero_index],</span>
<span class="c1">--     symmetry,</span>
<span class="c1">--     apply zero_apply v, },</span>
<span class="c1">--   { intros f k l&#39; _ _ IH hl&#39;,</span>
<span class="c1">--     rw [finsupp.add_apply, IH, finsupp.sum_add_index,</span>
<span class="c1">--         finsupp.sum_single_index],</span>
<span class="c1">--     { congr&#39; 1,</span>
<span class="c1">--       by_cases H : f ∈ h.dual,</span>
<span class="c1">--         { rw [finsupp.single_apply, smul_apply],</span>
<span class="c1">--           split_ifs with hf,</span>
<span class="c1">--           { rw [hf, dual_elem, constr_basis _ hv], simp, },</span>
<span class="c1">--           sorry },</span>
<span class="c1">--         {  }</span>
<span class="c1">--        } } }</span>
<span class="c1">-- end</span>

<span class="kn">lemma</span> <span class="n">dual_is_basis</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">is_basis</span> <span class="n">K</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">hfin</span> <span class="o">:</span> <span class="n">dim</span> <span class="n">K</span> <span class="n">V</span> <span class="bp">&lt;</span> <span class="n">omega</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">is_basis</span> <span class="n">K</span> <span class="o">(</span><span class="n">h</span><span class="bp">.</span><span class="n">dual</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">sorry</span> <span class="o">},</span>
  <span class="c1">-- { rw [linear_independent_iff],</span>
  <span class="c1">--   intros l hl H,</span>
  <span class="c1">--   ext f,</span>
  <span class="c1">--   by_cases hf : f ∈ h.dual,</span>
  <span class="c1">--   { rw lc.total_apply at H,</span>
  <span class="c1">--     rw mem_dual_iff at hf,</span>
  <span class="c1">--     rcases hf with ⟨v, hv, hf⟩,</span>
  <span class="c1">--     rw hf,</span>
  <span class="c1">--     sorry },</span>
  <span class="c1">--   { rw [lc.mem_supported&#39;] at hl,</span>
  <span class="c1">--     apply hl f hf, } },</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">le_antisymm</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>

      <span class="n">sorry</span> <span class="o">}</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="kn">end</span> <span class="n">is_basis</span>

<span class="kn">lemma</span> <span class="n">eval_ker</span> <span class="o">:</span> <span class="o">(</span><span class="kn">eval</span> <span class="n">K</span> <span class="n">V</span><span class="o">)</span><span class="bp">.</span><span class="n">ker</span> <span class="bp">=</span> <span class="err">⊥</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">ext</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">mem_ker</span><span class="o">,</span> <span class="n">mem_bot</span><span class="o">],</span>
    <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">sorry</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">mem_bot</span><span class="o">,</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">],</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="kn">end</span>
</pre></div>

<a name="159626775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159626775" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159626775">Patrick Massot (Feb 28 2019 at 16:03)</a>:</h4>
<p>Indeed there are too many sets in this story</p>

<a name="159627966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159627966" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159627966">Johan Commelin (Feb 28 2019 at 16:16)</a>:</h4>
<p>By the way, today's xkcd is also about depressing elementary topics: <a href="https://xkcd.com/2117/" target="_blank" title="https://xkcd.com/2117/">https://xkcd.com/2117/</a><br>
Maybe this can cheer us up a bit...</p>

<a name="159630167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159630167" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159630167">Mario Carneiro (Feb 28 2019 at 16:42)</a>:</h4>
<p>the definition of <code>is_basis.dual</code> is definitely not going to be easy to work with</p>

<a name="159630333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159630333" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159630333">Mario Carneiro (Feb 28 2019 at 16:44)</a>:</h4>
<p>BTW I think that XKCD is a great example of why decidability matters in mathematics</p>

<a name="159632123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159632123" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159632123">Kevin Buzzard (Feb 28 2019 at 17:07)</a>:</h4>
<p>Differentiation is a science, integration is an art.</p>

<a name="159634187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159634187" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159634187">Johannes Hölzl (Feb 28 2019 at 17:33)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> I'm currently preparing a push for the vector space structure of the function space and for finsupp: <a href="https://github.com/johoelzl/mathlib/commits/master" target="_blank" title="https://github.com/johoelzl/mathlib/commits/master">https://github.com/johoelzl/mathlib/commits/master</a> (specially <a href="https://github.com/johoelzl/mathlib/commit/c83c049126030c524cf63e70273635b5d9f26476" target="_blank" title="https://github.com/johoelzl/mathlib/commit/c83c049126030c524cf63e70273635b5d9f26476">https://github.com/johoelzl/mathlib/commit/c83c049126030c524cf63e70273635b5d9f26476</a> and <a href="https://github.com/johoelzl/mathlib/commit/592e3c7a2dfbd5826919b4605559d35d4d75938f" target="_blank" title="https://github.com/johoelzl/mathlib/commit/592e3c7a2dfbd5826919b4605559d35d4d75938f">https://github.com/johoelzl/mathlib/commit/592e3c7a2dfbd5826919b4605559d35d4d75938f</a>)</p>

<a name="159634277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159634277" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159634277">Johannes Hölzl (Feb 28 2019 at 17:34)</a>:</h4>
<p>I don't know if any of this material might help for your proof</p>

<a name="159634457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159634457" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159634457">Johannes Hölzl (Feb 28 2019 at 17:37)</a>:</h4>
<p>Instead of defining <code>is_basis.dual</code> directly, it might be easier to use the image of <code>dual_elem</code></p>

<a name="159634522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159634522" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159634522">Johan Commelin (Feb 28 2019 at 17:38)</a>:</h4>
<p>Hmm, I don't think that's where the problems are... the <code>iff</code> that I prove afterwards let's you move between the two.</p>

<a name="159634523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159634523" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159634523">Johannes Hölzl (Feb 28 2019 at 17:38)</a>:</h4>
<p>Ah, that's what <code>mem_dual</code> is for</p>

<a name="159634572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159634572" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159634572">Johan Commelin (Feb 28 2019 at 17:39)</a>:</h4>
<p>It's just that I'm running into many type class errors because it doesn't know how to coerce a linear map into a function. And then I manually add <code>.to_fun</code> and it typechecks, but then all sorts of <code>rw</code> and <code>simp</code> don't trigger. And it's just a pain.</p>

<a name="159634646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159634646" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159634646">Johan Commelin (Feb 28 2019 at 17:40)</a>:</h4>
<p>It also made me a bit worried about if bundling + coercions is a good idea...</p>

<a name="159634670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159634670" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159634670">Johannes Hölzl (Feb 28 2019 at 17:40)</a>:</h4>
<p>the coercion into functions worked quiet well for me</p>

<a name="159634704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159634704" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159634704">Johannes Hölzl (Feb 28 2019 at 17:41)</a>:</h4>
<p>I had more problems with the decidability instance required for finsupp</p>

<a name="159636754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159636754" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159636754">Johan Commelin (Feb 28 2019 at 18:09)</a>:</h4>
<p>I couldn't apply <code>lc.total _ _</code> to an <code>l : lc</code> in theorem statements.</p>

<a name="159636763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159636763" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159636763">Johan Commelin (Feb 28 2019 at 18:09)</a>:</h4>
<p>You can see the hackery in the code dump above.</p>

<a name="159636798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159636798" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159636798">Johan Commelin (Feb 28 2019 at 18:09)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="c1">-- lemma lc_dual_elem (l : lc K (module.dual K V))</span>
<span class="c1">-- (hl : ∀ (f : module.dual K V), f ∉ h.dual → l f = 0)</span>
<span class="c1">-- (v : V) (hv : v ∈ B) :</span>
<span class="c1">--   l (h.dual_elem v hv) = (pairing K V).to_fun</span>
<span class="c1">--     ((lc.total K (module.dual K V)).to_fun l) v :=</span>
<span class="c1">-- begin</span>
<span class="c1">--   have := lc.total_apply l,</span>
<span class="c1">--   change ((lc.total K (module.dual K V)).to_fun l) = _ at this,</span>
<span class="c1">--   erw this, clear this,</span>
</pre></div>

<a name="159636869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159636869" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159636869">Johan Commelin (Feb 28 2019 at 18:10)</a>:</h4>
<p>I have to write <code>((lc.total K (module.dual K V)).to_fun l</code></p>

<a name="159636906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_independent/near/159636906" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/79881linearindependent.html#159636906">Johan Commelin (Feb 28 2019 at 18:10)</a>:</h4>
<p>And then the first 3 lines of the proof are hackery to get <code>lc.total_apply</code> working.</p>


{% endraw %}

{% include archive_update.html %}