---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/116395maths/50915TurnasetyYexistsxinAyfxintofA.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/50915TurnasetyYexistsxinAyfxintofA.html">Turn a set { y : Y | exists x \in A, y = f x } into (f '' A)</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="192809665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Turn%20a%20set%20%7B%20y%20%3A%20Y%20%7C%20exists%20x%20%5Cin%20A%2C%20y%20%3D%20f%20x%20%7D%20into%20%28f%20%27%27%20A%29/near/192809665" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/50915TurnasetyYexistsxinAyfxintofA.html#192809665">Ryan Lahfa (Apr 03 2020 at 14:15)</a>:</h4>
<p>I often dabble with sets which are images or preimages but I'm not sure how to switch between those two forms easily, I often do quick proofs of what I mentioned in the title, which I feel sub-efficient.</p>
<p>I read many times the docs of sets but never found something close to those facts, I just realized that maybe it could be hidden in <code>set.range</code> definition. But I'm not too much up-to-date with subtypes → sets relations.</p>

<a name="192809874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Turn%20a%20set%20%7B%20y%20%3A%20Y%20%7C%20exists%20x%20%5Cin%20A%2C%20y%20%3D%20f%20x%20%7D%20into%20%28f%20%27%27%20A%29/near/192809874" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/50915TurnasetyYexistsxinAyfxintofA.html#192809874">Patrick Massot (Apr 03 2020 at 14:16)</a>:</h4>
<p>MWE?</p>

<a name="192809995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Turn%20a%20set%20%7B%20y%20%3A%20Y%20%7C%20exists%20x%20%5Cin%20A%2C%20y%20%3D%20f%20x%20%7D%20into%20%28f%20%27%27%20A%29/near/192809995" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/50915TurnasetyYexistsxinAyfxintofA.html#192809995">Johan Commelin (Apr 03 2020 at 14:17)</a>:</h4>
<p><span class="user-mention" data-user-id="262143">@Ryan Lahfa</span> I think that you should almost always prefer the <code>f '' A</code> form, and use <code>rw set.mem_image</code> and friends when you have things like <code>x \in f '' A</code></p>

<a name="192810219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Turn%20a%20set%20%7B%20y%20%3A%20Y%20%7C%20exists%20x%20%5Cin%20A%2C%20y%20%3D%20f%20x%20%7D%20into%20%28f%20%27%27%20A%29/near/192810219" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/50915TurnasetyYexistsxinAyfxintofA.html#192810219">Ryan Lahfa (Apr 03 2020 at 14:18)</a>:</h4>
<p>Let's take this small working example:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">cau_seq</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">finite</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">finset</span>
<span class="kn">import</span> <span class="n">order</span><span class="bp">.</span><span class="n">bounds</span>
<span class="kn">import</span> <span class="n">order</span><span class="bp">.</span><span class="n">complete_lattice</span>

<span class="kn">variable</span> <span class="o">{</span><span class="n">X</span><span class="o">:</span> <span class="kt">Type</span><span class="o">}</span>

<span class="n">local</span> <span class="n">attribute</span> <span class="o">[</span><span class="kn">instance</span><span class="o">]</span> <span class="n">classical</span><span class="bp">.</span><span class="n">prop_decidable</span> <span class="c1">-- on active la décidabilité partout.</span>

<span class="n">def</span> <span class="n">suite_st_croissante</span> <span class="o">[</span><span class="n">conditionally_complete_linear_order</span> <span class="n">X</span><span class="o">]</span> <span class="o">{</span><span class="n">S</span><span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">}</span>
  <span class="o">(</span><span class="n">Hinf</span><span class="o">:</span> <span class="n">set</span><span class="bp">.</span><span class="n">infinite</span> <span class="n">S</span><span class="o">)</span>
  <span class="o">(</span><span class="n">Hset</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">M</span> <span class="err">⊆</span> <span class="n">S</span><span class="o">,</span> <span class="n">M</span><span class="bp">.</span><span class="n">nonempty</span> <span class="bp">→</span> <span class="o">(</span><span class="n">Inf</span> <span class="n">M</span> <span class="err">∈</span> <span class="n">M</span><span class="o">))</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">X</span> <span class="o">:=</span>
  <span class="n">well_founded</span><span class="bp">.</span><span class="n">fix</span> <span class="n">nat</span><span class="bp">.</span><span class="n">lt_wf</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="n">suite_st_croissante</span><span class="o">,</span>
    <span class="n">Inf</span> <span class="o">(</span><span class="n">S</span> <span class="err">\</span> <span class="o">{</span> <span class="n">x</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">k</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">,</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">suite_st_croissante</span> <span class="n">k</span> <span class="n">H</span><span class="o">}))</span>

<span class="n">def</span> <span class="n">suite_st_croissante_def</span> <span class="o">[</span><span class="n">conditionally_complete_linear_order</span> <span class="n">X</span><span class="o">]</span> <span class="o">{</span><span class="n">S</span><span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">}</span>
  <span class="o">(</span><span class="n">Hinf</span><span class="o">:</span> <span class="n">set</span><span class="bp">.</span><span class="n">infinite</span> <span class="n">S</span><span class="o">)</span>
  <span class="o">(</span><span class="n">Hset</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">M</span> <span class="err">⊆</span> <span class="n">S</span><span class="o">,</span> <span class="n">M</span><span class="bp">.</span><span class="n">nonempty</span> <span class="bp">→</span> <span class="o">(</span><span class="n">Inf</span> <span class="n">M</span> <span class="err">∈</span> <span class="n">M</span><span class="o">))</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">):</span>
    <span class="n">suite_st_croissante</span> <span class="n">Hinf</span> <span class="n">Hset</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">Inf</span> <span class="o">(</span><span class="n">S</span> <span class="err">\</span> <span class="o">{</span> <span class="n">x</span><span class="o">:</span> <span class="n">X</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">k</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">,</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">suite_st_croissante</span> <span class="n">Hinf</span> <span class="n">Hset</span> <span class="n">k</span> <span class="o">})</span>
    <span class="o">:=</span> <span class="n">well_founded</span><span class="bp">.</span><span class="n">fix_eq</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span>

<span class="n">def</span> <span class="n">suite_st_croissante_nonempty</span> <span class="o">[</span><span class="n">conditionally_complete_linear_order</span> <span class="n">X</span><span class="o">]</span> <span class="o">{</span><span class="n">S</span><span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">}</span>
 <span class="o">(</span><span class="n">Hinf</span><span class="o">:</span> <span class="n">set</span><span class="bp">.</span><span class="n">infinite</span> <span class="n">S</span><span class="o">)</span> <span class="o">(</span><span class="n">Hset</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">M</span> <span class="err">⊆</span> <span class="n">S</span><span class="o">,</span> <span class="n">M</span><span class="bp">.</span><span class="n">nonempty</span> <span class="bp">→</span> <span class="o">(</span><span class="n">Inf</span> <span class="n">M</span> <span class="err">∈</span> <span class="n">M</span><span class="o">))</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">):</span>
    <span class="o">(</span><span class="n">S</span> <span class="err">\</span> <span class="o">{</span> <span class="n">x</span><span class="o">:</span> <span class="n">X</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">k</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">,</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">suite_st_croissante</span> <span class="n">Hinf</span> <span class="n">Hset</span> <span class="n">k</span> <span class="o">})</span><span class="bp">.</span><span class="n">nonempty</span> <span class="o">:=</span>
  <span class="k">begin</span>
  <span class="n">set</span> <span class="n">L</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">k</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">),</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">suite_st_croissante</span> <span class="n">Hinf</span> <span class="n">Hset</span> <span class="n">k</span><span class="o">},</span>
  <span class="n">by_contra</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">Hinf</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">set</span><span class="bp">.</span><span class="n">not_nonempty_iff_eq_empty</span><span class="bp">.</span><span class="mi">1</span> <span class="n">a</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="n">set</span><span class="bp">.</span><span class="n">diff_eq_empty</span><span class="bp">.</span><span class="mi">1</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">set</span><span class="bp">.</span><span class="n">finite_subset</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">HS_finite</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">y</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="o">(({</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">H_1</span> <span class="o">:</span> <span class="n">k</span> <span class="bp">&lt;</span> <span class="n">y</span><span class="o">),</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">suite_st_croissante</span> <span class="n">Hinf</span> <span class="n">Hset</span> <span class="n">k</span><span class="o">})</span><span class="bp">.</span><span class="n">finite</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">begin</span>
  <span class="o">{</span>
    <span class="n">intro</span> <span class="n">y</span><span class="o">,</span>
    <span class="c1">-- this proof looks complicated for nothing.</span>
    <span class="k">have</span><span class="o">:</span>
    <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">H_1</span> <span class="o">:</span> <span class="n">k</span> <span class="bp">&lt;</span> <span class="n">y</span><span class="o">),</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">suite_st_croissante</span> <span class="n">Hinf</span> <span class="n">Hset</span> <span class="n">k</span><span class="o">}</span>
      <span class="bp">=</span> <span class="o">(</span><span class="n">suite_st_croissante</span> <span class="n">Hinf</span> <span class="n">Hset</span><span class="o">)</span> <span class="err">&#39;&#39;</span> <span class="o">{</span> <span class="n">i</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">|</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">y</span><span class="o">}</span> <span class="o">:=</span> <span class="k">begin</span>
        <span class="n">ext</span><span class="o">,</span>
        <span class="n">split</span><span class="o">,</span>
        <span class="n">repeat</span> <span class="o">{</span>
          <span class="n">intro</span> <span class="n">H1</span><span class="o">,</span>
          <span class="n">simp</span> <span class="n">at</span> <span class="n">H1</span><span class="o">,</span>
          <span class="n">simp</span><span class="o">,</span>
          <span class="k">obtain</span> <span class="bp">⟨</span> <span class="n">x</span><span class="o">,</span> <span class="bp">⟨</span> <span class="n">hxy</span><span class="o">,</span> <span class="n">heq</span> <span class="bp">⟩</span> <span class="bp">⟩</span> <span class="o">:=</span> <span class="n">H1</span><span class="o">,</span>
          <span class="n">use</span> <span class="n">x</span><span class="o">,</span>
          <span class="n">split</span><span class="o">,</span>
          <span class="n">exact</span> <span class="n">hxy</span><span class="o">,</span>
          <span class="n">symmetry</span><span class="o">,</span>
          <span class="n">exact</span> <span class="n">heq</span><span class="o">,</span>
        <span class="o">},</span>
      <span class="kn">end</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">this</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">set</span><span class="bp">.</span><span class="n">finite_image</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">set</span><span class="bp">.</span><span class="n">finite_lt_nat</span><span class="o">,</span>
  <span class="o">}</span>
  <span class="kn">end</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">HS_finite</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">this</span><span class="o">,</span>
  <span class="kn">end</span>
</pre></div>

<a name="192810393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Turn%20a%20set%20%7B%20y%20%3A%20Y%20%7C%20exists%20x%20%5Cin%20A%2C%20y%20%3D%20f%20x%20%7D%20into%20%28f%20%27%27%20A%29/near/192810393" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/50915TurnasetyYexistsxinAyfxintofA.html#192810393">Ryan Lahfa (Apr 03 2020 at 14:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/116395-maths/topic/Turn.20a.20set.20.7B.20y.20.3A.20Y.20.7C.20exists.20x.20.5Cin.20A.2C.20y.20.3D.20f.20x.20.7D.20into.20(f.20''.20A)/near/192809995" title="#narrow/stream/116395-maths/topic/Turn.20a.20set.20.7B.20y.20.3A.20Y.20.7C.20exists.20x.20.5Cin.20A.2C.20y.20.3D.20f.20x.20.7D.20into.20(f.20''.20A)/near/192809995">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="262143">Ryan Lahfa</span> I think that you should almost always prefer the <code>f '' A</code> form, and use <code>rw set.mem_image</code> and friends when you have things like <code>x \in f '' A</code></p>
</blockquote>
<p>Okay, that was the answer I was converging by what I've seen, it is just that I feel like theorem statements look weird but I shouldn't think such things of statements… :D</p>

<a name="192810932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Turn%20a%20set%20%7B%20y%20%3A%20Y%20%7C%20exists%20x%20%5Cin%20A%2C%20y%20%3D%20f%20x%20%7D%20into%20%28f%20%27%27%20A%29/near/192810932" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/50915TurnasetyYexistsxinAyfxintofA.html#192810932">Patrick Massot (Apr 03 2020 at 14:23)</a>:</h4>
<p>Sorry, this is not minimal enough for me. It times out here.</p>

<a name="192811319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Turn%20a%20set%20%7B%20y%20%3A%20Y%20%7C%20exists%20x%20%5Cin%20A%2C%20y%20%3D%20f%20x%20%7D%20into%20%28f%20%27%27%20A%29/near/192811319" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/50915TurnasetyYexistsxinAyfxintofA.html#192811319">Ryan Lahfa (Apr 03 2020 at 14:26)</a>:</h4>
<p>I'll minimize it.</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span>

<span class="kn">variable</span> <span class="o">{</span><span class="n">X</span><span class="o">:</span> <span class="kt">Type</span><span class="o">}</span>

<span class="n">local</span> <span class="n">attribute</span> <span class="o">[</span><span class="kn">instance</span><span class="o">]</span> <span class="n">classical</span><span class="bp">.</span><span class="n">prop_decidable</span>

<span class="n">def</span> <span class="n">suite_st_croissante</span> <span class="o">[</span><span class="n">conditionally_complete_linear_order</span> <span class="n">X</span><span class="o">]</span> <span class="o">{</span><span class="n">S</span><span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">}</span>
  <span class="o">(</span><span class="n">Hinf</span><span class="o">:</span> <span class="n">set</span><span class="bp">.</span><span class="n">infinite</span> <span class="n">S</span><span class="o">)</span>
  <span class="o">(</span><span class="n">Hset</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">M</span> <span class="err">⊆</span> <span class="n">S</span><span class="o">,</span> <span class="n">M</span><span class="bp">.</span><span class="n">nonempty</span> <span class="bp">→</span> <span class="o">(</span><span class="n">Inf</span> <span class="n">M</span> <span class="err">∈</span> <span class="n">M</span><span class="o">))</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">X</span> <span class="o">:=</span>
  <span class="n">well_founded</span><span class="bp">.</span><span class="n">fix</span> <span class="n">nat</span><span class="bp">.</span><span class="n">lt_wf</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="n">suite_st_croissante</span><span class="o">,</span>
    <span class="n">Inf</span> <span class="o">(</span><span class="n">S</span> <span class="err">\</span> <span class="o">{</span> <span class="n">x</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">k</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">,</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">suite_st_croissante</span> <span class="n">k</span> <span class="n">H</span><span class="o">}))</span>

<span class="kn">lemma</span> <span class="n">suite_st_croissante_images</span> <span class="o">[</span><span class="n">conditionally_complete_linear_order</span> <span class="n">X</span><span class="o">]</span> <span class="o">{</span><span class="n">S</span><span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">}</span>
 <span class="o">(</span><span class="n">Hinf</span><span class="o">:</span> <span class="n">set</span><span class="bp">.</span><span class="n">infinite</span> <span class="n">S</span><span class="o">)</span> <span class="o">(</span><span class="n">Hset</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">M</span> <span class="err">⊆</span> <span class="n">S</span><span class="o">,</span> <span class="n">M</span><span class="bp">.</span><span class="n">nonempty</span> <span class="bp">→</span> <span class="o">(</span><span class="n">Inf</span> <span class="n">M</span> <span class="err">∈</span> <span class="n">M</span><span class="o">))</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">):</span>
    <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">H_1</span> <span class="o">:</span> <span class="n">k</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">),</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">suite_st_croissante</span> <span class="n">Hinf</span> <span class="n">Hset</span> <span class="n">k</span><span class="o">}</span>
    <span class="bp">=</span> <span class="o">(</span><span class="n">suite_st_croissante</span> <span class="n">Hinf</span> <span class="n">Hset</span><span class="o">)</span> <span class="err">&#39;&#39;</span> <span class="o">{</span> <span class="n">i</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">|</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">}</span> <span class="o">:=</span>
    <span class="c1">-- this proof looks complicated for nothing.</span>
    <span class="k">begin</span>
        <span class="n">ext</span><span class="o">,</span>
        <span class="n">split</span><span class="o">,</span>
        <span class="n">repeat</span> <span class="o">{</span>
          <span class="n">intro</span> <span class="n">H1</span><span class="o">,</span>
          <span class="n">simp</span> <span class="n">at</span> <span class="n">H1</span><span class="o">,</span>
          <span class="n">simp</span><span class="o">,</span>
          <span class="k">obtain</span> <span class="bp">⟨</span> <span class="n">x</span><span class="o">,</span> <span class="bp">⟨</span> <span class="n">hxy</span><span class="o">,</span> <span class="n">heq</span> <span class="bp">⟩</span> <span class="bp">⟩</span> <span class="o">:=</span> <span class="n">H1</span><span class="o">,</span>
          <span class="n">use</span> <span class="n">x</span><span class="o">,</span>
          <span class="n">split</span><span class="o">,</span>
          <span class="n">exact</span> <span class="n">hxy</span><span class="o">,</span>
          <span class="n">symmetry</span><span class="o">,</span>
          <span class="n">exact</span> <span class="n">heq</span><span class="o">,</span>
        <span class="o">},</span>
    <span class="kn">end</span>
</pre></div>


<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span>  Is it better?</p>

<a name="192811442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Turn%20a%20set%20%7B%20y%20%3A%20Y%20%7C%20exists%20x%20%5Cin%20A%2C%20y%20%3D%20f%20x%20%7D%20into%20%28f%20%27%27%20A%29/near/192811442" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/50915TurnasetyYexistsxinAyfxintofA.html#192811442">Mario Carneiro (Apr 03 2020 at 14:27)</a>:</h4>
<p>your theorem (which should not be a <code>def</code>) should be trivial by <code>simp</code></p>

<a name="192811521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Turn%20a%20set%20%7B%20y%20%3A%20Y%20%7C%20exists%20x%20%5Cin%20A%2C%20y%20%3D%20f%20x%20%7D%20into%20%28f%20%27%27%20A%29/near/192811521" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/50915TurnasetyYexistsxinAyfxintofA.html#192811521">Ryan Lahfa (Apr 03 2020 at 14:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/116395-maths/topic/Turn.20a.20set.20.7B.20y.20.3A.20Y.20.7C.20exists.20x.20.5Cin.20A.2C.20y.20.3D.20f.20x.20.7D.20into.20(f.20''.20A)/near/192811442" title="#narrow/stream/116395-maths/topic/Turn.20a.20set.20.7B.20y.20.3A.20Y.20.7C.20exists.20x.20.5Cin.20A.2C.20y.20.3D.20f.20x.20.7D.20into.20(f.20''.20A)/near/192811442">said</a>:</p>
<blockquote>
<p>your theorem (which should not be a <code>def</code>) should be trivial by <code>simp</code></p>
</blockquote>
<p>Replacing the body by <code>by simp</code> ? I just tried it and it failed to simplify.</p>

<a name="192811574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Turn%20a%20set%20%7B%20y%20%3A%20Y%20%7C%20exists%20x%20%5Cin%20A%2C%20y%20%3D%20f%20x%20%7D%20into%20%28f%20%27%27%20A%29/near/192811574" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/50915TurnasetyYexistsxinAyfxintofA.html#192811574">Mario Carneiro (Apr 03 2020 at 14:28)</a>:</h4>
<p>maybe apply <code>ext</code> first</p>

<a name="192811749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Turn%20a%20set%20%7B%20y%20%3A%20Y%20%7C%20exists%20x%20%5Cin%20A%2C%20y%20%3D%20f%20x%20%7D%20into%20%28f%20%27%27%20A%29/near/192811749" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/50915TurnasetyYexistsxinAyfxintofA.html#192811749">Ryan Lahfa (Apr 03 2020 at 14:29)</a>:</h4>
<p>Same, it just rewrite the (x \in A &lt;=&gt; x \in B) by (exists … &lt;=&gt; exists …)</p>

<a name="192811936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Turn%20a%20set%20%7B%20y%20%3A%20Y%20%7C%20exists%20x%20%5Cin%20A%2C%20y%20%3D%20f%20x%20%7D%20into%20%28f%20%27%27%20A%29/near/192811936" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/50915TurnasetyYexistsxinAyfxintofA.html#192811936">Mario Carneiro (Apr 03 2020 at 14:30)</a>:</h4>
<p>what?</p>

<a name="192812022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Turn%20a%20set%20%7B%20y%20%3A%20Y%20%7C%20exists%20x%20%5Cin%20A%2C%20y%20%3D%20f%20x%20%7D%20into%20%28f%20%27%27%20A%29/near/192812022" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/50915TurnasetyYexistsxinAyfxintofA.html#192812022">Ryan Lahfa (Apr 03 2020 at 14:30)</a>:</h4>
<p>It transforms the goal which is:</p>
<div class="codehilite"><pre><span></span>x ∈ {x : X | ∃ (k : ℕ) (H_1 : k &lt; n), x = suite_st_croissante Hinf Hset k} ↔
    x ∈ suite_st_croissante Hinf Hset &#39;&#39; {i : ℕ | i &lt; n}
</pre></div>


<p>by</p>
<div class="codehilite"><pre><span></span>(∃ (k : ℕ), k &lt; n ∧ x = suite_st_croissante Hinf Hset k) ↔
    ∃ (x_1 : ℕ), x_1 &lt; n ∧ suite_st_croissante Hinf Hset x_1 = x
</pre></div>

<a name="192812054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Turn%20a%20set%20%7B%20y%20%3A%20Y%20%7C%20exists%20x%20%5Cin%20A%2C%20y%20%3D%20f%20x%20%7D%20into%20%28f%20%27%27%20A%29/near/192812054" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/50915TurnasetyYexistsxinAyfxintofA.html#192812054">Ryan Lahfa (Apr 03 2020 at 14:31)</a>:</h4>
<p>which sounds finishable by <code>refl</code> to me…</p>

<a name="192812099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Turn%20a%20set%20%7B%20y%20%3A%20Y%20%7C%20exists%20x%20%5Cin%20A%2C%20y%20%3D%20f%20x%20%7D%20into%20%28f%20%27%27%20A%29/near/192812099" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/50915TurnasetyYexistsxinAyfxintofA.html#192812099">Mario Carneiro (Apr 03 2020 at 14:31)</a>:</h4>
<p>note the equality is the wrong way around</p>

<a name="192812100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Turn%20a%20set%20%7B%20y%20%3A%20Y%20%7C%20exists%20x%20%5Cin%20A%2C%20y%20%3D%20f%20x%20%7D%20into%20%28f%20%27%27%20A%29/near/192812100" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/50915TurnasetyYexistsxinAyfxintofA.html#192812100">Patrick Massot (Apr 03 2020 at 14:31)</a>:</h4>
<p><code>ext , simp [eq_comm]</code> does it</p>

<a name="192812133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Turn%20a%20set%20%7B%20y%20%3A%20Y%20%7C%20exists%20x%20%5Cin%20A%2C%20y%20%3D%20f%20x%20%7D%20into%20%28f%20%27%27%20A%29/near/192812133" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/50915TurnasetyYexistsxinAyfxintofA.html#192812133">Ryan Lahfa (Apr 03 2020 at 14:31)</a>:</h4>
<p>Ah! Right</p>

<a name="192812134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Turn%20a%20set%20%7B%20y%20%3A%20Y%20%7C%20exists%20x%20%5Cin%20A%2C%20y%20%3D%20f%20x%20%7D%20into%20%28f%20%27%27%20A%29/near/192812134" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/50915TurnasetyYexistsxinAyfxintofA.html#192812134">Patrick Massot (Apr 03 2020 at 14:31)</a>:</h4>
<p>Yes, <code>eq_comm</code> is the main ingredient here</p>

<a name="192812285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Turn%20a%20set%20%7B%20y%20%3A%20Y%20%7C%20exists%20x%20%5Cin%20A%2C%20y%20%3D%20f%20x%20%7D%20into%20%28f%20%27%27%20A%29/near/192812285" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/50915TurnasetyYexistsxinAyfxintofA.html#192812285">Ryan Lahfa (Apr 03 2020 at 14:32)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> Okay, so this happens because of this equality issue and <code>eq_comm</code> is not a simp-lemma, should it be a simp-lemma though?</p>

<a name="192812304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Turn%20a%20set%20%7B%20y%20%3A%20Y%20%7C%20exists%20x%20%5Cin%20A%2C%20y%20%3D%20f%20x%20%7D%20into%20%28f%20%27%27%20A%29/near/192812304" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/50915TurnasetyYexistsxinAyfxintofA.html#192812304">Mario Carneiro (Apr 03 2020 at 14:32)</a>:</h4>
<p>no, this is fine</p>

<a name="192812367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Turn%20a%20set%20%7B%20y%20%3A%20Y%20%7C%20exists%20x%20%5Cin%20A%2C%20y%20%3D%20f%20x%20%7D%20into%20%28f%20%27%27%20A%29/near/192812367" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/50915TurnasetyYexistsxinAyfxintofA.html#192812367">Mario Carneiro (Apr 03 2020 at 14:33)</a>:</h4>
<p><code>by ext; simp [eq_comm]</code> is a fine proof</p>

<a name="192812399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Turn%20a%20set%20%7B%20y%20%3A%20Y%20%7C%20exists%20x%20%5Cin%20A%2C%20y%20%3D%20f%20x%20%7D%20into%20%28f%20%27%27%20A%29/near/192812399" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/50915TurnasetyYexistsxinAyfxintofA.html#192812399">Mario Carneiro (Apr 03 2020 at 14:33)</a>:</h4>
<p>still "trivial" in my book</p>

<a name="192812440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Turn%20a%20set%20%7B%20y%20%3A%20Y%20%7C%20exists%20x%20%5Cin%20A%2C%20y%20%3D%20f%20x%20%7D%20into%20%28f%20%27%27%20A%29/near/192812440" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/50915TurnasetyYexistsxinAyfxintofA.html#192812440">Patrick Massot (Apr 03 2020 at 14:33)</a>:</h4>
<p>Even better: rewrite the statement with the "correct" equality</p>

<a name="192812449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Turn%20a%20set%20%7B%20y%20%3A%20Y%20%7C%20exists%20x%20%5Cin%20A%2C%20y%20%3D%20f%20x%20%7D%20into%20%28f%20%27%27%20A%29/near/192812449" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/50915TurnasetyYexistsxinAyfxintofA.html#192812449">Ryan Lahfa (Apr 03 2020 at 14:33)</a>:</h4>
<p>Yes, agreed, that helped me a lot!</p>

<a name="192817933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Turn%20a%20set%20%7B%20y%20%3A%20Y%20%7C%20exists%20x%20%5Cin%20A%2C%20y%20%3D%20f%20x%20%7D%20into%20%28f%20%27%27%20A%29/near/192817933" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/50915TurnasetyYexistsxinAyfxintofA.html#192817933">Kevin Buzzard (Apr 03 2020 at 15:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="262143">Ryan Lahfa</span> <a href="#narrow/stream/116395-maths/topic/Turn.20a.20set.20.7B.20y.20.3A.20Y.20.7C.20exists.20x.20.5Cin.20A.2C.20y.20.3D.20f.20x.20.7D.20into.20(f.20''.20A)/near/192812285" title="#narrow/stream/116395-maths/topic/Turn.20a.20set.20.7B.20y.20.3A.20Y.20.7C.20exists.20x.20.5Cin.20A.2C.20y.20.3D.20f.20x.20.7D.20into.20(f.20''.20A)/near/192812285">said</a>:</p>
<blockquote>
<p><code>eq_comm</code> is not a simp-lemma, should it be a simp-lemma though?</p>
</blockquote>
<p>It would loop, wouldn't it? I think the idea is to try and keep everything in the right order :-)</p>

<a name="192818086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Turn%20a%20set%20%7B%20y%20%3A%20Y%20%7C%20exists%20x%20%5Cin%20A%2C%20y%20%3D%20f%20x%20%7D%20into%20%28f%20%27%27%20A%29/near/192818086" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/50915TurnasetyYexistsxinAyfxintofA.html#192818086">Mario Carneiro (Apr 03 2020 at 15:06)</a>:</h4>
<p>No, it's specifically detected to be a symmetry lemma and does something with term orders to prevent it from looping. That's why <code>simp [eq_comm]</code>works</p>

<a name="192818131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Turn%20a%20set%20%7B%20y%20%3A%20Y%20%7C%20exists%20x%20%5Cin%20A%2C%20y%20%3D%20f%20x%20%7D%20into%20%28f%20%27%27%20A%29/near/192818131" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/50915TurnasetyYexistsxinAyfxintofA.html#192818131">Mario Carneiro (Apr 03 2020 at 15:07)</a>:</h4>
<p>similar things happen with <code>simp [add_comm]</code> or <code>simp [add_comm, add_assoc]</code></p>

<a name="192818331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Turn%20a%20set%20%7B%20y%20%3A%20Y%20%7C%20exists%20x%20%5Cin%20A%2C%20y%20%3D%20f%20x%20%7D%20into%20%28f%20%27%27%20A%29/near/192818331" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/50915TurnasetyYexistsxinAyfxintofA.html#192818331">Mario Carneiro (Apr 03 2020 at 15:08)</a>:</h4>
<p>Probably if you had a more elaborate symmetry like lemma like <code>foo a b c = foo b c a</code> then it would loop</p>

<a name="192818506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Turn%20a%20set%20%7B%20y%20%3A%20Y%20%7C%20exists%20x%20%5Cin%20A%2C%20y%20%3D%20f%20x%20%7D%20into%20%28f%20%27%27%20A%29/near/192818506" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/50915TurnasetyYexistsxinAyfxintofA.html#192818506">Kevin Buzzard (Apr 03 2020 at 15:09)</a>:</h4>
<p>I thought that if it was a job for add_comm and add_assoc you used something like <code>ac_refl</code>. Are these really confluent enough for <code>simp</code>? This is some inbuilt hack or something, right?</p>

<a name="192818676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Turn%20a%20set%20%7B%20y%20%3A%20Y%20%7C%20exists%20x%20%5Cin%20A%2C%20y%20%3D%20f%20x%20%7D%20into%20%28f%20%27%27%20A%29/near/192818676" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/50915TurnasetyYexistsxinAyfxintofA.html#192818676">Mario Carneiro (Apr 03 2020 at 15:10)</a>:</h4>
<p>Yes, I think <code>simp</code> calls <code>ac_refl</code> or the thing that drives it behind the scenes</p>


{% endraw %}

{% include archive_update.html %}