---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/116395maths/28435topologygeneratedbyanorder.html
---

## Stream: [maths](index.html)
### Topic: [topology generated by an order](28435topologygeneratedbyanorder.html)

---


{% raw %}
#### [ Kevin Buzzard (Aug 15 2018 at 14:19)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topology%20generated%20by%20an%20order/near/132171480):
<p>I don't know in what generality it's meaningful to ask about the topology "generated by" an order. Luca found <code>ordered_topology</code> in <code>analysis/topology/topological_structures.lean</code> but this is an assertion that sets coming from the order are closed in the topology, it doesn't rule out there being far more closed sets. </p>
<p>Here's a concrete question. Is there a theorem in mathlib saying that the topology on the reals is the one associated in some way to the total order <code>&lt;</code> on the reals? Presumably with a total order one can define basic open sets <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>{</mo><mi>x</mi><mo>:</mo><mi>a</mi><mo>&lt;</mo><mi>x</mi><mo>&lt;</mo><mi>b</mi><mo>}</mo></mrow><annotation encoding="application/x-tex">\{x : a&lt;x&lt;b\}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">{</span><span class="mord mathit">x</span><span class="mrel">:</span><span class="mord mathit">a</span><span class="mrel">&lt;</span><span class="mord mathit">x</span><span class="mrel">&lt;</span><span class="mord mathit">b</span><span class="mclose">}</span></span></span></span> for each pair <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(a,b)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">(</span><span class="mord mathit">a</span><span class="mpunct">,</span><span class="mord mathit">b</span><span class="mclose">)</span></span></span></span>. Is this all there already and how much further does it go? Seems to work fine for total orders, but probably not for partial orders because we seem to need infs and sups. Is this what a lattice is? I am reluctant to do work that's already there and as you can see I am not currently even sure which files I should be looking in.</p>

#### [ Mario Carneiro (Aug 15 2018 at 15:08)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topology%20generated%20by%20an%20order/near/132173596):
<p>note the difference between <code>ordered_topology</code> and <code>orderable_topology</code></p>

#### [ Mario Carneiro (Aug 15 2018 at 15:08)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topology%20generated%20by%20an%20order/near/132173603):
<p>the latter is for what topologists usually call "the order topology"</p>

#### [ Mario Carneiro (Aug 15 2018 at 15:09)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topology%20generated%20by%20an%20order/near/132173635):
<p>the former is more like an order-respecting topology</p>

#### [ Mario Carneiro (Aug 15 2018 at 15:10)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topology%20generated%20by%20an%20order/near/132173703):
<blockquote>
<p>Is there a theorem in mathlib saying that the topology on the reals is the one associated in some way to the total order &lt; on the reals?</p>
</blockquote>
<p>Yes, this is the instance of <code>orderable_topology real</code></p>

#### [ Mario Carneiro (Aug 15 2018 at 15:11)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topology%20generated%20by%20an%20order/near/132173758):
<blockquote>
<p>Is this all there already and how much further does it go? Seems to work fine for total orders, but probably not for partial orders because we seem to need infs and sups. </p>
</blockquote>
<p>If you look at the definition in <code>ordered_topology</code>, you will see that we require that closed intervals are closed, not that open intervals are open. In partial orders this is more natural. In total orders they are equivalent</p>

#### [ Kevin Buzzard (Aug 15 2018 at 15:57)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topology%20generated%20by%20an%20order/near/132175935):
<p>Aah this is perfect -- <code>orderable_topology</code> is exactly what we want. Thanks!</p>

#### [ Luca Gerolla (Aug 16 2018 at 12:46)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topology%20generated%20by%20an%20order/near/132231564):
<p>Thank you very much Mario... It was very helpful to understand the different "order_topologies" in <code>analysis/topology/topological_structures.lean</code>and at the end I found the result I needed: </p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">frontier_lt_subset_eq</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_linear_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">t</span> <span class="o">:</span> <span class="n">ordered_topology</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">[</span><span class="n">topological_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">continuous</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">hg</span> <span class="o">:</span> <span class="n">continuous</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span>
<span class="n">frontier</span> <span class="o">{</span><span class="n">b</span> <span class="bp">|</span> <span class="n">f</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">g</span> <span class="n">b</span><span class="o">}</span> <span class="err">⊆</span> <span class="o">{</span><span class="n">b</span> <span class="bp">|</span> <span class="n">f</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">g</span> <span class="n">b</span><span class="o">}</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">unfold</span> <span class="n">frontier</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h₁</span> <span class="o">:</span> <span class="n">interior</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">f</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">g</span> <span class="n">b</span><span class="o">}</span> <span class="bp">=</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">f</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">g</span> <span class="n">b</span><span class="o">},</span>
    <span class="n">exact</span> <span class="n">interior_eq_iff_open</span><span class="bp">.</span><span class="mi">2</span> <span class="o">(</span><span class="n">is_open_lt</span>  <span class="n">hf</span> <span class="n">hg</span><span class="o">),</span> <span class="n">rw</span> <span class="n">h₁</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h₂</span> <span class="o">:</span> <span class="n">closure</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">f</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">g</span> <span class="n">b</span><span class="o">}</span> <span class="err">⊆</span> <span class="n">closure</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">f</span> <span class="n">b</span> <span class="bp">≤</span>  <span class="n">g</span> <span class="n">b</span><span class="o">},</span>
    <span class="n">refine</span> <span class="n">closure_mono</span> <span class="bp">_</span>  <span class="o">,</span> <span class="n">rw</span> <span class="n">set</span><span class="bp">.</span><span class="n">set_of_subset_set_of</span><span class="o">,</span> <span class="n">intros</span> <span class="n">x</span> <span class="n">h</span><span class="o">,</span> <span class="n">exact</span> <span class="n">le_of_lt</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h₃</span> <span class="o">:</span> <span class="n">closure</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">f</span> <span class="n">b</span> <span class="bp">≤</span>  <span class="n">g</span> <span class="n">b</span><span class="o">}</span> <span class="bp">=</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">f</span> <span class="n">b</span> <span class="bp">≤</span>  <span class="n">g</span> <span class="n">b</span><span class="o">},</span>
    <span class="n">exact</span> <span class="n">closure_eq_iff_is_closed</span><span class="bp">.</span><span class="mi">2</span> <span class="o">(</span><span class="n">is_closed_le</span> <span class="n">hf</span> <span class="n">hg</span><span class="o">),</span> <span class="n">rw</span> <span class="n">h₃</span> <span class="n">at</span> <span class="n">h₂</span> <span class="o">,</span>
  <span class="k">have</span> <span class="n">g₁</span> <span class="o">:</span> <span class="n">closure</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">f</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">g</span> <span class="n">b</span><span class="o">}</span> <span class="err">\</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">f</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">g</span> <span class="n">b</span><span class="o">}</span> <span class="err">⊆</span>
                 <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">f</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">g</span> <span class="n">b</span><span class="o">}</span> <span class="err">\</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">f</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">g</span> <span class="n">b</span><span class="o">},</span>
   <span class="o">{</span><span class="n">unfold</span> <span class="n">has_sdiff</span><span class="bp">.</span><span class="n">sdiff</span> <span class="n">set</span><span class="bp">.</span><span class="n">diff</span><span class="o">,</span> <span class="n">intros</span> <span class="n">a</span> <span class="n">Ha</span><span class="o">,</span> <span class="n">simp</span> <span class="n">at</span> <span class="n">Ha</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">Ha</span> <span class="k">with</span> <span class="n">a₁</span> <span class="n">a₂</span> <span class="o">,</span>
    <span class="k">have</span> <span class="n">h₄</span> <span class="o">:</span> <span class="n">a</span> <span class="err">∈</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">f</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">g</span> <span class="n">b</span><span class="o">},</span> <span class="n">exact</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_of_mem_of_subset</span> <span class="n">a₁</span> <span class="n">h₂</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">mem_set_of_eq</span> <span class="n">at</span> <span class="n">h₄</span><span class="o">,</span> <span class="n">exact</span> <span class="bp">⟨</span> <span class="n">h₄</span><span class="o">,</span> <span class="n">a₂</span> <span class="bp">⟩</span> <span class="o">,</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">g₂</span> <span class="o">:</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">f</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">g</span> <span class="n">b</span><span class="o">}</span> <span class="err">\</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">f</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">g</span> <span class="n">b</span><span class="o">}</span> <span class="err">⊆</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">f</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">g</span> <span class="n">b</span><span class="o">},</span>
    <span class="n">unfold</span> <span class="n">has_sdiff</span><span class="bp">.</span><span class="n">sdiff</span> <span class="n">set</span><span class="bp">.</span><span class="n">diff</span><span class="o">,</span> <span class="n">intros</span> <span class="n">a</span> <span class="n">Ha</span><span class="o">,</span> <span class="n">simp</span>  <span class="n">at</span> <span class="n">Ha</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">mem_set_of_eq</span><span class="o">,</span> <span class="n">exact</span> <span class="n">le_antisymm</span> <span class="n">Ha</span><span class="bp">.</span><span class="mi">1</span> <span class="n">Ha</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">set</span><span class="bp">.</span><span class="n">subset</span><span class="bp">.</span><span class="n">trans</span> <span class="n">g₁</span> <span class="n">g₂</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p>By any chance, would this be helpful (with slicker proof) in mathlib in addition to <code>frontier_le_subset_eq</code>?</p>

#### [ Mario Carneiro (Aug 16 2018 at 12:48)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topology%20generated%20by%20an%20order/near/132231657):
<p>this should be an easy consequence of <code>frontier_le_subset_eq</code></p>

#### [ Mario Carneiro (Aug 16 2018 at 12:49)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topology%20generated%20by%20an%20order/near/132231681):
<p>The frontier of the complement of A is the same as the frontier of A, so each implies the other since <code>{b | f b &lt; g b}</code> is the complement of <code>{b | g b &lt;= f b} </code></p>

#### [ Mario Carneiro (Aug 16 2018 at 12:59)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topology%20generated%20by%20an%20order/near/132232056):
<p>added</p>

#### [ Luca Gerolla (Aug 16 2018 at 13:09)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topology%20generated%20by%20an%20order/near/132232441):
<blockquote>
<p>The frontier of the complement of A is the same as the frontier of A, so each implies the other since <code>{b | f b &lt; g b}</code> is the complement of <code>{b | g b &lt;= f b} </code></p>
</blockquote>
<p>I did try to go along this line of reasoning but  I did not find it that shorter ... Definitely not 2 lines like yours! :)</p>

#### [ Luca Gerolla (Aug 16 2018 at 13:10)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topology%20generated%20by%20an%20order/near/132232506):
<p>Also nice addition  <code>frontier_compl</code>! ..I had better update my mathlib</p>


{% endraw %}
