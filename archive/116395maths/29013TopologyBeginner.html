---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/116395maths/29013TopologyBeginner.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html">Topology - Beginner</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="129159440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/129159440" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#129159440">Luca Gerolla (Jul 05 2018 at 19:35)</a>:</h4>
<p>Hello, I am a beginner and I am trying to define a path (in particular a path from <code>x</code> to <code>y</code> on a topological space).<br>
I am sorry for the (temporary) maths notation of topological spaces and definitions.<br>
Not knowing the syntax/ best way to impose the conditions  for the continuous function (f : I = [0,1] --&gt; X)  to be a path I thought of having a product <code>lean X  × (I → X) ×  Prop </code> as output. </p>
<p>This is my code: </p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">analysis</span><span class="bp">.</span><span class="n">topology</span><span class="bp">.</span><span class="n">continuity</span>
<span class="kn">import</span> <span class="n">analysis</span><span class="bp">.</span><span class="n">topology</span><span class="bp">.</span><span class="n">topological_space</span>
<span class="kn">import</span> <span class="n">analysis</span><span class="bp">.</span><span class="n">topology</span><span class="bp">.</span><span class="n">infinite_sum</span>
<span class="kn">import</span> <span class="n">analysis</span><span class="bp">.</span><span class="n">topology</span><span class="bp">.</span><span class="n">topological_structures</span>
<span class="kn">import</span> <span class="n">analysis</span><span class="bp">.</span><span class="n">topology</span><span class="bp">.</span><span class="n">uniform_space</span>

<span class="kn">open</span> <span class="n">set</span> <span class="n">filter</span> <span class="n">lattice</span> <span class="n">classical</span>
<span class="kn">universe</span> <span class="n">u</span>

<span class="c1">-- ambient space</span>
<span class="kn">variable</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">X</span>
<span class="c1">------ variable x : X</span>

<span class="c1">-- topological space (X, T)</span>
<span class="kn">variable</span> <span class="n">T</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">X</span>

<span class="c1">-- Interval [0, 1]</span>
<span class="kn">definition</span> <span class="n">I</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">≥</span> <span class="mi">0</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">I</span>

<span class="kn">variable</span> <span class="n">E</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">ℝ</span>

<span class="c1">-- Define inclusion map</span>
<span class="kn">definition</span> <span class="n">i</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">I</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span>  <span class="o">:=</span> <span class="n">x</span>

<span class="c1">-- Define subspace topology [for Euclidean subspace topology?]</span>
<span class="n">def</span> <span class="n">S</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">I</span> <span class="o">:=</span>
<span class="n">topological_space</span><span class="bp">.</span><span class="n">induced</span>  <span class="n">i</span> <span class="n">E</span>

<span class="c1">-- PATH</span>
<span class="kn">variable</span> <span class="n">f</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">→</span> <span class="n">X</span>

<span class="n">def</span> <span class="n">path_topological2</span>  <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">}</span> <span class="o">{</span><span class="n">y</span> <span class="o">:</span> <span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">I</span><span class="o">)</span> <span class="o">:</span> <span class="n">X</span>  <span class="bp">×</span> <span class="o">(</span><span class="n">I</span> <span class="bp">→</span> <span class="n">X</span><span class="o">)</span> <span class="bp">×</span>  <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">t</span><span class="o">,</span> <span class="o">(</span> <span class="n">f</span> <span class="n">t</span> <span class="o">)</span> <span class="bp">×</span> <span class="n">f</span> <span class="bp">×</span> <span class="o">(</span><span class="n">continuous</span> <span class="n">f</span> <span class="bp">∧</span> <span class="n">f</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">f</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span>

<span class="c">/-</span><span class="cm">   type mismatch at application</span>
<span class="cm">  prod (f t)</span>
<span class="cm">term</span>
<span class="cm">  f t</span>
<span class="cm">has type</span>
<span class="cm">  X : Type u_1</span>
<span class="cm">but is expected to have type</span>
<span class="cm">  Type ? : Type (?+1)  -/</span>
</pre></div>

<a name="129159458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/129159458" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#129159458">Luca Gerolla (Jul 05 2018 at 19:35)</a>:</h4>
<p>What would be the best way to define a path? Also avoiding the <strong> type mismatch </strong> that arises in the definition?</p>

<a name="129160116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/129160116" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#129160116">Patrick Massot (Jul 05 2018 at 19:49)</a>:</h4>
<p>I don't understand what you are trying to do. But you could have a look at <code>data/sets/intervals</code> in mathlib</p>

<a name="129160140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/129160140" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#129160140">Patrick Massot (Jul 05 2018 at 19:49)</a>:</h4>
<p>But actually it may be better to have path as a structure bundling a map from reals to X and the condition that it is continuous on [0, 1].</p>

<a name="129161964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/129161964" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#129161964">Luca Gerolla (Jul 05 2018 at 20:20)</a>:</h4>
<blockquote>
<p>But actually it may be better to have path as a structure bundling a map from reals to X and the condition that it is continuous on [0, 1].</p>
</blockquote>
<p>I was not too sure whether use create as a structure or create a definition (later I would like define homotopy;  so I was thinking that (ideally) my definition of path would allow me to retrieve starting/ending points and the actual path (function f : I --&gt; X): this for possible re-parameterisations ( I --&gt; I ) )</p>
<p>I know very little about structure, but I may try to look into your suggestion. Many Thanks!</p>

<a name="129162181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/129162181" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#129162181">Luca Gerolla (Jul 05 2018 at 20:24)</a>:</h4>
<blockquote>
<p>I don't understand what you are trying to do. But you could have a look at <code>data/sets/intervals</code> in mathlib</p>
</blockquote>
<p>PS: Are you referring to the part before the definition or the definition itself? <br>
I included the code before definition  just to provide more information on the interval I (and the induced  subspace topology - which is meant to be induced from Euclidean topology on R ) and the topological space X of interest.</p>

<a name="129185328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/129185328" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#129185328">Johan Commelin (Jul 06 2018 at 06:43)</a>:</h4>
<p>A path is just a continuous function <code>I \to X</code>, right? Or do you want a Type for paths from <code>x</code> to <code>y</code>?</p>

<a name="129186563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/129186563" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#129186563">Patrick Massot (Jul 06 2018 at 07:18)</a>:</h4>
<p>It looks like he wants the end points to be parameters of the type</p>

<a name="129187672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/129187672" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#129187672">Kevin Buzzard (Jul 06 2018 at 07:47)</a>:</h4>
<p>Hey Luca. So just to comment that <code>set ℝ</code> is a type so <code>I</code> is "only" a term. So when you make <code>topological_space I</code> something magic is happening: the term is being somehow promoted to a type. What's happening is that the term <code>  {x : ℝ | x ≤ 1 ∧ x ≥ 0}</code>(which is really a function) is being interpreted as the type <code>{x : ℝ // x ≤ 1 ∧ x ≥ 0}</code> implicitly (and this is a so-called subtype).  So when you write <code>t : I</code> then <code>t</code> might not be what you think it is -- it's a term of the subtype, so it has a value <code>t.val</code> which is the real number, and then a proof too, called <code>t.property</code>.</p>
<p>The type mismatch is because <code>\times</code>, the little cross, is for making types, not terms; a term of type <code>α × β</code> looks like <code>(a,b)</code>, like in maths.</p>

<a name="129187690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/129187690" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#129187690">Luca Gerolla (Jul 06 2018 at 07:47)</a>:</h4>
<blockquote>
<p>A path is just a continuous function <code>I \to X</code>, right? Or do you want a Type for paths from <code>x</code> to <code>y</code>?</p>
</blockquote>
<p>Indeed, I would like the second one (a Type for paths from <code>x</code> to <code>y</code>) :)</p>

<a name="129187750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/129187750" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#129187750">Kevin Buzzard (Jul 06 2018 at 07:49)</a>:</h4>
<p>So you could build the type using a structure. You would have to decide whether to put things like <code>X</code> and <code>x</code> and <code>y</code> inside the structure or outside; this is the sort of question that I am terrible at.</p>

<a name="129187876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/129187876" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#129187876">Kevin Buzzard (Jul 06 2018 at 07:52)</a>:</h4>
<p>So it could look like</p>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">paths</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">I</span> <span class="err">\</span><span class="n">to</span> <span class="n">X</span><span class="o">)</span><span class="bp">...</span>
</pre></div>


<p>or</p>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">paths</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">start_point</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span>
<span class="o">(</span><span class="n">end_point</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span>
<span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">I</span> <span class="err">\</span><span class="n">to</span> <span class="n">X</span><span class="o">)</span><span class="bp">...</span>
</pre></div>


<p>or</p>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">paths</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
<span class="o">(</span><span class="n">HX</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">X</span><span class="o">)</span>
<span class="o">(</span><span class="n">start_point</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span>
<span class="bp">...</span>
</pre></div>

<a name="129187887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/129187887" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#129187887">Mario Carneiro (Jul 06 2018 at 07:52)</a>:</h4>
<p>In this case you definitely want <code>x</code> and <code>y</code> outside the structure</p>

<a name="129187895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/129187895" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#129187895">Kevin Buzzard (Jul 06 2018 at 07:52)</a>:</h4>
<p>Why?</p>

<a name="129187906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/129187906" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#129187906">Mario Carneiro (Jul 06 2018 at 07:53)</a>:</h4>
<blockquote>
<p>a Type for paths from <code>x</code> to <code>y</code></p>
</blockquote>

<a name="129187913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/129187913" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#129187913">Kevin Buzzard (Jul 06 2018 at 07:53)</a>:</h4>
<p>:-)</p>

<a name="129187916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/129187916" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#129187916">Luca Gerolla (Jul 06 2018 at 07:53)</a>:</h4>
<blockquote>
<p>Hey Luca. So just to comment that <code>set ℝ</code> is a type so <code>I</code> is "only" a term. So when you make <code>topological_space I</code> something magic is happening: the term is being somehow promoted to a type. What's happening is that the term <code>  {x : ℝ | x ≤ 1 ∧ x ≥ 0}</code>(which is really a function) is being interpreted as the type <code>{x : ℝ // x ≤ 1 ∧ x ≥ 0}</code> implicitly (and this is a so-called subtype).  So when you write <code>t : I</code> then <code>t</code> might not be what you think it is -- it's a term of the subtype, so it has a value <code>t.val</code> which is the real number, and then a proof too, called <code>t.property</code>.</p>
<p>The type mismatch is because <code>\times</code>, the little cross, is for making types, not terms; a term of type <code>α × β</code> looks like <code>(a,b)</code>, like in maths.</p>
</blockquote>
<p>Thank you! I am in the process of digesting this...  I will try with the structure :)</p>

<a name="129187924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/129187924" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#129187924">Kevin Buzzard (Jul 06 2018 at 07:53)</a>:</h4>
<p>and Mario is saying that you want the first of my three options above.</p>

<a name="129187976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/129187976" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#129187976">Kevin Buzzard (Jul 06 2018 at 07:54)</a>:</h4>
<p>I suspect that you might want to make <code>I</code>, the unit interval, into a subtype. If you don't then you'll have coercions everywhere. You'd perhaps be better off having the coercion from <code>I</code> to the reals.</p>

<a name="129188095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/129188095" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#129188095">Patrick Massot (Jul 06 2018 at 07:57)</a>:</h4>
<p>There is also the option of having the path "defined" on R but only use its values and continuity on I</p>

<a name="129188102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/129188102" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#129188102">Patrick Massot (Jul 06 2018 at 07:57)</a>:</h4>
<p>Minimal version would be:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">analysis</span><span class="bp">.</span><span class="n">real</span>

<span class="kn">open</span> <span class="n">filter</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span>

<span class="kn">structure</span> <span class="n">path</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">map</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">X</span><span class="o">)</span>
<span class="o">(</span><span class="n">start_pt</span> <span class="o">:</span> <span class="n">map</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">end_pt</span> <span class="o">:</span> <span class="n">map</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span>
<span class="o">(</span><span class="n">cont</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">t</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="bp">→</span> <span class="n">tendsto</span> <span class="n">map</span> <span class="o">(</span><span class="n">nhds</span> <span class="n">t</span><span class="o">)</span> <span class="o">(</span><span class="n">nhds</span> <span class="o">(</span><span class="n">map</span> <span class="n">t</span><span class="o">)))</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">path</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="n">p</span><span class="bp">.</span><span class="n">map</span><span class="bp">⟩</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">path</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span>
<span class="n">f</span><span class="bp">.</span><span class="n">end_pt</span>
</pre></div>

<a name="129188404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/129188404" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#129188404">Mario Carneiro (Jul 06 2018 at 08:04)</a>:</h4>
<p>Here's my suggestion:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">I01</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">//</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">≤</span> <span class="mi">1</span><span class="o">}</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">I01</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">unfold</span> <span class="n">I01</span><span class="bp">;</span> <span class="n">apply_instance</span>
<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_zero</span> <span class="n">I01</span> <span class="o">:=</span> <span class="bp">⟨⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">le_refl</span> <span class="bp">_</span><span class="o">,</span> <span class="n">zero_le_one</span><span class="bp">⟩⟩</span>
<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_one</span> <span class="n">I01</span> <span class="o">:=</span> <span class="bp">⟨⟨</span><span class="mi">1</span><span class="o">,</span> <span class="n">zero_le_one</span><span class="o">,</span> <span class="n">le_refl</span> <span class="bp">_⟩⟩</span>

<span class="kn">structure</span> <span class="n">path</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="n">I01</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">at_zero</span> <span class="o">:</span> <span class="n">to_fun</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">at_one</span> <span class="o">:</span> <span class="n">to_fun</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span>
<span class="o">(</span><span class="n">cont</span> <span class="o">:</span> <span class="n">continuous</span> <span class="n">to_fun</span><span class="o">)</span>

<span class="kn">instance</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">path</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="n">path</span><span class="bp">.</span><span class="n">to_fun</span><span class="bp">⟩</span>
</pre></div>

<a name="129188438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/129188438" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#129188438">Kevin Buzzard (Jul 06 2018 at 08:05)</a>:</h4>
<p><span class="user-mention" data-user-id="120726">@Luca Gerolla</span> Patrick's suggestion is an interesting one. It's a very "non-maths" way to think about things, but sometimes in computer science this seems to be the way it's done. Note that <code>cont</code> is an explicit proof that the map is continuous (using things called filters, which is a trick to enable you to talk about things tending to other things even when there's no metric). Note also that there's a trick with variables here -- this really says <code>structure path {X : Type} [topological_space X] (x y : X) :=...</code> Note also that there is a problem with equality here -- you can have two different terms of type <code>path x y</code> which are not literally equal but which are "the same path" because the maps are different but agree on <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[0,1]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">[</span><span class="mord mathrm">0</span><span class="mpunct">,</span><span class="mord mathrm">1</span><span class="mclose">]</span></span></span></span>.</p>

<a name="129188441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/129188441" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#129188441">Mario Carneiro (Jul 06 2018 at 08:05)</a>:</h4>
<p>I think that in this case it is best to build up the theory of the interval as a type in its own right rather than totalizing a la isabelle</p>

<a name="129188490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/129188490" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#129188490">Patrick Massot (Jul 06 2018 at 08:06)</a>:</h4>
<p>Note again that mathlib does have a rudimentary theory of intervals (in totally ordered types).</p>

<a name="129188497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/129188497" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#129188497">Mario Carneiro (Jul 06 2018 at 08:06)</a>:</h4>
<p>Indeed you can prove that <code>I01</code> is compact in one line</p>

<a name="129188505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/129188505" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#129188505">Patrick Massot (Jul 06 2018 at 08:07)</a>:</h4>
<p>I'm not saying my way is best, I only wanted to point it out because, as pointed out by Kevin, it's very unlikely a mathematician or math student beginning Lean would think of it</p>

<a name="129188506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/129188506" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#129188506">Kevin Buzzard (Jul 06 2018 at 08:07)</a>:</h4>
<p>Mario's version makes the interval a subtype, not a subset (so <code>I01</code> is a type), and the tricks beforehand with the instances make it a topological space and make it so you can talk about 0 and 1. His equality is equality of paths, however you are, I assume, not going to be interested in equality anyway, but homotopy equivalence, so you'll end up putting an equivalence relation on this structure anyway.</p>

<a name="129188516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/129188516" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#129188516">Patrick Massot (Jul 06 2018 at 08:07)</a>:</h4>
<p>The downside of Mario's version is it will be annoying to refer to any point in the interval, as seen in his definition of 0 and 1</p>

<a name="129188567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/129188567" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#129188567">Mario Carneiro (Jul 06 2018 at 08:08)</a>:</h4>
<p>The solution to this is to define appropriate functions on <code>I01</code> so that you abstract away the proof stuff</p>

<a name="129188573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/129188573" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#129188573">Mario Carneiro (Jul 06 2018 at 08:09)</a>:</h4>
<p>For example you can probably get away with just a <code>has_mul</code> instance (the usual one) and a <code>has_neg</code> instance (the 1-x function)</p>

<a name="129188574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/129188574" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#129188574">Patrick Massot (Jul 06 2018 at 08:09)</a>:</h4>
<p>If you are going for homotopy theory, there is a clear test case: prove that concatenation of homotopy classes of path is associative, using various modelisation choices.</p>

<a name="129188622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/129188622" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#129188622">Mario Carneiro (Jul 06 2018 at 08:10)</a>:</h4>
<p>Also 1/2 should be a point in [0,1]</p>

<a name="129188624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/129188624" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#129188624">Patrick Massot (Jul 06 2018 at 08:10)</a>:</h4>
<p>exactly</p>

<a name="129188629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/129188629" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#129188629">Mario Carneiro (Jul 06 2018 at 08:10)</a>:</h4>
<p>from those I think you have enough to define everything else in homotopy theory</p>

<a name="129188696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/129188696" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#129188696">Kevin Buzzard (Jul 06 2018 at 08:12)</a>:</h4>
<p>Luca -- as far as I know nobody has done this sort of stuff in Lean, however it definitely looks possible to me and hopefully not too hard. I have to do admin today so I won't be hanging around in the computer room, but I will be in the department and will pop in occasionally. I think trying to define homotopy classes of paths etc would be a fabulous exercise for you or you/Rohan.</p>

<a name="129188705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/129188705" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#129188705">Patrick Massot (Jul 06 2018 at 08:13)</a>:</h4>
<p>It's not quite true: Johan tried it</p>

<a name="129188736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/129188736" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#129188736">Patrick Massot (Jul 06 2018 at 08:14)</a>:</h4>
<p><a href="https://github.com/leanprover/mathlib/pull/144" target="_blank" title="https://github.com/leanprover/mathlib/pull/144">https://github.com/leanprover/mathlib/pull/144</a></p>

<a name="129188748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/129188748" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#129188748">Patrick Massot (Jul 06 2018 at 08:14)</a>:</h4>
<p>this has some intersection with what Luca wants to try</p>

<a name="129188750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/129188750" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#129188750">Kevin Buzzard (Jul 06 2018 at 08:14)</a>:</h4>
<p>Oh! Luca -- this is Johan Commelin. You might want to look at what he did (or you might want to figure it out yourself)</p>

<a name="129188752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/129188752" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#129188752">Kevin Buzzard (Jul 06 2018 at 08:14)</a>:</h4>
<p>Thanks Patrick.</p>

<a name="129188758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/129188758" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#129188758">Patrick Massot (Jul 06 2018 at 08:14)</a>:</h4>
<p>but it's geared towards homology, and biased towards abstraction (simplicial sets everywhere)</p>

<a name="129188888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/129188888" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#129188888">Luca Gerolla (Jul 06 2018 at 08:18)</a>:</h4>
<p>This is all very interesting, thank you very much everyone! :-)</p>

<a name="130051069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130051069" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130051069">Luca Gerolla (Jul 21 2018 at 11:41)</a>:</h4>
<p>Hello, I am trying to define a function (<code> f </code> : X --&gt; Y , where X and Y are topological spaces)  in terms of its restrictions; to then exploit the fact  later that if the restrictions of <code> f </code>  (in this case fa : A --&gt; Y, fb : B ---&gt; Y - where A, B are closed ,  and they cover X) are continuous then the overall  function <code> f </code>is continuous (theorem already proved by <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>  ). <br>
Unfortunately I am struggling with set.inter and the coercions that "naturally" arise; in particular when I try to give a definition for the restrictions to match <code> fun_match </code> (i.e. fa = fb on <code> A \and B  </code>) and to define f as fa on A and fb on B  <code>fun_pasting_closed </code>.</p>

<a name="130051111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130051111" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130051111">Luca Gerolla (Jul 21 2018 at 11:42)</a>:</h4>
<p>This is my code: </p>
<div class="codehilite"><pre><span></span><span class="c1">--- Attempt to define function (f : α → β ) in terms of its restriction</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span>
<span class="o">[</span><span class="n">topological_space</span> <span class="n">Y</span><span class="o">]</span>
<span class="kn">variable</span> <span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span>
<span class="kn">variables</span> <span class="o">(</span> <span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span> <span class="o">)</span> <span class="o">(</span> <span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">ga</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">Y</span> <span class="o">)</span> <span class="o">(</span> <span class="n">gb</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">Y</span> <span class="o">)</span>

<span class="kn">definition</span> <span class="n">restriction</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">Y</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span><span class="bp">.</span><span class="n">val</span>


<span class="n">def</span> <span class="n">fun_match</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span>
<span class="o">[</span><span class="n">topological_space</span> <span class="n">Y</span><span class="o">]</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">B</span><span class="o">]</span> <span class="o">(</span> <span class="n">fa</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">Y</span> <span class="o">)</span> <span class="o">(</span> <span class="n">fb</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">Y</span> <span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">sorry</span>
<span class="c1">--∀ x ∈  set.inter A B, fa x = fb x</span>
<span class="c1">--∀ x ∈ set.inter A B, fa x.val = fb x.val</span>
<span class="c1">--restriction fa ( set.inter A B) == restriction fb ( set.inter A B)</span>
<span class="c1">-- ∀ x, (restriction fa ( set.inter A B) ) x = (restriction fb ( set.inter A B) ) x</span>


<span class="n">def</span> <span class="n">fun_match2</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">B</span><span class="o">]</span> <span class="o">{</span><span class="n">fa</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">}</span> <span class="o">{</span> <span class="n">fb</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">}</span>
<span class="o">(</span> <span class="n">Ha</span> <span class="o">:</span> <span class="n">fa</span> <span class="bp">=</span> <span class="n">restriction</span> <span class="n">f</span> <span class="n">A</span> <span class="o">)</span> <span class="o">(</span> <span class="n">Hb</span> <span class="o">:</span> <span class="n">fb</span> <span class="bp">=</span> <span class="n">restriction</span> <span class="n">f</span> <span class="n">B</span> <span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">sorry</span>

<span class="n">def</span> <span class="n">fun_pasting_closed</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span>
<span class="o">[</span><span class="n">topological_space</span> <span class="n">Y</span><span class="o">]</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">}</span> <span class="o">(</span> <span class="n">fa</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">Y</span> <span class="o">)</span> <span class="o">(</span> <span class="n">fb</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">{</span> <span class="n">HAcont</span> <span class="o">:</span> <span class="n">continuous</span> <span class="n">fa</span><span class="o">}</span> <span class="o">{</span> <span class="n">HBcont</span> <span class="o">:</span> <span class="n">continuous</span> <span class="n">fb</span><span class="o">}</span>
<span class="o">{</span><span class="n">Hunion</span> <span class="o">:</span> <span class="n">A</span> <span class="err">∪</span> <span class="n">B</span> <span class="bp">=</span> <span class="n">set</span><span class="bp">.</span><span class="n">univ</span><span class="o">}</span> <span class="o">{</span><span class="n">HAclosed</span> <span class="o">:</span> <span class="n">is_closed</span> <span class="n">A</span><span class="o">}</span> <span class="o">{</span><span class="n">HBclosed</span> <span class="o">:</span> <span class="n">is_closed</span> <span class="n">B</span><span class="o">}</span>
<span class="o">{</span><span class="n">Hmatch</span> <span class="o">:</span> <span class="n">fun_match</span> <span class="n">fa</span> <span class="n">fb</span> <span class="o">}</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="c1">--- λ t : X, if H : t ∈ A  then fa t else fb t</span>
</pre></div>

<a name="130051195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130051195" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130051195">Mario Carneiro (Jul 21 2018 at 11:45)</a>:</h4>
<p>there are way too many topological space arguments in <code>fun_match</code></p>

<a name="130051196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130051196" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130051196">Luca Gerolla (Jul 21 2018 at 11:45)</a>:</h4>
<p>Any help would be greatly appreciated</p>

<a name="130051245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130051245" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130051245">Mario Carneiro (Jul 21 2018 at 11:46)</a>:</h4>
<div class="codehilite"><pre><span></span>def fun_match {X Y} {A B : set X} (fa : A → Y) (fb : B → Y) : Prop :=
∀ x h₁ h₂, fa ⟨x, h₁⟩ = fb ⟨x, h₂⟩
</pre></div>

<a name="130051367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130051367" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130051367">Mario Carneiro (Jul 21 2018 at 11:51)</a>:</h4>
<div class="codehilite"><pre><span></span>local attribute [instance] classical.prop_decidable

noncomputable def paste {X Y} {A B : set X} (Hunion : A ∪ B = set.univ) (fa : A → Y) (fb : B → Y) (t : X) : Y :=
if h₁ : t ∈ A then fa ⟨t, h₁⟩ else
have t ∈ A ∪ B, from set.eq_univ_iff_forall.1 Hunion t,
have h₂ : t ∈ B, from this.resolve_left h₁,
fb ⟨t, h₂⟩
</pre></div>

<a name="130051387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130051387" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130051387">Mario Carneiro (Jul 21 2018 at 11:51)</a>:</h4>
<p>we don't really need topology to define these functions; it only comes in for the continuity proof</p>

<a name="130051589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130051589" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130051589">Mario Carneiro (Jul 21 2018 at 11:56)</a>:</h4>
<p>Here's how you can prove it has the right values:</p>
<div class="codehilite"><pre><span></span>theorem paste_left {X Y} {A B : set X} (Hunion : A ∪ B = set.univ)
  (fa : A → Y) (fb : B → Y) (t : X) (h : t ∈ A) :
  paste Hunion fa fb t = fa ⟨t, h⟩ :=
dif_pos _

theorem paste_right {X Y} {A B : set X} (Hunion : A ∪ B = set.univ)
  (fa : A → Y) (fb : B → Y) (H : fun_match fa fb)
  (t : X) (h : t ∈ B) :
  paste Hunion fa fb t = fb ⟨t, h⟩ :=
by by_cases h&#39; : t ∈ A; simp [paste, h&#39;]; apply H
</pre></div>

<a name="130051606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130051606" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130051606">Kenny Lau (Jul 21 2018 at 11:56)</a>:</h4>
<p>do we really want to use the name <code>fun_match</code>? It is really similar to the internally generated variable <code>_fun_match</code></p>

<a name="130051616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130051616" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130051616">Mario Carneiro (Jul 21 2018 at 11:57)</a>:</h4>
<p>that's fair</p>

<a name="130051623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130051623" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130051623">Mario Carneiro (Jul 21 2018 at 11:57)</a>:</h4>
<p>mathlib uses <code>eq_on</code> for something very similar</p>

<a name="130141208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130141208" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130141208">Luca Gerolla (Jul 23 2018 at 10:42)</a>:</h4>
<p>Thank you very much <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> <br>
For the time being I renamed <code> fun_match </code> to <code> match_of_fun </code>. <br>
With your code the theorem <code> cont_of_paste </code> followed easily using (part of ) the pasting lemma; however, since this was done in terms of <code> restriction _ _ </code>, do you see an easy way to prove that the pasted <code> fa </code>, <code>fb </code> are indeed <code> restriction f A </code>, <code> restriction f B</code> respectively?  </p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">rest_of_paste</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span> <span class="o">}</span> <span class="o">{</span><span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">}</span> <span class="o">{</span><span class="n">Hunion</span> <span class="o">:</span> <span class="n">A</span> <span class="err">∪</span> <span class="n">B</span> <span class="bp">=</span> <span class="n">set</span><span class="bp">.</span><span class="n">univ</span><span class="o">}</span> <span class="o">(</span><span class="n">fa</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">fb</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span>
<span class="o">{</span> <span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span> <span class="o">}</span> <span class="o">(</span> <span class="n">Hf</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">paste</span> <span class="n">Hunion</span> <span class="n">fa</span> <span class="n">fb</span> <span class="o">)</span> <span class="o">:</span>
<span class="n">fa</span> <span class="bp">=</span> <span class="n">restriction</span> <span class="n">f</span> <span class="n">A</span> <span class="bp">∧</span> <span class="n">fb</span> <span class="bp">=</span> <span class="n">restriction</span> <span class="n">f</span> <span class="n">B</span> <span class="o">:=</span>
<span class="k">begin</span> <span class="n">split</span><span class="o">,</span>

<span class="n">sorry</span><span class="o">,</span>

<span class="n">sorry</span>
<span class="kn">end</span>

<span class="c1">-- prove continuity when pasted continuous restrictions on closed sets</span>
<span class="kn">theorem</span> <span class="n">cont_of_paste</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span> <span class="o">}</span> <span class="o">{</span><span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">Y</span><span class="o">]</span>
<span class="o">{</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span> <span class="o">}</span> <span class="o">{</span> <span class="n">Hunion</span> <span class="o">:</span> <span class="n">A</span> <span class="err">∪</span> <span class="n">B</span> <span class="bp">=</span> <span class="n">set</span><span class="bp">.</span><span class="n">univ</span><span class="o">}</span> <span class="o">{</span><span class="n">fa</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">Y</span> <span class="o">}</span> <span class="o">{</span> <span class="n">fb</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">Y</span> <span class="o">}</span>
<span class="o">{</span><span class="n">HAclosed</span> <span class="o">:</span> <span class="n">is_closed</span> <span class="n">A</span><span class="o">}</span> <span class="o">{</span><span class="n">HBclosed</span> <span class="o">:</span> <span class="n">is_closed</span> <span class="n">B</span><span class="o">}</span>  <span class="o">{</span> <span class="n">Hmatch</span> <span class="o">:</span> <span class="n">match_of_fun</span> <span class="n">fa</span> <span class="n">fb</span> <span class="o">}</span>
<span class="o">{</span> <span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span> <span class="o">}</span> <span class="o">(</span> <span class="n">Hf</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">paste</span> <span class="n">Hunion</span> <span class="n">fa</span> <span class="n">fb</span> <span class="o">)</span> <span class="o">:</span>
<span class="n">continuous</span> <span class="n">fa</span> <span class="bp">→</span> <span class="n">continuous</span> <span class="n">fb</span> <span class="bp">→</span> <span class="n">continuous</span> <span class="n">f</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intros</span> <span class="n">Ca</span> <span class="n">Cb</span><span class="o">,</span>
<span class="k">have</span> <span class="n">ResA</span> <span class="o">:</span> <span class="n">fa</span> <span class="bp">=</span> <span class="o">(</span><span class="n">restriction</span> <span class="n">f</span> <span class="n">A</span><span class="o">)</span> <span class="o">,</span> <span class="n">exact</span> <span class="o">(</span><span class="n">rest_of_paste</span> <span class="n">fa</span> <span class="n">fb</span> <span class="n">Hf</span> <span class="o">)</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span>
<span class="k">have</span> <span class="n">ResB</span> <span class="o">:</span> <span class="n">fb</span> <span class="bp">=</span> <span class="o">(</span><span class="n">restriction</span> <span class="n">f</span> <span class="n">B</span><span class="o">),</span> <span class="n">exact</span> <span class="o">(</span><span class="n">rest_of_paste</span> <span class="n">fa</span> <span class="n">fb</span> <span class="n">Hf</span> <span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">ResA</span> <span class="n">at</span> <span class="n">Ca</span><span class="o">,</span> <span class="n">rw</span> <span class="n">ResB</span> <span class="n">at</span> <span class="n">Cb</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">continuous_closed_union</span> <span class="n">f</span> <span class="n">Hunion</span> <span class="n">HAclosed</span> <span class="n">HBclosed</span> <span class="n">Ca</span> <span class="n">Cb</span>
<span class="kn">end</span>
</pre></div>

<a name="130141517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130141517" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130141517">Luca Gerolla (Jul 23 2018 at 10:50)</a>:</h4>
<p>PS:  has <code> cont_of_paste </code> the right arguments?  Is  </p>
<div class="codehilite"><pre><span></span><span class="o">{</span> <span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span> <span class="o">}</span> <span class="o">(</span> <span class="n">Hf</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">paste</span> <span class="n">Hunion</span> <span class="n">fa</span> <span class="n">fb</span> <span class="o">)</span>
</pre></div>


<p>the best way to specify <code> f </code> as a paste? Asking this because I have employed a similiar method to specify arguments which were functions of certain properties/definitions, and don't know if this makes things unnecessarily more convoluted.</p>

<a name="130170170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130170170" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130170170">Kevin Buzzard (Jul 23 2018 at 19:53)</a>:</h4>
<p>If you want to prove two functions are equal, the <code>funext</code> tactic reduces you to checking their values are equal on every input. This might be what you need?</p>

<a name="130182032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130182032" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130182032">Nicholas Scheel (Jul 24 2018 at 00:32)</a>:</h4>
<p><span class="user-mention" data-user-id="120726">@Luca Gerolla</span> what about removing those two arguments and substituting <code>f</code> in directly? so your result would be <code>continuous (paste Hunion fa fb)</code></p>

<a name="130200013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130200013" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130200013">Luca Gerolla (Jul 24 2018 at 09:09)</a>:</h4>
<blockquote>
<p>If you want to prove two functions are equal, the <code>funext</code> tactic reduces you to checking their values are equal on every input. This might be what you need?</p>
</blockquote>
<p><code> funext </code> does help, together with <code>rw </code> and <code> unfold </code> leads to much more progress. Here is my "nearly completed" proof: </p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">rest_of_paste</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span> <span class="o">}</span> <span class="o">{</span><span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">}</span> <span class="o">{</span><span class="n">Hunion</span> <span class="o">:</span> <span class="n">A</span> <span class="err">∪</span> <span class="n">B</span> <span class="bp">=</span> <span class="n">set</span><span class="bp">.</span><span class="n">univ</span><span class="o">}</span> <span class="o">(</span><span class="n">fa</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">fb</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span>
<span class="o">{</span> <span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span> <span class="o">}</span> <span class="o">(</span> <span class="n">Hf</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">paste</span> <span class="n">Hunion</span> <span class="n">fa</span> <span class="n">fb</span> <span class="o">)</span> <span class="o">:</span>
<span class="n">fa</span> <span class="bp">=</span> <span class="n">restriction</span> <span class="n">f</span> <span class="n">A</span> <span class="bp">∧</span> <span class="n">fb</span> <span class="bp">=</span> <span class="n">restriction</span> <span class="n">f</span> <span class="n">B</span> <span class="o">:=</span>
<span class="k">begin</span> <span class="n">split</span><span class="o">,</span>
  <span class="n">funext</span><span class="o">,</span> <span class="n">unfold</span> <span class="n">restriction</span><span class="o">,</span> <span class="n">rw</span> <span class="n">Hf</span><span class="o">,</span> <span class="n">unfold</span> <span class="n">paste</span><span class="o">,</span> <span class="n">rw</span> <span class="n">dif_pos</span><span class="o">,</span> <span class="c1">-- exact subtype.rec fa, exact subtype.rec_on,</span>
  <span class="k">have</span> <span class="n">H</span> <span class="o">:</span>  <span class="n">x</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">⟨</span> <span class="n">x</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span> <span class="bp">_</span> <span class="bp">⟩</span> <span class="o">:</span> <span class="n">A</span> <span class="o">)</span><span class="bp">.</span><span class="n">val</span> <span class="o">,</span>  <span class="n">trivial</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H1</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="bp">⟨</span><span class="n">x</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span> <span class="bp">_</span> <span class="bp">⟩</span><span class="o">,</span>  <span class="n">exact</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">eq</span> <span class="o">(</span> <span class="n">H</span> <span class="o">),</span> <span class="n">exact</span> <span class="n">x</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span> <span class="c1">--rw H1,</span>
  <span class="n">sorry</span><span class="o">,</span>  <span class="n">exact</span> <span class="n">x</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
<span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>


<p>Is there a way to prove <code> fa x = fa ⟨x.val, ?m_1⟩ </code>?  (I thought the <code>have</code>s should do the job but then <code>rw H1</code> fails )</p>

<a name="130200168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130200168" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130200168">Chris Hughes (Jul 24 2018 at 09:13)</a>:</h4>
<p>have you tried <code>simp</code> or <code>rw subtype.eta x.1 x.2</code></p>

<a name="130200179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130200179" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130200179">Mario Carneiro (Jul 24 2018 at 09:13)</a>:</h4>
<p><code>cases x</code> will make this a lot easier</p>

<a name="130200222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130200222" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130200222">Luca Gerolla (Jul 24 2018 at 09:14)</a>:</h4>
<p>Yes, simp does work! Thank you Chris, very silly of me not trying it.. sorry!</p>

<a name="130201370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130201370" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130201370">Luca Gerolla (Jul 24 2018 at 09:42)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">rest_of_paste</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span> <span class="o">}</span> <span class="o">{</span><span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">}</span> <span class="o">{</span><span class="n">Hunion</span> <span class="o">:</span> <span class="n">A</span> <span class="err">∪</span> <span class="n">B</span> <span class="bp">=</span> <span class="n">set</span><span class="bp">.</span><span class="n">univ</span><span class="o">}</span> <span class="o">(</span><span class="n">fa</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">fb</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span>
<span class="o">{</span> <span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span> <span class="o">}</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">match_of_fun</span> <span class="n">fa</span> <span class="n">fb</span><span class="o">)</span> <span class="o">(</span> <span class="n">Hf</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">paste</span> <span class="n">Hunion</span> <span class="n">fa</span> <span class="n">fb</span> <span class="o">)</span>  <span class="o">:</span>
<span class="n">fa</span> <span class="bp">=</span> <span class="n">restriction</span> <span class="n">f</span> <span class="n">A</span> <span class="bp">∧</span> <span class="n">fb</span> <span class="bp">=</span> <span class="n">restriction</span> <span class="n">f</span> <span class="n">B</span> <span class="o">:=</span>
<span class="k">begin</span> <span class="n">split</span><span class="o">,</span>
  <span class="n">funext</span><span class="o">,</span> <span class="n">unfold</span> <span class="n">restriction</span><span class="o">,</span> <span class="n">rw</span> <span class="n">Hf</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">eq</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">_</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">paste_left</span> <span class="n">Hunion</span> <span class="n">fa</span> <span class="n">fb</span> <span class="n">x</span><span class="bp">.</span><span class="n">val</span> <span class="n">x</span><span class="bp">.</span><span class="mi">2</span><span class="o">],</span>
  <span class="n">funext</span><span class="o">,</span> <span class="n">unfold</span> <span class="n">restriction</span><span class="o">,</span> <span class="n">rw</span> <span class="n">Hf</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">eq</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">_</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">paste_right</span> <span class="n">Hunion</span> <span class="n">fa</span> <span class="n">fb</span> <span class="n">H</span> <span class="n">x</span><span class="bp">.</span><span class="n">val</span> <span class="n">x</span><span class="bp">.</span><span class="mi">2</span><span class="o">],</span>
<span class="kn">end</span>
</pre></div>


<p>Needed also the H hypotheses to complete the proof for <code>fb</code> , then <code>paste_**</code> simplified the proof further  :)</p>

<a name="130201385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130201385" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130201385">Luca Gerolla (Jul 24 2018 at 09:43)</a>:</h4>
<p><span class="user-mention" data-user-id="111651">@Nicholas Scheel</span> do you mean to  rewrite the statement as </p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">cont_of_paste</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span> <span class="o">}</span> <span class="o">{</span><span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">Y</span><span class="o">]</span>
<span class="o">{</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span> <span class="o">}</span> <span class="o">{</span> <span class="n">Hunion</span> <span class="o">:</span> <span class="n">A</span> <span class="err">∪</span> <span class="n">B</span> <span class="bp">=</span> <span class="n">set</span><span class="bp">.</span><span class="n">univ</span><span class="o">}</span> <span class="o">{</span><span class="n">fa</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">Y</span> <span class="o">}</span> <span class="o">{</span> <span class="n">fb</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">Y</span> <span class="o">}</span>
<span class="o">{</span><span class="n">HAclosed</span> <span class="o">:</span> <span class="n">is_closed</span> <span class="n">A</span><span class="o">}</span> <span class="o">{</span><span class="n">HBclosed</span> <span class="o">:</span> <span class="n">is_closed</span> <span class="n">B</span><span class="o">}</span>  <span class="o">{</span> <span class="n">Hmatch</span> <span class="o">:</span> <span class="n">match_of_fun</span> <span class="n">fa</span> <span class="n">fb</span> <span class="o">}</span>
<span class="o">(</span> <span class="n">CA</span> <span class="o">:</span> <span class="n">continuous</span> <span class="n">fa</span> <span class="o">)</span> <span class="o">(</span> <span class="n">CB</span> <span class="o">:</span> <span class="n">continuous</span> <span class="n">fb</span><span class="o">)</span>  <span class="o">:</span> <span class="n">continuous</span> <span class="o">(</span><span class="n">paste</span> <span class="n">Hunion</span> <span class="n">fa</span> <span class="n">fb</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">...</span>
</pre></div>


<p>?</p>

<a name="130204505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130204505" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130204505">Kevin Buzzard (Jul 24 2018 at 11:07)</a>:</h4>
<blockquote>
<p>Is there a way to prove <code> fa x = fa ⟨x.val, ?m_1⟩ </code>?  (I thought the <code>have</code>s should do the job but then <code>rw H1</code> fails )</p>
</blockquote>
<p>Luca I mentioned this in my talk yesterday. The problem here is that x is <code>\&lt;x.val,x.property\&gt;</code> but you're trying to compare <code>x</code> with <code>\&lt;x.val,h\&gt;</code> for <code>h</code> some (un-named, that's why it says ?m_1) other proof of the thing that <code>x.property</code> is a proof of. Because these are both proofs of the same thing, they're definitionally equal by definition, so actually <code>x = ⟨x.val, ?m_1⟩</code> . Take a look at theorems like <code>subtype.eq</code> and <code>subtype.eta</code> to see the various tricks that can be used, but remember  that <code>simp</code> will know all the important ones.</p>

<a name="130204515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130204515" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130204515">Mario Carneiro (Jul 24 2018 at 11:07)</a>:</h4>
<p>the easy proof is <code>cases x, refl</code></p>

<a name="130204566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130204566" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130204566">Mario Carneiro (Jul 24 2018 at 11:08)</a>:</h4>
<p>I usually do cases on a variable like this before proofs, because everything becomes definitionally true that way</p>

<a name="130220203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130220203" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130220203">Nicholas Scheel (Jul 24 2018 at 16:07)</a>:</h4>
<p><span class="user-mention" data-user-id="120726">@Luca Gerolla</span> yes that’s what I meant, but it‘s not a big deal either way – looks like you’re making progress on it already :)</p>

<a name="130245778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130245778" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130245778">Kevin Buzzard (Jul 25 2018 at 00:00)</a>:</h4>
<p>So I am a bit confused as to why typeclass inference doesn't put a topology on the subtype of a topological space. Here's some non-pasteable code:</p>

<a name="130245786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130245786" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130245786">Kevin Buzzard (Jul 25 2018 at 00:00)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="bp">#</span><span class="kn">check</span> <span class="n">Spv</span><span class="bp">.</span><span class="n">is_continuous</span> <span class="c1">-- Spv.is_continuous : Spv ?M_1 → Prop</span>

<span class="n">def</span> <span class="n">Cont</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">topological_ring</span> <span class="n">R</span><span class="o">]</span>
  <span class="o">:=</span> <span class="o">{</span><span class="n">vs</span> <span class="o">:</span> <span class="n">Spv</span> <span class="n">R</span> <span class="bp">//</span> <span class="n">Spv</span><span class="bp">.</span><span class="n">is_continuous</span> <span class="n">vs</span><span class="o">}</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">topological_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span>
<span class="n">topological_space</span> <span class="o">(</span><span class="n">Spv</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span> <span class="c1">-- works</span>

<span class="c1">--example (R : Type) [comm_ring R] [topological_space R] [topological_ring R] :</span>
<span class="c1">--topological_space (Cont R) := by apply_instance -- fails</span>

<span class="kn">instance</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">topological_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span>
<span class="n">topological_space</span> <span class="o">(</span><span class="n">Cont</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">topological_space</span>
</pre></div>

<a name="130245821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130245821" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130245821">Kevin Buzzard (Jul 25 2018 at 00:01)</a>:</h4>
<p><code>Spv R</code> is a topological space, and type class inference knows this. I then make a subtype, and even though <code>subtype.topological_space</code> is marked as an instance, type class inference doesn't seem to work. Is this to do with <code>topological_space</code> being a structure with the class attribute rather than a class?</p>

<a name="130245882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130245882" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130245882">Kevin Buzzard (Jul 25 2018 at 00:02)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">analysis</span><span class="bp">.</span><span class="n">topology</span><span class="bp">.</span><span class="n">topological_space</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span>
<span class="n">topological_space</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">//</span> <span class="n">p</span> <span class="n">x</span><span class="o">}</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span>
</pre></div>

<a name="130245885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130245885" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130245885">Kevin Buzzard (Jul 25 2018 at 00:03)</a>:</h4>
<p>My MWE works :-/</p>

<a name="130246071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130246071" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130246071">Chris Hughes (Jul 25 2018 at 00:08)</a>:</h4>
<p>It can infer a topological space structure on <code>{vs : Spv R // Spv.is_continuous vs}</code> but not if you give it a different names.</p>

<a name="130246074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130246074" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130246074">Chris Hughes (Jul 25 2018 at 00:08)</a>:</h4>
<p>because type class inference looks at the <code>expr</code></p>

<a name="130246087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130246087" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130246087">Kevin Buzzard (Jul 25 2018 at 00:09)</a>:</h4>
<p>So am I OK to make the instance like I did?</p>

<a name="130246091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130246091" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130246091">Kevin Buzzard (Jul 25 2018 at 00:09)</a>:</h4>
<p>I don't want to make diamonds</p>

<a name="130246138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130246138" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130246138">Chris Hughes (Jul 25 2018 at 00:10)</a>:</h4>
<p>Don't see why not. It's a defeq diamond, and it's not even a diamond really because there's only one path it will choose.</p>

<a name="130246147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130246147" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130246147">Kevin Buzzard (Jul 25 2018 at 00:11)</a>:</h4>
<p>Thanks Chris.</p>

<a name="130259969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130259969" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130259969">Mario Carneiro (Jul 25 2018 at 07:33)</a>:</h4>
<p>You will notice the pattern <code>by unfold foo; apply_instance</code> used for this sort of situation (although an alternative is to do the first step of instance work yourself, as you did)</p>

<a name="130262773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130262773" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130262773">Kevin Buzzard (Jul 25 2018 at 08:42)</a>:</h4>
<p>I think I prefer your solution -- it sounds safer. I hadn't really internalised this type class inference fact though -- so it's picky about defeq like <code>rw</code>?</p>

<a name="130262843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130262843" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130262843">Mario Carneiro (Jul 25 2018 at 08:44)</a>:</h4>
<p>yes, it only unfolds <code>reducible</code> definitions</p>

<a name="130262867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130262867" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130262867">Mario Carneiro (Jul 25 2018 at 08:45)</a>:</h4>
<p>This is a good thing, because it means you can attach different typeclasses to defeq things, like <code>with_top A = with_bot A</code></p>

<a name="130262892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130262892" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130262892">Mario Carneiro (Jul 25 2018 at 08:46)</a>:</h4>
<p>So naming a def is a way of controlling what typeclasses you want to inherit</p>

<a name="130262934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130262934" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130262934">Johan Commelin (Jul 25 2018 at 08:46)</a>:</h4>
<p>I guess it sometimes makes sense to make definitions reducible. What do you think about <code>Cont</code>? Might that be a case where <code>reducible</code> makes sense?</p>

<a name="130262943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130262943" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130262943">Mario Carneiro (Jul 25 2018 at 08:46)</a>:</h4>
<p>I find that it is almost never a good idea to mark a definition <code>reducible</code></p>

<a name="130263136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130263136" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130263136">Kevin Buzzard (Jul 25 2018 at 08:50)</a>:</h4>
<p>You make it reducible and any goal with <code>Cont</code> in just gets unfolded and looks more unreadable. I think.</p>

<a name="130263163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130263163" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130263163">Johan Commelin (Jul 25 2018 at 08:51)</a>:</h4>
<p>Yes, so let's not do that. After all, <code>unfold</code>ing isn't very hard to do, if we need it.</p>

<a name="130413232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130413232" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130413232">Luca Gerolla (Jul 27 2018 at 14:20)</a>:</h4>
<p>Hello, has it been proved anywhere that a closed interval  [r, s]  is indeed closed?<br>
 I am stuck proving that a subset  <code> T r s Hrs </code>( closed subinterval [r,s] ) of  <code> I01 </code> ( unit interval [0, 1] ) is closed </p>
<div class="codehilite"><pre><span></span><span class="c1">-- May be needed / useful for Guillermo - Heine-Borel Thm</span>
<span class="kn">theorem</span> <span class="n">is_closed_int</span> <span class="o">{</span> <span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">}</span> <span class="o">(</span> <span class="n">Hrs</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">&lt;</span> <span class="n">s</span> <span class="o">)</span> <span class="o">:</span> <span class="n">is_closed</span> <span class="o">(</span><span class="n">int_clos</span> <span class="n">Hrs</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span> <span class="n">sorry</span> <span class="kn">end</span>


<span class="kn">lemma</span> <span class="n">T_is_closed</span>  <span class="o">{</span> <span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">}</span> <span class="o">(</span> <span class="n">Hrs</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">&lt;</span> <span class="n">s</span> <span class="o">):</span> <span class="n">is_closed</span> <span class="o">(</span><span class="n">T</span> <span class="n">r</span> <span class="n">s</span> <span class="n">Hrs</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span> <span class="n">unfold</span> <span class="n">T</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">is_closed_iff_nhds</span><span class="bp">.</span><span class="mi">2</span>
        <span class="o">(</span><span class="k">begin</span> <span class="n">intros</span> <span class="n">a</span> <span class="n">H</span> <span class="o">,</span> <span class="c1">--by_contradiction,</span>

        <span class="n">sorry</span> <span class="o">,</span>
    <span class="kn">end</span><span class="o">),</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">T_is_closed2</span>  <span class="o">{</span> <span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">}</span> <span class="o">(</span> <span class="n">Hrs</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">&lt;</span> <span class="n">s</span> <span class="o">):</span> <span class="n">is_closed</span> <span class="o">(</span><span class="n">T</span> <span class="n">r</span> <span class="n">s</span> <span class="n">Hrs</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span> <span class="n">unfold</span> <span class="n">T</span><span class="o">,</span>
<span class="c1">-- Write in terms of intersection with I01 (i.e. T r s Hrs =  I01 ∧  closed_int Hrs), resolving subset nesting problem</span>
    <span class="c1">-- Prove auxilliary lemma that (closed_int Hrs) is indeed closed</span>
        <span class="c1">-- Use is_closed_inter to prove this lemma</span>
<span class="c1">--have Int : {x : ↥I01 | r ≤ x.val ∧ x.val ≤ s} = set.inter univ  (closed_int Hrs) ,</span>
<span class="n">sorry</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p>With the underlying definitions </p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">I01</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">|</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">≤</span> <span class="mi">1</span><span class="o">}</span>

<span class="kn">definition</span> <span class="n">T</span> <span class="o">(</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">)</span> <span class="o">(</span> <span class="n">Hab</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">I01</span> <span class="o">:=</span>  <span class="o">{</span> <span class="n">x</span> <span class="o">:</span> <span class="n">I01</span> <span class="bp">|</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">x</span><span class="bp">.</span><span class="n">val</span> <span class="bp">∧</span> <span class="n">x</span><span class="bp">.</span><span class="n">val</span> <span class="bp">≤</span> <span class="n">b</span> <span class="o">}</span>

<span class="n">def</span> <span class="n">int_clos</span> <span class="o">{</span> <span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">}</span> <span class="o">(</span> <span class="n">Hrs</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">&lt;</span> <span class="n">s</span> <span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span>  <span class="bp">|</span> <span class="n">r</span> <span class="bp">≤</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">s</span><span class="o">}</span>
</pre></div>

<a name="130413243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130413243" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130413243">Kenny Lau (Jul 27 2018 at 14:20)</a>:</h4>
<p>it's even compact</p>

<a name="130413266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130413266" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130413266">Luca Gerolla (Jul 27 2018 at 14:20)</a>:</h4>
<blockquote>
<p>it's even compact</p>
</blockquote>
<p>Indeed! :)</p>

<a name="130413279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130413279" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130413279">Kenny Lau (Jul 27 2018 at 14:21)</a>:</h4>
<p>what I mean is it's even proved that it is compact</p>

<a name="130413304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130413304" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130413304">Reid Barton (Jul 27 2018 at 14:21)</a>:</h4>
<p>Check out the stuff around <code>ordered_topology</code> in <code>analysis.topology.topological_structures</code>, such as <code>is_closed_le</code></p>

<a name="130413315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130413315" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130413315">Luca Gerolla (Jul 27 2018 at 14:21)</a>:</h4>
<p>Oh, haven't thought to approach it from compactness..</p>

<a name="130413384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130413384" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130413384">Kenny Lau (Jul 27 2018 at 14:22)</a>:</h4>
<p>that isn't what I mean either, what I mean is that we even proved that it is compact, so I would expect it to be proved that it is closed</p>

<a name="130414100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130414100" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130414100">Kevin Buzzard (Jul 27 2018 at 14:34)</a>:</h4>
<p>Luca -- what Kenny means is "the answer to your first question is almost certainly yes". Here are some things which should be in mathlib <em>somewhere</em> : (1) interval [r,s] as a subspace of [0,1] with subspace topology will be closed in [0,1] if it is closed in R (2) interval [r,s] is closed in R. Reid is suggesting some places in mathlib where you might well find the theorems you want.</p>
<p>As a rule of thumb, when you are working on "high level" stuff like this, your first instinct should be to look in the library to see what is there. I know it sometimes feels a bit daunting but you could do worse than looking at a whole bunch of those topology files and looking through them. They are often long and complex, and written by experts so the proofs are often incomprehensible. But the trick is to find such a file, then to scan over it once and try and find the <em>definitions</em>, and see if you can figure out what they are supposed to be (because they are kind of like notation -- they are the language the file is written in, in some sense) and then scan over it again and try and find the <em>statements of the main theorems</em>.  Some clues as to whether a theorem is a "main theorem" -- it might be called "theorem" rather than "lemma", it might have a docstring (a comment starting with <code>/-- ... -/</code> -- note two dashes not one), or it might have a long proof. <em>DO NOT TRY TO READ ANY LONG PROOFS!</em>. You will get depressed and it will all seem much harder. If you find that you simply cannot understand a file because e.g. the definitions are constantly using things you've not heard of, then perhaps you started too late; look at the files which are imported at the very top and try reading one of those instead. Remember also that if a file compiles perfectly then you should be able to hover over anything and see its definition, or right click on it and see it in context. </p>
<p>I remember finding the files where rationals and reals were defined very intimidating to read, but that was before I started picking up some of the tricks I mention above.</p>

<a name="130415106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130415106" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130415106">Mario Carneiro (Jul 27 2018 at 14:52)</a>:</h4>
<p><code>is_closed_Icc</code><br>
<a href="https://github.com/leanprover/mathlib/blob/master/analysis/topology/topological_structures.lean#L282-L283" target="_blank" title="https://github.com/leanprover/mathlib/blob/master/analysis/topology/topological_structures.lean#L282-L283">https://github.com/leanprover/mathlib/blob/master/analysis/topology/topological_structures.lean#L282-L283</a></p>

<a name="130415280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130415280" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130415280">Mario Carneiro (Jul 27 2018 at 14:55)</a>:</h4>
<p>mathlib doesn't really use <code>theorem</code> vs <code>lemma</code> distinction (or at least I don't like to make this distinction)</p>

<a name="130415388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130415388" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130415388">Mario Carneiro (Jul 27 2018 at 14:57)</a>:</h4>
<p>I'm not sure it's worth focusing on "important theorems" either when reading mathlib files - you will usually be interested in easy theorems anyway. <code>is_closed_Icc</code> is an easy theorem</p>

<a name="130415529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130415529" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130415529">Luca Gerolla (Jul 27 2018 at 15:00)</a>:</h4>
<blockquote>
<p>Check out the stuff around <code>ordered_topology</code> in <code>analysis.topology.topological_structures</code>, such as <code>is_closed_le</code></p>
</blockquote>
<p>Thank you very much, <code>is_closed_le' </code> and  `is_closed_ge'  allowed me to prove [r, s] is closed without getting to use nhds and filters!</p>

<a name="130415717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Topology%20-%20Beginner/near/130415717" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/29013TopologyBeginner.html#130415717">Luca Gerolla (Jul 27 2018 at 15:02)</a>:</h4>
<p><code>is_closed_Icc </code> would have made it even quicker! (should have updated my mathlib to notice it!)  :)</p>


{% endraw %}
