---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/55758HammersSMT.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/55758HammersSMT.html">Hammers, SMT</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="190706517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Hammers%2C%20SMT/near/190706517" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/55758HammersSMT.html#190706517">Bas Spitters (Mar 16 2020 at 10:58)</a>:</h4>
<p>What is the status of hammers (like sledgehammer) in lean? Development in Coq seems to be somewhat stalled, but there are some interesting datasets:<br>
<a href="https://coq.discourse.group/t/coqhammer-1-1-1-for-coq-8-9/327/12" target="_blank" title="https://coq.discourse.group/t/coqhammer-1-1-1-for-coq-8-9/327/12">https://coq.discourse.group/t/coqhammer-1-1-1-for-coq-8-9/327/12</a><br>
<a href="https://coq.discourse.group/t/machine-learning-and-hammers-for-coq/303" target="_blank" title="https://coq.discourse.group/t/machine-learning-and-hammers-for-coq/303">https://coq.discourse.group/t/machine-learning-and-hammers-for-coq/303</a></p>
<p>Chantal Keller is doing nice work with on safely importing SMT proofs into Coq, and she is defining her own intermediate format. Could the same be used for lean?<br>
<a href="https://github.com/smtcoq/smtcoq" target="_blank" title="https://github.com/smtcoq/smtcoq">https://github.com/smtcoq/smtcoq</a></p>

<a name="190706600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Hammers%2C%20SMT/near/190706600" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/55758HammersSMT.html#190706600">Gabriel Ebner (Mar 16 2020 at 10:59)</a>:</h4>
<p>I've been working on a sledgehammer-like tool.  Here are the slides from FoMM in January: <a href="https://gebner.org/pdfs/2020-01-08_fomm20_leanhammer.pdf" target="_blank" title="https://gebner.org/pdfs/2020-01-08_fomm20_leanhammer.pdf">https://gebner.org/pdfs/2020-01-08_fomm20_leanhammer.pdf</a></p>

<a name="190706763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Hammers%2C%20SMT/near/190706763" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/55758HammersSMT.html#190706763">Gabriel Ebner (Mar 16 2020 at 11:01)</a>:</h4>
<p>However due to performance issues, I don't think this will ever make it into Lean3/mathlib.  Any future work will happen in Lean 4.</p>

<a name="190707685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Hammers%2C%20SMT/near/190707685" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/55758HammersSMT.html#190707685">Bas Spitters (Mar 16 2020 at 11:11)</a>:</h4>
<p>Nice! How much of this can be modularized? You don't seem to be using any parts of sledgehammer, coqhammer, deephol, ...<br>
BTW did you look at easycrypt? It uses why3 as an intermediate, and is quite pleasant to use.</p>

<a name="190708020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Hammers%2C%20SMT/near/190708020" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/55758HammersSMT.html#190708020">Gabriel Ebner (Mar 16 2020 at 11:15)</a>:</h4>
<p>No, everything I've had for FoMM is homegrown.  Since then, I've hooked up the relevance filter from CoqHammer (because it's pretty generic and written in C++, which is nice since Lean is also C++).  But in my tests it didn't perform any better than the dumb filters I was using before.</p>

<a name="190708284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Hammers%2C%20SMT/near/190708284" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/55758HammersSMT.html#190708284">Gabriel Ebner (Mar 16 2020 at 11:17)</a>:</h4>
<p>I don't think it makes sense to reuse translations at all.  It's pretty short and straightforward code, but it depends very much on the logic of the proof assistant.</p>

<a name="190708417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Hammers%2C%20SMT/near/190708417" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/55758HammersSMT.html#190708417">Gabriel Ebner (Mar 16 2020 at 11:19)</a>:</h4>
<p>I didn't know about easycrypt.  I'll take a look but it seems extremely specific ("reasoning about relational properties of probabilistic computations with adversarial code").</p>

<a name="190708430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Hammers%2C%20SMT/near/190708430" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/55758HammersSMT.html#190708430">Bas Spitters (Mar 16 2020 at 11:19)</a>:</h4>
<p>What are the relevant differences between classical Coq, isabelle and lean?</p>

<a name="190708599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Hammers%2C%20SMT/near/190708599" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/55758HammersSMT.html#190708599">Bas Spitters (Mar 16 2020 at 11:21)</a>:</h4>
<p>Easycrypt has an ambient logic: Classical HOL. There tactic language is ssr with an smt tactic. The libraries are fairly close copies of math-comp.</p>

<a name="190708714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Hammers%2C%20SMT/near/190708714" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/55758HammersSMT.html#190708714">Bas Spitters (Mar 16 2020 at 11:22)</a>:</h4>
<p>They have more rewriting build in than Coq.</p>

<a name="190708948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Hammers%2C%20SMT/near/190708948" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/55758HammersSMT.html#190708948">Gabriel Ebner (Mar 16 2020 at 11:24)</a>:</h4>
<p>Isabelle is very much different from the other two: the logic is simply-typed lambda calculus, which is much weaker than the type theories of Lean and Coq, and also much closer to what external provers expect.  Additionally, type classes in Isabelle are much more restricted than in Lean: they are coherent, which means that there is a unique instance per type.  Hence you just need predicates for type classes that say which type has a type class, and you can e.g. write <code>add(a,b)</code> for addition (in a sound translation).  In Lean and Coq, you can have multiple implementations of addition for a type so you might need to carry around an additional argument that says which type class instance you use.</p>

<a name="190709170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Hammers%2C%20SMT/near/190709170" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/55758HammersSMT.html#190709170">Gabriel Ebner (Mar 16 2020 at 11:26)</a>:</h4>
<p>The differences between Lean and Coq are smaller.  Coq has more syntactic features that you need to encode: in a addition to lambdas, they also have fixpoints and match expressions.  On the other hand, Lean makes an auxiliary definitions if you write a <code>match</code>, and also adds equational lemmas that hide the actual implementation as recursors.  You typically don't want to definitionally unfold the auxiliary definition, and only use the equational lemmas.</p>

<a name="190714184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Hammers%2C%20SMT/near/190714184" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/55758HammersSMT.html#190714184">Bas Spitters (Mar 16 2020 at 12:22)</a>:</h4>
<p>Thanks. I understood you translated lean to HOL (as in your slides). From that point on, one could imagine that similar tools could be used as for isabelle and easycrypt.<br>
F* of course is another data point. However, I understand that the translation they are doing to smt solvers is not really well understood.</p>


{% endraw %}

{% include archive_update.html %}