---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/02078ultimatetactic.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/02078ultimatetactic.html">ultimate tactic</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="123052910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ultimate%20tactic/near/123052910" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/02078ultimatetactic.html#123052910">Patrick Massot (Feb 27 2018 at 18:24)</a>:</h4>
<p>I found the ultimate Lean tactic: <a href="https://stacks.math.columbia.edu/tag/05SG" target="_blank" title="https://stacks.math.columbia.edu/tag/05SG">https://stacks.math.columbia.edu/tag/05SG</a></p>

<a name="123052963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ultimate%20tactic/near/123052963" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/02078ultimatetactic.html#123052963">Patrick Massot (Feb 27 2018 at 18:24)</a>:</h4>
<p>I think this is my new favorite Stacks tag</p>

<a name="123053363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ultimate%20tactic/near/123053363" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/02078ultimatetactic.html#123053363">Sean Leather (Feb 27 2018 at 18:34)</a>:</h4>
<p><strong>Lemma 4.2.18.</strong> Let <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>:</mo><mrow><mi mathvariant="script">A</mi></mrow><mo>→</mo><mrow><mi mathvariant="script">B</mi></mrow></mrow><annotation encoding="application/x-tex">F : \mathcal{A} \to \mathcal{B}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mrel">:</span><span class="mord"><span class="mord mathcal">A</span></span><span class="mrel">→</span><span class="mord"><span class="mord mathcal" style="margin-right:0.03041em;">B</span></span></span></span></span> be a fully faithful functor. Suppose for every <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>∈</mo><mi>O</mi><mi>b</mi><mo>(</mo><mrow><mi mathvariant="script">B</mi></mrow><mo>)</mo></mrow><annotation encoding="application/x-tex">X \in Ob(\mathcal{B})</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07847em;">X</span><span class="mrel">∈</span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mord mathit">b</span><span class="mopen">(</span><span class="mord"><span class="mord mathcal" style="margin-right:0.03041em;">B</span></span><span class="mclose">)</span></span></span></span> given an object <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo>(</mo><mi>X</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">j(X)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05724em;">j</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span> of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="script">A</mi></mrow></mrow><annotation encoding="application/x-tex">\mathcal{A}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathcal">A</span></span></span></span></span> and an isomorphism <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>i</mi><mi>X</mi></msub><mo>:</mo><mi>X</mi><mo>→</mo><mi>F</mi><mo>(</mo><mi>j</mi><mo>(</mo><mi>X</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">i_X : X \to F(j(X))</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathit">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.07847em;">X</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mrel">:</span><span class="mord mathit" style="margin-right:0.07847em;">X</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05724em;">j</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>. Then there is a unique functor <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo>:</mo><mrow><mi mathvariant="script">B</mi></mrow><mo>→</mo><mrow><mi mathvariant="script">A</mi></mrow></mrow><annotation encoding="application/x-tex">j : \mathcal{B} \to \mathcal{A}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05724em;">j</span><span class="mrel">:</span><span class="mord"><span class="mord mathcal" style="margin-right:0.03041em;">B</span></span><span class="mrel">→</span><span class="mord"><span class="mord mathcal">A</span></span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.65952em;"></span><span class="strut bottom" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05724em;">j</span></span></span></span> extends the rule on objects, and the isomorphisms <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>i</mi><mi>X</mi></msub></mrow><annotation encoding="application/x-tex">i_X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.65952em;"></span><span class="strut bottom" style="height:0.80952em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.07847em;">X</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> define an isomorphism of functors <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mtext>id</mtext><mi mathvariant="script">B</mi></msub><mo>→</mo><mi>F</mi><mo>∘</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">\text{id}_\mathcal{B} \to F \circ j</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord"><span class="mord text"><span class="mord mathrm">id</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathcal mtight" style="margin-right:0.03041em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mbin">∘</span><span class="mord mathit" style="margin-right:0.05724em;">j</span></span></span></span>. Moreover, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.65952em;"></span><span class="strut bottom" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05724em;">j</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.13889em;">F</span></span></span></span> are quasi-inverse equivalences of categories.</p>
<p><strong>Proof.</strong> This lemma proves itself. <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">□</mi></mrow><annotation encoding="application/x-tex">\square</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.675em;"></span><span class="strut bottom" style="height:0.675em;vertical-align:0em;"></span><span class="base"><span class="mord amsrm">□</span></span></span></span></p>

<a name="123053864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ultimate%20tactic/near/123053864" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/02078ultimatetactic.html#123053864">Simon Hudon (Feb 27 2018 at 18:49)</a>:</h4>
<p>I think this recursive proof is not well founded <span class="emoji emoji-1f61b" title="stuck out tongue">:stuck_out_tongue:</span></p>


{% endraw %}

{% include archive_update.html %}