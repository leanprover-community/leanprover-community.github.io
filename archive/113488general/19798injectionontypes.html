---
layout: archive
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/19798injectionontypes.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html">injection on types</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="163114235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163114235" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163114235">Scott Olson (Apr 11 2019 at 16:14)</a>:</h4>
<p>If I have the hypothesis <code>h : fin n = fin m</code>, am I allowed to conclude <code>n = m</code>? If so, how?</p>

<a name="163114282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163114282" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163114282">Simon Hudon (Apr 11 2019 at 16:15)</a>:</h4>
<p>No you can't</p>

<a name="163114319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163114319" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163114319">Kevin Buzzard (Apr 11 2019 at 16:15)</a>:</h4>
<p>you can, but you'll have to work</p>

<a name="163114325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163114325" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163114325">Kevin Buzzard (Apr 11 2019 at 16:15)</a>:</h4>
<p>you can count both sides, right?</p>

<a name="163114390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163114390" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163114390">Kevin Buzzard (Apr 11 2019 at 16:16)</a>:</h4>
<p>Note however that equality of types is evil, so what you are doing might not be the best idea.</p>

<a name="163114400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163114400" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163114400">Simon Hudon (Apr 11 2019 at 16:16)</a>:</h4>
<p>You would need for <code>fin</code> to be an injective function and inductive types are not assumed to be injective. Only their constructors</p>

<a name="163114425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163114425" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163114425">Kevin Buzzard (Apr 11 2019 at 16:16)</a>:</h4>
<p>There's a trick in this particular case though</p>

<a name="163114433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163114433" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163114433">Kevin Buzzard (Apr 11 2019 at 16:16)</a>:</h4>
<p>Don't you think?</p>

<a name="163114442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163114442" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163114442">Simon Hudon (Apr 11 2019 at 16:16)</a>:</h4>
<p>You mean proving a bijection?</p>

<a name="163114474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163114474" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163114474">Kevin Buzzard (Apr 11 2019 at 16:17)</a>:</h4>
<p>Something should work, shouldn't it?</p>

<a name="163114579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163114579" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163114579">Scott Olson (Apr 11 2019 at 16:18)</a>:</h4>
<p>I may not need this, but it came up in a larger proof I was struggling with and I was curious if I was missing something obvious or if it was truly non-trivial</p>

<a name="163114601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163114601" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163114601">Reid Barton (Apr 11 2019 at 16:18)</a>:</h4>
<p>It is true but not trivial by Lean standards</p>

<a name="163114608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163114608" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163114608">Simon Hudon (Apr 11 2019 at 16:18)</a>:</h4>
<p>It is non-trivial. In general, it is not possible. I'm not convinced that it's possible in this case</p>

<a name="163114637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163114637" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163114637">Scott Olson (Apr 11 2019 at 16:19)</a>:</h4>
<p>Yeah, that makes sense</p>

<a name="163114827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163114827" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163114827">Reid Barton (Apr 11 2019 at 16:21)</a>:</h4>
<p>Also, what Kevin said--if you find yourself needing this then most likely something went wrong earlier</p>

<a name="163114854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163114854" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163114854">Chris Hughes (Apr 11 2019 at 16:21)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">fin_injective</span> <span class="o">{</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">fin</span> <span class="n">m</span><span class="o">)</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">m</span> <span class="o">:=</span>
<span class="n">by_contradiction</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">hnm</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hcard</span> <span class="o">:</span>  <span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="bp">≠</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="o">(</span><span class="n">fin</span> <span class="n">m</span><span class="o">),</span> <span class="k">by</span> <span class="n">simpa</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hm</span> <span class="o">:</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="o">(</span><span class="n">fin</span> <span class="n">m</span><span class="o">)</span> <span class="bp">=</span> <span class="n">m</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span><span class="o">,</span>
<span class="n">hcard</span> <span class="err">$</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span><span class="bp">;</span> <span class="n">convert</span> <span class="n">hm</span>
</pre></div>

<a name="163114969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163114969" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163114969">Simon Hudon (Apr 11 2019 at 16:23)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="110044">@Chris Hughes</span>!</p>

<a name="163114994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163114994" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163114994">Scott Olson (Apr 11 2019 at 16:23)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> That's also good to know, thanks</p>

<a name="163115009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163115009" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163115009">Scott Olson (Apr 11 2019 at 16:23)</a>:</h4>
<p>Interesting, so it's classically provable, I guess?</p>

<a name="163115172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163115172" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163115172">Chris Hughes (Apr 11 2019 at 16:25)</a>:</h4>
<p>It shouldn't need classical logic. Equality of naturals is decidable, so <code>by_contradiction</code> is fine. My theorem does use classical logic, but only because mathlib uses it where it's totally unnecessary.</p>

<a name="163115229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163115229" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163115229">Kevin Buzzard (Apr 11 2019 at 16:26)</a>:</h4>
<p>I think the more interesting question is why you were faced with this goal in the first place. We just got lucky in this case. We can't prove <code>ℕ ≠ ℤ</code> for example. Equality of types is not at all well-behaved in dependent type theory.</p>

<a name="163115253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163115253" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163115253">Scott Olson (Apr 11 2019 at 16:26)</a>:</h4>
<p>Oh right, that by_contradiction uses the decidable instance</p>

<a name="163115294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163115294" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163115294">Scott Olson (Apr 11 2019 at 16:26)</a>:</h4>
<p>Yeah, I expect I'll be back later with a question closer to the actual problem I'm dealing with</p>

<a name="163115338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163115338" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163115338">Scott Olson (Apr 11 2019 at 16:27)</a>:</h4>
<p>In my experience it is typically <code>simp</code> which makes every theorem use every axiom</p>

<a name="163115511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163115511" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163115511">Kevin Buzzard (Apr 11 2019 at 16:29)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">fintype</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">m</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">have</span> <span class="n">hm</span> <span class="o">:</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="o">(</span><span class="n">fin</span> <span class="n">m</span><span class="o">)</span> <span class="bp">=</span> <span class="n">m</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hn</span> <span class="o">:</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="n">at</span> <span class="n">hm</span><span class="o">,</span> <span class="c1">-- phew</span>
  <span class="n">convert</span> <span class="n">hm</span><span class="o">,</span>
  <span class="n">convert</span> <span class="n">hn</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span> <span class="c1">-- phew</span>
<span class="kn">end</span>
</pre></div>

<a name="163115539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163115539" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163115539">Chris Hughes (Apr 11 2019 at 16:30)</a>:</h4>
<p>I want a prop valued <code>fintype</code> for this stuff.</p>

<a name="163115613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163115613" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163115613">Kevin Buzzard (Apr 11 2019 at 16:30)</a>:</h4>
<p><code>finite</code> isn't good enough because you lose the size?</p>

<a name="163115663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163115663" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163115663">Chris Hughes (Apr 11 2019 at 16:31)</a>:</h4>
<p>Because it's <code>set.finite</code></p>

<a name="163115674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163115674" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163115674">Kevin Buzzard (Apr 11 2019 at 16:31)</a>:</h4>
<p>Oh yes!</p>

<a name="163115707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163115707" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163115707">Kevin Buzzard (Apr 11 2019 at 16:31)</a>:</h4>
<p>So it's just <code>nonempty (fintype X)</code>?</p>

<a name="163115807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163115807" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163115807">Chris Hughes (Apr 11 2019 at 16:33)</a>:</h4>
<p>Yes.</p>

<a name="163115904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163115904" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163115904">Kevin Buzzard (Apr 11 2019 at 16:34)</a>:</h4>
<p>And then you'll have some noncomputable <code>prop_fintype.card</code>?</p>

<a name="163116096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163116096" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163116096">Chris Hughes (Apr 11 2019 at 16:36)</a>:</h4>
<p>Something like that. I don't know if this is a good approach though. I guess coq with its non definitional proof irrelevance must have good tactics for dealing with this.</p>

<a name="163116231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163116231" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163116231">Scott Olson (Apr 11 2019 at 16:38)</a>:</h4>
<p>Inspired by <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>'s, I realized the reasoning is pretty direct:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">fin</span> <span class="n">m</span><span class="o">)</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">m</span> <span class="o">:=</span> <span class="k">calc</span>
    <span class="n">n</span> <span class="bp">=</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">fintype</span><span class="bp">.</span><span class="n">card_fin</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>
  <span class="bp">...</span> <span class="bp">=</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="o">(</span><span class="n">fin</span> <span class="n">m</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="o">{</span> <span class="n">congr</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h</span> <span class="o">}</span>
  <span class="bp">...</span> <span class="bp">=</span> <span class="n">m</span>                    <span class="o">:</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">card_fin</span> <span class="n">m</span>
</pre></div>

<a name="163117254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163117254" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163117254">Kevin Buzzard (Apr 11 2019 at 16:51)</a>:</h4>
<p>The middle equality is the ropey one. Look at this:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="o">(</span><span class="n">fin</span> <span class="n">m</span><span class="o">)</span> <span class="bp">=</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="c1">--  rw h, -- fails!</span>
<span class="c1">--  erw h, -- fails!</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">],</span> <span class="c1">-- works...</span>
  <span class="c1">-- ⊢ fintype.card (fin n) = n</span>
  <span class="n">exact</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">card_fin</span> <span class="n">n</span><span class="o">,</span> <span class="c1">-- fails!</span>
<span class="kn">end</span>
</pre></div>


<p>The failure error is:</p>
<div class="codehilite"><pre><span></span>invalid type ascription, term has type
  @fintype.card (fin n) (fin.fintype n) = n
but is expected to have type
  @fintype.card (fin n) (@eq.rec Type (fin m) (λ (α : Type), fintype α) (fin.fintype m) (fin n) h) = n
</pre></div>


<p>Lean has switched on pp.all so you can see the problem. When Lean says <code>fintype.card X</code> it really means <code>@fintype.card X (term of type fintype X)</code>, and the hidden terms are not definitionally equal.</p>

<a name="163117367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163117367" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163117367">Kevin Buzzard (Apr 11 2019 at 16:52)</a>:</h4>
<p>On the other hand, this works:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="o">(</span><span class="n">fin</span> <span class="n">m</span><span class="o">)</span> <span class="bp">=</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">],</span>
  <span class="c1">-- ⊢ fintype.card (fin n) = n</span>
  <span class="n">convert</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">card_fin</span> <span class="n">n</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p>When you're playing fast and loose with type equality like this, I've seen situations where <code>exact</code> doesn't close the goal but <code>convert</code> does.</p>

<a name="163117617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163117617" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163117617">Kevin Buzzard (Apr 11 2019 at 16:55)</a>:</h4>
<p>The point is that fintype is not a proposition, but it is a subsingleton, so there can be at most one term of type <code>fintype X</code>. However, if my understanding is correct, then if you have two terms of type <code>fintype X</code> then in contrast to propositions, the fact that they are equal might be a theorem, rather than definitional.</p>
<div class="codehilite"><pre><span></span><span class="kn">instance</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="n">subsingleton</span> <span class="o">(</span><span class="n">fintype</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="bp">⟨</span><span class="n">s₁</span><span class="o">,</span> <span class="n">h₁</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">s₂</span><span class="o">,</span> <span class="n">h₂</span><span class="bp">⟩</span><span class="o">,</span> <span class="k">by</span> <span class="n">congr</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">finset</span><span class="bp">.</span><span class="n">ext</span><span class="o">,</span> <span class="n">h₁</span><span class="o">,</span> <span class="n">h₂</span><span class="o">]</span><span class="bp">⟩</span>
</pre></div>


<p>In the proof that fintype X is a subsingleton in the library, congr is used.</p>

<a name="163117811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163117811" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163117811">Scott Olson (Apr 11 2019 at 16:58)</a>:</h4>
<p>If you dump the proof term of my proof you see this: <code>(congr (eq.refl (fintype.card α_1)) (subsingleton.elim (eq.rec _inst_1 e_1) _inst_1_1)))</code> which is relating two different instances of fintype and mentions subsingleton =)</p>

<a name="163117835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163117835" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163117835">Reid Barton (Apr 11 2019 at 16:58)</a>:</h4>
<p><code>congr</code> knows about subsingletons and will automatically take care of goals that would have been generated that say that two values of a subsingleton are equal. That's why Scott's <code>congr</code> proof worked, because of the subsingleton instance that Kevin just mentioned. It's also why using <code>convert</code> worked, because <code>convert</code> uses <code>congr</code> internally.</p>

<a name="163118271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163118271" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163118271">Kevin Buzzard (Apr 11 2019 at 17:04)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="o">(</span><span class="n">fin</span> <span class="n">m</span><span class="o">)</span> <span class="bp">=</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">],</span>
  <span class="c1">-- ⊢ fintype.card (fin n) = n but there&#39;s a horrible term of type fintype (fin n) in there</span>
  <span class="k">have</span> <span class="n">h2</span> <span class="o">:</span> <span class="o">(</span><span class="bp">@</span><span class="n">eq</span><span class="bp">.</span><span class="n">rec</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">fin</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">),</span> <span class="n">fintype</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">fintype</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">h</span><span class="o">)</span> <span class="bp">=</span> <span class="n">fin</span><span class="bp">.</span><span class="n">fintype</span> <span class="n">n</span><span class="o">,</span>
<span class="c1">--    refl, -- fails</span>
    <span class="n">apply</span> <span class="n">subsingleton</span><span class="bp">.</span><span class="n">elim</span><span class="o">,</span> <span class="c1">-- works</span>
  <span class="n">rw</span> <span class="n">h2</span><span class="o">,</span> <span class="c1">-- horrible invisible term now replaced by correct term</span>
  <span class="n">exact</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">card_fin</span> <span class="n">n</span><span class="o">,</span> <span class="c1">-- now works</span>
<span class="kn">end</span>
</pre></div>


<p>Here I manually do the rewrite, so I can get <code>exact</code> to work.</p>

<a name="163118303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163118303" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163118303">Kevin Buzzard (Apr 11 2019 at 17:05)</a>:</h4>
<p><code>h2</code> is an equality of two terms of type <code>fintype n</code></p>

<a name="163118882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163118882" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163118882">Chris Hughes (Apr 11 2019 at 17:13)</a>:</h4>
<p>Maybe equivs are easier than type equalities.</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">fin_injective</span> <span class="o">{</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">fin</span> <span class="n">m</span><span class="o">)</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">m</span> <span class="o">:=</span>
<span class="k">have</span> <span class="n">e</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="err">≃</span> <span class="n">fin</span> <span class="n">m</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">h</span><span class="o">,</span>
<span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="err">←</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">card_fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">card_congr</span> <span class="n">e</span><span class="o">,</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">card_fin</span><span class="o">]</span>
</pre></div>

<a name="163119172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163119172" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163119172">Kevin Buzzard (Apr 11 2019 at 17:17)</a>:</h4>
<p><span class="user-mention" data-user-id="130491">@Scott Olson</span> Chris' approach is much better, because if you have two types which you personally think are equal, then dependent type theory wants them not to be equal but to be equiv. Nobody has mentioned this yet in this thread! <code>equiv</code> of types (which is <em>data</em>) is the correct notion of type equality. Chris takes your crazy equality, translates it into an equiv of types, and then the proof is straightforward with no weird stuff going on under the hood.</p>

<a name="163119314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163119314" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163119314">Kevin Buzzard (Apr 11 2019 at 17:19)</a>:</h4>
<p>Actually, here the congr is hidden in the application of <code>fintype.card_congr</code> so there is still some dirty work going on.</p>

<a name="163119493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163119493" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163119493">Scott Olson (Apr 11 2019 at 17:21)</a>:</h4>
<p>Yeah, for sure, I wouldn't intentionally try to bring type equalities into my proof but they came up automatically during a few attempts and I got curious about the limits of those</p>

<a name="163119629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163119629" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163119629">Scott Olson (Apr 11 2019 at 17:23)</a>:</h4>
<p>An example of another true one that's probably harder or impossible to solve is <code>list a = list b -&gt; a = b</code></p>

<a name="163120465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163120465" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163120465">Scott Olson (Apr 11 2019 at 17:33)</a>:</h4>
<p>Whereas with equivalences it <em>might</em> be provable by building an equivalence of <code>a</code> and <code>b</code> that goes through single-element lists and proves they must roundtrip properly because of the left/right inverse properties</p>

<a name="163124366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163124366" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163124366">Chris Hughes (Apr 11 2019 at 18:17)</a>:</h4>
<p>For lists, it doesn't work with equivalences if <code>a</code> and <code>b</code> are finite or countable.</p>

<a name="163125161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163125161" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163125161">Scott Olson (Apr 11 2019 at 18:26)</a>:</h4>
<p>Well, if they are used completely parametrically the <code>list a \equiv list b</code> equivalence can't know if they're finite/countable or not, but then it turns into an argument of parametricity, another set of things that tend to be true but unprovable in current dependent type systems</p>

<a name="163125917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163125917" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163125917">Reid Barton (Apr 11 2019 at 18:35)</a>:</h4>
<p>You don't really want parametricity statements to be theorems internally, because they aren't true in the "standard" model that we usually want to interpret Lean into.</p>

<a name="163131467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163131467" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163131467">François G. Dorais (Apr 11 2019 at 19:53)</a>:</h4>
<p>What is an "argument of parametricity"?</p>

<a name="163137042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163137042" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163137042">Scott Olson (Apr 11 2019 at 21:04)</a>:</h4>
<p><span class="user-mention" data-user-id="119741">@François G. Dorais</span> parametricity is the property that functions which are completely generic over some type are restricted in what they could possibly do with them, e.g. I can argue that <code>∀ {α : Type}, α → α</code> <em>must</em> be the identity function</p>

<a name="163137060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163137060" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163137060">Scott Olson (Apr 11 2019 at 21:04)</a>:</h4>
<p>Not sure of a good link off the top of my head, but there's a bit of a wikipedia article <a href="https://en.wikipedia.org/wiki/Parametricity" target="_blank" title="https://en.wikipedia.org/wiki/Parametricity">https://en.wikipedia.org/wiki/Parametricity</a></p>

<a name="163141468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163141468" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163141468">Kevin Buzzard (Apr 11 2019 at 22:10)</a>:</h4>
<p>You could argue this but it's not provable, right? And in Lean's type theory it's not even true, if you allow me to switch on decidability of all propositions and then say that it's the identity except on bool when it switches true and false</p>

<a name="163141517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163141517" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163141517">Kevin Buzzard (Apr 11 2019 at 22:11)</a>:</h4>
<p>Maybe that's a concrete version of what Reid is saying</p>

<a name="163141607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163141607" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163141607">Kevin Buzzard (Apr 11 2019 at 22:12)</a>:</h4>
<p>Why are we even talking about this? If you have the hypothesis list a = list b then my impression is that you have made a design error of some sort</p>

<a name="163143824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163143824" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163143824">matt rice (Apr 11 2019 at 22:46)</a>:</h4>
<p>I put some rather self contained identity stuff here, which I guess is intended to show some trouble <a href="https://gist.github.com/ratmice/eb771aa05ff9106ff0bb07dca6e6eecb" target="_blank" title="https://gist.github.com/ratmice/eb771aa05ff9106ff0bb07dca6e6eecb">https://gist.github.com/ratmice/eb771aa05ff9106ff0bb07dca6e6eecb</a></p>

<a name="163145667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163145667" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163145667">Scott Olson (Apr 11 2019 at 23:17)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> Yeah, I brought it up as a more likely unprovable example to support the idea that this should be avoided.</p>
<p>And right, the parametricity argument is not provable in most current systems of dependent types I've seen. There are a few papers on designing systems where you actually get the "Theorems for Free" for free.</p>

<a name="163145782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163145782" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163145782">Scott Olson (Apr 11 2019 at 23:18)</a>:</h4>
<p>I hadn't thought about classical reasoning breaking parametricity but that makes sense. Anything that lets you match on opaque types in some way means you don't actually have parametric polymophism, you have ad hoc polymorphism.</p>

<a name="163149937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163149937" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163149937">Scott Olson (Apr 12 2019 at 00:42)</a>:</h4>
<p>To make things completely concrete, this is the classical counterexample to parametricity I didn't think about that was mentioned:</p>
<div class="codehilite"><pre><span></span><span class="n">local</span> <span class="n">attribute</span> <span class="o">[</span><span class="kn">instance</span><span class="o">]</span> <span class="n">classical</span><span class="bp">.</span><span class="n">prop_decidable</span>

<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">non_id</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">bool</span>
<span class="k">then</span> <span class="n">h</span><span class="bp">.</span><span class="n">mpr</span> <span class="o">(</span><span class="n">bnot</span> <span class="o">(</span><span class="n">h</span><span class="bp">.</span><span class="n">mp</span> <span class="n">x</span><span class="o">))</span>
<span class="k">else</span> <span class="n">x</span>
</pre></div>

<a name="163150126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163150126" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163150126">Mario Carneiro (Apr 12 2019 at 00:46)</a>:</h4>
<p>Notably, this definition is <code>noncomputable</code>. It is believed (but not proven, I think) that any computable definition of id is defeq to the obvious one</p>

<a name="163150788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/injection%20on%20types/near/163150788" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/19798injectionontypes.html#163150788">Mario Carneiro (Apr 12 2019 at 01:02)</a>:</h4>
<p>ah, no defeq is the wrong notion for that. Here's a counterexample:</p>
<div class="codehilite"><pre><span></span><span class="n">noncomputable</span> <span class="n">def</span> <span class="n">stuck_id</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
<span class="n">bool</span><span class="bp">.</span><span class="n">rec</span> <span class="n">x</span> <span class="n">x</span> <span class="o">(</span><span class="bp">@</span><span class="n">classical</span><span class="bp">.</span><span class="n">choice</span> <span class="n">bool</span> <span class="bp">⟨</span><span class="n">tt</span><span class="bp">⟩</span><span class="o">)</span>

<span class="kn">theorem</span> <span class="n">stuck_id_eq</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">stuck_id</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">unfold</span> <span class="n">stuck_id</span><span class="bp">;</span> <span class="n">cases</span> <span class="bp">@</span><span class="n">classical</span><span class="bp">.</span><span class="n">choice</span> <span class="n">bool</span> <span class="bp">⟨</span><span class="n">tt</span><span class="bp">⟩;</span> <span class="n">refl</span>

<span class="n">def</span> <span class="n">foo</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
<span class="n">cast</span> <span class="o">(</span><span class="k">show</span> <span class="n">stuck_id</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">α</span><span class="o">,</span> <span class="k">from</span> <span class="o">(</span><span class="n">stuck_id_eq</span> <span class="n">α</span><span class="o">))</span> <span class="err">$</span>
<span class="n">cast</span> <span class="o">(</span><span class="k">show</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">stuck_id</span> <span class="n">α</span><span class="o">,</span> <span class="k">from</span> <span class="o">(</span><span class="n">stuck_id_eq</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">)</span> <span class="n">x</span>

<span class="kn">set_option</span> <span class="n">pp</span><span class="bp">.</span><span class="n">proofs</span> <span class="n">true</span>
<span class="bp">#</span><span class="n">reduce</span> <span class="bp">@</span><span class="n">foo</span>
<span class="c1">-- λ {α : Type} (x : α),</span>
<span class="c1">--   eq.rec</span>
<span class="c1">--     (eq.rec x</span>
<span class="c1">--        (eq.rec (eq.refl (bool.rec α α (classical.choice (nonempty.intro tt))))</span>
<span class="c1">--           (bool.rec (eq.refl α) (eq.refl α) (classical.choice (nonempty.intro tt)))))</span>
<span class="c1">--     (bool.rec (eq.refl α) (eq.refl α) (classical.choice (nonempty.intro tt)))</span>

<span class="c1">-- Lean VM doesn&#39;t know what the big deal is...</span>
<span class="bp">#</span><span class="kn">eval</span> <span class="bp">@</span><span class="n">foo</span> <span class="bp">ℕ</span> <span class="mi">3</span> <span class="c1">-- 3</span>
</pre></div>


{% endraw %}
