---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/71427Type.html
---

## Stream: [general](index.html)
### Topic: [Type](71427Type.html)

---


{% raw %}
#### [ Hoang Le Truong (Jul 02 2018 at 20:31)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/128980204):
When I write 

variable Œ± : Type
variable x:Œ± 
def f: Œ± ‚Üí Œ± ‚Üí Prop:= Œª x y, x=y

#check f (x:Œ± )

I get messages: type mismatch at application f x term x has type Œ± :Type but is expected to have Type Type: Type 1
What mean is it? please can you explain it.

#### [ Simon Hudon (Jul 02 2018 at 20:36)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/128980473):
Add `set_option pp.universes true` before your `#check` statement, that should be informative. Also, please encode your code snippets between ticks (`` ` ``) so that the font helps seeing what is code and what isn't

#### [ Reid Barton (Jul 02 2018 at 20:36)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/128980495):
`f` has two arguments, `alpha` and `x`. You gave `x` but not `alpha`

#### [ Reid Barton (Jul 02 2018 at 20:37)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/128980519):
So it thinks that `(x : alpha)` is the first argument to `f`, which is the `Type`

#### [ Kenny Lau (Jul 02 2018 at 20:38)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/128980570):
oh lol alpha is explicit

#### [ Simon Hudon (Jul 02 2018 at 20:38)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/128980581):
Good catch

#### [ Kevin Buzzard (Jul 02 2018 at 20:50)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/128981193):
```lean
variable Œ± : Type
variable x:Œ±
def f: Œ± ‚Üí Œ± ‚Üí Prop:= Œª x y, x=y

#check f -- Œ† (Œ± : Type), Œ± ‚Üí Œ± ‚Üí Prop

variable {Œ≤ : Type}
variable y : Œ≤
def g : Œ≤ ‚Üí Œ≤ ‚Üí Prop := Œª x y, x = y 

#check g -- ?M_1 ‚Üí ?M_1 ‚Üí Prop

#check g (y : Œ≤) -- Œ≤ ‚Üí Prop

```

#### [ Hoang Le Truong (Jul 02 2018 at 20:50)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/128981198):
I add ( set_option pp.universes true) but it not run. I do not understand why we need it. In fact, I need ( f(x: alpha) to definition next object. example

( def g (e: Œ± √ó Œ±):  ‚Ñï := if f e.1 e.2 then 2 else 0 )

#### [ Kevin Buzzard (Jul 02 2018 at 20:50)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/128981203):
If you use `{` `}` then beta is implicit

#### [ Kevin Buzzard (Jul 02 2018 at 20:51)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/128981218):
You used nothing, which is the same as `(` `)`, for alpha, so it's explicit

#### [ Kevin Buzzard (Jul 02 2018 at 20:51)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/128981223):
so then you have to give it.

#### [ Kevin Buzzard (Jul 02 2018 at 20:52)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/128981271):
`#check f Œ± x -- Œ± ‚Üí Prop `

#### [ Simon Hudon (Jul 02 2018 at 20:52)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/128981276):
And my suspicion that universes  were the root of the trouble did not pan out so you can discard my advice

#### [ Hoang Le Truong (Jul 02 2018 at 20:58)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/128981563):
Thank you I fix it.

#### [ Hoang Le Truong (Jul 03 2018 at 13:43)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/129017496):
I have the following code 
```
variables {Œ± : Type} 

definition  f : Œ± ‚Üí list Œ±‚Üí ‚Ñï  
| a     []          := 0
| a     (b :: l)  :=   if a = b then  (f a l)+1  else f a l 
```
and I received messages  
```
failed to synthesize type class instance for Œ± : Type, f : Œ± ‚Üí list Œ±‚Üí ‚Ñï, a b: Œ±, l: list Œ± ‚ä¢ decidable (a=b)
``` 
If I used type ``` char``` then it run. Please can you explain it and how to use type ```Œ±``` in such cases

#### [ Sean Leather (Jul 03 2018 at 13:46)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/129017656):
The `if a = b then t else f` is notation for `ite (a = b) t f`, where:

```lean
def ite (c : Prop) [h : decidable c] {Œ± : Sort u} (t e : Œ±) : Œ±
```

So, Lean is looking for an instance `decidable (a = b)`. You can tell Lean to wait for an instance to appear until you actually use `f` by putting `[decidable_eq Œ±]` before the colon (`:`).

#### [ Sean Leather (Jul 03 2018 at 13:49)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/129017730):
Note how `decidable_eq` reduces:
```lean
#reduce decidable_eq -- Œª (Œ± : Sort u_1), Œ† (a b : Œ±), decidable (a = b)
```

#### [ Hoang Le Truong (Jul 03 2018 at 13:54)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/129017953):
Thank you for that, Sean

```
variables {Œ± : Type} [decidable_eq Œ±]

definition  f : Œ± ‚Üí list Œ±‚Üí ‚Ñï  
| a     []        := 0
| a     (b :: l)  :=   if a = b then  (f a l)+1  else f a l 
```
It is Ok

#### [ Sean Leather (Jul 03 2018 at 13:55)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/129017975):
Yes, that also works.

#### [ Sean Leather (Jul 03 2018 at 13:57)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/129018051):
If you put `variables [decidable_eq Œ±]` while learning, it's fine. But note that if you write other definitions or theorems using `Œ±` after that, they will all have `[decidable_eq Œ±]` in their type signatures, whether you want it that way or not.

#### [ Hoang Le Truong (Jul 03 2018 at 13:57)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/129018069):
How to repair it

#### [ Sean Leather (Jul 03 2018 at 13:57)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/129018070):
That's one of those things that can trip you up when you're writing larger collections of Lean code.

#### [ Sean Leather (Jul 03 2018 at 13:58)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/129018118):
You can use `section` or `namespace` to make the `variables` local to a region.

#### [ Sean Leather (Jul 03 2018 at 13:59)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/129018151):
So, if you know you want to write a bunch of things that need `decidable_eq`, you can:

```lean
section
variables {Œ± : Type} [decidable_eq Œ±]
def f ...
theorem p ...
end -- variables {Œ± : Type} [decidable_eq Œ±] not valid after this.
```

#### [ Hoang Le Truong (Jul 03 2018 at 14:06)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/129018476):
Thank you for that. I used it.  I have more question
```
variables {Œ± : Type} 

definition f (l:list Œ±):Prop := head l = last l 
```
and I received messages 
```
type mismatch at application head l = last l term last l has type l  ‚â† nil ‚Üí  Œ± but is expected have type Œ±
```
How use type which have condition as function last?

#### [ Sean Leather (Jul 03 2018 at 14:08)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/129018562):
You should first check the types:

```lean
#check @list.head
#check @list.last
```

```lean
list.head : Œ† {Œ± : Type u_1} [_inst_1 : inhabited Œ±], list Œ± ‚Üí Œ±
list.last : Œ† {Œ± : Type u_1} (l : list Œ±), l ‚â† list.nil ‚Üí Œ±
```

#### [ Hoang Le Truong (Jul 03 2018 at 14:09)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/129018577):
Yes I used it

#### [ Hoang Le Truong (Jul 03 2018 at 14:10)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/129018636):
```
import data.list
open list
```

#### [ Sean Leather (Jul 03 2018 at 14:10)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/129018642):
So, in order to use `last`, you will need to prove `l ‚â† list.nil`.

#### [ Sean Leather (Jul 03 2018 at 14:11)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/129018658):
I'm not sure what you want to do, but you could have that condition as a parameter to `f`.

#### [ Sean Leather (Jul 03 2018 at 14:13)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/129018745):
```lean
definition head_eq_last (l : list Œ±) (h : l ‚â† list.nil) : Prop := head l = last l h
```

#### [ Hoang Le Truong (Jul 03 2018 at 14:15)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/129018829):
In fact I want definition f such that head of l equal tail of l. In general, I want used type have condition

#### [ Mario Carneiro (Jul 03 2018 at 14:16)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/129018899):
should the empty list satisfy the definition?

#### [ Hoang Le Truong (Jul 03 2018 at 14:17)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/129018934):
the empty list is not satisfy definition

#### [ Mario Carneiro (Jul 03 2018 at 14:17)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/129018947):
Then you can write
```
definition head_eq_last (l : list Œ±) : Prop := ‚àÉ (h : l ‚â† list.nil), head l = last l h
```

#### [ Hoang Le Truong (Jul 03 2018 at 14:23)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/129019196):
I try it but I received messages 

```
failed to synthesize type class instance for Œ±: Type, l: list Œ±, h : l ‚â† list.nil ‚ä¢inhibited Œ±
```

#### [ Sean Leather (Jul 03 2018 at 14:30)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/129019478):
That's a consequence of the type of `head`. Easy to fix:

```lean
def head_eq_last [inhabited Œ±] (l : list Œ±) : Prop := ‚àÉ (h : l ‚â† list.nil), head l = last l h
```

#### [ Hoang Le Truong (Jul 03 2018 at 14:32)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/129019614):
Thank you for that, I understood

#### [ Sean Leather (Jul 03 2018 at 14:33)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/129019630):
Any time you see this message pattern:

```lean
failed to synthesize type class instance for ... ‚ä¢ C
```

Lean is looking for either an existing instance `C` or a parameter such as `[C]`.

#### [ Sean Leather (Jul 03 2018 at 14:33)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/129019643):
So, when you used `char`, it used the existing instance `decidable_eq char`.

#### [ Hoang Le Truong (Jul 05 2018 at 11:19)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/129126831):
when I restrict type ``` Œ± ``` to type ``` fintype Œ± ```, I have problem. My code is
```
variables {Œ± : Type}

def preimage (f:Œ± ‚Üí ‚Ñï ) (u:‚Ñï ):set Œ±  := Œª x, f x=u 

def card_image (f:(fintype Œ±) ‚Üí ‚Ñï) (u:‚Ñï ):‚Ñï 
:= fintype.card (preimage g u) 

```
and I received messages 
```
failed to synthesize type class instance for Œ± : Type, f : fintype Œ± ‚Üí ‚Ñï, u : ‚Ñï ‚ä¢ fintype ‚Ü•(preimage f u)
```
I understand that Lean  find ```fintype ‚Ü•(preimage f u)```. What mean is ``` ‚Ü•```?  can we show that ```  preimage f u ``` have type ``` fintype```? How I fix it

#### [ Chris Hughes (Jul 05 2018 at 11:37)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/129127521):
This code should work. In the function `card_image`, the type of `f` should probably be `Œ± ‚Üí ‚Ñï`. `fintype Œ±` is more or less just the statement that `Œ±` is finite. I also made `decidable_eq` an argument to the function as this is necessary to compute the `fintype` instance. You could also use the line`local attribute [instance] classical.prop_decidable` to achieve the same thing without `decidable_eq`.
```lean
import data.fintype

variables {Œ± : Type}

def preimage (f : Œ± ‚Üí ‚Ñï) (u : ‚Ñï) : set Œ±  := Œª x, f x=u

instance [fintype Œ±] [decidable_eq Œ±] (f : Œ± ‚Üí ‚Ñï) (u : ‚Ñï) : fintype (preimage f u) :=
by unfold preimage; apply_instance

def card_image [fintype Œ±] [decidable_eq Œ±] (f : Œ± ‚Üí ‚Ñï) (u : ‚Ñï) : ‚Ñï :=
fintype.card (preimage f u)
```

#### [ Hoang Le Truong (Jul 05 2018 at 11:45)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/129127861):
Thank @**Chris Hughes** for that. üëç

#### [ Hoang Le Truong (Jul 05 2018 at 20:40)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/129156114):
What mean is messages 
```
maximum class-instance resolution depth has been reached (the limit can be increased by setting option 'class.instance_max_depth') (the class-instance resolution trace can be visualized by setting option 'trace.class_instances')
```

#### [ Simon Hudon (Jul 05 2018 at 20:44)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/129156386):
That means that you need an instance for a certain type class. Lean is trying to find one for you but gives up. It might be because none exists or because the one that would work is, in a sense, unattainable by Lean. Do you know what type class you're trying to find an instance for?

#### [ Hoang Le Truong (Jul 05 2018 at 20:53)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/129156858):
my type class is ``` fintype ```. I have code 50 line. when I break it to two file then it run. But I run one file. it give messages

#### [ Simon Hudon (Jul 05 2018 at 21:03)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/129157533):
Can you great a `gist` on github and show me where you break it into two files?

#### [ Hoang Le Truong (Jul 05 2018 at 21:25)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/129158857):
https://gist.github.com/truonghoangle/b9fa69e939bcb6c20fcf96affc0fd965
I break it after end direct_graph

#### [ Simon Hudon (Jul 05 2018 at 21:26)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/129158935):
Great! When you break it, what import do you give the new file?

#### [ Hoang Le Truong (Jul 05 2018 at 21:29)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/129159094):
I use only ``` import data.fintype ```

#### [ Simon Hudon (Jul 05 2018 at 21:30)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/129159141):
try copying all the imports. You probably use instances from the other modules

#### [ Simon Hudon (Jul 05 2018 at 21:30)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/129159179):
You can remove one at a time until it breaks

#### [ Hoang Le Truong (Jul 05 2018 at 21:33)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type/near/129159316):
Ok it is run. Thank you for that


{% endraw %}
