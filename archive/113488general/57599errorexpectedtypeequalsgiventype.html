---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/57599errorexpectedtypeequalsgiventype.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/57599errorexpectedtypeequalsgiventype.html">error: expected type equals given type</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="155160367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/error%3A%20expected%20type%20equals%20given%20type/near/155160367" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57599errorexpectedtypeequalsgiventype.html#155160367">Johan Commelin (Jan 15 2019 at 21:47)</a>:</h4>
<p>A mystery:</p>
<div class="codehilite"><pre><span></span><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">functor</span><span class="bp">.</span><span class="n">on_iso</span> <span class="o">(</span><span class="n">yoneda</span><span class="bp">.</span><span class="n">obj</span> <span class="n">F</span><span class="o">)</span>
<span class="n">term</span>
  <span class="n">yoneda</span><span class="bp">.</span><span class="n">obj</span> <span class="n">F</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="n">presheaf</span> <span class="n">X</span><span class="err">·µí·µñ</span> <span class="err">‚•§</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">presheaf</span> <span class="n">X</span><span class="err">·µí·µñ</span> <span class="err">‚•§</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span>
</pre></div>


<p>Last week <span class="user-mention" data-user-id="110032">@Reid Barton</span> and I encountered a similar error when working on over categories. Back then we could fix it by specifying a universe variable. But that still felt like a hack around a bug. This time universe annotations don't seem to help.</p>
<p>Anyway, I'm more interested in fact that Lean thinks two types are the same, but isn't happy to move on.<br>
Here is the <code>pp.all</code> version:</p>
<div class="codehilite"><pre><span></span><span class="n">has</span> <span class="n">type</span>
  <span class="bp">@</span><span class="n">category_theory</span><span class="bp">.</span><span class="n">functor</span><span class="bp">.</span><span class="o">{(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="o">(</span><span class="n">v</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span>
    <span class="o">(</span><span class="n">category_theory</span><span class="bp">.</span><span class="n">op</span><span class="bp">.</span><span class="o">{(</span><span class="n">max</span> <span class="n">u</span> <span class="o">(</span><span class="n">v</span><span class="bp">+</span><span class="mi">1</span><span class="o">))}</span> <span class="o">(</span><span class="bp">@</span><span class="n">category_theory</span><span class="bp">.</span><span class="n">presheaf</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span> <span class="n">u</span><span class="o">}</span> <span class="n">X</span> <span class="err">ùí≥</span><span class="o">))</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">category_theory</span><span class="bp">.</span><span class="n">opposite</span><span class="bp">.</span><span class="o">{(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="o">(</span><span class="n">v</span><span class="bp">+</span><span class="mi">1</span><span class="o">))}</span> <span class="o">(</span><span class="bp">@</span><span class="n">category_theory</span><span class="bp">.</span><span class="n">presheaf</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span> <span class="n">u</span><span class="o">}</span> <span class="n">X</span> <span class="err">ùí≥</span><span class="o">)</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">category_theory</span><span class="bp">.</span><span class="n">presheaf</span><span class="bp">.</span><span class="n">category_theory</span><span class="bp">.</span><span class="n">category</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span> <span class="n">u</span><span class="o">}</span> <span class="n">X</span> <span class="err">ùí≥</span><span class="o">))</span>
    <span class="o">(</span><span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">))</span>
    <span class="n">category_theory</span><span class="bp">.</span><span class="n">types</span><span class="bp">.</span><span class="o">{(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)}</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="bp">@</span><span class="n">category_theory</span><span class="bp">.</span><span class="n">functor</span><span class="bp">.</span><span class="o">{(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="o">(</span><span class="n">v</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span>
    <span class="o">(</span><span class="n">category_theory</span><span class="bp">.</span><span class="n">op</span><span class="bp">.</span><span class="o">{(</span><span class="n">max</span> <span class="n">u</span> <span class="o">(</span><span class="n">v</span><span class="bp">+</span><span class="mi">1</span><span class="o">))}</span> <span class="o">(</span><span class="bp">@</span><span class="n">category_theory</span><span class="bp">.</span><span class="n">presheaf</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span> <span class="n">u</span><span class="o">}</span> <span class="n">X</span> <span class="err">ùí≥</span><span class="o">))</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">category_theory</span><span class="bp">.</span><span class="n">opposite</span><span class="bp">.</span><span class="o">{(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="o">(</span><span class="n">v</span><span class="bp">+</span><span class="mi">1</span><span class="o">))}</span> <span class="o">(</span><span class="bp">@</span><span class="n">category_theory</span><span class="bp">.</span><span class="n">presheaf</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span> <span class="n">u</span><span class="o">}</span> <span class="n">X</span> <span class="err">ùí≥</span><span class="o">)</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">category_theory</span><span class="bp">.</span><span class="n">presheaf</span><span class="bp">.</span><span class="n">category_theory</span><span class="bp">.</span><span class="n">category</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span> <span class="n">u</span><span class="o">}</span> <span class="n">X</span> <span class="err">ùí≥</span><span class="o">))</span>
    <span class="o">(</span><span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">))</span>
    <span class="n">category_theory</span><span class="bp">.</span><span class="n">types</span><span class="bp">.</span><span class="o">{(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)}</span>
</pre></div>

<a name="155162452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/error%3A%20expected%20type%20equals%20given%20type/near/155162452" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57599errorexpectedtypeequalsgiventype.html#155162452">Sebastian Ullrich (Jan 15 2019 at 22:32)</a>:</h4>
<p>If you have too much time and want to take a closer look, you could try turning on the various defeq traces. Not sure if the output will be of any help.</p>

<a name="155163901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/error%3A%20expected%20type%20equals%20given%20type/near/155163901" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57599errorexpectedtypeequalsgiventype.html#155163901">Johan Commelin (Jan 15 2019 at 23:03)</a>:</h4>
<p><span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span> I have a bit of time. Do you have a guess about what's going on? Are you interested in those traces? How do I turn them on?</p>

<a name="155164151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/error%3A%20expected%20type%20equals%20given%20type/near/155164151" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57599errorexpectedtypeequalsgiventype.html#155164151">Sebastian Ullrich (Jan 15 2019 at 23:07)</a>:</h4>
<p>It should be <code>trace.type_context.is_def_eq</code> and <code>trace.type_context.is_def_eq_detail</code>. I can take a look, though I won't promise anything :) .</p>

<a name="155164241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/error%3A%20expected%20type%20equals%20given%20type/near/155164241" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57599errorexpectedtypeequalsgiventype.html#155164241">Johan Commelin (Jan 15 2019 at 23:09)</a>:</h4>
<p>Output of <code>trace.type_context.is_def_eq</code>:</p>
<div class="codehilite"><pre><span></span><span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq</span><span class="o">]</span> <span class="kt">Type</span> <span class="err">?</span> <span class="bp">=</span><span class="err">?</span><span class="bp">=</span> <span class="kt">Type</span> <span class="err">?</span> <span class="bp">...</span> <span class="n">success</span>  <span class="o">(</span><span class="n">approximate</span> <span class="n">mode</span><span class="o">)</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq</span><span class="o">]</span> <span class="n">category</span> <span class="err">?</span><span class="n">m_1</span> <span class="bp">=</span><span class="err">?</span><span class="bp">=</span> <span class="n">category</span> <span class="err">?</span><span class="n">m_1</span> <span class="bp">...</span> <span class="n">success</span>  <span class="o">(</span><span class="n">approximate</span> <span class="n">mode</span><span class="o">)</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq</span><span class="o">]</span> <span class="kt">Type</span> <span class="err">?</span> <span class="bp">=</span><span class="err">?</span><span class="bp">=</span> <span class="kt">Type</span> <span class="err">?</span> <span class="bp">...</span> <span class="n">success</span>  <span class="o">(</span><span class="n">approximate</span> <span class="n">mode</span><span class="o">)</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq</span><span class="o">]</span> <span class="n">category</span> <span class="err">?</span><span class="n">m_1</span> <span class="bp">=</span><span class="err">?</span><span class="bp">=</span> <span class="n">category</span> <span class="err">?</span><span class="n">m_1</span> <span class="bp">...</span> <span class="n">success</span>  <span class="o">(</span><span class="n">approximate</span> <span class="n">mode</span><span class="o">)</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq</span><span class="o">]</span> <span class="err">?</span><span class="n">m_1</span> <span class="err">‚•§</span> <span class="err">?</span><span class="n">m_1</span><span class="err">·µí·µñ</span> <span class="err">‚•§</span> <span class="kt">Type</span> <span class="err">?</span> <span class="bp">=</span><span class="err">?</span><span class="bp">=</span> <span class="err">?</span><span class="n">m_3</span> <span class="err">‚•§</span> <span class="err">?</span><span class="n">m_5</span> <span class="bp">...</span> <span class="n">success</span>  <span class="o">(</span><span class="n">approximate</span> <span class="n">mode</span><span class="o">)</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq</span><span class="o">]</span> <span class="err">?</span><span class="n">m_1</span> <span class="err">‚•§</span> <span class="err">?</span><span class="n">m_3</span> <span class="bp">=</span><span class="err">?</span><span class="bp">=</span> <span class="err">?</span><span class="n">m_5</span> <span class="bp">...</span> <span class="n">success</span>  <span class="o">(</span><span class="n">approximate</span> <span class="n">mode</span><span class="o">)</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq</span><span class="o">]</span> <span class="n">presheaf</span> <span class="n">X</span> <span class="bp">=</span><span class="err">?</span><span class="bp">=</span> <span class="err">?</span><span class="n">m_1</span> <span class="bp">...</span> <span class="n">success</span>  <span class="o">(</span><span class="n">approximate</span> <span class="n">mode</span><span class="o">)</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq</span><span class="o">]</span> <span class="n">presheaf</span> <span class="n">X</span> <span class="bp">=</span><span class="err">?</span><span class="bp">=</span> <span class="err">?</span><span class="n">m_1</span> <span class="bp">...</span> <span class="n">success</span>  <span class="o">(</span><span class="n">approximate</span> <span class="n">mode</span><span class="o">)</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq</span><span class="o">]</span> <span class="err">?</span><span class="n">m_1</span> <span class="bp">=</span><span class="err">?</span><span class="bp">=</span> <span class="n">F</span> <span class="bp">...</span> <span class="n">success</span>  <span class="o">(</span><span class="n">approximate</span> <span class="n">mode</span><span class="o">)</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq</span><span class="o">]</span> <span class="err">?</span><span class="n">m_1</span> <span class="bp">=</span><span class="err">?</span><span class="bp">=</span> <span class="err">?</span><span class="n">m_2</span> <span class="err">‚•§</span> <span class="err">?</span><span class="n">m_4</span> <span class="bp">...</span> <span class="n">failed</span>  <span class="o">(</span><span class="n">approximate</span> <span class="n">mode</span><span class="o">)</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq</span><span class="o">]</span> <span class="err">?</span><span class="n">m_1</span> <span class="bp">=</span><span class="err">?</span><span class="bp">=</span> <span class="n">presheaf</span><span class="bp">.</span><span class="n">category_theory</span><span class="bp">.</span><span class="n">category</span> <span class="bp">...</span> <span class="n">success</span>  <span class="o">(</span><span class="n">approximate</span> <span class="n">mode</span><span class="o">)</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq</span><span class="o">]</span> <span class="err">?</span><span class="n">m_1</span> <span class="bp">=</span><span class="err">?</span><span class="bp">=</span> <span class="n">presheaf</span><span class="bp">.</span><span class="n">category_theory</span><span class="bp">.</span><span class="n">category</span> <span class="bp">...</span> <span class="n">success</span>  <span class="o">(</span><span class="n">approximate</span> <span class="n">mode</span><span class="o">)</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq</span><span class="o">]</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">types</span> <span class="bp">=</span><span class="err">?</span><span class="bp">=</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">types</span> <span class="bp">...</span> <span class="n">success</span>  <span class="o">(</span><span class="n">approximate</span> <span class="n">mode</span><span class="o">)</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq</span><span class="o">]</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">opposite</span> <span class="bp">=</span><span class="err">?</span><span class="bp">=</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">opposite</span> <span class="bp">...</span> <span class="n">success</span>  <span class="o">(</span><span class="n">approximate</span> <span class="n">mode</span><span class="o">)</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq</span><span class="o">]</span> <span class="n">functor</span><span class="bp">.</span><span class="n">category</span> <span class="n">presheaf</span> <span class="n">X</span><span class="err">·µí·µñ</span> <span class="o">(</span><span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">))</span> <span class="bp">=</span><span class="err">?</span><span class="bp">=</span> <span class="n">functor</span><span class="bp">.</span><span class="n">category</span> <span class="n">presheaf</span> <span class="n">X</span><span class="err">·µí·µñ</span> <span class="o">(</span><span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">))</span> <span class="bp">...</span> <span class="n">success</span>  <span class="o">(</span><span class="n">approximate</span> <span class="n">mode</span><span class="o">)</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq</span><span class="o">]</span> <span class="err">?</span><span class="n">x_1</span> <span class="bp">=</span><span class="err">?</span><span class="bp">=</span> <span class="n">presheaf</span> <span class="n">X</span><span class="err">·µí·µñ</span> <span class="err">‚•§</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="bp">...</span> <span class="n">success</span>  <span class="o">(</span><span class="n">approximate</span> <span class="n">mode</span><span class="o">)</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq</span><span class="o">]</span> <span class="err">?</span><span class="n">x_0</span> <span class="bp">=</span><span class="err">?</span><span class="bp">=</span> <span class="n">presheaf</span> <span class="n">X</span><span class="err">·µí·µñ</span> <span class="err">‚•§</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="bp">...</span> <span class="n">success</span>  <span class="o">(</span><span class="n">approximate</span> <span class="n">mode</span><span class="o">)</span>
</pre></div>

<a name="155164317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/error%3A%20expected%20type%20equals%20given%20type/near/155164317" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57599errorexpectedtypeequalsgiventype.html#155164317">Johan Commelin (Jan 15 2019 at 23:10)</a>:</h4>
<p>Output of <code>trace.type_context.is_def_eq_detail</code>:</p>
<div class="codehilite"><pre><span></span><span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="o">[</span><span class="mi">1</span><span class="o">]:</span> <span class="err">?</span><span class="n">m_1</span> <span class="err">‚•§</span> <span class="err">?</span><span class="n">m_1</span><span class="err">·µí·µñ</span> <span class="err">‚•§</span> <span class="kt">Type</span> <span class="err">?</span> <span class="bp">=</span><span class="err">?</span><span class="bp">=</span> <span class="err">?</span><span class="n">m_3</span> <span class="err">‚•§</span> <span class="err">?</span><span class="n">m_5</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="o">[</span><span class="mi">2</span><span class="o">]:</span> <span class="n">functor</span> <span class="bp">=</span><span class="err">?</span><span class="bp">=</span> <span class="n">functor</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="n">process_assignment</span> <span class="err">?</span><span class="n">m_1</span> <span class="o">:=</span> <span class="err">?</span><span class="n">m_2</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="n">assign</span><span class="o">:</span> <span class="err">?</span><span class="n">m_1</span> <span class="o">:=</span> <span class="err">?</span><span class="n">m_2</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="n">process_assignment</span> <span class="err">?</span><span class="n">m_1</span> <span class="o">:=</span> <span class="err">?</span><span class="n">m_2</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="o">[</span><span class="mi">2</span><span class="o">]:</span> <span class="n">category</span> <span class="err">?</span><span class="n">m_1</span> <span class="bp">=</span><span class="err">?</span><span class="bp">=</span> <span class="n">category</span> <span class="err">?</span><span class="n">m_2</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="o">[</span><span class="mi">3</span><span class="o">]:</span> <span class="n">category</span> <span class="bp">=</span><span class="err">?</span><span class="bp">=</span> <span class="n">category</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="n">assign</span><span class="o">:</span> <span class="err">?</span><span class="n">m_1</span> <span class="o">:=</span> <span class="err">?</span><span class="n">m_2</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="n">process_assignment</span> <span class="err">?</span><span class="n">m_1</span> <span class="o">:=</span> <span class="err">?</span><span class="n">m_2</span><span class="err">·µí·µñ</span> <span class="err">‚•§</span> <span class="kt">Type</span> <span class="err">?</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="n">assign</span><span class="o">:</span> <span class="err">?</span><span class="n">m_1</span> <span class="o">:=</span> <span class="err">?</span><span class="n">m_2</span><span class="err">·µí·µñ</span> <span class="err">‚•§</span> <span class="kt">Type</span> <span class="err">?</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="n">process_assignment</span> <span class="err">?</span><span class="n">m_1</span> <span class="o">:=</span> <span class="n">functor</span><span class="bp">.</span><span class="n">category</span> <span class="err">?</span><span class="n">m_2</span><span class="err">·µí·µñ</span> <span class="o">(</span><span class="kt">Type</span> <span class="err">?</span><span class="o">)</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="o">[</span><span class="mi">2</span><span class="o">]:</span> <span class="n">category</span> <span class="err">?</span><span class="n">m_1</span> <span class="bp">=</span><span class="err">?</span><span class="bp">=</span> <span class="n">category</span> <span class="o">(</span><span class="err">?</span><span class="n">m_2</span><span class="err">·µí·µñ</span> <span class="err">‚•§</span> <span class="kt">Type</span> <span class="err">?</span><span class="o">)</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="o">[</span><span class="mi">3</span><span class="o">]:</span> <span class="n">category</span> <span class="bp">=</span><span class="err">?</span><span class="bp">=</span> <span class="n">category</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="n">assign</span><span class="o">:</span> <span class="err">?</span><span class="n">m_1</span> <span class="o">:=</span> <span class="n">functor</span><span class="bp">.</span><span class="n">category</span> <span class="err">?</span><span class="n">m_2</span><span class="err">·µí·µñ</span> <span class="o">(</span><span class="kt">Type</span> <span class="err">?</span><span class="o">)</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="o">[</span><span class="mi">1</span><span class="o">]:</span> <span class="err">?</span><span class="n">m_1</span> <span class="err">‚•§</span> <span class="err">?</span><span class="n">m_3</span> <span class="bp">=</span><span class="err">?</span><span class="bp">=</span> <span class="err">?</span><span class="n">m_5</span><span class="err">·µí·µñ</span> <span class="err">‚•§</span> <span class="kt">Type</span> <span class="err">?</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="o">[</span><span class="mi">2</span><span class="o">]:</span> <span class="n">functor</span> <span class="bp">=</span><span class="err">?</span><span class="bp">=</span> <span class="n">functor</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="n">process_assignment</span> <span class="err">?</span><span class="n">m_1</span> <span class="o">:=</span> <span class="err">?</span><span class="n">m_2</span><span class="err">·µí·µñ</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="n">assign</span><span class="o">:</span> <span class="err">?</span><span class="n">m_1</span> <span class="o">:=</span> <span class="err">?</span><span class="n">m_2</span><span class="err">·µí·µñ</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="n">process_assignment</span> <span class="err">?</span><span class="n">m_1</span> <span class="o">:=</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">opposite</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="o">[</span><span class="mi">2</span><span class="o">]:</span> <span class="n">category</span> <span class="err">?</span><span class="n">m_1</span> <span class="bp">=</span><span class="err">?</span><span class="bp">=</span> <span class="n">category</span> <span class="err">?</span><span class="n">m_2</span><span class="err">·µí·µñ</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="o">[</span><span class="mi">3</span><span class="o">]:</span> <span class="n">category</span> <span class="bp">=</span><span class="err">?</span><span class="bp">=</span> <span class="n">category</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="n">assign</span><span class="o">:</span> <span class="err">?</span><span class="n">m_1</span> <span class="o">:=</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">opposite</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="n">process_assignment</span> <span class="err">?</span><span class="n">m_1</span> <span class="o">:=</span> <span class="kt">Type</span> <span class="err">?</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="n">assign</span><span class="o">:</span> <span class="err">?</span><span class="n">m_1</span> <span class="o">:=</span> <span class="kt">Type</span> <span class="err">?</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="n">process_assignment</span> <span class="err">?</span><span class="n">m_1</span> <span class="o">:=</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">types</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="o">[</span><span class="mi">2</span><span class="o">]:</span> <span class="n">category</span> <span class="err">?</span><span class="n">m_1</span> <span class="bp">=</span><span class="err">?</span><span class="bp">=</span> <span class="n">large_category</span> <span class="o">(</span><span class="kt">Type</span> <span class="err">?</span><span class="o">)</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="n">unfold</span> <span class="n">right</span><span class="o">:</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">large_category</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="o">[</span><span class="mi">3</span><span class="o">]:</span> <span class="n">category</span> <span class="err">?</span><span class="n">m_1</span> <span class="bp">=</span><span class="err">?</span><span class="bp">=</span> <span class="n">category</span> <span class="o">(</span><span class="kt">Type</span> <span class="err">?</span><span class="o">)</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="o">[</span><span class="mi">4</span><span class="o">]:</span> <span class="n">category</span> <span class="bp">=</span><span class="err">?</span><span class="bp">=</span> <span class="n">category</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="n">assign</span><span class="o">:</span> <span class="err">?</span><span class="n">m_1</span> <span class="o">:=</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">types</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="n">process_assignment</span> <span class="err">?</span><span class="n">m_1</span> <span class="o">:=</span> <span class="n">presheaf</span> <span class="n">X</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="n">assign</span><span class="o">:</span> <span class="err">?</span><span class="n">m_1</span> <span class="o">:=</span> <span class="n">presheaf</span> <span class="n">X</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="n">process_assignment</span> <span class="err">?</span><span class="n">m_1</span> <span class="o">:=</span> <span class="n">F</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="n">assign</span><span class="o">:</span> <span class="err">?</span><span class="n">m_1</span> <span class="o">:=</span> <span class="n">F</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="o">[</span><span class="mi">1</span><span class="o">]:</span> <span class="n">presheaf</span> <span class="n">X</span><span class="err">·µí·µñ</span> <span class="err">‚•§</span> <span class="kt">Type</span> <span class="err">?</span> <span class="bp">=</span><span class="err">?</span><span class="bp">=</span> <span class="err">?</span><span class="n">m_2</span> <span class="err">‚•§</span> <span class="err">?</span><span class="n">m_4</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="o">[</span><span class="mi">2</span><span class="o">]:</span> <span class="n">functor</span> <span class="bp">=</span><span class="err">?</span><span class="bp">=</span> <span class="n">functor</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="o">[</span><span class="mi">2</span><span class="o">]:</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">opposite</span> <span class="bp">=</span><span class="err">?</span><span class="bp">=</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">opposite</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="o">[</span><span class="mi">2</span><span class="o">]:</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">types</span> <span class="bp">=</span><span class="err">?</span><span class="bp">=</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">types</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="n">on</span> <span class="n">failure</span><span class="o">:</span> <span class="n">presheaf</span> <span class="n">X</span><span class="err">·µí·µñ</span> <span class="err">‚•§</span> <span class="kt">Type</span> <span class="err">?</span> <span class="bp">=</span><span class="err">?</span><span class="bp">=</span> <span class="err">?</span><span class="n">m_2</span> <span class="err">‚•§</span> <span class="err">?</span><span class="n">m_4</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="n">process_assignment</span> <span class="err">?</span><span class="n">m_1</span> <span class="o">:=</span> <span class="n">presheaf</span><span class="bp">.</span><span class="n">category_theory</span><span class="bp">.</span><span class="n">category</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="o">[</span><span class="mi">1</span><span class="o">]:</span> <span class="n">category</span> <span class="err">?</span><span class="n">m_1</span> <span class="bp">=</span><span class="err">?</span><span class="bp">=</span> <span class="n">category</span> <span class="o">(</span><span class="n">presheaf</span> <span class="n">X</span><span class="o">)</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="o">[</span><span class="mi">2</span><span class="o">]:</span> <span class="n">category</span> <span class="bp">=</span><span class="err">?</span><span class="bp">=</span> <span class="n">category</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="n">assign</span><span class="o">:</span> <span class="err">?</span><span class="n">m_1</span> <span class="o">:=</span> <span class="n">presheaf</span><span class="bp">.</span><span class="n">category_theory</span><span class="bp">.</span><span class="n">category</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="o">[</span><span class="mi">1</span><span class="o">]:</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">types</span> <span class="bp">=</span><span class="err">?</span><span class="bp">=</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">types</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="o">[</span><span class="mi">1</span><span class="o">]:</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">opposite</span> <span class="bp">=</span><span class="err">?</span><span class="bp">=</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">opposite</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="n">process_assignment</span> <span class="err">?</span><span class="n">x_1</span> <span class="o">:=</span> <span class="n">presheaf</span> <span class="n">X</span><span class="err">·µí·µñ</span> <span class="err">‚•§</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="n">assign</span><span class="o">:</span> <span class="err">?</span><span class="n">x_1</span> <span class="o">:=</span> <span class="n">presheaf</span> <span class="n">X</span><span class="err">·µí·µñ</span> <span class="err">‚•§</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="n">process_assignment</span> <span class="err">?</span><span class="n">x_0</span> <span class="o">:=</span> <span class="n">presheaf</span> <span class="n">X</span><span class="err">·µí·µñ</span> <span class="err">‚•§</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span>
<span class="o">[</span><span class="n">type_context</span><span class="bp">.</span><span class="n">is_def_eq_detail</span><span class="o">]</span> <span class="n">assign</span><span class="o">:</span> <span class="err">?</span><span class="n">x_0</span> <span class="o">:=</span> <span class="n">presheaf</span> <span class="n">X</span><span class="err">·µí·µñ</span> <span class="err">‚•§</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span>
</pre></div>

<a name="155164531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/error%3A%20expected%20type%20equals%20given%20type/near/155164531" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57599errorexpectedtypeequalsgiventype.html#155164531">Mario Carneiro (Jan 15 2019 at 23:14)</a>:</h4>
<p>what does <code>convert yoneda F</code> give?</p>

<a name="155164556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/error%3A%20expected%20type%20equals%20given%20type/near/155164556" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57599errorexpectedtypeequalsgiventype.html#155164556">Johan Commelin (Jan 15 2019 at 23:14)</a>:</h4>
<p>The error is in a <code>have</code> statement...</p>
<div class="codehilite"><pre><span></span><span class="k">have</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">functor</span><span class="bp">.</span><span class="n">on_iso</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="n">yoneda</span><span class="bp">.</span><span class="n">obj</span> <span class="n">F</span><span class="o">),</span>
</pre></div>

<a name="155164575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/error%3A%20expected%20type%20equals%20given%20type/near/155164575" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57599errorexpectedtypeequalsgiventype.html#155164575">Mario Carneiro (Jan 15 2019 at 23:15)</a>:</h4>
<p>can you fill in the underscores?</p>

<a name="155164579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/error%3A%20expected%20type%20equals%20given%20type/near/155164579" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57599errorexpectedtypeequalsgiventype.html#155164579">Johan Commelin (Jan 15 2019 at 23:15)</a>:</h4>
<p>I'll try. Give me a second.</p>

<a name="155164640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/error%3A%20expected%20type%20equals%20given%20type/near/155164640" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57599errorexpectedtypeequalsgiventype.html#155164640">Mario Carneiro (Jan 15 2019 at 23:16)</a>:</h4>
<p>also your <code>op</code> has a really confusing precedence</p>

<a name="155164651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/error%3A%20expected%20type%20equals%20given%20type/near/155164651" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57599errorexpectedtypeequalsgiventype.html#155164651">Mario Carneiro (Jan 15 2019 at 23:16)</a>:</h4>
<p>there is no way lean can parse <code>presheaf X·µí·µñ</code> means <code>(presheaf X)·µí·µñ</code> but the printer seems to think so</p>

<a name="155164673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/error%3A%20expected%20type%20equals%20given%20type/near/155164673" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57599errorexpectedtypeequalsgiventype.html#155164673">Johan Commelin (Jan 15 2019 at 23:17)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="k">have</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">functor</span><span class="bp">.</span><span class="n">on_iso</span> <span class="o">((</span><span class="n">presheaf</span> <span class="n">X</span><span class="o">)</span><span class="err">·µí·µñ</span><span class="o">)</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="n">yoneda</span><span class="bp">.</span><span class="n">obj</span> <span class="n">F</span><span class="o">),</span>
</pre></div>


<p>Wow... this works...</p>

<a name="155165054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/error%3A%20expected%20type%20equals%20given%20type/near/155165054" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57599errorexpectedtypeequalsgiventype.html#155165054">Reid Barton (Jan 15 2019 at 23:24)</a>:</h4>
<blockquote>
<p>there is no way lean can parse <code>presheaf X·µí·µñ</code> means <code>(presheaf X)·µí·µñ</code> but the printer seems to think so</p>
</blockquote>
<p>I thought this was actually possible by using a precedence above 1000?</p>

<a name="155165061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/error%3A%20expected%20type%20equals%20given%20type/near/155165061" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57599errorexpectedtypeequalsgiventype.html#155165061">Reid Barton (Jan 15 2019 at 23:25)</a>:</h4>
<p>I was wondering whether we should do that</p>

<a name="155165111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/error%3A%20expected%20type%20equals%20given%20type/near/155165111" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57599errorexpectedtypeequalsgiventype.html#155165111">Mario Carneiro (Jan 15 2019 at 23:26)</a>:</h4>
<p>I think you want high precedence (above <code>max = 1024</code>) to get <code>presheaf X·µí·µñ</code> = <code>presheaf (X·µí·µñ)</code></p>

<a name="155165174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/error%3A%20expected%20type%20equals%20given%20type/near/155165174" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57599errorexpectedtypeequalsgiventype.html#155165174">Reid Barton (Jan 15 2019 at 23:27)</a>:</h4>
<p>Oh, I misread</p>

<a name="155165181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/error%3A%20expected%20type%20equals%20given%20type/near/155165181" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57599errorexpectedtypeequalsgiventype.html#155165181">Reid Barton (Jan 15 2019 at 23:27)</a>:</h4>
<p>What you just wrote is what I want</p>

<a name="155165245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/error%3A%20expected%20type%20equals%20given%20type/near/155165245" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57599errorexpectedtypeequalsgiventype.html#155165245">Mario Carneiro (Jan 15 2019 at 23:28)</a>:</h4>
<p>most postfix notations are at precedence <code>:max+1</code> for this reason</p>

<a name="155165251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/error%3A%20expected%20type%20equals%20given%20type/near/155165251" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57599errorexpectedtypeequalsgiventype.html#155165251">Kevin Buzzard (Jan 15 2019 at 23:28)</a>:</h4>
<p>Has this fixed the error Johan?</p>

<a name="155165253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/error%3A%20expected%20type%20equals%20given%20type/near/155165253" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57599errorexpectedtypeequalsgiventype.html#155165253">Reid Barton (Jan 15 2019 at 23:28)</a>:</h4>
<p>I'm not really sure how it works now actually. But I know there are a lot of parentheses in <code>category_theory</code> that look like they ought to be unnecessary</p>

<a name="155165266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/error%3A%20expected%20type%20equals%20given%20type/near/155165266" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57599errorexpectedtypeequalsgiventype.html#155165266">Mario Carneiro (Jan 15 2019 at 23:28)</a>:</h4>
<p>I doubt it addresses the error though, I'm still perplexed</p>

<a name="155165294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/error%3A%20expected%20type%20equals%20given%20type/near/155165294" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57599errorexpectedtypeequalsgiventype.html#155165294">Mario Carneiro (Jan 15 2019 at 23:29)</a>:</h4>
<p>it seems like it's an elaboration order issue</p>

<a name="155165388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/error%3A%20expected%20type%20equals%20given%20type/near/155165388" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57599errorexpectedtypeequalsgiventype.html#155165388">Mario Carneiro (Jan 15 2019 at 23:31)</a>:</h4>
<p>what's up with this name? <code>category_theory.presheaf.category_theory.category</code></p>

<a name="155165394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/error%3A%20expected%20type%20equals%20given%20type/near/155165394" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57599errorexpectedtypeequalsgiventype.html#155165394">Mario Carneiro (Jan 15 2019 at 23:31)</a>:</h4>
<p>just in case you forgot it's about categories</p>

<a name="155165589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/error%3A%20expected%20type%20equals%20given%20type/near/155165589" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57599errorexpectedtypeequalsgiventype.html#155165589">Reid Barton (Jan 15 2019 at 23:35)</a>:</h4>
<p>Just wait until we have the category of categories</p>

<a name="155165640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/error%3A%20expected%20type%20equals%20given%20type/near/155165640" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57599errorexpectedtypeequalsgiventype.html#155165640">Reid Barton (Jan 15 2019 at 23:36)</a>:</h4>
<p>or the category of theories</p>

<a name="155165686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/error%3A%20expected%20type%20equals%20given%20type/near/155165686" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57599errorexpectedtypeequalsgiventype.html#155165686">Chris Hughes (Jan 15 2019 at 23:37)</a>:</h4>
<blockquote>
<p>or the category of theories</p>
</blockquote>
<p>Is that a thing?</p>

<a name="155165751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/error%3A%20expected%20type%20equals%20given%20type/near/155165751" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57599errorexpectedtypeequalsgiventype.html#155165751">Johan Commelin (Jan 15 2019 at 23:39)</a>:</h4>
<p>I still don't understand the error.<br>
But I no longer need a solution, because I proved it differently.</p>

<a name="155165758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/error%3A%20expected%20type%20equals%20given%20type/near/155165758" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57599errorexpectedtypeequalsgiventype.html#155165758">Johan Commelin (Jan 15 2019 at 23:39)</a>:</h4>
<p>It's just weird that this shows up. And like I said: Reid and I had a similar thing last week when we worked with over categories.</p>

<a name="155165860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/error%3A%20expected%20type%20equals%20given%20type/near/155165860" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57599errorexpectedtypeequalsgiventype.html#155165860">Mario Carneiro (Jan 15 2019 at 23:41)</a>:</h4>
<blockquote>
<p>is that a thing?</p>
</blockquote>
<p>Sure, you can use interpretations as morphisms between theories even with different languages</p>

<a name="155247432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/error%3A%20expected%20type%20equals%20given%20type/near/155247432" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57599errorexpectedtypeequalsgiventype.html#155247432">Reid Barton (Jan 16 2019 at 22:48)</a>:</h4>
<blockquote>
<p>I think you want high precedence (above <code>max = 1024</code>) to get <code>presheaf X·µí·µñ</code> = <code>presheaf (X·µí·µñ)</code></p>
</blockquote>
<p>Implemented at <a href="https://github.com/leanprover/mathlib/pull/600" target="_blank" title="https://github.com/leanprover/mathlib/pull/600">https://github.com/leanprover/mathlib/pull/600</a> (<span class="user-mention" data-user-id="112680">@Johan Commelin</span> FYI)</p>

<a name="155248248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/error%3A%20expected%20type%20equals%20given%20type/near/155248248" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57599errorexpectedtypeequalsgiventype.html#155248248">Johan Commelin (Jan 16 2019 at 23:04)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> Thanks!</p>


{% endraw %}
