---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/62193tacticquestion.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html">tactic question</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="168134039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168134039" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168134039">Neil Strickland (Jun 14 2019 at 13:19)</a>:</h4>
<p>If I have <code>h : i = j ∨ k = l</code>, I might do <code>rcases h with rfl | rfl</code>.  If I have <code>h : i = j ∨ k = l  ∨ p = q</code>, I might do <code>rcases h with rfl | rfl | rfl</code>.  Now suppose I want to handle a large number of goals in parallel, each of which has an <code>h</code> as before, but with varying numbers of equations or'd together.  What is a tidy way to apply <code>rcases</code> with the right number of <code>rfl</code>'s in each goal?</p>

<a name="168134972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168134972" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168134972">Patrick Massot (Jun 14 2019 at 13:31)</a>:</h4>
<p>Indeed it would be nice to have a more automatic <code>rcases</code></p>

<a name="168135925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168135925" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168135925">Kevin Kappelmann (Jun 14 2019 at 13:44)</a>:</h4>
<p>Maybe use the <code>repeat</code> combinator?</p>

<a name="168136437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168136437" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168136437">Neil Strickland (Jun 14 2019 at 13:50)</a>:</h4>
<p>I tried <code>repeat { rcases h with rfl | _ }</code> but that did not work.  Perhaps some other variant would work, but I could not find one.</p>

<a name="168136463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168136463" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168136463">Johan Commelin (Jun 14 2019 at 13:51)</a>:</h4>
<p>You might have to explicitly call the second argument <code>h</code>, instead of <code>_</code>.</p>

<a name="168136472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168136472" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168136472">Johan Commelin (Jun 14 2019 at 13:51)</a>:</h4>
<p>Otherwise <code>rcases</code> might generate the wrong name.</p>

<a name="168137556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168137556" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168137556">Kevin Kappelmann (Jun 14 2019 at 14:04)</a>:</h4>
<p>I am a bit confused, by the way, about the <code>with rfl</code> part. I thought you'd need to write something like<br>
<code>repeat {cases h}; rfl</code></p>

<a name="168137617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168137617" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168137617">Neil Strickland (Jun 14 2019 at 14:05)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span>  Yes, that was the problem, thanks</p>

<a name="168137958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168137958" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168137958">Neil Strickland (Jun 14 2019 at 14:09)</a>:</h4>
<p><span class="user-mention" data-user-id="198376">@Kevin Kappelmann</span>  If <code>h : i = j</code> then <code>rcases h with rfl</code> will "specialise to the case where <code>h</code> is <code>rfl : i = i</code>" and so will remove change <code>j</code> to <code>i</code> in all hypotheses and in the goal.  Similarly, if <code>h : i = j ∨ i = k</code> then  <code>rcases h with rfl | rfl</code> will give two new goals, one will all <code>j</code>'s changed to <code>i</code>, and one with all <code>k</code>'s changed to <code>i</code>.</p>

<a name="168139042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168139042" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168139042">Kevin Kappelmann (Jun 14 2019 at 14:22)</a>:</h4>
<p>Ohhh, alright - thanks for explaining! :)</p>

<a name="168139335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168139335" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168139335">Wojciech Nawrocki (Jun 14 2019 at 14:26)</a>:</h4>
<p>Hello! This is a question about tactics also - is <code>ring</code> the only tactic for resolving equalities in an algebraic structure? Would something similar for other structures be considered useful or is <code>simp</code> good enough?</p>

<a name="168139879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168139879" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168139879">Patrick Massot (Jun 14 2019 at 14:32)</a>:</h4>
<p>There is also <code>abel</code>, and any other one would be very useful</p>

<a name="168142662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168142662" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168142662">Sebastien Gouezel (Jun 14 2019 at 15:03)</a>:</h4>
<p>Is there any tactic yet that could do</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="n">u</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">s</span> <span class="err">∩</span> <span class="o">(</span><span class="n">t</span> <span class="err">∩</span> <span class="n">u</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">s</span> <span class="err">∩</span> <span class="n">t</span><span class="o">)</span> <span class="err">∩</span> <span class="o">(</span><span class="n">s</span> <span class="err">∩</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">by</span> <span class="o">{</span> <span class="n">ext</span> <span class="n">x</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="n">split</span><span class="bp">;</span> <span class="n">finish</span> <span class="o">}</span>
</pre></div>


<p>This proof is quick to come up with, but slow. I could also come up with the right sequence of rewrites, which would be much faster, but my time is too precious for this :)</p>

<a name="168151569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168151569" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168151569">Simon Hudon (Jun 14 2019 at 16:45)</a>:</h4>
<p>Does <code>casesm</code>help at all? <a href="https://github.com/leanprover-community/lean/blob/master/library/init/meta/interactive.lean#L773" target="_blank" title="https://github.com/leanprover-community/lean/blob/master/library/init/meta/interactive.lean#L773">https://github.com/leanprover-community/lean/blob/master/library/init/meta/interactive.lean#L773</a></p>

<a name="168154217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168154217" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168154217">Wojciech Nawrocki (Jun 14 2019 at 17:17)</a>:</h4>
<p>Regarding ring, is it more or less accurate that <code>ring</code> runs faster than <code>ring2</code>, but <code>ring2</code> generates much smaller proof terms thanks to reflection and is therefore better for large expressions?</p>

<a name="168271152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168271152" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168271152">Mario Carneiro (Jun 16 2019 at 22:56)</a>:</h4>
<p>Generally speaking, the "smaller proof term" heuristic for complexity breaks down in the presence of "heavy rfls"</p>

<a name="168356828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168356828" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168356828">Wojciech Nawrocki (Jun 17 2019 at 23:28)</a>:</h4>
<p>What do you mean by <em>heavy rfls</em>? Is it that the normalizing procedure over the reflected expression has to take many steps and so does the kernel to decide judgmental eq., or something else?</p>

<a name="168356939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168356939" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168356939">Mario Carneiro (Jun 17 2019 at 23:30)</a>:</h4>
<p>Definitional equality is a large and complicated judgment. Normally we don't stress it too much, we just unfold a definition here or a beta reduction there. By "heavy rfl" I mean something with many steps of definitional reduction, comparable to the size of the entire rest of the proof term or even much much larger</p>

<a name="168357022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168357022" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168357022">Wojciech Nawrocki (Jun 17 2019 at 23:32)</a>:</h4>
<p>Okay, I think that's what I meant. So when you have that, you end up with a very small proof term which also happens to require a really large computation to typecheck, right?</p>

<a name="168357029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168357029" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168357029">Mario Carneiro (Jun 17 2019 at 23:32)</a>:</h4>
<p>right</p>

<a name="168357039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168357039" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168357039">Mario Carneiro (Jun 17 2019 at 23:32)</a>:</h4>
<p>and doing that computation in the kernel is not necessarily the best idea</p>

<a name="168357062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168357062" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168357062">Wojciech Nawrocki (Jun 17 2019 at 23:33)</a>:</h4>
<p>Okay, I think when saying ".. better for large expressions" I should've really said "better in terms of proof size", but not necessarily better in terms of <code>time lean --make</code>.</p>

<a name="168357078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168357078" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168357078">Mario Carneiro (Jun 17 2019 at 23:33)</a>:</h4>
<p>Most of the time, the length of the typing derivation is proportional to the size of the proof term, but heavy rfls break that comparison</p>

<a name="168357128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168357128" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168357128">Mario Carneiro (Jun 17 2019 at 23:34)</a>:</h4>
<p>In such cases it really is more accurate to measure the length of the typing derivation</p>

<a name="168357172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168357172" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168357172">Mario Carneiro (Jun 17 2019 at 23:35)</a>:</h4>
<p>To me, "proof size" means size of typing derivation, because that correlates to wall time</p>

<a name="168357229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168357229" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168357229">Mario Carneiro (Jun 17 2019 at 23:36)</a>:</h4>
<p>it is far too easy to write "short proofs" of every statement imaginable by doing a proof search in the kernel</p>

<a name="168357240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168357240" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168357240">Wojciech Nawrocki (Jun 17 2019 at 23:36)</a>:</h4>
<p>By typing derivation you mean the time it takes for the kernel to typecheck the term, but not elaboration/inference etc time?</p>

<a name="168357242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168357242" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168357242">Mario Carneiro (Jun 17 2019 at 23:36)</a>:</h4>
<p>yes</p>

<a name="168357275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168357275" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168357275">Mario Carneiro (Jun 17 2019 at 23:37)</a>:</h4>
<p>the other stuff is engineering challenges, and also it's a one time cost, at least in principle. The kernel typechecking is mandatory for correctness</p>

<a name="168357420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168357420" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168357420">Wojciech Nawrocki (Jun 17 2019 at 23:40)</a>:</h4>
<p>Right, but if a reflection tactic generates <em>heavy rfls</em> which take less time to check than an equivalent sequence of <code>eq.subst</code> or some such would, then it would still be preferrable?</p>

<a name="168357425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168357425" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168357425">Mario Carneiro (Jun 17 2019 at 23:40)</a>:</h4>
<p>yes</p>

<a name="168357439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168357439" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168357439">Mario Carneiro (Jun 17 2019 at 23:41)</a>:</h4>
<p>That's why I wrote <code>ring</code> and <code>ring2</code></p>

<a name="168357444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168357444" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168357444">Mario Carneiro (Jun 17 2019 at 23:41)</a>:</h4>
<p>because it wasn't obvious which method is faster in practice</p>

<a name="168357503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168357503" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168357503">Mario Carneiro (Jun 17 2019 at 23:42)</a>:</h4>
<p>but the kernel is not very optimized, in order to keep code size down, and it has to unfold many things because it doesn't exactly know where to go</p>

<a name="168357509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168357509" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168357509">Mario Carneiro (Jun 17 2019 at 23:42)</a>:</h4>
<p>with a proof term you can expose the kernel to only those things it needs to know</p>

<a name="168357579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168357579" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168357579">Mario Carneiro (Jun 17 2019 at 23:44)</a>:</h4>
<p>basically, you have a lot more control with a proof term than with a rfl proof</p>

<a name="168357829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168357829" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168357829">Wojciech Nawrocki (Jun 17 2019 at 23:50)</a>:</h4>
<p>With a rfl proof, could you not write your decision procedure in a way that makes it easy to reduce for the kernel?</p>

<a name="168358028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168358028" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168358028">Mario Carneiro (Jun 17 2019 at 23:55)</a>:</h4>
<p>yes you can, and it's pretty important that you do</p>

<a name="168358033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168358033" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168358033">Mario Carneiro (Jun 17 2019 at 23:55)</a>:</h4>
<p>but there is still the matter of the O(1) constant</p>

<a name="168358093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168358093" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168358093">Mario Carneiro (Jun 17 2019 at 23:56)</a>:</h4>
<p>and the only way to really find that out is to profile it</p>

<a name="168358127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168358127" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168358127">Mario Carneiro (Jun 17 2019 at 23:57)</a>:</h4>
<p>I think even just using the equation compiler to define, say, functions on lists is bad for the kernel</p>

<a name="168358139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168358139" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168358139">Mario Carneiro (Jun 17 2019 at 23:57)</a>:</h4>
<p>not that bad, but measurable</p>

<a name="168359137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168359137" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168359137">Wojciech Nawrocki (Jun 18 2019 at 00:18)</a>:</h4>
<p>I see</p>

<a name="168512360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168512360" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168512360">Wojciech Nawrocki (Jun 19 2019 at 14:37)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Is there any documentation/paper explaining what the purpose of <a href="https://github.com/leanprover-community/mathlib/blob/master/src/tactic/abel.lean#L13" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/src/tactic/abel.lean#L13">the cache in abel</a> is?</p>

<a name="168554009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168554009" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168554009">Mario Carneiro (Jun 19 2019 at 23:22)</a>:</h4>
<p>It's a bunch of info I want to inject into the proof term at various points without recomputing all the time. So I need the base type, the level of that type for constants, the zero constant because that comes up a lot, and the instance of either <code>add_comm_monoid</code> or <code>add_comm_group</code> (whichever it was able to find). This data can be calculated just from the type, which we find as soon as we start entering the term, and that means we can avoid almost all uses of <code>mk_app</code>, which tends to be unpredictably slow sometimes (see also the recent bug in <a href="#narrow/stream/116395-maths/topic/witt.20vectors" title="#narrow/stream/116395-maths/topic/witt.20vectors">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/witt.20vectors</a> ).</p>

<a name="168555193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168555193" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168555193">Wojciech Nawrocki (Jun 19 2019 at 23:48)</a>:</h4>
<p>Thanks!</p>

<a name="168608384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168608384" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168608384">Wojciech Nawrocki (Jun 20 2019 at 15:55)</a>:</h4>
<p>Is there a better notation for doing something on failure of a tactic match than</p>
<div class="codehilite"><pre><span></span><span class="o">(</span><span class="n">do</span> <span class="n">x</span> <span class="bp">&lt;-</span> <span class="n">t</span><span class="o">,</span>
  <span class="n">next_t</span><span class="o">)</span> <span class="bp">&lt;|&gt;</span> <span class="n">on_fail_t</span>
</pre></div>


<p>? It gets ugly quickly with multiple nested matches and failure handlers. Ideally something local like <code>do (x &lt;- t) except on_fail_t, next_t,</code>.</p>

<a name="168616436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/168616436" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#168616436">Wojciech Nawrocki (Jun 20 2019 at 17:35)</a>:</h4>
<p>Found it, it's just</p>
<div class="codehilite"><pre><span></span><span class="n">do</span>
  <span class="bp">`</span><span class="o">(</span><span class="n">some_expr</span><span class="o">)</span> <span class="bp">&lt;-</span> <span class="n">t</span>
  <span class="bp">|</span> <span class="n">on_fail_t</span><span class="o">,</span>
</pre></div>

<a name="170999997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/170999997" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#170999997">Wojciech Nawrocki (Jul 16 2019 at 15:55)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> is there any particular reason for using a custom <code>tree</code> instead of <code>rbnode</code> in <code>ring2</code>? (The <code>pos_num</code> indexing stuff could be added if <code>rbnode</code> doesn't have it already.)</p>

<a name="171010679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/171010679" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#171010679">Mario Carneiro (Jul 16 2019 at 17:58)</a>:</h4>
<p>The red-black tree implementation in core is broken,, so I try to use it as little as possible. Also it's important that the kernel compute with it well, so extraneous rebalancing code would be not good. All the rbnode handling happens in the VM, the kernel only sees <code>tree</code>.</p>

<a name="171011090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/171011090" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#171011090">Wojciech Nawrocki (Jul 16 2019 at 18:02)</a>:</h4>
<p>Oh I see, in what way is it broken? I think w.r.t. rebalancing it would be fine, because the rebalancing only happens on tree modifications, but neither normalization in <code>of_csexpr</code>, nor <code>eval</code>/<code>cseval</code> modify the tree.</p>

<a name="171011179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/171011179" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#171011179">Mario Carneiro (Jul 16 2019 at 18:03)</a>:</h4>
<p>It's still a more complicated recursive function since there are more cases</p>

<a name="171011281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/171011281" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#171011281">Mario Carneiro (Jul 16 2019 at 18:04)</a>:</h4>
<p>You can't erase from an <code>rbtree</code></p>

<a name="171011326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/171011326" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#171011326">Mario Carneiro (Jul 16 2019 at 18:04)</a>:</h4>
<p>because the red black invariant is wrong</p>

<a name="171015269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/171015269" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#171015269">Wojciech Nawrocki (Jul 16 2019 at 18:45)</a>:</h4>
<p>?! Do you mean it doesn't maintain the invariant, or it maintains the wrong invariant, or ..?</p>

<a name="171020547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/171020547" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#171020547">Mario Carneiro (Jul 16 2019 at 19:44)</a>:</h4>
<p>It maintains the wrong invariant. The actual red black invariant is not defined; instead it does the lazy thing and says "whatever you can get to by applying insert to empty" which is obviously sufficient to get insert and empty but basically nothing else</p>

<a name="171023629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/171023629" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#171023629">Wojciech Nawrocki (Jul 16 2019 at 20:21)</a>:</h4>
<p>So it is not defined, but are you also saying that "being a red-black tree" is actually dynamically broken, e.g. a <code>red_node</code> appears directly as the child of a <code>red_node</code> or some such? Or just that it doesn't maintain a proof of the right "being red-black" proposition (since <code>well_formed</code> is defined as "either a leaf or the result of <code>insert</code> on a well-formed tree" rather than "meets all the rbtree requirements")?</p>

<a name="171026496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/171026496" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#171026496">Mario Carneiro (Jul 16 2019 at 20:54)</a>:</h4>
<p>The red-black property is maintained, but this is not proven</p>

<a name="171026562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/171026562" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#171026562">Mario Carneiro (Jul 16 2019 at 20:55)</a>:</h4>
<p>The current definition of <code>well_formed</code> is not equivalent to the red black property, but implies it</p>

<a name="171026658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/171026658" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#171026658">Mario Carneiro (Jul 16 2019 at 20:56)</a>:</h4>
<p>But because of the over-strict well formedness predicate, you can't define anything on these red black trees other than insert and empty</p>

<a name="171061393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/171061393" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#171061393">Patrick Massot (Jul 17 2019 at 09:15)</a>:</h4>
<p>I don't really remember what is an rb-tree but I remember this came up last summer. See <a href="#narrow/stream/113488-general/topic/Ed's.20question.20barrage" title="#narrow/stream/113488-general/topic/Ed's.20question.20barrage">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Ed's.20question.20barrage</a> and <a href="#narrow/stream/113488-general/topic/using_well_founded" title="#narrow/stream/113488-general/topic/using_well_founded">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/using_well_founded</a></p>

<a name="171164645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/171164645" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#171164645">Wojciech Nawrocki (Jul 18 2019 at 12:30)</a>:</h4>
<p>I see what you mean now Mario, thanks a bunch for explaining! In that case it does make sense to use a custom <code>tree</code>. <br>
Thanks Patrick for the links - it does look like those discussions were partly about the same problem - I should have searched harder, sorry!</p>

<a name="171858775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/171858775" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#171858775">Wojciech Nawrocki (Jul 27 2019 at 20:22)</a>:</h4>
<p>While a term and its reduced form are equivalent in the type theory, they are not so syntactically. This matters if I want to compare <code>expr</code>s syntactically in a tactic. My question: is there a builtin/way to reduce an <code>expr</code> to normal form?</p>

<a name="171859446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/171859446" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#171859446">Andrew Ashworth (Jul 27 2019 at 20:45)</a>:</h4>
<p><code>whnf</code></p>

<a name="171861315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tactic%20question/near/171861315" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/62193tacticquestion.html#171861315">Wojciech Nawrocki (Jul 27 2019 at 21:45)</a>:</h4>
<p>Nice, there are also a bunch of others like <code>head_beta</code> next to it. Thanks!</p>


{% endraw %}

{% include archive_update.html %}