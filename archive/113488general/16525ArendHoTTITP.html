---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/16525ArendHoTTITP.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/16525ArendHoTTITP.html">Arend — HoTT ITP</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="172653009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Arend%20%E2%80%94%20HoTT%20ITP/near/172653009" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/16525ArendHoTTITP.html#172653009">Johan Commelin (Aug 07 2019 at 06:14)</a>:</h4>
<p><a href="https://arend-lang.github.io/2019/07/17/Arend-1.0.0-released.html" target="_blank" title="https://arend-lang.github.io/2019/07/17/Arend-1.0.0-released.html">https://arend-lang.github.io/2019/07/17/Arend-1.0.0-released.html</a></p>

<a name="172654644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Arend%20%E2%80%94%20HoTT%20ITP/near/172654644" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/16525ArendHoTTITP.html#172654644">Johan Commelin (Aug 07 2019 at 06:57)</a>:</h4>
<p>From my first glimpse it seems they have no bundling issues: <a href="https://arend-lang.github.io/about/arend-features#anonymous-extensions" target="_blank" title="https://arend-lang.github.io/about/arend-features#anonymous-extensions">https://arend-lang.github.io/about/arend-features#anonymous-extensions</a></p>

<a name="172654692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Arend%20%E2%80%94%20HoTT%20ITP/near/172654692" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/16525ArendHoTTITP.html#172654692">Johan Commelin (Aug 07 2019 at 06:58)</a>:</h4>
<p>Of course I can't say anything about speed.</p>

<a name="172654713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Arend%20%E2%80%94%20HoTT%20ITP/near/172654713" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/16525ArendHoTTITP.html#172654713">Johan Commelin (Aug 07 2019 at 06:59)</a>:</h4>
<p>Universes are cumulative</p>

<a name="172654752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Arend%20%E2%80%94%20HoTT%20ITP/near/172654752" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/16525ArendHoTTITP.html#172654752">Johan Commelin (Aug 07 2019 at 07:00)</a>:</h4>
<p>It's HoTT, so it has transport</p>

<a name="172654794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Arend%20%E2%80%94%20HoTT%20ITP/near/172654794" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/16525ArendHoTTITP.html#172654794">Johan Commelin (Aug 07 2019 at 07:01)</a>:</h4>
<p>What!! And <code>\Prop</code> is even impredicative.</p>

<a name="172654797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Arend%20%E2%80%94%20HoTT%20ITP/near/172654797" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/16525ArendHoTTITP.html#172654797">Johan Commelin (Aug 07 2019 at 07:01)</a>:</h4>
<p>Is this thing even consistent?</p>

<a name="172654938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Arend%20%E2%80%94%20HoTT%20ITP/near/172654938" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/16525ArendHoTTITP.html#172654938">Andrew Ashworth (Aug 07 2019 at 07:05)</a>:</h4>
<p>You can always pick 2 of: impredicative Prop, large elimination, and excluded middle</p>

<a name="172654993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Arend%20%E2%80%94%20HoTT%20ITP/near/172654993" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/16525ArendHoTTITP.html#172654993">Johan Commelin (Aug 07 2019 at 07:06)</a>:</h4>
<p>What does "large elimination" mean?</p>

<a name="172655104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Arend%20%E2%80%94%20HoTT%20ITP/near/172655104" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/16525ArendHoTTITP.html#172655104">Andrew Ashworth (Aug 07 2019 at 07:09)</a>:</h4>
<p><a href="https://lean-forward.github.io/logical-verification/2018/41_notes.html" target="_blank" title="https://lean-forward.github.io/logical-verification/2018/41_notes.html">https://lean-forward.github.io/logical-verification/2018/41_notes.html</a></p>

<a name="172655149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Arend%20%E2%80%94%20HoTT%20ITP/near/172655149" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/16525ArendHoTTITP.html#172655149">Andrew Ashworth (Aug 07 2019 at 07:10)</a>:</h4>
<p>there's a section on large elimination in the notes</p>

<a name="172655181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Arend%20%E2%80%94%20HoTT%20ITP/near/172655181" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/16525ArendHoTTITP.html#172655181">Johan Commelin (Aug 07 2019 at 07:11)</a>:</h4>
<p>The list of editor features (Intellij) also looks quite nice: <a href="https://arend-lang.github.io/about/intellij-features" target="_blank" title="https://arend-lang.github.io/about/intellij-features">https://arend-lang.github.io/about/intellij-features</a></p>

<a name="172655185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Arend%20%E2%80%94%20HoTT%20ITP/near/172655185" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/16525ArendHoTTITP.html#172655185">Johan Commelin (Aug 07 2019 at 07:11)</a>:</h4>
<p><span class="user-mention" data-user-id="110025">@Andrew Ashworth</span> Thanks, I'll take a look</p>

<a name="172655406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Arend%20%E2%80%94%20HoTT%20ITP/near/172655406" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/16525ArendHoTTITP.html#172655406">Johan Commelin (Aug 07 2019 at 07:17)</a>:</h4>
<p>As an example of the bundling thing: they have</p>
<div class="codehilite"><pre><span></span>\class Group \extends CancelMonoid {
  | inverse : E -&gt; E
  | inverse-left (x : E) : inverse x * x = ide
| inverse-right (x : E) : x * inverse x = ide
</pre></div>


<p>This allows you to write <code>(X : \Type) (Group X)</code> or <code>(X : Group)</code>, and these two are defeq. At the same time, they can also write</p>
<div class="codehilite"><pre><span></span>\instance GroupCategory : Cat Group
  =&gt; subCat (\new Embedding {
    | f (G : Group) =&gt; \new Monoid G.E G.ide (G.*) G.ide-left G.ide-right G.*-assoc
    | isEmb G H =&gt; \new Retraction {
      | sec =&gt; Group.equals G H
      | f_sec =&gt; idpe
    }
})
</pre></div>


<p>to prove that groups form a category.</p>
<p>There is no distinction between bundled and unbundled objects.</p>

<a name="172655631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Arend%20%E2%80%94%20HoTT%20ITP/near/172655631" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/16525ArendHoTTITP.html#172655631">Johan Commelin (Aug 07 2019 at 07:22)</a>:</h4>
<p><span class="user-mention" data-user-id="110025">@Andrew Ashworth</span> So you gave a pick-2-out-of-3. If I pick impredicative <code>Prop</code> and LEM, then I have to sacrifice large elimination. But do I sacrifice it for <code>Prop</code>, or in general?</p>

<a name="172655665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Arend%20%E2%80%94%20HoTT%20ITP/near/172655665" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/16525ArendHoTTITP.html#172655665">Chris Hughes (Aug 07 2019 at 07:23)</a>:</h4>
<p>I think in general would make your theory a bit useless.</p>

<a name="172655772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Arend%20%E2%80%94%20HoTT%20ITP/near/172655772" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/16525ArendHoTTITP.html#172655772">Johan Commelin (Aug 07 2019 at 07:25)</a>:</h4>
<p>It seems that Arend sacrifices LEM... which is a pity.</p>

<a name="172655850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Arend%20%E2%80%94%20HoTT%20ITP/near/172655850" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/16525ArendHoTTITP.html#172655850">Chris Hughes (Aug 07 2019 at 07:27)</a>:</h4>
<p>I don't understand how large elimination could be consistent.</p>

<a name="172656002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Arend%20%E2%80%94%20HoTT%20ITP/near/172656002" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/16525ArendHoTTITP.html#172656002">Chris Hughes (Aug 07 2019 at 07:30)</a>:</h4>
<p>This would give you a way to "choose" a bijection between types, which gives you em, at least in Lean.</p>

<a name="172656061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Arend%20%E2%80%94%20HoTT%20ITP/near/172656061" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/16525ArendHoTTITP.html#172656061">Chris Hughes (Aug 07 2019 at 07:31)</a>:</h4>
<p>So this HoTT must be weaker in some sense than Lean without choice</p>

<a name="175108784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Arend%20%E2%80%94%20HoTT%20ITP/near/175108784" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/16525ArendHoTTITP.html#175108784">Jason Rute (Sep 06 2019 at 22:27)</a>:</h4>
<p>I've looked into Arend (vs Lean) a bit and here is what I think I've found...</p>

<a name="175108787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Arend%20%E2%80%94%20HoTT%20ITP/near/175108787" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/16525ArendHoTTITP.html#175108787">Jason Rute (Sep 06 2019 at 22:27)</a>:</h4>
<p>I think, just like in Lean, <code>\Prop</code> in Arend is impredicative and does <em>not</em> allow large elimination.  Also, like Lean, the <code>\Type</code> universe levels are predicative and support large elimination.  I see nothing inconsistent about LEM (for <code>\Prop</code>) in Arend, especially since LEM (for propositions) is consistent in other HoTT systems.</p>

<a name="175108794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Arend%20%E2%80%94%20HoTT%20ITP/near/175108794" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/16525ArendHoTTITP.html#175108794">Jason Rute (Sep 06 2019 at 22:27)</a>:</h4>
<p>Indeed, to me, the foundations for Arend seem very similar to those for Lean, but contain more “levels” of types.  An analogy (possibly too simplistic) is that Lean is a logic for propositions (<code>Prop</code>) and sets (<code>Type</code>) while Arend is a logic for propositions (<code>\Prop</code>), sets (<code>\Set</code>), and other higher homotopy spaces/types (<code>\1-Type</code>, <code>\2-Type</code>, …).  This allows univalence since the univalence axiom requires that a type universe (except <code>\Prop</code>) not be a set.</p>

<a name="175108818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Arend%20%E2%80%94%20HoTT%20ITP/near/175108818" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/16525ArendHoTTITP.html#175108818">Jason Rute (Sep 06 2019 at 22:28)</a>:</h4>
<p>Now, in book HoTT, propositions and sets are defined.  (A <em>proposition</em> is a type <code>P</code> for which all pairs of elements are equal, and a <em>set</em> is a type <code>A</code> for which every <code>a = a'</code> is a proposition).  In Arend, however, it seems <code>\Prop</code> and <code>\Set</code> are also built into the type hierarchy.  So if <code>A : \Set</code> and <code>a a' : A</code>, then the type of <code>a = a'</code>  is Prop, judgmentally.  In this way, Arend’s <code>\Prop</code> is similar to Lean’s <code>Prop</code>.</p>

<a name="175108838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Arend%20%E2%80%94%20HoTT%20ITP/near/175108838" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/16525ArendHoTTITP.html#175108838">Jason Rute (Sep 06 2019 at 22:28)</a>:</h4>
<p>In Lean, inductively defined propositions are formed through a special <code>Prop</code>-valued induction.  Similarly, in Arend they are formed by truncating an inductively defined type to <code>\Prop</code>.  So, logical disjunction <code>\/</code> in <code>\Prop</code> would have the same definition as disjoint union <code>+</code> in <code>\Type</code>, except that the former is explicitly truncated to <code>\Prop</code>.  This truncation prevents large elimination.</p>

<a name="175108841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Arend%20%E2%80%94%20HoTT%20ITP/near/175108841" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/16525ArendHoTTITP.html#175108841">Jason Rute (Sep 06 2019 at 22:28)</a>:</h4>
<p>When it comes to classical reasoning, that is where Lean and Arend/HoTT start to differ is subtle ways (that I don’t completely appreciate yet).  HoTT is all about proof relevant reasoning, but proof relevant versions of classical reasoning are not compatible with the univalence axiom.  From the Curry-Howard Isomorphism, the analogy of LEM in <code>Type</code> would be <code>Π α : Type, α + (α -&gt; empty)</code> which contradicts univalence, and would be inconsistent in Arend.  Instead, Arend/HoTT’s version of LEM replaces <code>\Type</code> with <code>\Prop</code>.  In Lean, this is <code>prop_decidable</code>, but using the univalence axiom it is equivalent to the usual propositional LEM <code>Π p : Prop, p ∨ ¬ p</code>).  In Lean, the “type-valued LEM” above is provable via Lean’s choice function, which takes a nonempty type and extracts a value. Arend/HoTT can’t have such a strong choice function.  Instead, in the Arend/HoTT version of AC, all one can do is say is that if a <em>set</em> <code>A</code> is non-empty (proposition) then there exists (proposition) a choice function.  Since “exists” here is a proposition, one can’t directly use that choice function for constructions except inside proofs of propositions.  (Also, in Arend/HoTT there doesn’t propositionally exist one universal choice function, but instead one for each set-indexed family of non-empty sets.)</p>

<a name="175108844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Arend%20%E2%80%94%20HoTT%20ITP/near/175108844" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/16525ArendHoTTITP.html#175108844">Jason Rute (Sep 06 2019 at 22:28)</a>:</h4>
<p>Just like in Lean, in Arend’s version of HoTT, it seems useful to have an impredicative universe <code>\Prop</code> of propositions and predicative universes of other types.  (Arend/HoTT also seems to make it easier to go between arbitrary types and <code>\Prop</code> by either proving that a type is a proposition or by truncating it to one.)  How one uses <code>\Prop</code> seems to me to be a matter of taste, engineering, and philosophy.  Should one lean into constructive, proof relevant mathematics trying to avoid <code>\Prop</code> whenever possible?  Or, like Lean, should one embrace classical mathematics and propositions, adding AC (in the HoTT sense) as an axiom (while still getting univalence!).  (Or is there a “best of both worlds”, where one uses arbitrary types for constructive, proof-relevant reasoning, and AC for classical reasoning in <code>\Prop</code> and <code>\Set</code>, all within the same system?)</p>


{% endraw %}

{% include archive_update.html %}