---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/24709Instanceresolutionfailures.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/24709Instanceresolutionfailures.html">Instance resolution failures</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="175192998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Instance%20resolution%20failures/near/175192998" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/24709Instanceresolutionfailures.html#175192998">Sebastian Ullrich (Sep 08 2019 at 17:46)</a>:</h4>
<p><span class="user-mention" data-user-id="110044">@Chris Hughes</span> </p>
<blockquote>
<p>I made a repository of examples of type class failures in Lean 3. Most of them depend on using some old commit of mathlib. The respository is <a href="https://github.com/ChrisHughes24/type_class" target="_blank" title="https://github.com/ChrisHughes24/type_class">here</a></p>
</blockquote>
<p>Thanks, this is a good first step. If we want to get serious about analyzing and fixing these issues in Lean 4 (I hope nobody expects a solution for Lean 3), it would help tremendously to reduce them to minimized examples in stand-alone files (we want to port mathlib to Lean 4 <em>after</em> fixing these issues after all). If they are already valid Lean 4, even better. We may even want to port them to other systems to analyze their behavior.</p>

<a name="175193324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Instance%20resolution%20failures/near/175193324" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/24709Instanceresolutionfailures.html#175193324">Mario Carneiro (Sep 08 2019 at 17:57)</a>:</h4>
<p>It's not hard to cook up artificial examples, but I thought you wanted real examples</p>

<a name="175193380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Instance%20resolution%20failures/near/175193380" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/24709Instanceresolutionfailures.html#175193380">Mario Carneiro (Sep 08 2019 at 17:58)</a>:</h4>
<p>In short it checks the same typeclass problem many times. This causes issues with looping instances, and exponential worst case behavior on dags</p>

<a name="175199193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Instance%20resolution%20failures/near/175199193" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/24709Instanceresolutionfailures.html#175199193">Sebastian Ullrich (Sep 08 2019 at 20:55)</a>:</h4>
<p>We'd like to have realistic examples, but we'll still need to extract them if we want to test them in Lean 4</p>

<a name="175205903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Instance%20resolution%20failures/near/175205903" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/24709Instanceresolutionfailures.html#175205903">Floris van Doorn (Sep 09 2019 at 00:23)</a>:</h4>
<p>Here is an unrealistic example which shows that diamonds cause an exponential blow-up in the type class inference search:</p>
<div class="codehilite"><pre><span></span><span class="c1">-- Lean 3 code</span>
<span class="kn">set_option</span> <span class="n">old_structure_cmd</span> <span class="n">true</span>
<span class="n">class</span> <span class="n">bottom</span> <span class="o">(</span><span class="n">Î±</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">â„•</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span>
<span class="n">class</span> <span class="n">left</span> <span class="o">(</span><span class="n">Î±</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">â„•</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">bottom</span> <span class="n">Î±</span> <span class="n">n</span>
<span class="n">class</span> <span class="n">right</span> <span class="o">(</span><span class="n">Î±</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">â„•</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">bottom</span> <span class="n">Î±</span> <span class="n">n</span>
<span class="n">class</span> <span class="n">top</span> <span class="o">(</span><span class="n">Î±</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">â„•</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">left</span> <span class="n">Î±</span> <span class="n">n</span><span class="o">,</span> <span class="n">right</span> <span class="n">Î±</span> <span class="n">n</span>


<span class="kn">instance</span> <span class="n">unrealistic_loop</span> <span class="o">(</span><span class="n">Î±</span> <span class="n">n</span><span class="o">)</span> <span class="o">[</span><span class="n">bottom</span> <span class="n">Î±</span> <span class="n">n</span><span class="o">]</span> <span class="o">:</span> <span class="n">top</span> <span class="n">Î±</span> <span class="n">n</span><span class="bp">.</span><span class="n">succ</span> <span class="o">:=</span> <span class="o">{</span> <span class="bp">.._</span><span class="n">inst_1</span> <span class="o">}</span>

<span class="kn">set_option</span> <span class="n">trace</span><span class="bp">.</span><span class="n">class_instances</span> <span class="n">true</span>
<span class="kn">example</span> <span class="o">:</span> <span class="n">top</span> <span class="n">unit</span> <span class="mi">10</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span> <span class="c1">-- fails, but slowly</span>
</pre></div>


<p>Even though this example is unrealistic, diamonds occur all over the algebraic hierarchy, and I don't think there is a way avoiding diamonds from the algebraic hierarchy. And this is not a large amount of diamonds, there is already a significant slowdown with 11 diamonds on top of each other. I think mathlib has more diamonds (more parallel instead of serial).</p>

<a name="175205975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Instance%20resolution%20failures/near/175205975" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/24709Instanceresolutionfailures.html#175205975">Floris van Doorn (Sep 09 2019 at 00:24)</a>:</h4>
<p>In the stream <a href="#narrow/stream/113488-general/topic/more.20type.20class.20inference.20issues" title="#narrow/stream/113488-general/topic/more.20type.20class.20inference.20issues">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/more.20type.20class.20inference.20issues</a> I suggested:</p>
<blockquote>
<p>There should really be a different algorithm for these "forgetful instances". Make a graph of all instances that change the class but not the type (like <code>add_comm_group \a -&gt; add_group \a</code>) and when you have searched through all structural instances (or all instances with priority &gt;= default priority), then use a graph reachability algorithm to quickly search for a path to any instance in the local context.</p>
</blockquote>

<a name="175206555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Instance%20resolution%20failures/near/175206555" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/24709Instanceresolutionfailures.html#175206555">Floris van Doorn (Sep 09 2019 at 00:41)</a>:</h4>
<p>I don't know if that is the best way to deal with diamonds, but it should avoid the exponential blowup.</p>

<a name="175222358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Instance%20resolution%20failures/near/175222358" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/24709Instanceresolutionfailures.html#175222358">Sebastian Ullrich (Sep 09 2019 at 08:11)</a>:</h4>
<p>Thanks Floris. So are repeated (metavariable-free) instance problems the only big issue? Are <code>out_param</code>s more or less well behaved or were there fundamental issues as well?</p>

<a name="175225959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Instance%20resolution%20failures/near/175225959" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/24709Instanceresolutionfailures.html#175225959">Keeley Hoek (Sep 09 2019 at 09:20)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> do you think the category theory morphism problems deserve a mention here?</p>

<a name="175226803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Instance%20resolution%20failures/near/175226803" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/24709Instanceresolutionfailures.html#175226803">Scott Morrison (Sep 09 2019 at 09:36)</a>:</h4>
<p><span class="user-mention" data-user-id="110111">@Keeley Hoek</span> which did you have in mind?</p>

<a name="175226897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Instance%20resolution%20failures/near/175226897" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/24709Instanceresolutionfailures.html#175226897">Keeley Hoek (Sep 09 2019 at 09:37)</a>:</h4>
<p>I meant the whole business with having to specify the morphism universe everywhere because the resolver can't be coerced into being more aggressive.</p>

<a name="175226982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Instance%20resolution%20failures/near/175226982" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/24709Instanceresolutionfailures.html#175226982">Scott Morrison (Sep 09 2019 at 09:39)</a>:</h4>
<p>Oh, I see. Yes, it would be lovely if instance resolution would specialise universes in preference to failing.</p>

<a name="175227201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Instance%20resolution%20failures/near/175227201" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/24709Instanceresolutionfailures.html#175227201">Keeley Hoek (Sep 09 2019 at 09:43)</a>:</h4>
<p>I'm not so familiar with <code>out_param</code>, but maybe an annotation like that saying to aggressively unify could be a fix.</p>

<a name="175307681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Instance%20resolution%20failures/near/175307681" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/24709Instanceresolutionfailures.html#175307681">Floris van Doorn (Sep 10 2019 at 05:25)</a>:</h4>
<p><span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span> I don't feel confident to judge whether this is the only issue. My gut feeling is that there are more issues, but it's not always easy to say which problem is causing a type class search to time out.<br>
I have not worked with <code>out_param</code>s myself, so I cannot judge judge them.</p>

<a name="175308232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Instance%20resolution%20failures/near/175308232" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/24709Instanceresolutionfailures.html#175308232">Rob Lewis (Sep 10 2019 at 05:39)</a>:</h4>
<p>What's your timeline for collecting examples here? I'm limiting my Zulip time right now because I have too much else going on. But there are some bad instance searches I half-remember, and probably have saved on my office computer, I can try to write up once I get back there.</p>

<a name="175314585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Instance%20resolution%20failures/near/175314585" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/24709Instanceresolutionfailures.html#175314585">Sebastian Ullrich (Sep 10 2019 at 08:02)</a>:</h4>
<p><span class="user-mention" data-user-id="110596">@Rob Lewis</span> There are always other things to work on for us, so I'd say take your time</p>

<a name="175315402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Instance%20resolution%20failures/near/175315402" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/24709Instanceresolutionfailures.html#175315402">Mario Carneiro (Sep 10 2019 at 08:15)</a>:</h4>
<p><code>out_param</code> is finicky to use correctly, but AFAIK it doesn't cause any performance problems other than the preexisting ones</p>

<a name="175315475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Instance%20resolution%20failures/near/175315475" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/24709Instanceresolutionfailures.html#175315475">Mario Carneiro (Sep 10 2019 at 08:16)</a>:</h4>
<p>I would say as long as you can make it not asymptotically exponential everything else will be minor</p>

<a name="175315579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Instance%20resolution%20failures/near/175315579" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/24709Instanceresolutionfailures.html#175315579">Mario Carneiro (Sep 10 2019 at 08:18)</a>:</h4>
<p>TBH it's surprisingly fast considering how much work it is currently doing</p>

<a name="175316835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Instance%20resolution%20failures/near/175316835" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/24709Instanceresolutionfailures.html#175316835">Scott Morrison (Sep 10 2019 at 08:39)</a>:</h4>
<p>I wonder if just looking through the 53 current instances of <code>set_option class.instance_max_depth ...</code> in mathlib would provide some interesting examples.</p>

<a name="175325702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Instance%20resolution%20failures/near/175325702" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/24709Instanceresolutionfailures.html#175325702">Sebastien Gouezel (Sep 10 2019 at 11:17)</a>:</h4>
<p>Orthogonal to instance failures, but the following has been painful for me in manifolds.</p>
<div class="codehilite"><pre><span></span><span class="n">class</span> <span class="n">my_source</span> <span class="o">(</span><span class="n">Î±</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">source</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Î±</span><span class="o">)</span>
<span class="kn">lemma</span> <span class="n">foo</span> <span class="o">(</span><span class="n">Î±</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">my_source</span> <span class="n">Î±</span><span class="o">))</span> <span class="o">:</span> <span class="bp">âˆ€</span><span class="n">e</span> <span class="err">âˆˆ</span> <span class="n">A</span><span class="o">,</span> <span class="n">e</span><span class="bp">.</span><span class="n">source</span> <span class="bp">=</span> <span class="n">e</span><span class="bp">.</span><span class="n">source</span>
</pre></div>


<p>is not understood by Lean, as it is not able to infer the type of <code>e</code> in the statement of <code>foo</code> (even though <code>e âˆˆ A</code> should tell everything). So I have to give explicitly the type of <code>e</code>, which is not bad here but can be bad in more complicated instances. I know unification is complicated, but still...</p>

<a name="175325955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Instance%20resolution%20failures/near/175325955" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/24709Instanceresolutionfailures.html#175325955">Kenny Lau (Sep 10 2019 at 11:21)</a>:</h4>
<p>I think the issue is that you shouldn't use projection with class.</p>

<a name="175326366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Instance%20resolution%20failures/near/175326366" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/24709Instanceresolutionfailures.html#175326366">Sebastien Gouezel (Sep 10 2019 at 11:27)</a>:</h4>
<p>Sorry, I shouldn't have used <code>class</code>. Same outcome with <code>structure</code> instead.</p>

<a name="175477582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Instance%20resolution%20failures/near/175477582" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/24709Instanceresolutionfailures.html#175477582">Reid Barton (Sep 11 2019 at 21:22)</a>:</h4>
<p>Here is a pretty egregious failure:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">module</span>
<span class="kn">set_option</span> <span class="n">trace</span><span class="bp">.</span><span class="n">class_instances</span> <span class="n">true</span>
<span class="kn">example</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">T</span><span class="o">)</span> <span class="o">:</span> <span class="n">T</span> <span class="o">:=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">â„š</span><span class="o">)</span> <span class="err">â€¢</span> <span class="n">t</span>
</pre></div>


<p>Obviously the search <code>has_scalar â„š T</code> cannot succeed, but this is not obvious to Lean</p>

<a name="175477662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Instance%20resolution%20failures/near/175477662" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/24709Instanceresolutionfailures.html#175477662">Reid Barton (Sep 11 2019 at 21:23)</a>:</h4>
<p>I know I keep going on about GHC, but in GHC this kind of thing will fail in constant* time<br>
(* okay, probably logarithmic in something)</p>

<a name="175477724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Instance%20resolution%20failures/near/175477724" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/24709Instanceresolutionfailures.html#175477724">Reid Barton (Sep 11 2019 at 21:24)</a>:</h4>
<p>regardless of the number of classes or instances in the system or the depth of the class hierarchy</p>

<a name="175529388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Instance%20resolution%20failures/near/175529388" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/24709Instanceresolutionfailures.html#175529388">Sebastien Gouezel (Sep 12 2019 at 13:35)</a>:</h4>
<p>I just stumbled on a behavior I don't understand. Involving out_params, structures and typeclasses, so something a little bit exotic and probably the behavior will be completely different in Lean 4, but still let me record it here. Everything is fine with</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">local_homeomorph</span><span class="bp">.</span><span class="n">is_mdifferentiable</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">local_homeomorph</span> <span class="n">M</span> <span class="n">M&#39;</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">mdifferentiable_on</span> <span class="err">ğ•œ</span> <span class="n">f</span><span class="bp">.</span><span class="n">to_fun</span> <span class="n">f</span><span class="bp">.</span><span class="n">source</span><span class="o">)</span> <span class="bp">âˆ§</span> <span class="o">(</span><span class="n">mdifferentiable_on</span> <span class="err">ğ•œ</span> <span class="n">f</span><span class="bp">.</span><span class="n">inv_fun</span> <span class="n">f</span><span class="bp">.</span><span class="n">target</span><span class="o">)</span>

<span class="kn">lemma</span> <span class="n">mdifferentiable_atlas</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">e</span> <span class="err">âˆˆ</span> <span class="n">atlas</span> <span class="n">M</span> <span class="n">H</span><span class="o">)</span> <span class="o">:</span> <span class="n">e</span><span class="bp">.</span><span class="n">is_mdifferentiable</span> <span class="err">ğ•œ</span> <span class="o">:=</span>
<span class="bp">âŸ¨</span><span class="n">mdifferentiable_on_atlas_to_fun</span> <span class="err">ğ•œ</span> <span class="n">h</span><span class="o">,</span> <span class="n">mdifferentiable_on_atlas_inv_fun</span> <span class="err">ğ•œ</span> <span class="n">h</span><span class="bp">âŸ©</span>
</pre></div>


<p>But if I switch the definition to a structure, with</p>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">local_homeomorph</span><span class="bp">.</span><span class="n">is_mdifferentiable</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">local_homeomorph</span> <span class="n">M</span> <span class="n">M&#39;</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">diff_to_fun</span> <span class="o">:</span> <span class="n">mdifferentiable_on</span> <span class="err">ğ•œ</span> <span class="n">f</span><span class="bp">.</span><span class="n">to_fun</span> <span class="n">f</span><span class="bp">.</span><span class="n">source</span><span class="o">)</span>
<span class="o">(</span><span class="n">diff_inv_fun</span> <span class="o">:</span> <span class="n">mdifferentiable_on</span> <span class="err">ğ•œ</span> <span class="n">f</span><span class="bp">.</span><span class="n">inv_fun</span> <span class="n">f</span><span class="bp">.</span><span class="n">target</span><span class="o">)</span>
</pre></div>


<p>then the lemma is not accepted any more, failing with 4 messages</p>
<div class="codehilite"><pre><span></span><span class="n">don&#39;t</span> <span class="n">know</span> <span class="n">how</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">placeholder</span>
<span class="kn">context</span><span class="o">:</span>
<span class="err">ğ•œ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_1</span> <span class="o">:</span> <span class="n">nondiscrete_normed_field</span> <span class="err">ğ•œ</span><span class="o">,</span>
<span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_2</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_2</span> <span class="o">:</span> <span class="n">normed_group</span> <span class="n">E</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_3</span> <span class="o">:</span> <span class="n">normed_space</span> <span class="err">ğ•œ</span> <span class="n">E</span><span class="o">,</span>
<span class="n">H</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_3</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_4</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">H</span><span class="o">,</span>
<span class="n">I</span> <span class="o">:</span> <span class="n">model_with_corners</span> <span class="err">ğ•œ</span> <span class="n">E</span> <span class="n">H</span><span class="o">,</span>
<span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_4</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_5</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">M</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_6</span> <span class="o">:</span> <span class="n">manifold</span> <span class="n">H</span> <span class="n">M</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_7</span> <span class="o">:</span> <span class="n">smooth_manifold_with_corners</span> <span class="err">ğ•œ</span> <span class="n">E</span> <span class="n">H</span> <span class="n">M</span><span class="o">,</span>
<span class="n">e</span> <span class="o">:</span> <span class="n">local_homeomorph</span> <span class="n">M</span> <span class="n">H</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="n">e</span> <span class="err">âˆˆ</span> <span class="n">atlas</span> <span class="n">M</span> <span class="n">H</span>
<span class="err">âŠ¢</span> <span class="kt">Type</span> <span class="err">?</span>
</pre></div>


<p>I have several typeclass variables in scope, and I guess the main missing piece of information is the only exotic typeclass definition with outparams, i.e.,</p>
<div class="codehilite"><pre><span></span><span class="c">/-</span><span class="cm"> Specialization to the case of smooth manifolds with corners, over a field ğ•œ and with infinite</span>
<span class="cm">smoothness to simplify.</span>
<span class="cm">The set E is a vector space, and H is a model with corners based on E.</span>
<span class="cm">When ğ•œ is fixed, the model space with corners (E, H) should always be the same for a</span>
<span class="cm">given manifold M. Therefore, we register it as an out_param: it will not be necessary to write</span>
<span class="cm">it out explicitely when talking about smooth manifolds. This is the main point of this definition. -/</span>
<span class="n">class</span> <span class="n">smooth_manifold_with_corners</span> <span class="o">(</span><span class="err">ğ•œ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">nondiscrete_normed_field</span> <span class="err">ğ•œ</span><span class="o">]</span>
  <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="n">out_param</span> <span class="err">$</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">out_param</span> <span class="err">$</span> <span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">out_param</span> <span class="err">$</span> <span class="n">normed_space</span> <span class="err">ğ•œ</span> <span class="n">E</span><span class="o">]</span>
  <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">out_param</span> <span class="err">$</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">out_param</span> <span class="err">$</span> <span class="n">topological_space</span> <span class="n">H</span><span class="o">]</span> <span class="o">[</span><span class="n">I</span> <span class="o">:</span> <span class="n">out_param</span> <span class="err">$</span> <span class="n">model_with_corners</span> <span class="err">ğ•œ</span> <span class="n">E</span> <span class="n">H</span><span class="o">]</span>
  <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">out_param</span> <span class="err">$</span> <span class="n">manifold</span> <span class="n">H</span> <span class="n">M</span><span class="o">]</span> <span class="kn">extends</span>
  <span class="n">has_groupoid</span> <span class="n">H</span> <span class="n">M</span> <span class="o">(</span><span class="n">times_cont_diff_groupoid</span> <span class="err">âŠ¤</span> <span class="err">ğ•œ</span> <span class="n">E</span> <span class="n">H</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span>
</pre></div>

<a name="175620443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Instance%20resolution%20failures/near/175620443" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/24709Instanceresolutionfailures.html#175620443">Sebastian Ullrich (Sep 13 2019 at 12:55)</a>:</h4>
<blockquote>
<p>I know I keep going on about GHC, but in GHC this kind of thing will fail in constant* time<br>
(* okay, probably logarithmic in something)</p>
</blockquote>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> Is this still true with overlapping/incoherent instances?</p>

<a name="175620690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Instance%20resolution%20failures/near/175620690" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/24709Instanceresolutionfailures.html#175620690">Sebastian Ullrich (Sep 13 2019 at 12:58)</a>:</h4>
<p><span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> Why are your <code>out_param</code>s instance implicit? That looks very suspicious to me.</p>

<a name="175642412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Instance%20resolution%20failures/near/175642412" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/24709Instanceresolutionfailures.html#175642412">Sebastien Gouezel (Sep 13 2019 at 16:50)</a>:</h4>
<blockquote>
<p><span class="user-mention silent" data-user-id="110050">Sebastien Gouezel</span> Why are your <code>out_param</code>s instance implicit? That looks very suspicious to me.</p>
</blockquote>
<p>Probably because I am not using them properly. I did not find any doc, and hardly any example, so I tried some things until it worked. With my current setup, it works very well: with the definition</p>
<div class="codehilite"><pre><span></span><span class="kn">variables</span> <span class="o">(</span><span class="err">ğ•œ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">nondiscrete_normed_field</span> <span class="err">ğ•œ</span><span class="o">]</span>
<span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="err">ğ•œ</span> <span class="n">E</span><span class="o">]</span>
<span class="o">{</span><span class="n">H</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">H</span><span class="o">]</span> <span class="o">[</span><span class="n">I</span> <span class="o">:</span> <span class="n">model_with_corners</span> <span class="err">ğ•œ</span> <span class="n">E</span> <span class="n">H</span><span class="o">]</span>
<span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">manifold</span> <span class="n">H</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">smooth_manifold_with_corners</span> <span class="err">ğ•œ</span> <span class="n">E</span> <span class="n">H</span> <span class="n">M</span><span class="o">]</span>
<span class="o">{</span><span class="n">E&#39;</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E&#39;</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="err">ğ•œ</span> <span class="n">E&#39;</span><span class="o">]</span>
<span class="o">{</span><span class="n">H&#39;</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">H&#39;</span><span class="o">]</span> <span class="o">[</span><span class="n">I&#39;</span> <span class="o">:</span> <span class="n">model_with_corners</span> <span class="err">ğ•œ</span> <span class="n">E&#39;</span> <span class="n">H&#39;</span><span class="o">]</span>
<span class="o">{</span><span class="n">M&#39;</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">M&#39;</span><span class="o">]</span> <span class="o">[</span><span class="n">manifold</span> <span class="n">H&#39;</span> <span class="n">M&#39;</span><span class="o">]</span> <span class="o">[</span><span class="n">smooth_manifold_with_corners</span> <span class="err">ğ•œ</span> <span class="n">E&#39;</span> <span class="n">H&#39;</span> <span class="n">M&#39;</span><span class="o">]</span>
<span class="n">include</span> <span class="n">I</span> <span class="n">I&#39;</span>

<span class="n">def</span> <span class="n">mdifferentiable_at</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">â†’</span> <span class="n">M&#39;</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">continuous_at</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">âˆ§</span>
<span class="n">differentiable_within_at</span> <span class="err">ğ•œ</span> <span class="o">(</span><span class="n">written_in_ext_chart_at</span> <span class="err">ğ•œ</span> <span class="n">x</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">range</span> <span class="n">I</span><span class="bp">.</span><span class="n">to_fun</span><span class="o">)</span>
  <span class="o">((</span><span class="n">ext_chart_at</span> <span class="err">ğ•œ</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">to_fun</span> <span class="n">x</span><span class="o">)</span>
</pre></div>


<p>I can write <code>mdifferentiable_at ğ•œ f x</code> (where <code>ğ•œ</code> is a normed field and <code>f : M â†’ M'</code> and <code>x : M</code>), and Lean will infer by itself that it needs a manifold with corners structure on <code>M</code> and <code>M'</code>, and it will find all by itself about <code>E</code> and <code>H</code> and <code>I</code> and <code>E'</code> and <code>H'</code> and <code>I'</code>. Which is what I want to do differential geometry: when I want to talk about the derivative of a function, I just want to specify the field, and I am happy to let Lean fill in the gaps by itself.</p>
<p>As far as I understand, this is the goal of <code>out_param</code>s, and with my current setup it works well. But maybe there is a better syntax, or outparams are not designed for this. I would be super happy to hear your thoughts about this!  And I guess it could be useful to other people on this forum (I remember <span class="user-mention" data-user-id="210574">@Patrick Massot</span> asking naive questions on outparams too).</p>

<a name="175643554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Instance%20resolution%20failures/near/175643554" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/24709Instanceresolutionfailures.html#175643554">Reid Barton (Sep 13 2019 at 17:02)</a>:</h4>
<blockquote>
<blockquote>
<p>I know I keep going on about GHC, but in GHC this kind of thing will fail in constant* time<br>
(* okay, probably logarithmic in something)</p>
</blockquote>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> Is this still true with overlapping/incoherent instances?</p>
</blockquote>
<p>Well, what is true in general is that instance search in GHC never backtracks</p>


{% endraw %}

{% include archive_update.html %}