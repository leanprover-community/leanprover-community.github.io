---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/37846couldmetabeamonad.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/37846couldmetabeamonad.html">could meta be a monad</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="135797914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/could%20meta%20be%20a%20monad/near/135797914" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37846couldmetabeamonad.html#135797914">Johan Commelin (Oct 14 2018 at 23:38)</a>:</h4>
<p>Something that popped into my head recently, and my curiosity makes me ask this question:<br>
Could <code>meta</code> have been a monad?<br>
In Haskell, there is the <code>IO</code> monad that marks functions "unsafe" (i.e., they can have side effects). I could imagine that <code>meta</code> could also be a monad that marks functions "unsafe" (i.e., they are meta). Would this work? What would be the pros and cons?</p>

<a name="135802955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/could%20meta%20be%20a%20monad/near/135802955" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37846couldmetabeamonad.html#135802955">Simon Hudon (Oct 15 2018 at 02:30)</a>:</h4>
<p>Do you mean <code>tactic</code>? It's already a monad.</p>

<a name="135806442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/could%20meta%20be%20a%20monad/near/135806442" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37846couldmetabeamonad.html#135806442">Johan Commelin (Oct 15 2018 at 04:26)</a>:</h4>
<p>No, I meant what I wrote. [Edit: misinterpreted Simon's answer.]</p>

<a name="135806499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/could%20meta%20be%20a%20monad/near/135806499" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37846couldmetabeamonad.html#135806499">Scott Morrison (Oct 15 2018 at 04:28)</a>:</h4>
<p>I think you're conflating <code>meta</code> and <code>tactic</code> here.</p>

<a name="135806648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/could%20meta%20be%20a%20monad/near/135806648" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37846couldmetabeamonad.html#135806648">Johan Commelin (Oct 15 2018 at 04:33)</a>:</h4>
<p>No, I really meant <code>meta</code>.</p>

<a name="135806698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/could%20meta%20be%20a%20monad/near/135806698" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37846couldmetabeamonad.html#135806698">Johan Commelin (Oct 15 2018 at 04:34)</a>:</h4>
<p>If I have a trusted piece of code, I could wrap it into the "meta" tactic, and it would no longer be trusted, etc, etc...</p>

<a name="135806700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/could%20meta%20be%20a%20monad/near/135806700" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37846couldmetabeamonad.html#135806700">Johan Commelin (Oct 15 2018 at 04:34)</a>:</h4>
<p>Or does <span class="user-mention" data-user-id="110026">@Simon Hudon</span> mean that <code>tactic</code> is already a monad. I see. Yes, that I knew.</p>

<a name="135806707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/could%20meta%20be%20a%20monad/near/135806707" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37846couldmetabeamonad.html#135806707">Johan Commelin (Oct 15 2018 at 04:35)</a>:</h4>
<p>So I repeat my question: <em>Could</em> <code>meta</code> be a monad?</p>

<a name="135806807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/could%20meta%20be%20a%20monad/near/135806807" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37846couldmetabeamonad.html#135806807">Simon Hudon (Oct 15 2018 at 04:38)</a>:</h4>
<p>Ok so instead of having a keyword meta, you'd have a meta monad which would enable unbounded recursion and access to the prover's internals</p>

<a name="135806815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/could%20meta%20be%20a%20monad/near/135806815" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37846couldmetabeamonad.html#135806815">Simon Hudon (Oct 15 2018 at 04:39)</a>:</h4>
<p>I know that they want more parts of the tactics framework to be in pure code for Lean 4 but I don't know if everything can go there.</p>

<a name="135806816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/could%20meta%20be%20a%20monad/near/135806816" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37846couldmetabeamonad.html#135806816">Simon Hudon (Oct 15 2018 at 04:39)</a>:</h4>
<p>What gain do you think it would give us?</p>

<a name="135806917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/could%20meta%20be%20a%20monad/near/135806917" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37846couldmetabeamonad.html#135806917">Johan Commelin (Oct 15 2018 at 04:42)</a>:</h4>
<p>Like I said in my first post: just curiosity. I don't know anything about theoretical pros and cons.</p>

<a name="135807044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/could%20meta%20be%20a%20monad/near/135807044" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37846couldmetabeamonad.html#135807044">Simon Hudon (Oct 15 2018 at 04:46)</a>:</h4>
<p>I think at the moment, pure code doesn't allow unbounded recursion yet but that could be added too. I can't think of other reasons to not write all meta code as pure code</p>

<a name="135807583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/could%20meta%20be%20a%20monad/near/135807583" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37846couldmetabeamonad.html#135807583">Mario Carneiro (Oct 15 2018 at 05:03)</a>:</h4>
<p>I think the best analogue here is actually the <code>io</code> monad of lean</p>

<a name="135807626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/could%20meta%20be%20a%20monad/near/135807626" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37846couldmetabeamonad.html#135807626">Mario Carneiro (Oct 15 2018 at 05:04)</a>:</h4>
<p>it is non-meta, but you can do lots of external manipulation stuff and unbounded recursion</p>

<a name="135814024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/could%20meta%20be%20a%20monad/near/135814024" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37846couldmetabeamonad.html#135814024">Gabriel Ebner (Oct 15 2018 at 07:48)</a>:</h4>
<blockquote>
<p>Could <code>meta</code> have been a monad?</p>
</blockquote>
<p>Yes, instead of the <code>meta</code> keyword we could have a <code>meta</code> monad as follows:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="err">«</span><span class="n">meta</span><span class="err">»</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="bp">|</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">false</span> <span class="bp">→</span> <span class="n">α</span>
</pre></div>


<p>I think you can derive all features of the current meta in this monad, including <code>undefined</code> and general recursion.  But I'm not sure how helpful it would be.</p>

<a name="135814262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/could%20meta%20be%20a%20monad/near/135814262" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37846couldmetabeamonad.html#135814262">Johan Commelin (Oct 15 2018 at 07:53)</a>:</h4>
<p>I'm not sure if it is helpful. But I do find it <em>funny</em>.</p>

<a name="136114496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/could%20meta%20be%20a%20monad/near/136114496" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37846couldmetabeamonad.html#136114496">Reid Barton (Oct 19 2018 at 14:20)</a>:</h4>
<p>Encoding a type of effect as a monad has various generic disadvantages, including:</p>
<ul>
<li>You need different syntaxes to form the application <code>f x</code> depending on whether each of <code>f</code> or <code>x</code> is a monadic value or an ordinary value (here: <code>meta</code> or not).</li>
<li>You need to specify an order of effects, which forces you to linearize your program to a certain extent, whereas a pure program can have a tree structure.</li>
<li>If you want to use a second monad as well (say the <code>list</code> monad), now you need to figure out some way to combine the second monad with your effect monad (using something like monad transformers perhaps).</li>
</ul>
<p>In some contexts these points could be viewed as advantages, but the effect of nontermination is so mild that that doesn't apply here. For example, if <code>x</code> and <code>y</code> are possibly nonterminating computations, then computing <code>x</code> and then <code>y</code> is the same as computing <code>y</code> and then <code>x</code>.</p>

<a name="136114667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/could%20meta%20be%20a%20monad/near/136114667" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37846couldmetabeamonad.html#136114667">Reid Barton (Oct 19 2018 at 14:23)</a>:</h4>
<p>The only advantage of <code>meta</code> as a monad that I can think of is on the implementation side: Lean would no longer have to track the <code>meta</code> property. However, I think there would still be special cases required to reproduce the current behavior, e.g., <code>meta</code> inductive types have a relaxed syntax for recursion--Lean would have to make the constructors and/or recursors operate in the <code>meta</code> monad</p>


{% endraw %}

{% include archive_update.html %}