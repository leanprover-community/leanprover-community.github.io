---
layout: archive
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/83688syntax.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html">syntax</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="127544480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/127544480" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#127544480">Reid Barton (Jun 04 2018 at 13:22)</a>:</h4>
<p>Fun fact: <code>notation</code> applies even in <code>namespace</code> commands, so if you write <code>notation `foo` := bar</code> and then <code>namespace foo</code> it means <code>namespace bar</code></p>

<a name="127544555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/127544555" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#127544555">Simon Hudon (Jun 04 2018 at 13:24)</a>:</h4>
<p>Cool! :)</p>

<a name="127544571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/127544571" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#127544571">Simon Hudon (Jun 04 2018 at 13:25)</a>:</h4>
<p>I don't know if that's a good thing but I was properly surprised when I realized what you meant</p>

<a name="127544624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/127544624" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#127544624">Reid Barton (Jun 04 2018 at 13:26)</a>:</h4>
<p>If you don't want this to happen (like I didn't) then you can write <code>namespace «foo»</code></p>

<a name="127544649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/127544649" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#127544649">Simon Hudon (Jun 04 2018 at 13:27)</a>:</h4>
<p>Curiously enough, it also works on binders: <code>∀ foo, f foo</code> actually means <code>∀ bar, f bar</code> which is inconvenient when the notation is a short hand for an expression, not an identifier</p>

<a name="127544653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/127544653" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#127544653">Simon Hudon (Jun 04 2018 at 13:27)</a>:</h4>
<p>Thanks for the fix</p>

<a name="127544833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/127544833" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#127544833">Sebastian Ullrich (Jun 04 2018 at 13:31)</a>:</h4>
<p>o.O</p>

<a name="127544900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/127544900" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#127544900">Simon Hudon (Jun 04 2018 at 13:32)</a>:</h4>
<p>I take it that's unintended behavior?</p>

<a name="127544969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/127544969" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#127544969">Reid Barton (Jun 04 2018 at 13:34)</a>:</h4>
<p>(I was actually using <code>local notation</code>, in case that matters)</p>

<a name="127545111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/127545111" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#127545111">Sebastian Ullrich (Jun 04 2018 at 13:37)</a>:</h4>
<p>I get "identifier expected" in both cases</p>
<div class="codehilite"><pre><span></span>constants foo bar : Type
local notation `foo` := bar
#check ∀ foo, foo
namespace foo
</pre></div>

<a name="127545171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/127545171" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#127545171">Reid Barton (Jun 04 2018 at 13:38)</a>:</h4>
<p>Oh, I might have jumped to conclusions.<br>
What actually happened was that I was inside <code>namespace foo</code> and then I defined <code>foo</code> as local notation for something, and then <code>end foo</code> stopped working.</p>

<a name="127545183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/127545183" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#127545183">Reid Barton (Jun 04 2018 at 13:39)</a>:</h4>
<p>with some error like "identifier expected"</p>

<a name="127545332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/127545332" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#127545332">Simon Hudon (Jun 04 2018 at 13:42)</a>:</h4>
<p>Yes, you're right. That's what happens for me too. Sorry about the confusion</p>

<a name="127545397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/127545397" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#127545397">Sebastian Ullrich (Jun 04 2018 at 13:44)</a>:</h4>
<p>I see. This will probably be fixed in Lean 4 automatically since we will be using a parser combinator without a scanner, so we can skip notations where we only want to parse identifiers.</p>

<a name="127545431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/127545431" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#127545431">Simon Hudon (Jun 04 2018 at 13:45)</a>:</h4>
<p>How is that going by the way?</p>

<a name="127545680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/127545680" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#127545680">Sebastian Ullrich (Jun 04 2018 at 13:51)</a>:</h4>
<p>Let's... say that we're transitioning from the planning phase to the implementation phase (parser, compiler, and other refactorings)</p>

<a name="127545899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/127545899" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#127545899">Simon Hudon (Jun 04 2018 at 13:56)</a>:</h4>
<p>Exciting :D I can't wait to see where that will end up!</p>

<a name="166864691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/166864691" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#166864691">Tim Daly (May 29 2019 at 22:54)</a>:</h4>
<p>Is there an EBNF description of the Lean syntax?</p>

<a name="166864806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/166864806" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#166864806">Wojciech Nawrocki (May 29 2019 at 22:56)</a>:</h4>
<p>Maybe this: <a href="https://leanprover.github.io/reference/lexical_structure.html" target="_blank" title="https://leanprover.github.io/reference/lexical_structure.html">https://leanprover.github.io/reference/lexical_structure.html</a> ? I'm not sure if it's actually EBNF</p>

<a name="166864945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/166864945" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#166864945">Tim Daly (May 29 2019 at 22:59)</a>:</h4>
<p>That doesn't describe, for example, the syntax of optional types, etc. It is more like a tokenizer syntax.</p>

<a name="166865244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/166865244" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#166865244">Wojciech Nawrocki (May 29 2019 at 23:03)</a>:</h4>
<p>Oh, that's true</p>

<a name="166865321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/166865321" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#166865321">Tim Daly (May 29 2019 at 23:04)</a>:</h4>
<p>I'd like to accept Lean syntax as part of a system I'm building, making it easier to export proofs to Lean</p>

<a name="166865501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/166865501" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#166865501">Wojciech Nawrocki (May 29 2019 at 23:08)</a>:</h4>
<p>Perhaps <a href="https://bitbucket.org/gebner/pygments-main/src/d5e82e6ed58cfedf985cb1d5d55d056e477aa667/pygments/lexers/theorem.py?at=default#lines-377" target="_blank" title="https://bitbucket.org/gebner/pygments-main/src/d5e82e6ed58cfedf985cb1d5d55d056e477aa667/pygments/lexers/theorem.py?at=default#lines-377">the Pygments syntax description</a> might help?</p>

<a name="166865935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/166865935" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#166865935">Tim Daly (May 29 2019 at 23:14)</a>:</h4>
<p>Wow,  the person who wrote that code is multilingual. Still it is only a tokenizer. I was hoping that I didn't have to create the EBNF from Leonardo's source code.</p>

<a name="166887712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/166887712" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#166887712">Mario Carneiro (May 30 2019 at 07:44)</a>:</h4>
<p>I think <span class="user-mention" data-user-id="115334">@Thales</span> wrote a Lean grammar for Mehnir, which is probably the closest approximation yet. Part of the problem is that lean isn't actually context free, so you have to make a bunch of approximations and it's not actually sure to work (or even likely to work without a lot of hard-coding) on a real lean file</p>

<a name="167059113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167059113" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167059113">Tim Daly (Jun 01 2019 at 06:55)</a>:</h4>
<p>Well, I read the sources looking for EBNF. Unfortunately(?) Lean uses Pratt parsing. You can change syntax on the fly.</p>

<a name="167061418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167061418" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167061418">Mario Carneiro (Jun 01 2019 at 08:03)</a>:</h4>
<p>right, that's the <code>notation</code> command</p>

<a name="167061486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167061486" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167061486">Mario Carneiro (Jun 01 2019 at 08:04)</a>:</h4>
<p>You can still do decently if you know what syntaxes are defined, and parse up to the next command keyword</p>

<a name="167064470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167064470" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167064470">Tim Daly (Jun 01 2019 at 09:27)</a>:</h4>
<p>This causes a portability problem. I'd like to have a parser / exporter that can communicate freely with Lean. But if the notation command is used the associations can change dynamically making previously accepted communications fail. The obvious workaround would be to export the led-nud tables but I don't see anything in the source code that provides that. Another alternative would be to communicate using only "unsugared syntax". I will read more about that level of detail soon.</p>

<a name="167065160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167065160" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167065160">Tim Daly (Jun 01 2019 at 09:47)</a>:</h4>
<p>I am trying to combine proofs with code. This is a "30 year horizon" effort so it is important that the proofs are repeatable and stable (think latex, common lisp, and pdfs). The ability to modify syntax is one problem. The ability to modify tactics is another. Proofs are difficult, time consuming, and require a lot of effort. The hope is that today's proof will be accepted by the system years from now with the same result.</p>

<a name="167065472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167065472" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167065472">Tim Daly (Jun 01 2019 at 09:57)</a>:</h4>
<p>At the moment the only path seems to be to extract the Lean kernel and, for every proof, have the system dump a "kernel version" that used no syntax or tactics, just kernel-level I/O. That would enable proofs to be developed at the higher levels but stored and replayed as kernel code. The assumption is that the kernel is small and "30 year horizion" stable.</p>

<a name="167065647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167065647" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167065647">Andrew Ashworth (Jun 01 2019 at 10:02)</a>:</h4>
<p>The API is likely to change drastically regardless when Lean v4 arrives later this year. There will be many breaking changes. At a minimum mutually inductive types are going to move into the kernel for performance reasons, and there is no reason to believe other things may not move into the kernel if necessary for usability.</p>

<a name="167065649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167065649" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167065649">Tim Daly (Jun 01 2019 at 10:02)</a>:</h4>
<p>My code uses theorems from the 1890s so long-term proof stability is a vital issue.</p>

<a name="167065809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167065809" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167065809">Andrew Ashworth (Jun 01 2019 at 10:07)</a>:</h4>
<p>I can't think of a single proof language with that kind of stability, unfortunately.</p>

<a name="167066235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167066235" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167066235">Tim Daly (Jun 01 2019 at 10:19)</a>:</h4>
<p>How can I build up chains of Definitions and Lemmas proving code correctness if the whole thing fails a week later? I don't know how to do computational mathematics on that basis. I have common lisp source code for my computer algebra system that still compiles and executes with the same results today that it had when it was written in 1980. I have latex documents from then. It seems perfectly reasonable to expect that a "proof" by machine code would continue to be checkable in 2049.</p>

<a name="167066617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167066617" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167066617">Andrew Ashworth (Jun 01 2019 at 10:30)</a>:</h4>
<p>If you're willing to never upgrade or import results from the proof community at large, you could fix a version of &lt;your favorite proof language&gt;. Hardly appealing, I know.</p>

<a name="167066810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167066810" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167066810">Tim Daly (Jun 01 2019 at 10:37)</a>:</h4>
<p>It might be useful to consider a "standards effort" in proof technology. There used to be many competing lisp dialects and they eventually agreed on common lisp. I used lisp 1.5, maclisp, lispvm, psl, and many others and was good at "porting code". Now the common lisp standard makes that pointless. Perhaps there needs to be a Common Proof effort that provides a stable basis for (at least primitive syntax) of proofs  that can be universally accepted. Computational mathematics IS mathematics so it seems that long-term "30 year horizon" stability ought to be a major goal.</p>

<a name="167067071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167067071" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167067071">Tim Daly (Jun 01 2019 at 10:44)</a>:</h4>
<p>Competing on "features" is for game programmers, not mathematicians.</p>

<a name="167067132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167067132" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167067132">Patrick Massot (Jun 01 2019 at 10:46)</a>:</h4>
<p>I think you don't quite understand where we stand now. Freezing stuff at such an early stage would probably be very counter-productive. See <a href="https://deducteam.github.io/" target="_blank" title="https://deducteam.github.io/">https://deducteam.github.io/</a> however (but keep in mind that this is also very much work in progress)</p>

<a name="167067381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167067381" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167067381">Scott Morrison (Jun 01 2019 at 10:54)</a>:</h4>
<p>At the moment we are still before the beginning of history. Theorem provers are not yet useful for mathematics.</p>

<a name="167067386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167067386" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167067386">Scott Morrison (Jun 01 2019 at 10:54)</a>:</h4>
<p>(That is not to say they are not worth investing significant time in.)</p>

<a name="167067397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167067397" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167067397">Scott Morrison (Jun 01 2019 at 10:55)</a>:</h4>
<p>But any serious plans for backwards compatibility should wait (implementation at least, not discussion) until we have something.</p>

<a name="167067836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167067836" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167067836">Tim Daly (Jun 01 2019 at 11:08)</a>:</h4>
<p>Systems that use CIC, for instance, ought to have a compatible "raw" language for accepting each other's proofs. At minimum, a system ought to accept its own "raw" logic no matter what else changes. The logic is stable. The issue isn't "backward compatiblity" but "forward compatibilty". I can still compile and run my C code from my PDP-11/03 (1976). It seems obvious that a proof system should always accept a "proven" proof forever.</p>

<a name="167067971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167067971" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167067971">Andrew Ashworth (Jun 01 2019 at 11:12)</a>:</h4>
<p>In fact, the underlying logic isn't stable. For example, Coq only recently got universe polymorphism in version 8.5, and the underlying implementation is still subject to change.</p>

<a name="167068043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167068043" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167068043">Tim Daly (Jun 01 2019 at 11:15)</a>:</h4>
<p>So Coq doesn't have a stable proven kernel of logic?</p>

<a name="167068160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167068160" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167068160">Andrew Ashworth (Jun 01 2019 at 11:18)</a>:</h4>
<p>No. Extensions to CIC are allowed (as in Lean) as long as the developers think it's a good idea.</p>

<a name="167068175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167068175" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167068175">Tim Daly (Jun 01 2019 at 11:19)</a>:</h4>
<p>Do they invalidate prior proofs? (Will Flyspeck become junk?)</p>

<a name="167068523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167068523" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167068523">Andrew Ashworth (Jun 01 2019 at 11:28)</a>:</h4>
<p>I'm just looking at Flyspeck's project history and the most recent source code change was in Jan 25, 2019. Despite the fact the project was finished five years ago.</p>

<a name="167068536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167068536" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167068536">Patrick Massot (Jun 01 2019 at 11:29)</a>:</h4>
<p>According to Manuel Eberl, the Flyspeck project is compiled <em>every day</em> against current version of the relevant proof assistant.</p>

<a name="167068537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167068537" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167068537">Patrick Massot (Jun 01 2019 at 11:29)</a>:</h4>
<p>(automatically of course)</p>

<a name="167068792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167068792" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167068792">Tim Daly (Jun 01 2019 at 11:36)</a>:</h4>
<p>It seems my understanding of "the trusted kernel" is bogus. I'll read the source code and try to get a better grounding. Thanks.</p>

<a name="167073089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167073089" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167073089">Reid Barton (Jun 01 2019 at 13:41)</a>:</h4>
<blockquote>
<p>At the moment the only path seems to be to extract the Lean kernel and, for every proof, have the system dump a "kernel version" that used no syntax or tactics, just kernel-level I/O. That would enable proofs to be developed at the higher levels but stored and replayed as kernel code. The assumption is that the kernel is small and "30 year horizion" stable.</p>
</blockquote>
<p><code>lean --export</code> is something like this</p>

<a name="167073209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167073209" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167073209">Reid Barton (Jun 01 2019 at 13:45)</a>:</h4>
<p>There are external type checkers that can check the output of <code>lean --export</code>, for example <a href="https://github.com/dselsam/tc" target="_blank" title="https://github.com/dselsam/tc">https://github.com/dselsam/tc</a></p>

<a name="167073283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167073283" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167073283">Reid Barton (Jun 01 2019 at 13:47)</a>:</h4>
<p>So there is at least a very small amount of portability, namely, to outside the Lean kernel itself</p>

<a name="167075291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167075291" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167075291">Mario Carneiro (Jun 01 2019 at 14:45)</a>:</h4>
<p><span class="user-mention" data-user-id="223495">@Tim Daly</span>  I am sad I missed this discussion. Lean is not the place to look for stability, but there are proof languages that are designed for long term stability. Long future archiving and maintenance in perpetuity is among the selling points of Metamath. It has a standard, which was written down, in a published book from the 1990s and still remains valid (although additions have grown in the gaps, like HTML). There are as a result a whole ecosystem of independent verifiers, and in fact no single verifier "dominates the market", which is not something I can say about any other proof language I know. The axiom system is not completely stable but has changed only a few times in its 20 year history, and is based on an old mathematical standard, ZFC.</p>
<p>The downside to this kind of long term standardization is that it doesn't leave a lot of room for "syntax sugar" and building conveniences into the language, which is where Lean and Coq are coming from. I try to provide some assurance of "monotonicity" of proofs that are submitted to mathlib, but it's not easy. The axiom system is dependent on subtleties that make the proofs not portable to similar systems (such as Coq or other DTT systems), the syntax changes every few years, and we've literally thrown away the library and started afresh since the previous version, and while I don't intend to repeat that experience with lean 4 the language changes are just as traumatic. This is done in the quest for an easy to use language, where you can just sit down and write proofs and it's easy, and I respect that goal; but I think that this need not conflict with standardization.</p>
<p>Consider HTML and Javascript. This is a standard from the early 90s that we still use today. It has changed, but slowly and with a clearly defined standards body behind it. It has not hampered our ability to build new and glitzy things on top, but the key is that no one actually writes HTML/JS directly anymore. Instead the glitzy front end is written in some framework or language that didn't exist a year ago, and is hooked to a compiler that produces standards conformant HTML. I think this approach is very powerful, and I wish people would think more about having a separate back end with a well understood logic, and a core verifier that anyone can write.</p>

<a name="167075619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167075619" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167075619">Johan Commelin (Jun 01 2019 at 14:55)</a>:</h4>
<p>In principal I really like this idea... but it seems very non-trivial to build this. Quite a bit harder than HTML, I would think</p>

<a name="167075674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167075674" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167075674">Johan Commelin (Jun 01 2019 at 14:56)</a>:</h4>
<p>And already with the HTML + JS example you see that every new year brings a new framework, but it's hard to make them interact</p>

<a name="167075678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167075678" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167075678">Kevin Buzzard (Jun 01 2019 at 14:56)</a>:</h4>
<p>I still write html ;-)</p>

<a name="167075704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167075704" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167075704">Johan Commelin (Jun 01 2019 at 14:57)</a>:</h4>
<p>If proofs are written in some framework that still compiles in 50 (or 500) years, that is of course fabulous. But if those theorems can't be applied, because the framework they are written in is outdated, I don't see how this is any better than saying "Ooh, Flyspeck (or whatever) compiles with $ANCIENT version of $THEOREM_PROVER".</p>

<a name="167076295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167076295" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167076295">Mario Carneiro (Jun 01 2019 at 15:13)</a>:</h4>
<p>The theorems can be applied, but they may not be easily modified. For a mathematical theorem that's actually not that bad, and not all that different from conventional mathematical practice</p>

<a name="167076393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167076393" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167076393">Mario Carneiro (Jun 01 2019 at 15:15)</a>:</h4>
<p>The software analog is a library written in $OUTDATED that does something useful for you, so you link it to your project written in the new hotness</p>

<a name="167076443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167076443" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167076443">Johan Commelin (Jun 01 2019 at 15:16)</a>:</h4>
<p>They can be applied "in theory". Just like wordpress and joomla can probably be made to work together "in theory". But you can't just load a decades old joomla plugin into wordpress.</p>

<a name="167076463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167076463" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167076463">Johan Commelin (Jun 01 2019 at 15:17)</a>:</h4>
<p>Summary: I will have to see this work... until then, I remain somewhat skeptical. That "maths stack" is orders of magnitude more layered than any web-dev stack.</p>

<a name="167077027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167077027" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167077027">Mario Carneiro (Jun 01 2019 at 15:32)</a>:</h4>
<p>I'm working on it. I actually hope to have a demo soonish</p>

<a name="167079600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167079600" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167079600">Johan Commelin (Jun 01 2019 at 16:38)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Cool. I'm looking forward to it.</p>

<a name="167086565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167086565" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167086565">Tim Daly (Jun 01 2019 at 19:40)</a>:</h4>
<p>Axiom has a "30 Year Horizon" project goal, looking to develop the<br>
techniques and technology for reliable, proven computational<br>
mathematics.</p>
<p>I'm trying to prove Axiom Sane (rational, judicious, sound, logical)<br>
by constructing axioms and specifications for functions (actually,<br>
only the GCD functions since I'm not gonna live long enough to do<br>
much more :-) )</p>
<p>It is clearlly important to construct proofs that can be checked<br>
at compile time, every time, to ensure that Axiom is still<br>
mathematically sound despite changes.</p>
<p>Apparently this kind of "30 Year Horizon" stability isn't a project<br>
goal for a lot of the systems.I find this suprising since Gentzen's<br>
rules seem like a solid logic kernel you'd have to implement.</p>
<p>Robinson's resolution paper was in 1965 so proof technology is as<br>
old as computer algebra (SAINT/SIN). After  50+ years, it seems<br>
reasonable to think about standards.</p>
<p>Add all the features you want. Just give me a low-level, long-term<br>
language that still proof-checks 30 years from now.</p>

<a name="167103172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167103172" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167103172">Johan Commelin (Jun 02 2019 at 03:54)</a>:</h4>
<blockquote>
<p>Axiom has a "30 Year Horizon" project goal, looking to develop the<br>
techniques and technology for reliable, proven <em>computational</em><br>
mathematics.</p>
</blockquote>
<p>(emphasis mine) <span class="user-mention" data-user-id="223495">@Tim Daly</span> The problem is that most mathematicians are in love with a the 95% of mathematics that is not computational. Lean is a new system (not perfect, but getting close <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span>) that gives us powerful tools <em>and</em> explicitly doesn't give a thing if we use the axiom of choice are as noncomputable as we want. That is a new combo that other systems didn't give us.<br>
It's too early to claim victory. (In fact as others pointed out, we need systems that are even better than Lean.) But it cannot be denied that in its rather short life span Lean has made a rather impressive impact on the mathematical community compared to what other theorem provers have accomplished. (I didn't check any numbers, but I guess that the ratio <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mtext>mathematicians</mtext></mrow><mrow><mtext>computer scientists</mtext></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\text{mathematicians}}{\text{computer scientists}}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8801079999999999em;"></span><span class="strut bottom" style="height:1.3612159999999998em;vertical-align:-0.481108em;"></span><span class="base"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mathrm mtight">computer scientists</span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mathrm mtight">mathematicians</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> is higher in the Lean community than in the other theorem prover communities.)</p>
<p>I understand your wish for stability. It is also on my wish list. But my wish list is rather long (-;</p>

<a name="167113103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167113103" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167113103">Tim Daly (Jun 02 2019 at 08:58)</a>:</h4>
<p>About "victory"...</p>
<p>There are well over 100 "computer algebra systems" (I made a CD for a conference containing them). There are only a few large, general purpose ones (Mathematica, Maple, Axiom, Maxima, Magma). All of them had one thing in common... they had a reliable source of money. Sage was growing rapidly but the money ran out. (Oh, and nobody gets tenure writing software).</p>
<p>Look to see how reliable, long term, and deep-pocket-ed  the money source is. Winning systems need a constant funding of about 2 million dollars a year that will continue for 15+ years. The 2 million dollars will support 6-8 "core researchers". </p>
<p>When the core researchers are gone the software dies. Nobody ever, EVER, bothers to document the code. How many people know about the reference counting macros used in the Lean data structures? It is clever but unless you study the code and understand reference counting garbage collection, it is quite opaque. Who can maintain that software? (I'm trying to reverse-engineer the syntax which is considered a "trivial" task, just so my software can use Lean.)</p>
<p>On the mathematical side, what logic rules are actually implemented?  Can a non-mathematician even read the  papers that MIGHT show what SOME of the code does? Who can maintain that software?</p>
<p>Will Lean be "one of the large, general purpose systems" in 15 years? To misquote Zhou Enlai (when asked if the French Revolution was a good thing) ... "It is too soon to tell". But based on my experience, you just need to follow the money.</p>

<a name="167113450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167113450" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167113450">Tim Daly (Jun 02 2019 at 09:09)</a>:</h4>
<p>Interesting paper: Asperti et al. "Crafting a Proof Assistant"  Proc. Types 2006: Conf of the Types Project", 2006</p>

<a name="167115133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167115133" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167115133">Tim Daly (Jun 02 2019 at 09:56)</a>:</h4>
<p>Also: Barthe and Elbers "Towards Lean Proof Checking"</p>
<p>"Our implementation of Oracle types is very flexible and allows rewriting to be perfomred either inside Lego or by Reduce, an efficient symbolic computation system. In our view, the main novelty of our approach is to combine a sound theoretical foundation with an efficient implementation. Besides, our work provides the first attempt to combine symbolic computation systems with theorem provers such as Coq and Lego, which are based on intensional type theories."</p>

<a name="167118096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167118096" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167118096">Patrick Massot (Jun 02 2019 at 11:20)</a>:</h4>
<blockquote>
<p>But it cannot be denied that in its rather short life span Lean has made a rather impressive impact on the mathematical community compared to what other theorem provers have accomplished. (I didn't check any numbers, but I guess that the ratio <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mtext>mathematicians</mtext></mrow><mrow><mtext>computer scientists</mtext></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\text{mathematicians}}{\text{computer scientists}}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8801079999999999em;"></span><span class="strut bottom" style="height:1.3612159999999998em;vertical-align:-0.481108em;"></span><span class="base"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mathrm mtight">computer scientists</span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mathrm mtight">mathematicians</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> is higher in the Lean community than in the other theorem prover communities.)</p>
</blockquote>
<p>Johan, I appreciate your enthusiasm, but let's not forget we are discussing statistics on a negligible subset of mathematicians. For the sake of discussion, let's take the simplistic definition that we count people having a PhD in mathematics. Then, thinking about it for a couple of minutes, I can't get more than 10 mathematicians using Lean. Maybe I  forgot one or two (the list I have in mind is Bryan, Jan David, Johan, Kevin, Neil, Patrick, Sander, Scott, Sébastien, Tom, although I guess we could add Reid anyway). It seems there are at least 100 000 living mathematicians, so the ratio of Lean users among them is at most 1 out of  10 000. And taken all together, they have written 1 paper about formalizing maths in Lean (the cap set paper).</p>
<p>That's comparing Lean mathematicians with all mathematicians. Of course comparing to other proof assistants is more impressive. But we shouldn't forget there are, if I understand correctly, a number of mathematicians (using that simplistic definition) that do homotopy type theory, and it seems they almost all use Coq. There may very well be more than ten people in this category, say around Steve Awodey. There may be also people around Carlos Simpson, but I'm not sure he is still doing this. So I'm not sure at all we have more mathematicians than Coq. We probably have a better derivative, but still a tiny one. And we still miss having one landmark formalization. Computer scientists are not impressed <em>at all</em> by the perfectoid spaces project for instance. We claim it's something completely new, but we completely failed at convincing anyone of this up to now.</p>
<p>At the Edinburgh workshop, we really freaked out other proof assistant communities by bringing half a dozen mathematicians. The other gangs were not expecting this at all, and seemed thoroughly confused by this fact. But Jeremy was among people suggesting names to the main organizer. And we still don't understand why there were only 2 Coq users (Gonthier and Kerjean) at this workshop (other people were philosophers or Isabelle users or one person per "exotic" proof assistant like Naproche or PVS).</p>

<a name="167121188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167121188" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167121188">Tim Daly (Jun 02 2019 at 12:50)</a>:</h4>
<p>I agree with your point. I'm quite happy with Lean. I'm spending time reading the source code so I'm investing time in it.</p>

<a name="167121440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167121440" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167121440">Tim Daly (Jun 02 2019 at 12:58)</a>:</h4>
<p>There have been attempts to use Oracle systems to speed up proofs that involve computation. The problem is that the Oracle systems (usually a computer algebra system) are not proven, which undermines the premise that the proof is sound. However, if the GCD algorithms in Axiom were proven correct using Lean, then Lean could use Axiom's GCD computation as a proven Oracle. That changes the whole game.</p>

<a name="167121577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167121577" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167121577">Tim Daly (Jun 02 2019 at 13:02)</a>:</h4>
<p>And if the code for GCD was extracted from Lean it is even more interesting. See this paper:</p>
<p>Berger and Schwichtenberg "The Greatest Common Divisor: A Case Study for Program Extraction from Classical Proofs"  LNCS 1158 pp 36-46 1985</p>

<a name="167121797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167121797" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167121797">Tim Daly (Jun 02 2019 at 13:08)</a>:</h4>
<p>Efforts invested in a "landmark formalization" are interesting but are essentially a one-off effort. But efforts to tightly cooperate with a proven computer algebra system vastly increases the range of possible uses, both for the proof community and the computer algebra community.<br>
We really need these two towers of computational mathematics to cooperate.</p>

<a name="167121880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167121880" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167121880">Kevin Buzzard (Jun 02 2019 at 13:11)</a>:</h4>
<p>I spoke to <span class="user-mention" data-user-id="116034">@William Stein</span>  (who wrote SAGE) about Lean last year and he was super-enthusiastic, even going to the extent of making CoCalc work with Lean. I've used Lean in a multi-user environment within CoCalc just becuase of William's enthusiasm. But my aims were far less lofty than yours -- I just wanted a controlled place where students could use Lean without the hassle of having to install it. I'm sure he'd be very open-minded about further integration.</p>

<a name="167125227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167125227" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167125227">Tim Daly (Jun 02 2019 at 14:46)</a>:</h4>
<p>Axiom also works with Sage.</p>

<a name="167126487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167126487" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167126487">William Stein (Jun 02 2019 at 15:26)</a>:</h4>
<p>Hi Tim -- I'm glad to hear that you're learning and using LEAN!</p>


{% endraw %}
