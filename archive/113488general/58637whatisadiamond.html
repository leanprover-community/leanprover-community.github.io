---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/58637whatisadiamond.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html">what is a diamond?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="163833275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/163833275" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#163833275">Kevin Buzzard (Apr 21 2019 at 04:00)</a>:</h4>
<p><a href="https://github.com/kbuzzard/xena/blob/master/Examples/Category_5_Diamond.lean" target="_blank" title="https://github.com/kbuzzard/xena/blob/master/Examples/Category_5_Diamond.lean">The Category 5 Diamond (Xena)</a>.</p>
<p>What is a typeclass diamond (note : this has nothing to do with Scholze's diamonds, it's an unfortunate name-clash)? I think it's something like the above link. Two distinct instance routes from A to D, with typeclass inference giving us two terms of type D which are provably distinct. I am assuming that the system should be regarded as having failed at this point. How much can I get away with? I think there are other lower category diamonds as well though, right? What other things can go wrong? Instances which are equal but not computably equal? Instances which are equal but not definitionally equal? Is there some sort of complete catalogue of diamonds?</p>

<a name="163833380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/163833380" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#163833380">Keeley Hoek (Apr 21 2019 at 04:03)</a>:</h4>
<p>With regard to auto-naming, what do you think a good strategy for naming those would be? It would <del>probably</del> be really easy to implement</p>

<a name="163833569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/163833569" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#163833569">Kevin Buzzard (Apr 21 2019 at 04:09)</a>:</h4>
<p>I was going from <code>xena.B</code> to <code>xena.D</code> in my example, in the xena namespace, and getting a name which depended only on <code>D</code>. I guess I want to have B tagging along somehow. Is there some clever thing you can do with dots?</p>

<a name="164268877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/164268877" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#164268877">Floris van Doorn (Apr 26 2019 at 14:55)</a>:</h4>
<p>I think the term <code>type class diamond</code> is used whenever there are two ways to go from class <code>A</code> to class <code>D</code>, regardless of whether the two resulting instances are definitionally equal or not. I think it will be quite a big problem if you have a diamond and the resulting instances are not definitionally equal (whether they are provably equal is less important. I think we should restrict instances enough so that we don't get these kinds of bad diamonds.</p>

<a name="164268887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/164268887" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#164268887">Floris van Doorn (Apr 26 2019 at 14:55)</a>:</h4>
<p>golf:</p>
<div class="codehilite"><pre><span></span>theorem you_are_in_typeclass_trouble_now : d1 ≠ d2 := by rintro ⟨⟩
</pre></div>

<a name="164269265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/164269265" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#164269265">Johan Commelin (Apr 26 2019 at 14:58)</a>:</h4>
<p>If the class is a subsingleton, I want to be able to use non-defeq instances.</p>

<a name="164269295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/164269295" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#164269295">Johan Commelin (Apr 26 2019 at 14:59)</a>:</h4>
<p>That ought to be possible, right?</p>

<a name="164270793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/164270793" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#164270793">Kevin Buzzard (Apr 26 2019 at 15:14)</a>:</h4>
<p>That currently is annoying. <span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span> I know the type class system will not be changing, but this issue about typeclass inference failing to do subsingleton elimination is something we mathematicians are beginning to run into. Am I asking for <code>rfl++</code> or something?</p>

<a name="164270868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/164270868" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#164270868">Patrick Massot (Apr 26 2019 at 15:15)</a>:</h4>
<p>I don't think Sebastian said the type class system won't change. He wrote they didn't know yet what would be a better system. It's clear it has to improve, the current system simply doesn't scale.</p>

<a name="164271044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/164271044" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#164271044">Patrick Massot (Apr 26 2019 at 15:18)</a>:</h4>
<p>Part of the problem is indeed type-theoretic but, as far as I understand, most of the issues are completely generic (in which order do we search, what is cached, etc.)</p>

<a name="165756571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165756571" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165756571">Wojciech Nawrocki (May 15 2019 at 21:31)</a>:</h4>
<p>Ralf Jung, who's a Coq expert, just wrote <a href="https://www.ralfj.de/blog/2019/05/15/typeclasses-exponential-blowup.html" target="_blank" title="https://www.ralfj.de/blog/2019/05/15/typeclasses-exponential-blowup.html">a blog post (link)</a> about the problems diamonds cause and possible solutions. It seems that it's still a mostly unsolved problem, and possibly some issues you encounter here are due to the exponential blowup described there.</p>

<a name="165763496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165763496" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165763496">Reid Barton (May 15 2019 at 23:13)</a>:</h4>
<p>Interesting post. How did you come across it, by the way?</p>

<a name="165763606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165763606" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165763606">Reid Barton (May 15 2019 at 23:15)</a>:</h4>
<p>The diamonds mentioned in that post are of a different type, related to classes extending other classes</p>

<a name="165764226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165764226" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165764226">Reid Barton (May 15 2019 at 23:24)</a>:</h4>
<p>For example, B and C both extend A and D extends both B and C. If you have a D then you probably want the As to be defeq, but there's no way to even express that.</p>

<a name="165764349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165764349" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165764349">Simon Hudon (May 15 2019 at 23:26)</a>:</h4>
<p>In both Coq and Lean?</p>

<a name="165774918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165774918" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165774918">Reid Barton (May 16 2019 at 03:05)</a>:</h4>
<p>I think the issues are mostly the same in both. I guess I didn't pick the best example--in this case Lean will deduplicate the A fields in D if you use the old structure command, I think?</p>

<a name="165774948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165774948" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165774948">Reid Barton (May 16 2019 at 03:06)</a>:</h4>
<p>A better example is if you don't want to make the class D at all</p>

<a name="165775007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165775007" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165775007">Reid Barton (May 16 2019 at 03:07)</a>:</h4>
<p>because you have lots of things that extend A, and you don't want to make all the combinations.<br>
Then you have no way to say "A which is both B and C"</p>

<a name="165783076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165783076" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165783076">Johan Commelin (May 16 2019 at 06:16)</a>:</h4>
<p><span class="user-mention" data-user-id="128280">@Wojciech Nawrocki</span> Thanks for sharing this! Interesting read.</p>

<a name="165793783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165793783" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165793783">RalfJ (May 16 2019 at 09:33)</a>:</h4>
<p>Hi! Author of that post here. Lean was also just mentioned in our <a href="https://coq.discourse.group/t/blog-post-exponential-blowup-when-using-unbundled-typeclasses-to-model-algebraic-hierarchies/289" target="_blank" title="https://coq.discourse.group/t/blog-post-exponential-blowup-when-using-unbundled-typeclasses-to-model-algebraic-hierarchies/289">Coq-side discussion of this post</a>. I am very curious how Lean compares here.</p>

<a name="165793922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165793922" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165793922">RalfJ (May 16 2019 at 09:35)</a>:</h4>
<blockquote>
<p>The diamonds mentioned in that post are of a different type, related to classes extending other classes</p>
</blockquote>
<p>Yeah, the diamonds I saw mentioned in the backlog here are diamonds in the inference search tree, not in the algebraic hierarchy (which are the kinds of diamonds that bundling approaches have problems with). I mention that issue in my post as well though I dont call it a dimaond -- this is the exponential blowup coming from the <code>Monoid A -&gt; Semigroup A</code> instance together with the <code>prod</code> instances, where there are now two ways to derive <code>Monoid (A*A) -&gt; Semigroup (A*A)</code>.</p>

<a name="165794897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165794897" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165794897">Johan Commelin (May 16 2019 at 09:51)</a>:</h4>
<p>Cool, welcome!</p>

<a name="165796691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165796691" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165796691">Mario Carneiro (May 16 2019 at 10:22)</a>:</h4>
<p><span class="user-mention" data-user-id="222132">@RalfJ</span> Lean has the same foundational problem, but it isn't yet a big issue. The blog post doesn't discuss the style used in mathlib, which is to have "partially unbundled" structures, where the type is a parameter but none of the operators. This minimizes the nesting level, although there are some examples where we have deeper depth like modules (that use two variables) and there was an example using three variables that floated on the chat recently</p>

<a name="165796772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165796772" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165796772">Mario Carneiro (May 16 2019 at 10:23)</a>:</h4>
<p>Also, not mentioned in that asymptotic analysis is the amount of subterm sharing in the term. I think the size of those instances is actually linear, but if you write it as a tree instead of a dag then it becomes quadratic or cubic etc</p>

<a name="165796774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165796774" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165796774">Johan Commelin (May 16 2019 at 10:23)</a>:</h4>
<p>But it is very likely to become a problem in the (near?) future?</p>

<a name="165796853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165796853" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165796853">Mario Carneiro (May 16 2019 at 10:24)</a>:</h4>
<p>I don't think so... you have to be dealing with some pretty complicated objects for it to come up, so if it was an issue it would have stopped us already</p>

<a name="165796880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165796880" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165796880">Mario Carneiro (May 16 2019 at 10:25)</a>:</h4>
<p>We have issues with typeclass search order, but that's a different matter</p>

<a name="165796987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165796987" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165796987">Scott Morrison (May 16 2019 at 10:27)</a>:</h4>
<p>This is a really great thing about the <code>lean-perfectoid-spaces</code> project: we've made a definition which is about as complicated as they come (at least in algebraic geometry / number theory?), and Lean could cope.</p>

<a name="165797486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165797486" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165797486">Kevin Buzzard (May 16 2019 at 10:36)</a>:</h4>
<p>One of my main motivations for doing perfectoids was to see if Lean could handle them -- it was clear from the start that it was theoretically possible but Patrick pointed out very early on that this didn't mean that it was possible, and at times I was (incorrectly) worried that it might not be. I am still trying hard to understand what Mario wrote about timeouts. I've taken to trying to compile the perfectoid project with smaller values for the timeout parameter and am trying to understand what makes part of it slow to compile -- everything so far is pointing at naivity in the code -- poor proof engineering, as Mario calls it.</p>

<a name="165797498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165797498" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165797498">Kevin Buzzard (May 16 2019 at 10:36)</a>:</h4>
<p>In short, I have no formal training in programming and this is now beginning to show</p>

<a name="165797521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165797521" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165797521">Kevin Buzzard (May 16 2019 at 10:37)</a>:</h4>
<p>But at the end of the day the project does compile</p>

<a name="165799283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165799283" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165799283">RalfJ (May 16 2019 at 11:08)</a>:</h4>
<blockquote>
<p>"partially unbundled" structures, where the type is a parameter but none of the operators</p>
</blockquote>
<p>I mentioned having the operators unbundled but the superclasses bundled, that gives you <code>O(n^3)</code> If you just have the type unbundled you get <code>O(n^2)</code>, but you have even more sharing problems and you cannot even use the typeclasses for the operators and their notation before having shown the axioms. We had some cases where that was annoying, but the real trouble here is sharing once your inheritance hierarchy has a diamond.</p>

<a name="165799345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165799345" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165799345">RalfJ (May 16 2019 at 11:09)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> </p>
<blockquote>
<p>not mentioned in that asymptotic analysis is the amount of subterm sharing in the term. I think the size of those instances is actually linear, but if you write it as a tree instead of a dag then it becomes quadratic or cubic etc</p>
</blockquote>
<p>I explicitly mention that in the conclusion. :) And yes, if you fully exploit sharing I think it remains linear. But then you have to ensure that every pass traversing your AST (unification, reduction, elaboration, type checking, whatever...) exploits sharing. A single lapse and your get the bad complexities back. At least in the Coq world people tell me that is not feasible.</p>

<a name="165799593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165799593" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165799593">RalfJ (May 16 2019 at 11:12)</a>:</h4>
<blockquote>
<p>I don't think so... you have to be dealing with some pretty complicated objects for it to come up, so if it was an issue it would have stopped us already</p>
</blockquote>
<p>in our case, it was really when we started to put the hierarchy to use that the performance became an issue. as long as you are just defining your algebraic classes and show all sorts of properties about them it's good, but then we ended up defining our logic with 5 or more nested combinators (i.e., the equivalent of <code>Zn 5</code>), and then we nest that <em>again</em> in several more layers, so we end up with n=10 and more -- and then we have quite a few lemmas about that, and everything got slow. I have no idea what people have been doing in Lean so I cannot compare.</p>

<a name="165799618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165799618" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165799618">Mario Carneiro (May 16 2019 at 11:13)</a>:</h4>
<p>what do you mean about Zn 5?</p>

<a name="165799722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165799722" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165799722">RalfJ (May 16 2019 at 11:14)</a>:</h4>
<p>I was referring to my post; I mean that we had something like <code>iProp := T*U*V -&gt; A -&gt; B</code>, where <code>*</code> and <code>-&gt;</code> have TC instances like <code>prod</code> in my post. This is like <code>Zn 5 = Z*Z*Z*Z*Z</code>.</p>

<a name="165799769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165799769" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165799769">Mario Carneiro (May 16 2019 at 11:15)</a>:</h4>
<p>so you are trying to infer that e.g. Z^5 has a ring structure?</p>

<a name="165799786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165799786" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165799786">RalfJ (May 16 2019 at 11:15)</a>:</h4>
<p>and then we built things like <code>((X -&gt; iProp) -&gt; T -&gt; iProp) -&gt; ((X -&gt; iProp) -&gt; T -&gt; iProp)</code>. So if you count the number of combinators here, it's... 20 or more.</p>

<a name="165799865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165799865" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165799865">Mario Carneiro (May 16 2019 at 11:16)</a>:</h4>
<p>I'm confused about the role of T,U,V etc in those examples</p>

<a name="165799871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165799871" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165799871">RalfJ (May 16 2019 at 11:16)</a>:</h4>
<p>just random types that are in our hierarchy</p>

<a name="165799872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165799872" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165799872">Mario Carneiro (May 16 2019 at 11:16)</a>:</h4>
<p>You have a theorem that has 20 type arguments, plus all their typeclasses?</p>

<a name="165799889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165799889" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165799889">RalfJ (May 16 2019 at 11:17)</a>:</h4>
<p>like, random rings, if we stick to that example</p>

<a name="165799900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165799900" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165799900">RalfJ (May 16 2019 at 11:17)</a>:</h4>
<p>no, these are all concrete types</p>

<a name="165799903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165799903" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165799903">RalfJ (May 16 2019 at 11:17)</a>:</h4>
<p>well, most of them</p>

<a name="165800004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165800004" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165800004">Mario Carneiro (May 16 2019 at 11:18)</a>:</h4>
<p>Inferring that Z^5 has a ring structure should be quadratic, since you have to talk about Z^n itself and the ring structure for each of the subterms</p>

<a name="165800015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165800015" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165800015">Mario Carneiro (May 16 2019 at 11:18)</a>:</h4>
<p>it's not quintic</p>

<a name="165800019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165800019" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165800019">RalfJ (May 16 2019 at 11:18)</a>:</h4>
<p>with the fully unbundled approach and if ring is a subclass of group, the power is 6 at least</p>

<a name="165800049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165800049" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165800049">RalfJ (May 16 2019 at 11:19)</a>:</h4>
<p>that's what I explained in my post</p>

<a name="165800122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165800122" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165800122">Mario Carneiro (May 16 2019 at 11:20)</a>:</h4>
<p>So in mathlib if ring is a subclass of group that only increases things by a constant factor, I think, since the typeclass args will be twice as big</p>

<a name="165800152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165800152" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165800152">Mario Carneiro (May 16 2019 at 11:20)</a>:</h4>
<p>I think fully unbundled is the killer here</p>

<a name="165800284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165800284" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165800284">RalfJ (May 16 2019 at 11:22)</a>:</h4>
<blockquote>
<p>I think fully unbundled is the killer here</p>
</blockquote>
<p>it definitely is</p>

<a name="165800306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165800306" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165800306">RalfJ (May 16 2019 at 11:23)</a>:</h4>
<p>but we've also had loads of problems with bundling^^</p>

<a name="165800322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165800322" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165800322">Mario Carneiro (May 16 2019 at 11:23)</a>:</h4>
<p>with partially unbundled style you won't get that kind of thing unless you have n different type arguments, which is quite rare for mathematical structures</p>

<a name="165800332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165800332" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165800332">RalfJ (May 16 2019 at 11:23)</a>:</h4>
<p>the sheer number of arguments doesnt even matter</p>

<a name="165800336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165800336" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165800336">RalfJ (May 16 2019 at 11:23)</a>:</h4>
<p>only their "level of nesting" -- like arguments that have arguments</p>

<a name="165800413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165800413" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165800413">Mario Carneiro (May 16 2019 at 11:24)</a>:</h4>
<p>So I guess this is another variant on "don't use dependent types in DTT"</p>

<a name="165800425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165800425" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165800425">RalfJ (May 16 2019 at 11:24)</a>:</h4>
<p>;)</p>

<a name="165869412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165869412" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165869412">Johan Commelin (May 17 2019 at 03:31)</a>:</h4>
<p><span class="user-mention" data-user-id="222132">@RalfJ</span> I don't know if you have Lean installed. I ran this code to illustrate how mathlib/Lean deals with this:</p>
<div class="codehilite"><pre><span></span><span class="kn">section</span>
<span class="kn">set_option</span> <span class="n">pp</span><span class="bp">.</span><span class="n">all</span> <span class="n">true</span>

<span class="kn">lemma</span> <span class="n">inst01</span> <span class="o">:</span> <span class="n">ring</span> <span class="bp">ℤ</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span>
<span class="kn">lemma</span> <span class="n">inst02</span> <span class="o">:</span> <span class="n">ring</span> <span class="o">(</span><span class="bp">ℤ</span> <span class="bp">×</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span>
<span class="kn">lemma</span> <span class="n">inst03</span> <span class="o">:</span> <span class="n">ring</span> <span class="o">(</span><span class="bp">ℤ</span> <span class="bp">×</span> <span class="bp">ℤ</span> <span class="bp">×</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span>
<span class="kn">lemma</span> <span class="n">inst04</span> <span class="o">:</span> <span class="n">ring</span> <span class="o">(</span><span class="bp">ℤ</span> <span class="bp">×</span> <span class="bp">ℤ</span> <span class="bp">×</span> <span class="bp">ℤ</span> <span class="bp">×</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span>
<span class="kn">lemma</span> <span class="n">inst05</span> <span class="o">:</span> <span class="n">ring</span> <span class="o">(</span><span class="bp">ℤ</span> <span class="bp">×</span> <span class="bp">ℤ</span> <span class="bp">×</span> <span class="bp">ℤ</span> <span class="bp">×</span> <span class="bp">ℤ</span> <span class="bp">×</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">inst01</span>
<span class="bp">#</span><span class="kn">print</span> <span class="n">inst02</span>
<span class="bp">#</span><span class="kn">print</span> <span class="n">inst03</span>
<span class="bp">#</span><span class="kn">print</span> <span class="n">inst04</span>
<span class="bp">#</span><span class="kn">print</span> <span class="n">inst05</span>
<span class="kn">end</span>
</pre></div>


<p>The output of the last two prints is:</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">inst04</span> <span class="o">:</span> <span class="n">ring</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="o">(</span><span class="n">prod</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span> <span class="mi">0</span><span class="o">}</span> <span class="n">int</span> <span class="o">(</span><span class="n">prod</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span> <span class="mi">0</span><span class="o">}</span> <span class="n">int</span> <span class="o">(</span><span class="n">prod</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span> <span class="mi">0</span><span class="o">}</span> <span class="n">int</span> <span class="n">int</span><span class="o">)))</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">prod</span><span class="bp">.</span><span class="n">ring</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span> <span class="mi">0</span><span class="o">}</span> <span class="n">int</span> <span class="o">(</span><span class="n">prod</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span> <span class="mi">0</span><span class="o">}</span> <span class="n">int</span> <span class="o">(</span><span class="n">prod</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span> <span class="mi">0</span><span class="o">}</span> <span class="n">int</span> <span class="n">int</span><span class="o">))</span>
  <span class="o">(</span><span class="bp">@</span><span class="n">domain</span><span class="bp">.</span><span class="n">to_ring</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">int</span>
     <span class="o">(</span><span class="bp">@</span><span class="n">to_domain</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">int</span>
        <span class="o">(</span><span class="bp">@</span><span class="n">linear_ordered_comm_ring</span><span class="bp">.</span><span class="n">to_linear_ordered_ring</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">int</span>
           <span class="o">(</span><span class="bp">@</span><span class="n">decidable_linear_ordered_comm_ring</span><span class="bp">.</span><span class="n">to_linear_ordered_comm_ring</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">int</span>
              <span class="n">int</span><span class="bp">.</span><span class="n">decidable_linear_ordered_comm_ring</span><span class="o">))))</span>
  <span class="o">(</span><span class="bp">@</span><span class="n">prod</span><span class="bp">.</span><span class="n">ring</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span> <span class="mi">0</span><span class="o">}</span> <span class="n">int</span> <span class="o">(</span><span class="n">prod</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span> <span class="mi">0</span><span class="o">}</span> <span class="n">int</span> <span class="n">int</span><span class="o">)</span>
     <span class="o">(</span><span class="bp">@</span><span class="n">domain</span><span class="bp">.</span><span class="n">to_ring</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">int</span>
        <span class="o">(</span><span class="bp">@</span><span class="n">to_domain</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">int</span>
           <span class="o">(</span><span class="bp">@</span><span class="n">linear_ordered_comm_ring</span><span class="bp">.</span><span class="n">to_linear_ordered_ring</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">int</span>
              <span class="o">(</span><span class="bp">@</span><span class="n">decidable_linear_ordered_comm_ring</span><span class="bp">.</span><span class="n">to_linear_ordered_comm_ring</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">int</span>
                 <span class="n">int</span><span class="bp">.</span><span class="n">decidable_linear_ordered_comm_ring</span><span class="o">))))</span>
     <span class="o">(</span><span class="bp">@</span><span class="n">prod</span><span class="bp">.</span><span class="n">ring</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span> <span class="mi">0</span><span class="o">}</span> <span class="n">int</span> <span class="n">int</span>
        <span class="o">(</span><span class="bp">@</span><span class="n">domain</span><span class="bp">.</span><span class="n">to_ring</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">int</span>
           <span class="o">(</span><span class="bp">@</span><span class="n">to_domain</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">int</span>
              <span class="o">(</span><span class="bp">@</span><span class="n">linear_ordered_comm_ring</span><span class="bp">.</span><span class="n">to_linear_ordered_ring</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">int</span>
                 <span class="o">(</span><span class="bp">@</span><span class="n">decidable_linear_ordered_comm_ring</span><span class="bp">.</span><span class="n">to_linear_ordered_comm_ring</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">int</span>
                    <span class="n">int</span><span class="bp">.</span><span class="n">decidable_linear_ordered_comm_ring</span><span class="o">))))</span>
        <span class="o">(</span><span class="bp">@</span><span class="n">domain</span><span class="bp">.</span><span class="n">to_ring</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">int</span>
           <span class="o">(</span><span class="bp">@</span><span class="n">to_domain</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">int</span>
              <span class="o">(</span><span class="bp">@</span><span class="n">linear_ordered_comm_ring</span><span class="bp">.</span><span class="n">to_linear_ordered_ring</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">int</span>
                 <span class="o">(</span><span class="bp">@</span><span class="n">decidable_linear_ordered_comm_ring</span><span class="bp">.</span><span class="n">to_linear_ordered_comm_ring</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">int</span>
                    <span class="n">int</span><span class="bp">.</span><span class="n">decidable_linear_ordered_comm_ring</span><span class="o">))))))</span>
</pre></div>


<p>and</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">inst05</span> <span class="o">:</span> <span class="n">ring</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="o">(</span><span class="n">prod</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span> <span class="mi">0</span><span class="o">}</span> <span class="n">int</span> <span class="o">(</span><span class="n">prod</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span> <span class="mi">0</span><span class="o">}</span> <span class="n">int</span> <span class="o">(</span><span class="n">prod</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span> <span class="mi">0</span><span class="o">}</span> <span class="n">int</span> <span class="o">(</span><span class="n">prod</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span> <span class="mi">0</span><span class="o">}</span> <span class="n">int</span> <span class="n">int</span><span class="o">))))</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">prod</span><span class="bp">.</span><span class="n">ring</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span> <span class="mi">0</span><span class="o">}</span> <span class="n">int</span> <span class="o">(</span><span class="n">prod</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span> <span class="mi">0</span><span class="o">}</span> <span class="n">int</span> <span class="o">(</span><span class="n">prod</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span> <span class="mi">0</span><span class="o">}</span> <span class="n">int</span> <span class="o">(</span><span class="n">prod</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span> <span class="mi">0</span><span class="o">}</span> <span class="n">int</span> <span class="n">int</span><span class="o">)))</span>
  <span class="o">(</span><span class="bp">@</span><span class="n">domain</span><span class="bp">.</span><span class="n">to_ring</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">int</span>
     <span class="o">(</span><span class="bp">@</span><span class="n">to_domain</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">int</span>
        <span class="o">(</span><span class="bp">@</span><span class="n">linear_ordered_comm_ring</span><span class="bp">.</span><span class="n">to_linear_ordered_ring</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">int</span>
           <span class="o">(</span><span class="bp">@</span><span class="n">decidable_linear_ordered_comm_ring</span><span class="bp">.</span><span class="n">to_linear_ordered_comm_ring</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">int</span>
              <span class="n">int</span><span class="bp">.</span><span class="n">decidable_linear_ordered_comm_ring</span><span class="o">))))</span>
  <span class="o">(</span><span class="bp">@</span><span class="n">prod</span><span class="bp">.</span><span class="n">ring</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span> <span class="mi">0</span><span class="o">}</span> <span class="n">int</span> <span class="o">(</span><span class="n">prod</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span> <span class="mi">0</span><span class="o">}</span> <span class="n">int</span> <span class="o">(</span><span class="n">prod</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span> <span class="mi">0</span><span class="o">}</span> <span class="n">int</span> <span class="n">int</span><span class="o">))</span>
     <span class="o">(</span><span class="bp">@</span><span class="n">domain</span><span class="bp">.</span><span class="n">to_ring</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">int</span>
        <span class="o">(</span><span class="bp">@</span><span class="n">to_domain</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">int</span>
           <span class="o">(</span><span class="bp">@</span><span class="n">linear_ordered_comm_ring</span><span class="bp">.</span><span class="n">to_linear_ordered_ring</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">int</span>
              <span class="o">(</span><span class="bp">@</span><span class="n">decidable_linear_ordered_comm_ring</span><span class="bp">.</span><span class="n">to_linear_ordered_comm_ring</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">int</span>
                 <span class="n">int</span><span class="bp">.</span><span class="n">decidable_linear_ordered_comm_ring</span><span class="o">))))</span>
     <span class="o">(</span><span class="bp">@</span><span class="n">prod</span><span class="bp">.</span><span class="n">ring</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span> <span class="mi">0</span><span class="o">}</span> <span class="n">int</span> <span class="o">(</span><span class="n">prod</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span> <span class="mi">0</span><span class="o">}</span> <span class="n">int</span> <span class="n">int</span><span class="o">)</span>
        <span class="o">(</span><span class="bp">@</span><span class="n">domain</span><span class="bp">.</span><span class="n">to_ring</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">int</span>
           <span class="o">(</span><span class="bp">@</span><span class="n">to_domain</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">int</span>
              <span class="o">(</span><span class="bp">@</span><span class="n">linear_ordered_comm_ring</span><span class="bp">.</span><span class="n">to_linear_ordered_ring</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">int</span>
                 <span class="o">(</span><span class="bp">@</span><span class="n">decidable_linear_ordered_comm_ring</span><span class="bp">.</span><span class="n">to_linear_ordered_comm_ring</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">int</span>
                    <span class="n">int</span><span class="bp">.</span><span class="n">decidable_linear_ordered_comm_ring</span><span class="o">))))</span>
        <span class="o">(</span><span class="bp">@</span><span class="n">prod</span><span class="bp">.</span><span class="n">ring</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span> <span class="mi">0</span><span class="o">}</span> <span class="n">int</span> <span class="n">int</span>
           <span class="o">(</span><span class="bp">@</span><span class="n">domain</span><span class="bp">.</span><span class="n">to_ring</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">int</span>
              <span class="o">(</span><span class="bp">@</span><span class="n">to_domain</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">int</span>
                 <span class="o">(</span><span class="bp">@</span><span class="n">linear_ordered_comm_ring</span><span class="bp">.</span><span class="n">to_linear_ordered_ring</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">int</span>
                    <span class="o">(</span><span class="bp">@</span><span class="n">decidable_linear_ordered_comm_ring</span><span class="bp">.</span><span class="n">to_linear_ordered_comm_ring</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">int</span>
                       <span class="n">int</span><span class="bp">.</span><span class="n">decidable_linear_ordered_comm_ring</span><span class="o">))))</span>
           <span class="o">(</span><span class="bp">@</span><span class="n">domain</span><span class="bp">.</span><span class="n">to_ring</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">int</span>
              <span class="o">(</span><span class="bp">@</span><span class="n">to_domain</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">int</span>
                 <span class="o">(</span><span class="bp">@</span><span class="n">linear_ordered_comm_ring</span><span class="bp">.</span><span class="n">to_linear_ordered_ring</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">int</span>
                    <span class="o">(</span><span class="bp">@</span><span class="n">decidable_linear_ordered_comm_ring</span><span class="bp">.</span><span class="n">to_linear_ordered_comm_ring</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">int</span>
                       <span class="n">int</span><span class="bp">.</span><span class="n">decidable_linear_ordered_comm_ring</span><span class="o">)))))))</span>
</pre></div>

<a name="165869467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165869467" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165869467">Johan Commelin (May 17 2019 at 03:32)</a>:</h4>
<p>It is slightly repetetive, but it's clearly linear (-;</p>

<a name="165870396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165870396" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165870396">Mario Carneiro (May 17 2019 at 03:59)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">pi_instances</span>
<span class="kn">set_option</span> <span class="n">pp</span><span class="bp">.</span><span class="n">all</span> <span class="n">true</span>

<span class="kn">lemma</span> <span class="n">inst01</span> <span class="o">:</span> <span class="n">ring</span> <span class="bp">ℤ</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span>
<span class="kn">lemma</span> <span class="n">inst02</span> <span class="o">:</span> <span class="n">ring</span> <span class="o">(</span><span class="bp">ℤ</span> <span class="bp">×</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span>
<span class="kn">lemma</span> <span class="n">inst03</span> <span class="o">:</span> <span class="n">ring</span> <span class="o">(</span><span class="bp">ℤ</span> <span class="bp">×</span> <span class="bp">ℤ</span> <span class="bp">×</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span>
<span class="kn">lemma</span> <span class="n">inst04</span> <span class="o">:</span> <span class="n">ring</span> <span class="o">(</span><span class="bp">ℤ</span> <span class="bp">×</span> <span class="bp">ℤ</span> <span class="bp">×</span> <span class="bp">ℤ</span> <span class="bp">×</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span>
<span class="kn">lemma</span> <span class="n">inst05</span> <span class="o">:</span> <span class="n">ring</span> <span class="o">(</span><span class="bp">ℤ</span> <span class="bp">×</span> <span class="bp">ℤ</span> <span class="bp">×</span> <span class="bp">ℤ</span> <span class="bp">×</span> <span class="bp">ℤ</span> <span class="bp">×</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">count_int</span> <span class="o">:</span> <span class="n">list</span> <span class="n">char</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">l</span><span class="bp">@</span><span class="o">(</span><span class="bp">_::</span><span class="n">l&#39;</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">if</span> <span class="n">l</span><span class="bp">.</span><span class="k">take</span> <span class="mi">3</span> <span class="bp">=</span> <span class="s2">&quot;int&quot;</span><span class="bp">.</span><span class="n">to_list</span> <span class="k">then</span> <span class="n">count_int</span> <span class="o">(</span><span class="n">l</span><span class="bp">.</span><span class="n">drop</span> <span class="mi">3</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span> <span class="k">else</span>
  <span class="n">count_int</span> <span class="n">l&#39;</span>

<span class="kn">open</span> <span class="n">tactic</span>
<span class="n">meta</span> <span class="n">def</span> <span class="n">count_int_in_decl</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">name</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="n">do</span> <span class="n">d</span> <span class="err">←</span> <span class="n">get_decl</span> <span class="n">n</span><span class="o">,</span> <span class="n">e</span> <span class="err">←</span> <span class="n">pp</span> <span class="n">d</span><span class="bp">.</span><span class="n">value</span><span class="o">,</span>
   <span class="n">return</span> <span class="err">$</span> <span class="n">count_int</span> <span class="n">e</span><span class="bp">.</span><span class="n">to_string</span><span class="bp">.</span><span class="n">to_list</span>
<span class="bp">#</span><span class="kn">eval</span> <span class="n">do</span>
  <span class="n">l</span> <span class="err">←</span> <span class="n">mmap</span> <span class="n">count_int_in_decl</span>
    <span class="o">[</span><span class="bp">``</span><span class="n">inst01</span><span class="o">,</span> <span class="bp">``</span><span class="n">inst02</span><span class="o">,</span> <span class="bp">``</span><span class="n">inst03</span><span class="o">,</span> <span class="bp">``</span><span class="n">inst04</span><span class="o">,</span> <span class="bp">``</span><span class="n">inst05</span><span class="o">],</span>
  <span class="n">trace</span> <span class="n">l</span><span class="o">,</span> <span class="c1">-- [5, 12, 20, 29, 39]</span>
  <span class="n">guard</span> <span class="err">$</span> <span class="n">l</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="n">n</span><span class="err">^</span><span class="mi">2</span> <span class="bp">+</span> <span class="mi">13</span><span class="bp">*</span><span class="n">n</span><span class="o">)</span> <span class="bp">/</span> <span class="mi">2</span> <span class="bp">+</span> <span class="mi">5</span><span class="o">)</span> <span class="bp">&lt;</span><span class="err">$</span><span class="bp">&gt;</span> <span class="n">list</span><span class="bp">.</span><span class="n">range</span> <span class="mi">5</span>
</pre></div>

<a name="165870398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165870398" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165870398">Mario Carneiro (May 17 2019 at 03:59)</a>:</h4>
<p>it's quadratic</p>

<a name="165870513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165870513" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165870513">Mario Carneiro (May 17 2019 at 04:01)</a>:</h4>
<p>but the linear term is pretty large, so the quadratic behavior doesn't assert itself until <code>n = 13</code> or so</p>

<a name="165870582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165870582" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165870582">Mario Carneiro (May 17 2019 at 04:03)</a>:</h4>
<p>to see why, notice that <code>(prod.{0 0} int (prod.{0 0} int (prod.{0 0} int int)))</code> appears on line 1, <code>(prod.{0 0} int (prod.{0 0} int int))</code> appears on line 5, <code>(prod.{0 0} int int)</code> appears on line 10 and so on in <code>inst05</code></p>

<a name="165876758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165876758" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165876758">Kevin Buzzard (May 17 2019 at 06:35)</a>:</h4>
<p>I experimented with this stuff a few weeks ago. IIRC when you go up to 6 factors it doesn't work!</p>

<a name="165876763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165876763" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165876763">Kevin Buzzard (May 17 2019 at 06:36)</a>:</h4>
<p>Some search gives up before it finds it. Is my memory correct?</p>

<a name="165877139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165877139" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165877139">Mario Carneiro (May 17 2019 at 06:45)</a>:</h4>
<p>yes, you have to raise the instance search depth to get past 5 factors</p>

<a name="165922321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165922321" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165922321">RalfJ (May 17 2019 at 18:01)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> given that this uses just the type as an index, quadratic is exactly what my blog post predicts :)</p>

<a name="165922379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/165922379" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#165922379">RalfJ (May 17 2019 at 18:02)</a>:</h4>
<p>what I am curious about now is if lean can keep the inference and/or checking times linear by exploiting sharing</p>

<a name="166160360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20a%20diamond%3F/near/166160360" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/58637whatisadiamond.html#166160360">Mario Carneiro (May 21 2019 at 10:34)</a>:</h4>
<p>Heh, this just appeared on the isabelle mailing list: <a href="https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-May/msg00089.html" target="_blank" title="https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-May/msg00089.html">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-May/msg00089.html</a> . Looks familiar...</p>


{% endraw %}

{% include archive_update.html %}