---
layout: archive
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/10222Auxiliarytypes.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/10222Auxiliarytypes.html">Auxiliary types</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="151490448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Auxiliary%20types/near/151490448" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/10222Auxiliarytypes.html#151490448">Kenny Lau (Dec 11 2018 at 23:48)</a>:</h4>
<p>I've been thinking about auxiliary types. Types like <code>additive</code> and <code>multiplicative</code>. Types that help the type-class inference system do its job. Interestingly I don't see a wide use of auxiliary types. I understand that one of the inconveniences is that sometimes you want to refer to elements of the original type, and transferring between the real type and the auxiliary type might prove a bit troublesome. What are your thoughts on auxiliary types?</p>

<a name="151490470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Auxiliary%20types/near/151490470" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/10222Auxiliarytypes.html#151490470">Kenny Lau (Dec 11 2018 at 23:49)</a>:</h4>
<p>So for example there are <code>def</code>initions that should be instances, but is not so because the typeclass system could not possibly figure out the argument. What if we then created auxiliary types to solve this problem?</p>

<a name="151490751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Auxiliary%20types/near/151490751" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/10222Auxiliarytypes.html#151490751">Mario Carneiro (Dec 11 2018 at 23:55)</a>:</h4>
<p>auxiliary types can be used to help here</p>

<a name="151490855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Auxiliary%20types/near/151490855" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/10222Auxiliarytypes.html#151490855">Mario Carneiro (Dec 11 2018 at 23:57)</a>:</h4>
<p>for example, if you have a module on <code>B</code> from a ring hom <code>f : A -&gt; B</code>, then this is a bad instance because the ring hom <code>f</code> is not a typeclass but it is required for the instance. If you have a wrapper type <code>ring_hom_module f := B</code>, then lean can handle it because it is now inferred by unification instead of typeclass inference</p>

<a name="151490860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Auxiliary%20types/near/151490860" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/10222Auxiliarytypes.html#151490860">Mario Carneiro (Dec 11 2018 at 23:57)</a>:</h4>
<p>This is how <code>Qp</code> works, for example</p>

<a name="151490927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Auxiliary%20types/near/151490927" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/10222Auxiliarytypes.html#151490927">Kenny Lau (Dec 11 2018 at 23:59)</a>:</h4>
<p>what is Qp?</p>

<a name="151490931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Auxiliary%20types/near/151490931" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/10222Auxiliarytypes.html#151490931">Mario Carneiro (Dec 11 2018 at 23:59)</a>:</h4>
<p>actually never mind, that's not a good example (it is an example of something else)</p>

<a name="151490937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Auxiliary%20types/near/151490937" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/10222Auxiliarytypes.html#151490937">Mario Carneiro (Dec 11 2018 at 23:59)</a>:</h4>
<p>padic rats</p>

<a name="151490940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Auxiliary%20types/near/151490940" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/10222Auxiliarytypes.html#151490940">Kenny Lau (Dec 11 2018 at 23:59)</a>:</h4>
<p>actually I've been using exactly the same example and it has been working great</p>

<a name="151490947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Auxiliary%20types/near/151490947" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/10222Auxiliarytypes.html#151490947">Kenny Lau (Dec 11 2018 at 23:59)</a>:</h4>
<p>I'm now experimenting them on semidirect products</p>

<a name="151490959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Auxiliary%20types/near/151490959" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/10222Auxiliarytypes.html#151490959">Mario Carneiro (Dec 11 2018 at 23:59)</a>:</h4>
<p>aha, <code>zmodp</code> is an example</p>

<a name="151491042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Auxiliary%20types/near/151491042" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/10222Auxiliarytypes.html#151491042">Mario Carneiro (Dec 12 2018 at 00:00)</a>:</h4>
<p>it has an explicit argument <code>hp : prime p</code> so that lean can derive the field instance</p>

<a name="151491051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Auxiliary%20types/near/151491051" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/10222Auxiliarytypes.html#151491051">Mario Carneiro (Dec 12 2018 at 00:00)</a>:</h4>
<p>semidirect product is a pretty good example</p>

<a name="151494819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Auxiliary%20types/near/151494819" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/10222Auxiliarytypes.html#151494819">Kenny Lau (Dec 12 2018 at 01:14)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> it worked great with dihedral</p>

<a name="151494900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Auxiliary%20types/near/151494900" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/10222Auxiliarytypes.html#151494900">Kenny Lau (Dec 12 2018 at 01:16)</a>:</h4>
<p><a href="https://github.com/kckennylau/Lean/blob/master/semidirect_product.lean" target="_blank" title="https://github.com/kckennylau/Lean/blob/master/semidirect_product.lean">https://github.com/kckennylau/Lean/blob/master/semidirect_product.lean</a></p>

<a name="151494983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Auxiliary%20types/near/151494983" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/10222Auxiliarytypes.html#151494983">Simon Hudon (Dec 12 2018 at 01:18)</a>:</h4>
<p>(deleted)</p>

<a name="151873964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Auxiliary%20types/near/151873964" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/10222Auxiliarytypes.html#151873964">Kenny Lau (Dec 16 2018 at 09:53)</a>:</h4>
<p>I think we should use auxiliary types for modules</p>

<a name="151874110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Auxiliary%20types/near/151874110" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/10222Auxiliarytypes.html#151874110">Kevin Buzzard (Dec 16 2018 at 09:58)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> you hoped that Kenny would know how to fix modules but he knows several possible solutions. Which is best?</p>

<a name="151874162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Auxiliary%20types/near/151874162" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/10222Auxiliarytypes.html#151874162">Mario Carneiro (Dec 16 2018 at 10:00)</a>:</h4>
<p>what is the proposal exactly?</p>

<a name="151876446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Auxiliary%20types/near/151876446" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/10222Auxiliarytypes.html#151876446">Kevin Buzzard (Dec 16 2018 at 11:21)</a>:</h4>
<p>I don't even understand the outparam proposal, I am still an outparam amateur</p>

<a name="151876486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Auxiliary%20types/near/151876486" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/10222Auxiliarytypes.html#151876486">Kevin Buzzard (Dec 16 2018 at 11:22)</a>:</h4>
<p>There's an old thread which goes through it which I will dig up at some point</p>

<a name="151876777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Auxiliary%20types/near/151876777" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/10222Auxiliarytypes.html#151876777">Kenny Lau (Dec 16 2018 at 11:33)</a>:</h4>
<p>something like:</p>
<div class="codehilite"><pre><span></span><span class="n">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="n">class</span> <span class="n">has_scalar</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">smul</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">γ</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span>

<span class="kn">infixr</span> <span class="bp">`</span> <span class="err">•</span> <span class="bp">`</span><span class="o">:</span><span class="mi">73</span> <span class="o">:=</span> <span class="n">has_scalar</span><span class="bp">.</span><span class="n">smul</span>


<span class="kn">structure</span> <span class="n">module</span><span class="bp">.</span><span class="n">core</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="kn">extends</span> <span class="n">has_scalar</span> <span class="n">R</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">smul_add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">r</span><span class="o">:</span><span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span><span class="o">:</span><span class="n">M</span><span class="o">),</span> <span class="n">r</span> <span class="err">•</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">r</span> <span class="err">•</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">r</span> <span class="err">•</span> <span class="n">y</span><span class="o">)</span>

<span class="n">def</span> <span class="n">module_type</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">module</span><span class="bp">.</span><span class="n">core</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span> <span class="n">M</span>
</pre></div>


{% endraw %}
