---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/74934Trustdowntothemetal.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/74934Trustdowntothemetal.html">Trust "down to the metal"</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="184716541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Trust%20%22down%20to%20the%20metal%22/near/184716541" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74934Trustdowntothemetal.html#184716541">Tim Daly (Jan 03 2020 at 07:54)</a>:</h4>
<p>While building a trusted computer algebra system, the SANE version of Axiom, I've been looking at questions of trust at all levels.</p>
<p>Andrej Bauer has been working on a smaller kernel (a nucleus) that separates the trust from the logic. The rules of the logic can be specified as  needed but checked by the nucleus code.</p>
<p>I've been studying Field Programmable Gate Arrays (FPGA) that allow you to create your own hardware in a C-like language (Verilog). It allows you to check the chip you build all the way down to the transistor states. You can create things as complex as a whole CPU or as simple as a trusted nucleus (youtube: Building a CPU on an FPGA). ACL2 has a history of verifying hardware logic.</p>
<p>It appears that, assuming I can understand Bauer's Andromeda system, it would be possible and not all that hard to implemented a trusted kernel on an FPGA the size and form factor of a USB stick.</p>
<p>Trust "down to the metal"</p>

<a name="184717893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Trust%20%22down%20to%20the%20metal%22/near/184717893" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74934Trustdowntothemetal.html#184717893">Johan Commelin (Jan 03 2020 at 08:26)</a>:</h4>
<p><span class="user-mention" data-user-id="223495">@Tim Daly</span> You should also read Mario's metamath zero paper. One of his goals/applications is trust at all levels.</p>

<a name="184717917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Trust%20%22down%20to%20the%20metal%22/near/184717917" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74934Trustdowntothemetal.html#184717917">Johan Commelin (Jan 03 2020 at 08:27)</a>:</h4>
<p>You can see here <a href="https://github.com/digama0/mm0/tree/master/examples" target="_blank" title="https://github.com/digama0/mm0/tree/master/examples">https://github.com/digama0/mm0/tree/master/examples</a> that he has been formalising x86 and such</p>

<a name="184721500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Trust%20%22down%20to%20the%20metal%22/near/184721500" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74934Trustdowntothemetal.html#184721500">Tim Daly (Jan 03 2020 at 09:41)</a>:</h4>
<p>Yes, I've seen that repo.</p>
<p>The problem with the x86 is the instruction semantics. I wrote a program that generates the x86 instruction semantics (as conditional-concurrent assignments) which we used for reverse-engineering malware (<a href="http://daly.axiom-developer.org/TimothyDaly_files/publications/sei/intel/intel.pdf" target="_blank" title="http://daly.axiom-developer.org/TimothyDaly_files/publications/sei/intel/intel.pdf">http://daly.axiom-developer.org/TimothyDaly_files/publications/sei/intel/intel.pdf</a>). The x86 is a complex beast. Writing the semantics took 3 years. </p>
<p>On the other hand, an FPGA is small, has gate-level timing, and is an ideal platform for nucleus and kernel level semantics.<br>
You can do all the dancing you want at any level and then "run it through the hardware". Assuming your implementation provides independent proof checking it would not matter whether you used Coq, Lean, or something else.</p>

<a name="184721565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Trust%20%22down%20to%20the%20metal%22/near/184721565" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74934Trustdowntothemetal.html#184721565">Tim Daly (Jan 03 2020 at 09:42)</a>:</h4>
<p>In addition, Bauer's approach lets you choose your logic.</p>

<a name="184723072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Trust%20%22down%20to%20the%20metal%22/near/184723072" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74934Trustdowntothemetal.html#184723072">Andrew Ashworth (Jan 03 2020 at 10:16)</a>:</h4>
<p>Heh. You can simulate all the way down to transistor states, in an FPGA. What actually happens is un-knowable. Once you instrument your FPGA, your bug might disappear.  (My time doing occasional FPGA development may have made me a bit cynical...)</p>

<a name="184732471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Trust%20%22down%20to%20the%20metal%22/near/184732471" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74934Trustdowntothemetal.html#184732471">Mario Carneiro (Jan 03 2020 at 13:21)</a>:</h4>
<p>Running a theorem prover kernel on an FPGA is not out of the question. You need a relatively large read only memory, and a small read-write memory (probably on the order of 1 MB ROM and 16 KB RAM for something the size of <a href="http://set.mm" target="_blank" title="http://set.mm">set.mm</a>) and you stream the whole proof.</p>

<a name="184732550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Trust%20%22down%20to%20the%20metal%22/near/184732550" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74934Trustdowntothemetal.html#184732550">Mario Carneiro (Jan 03 2020 at 13:22)</a>:</h4>
<p>writing the logic gates is not fun though. You really need to abstract away from that to get a real theorem prover running</p>

<a name="184740243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Trust%20%22down%20to%20the%20metal%22/near/184740243" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74934Trustdowntothemetal.html#184740243">Tim Daly (Jan 03 2020 at 15:06)</a>:</h4>
<p>Intel bought Altera (the second largest FPGA company) a couple years ago. Intel now ships CPUs with a built-in FPGA. You can buy one now (but you have to be one of the FAANGs, they only sell them to the big server companies). One of these days you'll be able to "side load" your FPGA processor and side-load your proof from your proof-carrying code. Leo probably has access to one at Microsoft.</p>
<p>As for "a large read-only memory", the Altera has a lot of ROM that allows you to install whole CPUs. They also have dual MIPS CPUs available on the die itself if you want to run MPS code. The rules for a logic like CIC would be a trivial in comparison. And since the hardware is naturally fully parallel you can compute all branches of your proof tree at once.</p>
<p>It would be much easier to write proven hardware semantics for Bauer's Andromeda on an FPGA than it would to prove anything about an x86 instruction stream. Using a layered code architecture like Milawa would allow the user to decide which, and how many, layers to side load into the FPGA, each layer proven by lower layers. With not many layers you end up with a fully proven lisp engine.</p>
<p>It will all be available, likely within 2020, once Intel decides to ship non-FAANG hardware to the world.</p>

<a name="184741175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Trust%20%22down%20to%20the%20metal%22/near/184741175" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74934Trustdowntothemetal.html#184741175">Tim Daly (Jan 03 2020 at 15:18)</a>:</h4>
<p>So layering Lean's logic on an FPGA that implements the trusted kernel would run really fast and, if the kernel is in ROM, would be rather trustworthy.</p>

<a name="184745307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Trust%20%22down%20to%20the%20metal%22/near/184745307" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74934Trustdowntothemetal.html#184745307">Mario Carneiro (Jan 03 2020 at 16:09)</a>:</h4>
<p>I think x86 is being a distraction here. It does not make a big difference what the instruction set is</p>

<a name="184747611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Trust%20%22down%20to%20the%20metal%22/near/184747611" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74934Trustdowntothemetal.html#184747611">Tim Daly (Jan 03 2020 at 16:40)</a>:</h4>
<p>The point I set out to make had nothing to do with the x86. The basic idea was to embed something like Bauer's Andromeda in hardware. The Andromeda nucleus is designed to accept logic rules like CIC and perform the trusted verification. Thus many logics could be used depending on what you're trying to prove and what logic is convenient (assuming soundness/completeness) all of which use the same trusted nucleus.</p>

<a name="184747978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Trust%20%22down%20to%20the%20metal%22/near/184747978" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74934Trustdowntothemetal.html#184747978">Tim Daly (Jan 03 2020 at 16:44)</a>:</h4>
<p>The problem I'm trying to solve is proving mathematical algorithms. Such proofs can use different logics</p>

<a name="184748038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Trust%20%22down%20to%20the%20metal%22/near/184748038" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74934Trustdowntothemetal.html#184748038">Tim Daly (Jan 03 2020 at 16:45)</a>:</h4>
<p>Lean is useful for the group theory theorems since Axiom is designed around group theory.</p>


{% endraw %}

{% include archive_update.html %}