---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/70759bijectionwithnoncomputableinverse.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html">bijection with noncomputable inverse</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="167825286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167825286" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167825286">Kevin Buzzard (Jun 11 2019 at 07:13)</a>:</h4>
<p>There are some concepts which are obvious to computer scientists who have learnt some constructive logic but which are alien to mathematicians, and I am interested in explaining them to mathematicians.</p>
<p>One of these concepts is the idea that there are types which don't have decidable equality. I think I've cracked this one. One can argue that the real numbers on either side of the equality at, say, <a href="https://mathoverflow.net/a/331385/1384" target="_blank" title="https://mathoverflow.net/a/331385/1384">this answer</a> are clearly "well-defined" or "computable to arbitrary accuracy" or however mathematicians would like to think of it, but mathematicians can just as easily see that there is no "one method" which will answer all questions of this nature (as evidenced by the fact that apparently there is no known method which will answer that one).</p>
<p>I want to do the same for bijections. Mathematicians still find it jarring that the concept of "bijection" and "map with a two-sided inverse" are not "the same" in Lean. I'd like to give an example of a bijection from the reals to the reals which is defined by an algorithm but for which there is no obvious algorithm to define the inverse. I'm assuming such a function exists -- does it? I'm also assuming that this question can be made precise (where "real number" becomes something like "for all n, a rational number within 1/n of the real numbers" or whatever; I'm hoping there are no issues here).</p>

<a name="167825398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167825398" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167825398">Mario Carneiro (Jun 11 2019 at 07:14)</a>:</h4>
<p>an even simpler example of non-decidable equality is <code>nat -&gt; nat</code></p>

<a name="167825431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167825431" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167825431">Kevin Buzzard (Jun 11 2019 at 07:15)</a>:</h4>
<p>I think mathematicians will prefer the real example. I'm not sure they understand what a Turing machine is.</p>

<a name="167825447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167825447" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167825447">Mario Carneiro (Jun 11 2019 at 07:15)</a>:</h4>
<p>I am not talking about turing machines, I mean functions</p>

<a name="167825489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167825489" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167825489">Kevin Buzzard (Jun 11 2019 at 07:16)</a>:</h4>
<p>Mathematicians are typically not taught what a computable function is.</p>

<a name="167825529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167825529" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167825529">Mario Carneiro (Jun 11 2019 at 07:16)</a>:</h4>
<p>just regular functions</p>

<a name="167825540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167825540" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167825540">Kevin Buzzard (Jun 11 2019 at 07:16)</a>:</h4>
<p>Well fair enough.</p>

<a name="167825545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167825545" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167825545">Mario Carneiro (Jun 11 2019 at 07:16)</a>:</h4>
<p>to properly talk about decidability you need some notion of computing though</p>

<a name="167825552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167825552" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167825552">Mario Carneiro (Jun 11 2019 at 07:16)</a>:</h4>
<p>an informal sense is sufficient</p>

<a name="167825567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167825567" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167825567">Kevin Buzzard (Jun 11 2019 at 07:17)</a>:</h4>
<p>I know but this is the hard part for mathematicians. The example with the reals I think gets the point across for decidability.</p>

<a name="167825570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167825570" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167825570">Kevin Buzzard (Jun 11 2019 at 07:17)</a>:</h4>
<p>"if I can't decide it, how can a machine?"</p>

<a name="167825637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167825637" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167825637">Kevin Buzzard (Jun 11 2019 at 07:18)</a>:</h4>
<p>Maybe <code>nat -&gt; nat</code> is a place to look for computable bijections with a non-computable inverse?</p>

<a name="167825642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167825642" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167825642">Mario Carneiro (Jun 11 2019 at 07:18)</a>:</h4>
<p>really? I find the idea that real numbers are not decidable at least a bit weird, given that we generally picture them as completed entities, where 1 = 2 in real is no different from 1 = 2 in nat</p>

<a name="167825657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167825657" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167825657">Mario Carneiro (Jun 11 2019 at 07:18)</a>:</h4>
<p>plus I can ask my calculator if real numbers are equal no problem</p>

<a name="167825662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167825662" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167825662">Kevin Buzzard (Jun 11 2019 at 07:18)</a>:</h4>
<p>All I'm saying is that a mathematician will not even flinch when you say "conjecture: some stupid sum of binomial coefficients is pi^7"</p>

<a name="167825683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167825683" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167825683">Kevin Buzzard (Jun 11 2019 at 07:19)</a>:</h4>
<p>and then you can say "hah! But both sides are well-defined real numbers, and we can't figure out if they're equal."</p>

<a name="167825686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167825686" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167825686">Mario Carneiro (Jun 11 2019 at 07:19)</a>:</h4>
<p>conjecture: the function that maps all goldbach counterexamples to 1 and other stuff to 0 is the constant 0 function</p>

<a name="167825694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167825694" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167825694">Kevin Buzzard (Jun 11 2019 at 07:19)</a>:</h4>
<p>I believe you</p>

<a name="167825759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167825759" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167825759">Mario Carneiro (Jun 11 2019 at 07:20)</a>:</h4>
<p>I think it's easier to draw the parallel between Pi1 statements and equality of functions than equality of reals, but maybe that's the logician in me</p>

<a name="167825762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167825762" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167825762">Kevin Buzzard (Jun 11 2019 at 07:20)</a>:</h4>
<p>and I can use this to give noncomputable bijections with noncomputable inverses</p>

<a name="167825780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167825780" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167825780">Kevin Buzzard (Jun 11 2019 at 07:21)</a>:</h4>
<p>does Goldbach help with the noncomputable inverse thing?</p>

<a name="167825791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167825791" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167825791">Mario Carneiro (Jun 11 2019 at 07:21)</a>:</h4>
<p>I don't know whether I have a convincing example for the bijection problem</p>

<a name="167825796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167825796" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167825796">Kevin Buzzard (Jun 11 2019 at 07:21)</a>:</h4>
<p>Mathematicians don't know what a Pi1 statement is either.</p>

<a name="167825804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167825804" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167825804">Mario Carneiro (Jun 11 2019 at 07:21)</a>:</h4>
<p>obviously don't say that</p>

<a name="167825807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167825807" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167825807">Mario Carneiro (Jun 11 2019 at 07:21)</a>:</h4>
<p>say goldbach or RH or something</p>

<a name="167825810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167825810" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167825810">Kevin Buzzard (Jun 11 2019 at 07:21)</a>:</h4>
<p>We're so ignorant. Only the logicians know, and they're retiring and not being replaced.</p>

<a name="167825815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167825815" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167825815">Kevin Buzzard (Jun 11 2019 at 07:21)</a>:</h4>
<p>At least in the UK.</p>

<a name="167825860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167825860" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167825860">Mario Carneiro (Jun 11 2019 at 07:22)</a>:</h4>
<p>I mentioned the bijection between <code>option</code> and <code>roption</code> before, but I don't want to explain that one</p>

<a name="167825871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167825871" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167825871">Kevin Buzzard (Jun 11 2019 at 07:22)</a>:</h4>
<p>Yes, I looked at that comment and even wrote the code constructing the equiv afterwards</p>

<a name="167825879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167825879" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167825879">Kevin Buzzard (Jun 11 2019 at 07:22)</a>:</h4>
<p>I used your trick of subst to avoid heqs, IIRC</p>

<a name="167825894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167825894" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167825894">Mario Carneiro (Jun 11 2019 at 07:23)</a>:</h4>
<p>The problem is that you can't just use some simple type like <code>nat -&gt; nat</code> because you usually get obvious bijections, even if weird ones also exist</p>

<a name="167825899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167825899" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167825899">Mario Carneiro (Jun 11 2019 at 07:23)</a>:</h4>
<p>you have to put some strange subtype on the thing</p>

<a name="167825913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167825913" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167825913">Mario Carneiro (Jun 11 2019 at 07:23)</a>:</h4>
<p>you can embed <code>roption nat</code> in <code>nat -&gt; bool</code> as monotone sequences</p>

<a name="167825978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167825978" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167825978">Mario Carneiro (Jun 11 2019 at 07:24)</a>:</h4>
<p>and of course <code>option nat</code> is isomorphic to <code>nat</code></p>

<a name="167825984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167825984" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167825984">Mario Carneiro (Jun 11 2019 at 07:24)</a>:</h4>
<p>so perhaps that's a solution</p>

<a name="167826009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167826009" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167826009">Kevin Buzzard (Jun 11 2019 at 07:25)</a>:</h4>
<p>Thanks for these comments; I'll think more.</p>

<a name="167826176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167826176" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167826176">Mario Carneiro (Jun 11 2019 at 07:28)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">enat</span> <span class="o">:=</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">→</span> <span class="n">bool</span> <span class="bp">//</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">tt</span> <span class="bp">→</span> <span class="n">f</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="n">tt</span><span class="o">}</span>

<span class="n">def</span> <span class="n">f</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">→</span> <span class="n">enat</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">ff</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">n</span> <span class="n">h</span><span class="o">,</span> <span class="n">h</span><span class="bp">⟩</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">i</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">i</span> <span class="n">h</span><span class="o">,</span>
  <span class="o">(</span><span class="n">to_bool_iff</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="err">$</span> <span class="n">nat</span><span class="bp">.</span><span class="n">le_succ_of_le</span> <span class="err">$</span> <span class="o">(</span><span class="n">to_bool_iff</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="n">h</span><span class="bp">⟩</span>
</pre></div>


<p>the inverse to <code>f</code> is noncomputable</p>

<a name="167826351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167826351" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167826351">Kevin Buzzard (Jun 11 2019 at 07:31)</a>:</h4>
<p>Oh I like that!</p>

<a name="167826419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167826419" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167826419">Kevin Buzzard (Jun 11 2019 at 07:32)</a>:</h4>
<p>With the reals I was going round in circles thinking "I need to have some sort of discontinuity, where a and b are a long way apart but f(a) and f(b) are close -- and yet aren't all computable functions continuous or some such nonsense?"</p>

<a name="167826455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167826455" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167826455">Kevin Buzzard (Jun 11 2019 at 07:33)</a>:</h4>
<p>Here we have the discontinuity with f(1000000000000) and f(0) looking very close for the first gazillion entries, and yet f is still computable.</p>

<a name="167826630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167826630" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167826630">Kevin Buzzard (Jun 11 2019 at 07:36)</a>:</h4>
<p>I am quite good at "silly little maths puzzles" but I am much less good at these ones, because I have been brought up resolutely classical, so it's hard for me to tell the difference between option and roption. But because these are different things to you, you can tell which is which; they all just look like "some countable set" to me.</p>

<a name="167826680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167826680" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167826680">Kevin Buzzard (Jun 11 2019 at 07:37)</a>:</h4>
<p>This feels a bit like that embedding of nat into f : nat -&gt; nat from yesterday. These are somehow all implementation issues, computationally equivalent (but with different running times). I've never thought about these sorts of problems before in my life.</p>

<a name="167826711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167826711" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167826711">Kevin Buzzard (Jun 11 2019 at 07:37)</a>:</h4>
<p>I've spent 25 years living in a world where "computable" = "terminates instantly" and I had <code>noncomputable theory</code> at the top of the file anyway.</p>

<a name="167826712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167826712" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167826712">Mario Carneiro (Jun 11 2019 at 07:38)</a>:</h4>
<p>I think of it topologically - <code>roption</code> looks like the set {1/n...} \cup {0}</p>

<a name="167826765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167826765" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167826765">Kevin Buzzard (Jun 11 2019 at 07:38)</a>:</h4>
<p>It certainly does now.</p>

<a name="167826792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167826792" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167826792">Mario Carneiro (Jun 11 2019 at 07:39)</a>:</h4>
<p>so while there is an additional element, it isn't "apart" from the others, unlike <code>option</code> where it's a disjoint union</p>

<a name="167826891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167826891" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167826891">Mario Carneiro (Jun 11 2019 at 07:40)</a>:</h4>
<p>The <code>dint</code> example is actually computably isomorphic to <code>int</code>, because the constraint is that the functions are basically translations, so you don't get any of this "almost the same" business - you can just evaluate the function at any point to find out what it translates 0 to</p>

<a name="167826979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167826979" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167826979">Kevin Buzzard (Jun 11 2019 at 07:42)</a>:</h4>
<p>Right. My point is that given <code>dint</code> you know where to put it -- "it's the same as int". But your notion of "the same" is more refined than mine -- for me, option and roption are the same, and for things like enat you know whether it's option nat or roption nat.  For me, they're just all nat, because I've never been asked to think in this way.</p>

<a name="167826989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167826989" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167826989">Mario Carneiro (Jun 11 2019 at 07:42)</a>:</h4>
<p>surely you have a notion of topological distinctness though</p>

<a name="167827001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167827001" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167827001">Kevin Buzzard (Jun 11 2019 at 07:43)</a>:</h4>
<p>Oh <em>definitely</em>. I can certainly see that topologically they're not the same. I thought this was just an analogy though.</p>

<a name="167827013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167827013" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167827013">Mario Carneiro (Jun 11 2019 at 07:43)</a>:</h4>
<p>like there are different topologies on the same underlying points</p>

<a name="167827015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167827015" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167827015">Kevin Buzzard (Jun 11 2019 at 07:43)</a>:</h4>
<p>Sure.</p>

<a name="167827022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167827022" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167827022">Mario Carneiro (Jun 11 2019 at 07:43)</a>:</h4>
<p>it's not an analogy at all, there is literally a topological structure</p>

<a name="167827029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167827029" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167827029">Kevin Buzzard (Jun 11 2019 at 07:43)</a>:</h4>
<p>If you'd asked me to give you a continuous bijection with a discontinuous inverse, between two countable sets, I would have given you this instantly.</p>

<a name="167827093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167827093" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167827093">Kevin Buzzard (Jun 11 2019 at 07:44)</a>:</h4>
<p>I could well have given you that exact example in fact. But I don't see what this has to do with computability.</p>

<a name="167827094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167827094" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167827094">Mario Carneiro (Jun 11 2019 at 07:44)</a>:</h4>
<p>Domain theory is the branch of computer science that deals with putting topologies on all these types, such that the computable functions are continuous</p>

<a name="167827125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167827125" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167827125">Kevin Buzzard (Jun 11 2019 at 07:45)</a>:</h4>
<p>So if I put the topology on nat so that the closed sets are nat and the finite sets, what does domain theory tell me about that?</p>

<a name="167827146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167827146" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167827146">Kevin Buzzard (Jun 11 2019 at 07:45)</a>:</h4>
<p>That horrible non-Hausdorff topology is called the Zariski topology.</p>

<a name="167827152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167827152" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167827152">Kevin Buzzard (Jun 11 2019 at 07:45)</a>:</h4>
<p>(sort-of)</p>

<a name="167827327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167827327" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167827327">Mario Carneiro (Jun 11 2019 at 07:48)</a>:</h4>
<p>I don't think you can obtain all topologies via domain theory; it's usually phrased in terms of monotone functions on a chain complete partial order</p>

<a name="167827433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167827433" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167827433">Kevin Buzzard (Jun 11 2019 at 07:50)</a>:</h4>
<p>So just these "orderish" ones like 0 union 1/n maybe.</p>

<a name="167827445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167827445" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167827445">Mario Carneiro (Jun 11 2019 at 07:50)</a>:</h4>
<p>that said I can believe that your zariski example is representable</p>

<a name="167827465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167827465" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167827465">Kevin Buzzard (Jun 11 2019 at 07:51)</a>:</h4>
<p>It's what the topology on Spec(Z) is.</p>

<a name="167827542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167827542" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167827542">Kevin Buzzard (Jun 11 2019 at 07:52)</a>:</h4>
<p>What about if I say every even number is less than every odd number, but on even numbers and on odd numbers it's the usual &lt;=?</p>

<a name="167827548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167827548" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167827548">Kevin Buzzard (Jun 11 2019 at 07:52)</a>:</h4>
<p>the disjoint union of nat and nat</p>

<a name="167827553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167827553" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167827553">Kevin Buzzard (Jun 11 2019 at 07:52)</a>:</h4>
<p>omega+omega</p>

<a name="167827557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167827557" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167827557">Kevin Buzzard (Jun 11 2019 at 07:52)</a>:</h4>
<p>with the order topology.</p>

<a name="167827687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167827687" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167827687">Mario Carneiro (Jun 11 2019 at 07:55)</a>:</h4>
<p>aha, you can do zariski</p>

<a name="167827765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167827765" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167827765">Mario Carneiro (Jun 11 2019 at 07:56)</a>:</h4>
<p>you can take the representative of n to be a function which has 1 at <code>a, a+n, a+2n, ...</code> quotient over all choices of <code>a</code></p>

<a name="167827880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167827880" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167827880">Mario Carneiro (Jun 11 2019 at 07:58)</a>:</h4>
<p>the constraint is you should not ever be able to tell, given such a function, whether you actually have a representative of <code>n</code> or something else, but you can determine in finite time that two distinct elements are distinct</p>

<a name="167827989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167827989" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167827989">Mario Carneiro (Jun 11 2019 at 08:00)</a>:</h4>
<p>The epistemological interpretation is that the open sets represent your knowledge of the function at some point in time; you can knock off finitely many natural numbers as not being the represented value so the open sets are cofinite</p>

<a name="167828109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167828109" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167828109">Mario Carneiro (Jun 11 2019 at 08:02)</a>:</h4>
<p>It is possible to come up with arbitrary orders and interpret programming languages into those domains to get a funny model, but given a standard model you may not find your order represented</p>

<a name="167828111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167828111" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167828111">Kevin Buzzard (Jun 11 2019 at 08:02)</a>:</h4>
<p>The "Furstenburg topology" is the topology on Z induced from the profinite topology on the completion of Z; the closed sets are the arithmetic progressions.</p>

<a name="167828154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167828154" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167828154">Kevin Buzzard (Jun 11 2019 at 08:03)</a>:</h4>
<p>Anyway, this is just my mind wandering. Thanks for the roption example!</p>

<a name="167828217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167828217" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167828217">Kevin Buzzard (Jun 11 2019 at 08:04)</a>:</h4>
<p>I had no idea about this "topological model" of computability.</p>

<a name="167828236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167828236" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167828236">Mario Carneiro (Jun 11 2019 at 08:04)</a>:</h4>
<p>it kind of reminds me of some quantum computations... you can calculate the period of a periodic function efficiently without being able to get particular values</p>

<a name="167828427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167828427" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167828427">Kevin Buzzard (Jun 11 2019 at 08:06)</a>:</h4>
<p>That's how they factor large integers!</p>

<a name="167828437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167828437" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167828437">Mario Carneiro (Jun 11 2019 at 08:07)</a>:</h4>
<p>right, I'm thinking of shor's algorithm</p>

<a name="167828463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167828463" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167828463">Mario Carneiro (Jun 11 2019 at 08:07)</a>:</h4>
<p>maybe you can find a furstenburg topology in there</p>

<a name="167828809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167828809" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167828809">Mario Carneiro (Jun 11 2019 at 08:12)</a>:</h4>
<p>Oh, the zariski example doesn't quite work, because you can determine n if you find a and then search for the next set value. But permuting the values is actually a much more effective approach. You let the representative of <code>n</code> be a bijection between <code>nat</code> and <code>nat - {n}</code> (quotient over all such). Then given any such function you can never find <code>n</code>, you can only eliminate possible candidates for <code>n</code> by enumerating the members</p>

<a name="167829386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167829386" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167829386">Mario Carneiro (Jun 11 2019 at 08:21)</a>:</h4>
<p>Oh! I'm thinking too hard about this. The easy solution is to say that a representative is a monotone sequence of finsets whose union is <code>nat - {n}</code></p>

<a name="167829458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167829458" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167829458">Mario Carneiro (Jun 11 2019 at 08:22)</a>:</h4>
<p>and you can do the same trick to get the Furstenburg topology - a representative of n is a sequence of pairs (ai,di) such that ai = n (mod di) for all i, and such that n is uniquely determined by the full sequence</p>

<a name="167833777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167833777" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167833777">Reid Barton (Jun 11 2019 at 09:32)</a>:</h4>
<blockquote>
<p>The epistemological interpretation is that the open sets represent your knowledge of the function at some point in time; you can knock off finitely many natural numbers as not being the represented value so the open sets are cofinite</p>
</blockquote>
<p>Exercise for Kevin: What familiar topology do you get appllying this to the entire type <code>nat -&gt; bool</code>?</p>

<a name="167835218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167835218" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167835218">Kevin Buzzard (Jun 11 2019 at 09:53)</a>:</h4>
<p>I've been busy writing <a href="https://xenaproject.wordpress.com/2019/06/11/the-inverse-of-a-bijection/" target="_blank" title="https://xenaproject.wordpress.com/2019/06/11/the-inverse-of-a-bijection/">https://xenaproject.wordpress.com/2019/06/11/the-inverse-of-a-bijection/</a></p>

<a name="167835298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167835298" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167835298">Kevin Buzzard (Jun 11 2019 at 09:54)</a>:</h4>
<p>I'm going to guess that it's just the profinite topology on <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi mathvariant="double-struck">N</mi></msup></mrow><annotation encoding="application/x-tex">2^\mathbb{N}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.845223em;"></span><span class="strut bottom" style="height:0.845223em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathrm">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.845223em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathbb mtight">N</span></span></span></span></span></span></span></span></span></span></span></span>.</p>

<a name="167835347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167835347" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167835347">Kevin Buzzard (Jun 11 2019 at 09:55)</a>:</h4>
<p>The dumb algorithms will only end up evaluating functions at finitely many places</p>

<a name="167835402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167835402" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167835402">Kevin Buzzard (Jun 11 2019 at 09:56)</a>:</h4>
<p>So the issue seems to be whether there can be an algorithm which can end up evaluating functions at an arbitrarily large set of places and yet always be guaranteed to terminate.</p>

<a name="167835627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167835627" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167835627">Reid Barton (Jun 11 2019 at 09:59)</a>:</h4>
<p>I think you can rule that out with a compactness argument</p>

<a name="167835720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167835720" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167835720">Reid Barton (Jun 11 2019 at 10:00)</a>:</h4>
<p>Or Konig's lemma</p>

<a name="167836157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167836157" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167836157">Reid Barton (Jun 11 2019 at 10:07)</a>:</h4>
<p>So, in particular, pretty much any reasonable encoding of the p-adics will be assigned their usual profinite topology</p>

<a name="167846703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167846703" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167846703">David Michael Roberts (Jun 11 2019 at 12:53)</a>:</h4>
<p>I'm not sure if someone raised this above, but the space of infinite bit strings is the Cantor space 2^\mathbb{N} with the product topology (which probably coincides with the profinite topology). This is a metric space, and you should think of computable things as being <em>uniformly</em> continuous functions. IIRC there is no uniformly continuous function that picks out the streams that eventually have  a 1, as opposed to the ones that don't (or at least, this is the fable I tell myself in my head)</p>

<a name="167847998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167847998" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167847998">Kevin Buzzard (Jun 11 2019 at 13:08)</a>:</h4>
<p>I'd just come back to this thread with some more questions and perhaps David has answered one. </p>
<p>So yes by the profinite topology I meant the product topology. I am a bit confused about the metric space claim. sure I can put a metric space structure on it -- but I am equally sure that I can put two different metric space structures on it such that the uniformly continuous functions on one do not coincide with the uniformly continuous functions on the other. Is a product of uniform spaces a uniform space? Isn't a continuous function from a compact space automatically uniformly continuous anyway?</p>
<p>Reid, I am a bit confused about the logic of things here. I don't want to start using compactness arguments or Konig's lemma yet -- they are mathsy things so they don't see the notion of computability; they might see the notion of continuity, but I thought that's what we were trying to prove.</p>
<p>The claim washing around here seems to be that computable functions from <code>nat -&gt; bool</code> are continuous (or now we have this rival bid of uniformly continuous). So what about computable functions <code>(nat -&gt; bool) -&gt; nat</code>? What topology am I supposed to be putting on <code>nat</code> here? If the discrete topology, then continuous image of compact is compact so all continuous functions have finite image. Do all computable functions <code>(nat -&gt; bool) -&gt; nat</code>have finite image? </p>
<p>The general theorem can't be that the target always has the discrete topology though, becuase the identity function is a continuous function from <code>nat -&gt; bool</code> which has infinite image. </p>
<p>What is going on here?</p>

<a name="167848256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167848256" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167848256">David Michael Roberts (Jun 11 2019 at 13:11)</a>:</h4>
<p>In computable land, things are not so easy: <a href="https://link.springer.com/chapter/10.1007/11494645_3" target="_blank" title="https://link.springer.com/chapter/10.1007/11494645_3">https://link.springer.com/chapter/10.1007/11494645_3</a></p>

<a name="167848384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167848384" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167848384">David Michael Roberts (Jun 11 2019 at 13:13)</a>:</h4>
<p>Also, it might be something like not functions from Cantor space but functions from functionals on Cantor space. It's a bit too late here for me, so I should look up some references tomorrow. Certainly work of Andrej Bauer and of Martin Escardo is relevant here.</p>

<a name="167848534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167848534" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167848534">David Michael Roberts (Jun 11 2019 at 13:14)</a>:</h4>
<p>One more potentially relevant reference and I may come back to this tomorrow: <a href="https://www.jstor.org/stable/27590306?seq=1#page_scan_tab_contents" target="_blank" title="https://www.jstor.org/stable/27590306?seq=1#page_scan_tab_contents">https://www.jstor.org/stable/27590306?seq=1#page_scan_tab_contents</a></p>

<a name="167849040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167849040" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167849040">Reid Barton (Jun 11 2019 at 13:21)</a>:</h4>
<p>So you asked whether every computable (total) function from <code>nat -&gt; bool</code> to <code>bool</code> can only depend on the value of its argument at finitely many natural numbers.</p>

<a name="167849263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167849263" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167849263">Kevin Buzzard (Jun 11 2019 at 13:24)</a>:</h4>
<p>Oh yes, that was a question I meant to flag up again. If I have a computable function <code>(nat -&gt; bool) -&gt; nat</code> then is there some <code>B</code> such that the computable function does not depend on the values of the function which are greater than <code>B</code>? Note that this is not true for <code>(nat -&gt; bool) -&gt; (nat -&gt; bool)</code> so I am a bit bewildered about what's going on here.</p>

<a name="167849313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167849313" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167849313">Reid Barton (Jun 11 2019 at 13:25)</a>:</h4>
<p>The argument is going to go something like this. Suppose <code>F : (nat -&gt; bool) -&gt; bool</code> is not of this form, that is, there is no N such that <code>F</code> is determined by the restriction of its argument <code>f</code> to numbers less than N. The only thing that <code>F</code> can do with <code>f</code> is evaluate it at various values. So suppose <code>F</code> starts out by evaluating <code>f</code> at some value <code>i</code>.</p>

<a name="167849366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167849366" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167849366">Kevin Buzzard (Jun 11 2019 at 13:25)</a>:</h4>
<p>Aah, so the target is now <code>bool</code>? Is that always the target for these questions?</p>

<a name="167849481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167849481" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167849481">Reid Barton (Jun 11 2019 at 13:26)</a>:</h4>
<p><code>f</code> is going to return either <code>tt</code> or <code>ff</code>. Now in at least one of these two cases, <code>F</code> must still have the property that the result depends on infinitely many more values of <code>f</code>. (Otherwise, we could get a bound for the maximum index that <code>F</code> depends on.)</p>

<a name="167849618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167849618" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167849618">Reid Barton (Jun 11 2019 at 13:28)</a>:</h4>
<p>Let's say it's <code>tt</code>, and then mentally set <code>f i = tt</code> and continue running the algorithm. It has to next check the value of <code>f</code> at a new index <code>j</code>.</p>

<a name="167849670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167849670" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167849670">Reid Barton (Jun 11 2019 at 13:29)</a>:</h4>
<p>and again we can partially specify <code>f</code> in a way to ensure that <code>F</code> depends on infinitely many more of its values. (This is basically the proof of Konig's lemma happening here.)</p>

<a name="167849782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167849782" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167849782">Reid Barton (Jun 11 2019 at 13:30)</a>:</h4>
<p>Furthermore we may as well assume <code>j</code> is different from <code>i</code> since evaluating <code>f</code> at <code>i</code> again doesn't help <code>F</code>.</p>

<a name="167849865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167849865" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167849865">Reid Barton (Jun 11 2019 at 13:31)</a>:</h4>
<p>In this way we get an infinite sequence of constraints <code>f i0 = b0</code>, <code>f i1 = b1</code>, <code>f i2 = b2</code> ...<br>
Now choose a function <code>f</code> which satisfies all these constraints (this is a form of compactness), and run the algorithm for <code>F</code> on this <code>f</code>--it has to run forever, a contradiction because we assumed that the algorithm was total.</p>

<a name="167849993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167849993" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167849993">Reid Barton (Jun 11 2019 at 13:32)</a>:</h4>
<p>If we removed random bits of the space <code>nat -&gt; bool</code>, we might not be able to do the step where we picked <code>f</code>. For example, <code>nat</code> can be embedded within <code>nat -&gt; bool</code> and then the argument would break down at that step</p>

<a name="167850070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167850070" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167850070">Kevin Buzzard (Jun 11 2019 at 13:33)</a>:</h4>
<p>So if we stick to functions to <code>bool</code> we can guarantee they only query finitely many values, so they're continuous.</p>

<a name="167850377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167850377" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167850377">Reid Barton (Jun 11 2019 at 13:37)</a>:</h4>
<p>If you have a semidecidable subset of <code>nat -&gt; bool</code> then it's the union of the sets accepted by countably many functions <code>(nat -&gt; bool) -&gt; bool</code> (given by "run the semidecision procedure for <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.13889em;">T</span></span></span></span> steps, and return true if it accepts, otherwise false") and so it's an open subset.</p>

<a name="167885444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167885444" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167885444">Mario Carneiro (Jun 11 2019 at 20:02)</a>:</h4>
<p>This proof still works for <code>(nat -&gt; bool) -&gt; nat</code>, without any changes. It doesn't work for <code>(nat -&gt; bool) -&gt; (nat -&gt; bool)</code> because the values are now functions, which can delay the computation of <code>f</code> while still depending on infinitely many parts of it</p>

<a name="167885575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167885575" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167885575">Mario Carneiro (Jun 11 2019 at 20:03)</a>:</h4>
<p>what you can say is that in any case, finitely many evaluations of <code>f</code> are performed before a value is produced</p>

<a name="167886546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167886546" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167886546">Kevin Buzzard (Jun 11 2019 at 20:16)</a>:</h4>
<p>Sure in any run only finitely many evaluations occur. The question is whether there is a uniform bound independent of the function. Reid proved that this was true for functions to <code>bool</code>. What about functions to <code>nat</code>?</p>

<a name="167886986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167886986" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167886986">François G. Dorais (Jun 11 2019 at 20:22)</a>:</h4>
<blockquote>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">enat</span> <span class="o">:=</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">→</span> <span class="n">bool</span> <span class="bp">//</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">tt</span> <span class="bp">→</span> <span class="n">f</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="n">tt</span><span class="o">}</span>

<span class="n">def</span> <span class="n">f</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">→</span> <span class="n">enat</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">ff</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">n</span> <span class="n">h</span><span class="o">,</span> <span class="n">h</span><span class="bp">⟩</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">i</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">i</span> <span class="n">h</span><span class="o">,</span>
  <span class="o">(</span><span class="n">to_bool_iff</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="err">$</span> <span class="n">nat</span><span class="bp">.</span><span class="n">le_succ_of_le</span> <span class="err">$</span> <span class="o">(</span><span class="n">to_bool_iff</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="n">h</span><span class="bp">⟩</span>
</pre></div>


<p>the inverse to <code>f</code> is noncomputable</p>
</blockquote>
<p>Except that this is not a bijection! The statement <code>function.surjective f</code> is equivalent to <code>∀ (p : nat → bool), (∃ n, p n = tt) ∨ (∀ n, p n = ff)</code> (provably in plain Lean) but the latter is a non-provable instance of the law of excluded middle. In fact, the inverse becomes definable in Lean with the (somewhat stronger) assumption <code>[decidable  (∃ n, p n = tt)]</code>.</p>
<p>To return to <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>'s original question, what is missing from lean to prove that every bijection is invertible is the _Principle of Definite Description_, which is also known as the _Principle of Unique Choice_. In Lean, the Axiom of Choice is formulated as:</p>
<div class="codehilite"><pre><span></span><span class="kn">axiom</span> <span class="n">choice</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span>
</pre></div>


<p>The Axiom of Unique Choice can be formulated as follows:</p>
<div class="codehilite"><pre><span></span><span class="kn">axiom</span> <span class="n">unique_choice</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">subsingleton</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span>
</pre></div>


<p>Given a function <code>f : α → β</code>, <code>function.injective f</code> yields <code>Π (y : β), subsingleton { x :  α // f x = y }</code> and <code>function.surjective f</code> yields <code>Π (y : β), nonempty { x :  α // f x = y }</code> and thus <code>unique_choice</code> can be used to define the inverse.</p>
<p>Unlike <code>choice</code>, which gives classical logic by Diaconescu's Theorem and hence many noncomputable functions <code>nat → nat</code>, <code>unique_choice</code> has no consequence on the logic of Prop and cannot be used to prove the existence of a noncomputable function <code>nat → nat</code> in Lean. It does have interesting properties on the type structure of Lean. The main consequence is that <code>unique_choice</code> allows <code>Prop</code> to eliminate into <code>Type</code> and since <code>Prop</code> is impredicative, this makes the whole hierarchy of types impredicative as well. So the real problem for inverting bijections is with predicativity rather than computability. Assuming <code>unique_choice</code> every bijection has an inverse, but <span class="user-mention" data-user-id="110049">@Mario Carneiro</span>'s example is still not invertible since it is not provably bijective.</p>

<a name="167887052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167887052" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167887052">Reid Barton (Jun 11 2019 at 20:23)</a>:</h4>
<p>You can first prove that a computable function <code>(nat -&gt; bool) -&gt; nat</code> is bounded by the same kind of argument (otherwise we can construct an input for which the output exceeds N for every N).</p>

<a name="167887327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167887327" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167887327">Reid Barton (Jun 11 2019 at 20:27)</a>:</h4>
<p>Or since we already proved that computable functions to bool are continuous, consider the open cover by the sets <code>{f | F f = i}</code> and take a finite subcover.</p>

<a name="167888208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167888208" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167888208">Kevin Buzzard (Jun 11 2019 at 20:38)</a>:</h4>
<blockquote>
<p>Except that this is not a bijection! </p>
</blockquote>
<p>I can switch on some maths settings and then prove that it is, which surely means that it can't "not [be] a bijection" before -- it was just not <em>provably</em> a bijection or something.</p>

<a name="167888557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167888557" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167888557">François G. Dorais (Jun 11 2019 at 20:42)</a>:</h4>
<p>But, for most of these settings, if you switch on those settings you can also prove that every bijection has an inverse!</p>

<a name="167889424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167889424" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167889424">Chris Hughes (Jun 11 2019 at 20:52)</a>:</h4>
<p>em is weaker than full choice.</p>

<a name="167889462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167889462" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167889462">Chris Hughes (Jun 11 2019 at 20:52)</a>:</h4>
<p>I don't think em implies bijections have an inverse.</p>

<a name="167889564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167889564" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167889564">Kevin Buzzard (Jun 11 2019 at 20:54)</a>:</h4>
<p>Maths settings FTW</p>

<a name="167889605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167889605" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167889605">Mario Carneiro (Jun 11 2019 at 20:54)</a>:</h4>
<p>My claim has always been in the context of assume all classical axioms but not <code>noncomputable</code></p>

<a name="167889669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167889669" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167889669">Kevin Buzzard (Jun 11 2019 at 20:55)</a>:</h4>
<p>It's interesting. I always regard all of this non-maths stuff (computability, classicality) as just "non-maths stuff", but I am slowly beginning to be able to distinguish these various bogs from one another.</p>

<a name="167889679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167889679" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167889679">Mario Carneiro (Jun 11 2019 at 20:55)</a>:</h4>
<p>In constructive maths it is probably not possible, because a constructive proof that it is a bijection is basically an equiv</p>

<a name="167889791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167889791" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167889791">Kevin Buzzard (Jun 11 2019 at 20:56)</a>:</h4>
<p>I liked David Roberts' comment on my blog post -- if you think of functions as relations then one can prove that the inverse is a "functional relation" -- and yet it still doesn't arise from a function.</p>

<a name="167889811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167889811" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167889811">Mario Carneiro (Jun 11 2019 at 20:56)</a>:</h4>
<p>right, that's a good way to think about it</p>

<a name="167889816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167889816" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167889816">Kevin Buzzard (Jun 11 2019 at 20:56)</a>:</h4>
<p>In ZFC and classical first order logic is there a notion of computability?</p>

<a name="167889838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167889838" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167889838">Kevin Buzzard (Jun 11 2019 at 20:56)</a>:</h4>
<p>[indicating my still huge level of ignorance]</p>

<a name="167889862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167889862" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167889862">Kevin Buzzard (Jun 11 2019 at 20:57)</a>:</h4>
<p>because I thought that in ZFC a function was the same as a functional relation.</p>

<a name="167889948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167889948" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167889948">Mario Carneiro (Jun 11 2019 at 20:58)</a>:</h4>
<blockquote>
<blockquote>
<p>what you can say is that in any case, finitely many evaluations of <code>f</code> are performed before a value is produced</p>
</blockquote>
<p>Sure in any run only finitely many evaluations occur. The question is whether there is a uniform bound independent of the function. Reid proved that this was true for functions to <code>bool</code>. What about functions to <code>nat</code>?</p>
</blockquote>
<p>I mean that statement uniformly. For any computable closed term of <code>(nat -&gt; bool) -&gt; A</code>, there exists n such that the argument will be evaluated at most n times before the result becomes a value</p>

<a name="167890005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167890005" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167890005">Kevin Buzzard (Jun 11 2019 at 20:59)</a>:</h4>
<p>I see. But the value itself can depend on other arguments (e.g. <code>id</code> evaluates nothing and depends on everything)</p>

<a name="167890056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167890056" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167890056">Mario Carneiro (Jun 11 2019 at 21:00)</a>:</h4>
<p><code>id : (nat -&gt; bool) -&gt; (nat -&gt; bool)</code> does not evaluate the function <code>f</code> at all before returning <code>f</code></p>

<a name="167890130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167890130" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167890130">Mario Carneiro (Jun 11 2019 at 21:00)</a>:</h4>
<p><code>f</code> is assumed to already be a value here (i.e. a lambda) since it was passed to <code>id</code></p>

<a name="167890187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167890187" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167890187">Mario Carneiro (Jun 11 2019 at 21:01)</a>:</h4>
<p>the difference is that the meaning of "value" depends on the type in question</p>

<a name="167890198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167890198" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167890198">Mario Carneiro (Jun 11 2019 at 21:01)</a>:</h4>
<p>for <code>nat -&gt; bool</code>, a value is something of the form <code>\lam x : nat, e</code></p>

<a name="167890212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167890212" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167890212">Mario Carneiro (Jun 11 2019 at 21:01)</a>:</h4>
<p>for <code>bool</code>, a value is either <code>tt</code> or <code>ff</code>, and for <code>nat</code> a value is <code>succ $ ... $ succ 0</code></p>

<a name="167890229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167890229" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167890229">François G. Dorais (Jun 11 2019 at 21:02)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>  To be more precise with this last comment, it's totally fine to assume the full law of excluded middle in Prop. Since Prop can't eliminate into Type, you won't get any noncomputable functions out of that. But then you get into this awful scenario where you can prove the _existence_ of noncomputable functions <code>nat → nat</code> but you can't produce a single one: every closed term <code>nat → nat</code> is still computable. I find that scenario rather bizarre but I also like bizarre stuff... By the way, for the same reason, your question has a different answer if you ask for the _existence_ of an inverse rather than an actual term for the inverse.</p>

<a name="167890322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167890322" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167890322">Mario Carneiro (Jun 11 2019 at 21:03)</a>:</h4>
<p>there are noncomputable closed terms, e.g. unguarded use of <code>choice</code></p>

<a name="167890406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167890406" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167890406">François G. Dorais (Jun 11 2019 at 21:04)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>: Yes, that's my point. With <code>choice</code> every bijection has an inverse.</p>

<a name="167890441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167890441" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167890441">Mario Carneiro (Jun 11 2019 at 21:04)</a>:</h4>
<p>I'm talking about classical + computable though, where you are allowed to use <code>choice</code> but only to prove a proposition</p>

<a name="167890490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167890490" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167890490">Mario Carneiro (Jun 11 2019 at 21:05)</a>:</h4>
<p>in particular that means that if you only ask for existence of an inverse it's easy since you just use choice to construct a noncomputable function, and then the exists shields the noncomputability</p>

<a name="167890494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167890494" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167890494">François G. Dorais (Jun 11 2019 at 21:05)</a>:</h4>
<p>Yes, then you can prove the _existence_ of an inverse but you can't get to the inverse without eliminating the proposition.</p>

<a name="167890640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167890640" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167890640">Mario Carneiro (Jun 11 2019 at 21:07)</a>:</h4>
<blockquote>
<p>In ZFC and classical first order logic is there a notion of computability?</p>
</blockquote>
<p>No, except of course for the deep embedding, a.k.a the usual notion of computability by math/cs using turing machines or whatever</p>

<a name="167890720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167890720" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167890720">Kevin Buzzard (Jun 11 2019 at 21:08)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">function</span><span class="bp">.</span><span class="n">bijective</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">g</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">X</span><span class="o">,</span> <span class="n">true</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>


<p>I don't know how to prove this constructively :-(</p>

<a name="167890742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167890742" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167890742">Kevin Buzzard (Jun 11 2019 at 21:08)</a>:</h4>
<p>The only constructor I know for exists is "just show me the function" and that's exactly what I can't do.</p>

<a name="167890750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167890750" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167890750">Mario Carneiro (Jun 11 2019 at 21:08)</a>:</h4>
<p>the proof uses <code>choice</code></p>

<a name="167890792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167890792" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167890792">Mario Carneiro (Jun 11 2019 at 21:09)</a>:</h4>
<p>or at least <code>unique_choice</code></p>

<a name="167890800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167890800" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167890800">Kevin Buzzard (Jun 11 2019 at 21:09)</a>:</h4>
<p>oh I see, but it's still computable probably [goes to check]</p>

<a name="167891429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167891429" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167891429">Kevin Buzzard (Jun 11 2019 at 21:19)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span>

<span class="n">def</span> <span class="n">equiv_thing</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">function</span><span class="bp">.</span><span class="n">bijective</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">g</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">X</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">g</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">g</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">choose</span> <span class="n">g</span> <span class="n">hg</span> <span class="kn">using</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span><span class="o">,</span> <span class="n">hf</span><span class="bp">.</span><span class="mi">2</span> <span class="n">y</span><span class="o">),</span>
  <span class="n">use</span> <span class="n">g</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span> <span class="n">swap</span><span class="o">,</span> <span class="n">exact</span> <span class="n">hg</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">x</span><span class="o">,</span> <span class="n">apply</span> <span class="n">hf</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span> <span class="n">exact</span> <span class="n">hg</span> <span class="bp">_</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p>I love that <code>choose</code> tactic; it makes that argument so much easier than it used to be.</p>

<a name="167891515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167891515" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167891515">Kenny Lau (Jun 11 2019 at 21:20)</a>:</h4>
<p>you can eta-reduce <code>fun y, hf.2 y</code></p>

<a name="167891935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167891935" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167891935">Kevin Buzzard (Jun 11 2019 at 21:27)</a>:</h4>
<p>Eta reduction is defeq for pi types but not for inductive tires</p>

<a name="167891977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167891977" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167891977">Mario Carneiro (Jun 11 2019 at 21:27)</a>:</h4>
<p>did autocorrect change tyre to tire there?</p>

<a name="167892057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167892057" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167892057">Kevin Buzzard (Jun 11 2019 at 21:28)</a>:</h4>
<p>Maybe it's bed time, I seem to have spent all day thinking about type theory</p>

<a name="167892112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167892112" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167892112">Mario Carneiro (Jun 11 2019 at 21:29)</a>:</h4>
<p>eta reduction is defeq for inductive types, although sometimes lean gets confused</p>

<a name="167892567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167892567" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167892567">Mario Carneiro (Jun 11 2019 at 21:35)</a>:</h4>
<p>hey, a reasonable application of <code>axiom_of_choice</code>:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">equiv_thing</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">function</span><span class="bp">.</span><span class="n">bijective</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">g</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">X</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">g</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">g</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">let</span> <span class="bp">⟨</span><span class="n">g</span><span class="o">,</span> <span class="n">hg</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">classical</span><span class="bp">.</span><span class="n">axiom_of_choice</span> <span class="n">hf</span><span class="bp">.</span><span class="mi">2</span> <span class="k">in</span>
<span class="bp">⟨</span><span class="n">g</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">hf</span><span class="bp">.</span><span class="mi">1</span> <span class="o">(</span><span class="n">hg</span> <span class="bp">_</span><span class="o">),</span> <span class="n">hg</span><span class="bp">⟩</span>
</pre></div>

<a name="167892809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167892809" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167892809">Reid Barton (Jun 11 2019 at 21:38)</a>:</h4>
<p>Personally I've always found <code>choice</code> philosophically dubious, and I'd much prefer to stick to <code>axiom_of_choice</code> plus <code>unique_choice</code> wherever possible</p>

<a name="167892853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167892853" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167892853">Kevin Buzzard (Jun 11 2019 at 21:39)</a>:</h4>
<blockquote>
<p>Personally I've always found <code>choice</code> philosophically dubious, and I'd much prefer to stick to <code>axiom_of_choice</code> plus <code>unique_choice</code> wherever possible</p>
</blockquote>
<p>I put that sort of comment in the same box as "personally I find castling philosophically dubious in chess". Isn't it all a game?</p>

<a name="167892945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167892945" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167892945">Reid Barton (Jun 11 2019 at 21:41)</a>:</h4>
<p>It's another part of the "mathematicians' rules of conduct" I guess. We don't make definitions that depend on which element <code>choice</code>produces.</p>

<a name="167892962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167892962" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167892962">Kevin Buzzard (Jun 11 2019 at 21:41)</a>:</h4>
<blockquote>
<p>eta reduction is defeq for inductive types, although sometimes lean gets confused</p>
</blockquote>
<p>The proof of <code>complex.eta</code> is not <code>rfl</code>, it's <code>cases, rfl</code></p>

<a name="167893023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167893023" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167893023">Reid Barton (Jun 11 2019 at 21:42)</a>:</h4>
<p>If you replace <code>choice</code> by <code>axiom_of_choice</code>+<code>unique_choice</code> then you're forced to prove, for example, that the dimension of a vector space does not depend on the choice of basis</p>

<a name="167893689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167893689" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167893689">Mario Carneiro (Jun 11 2019 at 21:52)</a>:</h4>
<p>oh, right there are multiple things called eta</p>

<a name="167893700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167893700" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167893700">Mario Carneiro (Jun 11 2019 at 21:52)</a>:</h4>
<p>I'm not sure what I thought you meant</p>

<a name="167893748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167893748" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167893748">Mario Carneiro (Jun 11 2019 at 21:53)</a>:</h4>
<p><code>axiom_of_choice</code> + <code>unique_choice</code> makes type theory look basically like ZFC</p>

<a name="167894615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167894615" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167894615">Mario Carneiro (Jun 11 2019 at 22:05)</a>:</h4>
<p>However, it doesn't really affect proofs very much, you can just have a long lived hypothesis <code>variable [has_choice]</code> and do this:</p>
<div class="codehilite"><pre><span></span><span class="kn">universe</span> <span class="n">u</span>
<span class="n">class</span> <span class="n">has_choice</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="o">:=</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">,</span> <span class="n">nonempty</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>

<span class="kn">theorem</span> <span class="n">unchoice</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">[</span><span class="n">has_choice</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">}],</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="o">:=</span>
<span class="k">let</span> <span class="bp">⟨</span><span class="n">F</span><span class="o">,</span> <span class="bp">_⟩</span> <span class="o">:=</span> <span class="n">classical</span><span class="bp">.</span><span class="n">axiom_of_choice</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">,</span>
  <span class="k">show</span> <span class="bp">∃</span> <span class="n">f</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">,</span> <span class="n">true</span><span class="o">,</span> <span class="k">from</span>
  <span class="k">let</span> <span class="bp">⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">hf</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">classical</span><span class="bp">.</span><span class="n">axiom_of_choice</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="n">α</span><span class="o">,</span>
    <span class="n">exists_true_iff_nonempty</span><span class="bp">.</span><span class="mi">2</span> <span class="n">h</span><span class="o">)</span> <span class="k">in</span> <span class="bp">⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">trivial</span><span class="bp">⟩</span><span class="o">)</span> <span class="k">in</span>
<span class="bp">@</span><span class="n">H</span> <span class="bp">⟨</span><span class="n">F</span><span class="bp">⟩</span>
</pre></div>

<a name="167894735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167894735" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167894735">Mario Carneiro (Jun 11 2019 at 22:07)</a>:</h4>
<p>I think <code>choice</code> is the idea that since doing this is needless boilerplate we may as well just pick a global choice function</p>

<a name="167895436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167895436" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167895436">Reid Barton (Jun 11 2019 at 22:18)</a>:</h4>
<p>It's harmless for proofs but not for definitions</p>

<a name="167895787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167895787" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167895787">Mario Carneiro (Jun 11 2019 at 22:24)</a>:</h4>
<p>for definitions, you can just put <code>[has_choice]</code> in the arguments to the definition</p>

<a name="167898728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167898728" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167898728">François G. Dorais (Jun 11 2019 at 23:03)</a>:</h4>
<blockquote>
<p>em is weaker than full choice.</p>
</blockquote>
<p>Sorry <span class="user-mention" data-user-id="110044">@Chris Hughes</span>, I think an earlier reply was partly mistakenly written to Kevin instead of  you. You are totally right that EM for Prop is very weak and almost harmless. However, it becomes dangerous in combination with <code>unique_choice</code>, even locally!</p>
<div class="codehilite"><pre><span></span><span class="kn">section</span>
<span class="kn">parameter</span> <span class="n">unique_choice</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">subsingleton</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∨</span> <span class="bp">¬</span> <span class="n">p</span><span class="o">)</span>

<span class="n">def</span> <span class="n">nonempty_decidable_of_em</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="o">(</span><span class="n">decidable</span> <span class="n">p</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">or</span><span class="bp">.</span><span class="n">elim</span> <span class="n">h</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">nonempty</span><span class="bp">.</span><span class="n">intro</span> <span class="o">(</span><span class="n">decidable</span><span class="bp">.</span><span class="n">is_true</span> <span class="n">h</span><span class="o">))</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">nonempty</span><span class="bp">.</span><span class="n">intro</span> <span class="o">(</span><span class="n">decidable</span><span class="bp">.</span><span class="n">is_false</span> <span class="n">h</span><span class="o">))</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">decidable</span><span class="bp">.</span><span class="n">subsingleton</span> <span class="c1">-- show instance</span>

<span class="n">def</span> <span class="n">decidable_of_em</span> <span class="o">:</span> <span class="n">decidable</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">unique_choice</span> <span class="o">(</span><span class="n">nonempty_decidable_of_em</span> <span class="n">h</span><span class="o">)</span>

<span class="kn">end</span>
</pre></div>

<a name="167900106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167900106" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167900106">Mario Carneiro (Jun 11 2019 at 23:23)</a>:</h4>
<p>what's wrong with that? A mathematician would think that's fine</p>

<a name="167900119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167900119" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167900119">Mario Carneiro (Jun 11 2019 at 23:23)</a>:</h4>
<p>it's basically saying that <code>if p then 1 else 0</code> exists</p>

<a name="167900221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167900221" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167900221">Mario Carneiro (Jun 11 2019 at 23:25)</a>:</h4>
<p>which is a perfectly fine ZFC-ish thing to do</p>

<a name="167900226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167900226" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167900226">Mario Carneiro (Jun 11 2019 at 23:25)</a>:</h4>
<p>it's just not computable</p>

<a name="167900398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167900398" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167900398">François G. Dorais (Jun 11 2019 at 23:28)</a>:</h4>
<p>Yes, 100% of mathematicians (including me!) believe in Unique Choice. But this is not about mathematics, it's about the type theory of Lean. The problem is that it systematically breaks predicativity, even locally. So if Lean insists on predicativity of Type, Unique Choice is not an option.</p>

<a name="167900593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167900593" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167900593">François G. Dorais (Jun 11 2019 at 23:33)</a>:</h4>
<p>For what it's worth, I think Lean should have an "impredicative mode" where Unique Choice is true (but not full choice). This mode would make a lot of universe issues wash away, but it may have other consequences where ignoring props would trickle up to ignoring some types... This option needs a deeper look but it would match better with mathematics where types are also occasionally ignored.</p>

<a name="167901343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167901343" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167901343">François G. Dorais (Jun 11 2019 at 23:44)</a>:</h4>
<p>This trickling, combined with simpler universe constraint calculations, might make typing undecidable. That's the main implementation issue.</p>

<a name="167901557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167901557" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167901557">Mario Carneiro (Jun 11 2019 at 23:49)</a>:</h4>
<p>Do you still want computability in your impredicative mode?</p>

<a name="167901568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167901568" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167901568">Mario Carneiro (Jun 11 2019 at 23:49)</a>:</h4>
<p>because that basically means you can't erase anything</p>

<a name="167901644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167901644" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167901644">Mario Carneiro (Jun 11 2019 at 23:50)</a>:</h4>
<p>so you lose the ability to have "programs with assertions"</p>

<a name="167901680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167901680" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167901680">Mario Carneiro (Jun 11 2019 at 23:50)</a>:</h4>
<p>This is what actually happens in most HoTT libraries, but I don't think it's particularly practical for computation</p>

<a name="167901767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167901767" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167901767">Mario Carneiro (Jun 11 2019 at 23:52)</a>:</h4>
<p><code>unique_choice</code> on its own doesn't make anything undecidable. But perhaps you want a computation rule such as <code>unique_choice _ _ &lt;a&gt; ~&gt; a</code></p>

<a name="167901817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167901817" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167901817">Mario Carneiro (Jun 11 2019 at 23:53)</a>:</h4>
<p>I don't see it fixing any universe issues, although computation may end up doing weird things with universes</p>

<a name="167902383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167902383" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167902383">François G. Dorais (Jun 12 2019 at 00:04)</a>:</h4>
<p>Yes, that mode is for mathematics only. To obtain a computation, we would need to remove the mode and resolve the predicativity issues manually. In theory, this is possible but with the impredicative mode, Lean could accept things that are actually beyond what plain Lean can handle, so there is no choice but to do this process manually.</p>

<a name="167902418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167902418" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167902418">Mario Carneiro (Jun 12 2019 at 00:05)</a>:</h4>
<p>what are the impredicative constructions you envision?</p>

<a name="167902461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167902461" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167902461">Mario Carneiro (Jun 12 2019 at 00:06)</a>:</h4>
<p>lean can already do impredicative stuff with Prop</p>

<a name="167902488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167902488" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167902488">Mario Carneiro (Jun 12 2019 at 00:07)</a>:</h4>
<p>if you don't care about computation, then it seems like you can just have <code>choice</code>in Type and just ignore <code>noncomputable</code></p>

<a name="167902984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167902984" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167902984">François G. Dorais (Jun 12 2019 at 00:19)</a>:</h4>
<p>That doesn't work because noncomputable can't be eliminated, any derived term in Type* is noncomputable as well and must be marked that way. This can be mitigated by using type classes, but that only covers standardized ways of eliminating noncomputable axioms whereas the full process requires some creativity.</p>

<a name="167903262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167903262" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167903262">François G. Dorais (Jun 12 2019 at 00:25)</a>:</h4>
<p>The larger issue is that Math Computable and Lean Computable mean different things. In mathematics, computable is a computation that _happens_ to always terminate, but plain Lean requires more. The mode I'm proposing is an in-between, where some principles such as <code>unique choice</code> are accepted as rules (because they are admissible) but not necessarily as axioms. Then the admissible rules could be eliminated manually, if needed, to get a plain term.</p>

<a name="167903786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167903786" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167903786">Mario Carneiro (Jun 12 2019 at 00:32)</a>:</h4>
<p>noncomputable can't be eliminated but it can be ignored</p>

<a name="167903809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167903809" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167903809">Mario Carneiro (Jun 12 2019 at 00:33)</a>:</h4>
<p>actually you can trivially make noncomputable types computable</p>

<a name="167903907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167903907" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167903907">Mario Carneiro (Jun 12 2019 at 00:35)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">axiom</span> <span class="n">foo</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="n">def</span> <span class="n">foo&#39;</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">id</span> <span class="n">foo</span>
</pre></div>

<a name="167904097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167904097" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167904097">Mario Carneiro (Jun 12 2019 at 00:39)</a>:</h4>
<blockquote>
<p>The larger issue is that Math Computable and Lean Computable mean different things. In mathematics, computable is a computation that _happens_ to always terminate, but plain Lean requires more.</p>
</blockquote>
<p>Actually, I would argue that lean's (non)<code>noncomputable</code> + classical axioms matches math computable pretty well. Here "happens to terminate" is expressed as "classically proven to terminate", which is not exactly the same because of the gap between provability and truth, but it's indistinguishable from within the system</p>

<a name="167904287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167904287" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167904287">Mario Carneiro (Jun 12 2019 at 00:43)</a>:</h4>
<p><code>unique_choice</code> is not admissible as a computable axiom, without changing the interpretation of Prop, but it is admissible as a noncomputable axiom if you think ZF is reasonable. Even <code>choice</code> is admissible as a noncomputable axiom if you think ZFC + some universes is reasonable</p>

<a name="167904750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167904750" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167904750">François G. Dorais (Jun 12 2019 at 00:52)</a>:</h4>
<p>I think <code>unique_choice</code> might still be admissible as a _rule_. I still don't know how it plays with inductive construction, which is just another bunch of rules (if you want to think about them that way) but rules aren't necessarily compatible.</p>

<a name="167904782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167904782" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167904782">Mario Carneiro (Jun 12 2019 at 00:53)</a>:</h4>
<p>what do you mean by "as a rule"?</p>

<a name="167904925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167904925" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167904925">François G. Dorais (Jun 12 2019 at 00:56)</a>:</h4>
<p>A deduction rule rather than as an axiom (an actual constant).</p>

<a name="167904947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167904947" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167904947">Mario Carneiro (Jun 12 2019 at 00:56)</a>:</h4>
<p>I don't see any way that a term constructor could end up differing in any essential way from a constant given all the other stuff in DTT</p>

<a name="167904991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167904991" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167904991">Mario Carneiro (Jun 12 2019 at 00:57)</a>:</h4>
<p>If you allow a context in your rule, then I will just lambda abstract and build the constant</p>

<a name="167905027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167905027" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167905027">François G. Dorais (Jun 12 2019 at 00:58)</a>:</h4>
<p>Proofs are finite. Axioms are more powerful than rules.</p>

<a name="167905056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167905056" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167905056">Mario Carneiro (Jun 12 2019 at 00:58)</a>:</h4>
<p>Unless you put an unusual constraint on the rule, it's equivalent</p>

<a name="167905076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/bijection%20with%20noncomputable%20inverse/near/167905076" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/70759bijectionwithnoncomputableinverse.html#167905076">Mario Carneiro (Jun 12 2019 at 00:59)</a>:</h4>
<p>so I'm asking what the constraint is</p>


{% endraw %}
