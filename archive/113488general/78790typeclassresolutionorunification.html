---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/78790typeclassresolutionorunification.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html">type class resolution or unification?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="125265237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125265237" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125265237">Kevin Buzzard (Apr 18 2018 at 18:32)</a>:</h4>
<p>This question might be too vague to answer. I have a fixed type <code>X</code> and I am doing a lot of work with functions from <code>{U : set X // P U}</code> to <code>Type*</code> (for example, <code>X</code> might be a topological space and the functions might assign a type to each open set in <code>X</code>, but I also consider more general possibilities for <code>P</code>, e.g. <code>P</code> might say "<code>U</code> is in a fixed basis for the topological space"). I seem to have three different ways to set up such functions.</p>

<a name="125265251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125265251" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125265251">Kevin Buzzard (Apr 18 2018 at 18:32)</a>:</h4>
<p>1) I could look at functions on subtypes, as I wrote above. I don't do this. I think subtypes are messy and would be forever taking them apart.</p>

<a name="125265280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125265280" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125265280">Kevin Buzzard (Apr 18 2018 at 18:33)</a>:</h4>
<p>2) I could define my functions as <code>lam {U} (H : P U), ...</code></p>

<a name="125265322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125265322" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125265322">Kevin Buzzard (Apr 18 2018 at 18:34)</a>:</h4>
<p>3) I could define my functions as <code>lam U [H : P U], ...</code></p>

<a name="125265336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125265336" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125265336">Kevin Buzzard (Apr 18 2018 at 18:34)</a>:</h4>
<p>I don't like (3) because it relies on the type class inference system and for my own types P it would rely on my getting the system to work.</p>

<a name="125265360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125265360" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125265360">Kevin Buzzard (Apr 18 2018 at 18:35)</a>:</h4>
<p>I used to be using (4) <code>lam U (H : P U)</code> but I just got sick of constantly writing U when it could be inferred from HU, so I just switched to (2).</p>

<a name="125265371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125265371" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125265371">Kevin Buzzard (Apr 18 2018 at 18:35)</a>:</h4>
<p>I am now looking at (2) thinking "ugh, my functions are supposed to be eating open sets and they're now eating proofs, that looks a bit weird"</p>

<a name="125265469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125265469" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125265469">Chris Hughes (Apr 18 2018 at 18:37)</a>:</h4>
<p>I like (2). Same number of arguments, but you don't have to rely on type classes. So long as you always have a proof of <code>P U</code> to hand.</p>

<a name="125265532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125265532" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125265532">Kevin Buzzard (Apr 18 2018 at 18:39)</a>:</h4>
<p>Are there any arguments for or against any of (1) to (4)? I am 99.9% convinced that I could get any of (1), (2) or (4) working. I simply don't know whether I could get (3) working; in my mind it would be by far the "riskiest" approach. These functions are everywhere in my code and I am constantly coming up with proofs that various sets have property <code>P</code>; in the case <code>P</code> is "I am an open set" then some of these are in mathlib. I would probably have to go around making a whole bunch of things instances, and even then I'm not convinced that I would be able to cover everything (e.g. these functions might show up as part of structures, where the proof of <code>P U</code> is somewhere else in the structure and I am not 100 percent convinced that type class inference can get me to it).</p>

<a name="125265593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125265593" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125265593">Kevin Buzzard (Apr 18 2018 at 18:40)</a>:</h4>
<p>I used (4) for open sets and (2) for bases of open sets, and both worked fine, so I switched to (2) because it made my code shorter.</p>

<a name="125265703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125265703" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125265703">Kevin Buzzard (Apr 18 2018 at 18:42)</a>:</h4>
<p>...and possibly slightly less readable -- e.g. open sets like <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>f</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>(</mo><mi>V</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f^{-1}(V)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathrm mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span> (which was easy to read) have now been removed and replaced by hypotheses like "I am a lemma in mathlib saying the pre-image of an open set under a continuous function is open".</p>

<a name="125265721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125265721" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125265721">Kevin Buzzard (Apr 18 2018 at 18:43)</a>:</h4>
<p>On the other hand I am using type class inference for rings (the functions map open sets to rings) and sometimes it just doesn't work and it's easier to do the <code>@</code> dance than try to figure out why it didn't work.</p>

<a name="125265734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125265734" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125265734">Chris Hughes (Apr 18 2018 at 18:43)</a>:</h4>
<p>(1) has no advantages other than proving things like injectivity where the function has to be <code>α → β</code>, but I don't think you want to do that. (4) does have the advantage of readability. <code>some _</code> is a nightmare in this regard.</p>

<a name="125265779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125265779" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125265779">Kenny Lau (Apr 18 2018 at 18:44)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> it's amazing how we went from knowing nothing about type theory to having an opinion on them</p>

<a name="125265780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125265780" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125265780">Kevin Buzzard (Apr 18 2018 at 18:44)</a>:</h4>
<p>yes.</p>

<a name="125265784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125265784" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125265784">Kevin Buzzard (Apr 18 2018 at 18:44)</a>:</h4>
<p>I've learnt so much this year.</p>

<a name="125265795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125265795" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125265795">Kenny Lau (Apr 18 2018 at 18:44)</a>:</h4>
<p>the best way to learn maths is indeed to play with them</p>

<a name="125265805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125265805" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125265805">Kenny Lau (Apr 18 2018 at 18:45)</a>:</h4>
<p>people just learn symbols without the meanings</p>

<a name="125265810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125265810" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125265810">Kenny Lau (Apr 18 2018 at 18:45)</a>:</h4>
<p>(x+y)^2 = x^2+2xy+y^2</p>

<a name="125265811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125265811" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125265811">Kevin Buzzard (Apr 18 2018 at 18:45)</a>:</h4>
<p>I am very much in two minds about whether I want my code to be readable though.</p>

<a name="125265812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125265812" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125265812">Kenny Lau (Apr 18 2018 at 18:45)</a>:</h4>
<p>means nothing</p>

<a name="125265819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125265819" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125265819">Kenny Lau (Apr 18 2018 at 18:45)</a>:</h4>
<p>but whenever you are told to expand it, you go from left to right</p>

<a name="125265829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125265829" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125265829">Kevin Buzzard (Apr 18 2018 at 18:45)</a>:</h4>
<p>here it means "about 6 invocations of the axioms of a ring" :-)</p>

<a name="125265831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125265831" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125265831">Andrew Ashworth (Apr 18 2018 at 18:46)</a>:</h4>
<p>i think you should not worry too much about your code being readable in tactic mode</p>

<a name="125265888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125265888" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125265888">Andrew Ashworth (Apr 18 2018 at 18:46)</a>:</h4>
<p>i don't think there's any way to understand tactic mode without going through the proofs line by line</p>

<a name="125265901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125265901" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125265901">Moses Schönfinkel (Apr 18 2018 at 18:47)</a>:</h4>
<p>Technically Coq is all tactic mode and you can write readable proofs just fine :).</p>

<a name="125265962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125265962" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125265962">Andrew Ashworth (Apr 18 2018 at 18:48)</a>:</h4>
<p>chlipala disagrees :)</p>

<a name="125265965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125265965" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125265965">Kevin Buzzard (Apr 18 2018 at 18:48)</a>:</h4>
<p>I think I read some quote by Paulson arguing that readability was super-important</p>

<a name="125265968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125265968" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125265968">Andrew Ashworth (Apr 18 2018 at 18:48)</a>:</h4>
<p>and that's the biggest difference between the isabelle style and the coq style</p>

<a name="125265970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125265970" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125265970">Kevin Buzzard (Apr 18 2018 at 18:48)</a>:</h4>
<p>I see.</p>

<a name="125265972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125265972" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125265972">Moses Schönfinkel (Apr 18 2018 at 18:48)</a>:</h4>
<p>Adam Disagrees and then writes CPDT, which has yet to be deciphered :).</p>

<a name="125266045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125266045" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125266045">Andrew Ashworth (Apr 18 2018 at 18:50)</a>:</h4>
<p>well, readability is definitely important, but do you want to make a second pass over all your proofs?</p>

<a name="125266060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125266060" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125266060">Andrew Ashworth (Apr 18 2018 at 18:50)</a>:</h4>
<p>you can write out many of the intermediate steps with show, have, and give many comments, and that is certainly great</p>

<a name="125266138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125266138" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125266138">Kevin Buzzard (Apr 18 2018 at 18:52)</a>:</h4>
<p>The last big proof I wrote (compactness of a certain topological space), every few lines I wrote down what the goal was (in mathematical language) and what I was going to do next.</p>

<a name="125266142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125266142" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125266142">Kevin Buzzard (Apr 18 2018 at 18:52)</a>:</h4>
<p>So "unreadable" proof but readable comments</p>

<a name="125266222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125266222" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125266222">Andrew Ashworth (Apr 18 2018 at 18:54)</a>:</h4>
<p>in isabelle some authors go so far as to write a latex proof in the comments next to the formal derivation</p>

<a name="125266226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125266226" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125266226">Kenny Lau (Apr 18 2018 at 18:54)</a>:</h4>
<p>in isabelle one forgets computability</p>

<a name="125266580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125266580" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125266580">Kevin Buzzard (Apr 18 2018 at 19:02)</a>:</h4>
<p>In the future there will be files which humans read which will look like beautifully typeset mathematics and which will unfold into computer-checked proofs.</p>

<a name="125266586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125266586" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125266586">Kevin Buzzard (Apr 18 2018 at 19:02)</a>:</h4>
<p>I hope to see it before I die.</p>

<a name="125266609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125266609" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125266609">Andrew Ashworth (Apr 18 2018 at 19:03)</a>:</h4>
<p>perhaps... you have to wonder why coq and isabelle never took off. well, maybe people just need to be exposed to it more</p>

<a name="125266776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125266776" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125266776">Sebastien Gouezel (Apr 18 2018 at 19:07)</a>:</h4>
<p>Speaking of readability, I just wrote a proof like that:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">eventually_bdd_above_iff_exists_eventually_le</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">u</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span>
<span class="o">(</span><span class="n">eventually_bdd_above</span> <span class="n">F</span> <span class="n">u</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">∃</span><span class="n">t</span><span class="o">,</span> <span class="n">eventually</span> <span class="o">(</span><span class="bp">λ</span><span class="n">n</span><span class="o">,</span> <span class="n">u</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">t</span><span class="o">)</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">have</span> <span class="n">A</span><span class="o">:</span> <span class="n">eventually_bdd_above</span> <span class="n">F</span> <span class="n">u</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span><span class="n">t</span><span class="o">,</span> <span class="n">eventually</span> <span class="o">(</span><span class="bp">λ</span><span class="n">n</span><span class="o">,</span> <span class="n">u</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">t</span><span class="o">)</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">assume</span> <span class="bp">⟨</span><span class="n">su</span><span class="o">,</span> <span class="n">suF</span><span class="o">,</span> <span class="n">tu</span><span class="o">,</span> <span class="n">tuH</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">eventually</span> <span class="o">(</span><span class="bp">λ</span><span class="n">n</span><span class="o">,</span> <span class="n">u</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">tu</span><span class="o">)</span> <span class="n">F</span> <span class="o">:=</span>
  <span class="k">begin</span>
    <span class="n">apply</span> <span class="n">filter</span><span class="bp">.</span><span class="n">upwards_sets</span> <span class="n">F</span> <span class="n">suF</span><span class="o">,</span>
    <span class="k">assume</span> <span class="o">(</span><span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">Hy</span><span class="o">),</span>
    <span class="n">apply</span> <span class="n">tuH</span> <span class="bp">_</span> <span class="o">(</span><span class="n">mem_image_of_mem</span> <span class="bp">_</span> <span class="n">Hy</span><span class="o">)</span>
  <span class="kn">end</span><span class="o">,</span>
  <span class="bp">⟨</span><span class="n">tu</span><span class="o">,</span> <span class="k">by</span> <span class="n">assumption</span><span class="bp">⟩</span><span class="o">,</span>
<span class="k">have</span> <span class="n">B</span><span class="o">:</span> <span class="o">(</span><span class="bp">∃</span><span class="n">t</span><span class="o">,</span> <span class="n">eventually</span> <span class="o">(</span><span class="bp">λ</span><span class="n">n</span><span class="o">,</span> <span class="n">u</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">t</span><span class="o">)</span> <span class="n">F</span><span class="o">)</span> <span class="bp">→</span> <span class="n">eventually_bdd_above</span> <span class="n">F</span> <span class="n">u</span> <span class="o">:=</span>
  <span class="k">assume</span> <span class="bp">⟨</span><span class="n">t</span><span class="o">,</span> <span class="n">Ht</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">bdd_above</span> <span class="o">(</span><span class="n">u</span> <span class="err">&#39;&#39;</span> <span class="o">{</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">|</span> <span class="n">u</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">t</span><span class="o">})</span> <span class="o">:=</span>
  <span class="k">begin</span>
    <span class="n">apply</span> <span class="n">bdd_above</span><span class="bp">.</span><span class="n">mk</span> <span class="n">t</span><span class="o">,</span>
    <span class="k">assume</span> <span class="o">(</span><span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">Hy</span><span class="o">),</span>
    <span class="n">induction</span> <span class="n">Hy</span> <span class="k">with</span> <span class="n">x</span> <span class="n">Hx</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="o">[</span><span class="n">Hx</span><span class="bp">.</span><span class="mi">2</span><span class="o">]</span> <span class="kn">using</span> <span class="n">Hx</span><span class="o">,</span>
  <span class="kn">end</span><span class="o">,</span>
  <span class="bp">⟨</span><span class="o">{</span><span class="n">y</span> <span class="bp">|</span> <span class="n">u</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">t</span><span class="o">},</span> <span class="k">by</span> <span class="n">assumption</span><span class="o">,</span> <span class="k">by</span> <span class="n">assumption</span><span class="bp">⟩</span><span class="o">,</span>
<span class="bp">⟨</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="bp">⟩</span>
</pre></div>


<p>and then I compacted it to</p>
<div class="codehilite"><pre><span></span><span class="bp">⟨λ</span> <span class="bp">⟨</span><span class="n">su</span><span class="o">,</span> <span class="n">suF</span><span class="o">,</span> <span class="n">tu</span><span class="o">,</span> <span class="n">tuH</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">tu</span><span class="o">,</span> <span class="n">filter</span><span class="bp">.</span><span class="n">upwards_sets</span> <span class="n">F</span> <span class="n">suF</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span> <span class="n">Hy</span><span class="o">,</span> <span class="n">tuH</span> <span class="bp">_</span> <span class="o">(</span><span class="n">mem_image_of_mem</span> <span class="bp">_</span> <span class="n">Hy</span><span class="o">))</span><span class="bp">⟩</span><span class="o">,</span>
 <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">t</span><span class="o">,</span> <span class="n">Ht</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="o">{</span><span class="n">y</span> <span class="bp">|</span> <span class="n">u</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">t</span><span class="o">},</span> <span class="n">Ht</span><span class="o">,</span> <span class="n">t</span><span class="o">,</span> <span class="o">(</span><span class="bp">λ</span><span class="n">y</span> <span class="n">Hy</span><span class="o">,</span> <span class="k">let</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">Hx</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">Hy</span> <span class="k">in</span> <span class="k">by</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">Hx</span><span class="bp">.</span><span class="mi">2</span><span class="o">]</span> <span class="kn">using</span> <span class="n">Hx</span><span class="o">)</span><span class="bp">⟩⟩</span>
</pre></div>


<p>Do you have an opinion on the readability of both, and which one I should keep?</p>

<a name="125266974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125266974" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125266974">Moses Schönfinkel (Apr 18 2018 at 19:11)</a>:</h4>
<p><span class="user-mention" data-user-id="110025">@Andrew Ashworth</span> They're reasonably well established in a few specific areas, almost exclusively related to software verification. Are you talking widespread adoption by mathematicians and in general, people who use formal apparatus of any kind?</p>

<a name="125267209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125267209" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125267209">Andrew Ashworth (Apr 18 2018 at 19:16)</a>:</h4>
<p>i like non-compacted proofs, although the mathlib developers disagree with me <span class="emoji emoji-1f600" title="grinning">:grinning:</span></p>

<a name="125267224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125267224" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125267224">Kevin Buzzard (Apr 18 2018 at 19:16)</a>:</h4>
<p>I think it depends on your audience.</p>

<a name="125267229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125267229" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125267229">Kevin Buzzard (Apr 18 2018 at 19:16)</a>:</h4>
<p>If you want to get it into mathlib then if you wrote the long one they would squish it down to the short one themselves</p>

<a name="125267240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125267240" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125267240">Kevin Buzzard (Apr 18 2018 at 19:17)</a>:</h4>
<p>If you want to explain to a bunch of undergraduates how Lean works then I would definitely not recommend the short one</p>

<a name="125267303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125267303" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125267303">Mario Carneiro (Apr 18 2018 at 19:18)</a>:</h4>
<p>there is plenty of space for big proofs in TPIL and similar works</p>

<a name="125267345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125267345" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125267345">Andrew Ashworth (Apr 18 2018 at 19:19)</a>:</h4>
<p><span class="user-mention" data-user-id="110027">@Moses Schönfinkel</span> yes. it doesn't even have that many inroads into high-assurance software, which is all written in things like MISRA C</p>

<a name="125267350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125267350" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125267350">Johannes Hölzl (Apr 18 2018 at 19:19)</a>:</h4>
<p>For simple statements like this I prefer the later proof (btw: you can even reduce it more: <code>λy Hy, let ⟨x, Hx⟩ := Hy in  ~&gt; λy ⟨x, Hx⟩,</code>). But the more complicated the proof itself is, especially when the proof goes over a couple of lines, I prefer the more elaborate one.</p>

<a name="125267433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125267433" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125267433">Kevin Buzzard (Apr 18 2018 at 19:21)</a>:</h4>
<p>In fact Johannes taught me a valuable lesson regarding this sort of thing (which you already know Sebastian) -- it's a very good exercise, at some point in your Lean career, to start trying to write the shortest proofs you possibly can.</p>

<a name="125267442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125267442" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125267442">Kevin Buzzard (Apr 18 2018 at 19:21)</a>:</h4>
<p>because this game just teaches you stuff, or perhaps teaches you to appreciate certain things</p>

<a name="125267448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125267448" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125267448">Kevin Buzzard (Apr 18 2018 at 19:21)</a>:</h4>
<p>which you might otherwise miss.</p>

<a name="125267549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125267549" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125267549">Sebastien Gouezel (Apr 18 2018 at 19:23)</a>:</h4>
<p>Agreed. To be able to compactify the proof, I needed to understand much more of what is going on.</p>

<a name="125267682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125267682" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125267682">Johannes Hölzl (Apr 18 2018 at 19:27)</a>:</h4>
<p>The problem with compact proofs is of course, that it is hard to ever change the definition of constants. As the often rely on definitional equality. There using automation has a big advantage, as it is often configurable like the simplifier.</p>

<a name="125267683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125267683" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125267683">Andrew Ashworth (Apr 18 2018 at 19:27)</a>:</h4>
<p>compact proofs / programs are painful to me. as someone who was tasked with fixing an old scientific c program from the 80s for several months, terseness is the great enemy</p>

<a name="125267849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125267849" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125267849">Patrick Massot (Apr 18 2018 at 19:30)</a>:</h4>
<p>What about having the goal that people could learn stuff from reading proofs?</p>

<a name="125267852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125267852" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125267852">Patrick Massot (Apr 18 2018 at 19:30)</a>:</h4>
<p>In ordinary maths this is a pretty important idea</p>

<a name="125267932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125267932" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125267932">Patrick Massot (Apr 18 2018 at 19:32)</a>:</h4>
<p>Of course we could completely separate the explanation of a theorem from its proof using Lean. But that wouldn't help people learning how to convince Lean that something is true</p>

<a name="125269848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125269848" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125269848">Kevin Buzzard (Apr 18 2018 at 20:10)</a>:</h4>
<p>What about having the goal that in between the incomprehensible lines of Lean code there are comments explaining what is going on, so people can learn from the comments?</p>

<a name="125269853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125269853" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125269853">Johan Commelin (Apr 18 2018 at 20:10)</a>:</h4>
<p>I think readability is extremely important for people to have confidence in formalisations. I am sure you all know the paper by Pollack, "How to believe a machine-checked proof": <a href="http://www.brics.dk/RS/97/18/BRICS-RS-97-18.pdf" target="_blank" title="http://www.brics.dk/RS/97/18/BRICS-RS-97-18.pdf">http://www.brics.dk/RS/97/18/BRICS-RS-97-18.pdf</a></p>

<a name="125269859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125269859" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125269859">Johan Commelin (Apr 18 2018 at 20:10)</a>:</h4>
<p>I think he has very good points</p>

<a name="125269962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125269962" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125269962">Johan Commelin (Apr 18 2018 at 20:13)</a>:</h4>
<p>For example, if the statement of Ramanujan's conjecture uses modular forms, then I need to understand the formalisation of the definition of modular forms as well. And if they are defined as sections of some line bundle on a modular curve, then I need to understand those as well...</p>

<a name="125269972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125269972" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125269972">Johan Commelin (Apr 18 2018 at 20:13)</a>:</h4>
<p>If there is one typo in those definitions... then the proof of Ramanujan's conjecture might not actually be a proof.</p>

<a name="125270026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125270026" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125270026">Johan Commelin (Apr 18 2018 at 20:14)</a>:</h4>
<p>That is why theorems with simple statements should have extremely readable and simple formalisations</p>

<a name="125270044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125270044" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125270044">Johan Commelin (Apr 18 2018 at 20:14)</a>:</h4>
<p>And afterwards, there might be theorems that say the statement is equivalent to some other statement using involved definitions, which you then go on to prove...</p>

<a name="125270068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/type%20class%20resolution%20or%20unification%3F/near/125270068" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78790typeclassresolutionorunification.html#125270068">Johan Commelin (Apr 18 2018 at 20:15)</a>:</h4>
<p>On the other hand, maybe my rant does not have much bearing on readability of <em>proofs</em>...</p>


{% endraw %}
