---
layout: archive
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/74751transportandparametricity.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html">transport and parametricity</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="164621456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164621456" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#164621456">Simon Hudon (May 01 2019 at 13:02)</a>:</h4>
<p>I could put some time on transfer and parametricity. I'll have to get a refresher on parametricity though. But this project is still useful. Although it will likely be replaced in Lean 4, when we do have a FFI, we can start building CS applications that themselves may be more portable.</p>

<a name="164621612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164621612" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#164621612">Simon Hudon (May 01 2019 at 13:05)</a>:</h4>
<p>The math is moving forward pretty nicely. Meanwhile the CS side of mathlib and other Lean packages is still under furnished. Please forgive us for spending time on it ;-)</p>

<a name="164621748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164621748" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#164621748">Simon Hudon (May 01 2019 at 13:07)</a>:</h4>
<p>Btw, do you have any time for parametricity and transfer? We could pick it up today if you like</p>

<a name="164621804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164621804" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#164621804">Patrick Massot (May 01 2019 at 13:08)</a>:</h4>
<p>I have time today, but I don't have the required knowledge</p>

<a name="164621813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164621813" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#164621813">Patrick Massot (May 01 2019 at 13:08)</a>:</h4>
<p>I can only repeat what Kevin wrote hundreds of times</p>

<a name="164621816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164621816" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#164621816">Simon Hudon (May 01 2019 at 13:08)</a>:</h4>
<p>Maybe I should talk to <span class="user-mention" data-user-id="110193">@Cyril Cohen</span> again</p>

<a name="164621826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164621826" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#164621826">Patrick Massot (May 01 2019 at 13:09)</a>:</h4>
<p>We need Lean to understand that isomorphic stuff have the same properties, for any property that makes sense</p>

<a name="164622622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164622622" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#164622622">Patrick Massot (May 01 2019 at 13:22)</a>:</h4>
<p>Simon, if you want a nice project for today, you could redo my leancrawler correctly. The goal is to be able to display the graph of all concepts in a Lean project, where each declaration is a node, and each edge means a declaration uses another declaration. Mine is unfortunately really bad, many edges are missing</p>

<a name="164623443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164623443" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#164623443">Simon Hudon (May 01 2019 at 13:35)</a>:</h4>
<p>You misunderstand me. I'm not looking for new projects. I'm trying to find help for the projects I already have</p>

<a name="164623646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164623646" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#164623646">Keeley Hoek (May 01 2019 at 13:38)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> a bit of an aside, but a fellow one of Scott's students has just started working on <code>iso_induction</code>, using an isomorphism <code>X ≅ Y</code> to replace every object <code>Y</code> that's in your goal with an <code>X</code> (and hopefully changing nothing else). At the moment it can show that for <code>X</code> and <code>Y</code> isomorphic types, to prove <code>inhabited Y</code> it suffices to show <code>inhabited X</code>! But this is done with some very general typeclass instances pertaining to functoriality. Not too long from now you should be able to add a command after the definition of e.g. <code>local_ring</code> which generates a proof of functoriality of the construction, and then be done with transporting such structure.</p>

<a name="164623953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164623953" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#164623953">Simon Hudon (May 01 2019 at 13:43)</a>:</h4>
<p>Interesting. I got a fair amount of push back when I tried focusing on isomorphisms for transport. That seemed like a good goal to me but Johannes didn't seem to like that idea</p>

<a name="164630636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164630636" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#164630636">Kevin Buzzard (May 01 2019 at 15:13)</a>:</h4>
<p>I wish I understood all of this better. I still keep coming back to the same idea -- if R is a local ring and S is isomorphic to R then S is local, and I cannot see why Lean can't auto-generate this theorem using some sequence of <code>equiv</code>s. <code>R</code> and <code>S</code> are ring-equiv, so the lattice of ideals of R and of S are lattice-equiv, and the definition of local ring is some predicate on these lattices which only depends on the lattice structure so commutes with the equiv. If someone wants to update <a href="https://github.com/leanprover-community/mathlib/issues/408" target="_blank" title="https://github.com/leanprover-community/mathlib/issues/408">https://github.com/leanprover-community/mathlib/issues/408</a> so I understand better the plan for implementing this in Lean, maybe I would get less frustrated by this issue :-/</p>

<a name="164630718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164630718" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#164630718">Kevin Buzzard (May 01 2019 at 15:14)</a>:</h4>
<p>(deleted)</p>

<a name="164972721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164972721" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#164972721">Kevin Buzzard (May 06 2019 at 11:05)</a>:</h4>
<p>I have two fintypes <code>S</code> and <code>T</code>, an equiv <code>S \equiv T</code>, a proof that all reflexive binary relations on <code>S</code> are transitive, and I want to deduce that all reflexive binary relations on <code>T</code> are transitive.  I am adding this to my list of transport complaints ;-) The maths proof is: "consider a reflexive binary relation on <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.13889em;">T</span></span></span></span>; this obviously induces a reflexive binary relation on <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span></span>; the induced relation is transitive; hence obviously the original relation is transitive". </p>
<p>How to do this in Lean in a clean and clear way?</p>
<hr>
<p>Background: I asked my students (in last year's exam) to prove that if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">r</span></span></span></span> was a reflexive binary relation on a set <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span></span> with two elements, then <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">r</span></span></span></span> was transitive. <span class="user-mention" data-user-id="130500">@Abhimanyu Pallavi Sudhir</span> wrote up the solutions in Lean and he assumed that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span></span> was <code>fin 2</code>. In a solution to such a question a mathematician would not think twice if a student wrote "WLOG <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><mo>{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo>}</mo></mrow><annotation encoding="application/x-tex">S=\{0,1\}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mrel">=</span><span class="mopen">{</span><span class="mord mathrm">0</span><span class="mpunct">,</span><span class="mord mathrm">1</span><span class="mclose">}</span></span></span></span>"; it is indistinguishable from "let the elements of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span></span> be called <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">x</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span>". In fact assuming <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span></span> is <code>bool</code> makes life even easier, but then one is faced with the question above.</p>

<a name="164973498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164973498" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#164973498">Chris Hughes (May 06 2019 at 11:21)</a>:</h4>
<p>I don't think this is the answer you wanted but</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">α</span> <span class="err">≃</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">r</span> <span class="n">y</span> <span class="n">z</span> <span class="bp">→</span> <span class="n">r</span> <span class="n">x</span> <span class="n">z</span><span class="o">))</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">r</span> <span class="n">y</span> <span class="n">z</span> <span class="bp">→</span> <span class="n">r</span> <span class="n">x</span> <span class="n">z</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">r</span> <span class="n">hrefl</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="n">hxy</span> <span class="n">hyz</span><span class="o">,</span> <span class="k">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="err">←</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">apply_symm_apply</span> <span class="n">e</span> <span class="n">x</span><span class="o">,</span> <span class="err">←</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">apply_symm_apply</span> <span class="n">e</span> <span class="n">z</span><span class="o">],</span>
  <span class="n">rw</span> <span class="o">[</span><span class="err">←</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">apply_symm_apply</span> <span class="n">e</span> <span class="n">x</span><span class="o">,</span> <span class="err">←</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">apply_symm_apply</span> <span class="n">e</span> <span class="n">y</span><span class="o">]</span> <span class="n">at</span> <span class="n">hxy</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="err">←</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">apply_symm_apply</span> <span class="n">e</span> <span class="n">y</span><span class="o">,</span> <span class="err">←</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">apply_symm_apply</span> <span class="n">e</span> <span class="n">z</span><span class="o">]</span> <span class="n">at</span> <span class="n">hyz</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">r</span> <span class="o">(</span><span class="n">e</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span> <span class="n">y</span><span class="o">))</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">hrefl</span> <span class="bp">_</span><span class="o">)</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">hxy</span> <span class="n">hyz</span>
<span class="kn">end</span>
</pre></div>

<a name="164973691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164973691" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#164973691">Johan Commelin (May 06 2019 at 11:25)</a>:</h4>
<p>Now Kenny golfs it (-;</p>

<a name="164973732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164973732" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#164973732">Kenny Lau (May 06 2019 at 11:26)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">α</span> <span class="err">≃</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">r</span> <span class="n">y</span> <span class="n">z</span> <span class="bp">→</span> <span class="n">r</span> <span class="n">x</span> <span class="n">z</span><span class="o">))</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">r</span> <span class="n">y</span> <span class="n">z</span> <span class="bp">→</span> <span class="n">r</span> <span class="n">x</span> <span class="n">z</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">r</span> <span class="n">hrefl</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="n">hxy</span> <span class="n">hyz</span><span class="o">,</span> <span class="k">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="err">←</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">apply_symm_apply</span> <span class="n">e</span> <span class="n">x</span><span class="o">,</span> <span class="err">←</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">apply_symm_apply</span> <span class="n">e</span> <span class="n">z</span><span class="o">]</span> <span class="n">at</span> <span class="err">\</span><span class="bp">|-</span> <span class="n">hxy</span> <span class="n">hyz</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">r</span> <span class="o">(</span><span class="n">e</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span> <span class="n">y</span><span class="o">))</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">hrefl</span> <span class="bp">_</span><span class="o">)</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">hxy</span> <span class="n">hyz</span>
<span class="kn">end</span>
</pre></div>

<a name="164973840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164973840" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#164973840">Johan Commelin (May 06 2019 at 11:27)</a>:</h4>
<p>Also, you missed the chance to use projection notation</p>

<a name="164973841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164973841" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#164973841">Johan Commelin (May 06 2019 at 11:27)</a>:</h4>
<p>You clearly didn't run that one</p>

<a name="164973889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164973889" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#164973889">Kenny Lau (May 06 2019 at 11:28)</a>:</h4>
<p>I haven't fired up Lean since a long time</p>

<a name="164973900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164973900" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#164973900">Johan Commelin (May 06 2019 at 11:28)</a>:</h4>
<p>And your internal type checker is rusty (-;</p>

<a name="164973950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164973950" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#164973950">Johan Commelin (May 06 2019 at 11:29)</a>:</h4>
<p>You're still running Lean 3.4.1, aren't you?</p>

<a name="164974024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164974024" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#164974024">Kenny Lau (May 06 2019 at 11:30)</a>:</h4>
<p>I'm staying off Lean until after the exam</p>

<a name="164974108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164974108" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#164974108">Johan Commelin (May 06 2019 at 11:31)</a>:</h4>
<p>Too bad that your exam is also staying off Lean</p>

<a name="164993381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164993381" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#164993381">Kevin Buzzard (May 06 2019 at 15:54)</a>:</h4>
<p>Yeah, I can prove it too; but I just know deep down that this is a special case of a general principle; given <code>e</code> and <code>h</code>, a mathematician knows in their soul that the goal is true, and doesn't want to prove it. The question, I think, is how to prove it with a tactic. I have more time for this now; Mario posted something a month or two ago but I was completely focussed on the perfectoid project at the time and didn't want to get distracted; now I am interested again.</p>
<p>My proof was more mundane: given rb on beta I literally built ra on alpha using the equiv, proved that the relationship on beta one can build from ra is rb again, and then just transferred everything manually.</p>
<p>But my point is that this should somehow be a one-liner.</p>

<a name="164998189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164998189" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#164998189">Jesse Michael Han (May 06 2019 at 16:50)</a>:</h4>
<p>essentially Kevin's approach, but <code>big_bertha</code> style:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">α</span> <span class="err">≃</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">r</span> <span class="n">y</span> <span class="n">z</span> <span class="bp">→</span> <span class="n">r</span> <span class="n">x</span> <span class="n">z</span><span class="o">))</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">r</span> <span class="n">y</span> <span class="n">z</span> <span class="bp">→</span> <span class="n">r</span> <span class="n">x</span> <span class="n">z</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span> <span class="n">r</span> <span class="n">H</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">r&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">r</span> <span class="o">(</span><span class="n">e</span><span class="bp">.</span><span class="mi">1</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span><span class="bp">.</span><span class="mi">1</span> <span class="n">b</span><span class="o">),</span>
  <span class="n">specialize</span> <span class="n">h</span> <span class="n">r&#39;</span> <span class="o">(</span><span class="k">by</span> <span class="n">finish</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span><span class="bp">.</span><span class="mi">2</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span><span class="bp">.</span><span class="mi">2</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span><span class="bp">.</span><span class="mi">2</span> <span class="n">z</span><span class="o">),</span>
  <span class="o">{[</span><span class="n">smt</span><span class="o">]</span> <span class="n">eblast_using</span><span class="o">[</span><span class="n">e</span><span class="bp">.</span><span class="mi">4</span><span class="o">,</span> <span class="o">(</span><span class="k">by</span> <span class="n">simp</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">r</span> <span class="o">(</span><span class="n">e</span><span class="bp">.</span><span class="mi">1</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span><span class="bp">.</span><span class="mi">1</span> <span class="n">b</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">r&#39;</span> <span class="n">a</span> <span class="n">b</span><span class="o">)]}</span>
<span class="kn">end</span>
</pre></div>

<a name="164999356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/164999356" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#164999356">Jesse Michael Han (May 06 2019 at 17:05)</a>:</h4>
<p>this doesn't quite do what Kevin wants, but we can see that proving the transfer is automatic; we just have to state it. all the constructed data/lemmas in the above proof are very follow-your-nose, so it's conceivable that one could whip up a tactic that attempts to use <code>equiv.to_fun</code> and <code>equiv.inv_fun</code> to produce the requisite data when it sees a lemma in context like <code>h</code> which is applicable "modulo equivalence"</p>

<a name="165023729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/165023729" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#165023729">Mario Carneiro (May 06 2019 at 22:14)</a>:</h4>
<p>There is a transfer style proof of this theorem. Floris mentioned wanting to get working on adding more transfer lemmas; I should PR <code>equiv.rel</code> if it hasn't made it in yet, it's pretty important for these kinds of proofs</p>

<a name="167886462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167886462" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#167886462">Kevin Buzzard (Jun 11 2019 at 20:15)</a>:</h4>
<p><a href="http://scholar.google.co.uk/scholar_url?url=http://www2.mat.ulaval.ca/fileadmin/Pages_personnelles_des_profs/hm/H14_Mac_Lane_Phil_Math_1996.pdf&amp;hl=en&amp;sa=X&amp;scisig=AAGBfm2Jux_hxs-Oz__pML2nCyJqSwH5vw&amp;nossl=1&amp;oi=scholarr" target="_blank" title="http://scholar.google.co.uk/scholar_url?url=http://www2.mat.ulaval.ca/fileadmin/Pages_personnelles_des_profs/hm/H14_Mac_Lane_Phil_Math_1996.pdf&amp;hl=en&amp;sa=X&amp;scisig=AAGBfm2Jux_hxs-Oz__pML2nCyJqSwH5vw&amp;nossl=1&amp;oi=scholarr">In this old paper by MacLane</a> he sketches on p179 what he says Bourbaki calls a "type" of "structure". His definition of structure is sufficiently general to allow topological spaces.</p>
<p>What is confusing me is the claim on p180 that a type of structure leads to the notion of morphism from one model of the structure to another; I'm not sure these words mean the same thing nowadays but what he's saying is that the axioms for a group give you a structure and now you can figure out what a homomorphism of groups is. But he's also saying that the axioms for a topological space give you a structure and now you can figure out what a homomorphism of topological spaces is. I did not know this. Is it true? MacLane offers no proof. I am fine with the idea that you can figure out what an <em>isomorphism</em> of structures is, but I don't see how to guess what a morphism of topological spaces is. There are some vague comments about how the power set can be covariant or contravariant, but I am confused about whether this co/contravariance is supposed to be part of the structure. Is this just a load of old codswallop or is there something here which can be made rigorous?</p>

<a name="167887254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167887254" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#167887254">Johan Commelin (Jun 11 2019 at 20:26)</a>:</h4>
<p><span class="user-mention" data-user-id="210057">@Fabian Glöckle</span> <span aria-label="up" class="emoji emoji-2b06" role="img" title="up">:up:</span> This might be relevant to what you are implementing</p>

<a name="167887817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167887817" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#167887817">Kevin Buzzard (Jun 11 2019 at 20:33)</a>:</h4>
<p>Does anyone know the reference to Bourbaki where they define these "types of structures"?</p>

<a name="167892115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167892115" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#167892115">Chris Hughes (Jun 11 2019 at 21:29)</a>:</h4>
<p><a href="https://link-springer-com.iclibezp1.cc.ic.ac.uk/content/pdf/10.1007%2F978-3-540-34035-5.pdf" target="_blank" title="https://link-springer-com.iclibezp1.cc.ic.ac.uk/content/pdf/10.1007%2F978-3-540-34035-5.pdf">https://link-springer-com.iclibezp1.cc.ic.ac.uk/content/pdf/10.1007%2F978-3-540-34035-5.pdf</a> I think.<br>
Chaiptre IV is called structures. It's in Théorie des ensembles</p>

<a name="167894846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167894846" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#167894846">Kevin Buzzard (Jun 11 2019 at 22:08)</a>:</h4>
<p>Thanks Chris. I've found it. Bourbaki don't just define a morphism between two structures, they have some additional data (basically the axioms that the map has to satisfy!). They explicitly give the example of topological spaces and how morphisms can either be open maps or continuous maps depending on the additional data (denoted <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.03588em;">σ</span></span></span></span>), on p215 of the pdf, section 2.1 of chapter IV. In fact they explicitly flag with a bendy road sign the fact that given just a structure, you don't have enough information to define morphisms of structures.</p>

<a name="167918782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167918782" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#167918782">Fabian Glöckle (Jun 12 2019 at 06:16)</a>:</h4>
<p>I have some thoughts on this.<br>
1) I already implemented the easy case: <a href="https://github.com/faabian/mathlib/blob/3.5/meta.lean" target="_blank" title="https://github.com/faabian/mathlib/blob/3.5/meta.lean">https://github.com/faabian/mathlib/blob/3.5/meta.lean</a><br>
Take a structure definition (like <code>ordered_ring</code>) and generate the corresponding type of homomorphisms (of maps compatible with all additional structure). I will now head for generating the category instances, forgetful functors etc.<br>
2) I didn't know about this before, but think MacLane may be correct about being able to find out what a continuous map is:</p>
<p>In logic/model theory, there are two types of homomorphisms, weak ones (respecting relations as in <code>R(x_1, ..., x_n) \implies R(f x_1, ..., f x_n)</code>) and strong ones (the same with Iff). Which one would one choose in category theory? Answer: weak ones, as they correspond to precomposition with <code>f</code> if we view relations as maps <code>X \times ... \times X \to Prop</code>.<br>
Then a subset of X is the same as a predicate (unary relation) on X or Y, and for a map <code>f : X \to Y</code>and a subset U \subset Y, the composition "characteristic function of U \comp f" is the characteristic function of the preimage of U under f.<br>
Then topologies are subsets of the powersets, so predicates on the power sets. We already found out that the natural map between the powersets is taking preimages. So a weak homomorphism means: "open U \subset Y \implies open (f^{-1} U) \subset X", the definition of a continuous map. (Or: the preimage of the topology of X under the map "take preimage under f" is the topology on Y).</p>
<p>I didn't check in the paper, but hope this is what he meant.</p>

<a name="167920167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167920167" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#167920167">Kevin Buzzard (Jun 12 2019 at 06:46)</a>:</h4>
<p>The issue is that Bourbaki's definition of "structure" allows more things than functions and relations -- it allows things like "functions from the power set of the power set of X to the product of X and the power set of X". It seems to me that MacLane just throws comments around like "let's say power set is contravariant" when talking about topologies, but without making it clear what he means in the general case. Is the thing I just mentioned covariant or contravariant? I'm not sure what I asked there even makes sense. Bourbaki avoid this by simply writing down the things they want to remain invariant <em>first</em>, calling them sigma, and then defining a sigma-morphism to be something that preserves sigma. They make it expressly clear that there is no "abstract nonsense" definition of a morphism between structures which does not involve choosing a sigma first.</p>

<a name="167921705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167921705" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#167921705">Fabian Glöckle (Jun 12 2019 at 07:12)</a>:</h4>
<p>But does this contradict the statement that in some cases there is a canonical way of finding sigma? I think MacLane says taking powerset to be contravariant is natural, and thus continuous maps are (unlike open maps) the natural choice. Do we know structures where this "canonical" choice of morphisms is not correct?</p>

<a name="167922147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167922147" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#167922147">Fabian Glöckle (Jun 12 2019 at 07:21)</a>:</h4>
<p>Concerning your example, the X part should be covariant, the (X to Prop) part contravariant. I think this is fully algorithmical as the only rule is "whenever the structure X itself appears, use f to get to Y". This can mean both pre- or postcomposition. Then draw a diagram and say it must commute.</p>

<a name="167924077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167924077" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#167924077">Chris Hughes (Jun 12 2019 at 08:00)</a>:</h4>
<p>So if a monotonic function is <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>≤</mo><mi>y</mi><mspace width="0.277778em"></mspace><mo>⟹</mo><mspace width="0.277778em"></mspace><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>≤</mo><mi>f</mi><mo>(</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">x \le y \implies f(x) \le f(y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">x</span><span class="mrel">≤</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mrel"><span class="mspace thickspace"></span><span class="mrel">⟹</span></span><span class="mord mathit"><span class="mspace thickspace"></span><span class="mord mathit" style="margin-right:0.10764em;">f</span></span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span><span class="mrel">≤</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>, we're using the order on Prop somehow, or we're just saying an order is a category, so a morphism is a functor? What's the canonical "weak" morphism on a metric space? Is it <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo>≤</mo><mi>d</mi><mo>(</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo separator="true">,</mo><mi>f</mi><mo>(</mo><mi>y</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">d(x,y) \le d(f(x),f(y))</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">d</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mrel">≤</span><span class="mord mathit">d</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p>

<a name="167924208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167924208" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#167924208">Fabian Glöckle (Jun 12 2019 at 08:03)</a>:</h4>
<p>Yes, somehow prop gets special treatment..</p>

<a name="167924304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167924304" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#167924304">Fabian Glöckle (Jun 12 2019 at 08:04)</a>:</h4>
<p>The metric spaces though are a great example showing that there are more than just the algebraic structures.</p>

<a name="167924584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167924584" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#167924584">Fabian Glöckle (Jun 12 2019 at 08:09)</a>:</h4>
<p>The algebraic version of a metric space map would be d(x,y) = d(f(x),f(y)) (called isometry?)</p>

<a name="167925016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167925016" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#167925016">Kevin Buzzard (Jun 12 2019 at 08:17)</a>:</h4>
<p>Locally ringed spaces are a great example showing that a structure in the sense of Bourbaki is not everything that a mathematician cares about. It is surely impossible to automatically generate the definition of a morphism of locally ringed spaces. But I am not sure that a locally ringed space falls into this whole structure definition at all. On the other hand it is clearly possible to define an isomorphism of locally ringed spaces, even though they are a more complex structure than what I think is allowed by Bourbaki.</p>

<a name="167925105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167925105" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#167925105">Kevin Buzzard (Jun 12 2019 at 08:19)</a>:</h4>
<blockquote>
<p>Concerning your example, the X part should be covariant, the (X to Prop) part contravariant.</p>
</blockquote>
<p>Does this make sense? Let's define a structure called <code>foo</code>, and a <code>foo</code> is a type <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07847em;">X</span></span></span></span> plus a subset of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>×</mo><mrow><mi mathvariant="script">P</mi></mrow><mo>(</mo><mi>X</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">X\times\mathcal{P}(X)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07847em;">X</span><span class="mbin">×</span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span> (the product of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07847em;">X</span></span></span></span> and its power set). How are you going to define morphisms? How can you be covariant in part of the data and contravariant in the other part? I just don't understand how to make this precise.</p>

<a name="167958320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167958320" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#167958320">Johan Commelin (Jun 12 2019 at 15:30)</a>:</h4>
<blockquote>
<p>Locally ringed spaces are a great example showing that a structure in the sense of Bourbaki is not everything that a mathematician cares about. It is surely impossible to automatically generate the definition of a morphism of locally ringed spaces. But I am not sure that a locally ringed space falls into this whole structure definition at all. On the other hand it is clearly possible to define an isomorphism of locally ringed spaces, even though they are a more complex structure than what I think is allowed by Bourbaki.</p>
</blockquote>
<p>A naive autogenerated type-theoretic isom of locally ringed spaces would probably be wrong. Because the isom is a 2-categorical thing. HoTT would automatically get it right, I guess.<br>
But if you aren't careful, the autogenerated thing would ask for the <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mo>∗</mo></msub><msub><mi mathvariant="script">O</mi><mi>X</mi></msub><mo>=</mo><msub><mi mathvariant="script">O</mi><mi>Y</mi></msub></mrow><annotation encoding="application/x-tex">f_* \mathcal{O}_X = \mathcal{O}_Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.175696em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.07847em;">X</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mrel">=</span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.22222em;">Y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> (with equality on the nose). Of course the isom should actually include extra data, namely an isom between those two sheaves.</p>

<a name="167958549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167958549" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#167958549">Johan Commelin (Jun 12 2019 at 15:32)</a>:</h4>
<p>But how could Lean ever figure out that it should automatically include such an isom in the autogenerated definition of an iso of LRS's? This only seems plausible if we tightly couple the categorical nature of sheaves to the definition of a sheaf. Otherwise it will just treat <code>sheaf X</code> as a discrete thing. But we want to consider them "up to homotopy".</p>

<a name="167961114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167961114" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#167961114">Kevin Buzzard (Jun 12 2019 at 15:56)</a>:</h4>
<p>I am not sure that locally ringed spaces are covered by this Bourbaki definition of structure, so probably you have to put extra allowances in for all the extra types kicking around; terms have to be equal but types just have to be isomorphic.</p>

<a name="167965900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167965900" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#167965900">Johan Commelin (Jun 12 2019 at 16:49)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> I'm not yet convinced that one can automagically produce the definition of isoms of LRS's...</p>

<a name="167966005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167966005" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#167966005">Johan Commelin (Jun 12 2019 at 16:50)</a>:</h4>
<p>If we endow everything with category instances... then maybe. Otherwise you either need to give the system a helping hand, or something clever has to be done.</p>

<a name="167967909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167967909" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#167967909">Kevin Buzzard (Jun 12 2019 at 17:16)</a>:</h4>
<p>The isomorphism of topological spaces enables you to push one sheaf over to the other space and now we want an isomorphism of sheaves. I don't see the problem but given that transfer seems to be such a key issue I'm still listening. I still believe that given any structure that Lean could make, it should be able to construct the notion of isomorphism between two instances of that structure (modulo possible universe issues)</p>

<a name="167968108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167968108" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#167968108">Johan Commelin (Jun 12 2019 at 17:19)</a>:</h4>
<p>How should the transfer tactic realise that an isomorphism of LRS requires an isomorphism between <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mo>∗</mo></msub><msub><mi mathvariant="script">O</mi><mi>X</mi></msub></mrow><annotation encoding="application/x-tex">f_* \mathcal{O}_X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.175696em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.07847em;">X</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="script">O</mi><mi>Y</mi></msub></mrow><annotation encoding="application/x-tex">\mathcal{O}_Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.22222em;">Y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span>, instead of an equality?</p>

<a name="167968506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167968506" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#167968506">Johan Commelin (Jun 12 2019 at 17:23)</a>:</h4>
<p>I've got <code>(X Y : LRS)</code>. I'm a robot. I need to figure out what is an isomorphism between <code>X</code> and <code>Y</code>. Well... an <code>LRS</code> consists of a topological space, a sheaf on that space, and some other junk.<br>
Great, I figure out what is an isomorphism of topological spaces. So I decide that an isom of <code>LRS</code>s consists of a topological isom <code>f : X.carrier \iso Y.carrier</code>. Using generic transfer blabla, this allows me to transfer the sheaf <code>X.sheaf</code> from <code>X.carrier</code> to <code>Y.carrier</code> along <code>f</code>. Now, I've got two terms of type <code>sheaf Y.carrier</code>. I decide that it is very reasonable that these two terms should be equal.<br>
Finally, this equality trivially preserves all the other junk. I have figured out what an isomorphism between <code>X</code> and <code>Y</code> is.<br>
I'm a robot.</p>

<a name="167968727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167968727" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#167968727">Reid Barton (Jun 12 2019 at 17:26)</a>:</h4>
<p>Well there are <code>Type</code>s inside <code>sheaf</code>, so presumably you would need to construct a notion of "equal" that doesn't involve literal equality of types</p>

<a name="167968737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167968737" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#167968737">Reid Barton (Jun 12 2019 at 17:26)</a>:</h4>
<p>by induction over the syntax of the structure</p>

<a name="167968779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167968779" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#167968779">Johan Commelin (Jun 12 2019 at 17:26)</a>:</h4>
<p>This very much feels like reinventing HoTT's transport.</p>

<a name="167969474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167969474" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#167969474">Reid Barton (Jun 12 2019 at 17:35)</a>:</h4>
<p>That is kind of the goal, right?</p>

<a name="167970737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167970737" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#167970737">Johan Commelin (Jun 12 2019 at 17:48)</a>:</h4>
<p>Hmmm... maybe it does work.</p>

<a name="167970792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167970792" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#167970792">Johan Commelin (Jun 12 2019 at 17:49)</a>:</h4>
<p><span class="user-mention" data-user-id="210057">@Fabian Glöckle</span> How hard would it be for you to automatically generate such an <code>equiv</code> for an arbitrary structure using the framework that you have so far?</p>

<a name="167974907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167974907" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#167974907">Reid Barton (Jun 12 2019 at 18:36)</a>:</h4>
<p>A difference is that in HoTT the equality is an intrinsic part of the theory, while here we're trying to emulate it by meta-level considerations, building up by induction on the structure what we expect the right interpretation of "equality" to be.</p>

<a name="167974932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/167974932" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#167974932">Reid Barton (Jun 12 2019 at 18:36)</a>:</h4>
<p>Equality of types in HoTT is not <em>defined</em> to be isomorphism any more than equality of ordered pairs is defined to be equality of each component</p>

<a name="168673712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/168673712" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#168673712">Cyril Cohen (Jun 21 2019 at 11:36)</a>:</h4>
<p><span class="user-mention" data-user-id="110026">@Simon Hudon</span> did someone progress on this while I was away?</p>

<a name="168677105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/transport%20and%20parametricity/near/168677105" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74751transportandparametricity.html#168677105">Simon Hudon (Jun 21 2019 at 12:33)</a>:</h4>
<p>I didn't. I think it's at the same point it was before</p>


{% endraw %}
