---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/08031Overlyspecificinstancesininitcategory.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/08031Overlyspecificinstancesininitcategory.html">Overly specific instances in init.category.*</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="192259114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Overly%20specific%20instances%20in%20init.category.%2A/near/192259114" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/08031Overlyspecificinstancesininitcategory.html#192259114">Jannis Limperg (Mar 30 2020 at 13:59)</a>:</h4>
<p>Hey! I recently needed the fact that <code>state_t σ m a</code> is an <code>applicative</code> whenever <code>m</code> is. However, this instance is currently not available from <code>init.category.state</code> because the <code>applicative</code> instance there requires the stronger <code>monad m</code>, and many other instances in <code>init.category.*</code> have the same problem. Would y'all take a PR to fix this (which would make the code somewhat less elegant and may or may not lead to compatibility issues)?</p>

<a name="192261089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Overly%20specific%20instances%20in%20init.category.%2A/near/192261089" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/08031Overlyspecificinstancesininitcategory.html#192261089">Reid Barton (Mar 30 2020 at 14:13)</a>:</h4>
<p>If it doesn't break mathlib then it's probably fine. However this change might be a bit questionable because I imagine the new <code>applicative</code> instance will not be definitionally equal to the current one (when <code>m</code> happens to be a <code>monad</code>)--or is that wrong?</p>

<a name="192261676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Overly%20specific%20instances%20in%20init.category.%2A/near/192261676" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/08031Overlyspecificinstancesininitcategory.html#192261676">Reid Barton (Mar 30 2020 at 14:18)</a>:</h4>
<p>Hm, thinking about this more and actually looking at the definitions, I think defining the <code>applicative</code> structure on <code>state_t</code> in terms of the original <code>applicative</code> structure on <code>m</code> is probably better anyways.</p>

<a name="192262105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Overly%20specific%20instances%20in%20init.category.%2A/near/192262105" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/08031Overlyspecificinstancesininitcategory.html#192262105">Reid Barton (Mar 30 2020 at 14:21)</a>:</h4>
<p>So, I stand by my first sentence. Ignore the second sentence <span aria-label="slight smile" class="emoji emoji-1f642" role="img" title="slight smile">:slight_smile:</span></p>

<a name="192268754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Overly%20specific%20instances%20in%20init.category.%2A/near/192268754" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/08031Overlyspecificinstancesininitcategory.html#192268754">Simon Hudon (Mar 30 2020 at 15:04)</a>:</h4>
<p>I doubt that the instance actually works. In order to define <code>seq</code> on <code>state_t</code>, you need to thread the final state of the first argument into the second argument, i.e. you need to use <code>bind</code>.</p>

<a name="192274397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Overly%20specific%20instances%20in%20init.category.%2A/near/192274397" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/08031Overlyspecificinstancesininitcategory.html#192274397">Jannis Limperg (Mar 30 2020 at 15:42)</a>:</h4>
<p>Oh yes, you're right; Haskell also has the <code>monad m</code> constraint. I'll have to rethink my original application then.</p>
<p>However, the general problem remains, e.g. <code>functor (state_t σ m)</code> currently requires <code>monad m</code> when it could be <code>functor m</code>.</p>

<a name="192280445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Overly%20specific%20instances%20in%20init.category.%2A/near/192280445" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/08031Overlyspecificinstancesininitcategory.html#192280445">Simon Hudon (Mar 30 2020 at 16:25)</a>:</h4>
<p>That's true, we could change that</p>

<a name="192784228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Overly%20specific%20instances%20in%20init.category.%2A/near/192784228" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/08031Overlyspecificinstancesininitcategory.html#192784228">Jannis Limperg (Apr 03 2020 at 10:25)</a>:</h4>
<p>This turns out to be a bigger project than I thought: I'll have to redo the <code>lawful_monad</code> proofs as well (and add <code>lawful_applicative</code> instances etc.). But at least that seems to be the only thing that breaks in core, and I'd be surprised if mathlib relied on the exact definitions of <code>map</code> or <code>seq</code> much. PR still forthcoming, but it'll take a while.</p>


{% endraw %}

{% include archive_update.html %}