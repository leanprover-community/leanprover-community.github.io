---
layout: archive
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/40085Inferringsetoidinstances.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html">Inferring setoid instances</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="129811730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129811730" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129811730">Chris Hughes (Jul 17 2018 at 13:10)</a>:</h4>
<p>I've had a bit of trouble with setoid instances in quotient rings and groups. Changes the brackets around <code>setoid</code> in <code>quotient.induction_on</code> and similar lemmas form <code>[]</code> to <code>{}</code> improves matters a lot. Is there a downside to this approach? There should always only be one possibility for <code>setoid</code> from the type of <code>q</code> right?</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">induction_on&#39;</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">setoid</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">quotient</span> <span class="n">s</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>
  <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">quotient</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">β</span> <span class="err">⟦</span><span class="n">a</span><span class="err">⟧</span><span class="o">)</span> <span class="o">:</span> <span class="n">β</span> <span class="n">q</span> <span class="o">:=</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">induction_on</span> <span class="n">q</span> <span class="n">h</span>
</pre></div>

<a name="129812715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129812715" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129812715">Reid Barton (Jul 17 2018 at 13:30)</a>:</h4>
<p>I have also thought the same thing "why not just infer the relation based on the type of <code>q</code>".</p>

<a name="129812730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129812730" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129812730">Reid Barton (Jul 17 2018 at 13:31)</a>:</h4>
<p>I'm guessing you have a type (like, a group) on which you have a relation that depends on some other variable (like, a subgroup) which isn't mentioned in the carrier type?</p>

<a name="129812795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129812795" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129812795">Reid Barton (Jul 17 2018 at 13:32)</a>:</h4>
<p>I also found these type class arguments annoying to deal with in this kind of situation, although I don't remember what I did about it.<br>
It's possible that switching to a different elaboration strategy fixed my problem, and I didn't look into exactly why.</p>

<a name="129812897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129812897" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129812897">Reid Barton (Jul 17 2018 at 13:34)</a>:</h4>
<p>Or maybe I just used <code>quot</code> methods instead. <a href="#narrow/stream/113488-general/topic/elab_as_eliminator" title="#narrow/stream/113488-general/topic/elab_as_eliminator">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/elab_as_eliminator</a></p>

<a name="129812930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129812930" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129812930">Reid Barton (Jul 17 2018 at 13:35)</a>:</h4>
<p>Yes, now I remember wondering whether mixing <code>quotient</code> with <code>quot.induction_on</code> was a sensible thing to do, and then I saw that TPIL does the same thing in the section on quotients.</p>

<a name="129814544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129814544" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129814544">Chris Hughes (Jul 17 2018 at 14:06)</a>:</h4>
<p>I'm not sure what you mean by carrier type, but basically it's struggling to find the setoid instances for the standard relation for quotienting by an ideal. It's particularly bad when I have two ideals in my context, but at the moment I only have one and it's still struggling.</p>

<a name="129815018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129815018" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129815018">Chris Hughes (Jul 17 2018 at 14:14)</a>:</h4>
<p>Deleting my instance for preimage of a ring_hom is an ideal helps, even though my lemma has nothing to do with preimages or ring_homs.</p>

<a name="129815052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129815052" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129815052">Reid Barton (Jul 17 2018 at 14:15)</a>:</h4>
<p>By carrier I mean the type that you're putting an equivalence relation on.</p>

<a name="129815143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129815143" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129815143">Reid Barton (Jul 17 2018 at 14:17)</a>:</h4>
<p>in this case, (the underlying type of) the ring</p>

<a name="129815513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129815513" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129815513">Reid Barton (Jul 17 2018 at 14:24)</a>:</h4>
<p>The equivalence relation here depends on the ideal I, which cannot be inferred from the ring or from instance synthesis.<br>
Basically, when you have an instance which has non-typeclass variables to the left of the colon which don't also appear to the right of the colon, I don't see how Lean can ever select the instance by type class inference.</p>

<a name="129815620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129815620" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129815620">Patrick Massot (Jul 17 2018 at 14:26)</a>:</h4>
<p>We certainly don't want Lean to guess which ideal we want to quotient. And one can always add local setoid instances if we have a whole section of file where the ideal is fixed.</p>

<a name="129816521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129816521" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129816521">Chris Hughes (Jul 17 2018 at 14:43)</a>:</h4>
<p>@pat</p>
<blockquote>
<p>We certainly don't want Lean to guess which ideal we want to quotient. And one can always add local setoid instances if we have a whole section of file where the ideal is fixed.</p>
</blockquote>
<p>Not actually that easy to add a local attribute that depends on a variable.</p>

<a name="129836199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129836199" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129836199">Patrick Massot (Jul 17 2018 at 21:23)</a>:</h4>
<p>I see Mario merged your PR (before anyone added your name to the authors list). Did you solve your instance issue?</p>

<a name="129836266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129836266" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129836266">Mario Carneiro (Jul 17 2018 at 21:24)</a>:</h4>
<p>oops</p>

<a name="129836295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129836295" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129836295">Chris Hughes (Jul 17 2018 at 21:25)</a>:</h4>
<p>Not really. I think in general we shouldn't be using type class inference for quotient rings and groups, and maybe we need some infrastructure to deal with that, like a whole load of new quotient lemmas. But I'm not sure. I usually find a way round it, but it's a constant nuisance</p>

<a name="129836545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129836545" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129836545">Kevin Buzzard (Jul 17 2018 at 21:30)</a>:</h4>
<p>Here's another type class inference issue which Keji pointed out to me:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">group_theory</span><span class="bp">.</span><span class="n">subgroup</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">is_subgroup</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">H1</span> <span class="n">H2</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="o">)</span> <span class="o">[</span><span class="n">is_subgroup</span> <span class="n">H1</span><span class="o">]</span> <span class="o">[</span><span class="n">is_subgroup</span> <span class="n">H2</span><span class="o">]</span> <span class="o">:</span> <span class="n">is_subgroup</span> <span class="o">(</span><span class="n">H1</span> <span class="err">∩</span> <span class="n">H2</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">inv_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span> <span class="n">Hyp</span><span class="o">,</span><span class="bp">⟨</span><span class="n">is_subgroup</span><span class="bp">.</span><span class="n">inv_mem</span> <span class="n">Hyp</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span><span class="n">is_subgroup</span><span class="bp">.</span><span class="n">inv_mem</span> <span class="n">Hyp</span><span class="bp">.</span><span class="mi">2</span><span class="bp">⟩</span><span class="o">,</span>

<span class="o">}</span>
</pre></div>


<p>-&gt;</p>
<div class="codehilite"><pre><span></span>failed to synthesize type class instance for
G : Type,
_inst_1 : group G,
H1 H2 : set G,
_inst_2 : is_subgroup H1,
_inst_3 : is_subgroup H2
⊢ is_submonoid (H1 ∩ H2)
</pre></div>


<p>I just wanted to populate the fields of the structure but I couldn't figure out an easy way to do so without proving <code>is_submonoid (H1 ∩ H2)</code> first and making it an instance</p>

<a name="129836549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129836549" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129836549">Kevin Buzzard (Jul 17 2018 at 21:30)</a>:</h4>
<p>Is there a way round this?</p>

<a name="129836743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129836743" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129836743">Patrick Massot (Jul 17 2018 at 21:35)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">H1</span> <span class="n">H2</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="o">)</span> <span class="o">[</span><span class="n">is_subgroup</span> <span class="n">H1</span><span class="o">]</span> <span class="o">[</span><span class="n">is_subgroup</span> <span class="n">H2</span><span class="o">]</span> <span class="o">:</span> <span class="n">is_subgroup</span> <span class="o">(</span><span class="n">H1</span> <span class="err">∩</span> <span class="n">H2</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">refine_struct</span> <span class="o">{</span><span class="bp">..</span><span class="o">},</span>
  <span class="n">sorry</span><span class="o">,</span> <span class="n">sorry</span><span class="o">,</span> <span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>


<p>state after first line looks good to me</p>

<a name="129837625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129837625" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129837625">Chris Hughes (Jul 17 2018 at 21:54)</a>:</h4>
<blockquote>
<p>I just wanted to populate the fields of the structure but I couldn't figure out an easy way to do so without proving <code>is_submonoid (H1 ∩ H2)</code> first and making it an instance</p>
</blockquote>
<p>It's probably good practice to make <code>inter.is_submonoid</code> an instance first anyway.</p>

<a name="129837657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129837657" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129837657">Kevin Buzzard (Jul 17 2018 at 21:55)</a>:</h4>
<p>Yeah but I was teaching.</p>

<a name="129837666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129837666" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129837666">Kevin Buzzard (Jul 17 2018 at 21:55)</a>:</h4>
<p>I just wanted it to look relatively easy. In the end I re-defined is_subgroup (and didn't import it)</p>

<a name="129837913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129837913" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129837913">Patrick Massot (Jul 17 2018 at 22:00)</a>:</h4>
<p>Full proof could be either</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">H1</span> <span class="n">H2</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="o">)</span> <span class="o">[</span><span class="n">is_subgroup</span> <span class="n">H1</span><span class="o">]</span> <span class="o">[</span><span class="n">is_subgroup</span> <span class="n">H2</span><span class="o">]</span> <span class="o">:</span> <span class="n">is_subgroup</span> <span class="o">(</span><span class="n">H1</span> <span class="err">∩</span> <span class="n">H2</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">one_mem</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">is_submonoid</span><span class="bp">.</span><span class="n">one_mem</span> <span class="n">H1</span><span class="o">,</span> <span class="n">is_submonoid</span><span class="bp">.</span><span class="n">one_mem</span> <span class="n">H2</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">mul_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">a_in</span> <span class="n">b_in</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">is_submonoid</span><span class="bp">.</span><span class="n">mul_mem</span> <span class="n">a_in</span><span class="bp">.</span><span class="mi">1</span> <span class="n">b_in</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span> <span class="n">is_submonoid</span><span class="bp">.</span><span class="n">mul_mem</span> <span class="n">a_in</span><span class="bp">.</span><span class="mi">2</span> <span class="n">b_in</span><span class="bp">.</span><span class="mi">2</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">inv_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span> <span class="n">Hyp</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">is_subgroup</span><span class="bp">.</span><span class="n">inv_mem</span> <span class="n">Hyp</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span><span class="n">is_subgroup</span><span class="bp">.</span><span class="n">inv_mem</span> <span class="n">Hyp</span><span class="bp">.</span><span class="mi">2</span><span class="bp">⟩</span> <span class="o">}</span>
</pre></div>


<p>or</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">H1</span> <span class="n">H2</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="o">)</span> <span class="o">[</span><span class="n">is_subgroup</span> <span class="n">H1</span><span class="o">]</span> <span class="o">[</span><span class="n">is_subgroup</span> <span class="n">H2</span><span class="o">]</span> <span class="o">:</span> <span class="n">is_subgroup</span> <span class="o">(</span><span class="n">H1</span> <span class="err">∩</span> <span class="n">H2</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">refine_struct</span> <span class="o">{</span><span class="bp">..</span><span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="bp">⟨</span><span class="n">is_submonoid</span><span class="bp">.</span><span class="n">one_mem</span> <span class="n">H1</span><span class="o">,</span> <span class="n">is_submonoid</span><span class="bp">.</span><span class="n">one_mem</span> <span class="n">H2</span><span class="bp">⟩</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span> <span class="n">a_in</span> <span class="n">b_in</span><span class="o">,</span>
    <span class="n">exact</span> <span class="bp">⟨</span><span class="n">is_submonoid</span><span class="bp">.</span><span class="n">mul_mem</span> <span class="n">a_in</span><span class="bp">.</span><span class="mi">1</span> <span class="n">b_in</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span> <span class="n">is_submonoid</span><span class="bp">.</span><span class="n">mul_mem</span> <span class="n">a_in</span><span class="bp">.</span><span class="mi">2</span> <span class="n">b_in</span><span class="bp">.</span><span class="mi">2</span><span class="bp">⟩</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">g</span> <span class="n">Hyp</span><span class="o">,</span>
    <span class="n">exact</span> <span class="bp">⟨</span><span class="n">is_subgroup</span><span class="bp">.</span><span class="n">inv_mem</span> <span class="n">Hyp</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span><span class="n">is_subgroup</span><span class="bp">.</span><span class="n">inv_mem</span> <span class="n">Hyp</span><span class="bp">.</span><span class="mi">2</span><span class="bp">⟩</span> <span class="o">}</span>
<span class="kn">end</span>
</pre></div>


<p>depending whether you want to get tactical or not. I'm not sure I understand your question</p>

<a name="129837927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129837927" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129837927">Patrick Massot (Jul 17 2018 at 22:01)</a>:</h4>
<p>The teaching advantage of the tactical way is what I showed in my first answer: Lean tells you want it wants, even putting names on questions</p>

<a name="129838009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129838009" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129838009">Mario Carneiro (Jul 17 2018 at 22:02)</a>:</h4>
<p>I'm going to make a rather radical suggestion and suggest that perhaps <code>subgroup G</code> should be a type on its own, like <code>filter</code></p>

<a name="129838032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129838032" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129838032">Kevin Buzzard (Jul 17 2018 at 22:03)</a>:</h4>
<p>I am surprised the first one works! With no structure fields just the <code>{}</code> Lean complains it has no <code>inv_mem</code> and that type class inference fails to prove <code>is_submonoid</code>. I hadn't expected that just declaring the fields anyway would work.</p>

<a name="129838104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129838104" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129838104">Kevin Buzzard (Jul 17 2018 at 22:05)</a>:</h4>
<p>In particular Lean doesn't put all names on questions -- you have to look at what <code>is_submonoid</code> wants -- but that's not too hard.</p>

<a name="129838122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129838122" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129838122">Patrick Massot (Jul 17 2018 at 22:05)</a>:</h4>
<p>Did you try my suggestion with three <code>sorry</code>?</p>

<a name="129838129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129838129" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129838129">Patrick Massot (Jul 17 2018 at 22:05)</a>:</h4>
<p>The crucial part is Simon's <code>refine_struct</code> tactic</p>

<a name="129838188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129838188" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129838188">Patrick Massot (Jul 17 2018 at 22:06)</a>:</h4>
<p>Mario, do you mean bundling the subset and its properties?</p>

<a name="129838197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129838197" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129838197">Mario Carneiro (Jul 17 2018 at 22:07)</a>:</h4>
<p>yes, and adding a <code>has_mem</code> instance and so on</p>

<a name="129838198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129838198" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129838198">Chris Hughes (Jul 17 2018 at 22:07)</a>:</h4>
<p>How does that solve the <code>setoid</code> problem?</p>

<a name="129838200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129838200" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129838200">Mario Carneiro (Jul 17 2018 at 22:07)</a>:</h4>
<p>what setoid?</p>

<a name="129838244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129838244" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129838244">Mario Carneiro (Jul 17 2018 at 22:08)</a>:</h4>
<p>it solves the typeclass inference problem</p>

<a name="129838246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129838246" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129838246">Patrick Massot (Jul 17 2018 at 22:08)</a>:</h4>
<p>he wants quotients by subgroups</p>

<a name="129838247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129838247" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129838247">Chris Hughes (Jul 17 2018 at 22:08)</a>:</h4>
<p>The problem about inferrinf <code>setoid</code> instances for quotient groups and rings.</p>

<a name="129838248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129838248" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129838248">Mario Carneiro (Jul 17 2018 at 22:08)</a>:</h4>
<p>example?</p>

<a name="129838266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129838266" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129838266">Chris Hughes (Jul 17 2018 at 22:09)</a>:</h4>
<p>I don't have an MWE right now, but having two subgroups around means it uses the wrong one sometimes.</p>

<a name="129838337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129838337" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129838337">Mario Carneiro (Jul 17 2018 at 22:10)</a>:</h4>
<p>I don't mean MWE, just sketch the problem. I don't see how two quotient groups with different subgroups can be confused</p>

<a name="129838361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129838361" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129838361">Chris Hughes (Jul 17 2018 at 22:11)</a>:</h4>
<p>It always tries to use the setoid instance with the subgroup which comes last in the statement of the theorem.</p>

<a name="129838410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129838410" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129838410">Mario Carneiro (Jul 17 2018 at 22:12)</a>:</h4>
<p>why are you inferring a setoid instance?</p>

<a name="129838430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129838430" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129838430">Reid Barton (Jul 17 2018 at 22:13)</a>:</h4>
<p>Because the setoid argument to <code>quotient.induction_on</code> is a <code>[]</code> argument for some reason</p>

<a name="129838483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129838483" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129838483">Mario Carneiro (Jul 17 2018 at 22:14)</a>:</h4>
<p>you could use <code>quot.induction_on</code>...</p>

<a name="129838552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129838552" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129838552">Chris Hughes (Jul 17 2018 at 22:16)</a>:</h4>
<p>What do you suggest in place of <code>quotient.mk</code>?</p>

<a name="129838565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129838565" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129838565">Chris Hughes (Jul 17 2018 at 22:17)</a>:</h4>
<p>And there's no <code>quot.lift_on₂</code></p>

<a name="129838568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129838568" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129838568">Mario Carneiro (Jul 17 2018 at 22:17)</a>:</h4>
<p><code>quot.mk</code> of course</p>

<a name="129838612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129838612" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129838612">Chris Hughes (Jul 17 2018 at 22:18)</a>:</h4>
<p>Then I have a really long expression.</p>

<a name="129838619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129838619" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129838619">Mario Carneiro (Jul 17 2018 at 22:18)</a>:</h4>
<p>You usually want to make custom versions of all these anyway</p>

<a name="129838620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129838620" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129838620">Chris Hughes (Jul 17 2018 at 22:18)</a>:</h4>
<p>A <code>has_coe</code> instance seems like a sensible substitute.</p>

<a name="129838634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129838634" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129838634">Chris Hughes (Jul 17 2018 at 22:19)</a>:</h4>
<p>How about <code>quotient.exact</code>?</p>

<a name="129838685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129838685" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129838685">Mario Carneiro (Jul 17 2018 at 22:20)</a>:</h4>
<p>You can always use <code>@</code> if you like the <code>quotient</code> version</p>

<a name="129838695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/129838695" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#129838695">Mario Carneiro (Jul 17 2018 at 22:21)</a>:</h4>
<p>just put <code>(id _)</code> in the typeclass slot and it will unify for it instead of use typeclass inference</p>

<a name="130011028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/130011028" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#130011028">Chris Hughes (Jul 20 2018 at 17:18)</a>:</h4>
<p>I had a go at following Mario's recommendation and not using type class inference for setoids for quotient groups. I wanted to find a solution that made it easy, and initially it wasn't. <br>
I used the follwing definitions</p>
<div class="codehilite"><pre><span></span><span class="kn">section</span> <span class="n">quotients</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">φ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">{</span><span class="n">s₁</span> <span class="o">:</span> <span class="n">setoid</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">s₂</span> <span class="o">:</span> <span class="n">setoid</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">s₃</span> <span class="o">:</span> <span class="n">setoid</span> <span class="n">γ</span><span class="o">}</span>

<span class="bp">@</span><span class="o">[</span><span class="n">elab_as_eliminator</span><span class="o">,</span> <span class="kn">reducible</span><span class="o">]</span>
<span class="n">def</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">lift_on&#39;</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">quotient</span> <span class="n">s₁</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">φ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="bp">@</span><span class="n">setoid</span><span class="bp">.</span><span class="n">r</span> <span class="n">α</span> <span class="n">s₁</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">φ</span> <span class="o">:=</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">lift_on</span> <span class="n">q</span> <span class="n">f</span> <span class="n">h</span>

<span class="bp">@</span><span class="o">[</span><span class="n">elab_as_eliminator</span><span class="o">,</span> <span class="kn">reducible</span><span class="o">]</span>
<span class="n">def</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">lift_on₂&#39;</span> <span class="o">(</span><span class="n">q₁</span> <span class="o">:</span> <span class="n">quotient</span> <span class="n">s₁</span><span class="o">)</span> <span class="o">(</span><span class="n">q₂</span> <span class="o">:</span> <span class="n">quotient</span> <span class="n">s₂</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a₁</span> <span class="n">a₂</span> <span class="n">b₁</span> <span class="n">b₂</span><span class="o">,</span> <span class="bp">@</span><span class="n">setoid</span><span class="bp">.</span><span class="n">r</span> <span class="n">α</span> <span class="n">s₁</span> <span class="n">a₁</span> <span class="n">b₁</span> <span class="bp">→</span> <span class="bp">@</span><span class="n">setoid</span><span class="bp">.</span><span class="n">r</span> <span class="n">β</span> <span class="n">s₂</span> <span class="n">a₂</span> <span class="n">b₂</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">a₁</span> <span class="n">a₂</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">b₁</span> <span class="n">b₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">γ</span> <span class="o">:=</span>
<span class="n">quotient</span><span class="bp">.</span><span class="n">lift_on₂</span> <span class="n">q₁</span> <span class="n">q₂</span> <span class="n">f</span> <span class="n">h</span>

<span class="bp">@</span><span class="o">[</span><span class="n">elab_as_eliminator</span><span class="o">]</span>
<span class="kn">lemma</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">induction_on&#39;</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">quotient</span> <span class="n">s₁</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">quotient</span> <span class="n">s₁</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">p</span> <span class="o">(</span><span class="n">quot</span><span class="bp">.</span><span class="n">mk</span> <span class="n">s₁</span><span class="bp">.</span><span class="mi">1</span> <span class="n">a</span><span class="o">))</span> <span class="o">:</span> <span class="n">p</span> <span class="n">q</span> <span class="o">:=</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">induction_on</span> <span class="n">q</span> <span class="n">h</span>

<span class="bp">@</span><span class="o">[</span><span class="n">elab_as_eliminator</span><span class="o">]</span>
<span class="kn">lemma</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">induction_on₂&#39;</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">quotient</span> <span class="n">s₁</span> <span class="bp">→</span> <span class="n">quotient</span> <span class="n">s₂</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">q₁</span> <span class="o">:</span> <span class="n">quotient</span> <span class="n">s₁</span><span class="o">)</span>
  <span class="o">(</span><span class="n">q₂</span> <span class="o">:</span> <span class="n">quotient</span> <span class="n">s₂</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a₁</span> <span class="n">a₂</span><span class="o">,</span> <span class="n">p</span> <span class="o">(</span><span class="n">quot</span><span class="bp">.</span><span class="n">mk</span> <span class="n">s₁</span><span class="bp">.</span><span class="mi">1</span> <span class="n">a₁</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">quotient</span><span class="bp">.</span><span class="n">mk</span> <span class="n">β</span> <span class="n">s₂</span> <span class="n">a₂</span><span class="o">))</span> <span class="o">:</span> <span class="n">p</span> <span class="n">q₁</span> <span class="n">q₂</span> <span class="o">:=</span>
<span class="n">quotient</span><span class="bp">.</span><span class="n">induction_on₂</span> <span class="n">q₁</span> <span class="n">q₂</span> <span class="n">h</span>

<span class="bp">@</span><span class="o">[</span><span class="n">elab_as_eliminator</span><span class="o">]</span>
<span class="kn">lemma</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">induction_on₃&#39;</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">quotient</span> <span class="n">s₁</span> <span class="bp">→</span> <span class="n">quotient</span> <span class="n">s₂</span> <span class="bp">→</span> <span class="n">quotient</span> <span class="n">s₃</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>
  <span class="o">(</span><span class="n">q₁</span> <span class="o">:</span> <span class="n">quotient</span> <span class="n">s₁</span><span class="o">)</span> <span class="o">(</span><span class="n">q₂</span> <span class="o">:</span> <span class="n">quotient</span> <span class="n">s₂</span><span class="o">)</span> <span class="o">(</span><span class="n">q₃</span> <span class="o">:</span> <span class="n">quotient</span> <span class="n">s₃</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a₁</span> <span class="n">a₂</span> <span class="n">a₃</span><span class="o">,</span> <span class="n">p</span> <span class="o">(</span><span class="n">quot</span><span class="bp">.</span><span class="n">mk</span> <span class="n">s₁</span><span class="bp">.</span><span class="mi">1</span> <span class="n">a₁</span><span class="o">)</span> <span class="o">(</span><span class="n">quot</span><span class="bp">.</span><span class="n">mk</span> <span class="n">s₂</span><span class="bp">.</span><span class="mi">1</span> <span class="n">a₂</span><span class="o">)</span> <span class="o">(</span><span class="n">quot</span><span class="bp">.</span><span class="n">mk</span> <span class="n">s₃</span><span class="bp">.</span><span class="mi">1</span> <span class="n">a₃</span><span class="o">))</span> <span class="o">:</span> <span class="n">p</span> <span class="n">q₁</span> <span class="n">q₂</span> <span class="n">q₃</span> <span class="o">:=</span>
<span class="n">quotient</span><span class="bp">.</span><span class="n">induction_on₃</span> <span class="n">q₁</span> <span class="n">q₂</span> <span class="n">q₃</span> <span class="n">h</span>

<span class="kn">end</span> <span class="n">quotients</span>
</pre></div>


<p>Using these definitions everything was easy. They differ from the library definitions in two ways, the absence of the <code>elab_strategy</code> attribute, not sure what this does, but it makes stuff harder for some reason, and the use of <code>{}</code> instead of <code>[]</code> for setoids. Using <code>quot</code> versions of these lemmas has two problems, one is the <code>elab_strategy</code> attribute, and the other is that <code>quot.lift_on₂</code> as well as <code>quot.exact</code> are not provable without the relations being equivalence relations.</p>

<a name="130014064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inferring%20setoid%20instances/near/130014064" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/40085Inferringsetoidinstances.html#130014064">Mario Carneiro (Jul 20 2018 at 18:19)</a>:</h4>
<p>Hm, this sounds like reason enough to PR these theorems. (Since we all know that mathlib is collecting patches of core lean theorems.) I actually have no idea what the <code>elab_strategy</code> attribute does, I've never heard of it</p>


{% endraw %}
