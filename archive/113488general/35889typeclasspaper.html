---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/35889typeclasspaper.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html">typeclass paper</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="185313688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185313688" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185313688">Daniel Selsam (Jan 10 2020 at 14:25)</a>:</h4>
<p>Hello Mathlib! As many of you know, <span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span> <span class="user-mention" data-user-id="112857">@Leonardo de Moura</span> and I are writing a paper about our new typeclass resolution procedure for Lean4. We have a first draft and it would be great to get feedback, particularly from people who know more about Mathlib than they do about the internals of typeclass resolution. Here is a link: <a href="https://www.dropbox.com/s/5nxklkxvdh7xna9/typeclass.pdf?dl=0" target="_blank" title="https://www.dropbox.com/s/5nxklkxvdh7xna9/typeclass.pdf?dl=0">https://www.dropbox.com/s/5nxklkxvdh7xna9/typeclass.pdf?dl=0</a> Thanks in advance.</p>
<div class="message_inline_ref"><a href="https://www.dropbox.com/s/5nxklkxvdh7xna9/typeclass.pdf?dl=0" target="_blank" title="typeclass.pdf"><img src="https://www.dropbox.com/static/images/spectrum-icons/generated/content/content-pdf-large.png"></a><div><div class="message_inline_image_title">typeclass.pdf</div><desc class="message_inline_image_desc"></desc></div></div>

<a name="185314530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185314530" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185314530">Rob Lewis (Jan 10 2020 at 14:34)</a>:</h4>
<p>Do you have a submission/feedback deadline? I'd love to take a look but might not find time until next week.</p>

<a name="185314592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185314592" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185314592">Daniel Selsam (Jan 10 2020 at 14:35)</a>:</h4>
<p>We are submitting to IJCAR 2020, January 23rd deadline</p>

<a name="185318515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185318515" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185318515">Johan Commelin (Jan 10 2020 at 15:15)</a>:</h4>
<p><span class="user-mention" data-user-id="230999">@Daniel Selsam</span> See <a href="https://www.math.sciences.univ-nantes.fr/~gouezel/" target="_blank" title="https://www.math.sciences.univ-nantes.fr/~gouezel/">https://www.math.sciences.univ-nantes.fr/~gouezel/</a> for how to spell <span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span>'s name outside of Zulip <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>

<a name="185320293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185320293" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185320293">Johan Commelin (Jan 10 2020 at 15:34)</a>:</h4>
<blockquote>
<p>Thus even though e.g. lists and multisets may usefully coerce into each other, one direction must be chosen arbitrarily for the Coe instance and the other must be sacrificed.</p>
</blockquote>
<p>How do you coerce a multiset into a list? You've lost the ordering... Do you want "multisets" and "finsets"? (Note that the generic mathematical reader won't recognize "finset", but then, they aren't your target audience anyway.)</p>

<a name="185320352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185320352" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185320352">Johan Commelin (Jan 10 2020 at 15:35)</a>:</h4>
<p>Also... you talk about coercions between "bijective" types. But for example <code>multiset</code> and <code>finset</code> are not bijective. It's just that there are natural maps in both directions, but those maps are not bijections.</p>

<a name="185320490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185320490" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185320490">Johan Commelin (Jan 10 2020 at 15:36)</a>:</h4>
<p>Minor comment:</p>
<blockquote>
<p>allows reducing the scalars in a module</p>
</blockquote>
<p>It's <em>restricting</em> scalars, not "reducing"</p>

<a name="185321363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185321363" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185321363">Johan Commelin (Jan 10 2020 at 15:45)</a>:</h4>
<p><span class="user-mention" data-user-id="230999">@Daniel Selsam</span> Is this new typeclass resolution procedure implemented in Lean4 or in C++?</p>

<a name="185321667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185321667" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185321667">Daniel Selsam (Jan 10 2020 at 15:49)</a>:</h4>
<blockquote>
<p><span class="user-mention silent" data-user-id="230999">Daniel Selsam</span> Is this new typeclass resolution procedure implemented in Lean4 or in C++?</p>
</blockquote>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> in Lean4: <a href="https://github.com/leanprover/lean4/blob/master/src/Init/Lean/Meta/SynthInstance.lean" target="_blank" title="https://github.com/leanprover/lean4/blob/master/src/Init/Lean/Meta/SynthInstance.lean">https://github.com/leanprover/lean4/blob/master/src/Init/Lean/Meta/SynthInstance.lean</a></p>

<a name="185321716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185321716" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185321716">Johan Commelin (Jan 10 2020 at 15:49)</a>:</h4>
<p>Ok, cool!</p>

<a name="185321840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185321840" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185321840">Johan Commelin (Jan 10 2020 at 15:51)</a>:</h4>
<p>Is there a way to deal with diamonds that prop-eq but not def-eq?</p>

<a name="185322040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185322040" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185322040">Johan Commelin (Jan 10 2020 at 15:53)</a>:</h4>
<p>For example, Chris mentioned the other day that we'll get two <code>algebra ℚ ℂ</code> instances. But we know that <code>algebra ℚ K</code> is a subsingleton, so they must be prop-eq.</p>

<a name="185322170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185322170" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185322170">Daniel Selsam (Jan 10 2020 at 15:54)</a>:</h4>
<p>What do you mean by "deal with"? What are you afraid will happen, and what do you want to happen?</p>

<a name="185322179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185322179" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185322179">Johan Commelin (Jan 10 2020 at 15:54)</a>:</h4>
<p>But maybe this is not something that the typeclass resolution should deal with, but another part of the system.</p>

<a name="185322321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185322321" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185322321">Johan Commelin (Jan 10 2020 at 15:55)</a>:</h4>
<p>I might claim that <code>algebra_map x = algebra_map x</code>, but both sides might find different instances (especially if the expressions are a bit more complicated and not syntactically equal).</p>

<a name="185322386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185322386" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185322386">Johan Commelin (Jan 10 2020 at 15:56)</a>:</h4>
<p>And so Lean will refuse, because the <code>algebra_map</code>s come from different instances.</p>

<a name="185322425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185322425" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185322425">Johan Commelin (Jan 10 2020 at 15:56)</a>:</h4>
<p>But since those instances are prop-eq, we are a silly rw away from moving forward.</p>

<a name="185322480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185322480" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185322480">Johan Commelin (Jan 10 2020 at 15:57)</a>:</h4>
<p>But I realize now that this is not a problem that you hit during tc resolution, but during type checking</p>

<a name="185322562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185322562" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185322562">Johan Commelin (Jan 10 2020 at 15:58)</a>:</h4>
<p>So I guess it's a bit off topic in this thread.</p>

<a name="185322677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185322677" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185322677">Johan Commelin (Jan 10 2020 at 15:59)</a>:</h4>
<p><span class="user-mention" data-user-id="230999">@Daniel Selsam</span> Section 5.3 ends with a parenthetical remark (that is not properly</p>

<a name="185322808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185322808" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185322808">Daniel Selsam (Jan 10 2020 at 16:00)</a>:</h4>
<p>I have been pushing frequent fixes, including the 5.3 issue. Please reload the page.</p>

<a name="185322908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185322908" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185322908">Daniel Selsam (Jan 10 2020 at 16:01)</a>:</h4>
<p>If 5.3 still trails off for you after reloading, you may need to click some kind of "jump to most recent version of paper" button.</p>

<a name="185323900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185323900" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185323900">Daniel Selsam (Jan 10 2020 at 16:11)</a>:</h4>
<blockquote>
<p>But I realize now that this is not a problem that you hit during tc resolution, but during type checking</p>
</blockquote>
<p>This example is outside the scope of tc resolution, since presumably the two calls to tc are independent. There is a related issue we have discussed about TC though: whether to consider a second solution to the same (sub)goal to be a repeat (and so discard it) if it has the same type as the first solution, even if it is not definitionally equal to the first solution.</p>

<a name="185324025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185324025" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185324025">Daniel Selsam (Jan 10 2020 at 16:12)</a>:</h4>
<p>Our current plan is to say that typeclasses are "morally canonical", and consider a solution (to a subgoal) to be a repeat if it has the same type as a previous solution.</p>

<a name="185324260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185324260" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185324260">Daniel Selsam (Jan 10 2020 at 16:14)</a>:</h4>
<p>The "morally canonical" assumption would be violated by <code>Algebra</code>, and some downstream goals may succeed or fail depending on which specific instance to <code>Algebra</code> is found first.</p>

<a name="185324441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185324441" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185324441">Johan Commelin (Jan 10 2020 at 16:16)</a>:</h4>
<p>Aah, it might be that it still pops up here...</p>

<a name="185324471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185324471" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185324471">Johan Commelin (Jan 10 2020 at 16:16)</a>:</h4>
<p>Note that in general <code>Algebra R A</code> is not a subsingleton... but if <code>R</code> is <code>\Z</code> or <code>\Q</code>, then it is...</p>

<a name="185324520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185324520" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185324520">Daniel Selsam (Jan 10 2020 at 16:17)</a>:</h4>
<p>Edited my comment -- the assumption is violated whether or not Algebra is a subsingleton.</p>

<a name="185324863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185324863" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185324863">Johan Commelin (Jan 10 2020 at 16:20)</a>:</h4>
<p>By transitivity <code>algebra R A</code> and <code>f</code> will give me another instance of <code>algebra R B</code>, and by some property field of <code>alg_hom</code> we know that <code>f</code> ensures it is prop-eq to the existing instance of <code>algebra R B</code>.<br>
Mathematicians treat these instances as def-eq all the time.</p>

<a name="185324875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185324875" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185324875">Johan Commelin (Jan 10 2020 at 16:20)</a>:</h4>
<p>Or if <code>R</code> is any field</p>

<a name="185324877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185324877" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185324877">Johan Commelin (Jan 10 2020 at 16:21)</a>:</h4>
<p>Suppose we have <code>algebra R A</code>, <code>algebra R B</code> and <code>f : alg_hom[R] A B</code> in the context.</p>

<a name="185324902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185324902" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185324902">Johan Commelin (Jan 10 2020 at 16:21)</a>:</h4>
<p>Oops... messages are mangled up by German telecom</p>

<a name="185325802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185325802" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185325802">Daniel Selsam (Jan 10 2020 at 16:29)</a>:</h4>
<p>Can you come up with an example where typeclass resolution will succeed or fail depending on which of two different instances with the same type are discovered first for some subgoal?</p>

<a name="185326046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185326046" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185326046">Daniel Selsam (Jan 10 2020 at 16:31)</a>:</h4>
<p>How about I try to come up with a toy example first to make the issue clear, and then you can try to come up with a real example that would exhibit the same problem.</p>

<a name="185328210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185328210" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185328210">Chris Hughes (Jan 10 2020 at 16:51)</a>:</h4>
<p>I don't think typeclass inference fails in these situations, the problem tends to be that it infers two different instances in different situations, so terms that look the same, and are in fact equal aren't definitionally equal, so <code>exact</code> doesn't work when it looks like it should.</p>

<a name="185328504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185328504" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185328504">Daniel Selsam (Jan 10 2020 at 16:54)</a>:</h4>
<p>Very artificial example but just to give intuition:</p>
<div class="codehilite"><pre><span></span><span class="n">class</span> <span class="n">Foo</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">Bool</span><span class="o">)</span>
<span class="n">class</span> <span class="n">Bar</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">Bool</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="o">())</span>
<span class="n">class</span> <span class="n">Rig</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="o">())</span>

<span class="kn">instance</span> <span class="n">FooToBar</span> <span class="o">[</span><span class="n">f</span><span class="o">:</span><span class="n">Foo</span><span class="o">]</span> <span class="o">:</span> <span class="n">Bar</span> <span class="n">f</span><span class="bp">.</span><span class="n">b</span> <span class="o">:=</span> <span class="o">{}</span>
<span class="kn">instance</span> <span class="n">BarToRig</span> <span class="o">[</span><span class="n">Bar</span> <span class="n">true</span><span class="o">]</span> <span class="o">:</span> <span class="n">Rig</span> <span class="o">:=</span> <span class="o">{}</span>

<span class="kn">instance</span> <span class="n">FooTrue</span>  <span class="o">:</span> <span class="n">Foo</span> <span class="o">:=</span> <span class="o">{</span><span class="n">b</span> <span class="o">:=</span> <span class="n">true</span><span class="o">}</span>
<span class="kn">instance</span> <span class="n">FooFalse</span> <span class="o">:</span> <span class="n">Foo</span> <span class="o">:=</span> <span class="o">{</span><span class="n">b</span> <span class="o">:=</span> <span class="n">false</span><span class="o">}</span>

<span class="c1">-- There are two instances to Foo with different values.</span>
<span class="c1">-- Since they have the same type, the second one found is discarded.</span>
<span class="c1">-- The overall query succeeds only if the first one found happens to be `FooTrue`.</span>

<span class="n">def</span> <span class="n">synthRig</span> <span class="o">[</span><span class="n">Rig</span><span class="o">]</span> <span class="o">:</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="o">()</span>
<span class="kn">example</span> <span class="o">:</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="n">synthRig</span>
</pre></div>

<a name="185328736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185328736" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185328736">Daniel Selsam (Jan 10 2020 at 16:56)</a>:</h4>
<blockquote>
<p>I don't think typeclass inference fails in these situations, the problem tends to be that it infers two different instances in different situations, so terms that look the same, and are in fact equal aren't definitionally equal, so <code>exact</code> doesn't work when it looks like it should.</p>
</blockquote>
<p>I agree with <span class="user-mention" data-user-id="112680">@Johan Commelin</span> that the issue you are describing is probably better addressed after the fact, outside of typeclass resolution. Note that Lean3 had a subsingleton-canonicalizer which would address this problem.</p>

<a name="185329385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185329385" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185329385">Chris Hughes (Jan 10 2020 at 17:04)</a>:</h4>
<p>Here's an example that comes up in practice</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">constant</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span>

<span class="n">attribute</span> <span class="o">[</span><span class="n">class</span><span class="o">]</span> <span class="n">fintype</span>

<span class="n">def</span> <span class="n">card</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">constant</span> <span class="n">fintype_range</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">fintype</span> <span class="err">↥</span><span class="n">p</span>

<span class="n">attribute</span> <span class="o">[</span><span class="kn">instance</span><span class="o">]</span> <span class="n">fintype_range</span>

<span class="kn">instance</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">lemma</span> <span class="n">subset_lemma</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">card</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">card</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">card</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="n">f</span><span class="o">)</span> <span class="bp">=</span> <span class="n">card</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="n">f</span><span class="o">):=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">subset_lemma</span><span class="o">],</span> <span class="c1">--fails</span>
<span class="kn">end</span>
</pre></div>

<a name="185345362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185345362" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185345362">Daniel Selsam (Jan 10 2020 at 19:57)</a>:</h4>
<p><span class="user-mention" data-user-id="110044">@Chris Hughes</span> Thanks. I don't think this is an issue with typeclass resolution though. Higher-level tactics can be made to hide this kind of complication, similar to the way <code>simp</code> does.</p>

<a name="185362526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185362526" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185362526">Tim Daly (Jan 10 2020 at 23:51)</a>:</h4>
<p><span class="user-mention" data-user-id="230999">@Daniel Selsam</span> Note that the Diamond problem has been around a while. Symbolics Common Lisp solved this using the "Mixin" idea (<a href="https://en.wikipedia.org/wiki/Mixin" target="_blank" title="https://en.wikipedia.org/wiki/Mixin">https://en.wikipedia.org/wiki/Mixin</a>) in its Flavors implementation. Common Lisp Object System (CLOS) has rules (<a href="http://www.lambdafaq.org/how-are-conflicting-method-declarations-resolved" target="_blank" title="http://www.lambdafaq.org/how-are-conflicting-method-declarations-resolved">http://www.lambdafaq.org/how-are-conflicting-method-declarations-resolved</a>).</p>

<a name="185370110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185370110" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185370110">Tim Daly (Jan 11 2020 at 02:42)</a>:</h4>
<p>Also note that CLOS checks class precedence to check for the cycle problem.</p>

<a name="185375312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185375312" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185375312">Johan Commelin (Jan 11 2020 at 05:23)</a>:</h4>
<p><span class="user-mention" data-user-id="223495">@Tim Daly</span> Is there any reason to think that diamonds in those systems can be dealt with in the same way as diamonds in the algebraic hierarchy of an interactive theorem prover? Intuitively it feels to me like they might need different solutions.</p>

<a name="185378278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185378278" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185378278">Tim Daly (Jan 11 2020 at 07:06)</a>:</h4>
<p>Axiom struggled with similar problems. Here is an abbreviated form of Axiom's typeclasses: <a href="https://github.com/daly/PDFS/blob/master/endpaper.pdf" target="_blank" title="https://github.com/daly/PDFS/blob/master/endpaper.pdf">https://github.com/daly/PDFS/blob/master/endpaper.pdf</a> and the full form (with typeclass abbreviated names): <a href="http://axiom-developer.org/axiom-website/bookvol10.2abb.html" target="_blank" title="http://axiom-developer.org/axiom-website/bookvol10.2abb.html">http://axiom-developer.org/axiom-website/bookvol10.2abb.html</a></p>

<a name="185378404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185378404" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185378404">Tim Daly (Jan 11 2020 at 07:10)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> If you have a function with the same name and same signature but different semantics available on two different paths there are various schemes to resolve them. Axiom knows that a function FOO on the path from typeclass X can be different from FOO on the path from typeclass Y. The compiler will complain. But you can be explicit FOO$X or FOO$Y where the $ operator explicitly says "use this typeclass"</p>

<a name="185378732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185378732" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185378732">Johan Commelin (Jan 11 2020 at 07:22)</a>:</h4>
<p>How is that remark relevant  to my reply to your remark about how lisp flavours solved the diamond problem?</p>

<a name="185380831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185380831" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185380831">Tim Daly (Jan 11 2020 at 08:37)</a>:</h4>
<p>Sorry, I thought the referenced Wikipedia article covered that question. Flavors was merged into the Common Lisp standard as the Common Lisp Object System (CLOS) </p>
<p>"CLOS allows multiple inheritance. When the default order in which methods are executed in multiple inheritance is not correct, the programmer may resolve the diamond inheritance problems by specifying the order of method combinations".</p>
<p>"CLOS attempts to provide both reasonable default behavior and the ability to override it... by giving a specific method resolution order or stating a rule for combining methods. This is called 'method combination', which may be fully controlled. The MOP (metaobject protocol) also provides means to modify the inheritance, dynamic dispatch, class instantiation, and other internal mechanisms without affecting the stability of the system."</p>
<p>Essentially the CLOS programmer can specify their own method of solving the diamond problem by writing 'method combinators'. So you can override the system-provided version in a specific case if you need to. This was derived from the Symbolics Flavors system.</p>

<a name="185380934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185380934" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185380934">Tim Daly (Jan 11 2020 at 08:40)</a>:</h4>
<p>See <a href="http://www.bracha.org/oopsla90.pdf" target="_blank" title="http://www.bracha.org/oopsla90.pdf">http://www.bracha.org/oopsla90.pdf</a> ... Mixin-based Inheritance</p>

<a name="185381102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185381102" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185381102">Tim Daly (Jan 11 2020 at 08:47)</a>:</h4>
<p>Axiom's approach is "Well, you've got two functions from different paths with the same signature. That's fine but you have to tell me which one you mean when you decide to use it."</p>

<a name="185381157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185381157" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185381157">Tim Daly (Jan 11 2020 at 08:49)</a>:</h4>
<p>If Lean were implemented in Common Lisp it would be much easier to resolve certain problems. (Disclosure: I'm a lisper, in case that isn't obvious)</p>

<a name="185381219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185381219" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185381219">Tim Daly (Jan 11 2020 at 08:51)</a>:</h4>
<p>Lean could adopt the approach of specifying not only the name of the function but, if there are duplicates, also specifying the particular typeclass (otherwise complain).</p>

<a name="185381893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185381893" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185381893">Johan Commelin (Jan 11 2020 at 09:15)</a>:</h4>
<blockquote>
<p>If Lean were implemented in Common Lisp it would be much easier to resolve certain problems. (Disclosure: I'm a lisper, in case that isn't obvious)</p>
</blockquote>
<p>Too bad (for you) that most of Lean4 is implemented in Lean4...</p>

<a name="185381898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185381898" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185381898">Johan Commelin (Jan 11 2020 at 09:16)</a>:</h4>
<p>In Lean it is always possible to explicitly provide the type class. So I think all of the things you've described are already available. The point is (mostly) that we want things to be fast.</p>

<a name="185381942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185381942" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185381942">Johan Commelin (Jan 11 2020 at 09:16)</a>:</h4>
<p>My remark was that mathlib's diamonds are probably the same kind as those in Lisp, but considerably more complex.</p>

<a name="185382597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185382597" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185382597">Tim Daly (Jan 11 2020 at 09:38)</a>:</h4>
<p>Actually, that's a huge win. I'm looking forward to seeing the implementation.</p>

<a name="185389661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185389661" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185389661">Daniel Selsam (Jan 11 2020 at 13:22)</a>:</h4>
<p><span class="user-mention" data-user-id="223495">@Tim Daly</span> Thanks for sharing the links. We seem to be using the phrase <em>diamond problem</em> to mean slightly different things.  In Lean, in the common case, all the different paths through the diamond towers lead to the same implementation.  So, deciding among alternative implementations is not the main challenge. The problem is that towers of diamonds in the instance graph induce an exponential number of paths, and without care, certain queries will spend exponential time traversing these paths. The diamond problem for us is purely a performance problem.</p>

<a name="185390666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185390666" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185390666">Tim Daly (Jan 11 2020 at 13:52)</a>:</h4>
<p>The term 'diamond problem' has a long history. You might want to be very clear up front to distinguish your problem from the other uses of the term.</p>

<a name="185390808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185390808" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185390808">Tim Daly (Jan 11 2020 at 13:57)</a>:</h4>
<p>If your problem is only that you might encounter the same object on different paths, it might help to memoize the path information so you never traverse it more than once. I will reread the paper with your new definition. I assumed more about the problem than you wrote I guess. My apology for the mistake.</p>

<a name="185391293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185391293" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185391293">Jason Rute (Jan 11 2020 at 14:11)</a>:</h4>
<p>Also Rust is another language using type classes or something similar.  Is any of this a concern there?</p>

<a name="185391928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185391928" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185391928">Jason Rute (Jan 11 2020 at 14:27)</a>:</h4>
<p>In Scala, <em>implicits</em> are similar to Lean's type classes. They are used  to support ad-hoc polymorphism, coercion, and true-type classes.  They also have a similar syntax to Lean.  I know they are one fo the things which makes compiling Scala so slow, particularly because of <em>implicit macros</em>, which are the Scala analogue of instances depending on other instances.  Do you know off-hand if your method can be used to speed up implicit resolution in Scala?  (Or if Scala uses a method similar to yours already?)  I know the implicit resolution in Scala has some additional concerns such as trying to resolve implicits in closer levels of scope first.  Also, I haven't checked for sure that diamonds or loops are allowed in implicit macros.  Last, I don't know for sure that the slow down in implicit search in practice is due to an exponential search tree or if it is due to the execution time of the code in the implicit macros.  Just curious if you have any thoughts on this.</p>

<a name="185391976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185391976" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185391976">Jason Rute (Jan 11 2020 at 14:28)</a>:</h4>
<p>(Due to the Zulip mobile app issues, my messages got reversed.)</p>

<a name="185392639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185392639" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185392639">Jason Rute (Jan 11 2020 at 14:49)</a>:</h4>
<p>Actually, I just checked with some Scala code.  Diamonds are allowed in Scala in the sense that you can write the code.  However, implicit search will fall if it finds two ways to resolve the same implicit at the same level of scope, so if the top of the diamond is inhabited, it will complain that there are two ways to match the expected type (even if they evaluate the same).  This must mean it is checking all the paths (at least until it finds two satisfied paths).  In that case, I hope it is doing something similar to your method or it could be checking an exponential number of paths.</p>

<a name="185392767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185392767" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185392767">Daniel Selsam (Jan 11 2020 at 14:53)</a>:</h4>
<p><span class="user-mention" data-user-id="115715">@Jason Rute</span> Thanks. I have never used Scala and know very little about it. Could you please share your diamond example?</p>

<a name="185393609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185393609" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185393609">Jason Rute (Jan 11 2020 at 15:17)</a>:</h4>
<p>You can paste this into a scala REPL.</p>
<div class="codehilite"><pre><span></span><span class="c1">// The classes</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">A</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>  <span class="c1">// this like a structure type</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">B</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">C</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">D</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>

<span class="c1">// the implicit macros</span>
<span class="k">implicit</span> <span class="k">def</span> <span class="n">dToC</span><span class="o">(</span><span class="k">implicit</span> <span class="n">d</span><span class="k">:</span> <span class="kt">D</span><span class="o">)</span><span class="k">:</span> <span class="kt">C</span> <span class="o">=</span> <span class="n">C</span><span class="o">(</span><span class="n">d</span><span class="o">.</span><span class="n">n</span><span class="o">)</span>
<span class="k">implicit</span> <span class="k">def</span> <span class="n">dToB</span><span class="o">(</span><span class="k">implicit</span> <span class="n">d</span><span class="k">:</span> <span class="kt">D</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=</span> <span class="n">B</span><span class="o">(</span><span class="n">d</span><span class="o">.</span><span class="n">n</span><span class="o">)</span>
<span class="k">implicit</span> <span class="k">def</span> <span class="n">bToA</span><span class="o">(</span><span class="k">implicit</span> <span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="n">n</span><span class="o">)</span>
<span class="k">implicit</span> <span class="k">def</span> <span class="n">cToA</span><span class="o">(</span><span class="k">implicit</span> <span class="n">c</span><span class="k">:</span> <span class="kt">C</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">(</span><span class="n">c</span><span class="o">.</span><span class="n">n</span><span class="o">)</span>

<span class="c1">// case 1: only one valid path.  This block will return A(42)</span>
<span class="o">{</span>  <span class="c1">// restrict scope</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="n">b</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=</span> <span class="n">B</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>
 <span class="c1">// can use implicitly to check implicit implicit resolution &quot;def implicitly[T](implicit t : T): T = T&quot;</span>
 <span class="n">implicitly</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="o">}</span>

<span class="c1">// case 2: two valid paths which meet together.  This will fail.</span>
<span class="o">{</span>  <span class="c1">// restrict scope</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="n">d</span><span class="k">:</span> <span class="kt">D</span> <span class="o">=</span> <span class="n">D</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>
  <span class="n">implicitly</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>   <span class="c1">// compiler will complain about &quot;ambiguous implicit values&quot;</span>
<span class="o">}</span>

<span class="c1">// case 3: two valid paths (one which extends the other). This will succeed and return A(43)</span>
<span class="o">{</span>  <span class="c1">// restrict scope</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="n">b</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=</span> <span class="n">B</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="n">d</span><span class="k">:</span> <span class="kt">D</span> <span class="o">=</span> <span class="n">D</span><span class="o">(</span><span class="mi">43</span><span class="o">)</span>
  <span class="n">implicitly</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="o">}</span>

<span class="c1">// case 3: two valid paths not extending each other. This will fail.</span>
<span class="o">{</span>  <span class="c1">// restrict scope</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="n">b</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=</span> <span class="n">B</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="n">c</span><span class="k">:</span> <span class="kt">C</span> <span class="o">=</span> <span class="n">C</span><span class="o">(</span><span class="mi">43</span><span class="o">)</span>
  <span class="n">implicitly</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>   <span class="c1">// compiler will complain about &quot;ambiguous implicit values&quot;</span>
<span class="o">}</span>
</pre></div>

<a name="185395015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185395015" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185395015">Daniel Selsam (Jan 11 2020 at 15:59)</a>:</h4>
<p><span class="user-mention" data-user-id="115715">@Jason Rute</span> Thank you very much. I just confirmed that it also scales exponentially on the tower of (failing) diamonds.</p>

<a name="185395083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185395083" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185395083">Daniel Selsam (Jan 11 2020 at 16:00)</a>:</h4>
<p>I am not sure if it merits putting in the paper though. For all I know, their instance logic may be simple enough that relatively naive caching would address this. And I doubt it is a problem in practice for them.</p>

<a name="185395152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185395152" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185395152">Daniel Selsam (Jan 11 2020 at 16:03)</a>:</h4>
<p>Haskell is the same boat. We discuss and compare against Haskell mainly due its historical significance in pioneering typeclasses. I suspect Haskell could implement a simple caching scheme, and I highly doubt it would make sense for them to implement tabled resolution.</p>

<a name="185842670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185842670" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185842670">Rob Lewis (Jan 16 2020 at 18:13)</a>:</h4>
<p><span class="user-mention" data-user-id="230999">@Daniel Selsam</span> Thanks for sharing the paper, it's very nice. Very excited to use the new procedure in Lean 4. I have some minor line comments on the paper I'll send you directly, but a few more general points:</p>
<ul>
<li>
<p>One of the frustrating parts of Lean 3 type class resolution is error reporting. To some extent I think this is inherent in the algorithm, it can be hard to localize what goes wrong. I wonder if this gets better or worse with tabled resolution. Is this something you've thought about at all and is there anything worth saying in the paper? I'd be very interested to read a paragraph on this in section 5.5 if there is.</p>
</li>
<li>
<p>Both appear in the literature, but "type class" seems to be more common than "typeclass" (except maybe surrounding Coq). Any reason to prefer the latter?</p>
</li>
<li>
<p>There might not be space, but I'd be curious to see one or two more examples at the end, eg the frustrating int coe issue we had in mathlib. I don't think it fits the same pattern as the tower of diamonds. (edit - thinking harder, maybe it is essentially the same idea?)</p>
</li>
<li>
<p>Mathlib is dropped in toward the beginning without introduction. One of the reasons we wrote the mathlib paper was just for this reason, so we can cite it without describing it!</p>
</li>
</ul>

<a name="185842835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185842835" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185842835">Patrick Massot (Jan 16 2020 at 18:15)</a>:</h4>
<p>Another question that Coq users keep asking whenever we mention type class resolution. Will we have <a href="https://en.wikipedia.org/wiki/Cut_(logic_programming)" target="_blank" title="https://en.wikipedia.org/wiki/Cut_(logic_programming)">cuts</a>?</p>

<a name="185846970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185846970" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185846970">Daniel Selsam (Jan 16 2020 at 18:56)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> To the best of my knowledge, nobody has yet brought to our attention any issue that cuts might help address, so we haven't considered it.</p>

<a name="185847550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185847550" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185847550">Daniel Selsam (Jan 16 2020 at 19:02)</a>:</h4>
<blockquote>
<p>Mathlib is dropped in toward the beginning without introduction. One of the reasons we wrote the mathlib paper was just for this reason, so we can cite it without describing it!</p>
</blockquote>
<p>Funny, I thought we cited the Mathlib paper in both the abstract and the introduction, but we don't seem to cite it all... <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span> ... must have gotten lost during refactoring. Great catch!</p>

<a name="185848459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185848459" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185848459">Daniel Selsam (Jan 16 2020 at 19:11)</a>:</h4>
<blockquote>
<p>One of the frustrating parts of Lean 3 type class resolution is error reporting. To some extent I think this is inherent in the algorithm, it can be hard to localize what goes wrong. I wonder if this gets better or worse with tabled resolution. Is this something you've thought about at all and is there anything worth saying in the paper? I'd be very interested to read a paragraph on this in section 5.5 if there is.</p>
</blockquote>
<p>This is an interesting question. Tracing and error reporting for typeclass resolution will be <em>way</em> better in Lean4, not because of the tabled typeclass resolution procedure but because of a much better system-wide tracing framework. I think tabling will help as well, but not for any deep reason -- mainly just because the traces will be that much shorter (in some cases, exponentially shorter). I don't think this is a paper-worthy insight though.</p>

<a name="185848799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185848799" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185848799">Daniel Selsam (Jan 16 2020 at 19:14)</a>:</h4>
<p>The discrimination trees (S5.3, indexing the instances) will shrink the traces a lot too. Lean3 tries to resolve every goal with every instance whose result type has the same head symbol, and the vast majority of these attempts fail. Lean4 will only try a much smaller superset of the instances that will successfully resolve.</p>

<a name="185850707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185850707" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185850707">Daniel Selsam (Jan 16 2020 at 19:32)</a>:</h4>
<blockquote>
<p>the frustrating int coe issue we had in mathlib</p>
</blockquote>
<p>AFAICT this issue is just the "succeeding diamond following by failing downstream goal" variant of the diamond problem, which will be solved by tabling (and is also solved by Coq's short-circuit trick). However, even without the exponential blowup, typeclass resolution still does need to do search, so the "most-constrained variable first" advice you gave in Zulip awhile back is still sound.</p>

<a name="185851275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185851275" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185851275">Daniel Selsam (Jan 16 2020 at 19:38)</a>:</h4>
<blockquote>
<p>Both appear in the literature, but "type class" seems to be more common than "typeclass" (except maybe surrounding Coq). Any reason to prefer the latter?</p>
</blockquote>
<p>I prefer "typeclass", since typeclass is a distinct concept from the compositional meaning of "type class". I also always write "datastructure" as opposed to "data structure" for the same reason.</p>

<a name="185858514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185858514" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185858514">Patrick Massot (Jan 16 2020 at 20:51)</a>:</h4>
<blockquote>
<p>To the best of my knowledge, nobody has yet brought to our attention any issue that cuts might help address, so we haven't considered it.</p>
</blockquote>
<p>I know nothing about this, I'm only repeating questions I heard <span class="user-mention" data-user-id="110193">@Cyril Cohen</span> and <span class="user-mention" data-user-id="110172">@Assia Mahboubi</span> asking.</p>

<a name="185858791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185858791" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185858791">Rob Lewis (Jan 16 2020 at 20:54)</a>:</h4>
<p>I see, thanks for clarifying! With the error reporting, my hope was that it might be possible to extract some kind of list of possible missing instances from the info in the table. I don't have any real proposal on how to do this; it just seems more plausible than with the old method. Maybe it's really just a matter of size. Either way, it does sound like the new approach will be way easier to work with. So thanks again.</p>

<a name="185860924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185860924" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185860924">Sebastian Ullrich (Jan 16 2020 at 21:13)</a>:</h4>
<p>There could be some heuristics like reporting the "deepest" failing goal as the "most likely point of failure". This is relatively independent of the actual algorithm, could be worth an experiment at some point.</p>

<a name="185867331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185867331" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185867331">Daniel Selsam (Jan 16 2020 at 22:11)</a>:</h4>
<blockquote>
<p>There could be some heuristics like reporting the "deepest" failing goal as the "most likely point of failure". This is relatively independent of the actual algorithm, could be worth an experiment at some point.</p>
</blockquote>
<p>Depth is not as straightforward a concept in tabled resolution as it is in SLD.</p>

<a name="185899823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185899823" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185899823">Cyril Cohen (Jan 17 2020 at 09:28)</a>:</h4>
<p>Hi, not only cuts are a good tool to control the behavior of backtracking during proof search, but they are also a good tool for debugging, in order to find in which branch the problems are actually happening, and to get a cleaner trace.</p>

<a name="185950466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185950466" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185950466">Daniel Selsam (Jan 17 2020 at 19:54)</a>:</h4>
<blockquote>
<p>Hi, not only cuts are a good tool to control the behavior of backtracking during proof search, but they are also a good tool for debugging, in order to find in which branch the problems are actually happening, and to get a cleaner trace.</p>
</blockquote>
<p>My hope is that typeclass resolution will be so fast in mathlib4 that there will be no need try to improve performance further using <code>cut</code>. As for debugging, In Lean4, the trace messages are collected in a datastructure, and users will be able to write their owns scripts for traversing and filtering the traces as they desire.</p>

<a name="186119148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186119148" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186119148">Bas Spitters (Jan 20 2020 at 17:08)</a>:</h4>
<p>I'm new here. Thanks for the nice paper!<br>
I understand lean does not use canonical structures. Can anyone clarify, as they are popular in Coq (math-comp)</p>
<p>This should probably go somewhere else, but I'd like to understand more about congruence, and more generally automation in lean.<br>
Is the congruence paper still the best reference?</p>

<a name="186130428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186130428" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186130428">Reid Barton (Jan 20 2020 at 20:18)</a>:</h4>
<p>The short explanation is that type classes perform the corresponding function</p>

<a name="186148438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186148438" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186148438">Daniel Selsam (Jan 21 2020 at 02:49)</a>:</h4>
<blockquote>
<p>I'm new here. Thanks for the nice paper!<br>
I understand lean does not use canonical structures. Can anyone clarify, as they are popular in Coq (math-comp)</p>
</blockquote>
<p><span class="user-mention" data-user-id="259452">@Bas Spitters</span> Welcome! Typeclasses are remarkably simple and versatile, and (at least with tabling) seem to work extremely well for zillions of diverse uses. Do you see any major advantages offered by canonical structures?</p>

<a name="186149253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186149253" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186149253">Daniel Selsam (Jan 21 2020 at 03:08)</a>:</h4>
<blockquote>
<p>This should probably go somewhere else, but I'd like to understand more about congruence, and more generally automation in lean.<br>
Is the congruence paper still the best reference?</p>
</blockquote>
<p>We haven't started building automation for Lean4 yet. Note that the congruence closure procedure from IJCAR2016 doesn't seem to be that popular in mathlib --- the main workhorse has been the simplifier. We are not currently planning many changes to the simplifier, though our preliminary experiments suggest that we may be able to improve its performance by 10-100x. Mathlib also includes many diverse, interesting tactics written by users. You may want to ask a mathlib power-user to give you a tour.</p>

<a name="186149566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186149566" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186149566">Mario Carneiro (Jan 21 2020 at 03:17)</a>:</h4>
<p><span class="user-mention" data-user-id="230999">@Daniel Selsam</span> Can you give any clues as to where the 10x performance improvement in <code>simp</code> is likely to come from?</p>

<a name="186151247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186151247" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186151247">Simon Hudon (Jan 21 2020 at 03:56)</a>:</h4>
<p>Already indexing <code>simp</code> lemmas with discrimation trees should make a big difference. Right now, if you have a lemma of the same <code>@coe (list a) (multiset a) xs = ...</code>, it is simply indexed by the function name <code>coe</code>. With a discrimination tree, you can have the index distinguish between <code>@coe (list a) (multiset a) xs</code> and <code>@coe nat int n</code>. Where as the Lean 3 solution gives us hundreds of collisions for <code>coe</code>, the Lean 4 solution should narrow down the search more aggressively before trying to apply rewrite rules.</p>

<a name="186163436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186163436" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186163436">Patrick Massot (Jan 21 2020 at 08:46)</a>:</h4>
<p><span class="user-mention" data-user-id="230999">@Daniel Selsam</span> do you know what happened to <a href="https://github.com/leanprover/lean/wiki/Simplifier-Features" target="_blank" title="https://github.com/leanprover/lean/wiki/Simplifier-Features">https://github.com/leanprover/lean/wiki/Simplifier-Features</a>? It seemed to have many ideas to improve the simplifier. Note that most of it is covered by the golden rule of automation: compare with Isabelle.</p>

<a name="186172293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186172293" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186172293">Daniel Selsam (Jan 21 2020 at 11:01)</a>:</h4>
<blockquote>
<p><span class="user-mention silent" data-user-id="230999">Daniel Selsam</span> Can you give any clues as to where the 10x performance improvement in <code>simp</code> is likely to come from?</p>
</blockquote>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> By far the single biggest speedup will come from better caching of the simp sets. Last I checked, building mathlib involves ~70 minutes of building simp sets but only ~25 minutes inside the actual simplifier. A second big speedup will come from using discrimination trees instead of head maps as <span class="user-mention" data-user-id="110026">@Simon Hudon</span> said. A third will come from being more careful not to accidentally traverse huge terms (e.g. by eagerly reducing projections and abstracting all proof terms).</p>

<a name="186172597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186172597" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186172597">Daniel Selsam (Jan 21 2020 at 11:05)</a>:</h4>
<blockquote>
<p><span class="user-mention silent" data-user-id="230999">Daniel Selsam</span> do you know what happened to <a href="https://github.com/leanprover/lean/wiki/Simplifier-Features" target="_blank" title="https://github.com/leanprover/lean/wiki/Simplifier-Features">https://github.com/leanprover/lean/wiki/Simplifier-Features</a>? It seemed to have many ideas to improve the simplifier. Note that most of it is covered by the golden rule of automation: compare with Isabelle.</p>
</blockquote>
<p>I was not aware of this document. Thank you for sharing.</p>

<a name="186204508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186204508" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186204508">Bas Spitters (Jan 21 2020 at 17:11)</a>:</h4>
<p>Here's a problem with the fully unbundled approach. The term size can blow up, so we need a mechanism to go between bundled and unbundled structures. My understanding is that you are using the (mostly) unbundled approach in lean.<br>
I believe this is also a main argument by the math-comp group to use canonical structures.<br>
It has been argued that we'd need general unification hints to get the best of both worlds (type classes and canonical structures)<br>
<a href="https://coq.discourse.group/t/blog-post-exponential-blowup-when-using-unbundled-typeclasses-to-model-algebraic-hierarchies/289/2" target="_blank" title="https://coq.discourse.group/t/blog-post-exponential-blowup-when-using-unbundled-typeclasses-to-model-algebraic-hierarchies/289/2">https://coq.discourse.group/t/blog-post-exponential-blowup-when-using-unbundled-typeclasses-to-model-algebraic-hierarchies/289/2</a></p>

<a name="186211320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186211320" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186211320">Floris van Doorn (Jan 21 2020 at 18:22)</a>:</h4>
<p><span class="user-mention" data-user-id="259452">@Bas Spitters</span> Note that Lean 3 does not use the fully unbundled approach. We use a partially bundled approach (for most classes in the algebraic hierarchy only the type is an argument to the class). This doesn't have the exponential blowup problem. This was also discussed here:<br>
<a href="#narrow/stream/113488-general/topic/what.20is.20a.20diamond.3F" title="#narrow/stream/113488-general/topic/what.20is.20a.20diamond.3F">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what.20is.20a.20diamond.3F</a></p>
<p>There are problems with canonical structures as well. One thing I dislike about canonical structures is the amount of boilerplate code you have to write to add a new structure to the hierarchy (for example, the number of unification hints you have to explicitly declare is quadratic in the number of structures, and forgetting one can cause hard-to-debug errors).<br>
Combining both type classes and canonical structures in a library sounds very dangerous: it sounds a lot more manageable to stick with a single approach, than continually translating between two different approaches.</p>

<a name="186219826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186219826" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186219826">Daniel Selsam (Jan 21 2020 at 19:50)</a>:</h4>
<blockquote>
<p>Here's a problem with the fully unbundled approach. The term size can blow up</p>
</blockquote>
<p>AFAICT only the term <em>tree</em> size blows up, and I don't see any fundamental reason why all operations in the system couldn't in principle be made to scale in the dag sizes instead of the tree sizes. Note that Lean currently does scale exponentially on <a href="#narrow/stream/113488-general/topic/huge.20term.20trees/near/185818383" title="#narrow/stream/113488-general/topic/huge.20term.20trees/near/185818383">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge.20term.20trees/near/185818383</a> , though this is a conscious decision: we don't hash-cons and we use faster, imprecise caches in many places. Some recent discussion at <a href="#narrow/stream/113488-general/topic/huge.20term.20trees" title="#narrow/stream/113488-general/topic/huge.20term.20trees">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge.20term.20trees</a></p>

<a name="186334761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186334761" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186334761">Daniel Selsam (Jan 22 2020 at 21:51)</a>:</h4>
<p>FYI the paper is on arXiv now: <a href="https://arxiv.org/abs/2001.04301" target="_blank" title="https://arxiv.org/abs/2001.04301">https://arxiv.org/abs/2001.04301</a></p>

<a name="186334851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186334851" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186334851">Patrick Massot (Jan 22 2020 at 21:52)</a>:</h4>
<p>Are there differences with the version you posted here?</p>

<a name="186334893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186334893" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186334893">Patrick Massot (Jan 22 2020 at 21:53)</a>:</h4>
<p>I can see in the reference section  "35. mathlib Community, T.: The Lean mathematical library."</p>

<a name="186334895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186334895" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186334895">Daniel Selsam (Jan 22 2020 at 21:53)</a>:</h4>
<p>Thanks again everyone for the helpful feedback.</p>

<a name="186335220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186335220" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186335220">Daniel Selsam (Jan 22 2020 at 21:56)</a>:</h4>
<blockquote>
<p>Are there differences with the version you posted here?</p>
</blockquote>
<p>Almost no changes to the description of the procedure. The main improvements are highlighting mathlib as a primary motivator, and explaining the subtle but surprisingly big gap between what typeclasses mean in most systems vs. what they mean in Coq and Lean.</p>

<a name="186340674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186340674" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186340674">Bas Spitters (Jan 22 2020 at 23:00)</a>:</h4>
<p>According to Georges, canonical structures are the real type classes in Coq. They are key in the math-comp library.<br>
One advantage is that they are predictable. It's interesting that they are not used in lean.<br>
On the other hand, they have also been an obscure feature for a long time in Coq, before they became popular in math-comp.</p>

<a name="186341885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186341885" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186341885">Daniel Selsam (Jan 22 2020 at 23:16)</a>:</h4>
<p>No one will drive us from the paradise that Wadler and Blott created for us.</p>

<a name="186341978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186341978" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186341978">Kevin Buzzard (Jan 22 2020 at 23:18)</a>:</h4>
<p>They do exist in Lean 3 but I think someone (Cyril Cohen?) once told me that they were used precisely once in mathlib, and so there was not much of an argument for keeping them in Lean 4...</p>

<a name="186342255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186342255" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186342255">Yury G. Kudryashov (Jan 22 2020 at 23:22)</a>:</h4>
<p>Semi-offtopic: it would be nice to have a document that explain current <code>mathlib</code> policies about <code>class A extends B :=</code> vs <code>class A [B] :=</code>.</p>

<a name="186342258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186342258" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186342258">François G. Dorais (Jan 22 2020 at 23:22)</a>:</h4>
<p>Are there planned changes to unification hints in Lean 4?</p>

<a name="186342285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186342285" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186342285">Mario Carneiro (Jan 22 2020 at 23:23)</a>:</h4>
<p>removal?</p>

<a name="186342298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186342298" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186342298">Mario Carneiro (Jan 22 2020 at 23:23)</a>:</h4>
<p>that's more of an "effected change" than a "planned change" though</p>

<a name="186342394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186342394" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186342394">François G. Dorais (Jan 22 2020 at 23:24)</a>:</h4>
<p>Why?</p>

<a name="186342410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186342410" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186342410">Mario Carneiro (Jan 22 2020 at 23:25)</a>:</h4>
<blockquote>
<p>They do exist in Lean 3 but I think someone (Cyril Cohen?) once told me that they were used precisely once in mathlib, and so there was not much of an argument for keeping them in Lean 4...</p>
</blockquote>

<a name="186342449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186342449" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186342449">Mario Carneiro (Jan 22 2020 at 23:25)</a>:</h4>
<p>Lean 4 also appears to be doubling down on typeclass support with this new algorithm, while effective implementation of unification hints for comparable benefit is a big wild card</p>

<a name="186342525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186342525" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186342525">Mario Carneiro (Jan 22 2020 at 23:26)</a>:</h4>
<p>Typeclasses and unification hints are somewhat mutually exclusive mechanisms, so we have to pick one and stick with it</p>

<a name="186342563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186342563" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186342563">Yury G. Kudryashov (Jan 22 2020 at 23:27)</a>:</h4>
<p>I mean, for a mathematician both <code>.. extends ..</code> and <code>... [B] ...</code> mean the same, and it's hard to guess technical consequences of choosing one over another. As far as I understand, with <code>extends</code> we have to think about diamonds, and with <code>... [B]</code> we may create really huge goals. Am I correct?</p>

<a name="186342642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186342642" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186342642">Mario Carneiro (Jan 22 2020 at 23:28)</a>:</h4>
<p>I've written about the policy before, but the short version is: if you use the same types as the parent, inherit, otherwise add it as a parameter</p>

<a name="186342707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186342707" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186342707">Daniel Selsam (Jan 22 2020 at 23:29)</a>:</h4>
<p>Before cementing a policy, I suggest figuring out where the term tree blowup is coming from that was discussed in <a href="#narrow/stream/113488-general/topic/huge.20term.20trees" title="#narrow/stream/113488-general/topic/huge.20term.20trees">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge.20term.20trees</a></p>

<a name="186342713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186342713" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186342713">Mario Carneiro (Jan 22 2020 at 23:29)</a>:</h4>
<p>The exponential blowup is in the number of mutually referring parameters in a highly parameterized definition. With this policy, this situation only arises if the typeclass relates many different types, with lots of structure between proper subsets of those types</p>

<a name="186342719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186342719" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186342719">François G. Dorais (Jan 22 2020 at 23:30)</a>:</h4>
<p>I've been using them, but they have so little support it's hard to use them. I've been using type classes and unification hints together since they can be made to work together in orthogonal directions pretty well.</p>

<a name="186342782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186342782" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186342782">Mario Carneiro (Jan 22 2020 at 23:30)</a>:</h4>
<p><span class="user-mention" data-user-id="230999">@Daniel Selsam</span> I'm talking about the lean 3 mathlib policy. This may change in lean 4 depending on how lean performs on different loads</p>

<a name="186342786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186342786" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186342786">Sebastien Gouezel (Jan 22 2020 at 23:30)</a>:</h4>
<blockquote>
<p>if you use the same types as the parent, inherit</p>
</blockquote>
<p>except if you are only addings Props and there is a big zoo of them, and an exponentially large number of possible combinations (just as in topological spaces, which might be second countable, order topology, T2, and so on). Then the Props should be mixins.</p>

<a name="186342902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186342902" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186342902">Mario Carneiro (Jan 22 2020 at 23:32)</a>:</h4>
<p>I agree with that too. You shouldn't have the definition of one such mixin depend on another as a parameter, so there is no parameter depth problem here either</p>

<a name="186342961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186342961" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186342961">Mario Carneiro (Jan 22 2020 at 23:33)</a>:</h4>
<p>A data typeclass should never have a prop mixin as a parameter, since there is no diamond problem here</p>

<a name="186343163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186343163" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186343163">Yury G. Kudryashov (Jan 22 2020 at 23:36)</a>:</h4>
<p>Another possibly stupid question. Would the following approach to algebraic classes create an exponential blow-up?</p>
<ol>
<li>Define classes <code>has_mul</code>, <code>has_add</code> (one per an operation and a constant).</li>
<li>Declare a policy "only one instance of these classes per a type".</li>
<li>Make prop classes, one per each property (e.g., <code>class is_mul_comm</code>). These classes take <code>has_mul</code> etc as parameters.</li>
<li>Create common classes (<code>group</code>, <code>monoid</code>, ...) by <code>extend</code>ing various combinations  of one-property classes.</li>
</ol>

<a name="186343289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186343289" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186343289">Chris Hughes (Jan 22 2020 at 23:38)</a>:</h4>
<p>There was talk at some point about making <code>group</code> a Prop that took a binary function as an argument.</p>

<a name="186343335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186343335" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186343335">Yury G. Kudryashov (Jan 22 2020 at 23:39)</a>:</h4>
<p>As a mathematician, I like a possibility to write a lemma taking specific <code>is_*</code> as parameters if a specific combination is not declared as a <code>class</code>. Think about all those <code>ordered_comm_monoid</code> etc.</p>

<a name="186345763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186345763" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186345763">Mario Carneiro (Jan 23 2020 at 00:13)</a>:</h4>
<p>That would not cause a blowup (the only thing that matters for that is the signatures of the classes), but it would make the hierarchy a bit larger and (IMO) a bit harder to understand, because the axioms are now separated from the useful classes. I think a policy like this is where <code>mul_zero_class</code> and <code>distrib</code> came from</p>

<a name="186345868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186345868" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186345868">Mario Carneiro (Jan 23 2020 at 00:15)</a>:</h4>
<blockquote>
<p>As a mathematician, I like a possibility to write a lemma taking specific <code>is_*</code> as parameters if a specific combination is not declared as a <code>class</code>. Think about all those <code>ordered_comm_monoid</code> etc.</p>
</blockquote>
<p>These usually can't be just combinations of classes, because there are also compatibility claims between the order and the comm_monoid part</p>

<a name="186346347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186346347" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186346347">Chris Hughes (Jan 23 2020 at 00:24)</a>:</h4>
<p>But there are tons of variations of it for partial and total orders, commutativity, cancellation. They're also slightly confusing, I remember something like not every <code>ordered_comm_monoid</code> is an <code>ordered_monoid</code> or something.</p>

<a name="186346825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186346825" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186346825">Mario Carneiro (Jan 23 2020 at 00:32)</a>:</h4>
<p>Some of that is legacy from the core/mathlib split</p>

<a name="186371396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186371396" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186371396">Patrick Massot (Jan 23 2020 at 09:30)</a>:</h4>
<p>We still have one example when canonical structures do something we have never been able to do with type classes: math-comp's bigop. They have a big operators library which is completely generic in the operator. This requires having lemmas whose input are predicates like <code>is_associative</code> and <code>is_commutative</code>. Such things were tried with type classes, there are remnants in the core library, but it never took off. My understanding is we always need some constant head symbol, like <code>has_add.add</code> instead of a mysterious operator <code>op</code> and a type class <code>[is_associative op]</code>.</p>

<a name="186371459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186371459" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186371459">Patrick Massot (Jan 23 2020 at 09:31)</a>:</h4>
<p>In this bigop library they can prove one lemma covering big sums, big products, big intersection, big direct sum of modules etc where we have separate lemmas for each case (with giant holes in the API until someone needs each specific case).</p>

<a name="186371562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186371562" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186371562">Patrick Massot (Jan 23 2020 at 09:33)</a>:</h4>
<p>But there is a huge barrier to trying canonical structures, we would need to rewrite the whole library. At the end of summer there was almost enough incentive with all the type class resolution failure or crazy timing. But then Daniel came and promised all this will be solved in Lean 4 so we wait.</p>

<a name="186372534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186372534" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186372534">Gabriel Ebner (Jan 23 2020 at 09:48)</a>:</h4>
<blockquote>
<p>My understanding is we always need some constant head symbol, like has_add.add instead of a mysterious operator op</p>
</blockquote>
<p>This is only true for the simplifier, which looks up the simp lemmas by the name of the head symbol. I don't think that's a problem to develop generic bigops.  BTW, we have a type class <code>is_associative</code> and also instances like <code>is_associative (*)</code> for semigroups, etc.</p>

<a name="186372701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186372701" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186372701">Johan Commelin (Jan 23 2020 at 09:51)</a>:</h4>
<p><span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> Could you please clarify. Should <code>simp</code>-lemmas have these constant head symbols, or only the terms that we are matching?</p>

<a name="186372765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186372765" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186372765">Johan Commelin (Jan 23 2020 at 09:52)</a>:</h4>
<p>Because I think <span class="user-mention" data-user-id="110031">@Patrick Massot</span> would like a world where you state a lemma for a generic <code>op</code> and then use it in the simplifier when applying it to some <code>has_add.add</code> occurence.</p>

<a name="186372842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186372842" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186372842">Gabriel Ebner (Jan 23 2020 at 09:53)</a>:</h4>
<p>Errm, both:</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="bp">...</span> <span class="o">:</span> <span class="n">r</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">↔</span> <span class="n">r</span> <span class="n">y</span> <span class="n">x</span> <span class="o">:=</span> <span class="bp">...</span> <span class="c1">-- bad since relation `r` is not a constant</span>
<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">[</span><span class="n">is_associative</span> <span class="n">f</span><span class="o">]</span> <span class="bp">...</span> <span class="o">:</span>
  <span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="o">(</span><span class="n">f</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span>  <span class="o">:=</span> <span class="bp">...</span> <span class="c1">-- bad since head symbol `f` of lhs is not a constant</span>
</pre></div>

<a name="186372973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186372973" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186372973">Johan Commelin (Jan 23 2020 at 09:55)</a>:</h4>
<p>Ok. so that's bad. Because it means we have to state each lemma 5 times, instead of once.</p>

<a name="186372984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186372984" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186372984">Johan Commelin (Jan 23 2020 at 09:55)</a>:</h4>
<p>Which is exactly the situation that Patrick is describing.</p>

<a name="186373047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186373047" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186373047">Anne Baanen (Jan 23 2020 at 09:56)</a>:</h4>
<p>If we replaced <code>finset.prod</code> with <code>finset.bigop (*)</code>, then <code>finset.bigop</code> would be the head symbol, no?</p>

<a name="186373049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186373049" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186373049">Johan Commelin (Jan 23 2020 at 09:56)</a>:</h4>
<p>Of course we could try to generalise the proofs, but it's clear that in this regard our setup with typeclasses is suboptimal.</p>

<a name="186373152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186373152" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186373152">Johan Commelin (Jan 23 2020 at 09:58)</a>:</h4>
<blockquote>
<p>If we replaced <code>finset.prod</code> with <code>finset.bigop (*)</code>, then <code>finset.bigop</code> would be the head symbol, no?</p>
</blockquote>
<p>Aha, I guess that might work, but it would mean a step down in readability.</p>

<a name="186373218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186373218" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186373218">Johan Commelin (Jan 23 2020 at 09:59)</a>:</h4>
<p>If <code>finset.prod</code> is than made an <code>abbreviation</code> of <code>finset.bigop (*)</code> and simp-lemmas can see through such an abbreviation, then it might work. But I'm not sure if that actually works.</p>

<a name="186373401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186373401" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186373401">Johan Commelin (Jan 23 2020 at 10:01)</a>:</h4>
<p>I tried something like this in a commit on folding min and max: <a href="https://github.com/leanprover-community/mathlib/commit/b031290b228838d5e779908b129420331bb131c5" target="_blank" title="https://github.com/leanprover-community/mathlib/commit/b031290b228838d5e779908b129420331bb131c5">https://github.com/leanprover-community/mathlib/commit/b031290b228838d5e779908b129420331bb131c5</a></p>

<a name="186373503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186373503" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186373503">Patrick Massot (Jan 23 2020 at 10:02)</a>:</h4>
<p>Sure, we can have <code>finset.bigop (*)</code> and a notation for that. But then the library would still need lemmas about the generic <code>op</code> and the simplifier wouldn't trigger</p>

<a name="186373507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186373507" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186373507">Johan Commelin (Jan 23 2020 at 10:02)</a>:</h4>
<p>More than half of that commit is stating specialised versions of the two general lemmas, and even the two general lemmas ought to be unified.</p>

<a name="186373527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186373527" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186373527">Patrick Massot (Jan 23 2020 at 10:03)</a>:</h4>
<p>See also <a href="https://github.com/PatrickMassot/bigop/blob/master/src/bigop.lean" target="_blank" title="https://github.com/PatrickMassot/bigop/blob/master/src/bigop.lean">https://github.com/PatrickMassot/bigop/blob/master/src/bigop.lean</a> for my old attempt to port the bigop library</p>

<a name="186373569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186373569" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186373569">Johan Commelin (Jan 23 2020 at 10:04)</a>:</h4>
<p>Could we have attributes that state the specialised simp-lemmas after the generic <code>op</code> version?</p>

<a name="186373643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186373643" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186373643">Patrick Massot (Jan 23 2020 at 10:04)</a>:</h4>
<p>It sorts of work (although it faces elaboration issues). But then you need to actually use it in the middle of other proofs where you expect the simplifier to work.</p>

<a name="186373670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186373670" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186373670">Sebastian Ullrich (Jan 23 2020 at 10:05)</a>:</h4>
<p>Yes, that was one idea for making the simplifier work with more unbundled typeclasses. Throw a metaprogram at it.</p>

<a name="186373692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186373692" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186373692">Sebastian Ullrich (Jan 23 2020 at 10:05)</a>:</h4>
<p>The specialized lemmas would be generated eagerly</p>

<a name="186374274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186374274" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186374274">Sebastien Gouezel (Jan 23 2020 at 10:12)</a>:</h4>
<p>Or craft an attribute on the generic lemmas that would generate the versions for sums, products, unions, and so on, which would be generic enough that one can add new instances to the attributes (for instance max), and then all the lemmas would become available right away for max.</p>

<a name="186374298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186374298" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186374298">Sebastien Gouezel (Jan 23 2020 at 10:12)</a>:</h4>
<p>Oups, Johan just said this two messages ago!</p>

<a name="186380199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186380199" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186380199">Daniel Selsam (Jan 23 2020 at 11:43)</a>:</h4>
<blockquote>
<p>... the simplifier, which looks up the simp lemmas by the name of the head symbol.</p>
</blockquote>
<p>Lean4 will use a discrimination tree instead of a head map.</p>

<a name="186380560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186380560" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186380560">Johan Commelin (Jan 23 2020 at 11:50)</a>:</h4>
<p><span class="user-mention" data-user-id="230999">@Daniel Selsam</span> In other words: in Lean 4 we can have typeclasses and an elegant bigop library?</p>

<a name="186382577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186382577" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186382577">Daniel Selsam (Jan 23 2020 at 12:18)</a>:</h4>
<p>I didn't mean to imply that. To be honest, I don't remember all the desiderata and challenges involved in this issue.</p>

<a name="186383047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186383047" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186383047">Daniel Selsam (Jan 23 2020 at 12:25)</a>:</h4>
<p>How much of the concern is automation (or the lack thereof) when proving the generic big-op lemmas themselves? For using the big-op theorems for concrete ops in downstream automation, what are the downsides of the meta-programming approach?</p>

<a name="186383466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186383466" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186383466">Sebastian Ullrich (Jan 23 2020 at 12:30)</a>:</h4>
<p>There is a minor diamond issue: if you define a bigop simp lemma in one file and a new bigop in an independent file, you might not get a specialized version of this lemma for that bigop when you import both, depending on the implementation</p>

<a name="186383554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186383554" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186383554">Sebastian Ullrich (Jan 23 2020 at 12:31)</a>:</h4>
<p>There could of course be an explicit command "generate all missing combinations at this point"</p>

<a name="186408714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186408714" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186408714">Patrick Massot (Jan 23 2020 at 16:49)</a>:</h4>
<p>I'm sorry I have very very little time for Lean right now (and probably for the coming two weeks). I only try to remember what happened one year ago. But I see from <a href="https://github.com/leanprover/lean4/commit/c9e9208ea29a34fe715310f47fa5ce786a4b3b8e" target="_blank" title="https://github.com/leanprover/lean4/commit/c9e9208ea29a34fe715310f47fa5ce786a4b3b8e">https://github.com/leanprover/lean4/commit/c9e9208ea29a34fe715310f47fa5ce786a4b3b8e</a> that Leo is on it.</p>

<a name="186410959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186410959" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186410959">Sebastian Ullrich (Jan 23 2020 at 17:10)</a>:</h4>
<p>Good eye. This is strictly about notations for now though.</p>

<a name="186430421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186430421" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186430421">Patrick Massot (Jan 23 2020 at 20:12)</a>:</h4>
<p>I noticed it was notation only, but it still suggest this bigop question is somewhere in Leo's mind.</p>

<a name="186431887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/186431887" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#186431887">Daniel Selsam (Jan 23 2020 at 20:28)</a>:</h4>
<p>We all love big-ops. The main issue is that we don't want automation (e.g. the simplifier) to stupidly try applying every big-op lemma to every subterm for lack of decent indexing. It might be possible to extend our discrimination trees to index these lemmas better, but so far the macro-specialization approach seems acceptable to me.</p>


{% endraw %}

{% include archive_update.html %}