---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/48677combiningclasses.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/48677combiningclasses.html">combining classes</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="151584488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/combining%20classes/near/151584488" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48677combiningclasses.html#151584488">Reid Barton (Dec 13 2018 at 15:24)</a>:</h4>
<p>If I have <code>class C t extends A t, B t.</code> I guess it doesn't mean that anything which is an instance of <code>A</code> and <code>B</code> is automatically an instance of <code>C</code>? Does it make sense to write an instance for <code>C</code> to make that true?</p>

<a name="151584538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/combining%20classes/near/151584538" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48677combiningclasses.html#151584538">Reid Barton (Dec 13 2018 at 15:26)</a>:</h4>
<p>hmm, it seems not to be a good idea.</p>

<a name="151585886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/combining%20classes/near/151585886" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48677combiningclasses.html#151585886">Mario Carneiro (Dec 13 2018 at 16:08)</a>:</h4>
<p>no, it means that a <code>C t</code> is an <code>A t</code> and a <code>B t</code></p>

<a name="151585889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/combining%20classes/near/151585889" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48677combiningclasses.html#151585889">Mario Carneiro (Dec 13 2018 at 16:08)</a>:</h4>
<p>so that instance would be a loop</p>

<a name="151586018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/combining%20classes/near/151586018" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48677combiningclasses.html#151586018">Reid Barton (Dec 13 2018 at 16:12)</a>:</h4>
<p>So is it a bad idea to define this class <code>C</code> in the first place then?</p>

<a name="151586529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/combining%20classes/near/151586529" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48677combiningclasses.html#151586529">Mario Carneiro (Dec 13 2018 at 16:30)</a>:</h4>
<p>It has the same concerns as any other class introduction</p>

<a name="151586740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/combining%20classes/near/151586740" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48677combiningclasses.html#151586740">Reid Barton (Dec 13 2018 at 16:36)</a>:</h4>
<p>I can't use C as a shorthand for A + B though</p>

<a name="151586752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/combining%20classes/near/151586752" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48677combiningclasses.html#151586752">Reid Barton (Dec 13 2018 at 16:37)</a>:</h4>
<p>because I don't see any way to arrange that there is an instance of C whenever there is one of both A and B</p>

<a name="151586801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/combining%20classes/near/151586801" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48677combiningclasses.html#151586801">Reid Barton (Dec 13 2018 at 16:38)</a>:</h4>
<p>In GHC, this works because GHC doesn't have these weird backwards instances "try to get A from C"</p>

<a name="151586810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/combining%20classes/near/151586810" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48677combiningclasses.html#151586810">Reid Barton (Dec 13 2018 at 16:38)</a>:</h4>
<p>In particular, I'm looking at <a href="https://github.com/leanprover/mathlib/blob/master/category_theory/fully_faithful.lean#L52" target="_blank" title="https://github.com/leanprover/mathlib/blob/master/category_theory/fully_faithful.lean#L52">https://github.com/leanprover/mathlib/blob/master/category_theory/fully_faithful.lean#L52</a></p>

<a name="151587244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/combining%20classes/near/151587244" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48677combiningclasses.html#151587244">Johan Commelin (Dec 13 2018 at 16:54)</a>:</h4>
<p>Right, so I've only been proving that things are <code>fully_faithful</code> but I never put it as an assumption. It's a bit awkard.</p>

<a name="151587292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/combining%20classes/near/151587292" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48677combiningclasses.html#151587292">Reid Barton (Dec 13 2018 at 16:55)</a>:</h4>
<p>I guess that works, to an extent</p>

<a name="151588362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/combining%20classes/near/151588362" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48677combiningclasses.html#151588362">Johan Commelin (Dec 13 2018 at 17:29)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> But you would also want the type class system to try to deduce that <code>F</code> is <code>full</code> by searching for an instance that <code>F</code> is <code>fully_faithful</code> (which you say GHC wouldn't do). So the search <em>must</em> go both ways. We really need a smarter system, that wouldn't run into these <em>trivial</em> loops.</p>

<a name="151588420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/combining%20classes/near/151588420" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48677combiningclasses.html#151588420">Mario Carneiro (Dec 13 2018 at 17:30)</a>:</h4>
<p>GHC would require that you prove <code>F</code> is <code>full</code> before proving it is <code>fully_faithful</code>, so it doesn't have to do the search</p>

<a name="151590559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/combining%20classes/near/151590559" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48677combiningclasses.html#151590559">Andrew Ashworth (Dec 13 2018 at 18:39)</a>:</h4>
<p>The smarter you make type class search, the more memory it will use... I'm sure you could use high power search techniques like contraction hierarchies, along with keeping visited nodes in memory so you could detect loops... I suspect/speculate it hasn't been done because 90% of CS users would riot over the unnecessary resource usage in large projects that do not need these features. Maybe I'm completely off-base.</p>

<a name="151590617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/combining%20classes/near/151590617" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48677combiningclasses.html#151590617">Andrew Ashworth (Dec 13 2018 at 18:41)</a>:</h4>
<p>It would definitely be interesting to benchmark different algorithms over a large code-base though - those would be interesting results.</p>

<a name="151590726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/combining%20classes/near/151590726" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48677combiningclasses.html#151590726">Johan Commelin (Dec 13 2018 at 18:44)</a>:</h4>
<p>I understand.</p>

<a name="151590731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/combining%20classes/near/151590731" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48677combiningclasses.html#151590731">Kevin Buzzard (Dec 13 2018 at 18:45)</a>:</h4>
<p>Mathematicians seem to me to be a class of users who are constantly running into these issues with the type class system though.</p>

<a name="151590737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/combining%20classes/near/151590737" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48677combiningclasses.html#151590737">Johan Commelin (Dec 13 2018 at 18:45)</a>:</h4>
<p>Lean 4 will give us the possibility to swap out the type class search algorithm...</p>

<a name="151590739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/combining%20classes/near/151590739" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48677combiningclasses.html#151590739">Johan Commelin (Dec 13 2018 at 18:45)</a>:</h4>
<p>So then everyone can be happy.</p>

<a name="151590801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/combining%20classes/near/151590801" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48677combiningclasses.html#151590801">Kevin Buzzard (Dec 13 2018 at 18:46)</a>:</h4>
<p>You made <code>group</code> a class and we thought "Oh I get it, a locally analytic topological vector space must be a class" and then it turns out that it's harder than that</p>

<a name="151590860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/combining%20classes/near/151590860" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48677combiningclasses.html#151590860">Kevin Buzzard (Dec 13 2018 at 18:48)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> in a given use case you could try adding the loopy instance with priority 0, and then hope that this discouragement is enough in practice. It feels like any code you ship should come with a warning though.</p>

<a name="151590875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/combining%20classes/near/151590875" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48677combiningclasses.html#151590875">Kevin Buzzard (Dec 13 2018 at 18:50)</a>:</h4>
<p>The system would be likely to loop rather than fail so for buggy code where it should error with a failure you'll instead perhaps get a more obscure error</p>

<a name="151590987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/combining%20classes/near/151590987" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48677combiningclasses.html#151590987">Kevin Buzzard (Dec 13 2018 at 18:53)</a>:</h4>
<p>Johan I guess I made one explicit example of where we weren't happy very clear to Sebastian the other day -- type class inference failing to unify two terms of a subsingleton type -- so he knows we want more here. Loops are another issue. We definitely want them. "Defeq loops" should be fine but even they can cause problems because the system doesn't abort. "Oh look we've been here before -- let's press on"</p>

<a name="151594433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/combining%20classes/near/151594433" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48677combiningclasses.html#151594433">Gabriel Ebner (Dec 13 2018 at 20:16)</a>:</h4>
<p>Haskell has this nice <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#the-constraint-kind" target="_blank" title="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#the-constraint-kind">constraint kinds extension</a>, which allows you to define aliases for combinations of type classes:</p>
<div class="codehilite"><pre><span></span><span class="kr">type</span> <span class="kt">Stringy</span> <span class="n">a</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">Read</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Show</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Read and Show are type classes</span>
<span class="kr">type</span> <span class="kt">C</span> <span class="n">t</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">A</span> <span class="n">t</span><span class="p">,</span> <span class="kt">B</span> <span class="n">t</span><span class="p">)</span> <span class="c1">-- Reid&#39;s example</span>
</pre></div>


<p>In principle, there is no fundamental reason why we couldn't do something like this in Lean as well.  <span class="user-mention" data-user-id="112680">@Johan Commelin</span> I wouldn't count on customizing type class inference.</p>

<a name="151594520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/combining%20classes/near/151594520" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48677combiningclasses.html#151594520">Johan Commelin (Dec 13 2018 at 20:18)</a>:</h4>
<p>Ooh, too bad. I thought I heard at some point that it would be possible...</p>


{% endraw %}
