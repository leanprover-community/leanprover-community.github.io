---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/25844optionmapcomp.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/25844optionmapcomp.html">option.map_comp</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="161541947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/option.map_comp/near/161541947" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/25844optionmapcomp.html#161541947">Kevin Buzzard (Mar 23 2019 at 20:45)</a>:</h4>
<p>What is option.map_comp called? I can't find it :-/ Oh! Is it something to do with monads?</p>

<a name="161542429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/option.map_comp/near/161542429" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/25844optionmapcomp.html#161542429">Sebastian Ullrich (Mar 23 2019 at 20:59)</a>:</h4>
<p>Yes, it's <code>comp_map</code> (of class <code>is_lawful_functor</code>)</p>

<a name="161546436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/option.map_comp/near/161546436" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/25844optionmapcomp.html#161546436">Kevin Buzzard (Mar 23 2019 at 22:51)</a>:</h4>
<p>Can I get this cheaply?</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">with_zero</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">option</span> <span class="n">α</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">monad</span> <span class="n">with_zero</span> <span class="o">:=</span> <span class="n">option</span><span class="bp">.</span><span class="n">monad</span>

<span class="kn">namespace</span> <span class="n">with_zero</span>

<span class="n">def</span> <span class="n">map</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">with_zero</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">with_zero</span> <span class="n">β</span> <span class="o">:=</span> <span class="n">option</span><span class="bp">.</span><span class="n">map</span> <span class="n">f</span>

<span class="kn">lemma</span> <span class="n">map_id</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span> <span class="n">map</span> <span class="o">(</span><span class="n">id</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="n">id</span> <span class="o">:=</span> <span class="n">option</span><span class="bp">.</span><span class="n">map_id</span>

<span class="kn">lemma</span> <span class="n">map_comp</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">with_zero</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">with_zero</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="n">g</span> <span class="err">∘</span> <span class="n">f</span><span class="o">)</span> <span class="n">r</span> <span class="bp">=</span> <span class="o">(</span><span class="n">with_zero</span><span class="bp">.</span><span class="n">map</span> <span class="n">g</span><span class="o">)</span> <span class="o">((</span><span class="n">with_zero</span><span class="bp">.</span><span class="n">map</span> <span class="n">f</span><span class="o">)</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">is_lawful_functor</span><span class="bp">.</span><span class="n">comp_map</span> <span class="n">f</span> <span class="n">g</span> <span class="n">r</span> <span class="c1">-- error involving &lt;$&gt;</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">  type mismatch, term</span>
<span class="cm">    comp_map ?m_7 ?m_8 ?m_9</span>
<span class="cm">  has type</span>
<span class="cm">    (?m_6 ∘ ?m_7) &lt;$&gt; ?m_8 = ?m_6 &lt;$&gt; ?m_7 &lt;$&gt; ?m_8</span>
<span class="cm">  but is expected to have type</span>
<span class="cm">    map (g ∘ f) r = map g (map f r)</span>
<span class="cm">-/</span>

<span class="kn">end</span> <span class="n">with_zero</span>
</pre></div>


<p>I have never had to deal with <code>&lt;$&gt;</code> before.</p>

<a name="161546612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/option.map_comp/near/161546612" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/25844optionmapcomp.html#161546612">Chris Hughes (Mar 23 2019 at 22:57)</a>:</h4>
<p>Have you proved it's a lawful monad?</p>

<a name="161546613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/option.map_comp/near/161546613" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/25844optionmapcomp.html#161546613">Kevin Buzzard (Mar 23 2019 at 22:57)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">map</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">with_zero</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">with_zero</span> <span class="n">β</span> <span class="o">:=</span> <span class="n">functor</span><span class="bp">.</span><span class="n">map</span> <span class="n">f</span>
</pre></div>


<p>This fixes it.</p>

<a name="161546658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/option.map_comp/near/161546658" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/25844optionmapcomp.html#161546658">Kevin Buzzard (Mar 23 2019 at 22:58)</a>:</h4>
<p>I've proved it's a functor:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">:</span> <span class="n">functor</span> <span class="n">with_zero</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span>
</pre></div>

<a name="161546659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/option.map_comp/near/161546659" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/25844optionmapcomp.html#161546659">Kevin Buzzard (Mar 23 2019 at 22:58)</a>:</h4>
<p>Or at least, someone did...</p>

<a name="161546669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/option.map_comp/near/161546669" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/25844optionmapcomp.html#161546669">Chris Hughes (Mar 23 2019 at 22:59)</a>:</h4>
<p>Don't you need to prove it's a lawful functor?</p>

<a name="161546759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/option.map_comp/near/161546759" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/25844optionmapcomp.html#161546759">Kevin Buzzard (Mar 23 2019 at 23:01)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">with_zero</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">option</span> <span class="n">α</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">monad</span> <span class="n">with_zero</span> <span class="o">:=</span> <span class="n">option</span><span class="bp">.</span><span class="n">monad</span>

<span class="kn">namespace</span> <span class="n">with_zero</span>

<span class="n">def</span> <span class="n">map</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">with_zero</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">with_zero</span> <span class="n">β</span> <span class="o">:=</span> <span class="n">functor</span><span class="bp">.</span><span class="n">map</span> <span class="n">f</span>

<span class="kn">lemma</span> <span class="n">map_id</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span> <span class="n">map</span> <span class="o">(</span><span class="n">id</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="n">id</span> <span class="o">:=</span> <span class="n">option</span><span class="bp">.</span><span class="n">map_id</span>

<span class="kn">lemma</span> <span class="n">map_comp</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">with_zero</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">with_zero</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="n">g</span> <span class="err">∘</span> <span class="n">f</span><span class="o">)</span> <span class="n">r</span> <span class="bp">=</span> <span class="o">(</span><span class="n">with_zero</span><span class="bp">.</span><span class="n">map</span> <span class="n">g</span><span class="o">)</span> <span class="o">((</span><span class="n">with_zero</span><span class="bp">.</span><span class="n">map</span> <span class="n">f</span><span class="o">)</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">is_lawful_functor</span><span class="bp">.</span><span class="n">comp_map</span> <span class="n">f</span> <span class="n">g</span> <span class="n">r</span> <span class="c1">-- compiles fine</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">is_lawful_functor</span> <span class="n">with_zero</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span> <span class="c1">-- fails!</span>

<span class="kn">end</span> <span class="n">with_zero</span>
</pre></div>


<p>Apparently not :P</p>

<a name="161546803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/option.map_comp/near/161546803" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/25844optionmapcomp.html#161546803">Kevin Buzzard (Mar 23 2019 at 23:02)</a>:</h4>
<p>I've never played with this stuff before.</p>

<a name="161547124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/option.map_comp/near/161547124" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/25844optionmapcomp.html#161547124">Kevin Buzzard (Mar 23 2019 at 23:10)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">:</span> <span class="n">is_lawful_functor</span> <span class="n">option</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span> <span class="c1">-- works!</span>
</pre></div>

<a name="161547146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/option.map_comp/near/161547146" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/25844optionmapcomp.html#161547146">Kevin Buzzard (Mar 23 2019 at 23:11)</a>:</h4>
<p>I am surprised things work out like this. Type class inference found an instance for <code>is_lawful_functor with_zero</code> when using <code>is_lawful_functor.comp_map</code> but not when I asked it explicitly.</p>

<a name="161547363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/option.map_comp/near/161547363" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/25844optionmapcomp.html#161547363">Kevin Buzzard (Mar 23 2019 at 23:17)</a>:</h4>
<p>Am I supposed to be writing code like this in a library:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">with_zero</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">option</span> <span class="n">α</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">monad</span> <span class="n">with_zero</span> <span class="o">:=</span> <span class="n">option</span><span class="bp">.</span><span class="n">monad</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">is_lawful_functor</span> <span class="n">with_zero</span> <span class="o">:=</span> <span class="k">show</span> <span class="n">is_lawful_functor</span> <span class="n">option</span><span class="o">,</span> <span class="k">by</span> <span class="n">apply_instance</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">is_lawful_monad</span> <span class="n">with_zero</span> <span class="o">:=</span> <span class="k">show</span> <span class="n">is_lawful_monad</span> <span class="n">option</span><span class="o">,</span> <span class="k">by</span> <span class="n">apply_instance</span>

<span class="kn">namespace</span> <span class="n">with_zero</span>

<span class="n">def</span> <span class="n">map</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">with_zero</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">with_zero</span> <span class="n">β</span> <span class="o">:=</span> <span class="n">functor</span><span class="bp">.</span><span class="n">map</span> <span class="n">f</span>

<span class="kn">lemma</span> <span class="n">map_id</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span> <span class="n">map</span> <span class="o">(</span><span class="n">id</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="n">id</span> <span class="o">:=</span> <span class="n">option</span><span class="bp">.</span><span class="n">map_id</span>

<span class="kn">lemma</span> <span class="n">map_comp</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">with_zero</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">with_zero</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="n">g</span> <span class="err">∘</span> <span class="n">f</span><span class="o">)</span> <span class="n">r</span> <span class="bp">=</span> <span class="o">(</span><span class="n">with_zero</span><span class="bp">.</span><span class="n">map</span> <span class="n">g</span><span class="o">)</span> <span class="o">((</span><span class="n">with_zero</span><span class="bp">.</span><span class="n">map</span> <span class="n">f</span><span class="o">)</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">is_lawful_functor</span><span class="bp">.</span><span class="n">comp_map</span> <span class="n">f</span> <span class="n">g</span> <span class="n">r</span>

<span class="kn">end</span> <span class="n">with_zero</span>
</pre></div>


<p>Or am I just supposed to use <code>is_lawful_functor.comp_map</code> whenever I want <code>with_zero.comp_map</code>?</p>

<a name="161547410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/option.map_comp/near/161547410" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/25844optionmapcomp.html#161547410">Kevin Buzzard (Mar 23 2019 at 23:18)</a>:</h4>
<p>It's the same question Johan asked earlier with vector_subspace.zero_mem just equalling submodule.zero_mem.</p>

<a name="161565856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/option.map_comp/near/161565856" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/25844optionmapcomp.html#161565856">Patrick Massot (Mar 24 2019 at 08:13)</a>:</h4>
<p>What about using <code>open is_lawful_functor</code> and stop worrying?</p>

<a name="161566835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/option.map_comp/near/161566835" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/25844optionmapcomp.html#161566835">Kevin Buzzard (Mar 24 2019 at 08:43)</a>:</h4>
<p>Is that what I'm supposed to do?</p>

<a name="161567589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/option.map_comp/near/161567589" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/25844optionmapcomp.html#161567589">Kevin Buzzard (Mar 24 2019 at 09:05)</a>:</h4>
<p>aargh functor is rubbish</p>
<div class="codehilite"><pre><span></span><span class="n">class</span> <span class="n">functor</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">map</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">},</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">β</span><span class="o">)</span>
<span class="o">(</span><span class="n">map_const</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">},</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">α</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span> <span class="n">β</span><span class="o">,</span> <span class="n">map</span> <span class="err">∘</span> <span class="n">const</span> <span class="n">β</span><span class="o">)</span>
</pre></div>


<p><code>functor.map</code> will only eat <code>f : alpha -&gt; beta</code> if alpha and beta live in the same universe :-(</p>

<a name="161567597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/option.map_comp/near/161567597" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/25844optionmapcomp.html#161567597">Kevin Buzzard (Mar 24 2019 at 09:05)</a>:</h4>
<p>I don't think this is general enough for me after all</p>

<a name="161567857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/option.map_comp/near/161567857" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/25844optionmapcomp.html#161567857">Kevin Buzzard (Mar 24 2019 at 09:13)</a>:</h4>
<p>So I'm back to the start.</p>
<div class="codehilite"><pre><span></span><span class="n">universes</span> <span class="n">u₁</span> <span class="n">u₂</span> <span class="n">u₃</span>

<span class="n">def</span> <span class="n">option</span><span class="bp">.</span><span class="n">map_comp</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₁</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₂</span><span class="o">}</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₃</span><span class="o">}</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">option</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
<span class="n">option</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="n">g</span> <span class="err">∘</span> <span class="n">f</span><span class="o">)</span> <span class="n">r</span> <span class="bp">=</span> <span class="n">option</span><span class="bp">.</span><span class="n">map</span> <span class="n">g</span> <span class="o">(</span><span class="n">option</span><span class="bp">.</span><span class="n">map</span> <span class="n">f</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>


<p>Is this in Lean or mathlib somewhere?</p>

<a name="161568259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/option.map_comp/near/161568259" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/25844optionmapcomp.html#161568259">Mario Carneiro (Mar 24 2019 at 09:24)</a>:</h4>
<p>I don't think it is, it should be in <code>data.option.basic</code></p>

<a name="161568285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/option.map_comp/near/161568285" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/25844optionmapcomp.html#161568285">Kevin Buzzard (Mar 24 2019 at 09:25)</a>:</h4>
<p>You can't prove it using lawful functors, or at least I can't, because then the universes have to be the same.</p>

<a name="161568297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/option.map_comp/near/161568297" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/25844optionmapcomp.html#161568297">Mario Carneiro (Mar 24 2019 at 09:25)</a>:</h4>
<p>This is a known limitation of <code>functor</code></p>

<a name="161568343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/option.map_comp/near/161568343" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/25844optionmapcomp.html#161568343">Mario Carneiro (Mar 24 2019 at 09:26)</a>:</h4>
<p>this is why many monads have <code>map</code> functions separate from the notation</p>

<a name="161568345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/option.map_comp/near/161568345" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/25844optionmapcomp.html#161568345">Kevin Buzzard (Mar 24 2019 at 09:26)</a>:</h4>
<p>You want this sort of thing to construct an equiv of monoids (with_zero G) from an equiv of groups (G)</p>

<a name="161568359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/option.map_comp/near/161568359" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/25844optionmapcomp.html#161568359">Mario Carneiro (Mar 24 2019 at 09:26)</a>:</h4>
<p>I guess it's just a semigroup equiv?</p>

<a name="161568381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/option.map_comp/near/161568381" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/25844optionmapcomp.html#161568381">Kevin Buzzard (Mar 24 2019 at 09:27)</a>:</h4>
<p>A semigroup equiv of monoids is a monoid equiv, if I've understood this statement correctly</p>

<a name="161568389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/option.map_comp/near/161568389" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/25844optionmapcomp.html#161568389">Mario Carneiro (Mar 24 2019 at 09:27)</a>:</h4>
<p><code>with_zero</code> makes a semigroup into a monoid</p>

<a name="161568440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/option.map_comp/near/161568440" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/25844optionmapcomp.html#161568440">Kevin Buzzard (Mar 24 2019 at 09:28)</a>:</h4>
<p>Aah I see. Yes.</p>

<a name="161568441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/option.map_comp/near/161568441" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/25844optionmapcomp.html#161568441">Mario Carneiro (Mar 24 2019 at 09:28)</a>:</h4>
<p>so the congr theorem should turn semigroup equivs into monoid equivs</p>

<a name="161568443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/option.map_comp/near/161568443" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/25844optionmapcomp.html#161568443">Kevin Buzzard (Mar 24 2019 at 09:28)</a>:</h4>
<p>Right.</p>

<a name="161568446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/option.map_comp/near/161568446" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/25844optionmapcomp.html#161568446">Kevin Buzzard (Mar 24 2019 at 09:28)</a>:</h4>
<p>Oh this is more congr?</p>

<a name="161568448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/option.map_comp/near/161568448" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/25844optionmapcomp.html#161568448">Mario Carneiro (Mar 24 2019 at 09:28)</a>:</h4>
<p>yeah, if you squint</p>

<a name="161568453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/option.map_comp/near/161568453" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/25844optionmapcomp.html#161568453">Kevin Buzzard (Mar 24 2019 at 09:28)</a>:</h4>
<p>I'm learning to squint at congr.</p>

<a name="161568462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/option.map_comp/near/161568462" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/25844optionmapcomp.html#161568462">Mario Carneiro (Mar 24 2019 at 09:29)</a>:</h4>
<p><code>G ~= H -&gt; with_zero G ~= with_zero H</code></p>

<a name="161568468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/option.map_comp/near/161568468" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/25844optionmapcomp.html#161568468">Kevin Buzzard (Mar 24 2019 at 09:29)</a>:</h4>
<p>yes, that's a congr alright.</p>

<a name="161568473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/option.map_comp/near/161568473" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/25844optionmapcomp.html#161568473">Kevin Buzzard (Mar 24 2019 at 09:29)</a>:</h4>
<p>So what's the function called?</p>

<a name="161568477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/option.map_comp/near/161568477" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/25844optionmapcomp.html#161568477">Mario Carneiro (Mar 24 2019 at 09:29)</a>:</h4>
<p><code>with_zero_congr</code>?</p>

<a name="161568478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/option.map_comp/near/161568478" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/25844optionmapcomp.html#161568478">Kevin Buzzard (Mar 24 2019 at 09:29)</a>:</h4>
<p>I don't think I'll tell you what I was going to call it.</p>

<a name="161568482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/option.map_comp/near/161568482" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/25844optionmapcomp.html#161568482">Mario Carneiro (Mar 24 2019 at 09:29)</a>:</h4>
<p>or maybe something with projection notation</p>

<a name="161568540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/option.map_comp/near/161568540" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/25844optionmapcomp.html#161568540">Kevin Buzzard (Mar 24 2019 at 09:30)</a>:</h4>
<p>semigroup_equiv.with_zero_congr?</p>

<a name="161568542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/option.map_comp/near/161568542" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/25844optionmapcomp.html#161568542">Mario Carneiro (Mar 24 2019 at 09:30)</a>:</h4>
<p><code>semigroup_equiv.with_zero_congr</code> doesn't buy much</p>

<a name="161583906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/option.map_comp/near/161583906" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/25844optionmapcomp.html#161583906">Kevin Buzzard (Mar 24 2019 at 15:29)</a>:</h4>
<p>Ohohoh I just sat down to code this and noticed that it is from groups to monoids -- the group law is <code>*</code>, so this extra zero isn't the monoid identity. Maybe it's from monoids to monoids.</p>

<a name="161584173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/option.map_comp/near/161584173" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/25844optionmapcomp.html#161584173">Kevin Buzzard (Mar 24 2019 at 15:36)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">to_with_zero_monoid_equiv</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">monoid_equiv</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">monoid_equiv</span> <span class="o">(</span><span class="n">with_zero</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">with_zero</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">with_zero</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="n">h</span><span class="bp">.</span><span class="n">to_equiv</span><span class="o">),</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="n">with_zero</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="n">h</span><span class="bp">.</span><span class="n">to_equiv</span><span class="bp">.</span><span class="n">symm</span><span class="o">),</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">begin</span> <span class="n">cases</span> <span class="n">x</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span> <span class="k">show</span> <span class="n">some</span> <span class="bp">_</span> <span class="bp">=</span> <span class="n">some</span> <span class="bp">_</span><span class="o">,</span> <span class="n">congr</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h</span><span class="bp">.</span><span class="n">left_inv</span> <span class="n">x</span> <span class="kn">end</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">begin</span> <span class="n">cases</span> <span class="n">x</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span> <span class="k">show</span> <span class="n">some</span> <span class="bp">_</span> <span class="bp">=</span> <span class="n">some</span> <span class="bp">_</span><span class="o">,</span> <span class="n">congr</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h</span><span class="bp">.</span><span class="n">right_inv</span> <span class="n">x</span> <span class="kn">end</span><span class="o">,</span>
  <span class="n">mul_hom</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="k">begin</span> <span class="n">cases</span> <span class="n">x</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">y</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">refl</span><span class="o">},</span>
  <span class="o">{</span> <span class="n">refl</span><span class="o">},</span>
  <span class="o">{</span> <span class="n">refl</span><span class="o">},</span>
  <span class="o">{</span> <span class="k">show</span> <span class="n">some</span> <span class="bp">_</span> <span class="bp">=</span> <span class="n">some</span> <span class="bp">_</span><span class="o">,</span> <span class="n">congr</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h</span><span class="bp">.</span><span class="n">mul_hom</span> <span class="n">x</span> <span class="n">y</span><span class="o">}</span>
  <span class="kn">end</span><span class="o">}</span>
</pre></div>


<p>My plan for the proof of <code>left_inv</code> was to use <code>with_zero.map_comp</code> and <code>with_zero.map_id</code> but there's barely any point.</p>


{% endraw %}

{% include archive_update.html %}