---
layout: archive
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/45155monadonarbitrarycategories.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/45155monadonarbitrarycategories.html">monad on arbitrary categories</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="158789393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/monad%20on%20arbitrary%20categories/near/158789393" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/45155monadonarbitrarycategories.html#158789393">Kenny Lau (Feb 18 2019 at 10:19)</a>:</h4>
<p>Would it be useful to have monads on categories instead of always on Types?</p>

<a name="158789513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/monad%20on%20arbitrary%20categories/near/158789513" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/45155monadonarbitrarycategories.html#158789513">Kenny Lau (Feb 18 2019 at 10:21)</a>:</h4>
<p>that would also require Cartesian-Closed-Categories though</p>

<a name="158789559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/monad%20on%20arbitrary%20categories/near/158789559" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/45155monadonarbitrarycategories.html#158789559">Johannes Hölzl (Feb 18 2019 at 10:22)</a>:</h4>
<p>Yes, they are also interesting for category theory. An instance I'm interested in is the monad on measurable spaces, i.e. the Giry monad. But keep in mind that they are different beasts than the <code>Type</code>-monads. The latter is very normal in DDT, the former is more involved.</p>

<a name="158789573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/monad%20on%20arbitrary%20categories/near/158789573" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/45155monadonarbitrarycategories.html#158789573">Johannes Hölzl (Feb 18 2019 at 10:22)</a>:</h4>
<p>Hm, I don't think so. Monads work on arbitrary functors no CCCs are required.</p>

<a name="158789595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/monad%20on%20arbitrary%20categories/near/158789595" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/45155monadonarbitrarycategories.html#158789595">Kenny Lau (Feb 18 2019 at 10:22)</a>:</h4>
<p>but we also want <code>&lt;*&gt;</code> don't we</p>

<a name="158789723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/monad%20on%20arbitrary%20categories/near/158789723" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/45155monadonarbitrarycategories.html#158789723">Johannes Hölzl (Feb 18 2019 at 10:25)</a>:</h4>
<p>I'm not sure what the best approach is. Keep in mind that monads in category theory are different, the morphisms are not necessary functions.</p>

<a name="158789756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/monad%20on%20arbitrary%20categories/near/158789756" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/45155monadonarbitrarycategories.html#158789756">Johannes Hölzl (Feb 18 2019 at 10:25)</a>:</h4>
<p>Often they are a subset of functions, but not in a CCC (at least not in Top or Meas)</p>

<a name="158811627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/monad%20on%20arbitrary%20categories/near/158811627" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/45155monadonarbitrarycategories.html#158811627">Simon Hudon (Feb 18 2019 at 16:28)</a>:</h4>
<p>I have a draft of those (monads and CCCs) on my drive. I can clean them up and PR them</p>

<a name="158811708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/monad%20on%20arbitrary%20categories/near/158811708" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/45155monadonarbitrarycategories.html#158811708">Simon Hudon (Feb 18 2019 at 16:29)</a>:</h4>
<p><span class="user-mention" data-user-id="110294">@Johannes Hölzl</span> Do you think it's a good idea to define monads as their Kleisli category and then derive a monoid from them?</p>

<a name="158812087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/monad%20on%20arbitrary%20categories/near/158812087" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/45155monadonarbitrarycategories.html#158812087">Johan Commelin (Feb 18 2019 at 16:35)</a>:</h4>
<p>For adjunctions we also had choices, and we came to the conclusion that we just wanted both.</p>

<a name="158812104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/monad%20on%20arbitrary%20categories/near/158812104" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/45155monadonarbitrarycategories.html#158812104">Johan Commelin (Feb 18 2019 at 16:35)</a>:</h4>
<p>Redundancy of data in definitions seems to be a good thing.</p>

<a name="158812310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/monad%20on%20arbitrary%20categories/near/158812310" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/45155monadonarbitrarycategories.html#158812310">Johannes Hölzl (Feb 18 2019 at 16:38)</a>:</h4>
<p><span class="user-mention" data-user-id="110026">@Simon Hudon</span> I think we should focus on what we need. Do you have a case where you get a Kleisli category? Or do you have a functor + monad properties? In my case I currently need the later.</p>

<a name="158812956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/monad%20on%20arbitrary%20categories/near/158812956" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/45155monadonarbitrarycategories.html#158812956">Simon Hudon (Feb 18 2019 at 16:48)</a>:</h4>
<p>When you say monad properties, do you mean as a monoid? I have a preference for the kleisli category because it does not depend on monoidal catergories (of which there seems to be an endless supply of bad definitions) and it is easier to connect to programming</p>

<a name="158812981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/monad%20on%20arbitrary%20categories/near/158812981" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/45155monadonarbitrarycategories.html#158812981">Reid Barton (Feb 18 2019 at 16:48)</a>:</h4>
<p>I think this has come up before, but my view is that we certainly want the ordinary definition of a monad at some point (i.e., a functor <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>:</mo><mi>C</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">T : C \to C</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mrel">:</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.07153em;">C</span></span></span></span> with a unit <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>→</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">1 \to T</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathrm">1</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.13889em;">T</span></span></span></span> and multiplication <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>∘</mo><mi>T</mi><mo>→</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">T \circ T \to T</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mbin">∘</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.13889em;">T</span></span></span></span> such that ...), but monads aren't actually as useful for proving basic things about algebraic categories as books on category theory would have you believe.</p>

<a name="158813131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/monad%20on%20arbitrary%20categories/near/158813131" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/45155monadonarbitrarycategories.html#158813131">Reid Barton (Feb 18 2019 at 16:51)</a>:</h4>
<p>Because in the monad approach you still have to define the monad and its multiplication from scratch, and the monad is supposed to compute, for example, the free group on a set, and writing that down is most of the work of proving that the category of groups has colimits or whatever. And then you still have to check that algebras for the free group monad are the same as groups defined in the usual way, because your examples are all in the latter form.</p>

<a name="158813621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/monad%20on%20arbitrary%20categories/near/158813621" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/45155monadonarbitrarycategories.html#158813621">Reid Barton (Feb 18 2019 at 16:56)</a>:</h4>
<p>But there are also more significant applications of monads. Note this is all from a math perspective.</p>

<a name="158814265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/monad%20on%20arbitrary%20categories/near/158814265" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/45155monadonarbitrarycategories.html#158814265">Reid Barton (Feb 18 2019 at 17:04)</a>:</h4>
<p>The issue related to CCCs is I guess <code>monad</code> extends <code>appllicative</code>, which is supposed to mean a lax closed functor or lax monoidal functor depending on your point of view. That is something specific to the category of types (sets)--actually I'm not sure in what generality it holds.  I actually don't see why the category being a CCC should be enough, I think you also need the monad to be a strong functor.<br>
But anyways, that might cause some difficulty if we try to unify <code>monad</code> with the monads from category theory.</p>

<a name="158815037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/monad%20on%20arbitrary%20categories/near/158815037" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/45155monadonarbitrarycategories.html#158815037">Reid Barton (Feb 18 2019 at 17:16)</a>:</h4>
<p><span class="user-mention" data-user-id="110026">@Simon Hudon</span> by "the kleisli category" do you mean something like page 35 of <a href="http://www.cse.chalmers.se/research/group/logic/Types/Uustalo-lectures.pdf" target="_blank" title="http://www.cse.chalmers.se/research/group/logic/Types/Uustalo-lectures.pdf">http://www.cse.chalmers.se/research/group/logic/Types/Uustalo-lectures.pdf</a>? That is, specifying a monad by giving its Kleisli category</p>

<a name="158815947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/monad%20on%20arbitrary%20categories/near/158815947" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/45155monadonarbitrarycategories.html#158815947">Simon Hudon (Feb 18 2019 at 17:29)</a>:</h4>
<p>That looks similar. I'm not too well versed in the who adjunction business but I think that's the same. You can specify a monad M on C by giving a category with the same objects as C and which defines a morphism between <code>a --&gt; b</code> iff C has one between <code>a --&gt; M b</code></p>

<a name="158816072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/monad%20on%20arbitrary%20categories/near/158816072" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/45155monadonarbitrarycategories.html#158816072">Reid Barton (Feb 18 2019 at 17:31)</a>:</h4>
<p>Okay, but then you need to require something on the new category in order to know that it's the Kleisli category of some monad. (For example, it could also be the co-Kleisli category of a comonad.) Apparently, it's this right adjoint condition</p>

<a name="158816103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/monad%20on%20arbitrary%20categories/near/158816103" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/45155monadonarbitrarycategories.html#158816103">Simon Hudon (Feb 18 2019 at 17:32)</a>:</h4>
<p>Isn't that automatic?</p>

<a name="158816157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/monad%20on%20arbitrary%20categories/near/158816157" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/45155monadonarbitrarycategories.html#158816157">Reid Barton (Feb 18 2019 at 17:32)</a>:</h4>
<p>isn't what automatic?</p>

<a name="158816210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/monad%20on%20arbitrary%20categories/near/158816210" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/45155monadonarbitrarycategories.html#158816210">Reid Barton (Feb 18 2019 at 17:33)</a>:</h4>
<p>If I start with a monad, then I can build a Kleisli category, which has the same objects and a functor from the original category that is the identity on objects. But if I start with any nonsense such category, it might not come from a monad in this way (I already gave a counterexample--I could build other examples from a comonad)</p>

<a name="158816299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/monad%20on%20arbitrary%20categories/near/158816299" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/45155monadonarbitrarycategories.html#158816299">Reid Barton (Feb 18 2019 at 17:35)</a>:</h4>
<p>You also have to check that the Kleisli category "remembers" the entire monad, but I think that's some easy Yoneda argument</p>

<a name="158816447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/monad%20on%20arbitrary%20categories/near/158816447" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/45155monadonarbitrarycategories.html#158816447">Simon Hudon (Feb 18 2019 at 17:37)</a>:</h4>
<p>Ok, I see. I think I misunderstood your point. I now see that the comonad was your counterexample.</p>

<a name="158816522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/monad%20on%20arbitrary%20categories/near/158816522" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/45155monadonarbitrarycategories.html#158816522">Simon Hudon (Feb 18 2019 at 17:38)</a>:</h4>
<p>Does the whole monad have anything more than a monoid in the category of endofunctors?</p>

<a name="158816542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/monad%20on%20arbitrary%20categories/near/158816542" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/45155monadonarbitrarycategories.html#158816542">Reid Barton (Feb 18 2019 at 17:39)</a>:</h4>
<p>No, those definitions are equivalent</p>

<a name="158816674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/monad%20on%20arbitrary%20categories/near/158816674" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/45155monadonarbitrarycategories.html#158816674">Simon Hudon (Feb 18 2019 at 17:40)</a>:</h4>
<p>That's curious. I thought my Kleisli construction was sufficient to generate that monoid. I'll have to revisit it to see what I missed</p>

<a name="158816686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/monad%20on%20arbitrary%20categories/near/158816686" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/45155monadonarbitrarycategories.html#158816686">Reid Barton (Feb 18 2019 at 17:41)</a>:</h4>
<p>I agree trying to literally write "monoid object in the category of endofunctors" using monoidal categories would be a mess, but the definition you get by unraveling "monoid object" is rather simple (and what I think of as the usual one), see <a href="https://en.wikipedia.org/wiki/Monad_(category_theory)#Formal_definition" target="_blank" title="https://en.wikipedia.org/wiki/Monad_(category_theory)#Formal_definition">https://en.wikipedia.org/wiki/Monad_(category_theory)#Formal_definition</a></p>

<a name="158816934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/monad%20on%20arbitrary%20categories/near/158816934" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/45155monadonarbitrarycategories.html#158816934">Simon Hudon (Feb 18 2019 at 17:44)</a>:</h4>
<p>Nice! Thanks!</p>

<a name="158816988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/monad%20on%20arbitrary%20categories/near/158816988" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/45155monadonarbitrarycategories.html#158816988">Reid Barton (Feb 18 2019 at 17:45)</a>:</h4>
<p>If you start from the Kleisli category, let's call it D, you need some way to show that D(A, B) = C(A, TB) for some functor T on C. If you have that, then the monad laws for T should follow.<br>
It's easier to just start with T.</p>

<a name="158817209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/monad%20on%20arbitrary%20categories/near/158817209" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/45155monadonarbitrarycategories.html#158817209">Simon Hudon (Feb 18 2019 at 17:49)</a>:</h4>
<p>Ah! Yes! That's what I did! I start with T and C and the monad instance define <code>bind : (a --&gt; T b) -&gt; (b --&gt; T c) -&gt; (a --&gt; T c</code> and <code>return : a --&gt; T a</code> with morphisms on <code>C</code> together with their laws. The Kleisli category is actually derived from that. I thought of it as the Kleisli category itself because of how close they are.</p>

<a name="158817292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/monad%20on%20arbitrary%20categories/near/158817292" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/45155monadonarbitrarycategories.html#158817292">Reid Barton (Feb 18 2019 at 17:50)</a>:</h4>
<p>Okay, so you were probably thinking of something like "T : C -&gt; C, together with a category structure on Ob C with hom sets given by A -&gt; TB"</p>

<a name="158817435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/monad%20on%20arbitrary%20categories/near/158817435" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/45155monadonarbitrarycategories.html#158817435">Simon Hudon (Feb 18 2019 at 17:52)</a>:</h4>
<p>Yes exactly</p>


{% endraw %}
