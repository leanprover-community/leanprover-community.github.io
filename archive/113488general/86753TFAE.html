---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/86753TFAE.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html">TFAE</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="133533223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133533223" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133533223">Reid Barton (Sep 07 2018 at 21:52)</a>:</h4>
<p>What's the best way to structure the statement and proof when I want to prove (1), (2), and (3) are equivalent by showing (1) =&gt; (2) =&gt; (3) =&gt; (1)?</p>

<a name="133533668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133533668" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133533668">Reid Barton (Sep 07 2018 at 22:01)</a>:</h4>
<p>Let's say (1) is the definition of something, and (2) and (3) are alternate definitions and I'd like to end up with (1) &lt;=&gt; (2) and (1) &lt;=&gt; (3).<br>
I could just do something very straightforward (prove (1) =&gt; (2), (2) =&gt; (3), (3) =&gt; (1) as separate top-level lemmas, then conclude (1) &lt;=&gt; (2) and (1) &lt;=&gt; (3) manually) but maybe there is a better idea.</p>

<a name="133552573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133552573" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133552573">Keeley Hoek (Sep 08 2018 at 05:47)</a>:</h4>
<p>it'd be cool if there was a tactic for this</p>

<a name="133552679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133552679" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133552679">Mario Carneiro (Sep 08 2018 at 05:51)</a>:</h4>
<p>I'm not sure how a tactic could help. The problem is the proof structuring, you don't want all three major parts to be in one big proof</p>

<a name="133552721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133552721" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133552721">Mario Carneiro (Sep 08 2018 at 05:52)</a>:</h4>
<p>It is easy enough to encode the idea of a cycle in a preorder, and deduce equivalence of all parts, which you could prove once and for all and apply as a theorem for your 11-part theorem</p>

<a name="133552726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133552726" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133552726">Mario Carneiro (Sep 08 2018 at 05:53)</a>:</h4>
<p>For the case of 2 or 3 statements, it's easier just to use the lemmas as given</p>

<a name="133552773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133552773" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133552773">Mario Carneiro (Sep 08 2018 at 05:54)</a>:</h4>
<p>I'm not sure I've ever had a case of 4+ statements proven in cyclic order where I actually care about all 4 equivalences</p>

<a name="133553769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133553769" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133553769">Keeley Hoek (Sep 08 2018 at 06:26)</a>:</h4>
<p>I was just thinking of a tactic which turns a single goal "a iff b iff c iff d iff ..." into a cyclic set of goals "a=&gt;b", "b=&gt;c", etc. Probably itd be too yuck for anything big?</p>

<a name="133553893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133553893" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133553893">Mario Carneiro (Sep 08 2018 at 06:30)</a>:</h4>
<p>There are two problems with that: (1) the goals might be big - if they aren't there isn't really a need for this (2) The output is <code>a iff b iff c</code> - what is that? If it is a big conjunction then there is still work to be done to make a usable lemma</p>

<a name="133553898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133553898" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133553898">Keeley Hoek (Sep 08 2018 at 06:30)</a>:</h4>
<p>yep ok sure</p>

<a name="133559919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133559919" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133559919">Reid Barton (Sep 08 2018 at 10:21)</a>:</h4>
<blockquote>
<p>(2) The output is <code>a iff b iff c</code> - what is that? If it is a big conjunction then there is still work to be done to make a usable lemma</p>
</blockquote>
<p>Yeah, this is where I really got stuck</p>

<a name="133561811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133561811" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133561811">Chris Hughes (Sep 08 2018 at 11:32)</a>:</h4>
<p>Also <code>a iff b iff c</code> is not the same as <code>a iff b and b iff c</code></p>

<a name="133562136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133562136" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133562136">Reid Barton (Sep 08 2018 at 11:45)</a>:</h4>
<p>I guess one out-there idea is to define</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">the_following_are_equivalent</span> <span class="o">(</span><span class="n">ps</span> <span class="o">:</span> <span class="n">list</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">p</span> <span class="n">q</span> <span class="err">∈</span> <span class="n">ps</span><span class="o">,</span> <span class="n">p</span> <span class="bp">↔</span> <span class="n">q</span>
</pre></div>


<p>and then a helper function which extracts for a given pair of indices implication (or bi-implication) between the corresponding Props</p>

<a name="133562550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133562550" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133562550">Reid Barton (Sep 08 2018 at 11:58)</a>:</h4>
<p>Mario I do agree that when the list is really long, typically some of the equivalent statements are not included for later use, but rather to elucidate the structure of the argument. Or to say: here is a variant definition of something and you might wonder whether it is equivalent to the official one; it is (and now we never need to talk about it again).</p>

<a name="133586841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133586841" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133586841">Simon Hudon (Sep 09 2018 at 01:54)</a>:</h4>
<p>I could imagine a presentation like:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">my_interesting_equivalences</span> <span class="o">:</span>
   <span class="n">the_following_are_equivalent</span>
    <span class="o">[</span> <span class="n">formula1</span><span class="o">,</span>
      <span class="n">formula2</span><span class="o">,</span>
      <span class="n">formula3</span> <span class="o">]</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">circular_implication</span><span class="o">,</span>
  <span class="o">{</span> <span class="c">/-</span><span class="cm"> proof1 -/</span> <span class="o">},</span>
  <span class="o">{</span> <span class="c">/-</span><span class="cm"> proof2 -/</span> <span class="o">},</span>
  <span class="o">{</span> <span class="c">/-</span><span class="cm"> proof3 -/</span> <span class="o">},</span>
<span class="kn">end</span>
</pre></div>


<p>and have <code>circular_implication</code> extract the two by two equivalences as separate lemmas: <code>my_interesting_equivalences_1_2</code>, my_interesting_equivalences_1_3<code>, my_interesting_equivalences_2_3</code>.</p>

<a name="133586909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133586909" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133586909">Simon Hudon (Sep 09 2018 at 01:56)</a>:</h4>
<p>Or, even better:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">my_interesting_equivalences</span> <span class="o">:</span>
   <span class="n">the_following_are_equivalent</span>
    <span class="o">[</span> <span class="n">Reids_defn</span> <span class="bp">::=</span> <span class="n">formula1</span><span class="o">,</span>
      <span class="n">Simons_defn</span> <span class="bp">::=</span> <span class="n">formula2</span><span class="o">,</span>
      <span class="n">Marios_defn</span> <span class="bp">::=</span> <span class="n">formula3</span> <span class="o">]</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">circular_implication</span><span class="o">,</span>
  <span class="o">{</span> <span class="c">/-</span><span class="cm"> proof1 -/</span> <span class="o">},</span>
  <span class="o">{</span> <span class="c">/-</span><span class="cm"> proof2 -/</span> <span class="o">},</span>
  <span class="o">{</span> <span class="c">/-</span><span class="cm"> proof3 -/</span> <span class="o">},</span>
<span class="kn">end</span>
</pre></div>


<p>and then have <code>my_interesting_equivalences_Reids_defn_iff_Simons_defn</code> etc and make <code>Reids_defn</code>, <code>Simons_defn</code> and <code>Marios_defn</code> into stand alone definitions.</p>

<a name="133587038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133587038" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133587038">Mario Carneiro (Sep 09 2018 at 02:01)</a>:</h4>
<p>This won't work inside a theorem, you can't make new definitions</p>

<a name="133587079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133587079" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133587079">Mario Carneiro (Sep 09 2018 at 02:02)</a>:</h4>
<p>Also, that's a quadratic number of generated lemmas</p>

<a name="133587184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133587184" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133587184">Simon Hudon (Sep 09 2018 at 02:06)</a>:</h4>
<blockquote>
<p>This won't work inside a theorem, you can't make new definitions</p>
</blockquote>
<p>I'm fairly sure that you can.</p>

<a name="133587234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133587234" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133587234">Simon Hudon (Sep 09 2018 at 02:08)</a>:</h4>
<blockquote>
<p>Also, that's a quadratic number of generated lemmas</p>
</blockquote>
<p>Yes it is but that's what you're trying to prove if you use this approach, no? You could also state only consecutive equivalences but I think that would make the use of those lemmas harder.</p>

<a name="133587455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133587455" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133587455">Kenny Lau (Sep 09 2018 at 02:16)</a>:</h4>
<p>I know there's a tactic that can generate iff statements for any inductive type</p>

<a name="133587500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133587500" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133587500">Mario Carneiro (Sep 09 2018 at 02:18)</a>:</h4>
<p>Here's how I think you can do it with just definitions:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">list</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">namespace</span> <span class="n">list</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">def</span> <span class="n">last&#39;</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">[]</span>     <span class="o">:=</span> <span class="n">a</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">(</span><span class="n">b</span><span class="bp">::</span><span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="n">last&#39;</span> <span class="n">b</span> <span class="n">l</span>

<span class="n">def</span> <span class="n">TFAE</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">l</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">l</span><span class="o">,</span> <span class="n">x</span> <span class="bp">↔</span> <span class="n">y</span>

<span class="kn">theorem</span> <span class="n">TFAE_of_cycle</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span><span class="o">}</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">list</span><span class="bp">.</span><span class="n">chain</span> <span class="o">(</span><span class="bp">→</span><span class="o">)</span> <span class="n">a</span> <span class="o">(</span><span class="n">b</span><span class="bp">::</span><span class="n">l</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">last&#39;</span> <span class="n">b</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">a</span><span class="o">)</span> <span class="bp">→</span> <span class="n">TFAE</span> <span class="o">(</span><span class="n">a</span><span class="bp">::</span><span class="n">b</span><span class="bp">::</span><span class="n">l</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">sorry</span>

<span class="n">def</span> <span class="n">TFAE</span><span class="bp">.</span><span class="n">out</span> <span class="o">{</span><span class="n">l</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">TFAE</span> <span class="n">l</span><span class="o">)</span> <span class="o">(</span><span class="n">n₁</span> <span class="n">n₂</span><span class="o">)</span>
 <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">n₁</span> <span class="bp">&lt;</span> <span class="n">list</span><span class="bp">.</span><span class="n">length</span> <span class="n">l</span> <span class="bp">.</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">exact_dec_trivial</span><span class="o">)</span>
 <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">n₂</span> <span class="bp">&lt;</span> <span class="n">list</span><span class="bp">.</span><span class="n">length</span> <span class="n">l</span> <span class="bp">.</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">exact_dec_trivial</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">list</span><span class="bp">.</span><span class="n">nth_le</span> <span class="n">l</span> <span class="n">n₁</span> <span class="n">h₁</span> <span class="bp">↔</span> <span class="n">list</span><span class="bp">.</span><span class="n">nth_le</span> <span class="n">l</span> <span class="n">n₂</span> <span class="n">h₂</span> <span class="o">:=</span>
<span class="n">h</span> <span class="bp">_</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">nth_le_mem</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="bp">_</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">nth_le_mem</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span>

<span class="kn">theorem</span> <span class="n">TFAE_test</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">TFAE</span> <span class="o">[</span><span class="n">true</span><span class="o">,</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">y</span><span class="o">]</span> <span class="o">:=</span>
<span class="n">TFAE_of_cycle</span> <span class="o">(</span><span class="k">by</span> <span class="n">simp</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">trivial</span><span class="o">)</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">↔</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span> <span class="o">(</span><span class="n">TFAE_test</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">out</span> <span class="mi">1</span> <span class="mi">2</span>

<span class="kn">end</span> <span class="n">list</span>
</pre></div>

<a name="133587508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133587508" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133587508">Mario Carneiro (Sep 09 2018 at 02:19)</a>:</h4>
<p>A tactic could be used to unfold the definitions involved in <code>TFAE_of_cycle</code></p>

<a name="133587509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133587509" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133587509">Mario Carneiro (Sep 09 2018 at 02:19)</a>:</h4>
<p>then again, <code>simp</code> already does that</p>

<a name="133587554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133587554" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133587554">Kenny Lau (Sep 09 2018 at 02:21)</a>:</h4>
<p>wow that's so magical</p>

<a name="133587995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133587995" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133587995">Mario Carneiro (Sep 09 2018 at 02:37)</a>:</h4>
<p>Another option besides <code>TFAE.out</code> is to use</p>
<div class="codehilite"><pre><span></span>theorem TFAE_iff_iff {a l} : TFAE (a::l) ↔ ∀ b ∈ l, a ↔ b := sorry
</pre></div>


<p>as a simp lemma, that way you can simplify a <code>TFAE</code> into a bunch of iffs with the first thing in the list (which is usually what you will want to have as the output theorems)</p>

<a name="133745529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133745529" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133745529">Cyril Cohen (Sep 11 2018 at 18:59)</a>:</h4>
<p><span class="user-mention" data-user-id="110172">@Assia Mahboubi</span> pointed this thread to me. It is funny because I was considering adding such a feature to mathcomp: <a href="https://github.com/math-comp/math-comp/commit/0d41046cff37af7b85da0e771e3d25a4c640edbf" target="_blank" title="https://github.com/math-comp/math-comp/commit/0d41046cff37af7b85da0e771e3d25a4c640edbf">https://github.com/math-comp/math-comp/commit/0d41046cff37af7b85da0e771e3d25a4c640edbf</a></p>

<a name="133748935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133748935" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133748935">Patrick Massot (Sep 11 2018 at 19:55)</a>:</h4>
<p>What is the interface you chose then? It's hard to tell from the link  without knowing Coq</p>

<a name="133792495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133792495" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133792495">Cyril Cohen (Sep 12 2018 at 13:23)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> I chose something like: <code>[↔ P0; ...; Pn] := (all_iff P0 [P1; ...; Pn]) := ((P0 → P1) ∧ (P1 → P2) ∧ ... ∧ (Pn → P0))</code> (pseudo syntax)<br>
And the main theorem <code>all_iffLR</code> says roughly that <code>[↔ P0; ...; Pn] → ∀i j, Pi → Pj</code> (pseudo syntax again), and is a coercion to a function, so that a lemma <code>mylemma : [↔ P0; ...; Pn]</code> can be applied to natural numbers to give <code>mylemma i j</code>, a proof of <code>Pi → Pj</code>.</p>

<a name="133792868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133792868" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133792868">Johan Commelin (Sep 12 2018 at 13:30)</a>:</h4>
<p>That looks like a really nice way to attack this.</p>

<a name="133792930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133792930" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133792930">Johan Commelin (Sep 12 2018 at 13:32)</a>:</h4>
<p>As a mathematician I wonder if we could use tactics to allow for even more general ways of proving an <code>all_iff</code> instead of only cycles.</p>

<a name="133792958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133792958" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133792958">Cyril Cohen (Sep 12 2018 at 13:33)</a>:</h4>
<p>One of the improvements I have in mind is to provide a graph. And have the computational part of the system check it is strongly connected, then ask to prove only the edges. (so no deep tactic involved, just reflexion)</p>

<a name="133793003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133793003" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133793003">Johan Commelin (Sep 12 2018 at 13:34)</a>:</h4>
<p>Right.</p>

<a name="133793006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133793006" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133793006">Johan Commelin (Sep 12 2018 at 13:34)</a>:</h4>
<p>But it would allow for more convenience.</p>

<a name="133793017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133793017" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133793017">Cyril Cohen (Sep 12 2018 at 13:34)</a>:</h4>
<p>Yes</p>

<a name="133793019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133793019" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133793019">Johan Commelin (Sep 12 2018 at 13:35)</a>:</h4>
<p>The interactive version would first ask the user to supply a graph. Then the system does the connectedness check (or asks the user for a proof). And then the tactic goes on to supply you all the edges 1-by-1</p>

<a name="133793042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133793042" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133793042">Johan Commelin (Sep 12 2018 at 13:35)</a>:</h4>
<p>I mean, check this out: <a href="https://stacks.math.columbia.edu/tag/04GG" target="_blank" title="https://stacks.math.columbia.edu/tag/04GG">https://stacks.math.columbia.edu/tag/04GG</a></p>

<a name="133793116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133793116" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133793116">Johan Commelin (Sep 12 2018 at 13:37)</a>:</h4>
<p>Too bad we don't have a lot about graphs in Lean.</p>

<a name="133793117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133793117" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133793117">Cyril Cohen (Sep 12 2018 at 13:37)</a>:</h4>
<p>I would start my proof by applying the lemma <code>all_iff_from [(2,1);(5,3)...]</code>(implicit arguments + unification would do the job of checking the connectedness of the graph, and a split would ask for all the implications, that is why I see no need for a tactic...</p>

<a name="133793166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133793166" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133793166">Cyril Cohen (Sep 12 2018 at 13:38)</a>:</h4>
<p>And since we have graphs in coq with math-comp, I am really eager to try :)</p>

<a name="133793173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133793173" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133793173">Johan Commelin (Sep 12 2018 at 13:38)</a>:</h4>
<p>But do you have henselian local rings?</p>

<a name="133793175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133793175" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133793175">Johan Commelin (Sep 12 2018 at 13:38)</a>:</h4>
<p>Just kidding...</p>

<a name="133793184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133793184" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133793184">Johan Commelin (Sep 12 2018 at 13:39)</a>:</h4>
<p>I would love to have this kind of stuff in Lean!</p>

<a name="133793189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133793189" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133793189">Johan Commelin (Sep 12 2018 at 13:39)</a>:</h4>
<p>How hard is the connectedness check? I guess that shouldn't be too hard, right?</p>

<a name="133793241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133793241" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133793241">Cyril Cohen (Sep 12 2018 at 13:40)</a>:</h4>
<p>it is just a dfs</p>

<a name="133793242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133793242" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133793242">Johan Commelin (Sep 12 2018 at 13:40)</a>:</h4>
<p>/me walks over to his copy of TAOCP</p>

<a name="133793250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133793250" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133793250">Johan Commelin (Sep 12 2018 at 13:40)</a>:</h4>
<p>Right, and you need to generate a proof along the way.</p>

<a name="133793266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133793266" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133793266">Johan Commelin (Sep 12 2018 at 13:41)</a>:</h4>
<p>(I've never really written tactics before... so I'm just thinking out loud.)</p>

<a name="133793352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133793352" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133793352">Johan Commelin (Sep 12 2018 at 13:42)</a>:</h4>
<p>Hmmm... but most of this isn't even <code>meta</code>.</p>

<a name="133793369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133793369" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133793369">Johan Commelin (Sep 12 2018 at 13:43)</a>:</h4>
<p><span class="user-mention" data-user-id="110193">@Cyril Cohen</span> Two questions: (1) Do you have any experience in Lean? (2) Where can we find your coq implementation?</p>

<a name="133793540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133793540" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133793540">Cyril Cohen (Sep 12 2018 at 13:47)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> (1) I only saw <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> and <span class="user-mention" data-user-id="110294">@Johannes Hölzl</span> in action, I have no more experience than that. (2) my current coq implementation does not support graphs yet, only what I described in the message you replied to and it is here: <a href="https://github.com/math-comp/math-comp/commit/0d41046cff37af7b85da0e771e3d25a4c640edbf" target="_blank" title="https://github.com/math-comp/math-comp/commit/0d41046cff37af7b85da0e771e3d25a4c640edbf">https://github.com/math-comp/math-comp/commit/0d41046cff37af7b85da0e771e3d25a4c640edbf</a> (waiting patiently to be cleaned and merged since august)</p>

<a name="133793720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133793720" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133793720">Johan Commelin (Sep 12 2018 at 13:50)</a>:</h4>
<p>Ok, understood <span class="emoji emoji-1f44d" title="thumbs up">:thumbs_up:</span></p>

<a name="133793964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133793964" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133793964">Patrick Massot (Sep 12 2018 at 13:55)</a>:</h4>
<p>Nice! So the current implementation in Coq is about using a chain of equivalences, not proving it. But clearly both ways are useful. I'm sure we'll soon have this in Lean</p>

<a name="133794023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133794023" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133794023">Cyril Cohen (Sep 12 2018 at 13:57)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> it's also about proving it, but only from circular implications <code>P0 -&gt; ... -&gt; Pn -&gt; P0</code> (no arbitrary strongly connected graph)</p>

<a name="133794539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133794539" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133794539">Patrick Massot (Sep 12 2018 at 14:10)</a>:</h4>
<p>ok, nice</p>

<a name="133794566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133794566" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133794566">Patrick Massot (Sep 12 2018 at 14:11)</a>:</h4>
<p>I guess it already covers most use cases, you only need to list the conditions in the order you intend to prove the chain of implications, and then you can use any implication</p>

<a name="133794674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133794674" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133794674">Johan Commelin (Sep 12 2018 at 14:13)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">vector</span>

<span class="bp">@</span><span class="o">[</span><span class="n">pattern</span><span class="o">]</span> <span class="n">def</span> <span class="n">vector</span><span class="bp">.</span><span class="n">mk</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">pr</span> <span class="o">:</span> <span class="n">l</span><span class="bp">.</span><span class="n">length</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">l</span><span class="o">,</span> <span class="n">pr</span><span class="bp">⟩</span>

<span class="n">def</span> <span class="n">all_iff</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">},</span> <span class="n">vector</span> <span class="kt">Prop</span> <span class="n">n</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="mi">0</span>     <span class="n">Ps</span> <span class="o">:=</span> <span class="n">true</span>
<span class="bp">|</span> <span class="mi">1</span>     <span class="n">Ps</span> <span class="o">:=</span> <span class="n">Ps</span><span class="bp">.</span><span class="n">head</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">2</span><span class="o">)</span> <span class="n">Ps</span> <span class="o">:=</span> <span class="o">(</span><span class="n">Ps</span><span class="bp">.</span><span class="n">head</span> <span class="bp">→</span> <span class="n">Ps</span><span class="bp">.</span><span class="n">tail</span><span class="bp">.</span><span class="n">head</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">all_iff</span> <span class="n">Ps</span><span class="bp">.</span><span class="n">tail</span><span class="o">)</span>

<span class="n">local</span> <span class="kn">notation</span> <span class="bp">`</span><span class="o">[</span><span class="bp">↔`</span> <span class="n">l</span><span class="o">:(</span><span class="n">foldr</span> <span class="bp">`</span><span class="o">,</span> <span class="bp">`</span> <span class="o">(</span><span class="n">h</span> <span class="n">t</span><span class="o">,</span> <span class="n">list</span><span class="bp">.</span><span class="n">cons</span> <span class="n">h</span> <span class="n">t</span><span class="o">)</span> <span class="n">list</span><span class="bp">.</span><span class="n">nil</span> <span class="bp">`</span><span class="o">]</span><span class="bp">`</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">all_iff</span> <span class="o">(</span><span class="n">vector</span><span class="bp">.</span><span class="n">mk</span> <span class="n">l</span> <span class="n">rfl</span><span class="o">)</span>

<span class="kn">example</span> <span class="o">:</span> <span class="o">[</span><span class="bp">↔</span> <span class="n">true</span><span class="o">,</span> <span class="n">false</span><span class="o">]</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="n">def</span> <span class="n">all_iff_LR</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">Ps</span> <span class="o">:</span> <span class="n">vector</span> <span class="kt">Prop</span> <span class="n">n</span><span class="o">}</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">all_iff</span> <span class="n">Ps</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="n">Ps</span><span class="bp">.</span><span class="n">nth</span> <span class="n">i</span> <span class="bp">→</span> <span class="n">Ps</span><span class="bp">.</span><span class="n">nth</span> <span class="n">j</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>

<a name="133794856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133794856" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133794856">Johan Commelin (Sep 12 2018 at 14:16)</a>:</h4>
<p>Oops, there is a bug. I'm not closing the cycle.</p>

<a name="133795209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133795209" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133795209">Reid Barton (Sep 12 2018 at 14:24)</a>:</h4>
<p>Somewhere on Twitch there is now a video of me having proved 1 =&gt; 2 and 2 =&gt; 3 and 3 =&gt; 1 and then taking several minutes to figure out how to prove 2 &lt;=&gt; 1 and 3 &lt;=&gt; 1 and then later being unable to remember whether I had proved 2 &lt;=&gt; 1 or 1 &lt;=&gt; 2. So I guess there is some real non-zero value to this.</p>

<a name="133796095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133796095" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133796095">Johan Commelin (Sep 12 2018 at 14:42)</a>:</h4>
<p>This is better:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">vector</span>

<span class="bp">@</span><span class="o">[</span><span class="n">pattern</span><span class="o">]</span> <span class="n">def</span> <span class="n">vector</span><span class="bp">.</span><span class="n">mk</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">pr</span> <span class="o">:</span> <span class="n">l</span><span class="bp">.</span><span class="n">length</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">l</span><span class="o">,</span> <span class="n">pr</span><span class="bp">⟩</span>

<span class="bp">@</span><span class="o">[</span><span class="kn">reducible</span><span class="o">]</span> <span class="n">def</span> <span class="n">all_iff&#39;</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="bp">→</span> <span class="n">list</span> <span class="kt">Prop</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">P₀</span> <span class="o">[]</span>               <span class="o">:=</span> <span class="n">true</span>
<span class="bp">|</span> <span class="n">P₀</span> <span class="o">(</span><span class="n">P₁</span> <span class="bp">::</span> <span class="o">[])</span>       <span class="o">:=</span> <span class="n">P₁</span> <span class="bp">→</span> <span class="n">P₀</span>
<span class="bp">|</span> <span class="n">P₀</span> <span class="o">(</span><span class="n">P₁</span> <span class="bp">::</span> <span class="n">P₂</span> <span class="bp">::</span> <span class="n">Ps</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">P₁</span> <span class="bp">→</span> <span class="n">P₂</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">all_iff&#39;</span> <span class="n">P₀</span> <span class="o">(</span><span class="n">P₂</span> <span class="bp">::</span> <span class="n">Ps</span><span class="o">)</span>

<span class="n">def</span> <span class="n">all_iff</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">vector</span> <span class="kt">Prop</span> <span class="n">n</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="bp">⟨</span><span class="o">[],</span>             <span class="n">h</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">true</span>
<span class="bp">|</span> <span class="bp">⟨</span><span class="n">P</span> <span class="bp">::</span> <span class="o">[],</span>        <span class="n">h</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">true</span>
<span class="bp">|</span> <span class="bp">⟨</span><span class="n">P₀</span> <span class="bp">::</span> <span class="n">P₁</span> <span class="bp">::</span> <span class="n">Ps</span><span class="o">,</span> <span class="n">h</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="o">(</span><span class="n">P₀</span> <span class="bp">→</span> <span class="n">P₁</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">all_iff&#39;</span> <span class="n">P₀</span> <span class="o">(</span><span class="n">P₁</span> <span class="bp">::</span> <span class="n">Ps</span><span class="o">)</span>

<span class="n">local</span> <span class="kn">notation</span> <span class="bp">`</span><span class="o">[</span><span class="bp">↔`</span> <span class="n">l</span><span class="o">:(</span><span class="n">foldr</span> <span class="bp">`</span><span class="o">,</span> <span class="bp">`</span> <span class="o">(</span><span class="n">h</span> <span class="n">t</span><span class="o">,</span> <span class="n">list</span><span class="bp">.</span><span class="n">cons</span> <span class="n">h</span> <span class="n">t</span><span class="o">)</span> <span class="n">list</span><span class="bp">.</span><span class="n">nil</span> <span class="bp">`</span><span class="o">]</span><span class="bp">`</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">all_iff</span> <span class="o">(</span><span class="n">vector</span><span class="bp">.</span><span class="n">mk</span> <span class="n">l</span> <span class="n">rfl</span><span class="o">)</span>

<span class="kn">example</span> <span class="o">:</span> <span class="o">[</span><span class="bp">↔</span> <span class="n">true</span><span class="o">,</span> <span class="n">true</span><span class="o">,</span> <span class="n">true</span><span class="o">]</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">split</span><span class="o">,</span> <span class="n">tauto</span><span class="o">,</span>
  <span class="n">dsimp</span> <span class="o">[</span><span class="n">all_iff&#39;</span><span class="o">],</span> <span class="n">tauto</span>
<span class="kn">end</span>
</pre></div>

<a name="133796112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133796112" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133796112">Johan Commelin (Sep 12 2018 at 14:42)</a>:</h4>
<p>I would like to not have the <code>dsimp [all_iff']</code> in the example. I marked the definition <code>reducible</code>, but that didn't help.</p>

<a name="133796235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133796235" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133796235">Reid Barton (Sep 12 2018 at 14:45)</a>:</h4>
<p>I don't know whether this matters here, but when I was playing around with this stuff I found you can also do</p>
<div class="codehilite"><pre><span></span><span class="n">local</span> <span class="kn">notation</span> <span class="bp">`</span><span class="o">[</span><span class="bp">↔`</span> <span class="n">p0</span> <span class="bp">`</span><span class="o">,</span> <span class="bp">`</span> <span class="n">l</span><span class="o">:(</span><span class="n">foldr</span> <span class="bp">`</span><span class="o">,</span> <span class="bp">`</span> <span class="o">(</span><span class="n">h</span> <span class="n">t</span><span class="o">,</span> <span class="n">list</span><span class="bp">.</span><span class="n">cons</span> <span class="n">h</span> <span class="n">t</span><span class="o">)</span> <span class="n">list</span><span class="bp">.</span><span class="n">nil</span> <span class="bp">`</span><span class="o">]</span><span class="bp">`</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">all_iff</span> <span class="o">(</span><span class="n">vector</span><span class="bp">.</span><span class="n">mk</span> <span class="o">(</span><span class="n">p0</span> <span class="bp">::</span> <span class="n">l</span><span class="o">)</span> <span class="n">rfl</span><span class="o">)</span>
</pre></div>

<a name="133796240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133796240" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133796240">Reid Barton (Sep 12 2018 at 14:45)</a>:</h4>
<p>which lets you guarantee that the list is nonempty</p>

<a name="133796412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133796412" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133796412">Johan Commelin (Sep 12 2018 at 14:48)</a>:</h4>
<p>I'm not sure if we want that guarantee... for interaction sure. But maybe this code will also be used in automation or something. And then it would be nice if <code>[]</code> is not a problem.</p>

<a name="133796518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133796518" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133796518">Reid Barton (Sep 12 2018 at 14:50)</a>:</h4>
<p>If you <code>dsimp only [all_iff, all_iff', vector.mk]</code> first then you get a conjunction of the 3 iffs</p>

<a name="133796551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133796551" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133796551">Reid Barton (Sep 12 2018 at 14:51)</a>:</h4>
<p>I thought it might be more likely that allowing <code>[]</code> is a problem for automation than that disallowing it is a problem. But I'm not sure either, just thought I would mention the possibility.</p>

<a name="133796744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133796744" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133796744">Reid Barton (Sep 12 2018 at 14:55)</a>:</h4>
<p>I think a very simple tactic which turns an <code>all_iff</code> goal with list of length N into N subgoals (or possibly a conjunction of N implications) will probably be useful. Otherwise, I think it will be hard to avoid making the intermediate goals confusing.</p>

<a name="133796811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133796811" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133796811">Johan Commelin (Sep 12 2018 at 14:56)</a>:</h4>
<p>True, something like that is necessary.</p>

<a name="133797157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133797157" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133797157">Johan Commelin (Sep 12 2018 at 15:04)</a>:</h4>
<p><span class="user-mention" data-user-id="110193">@Cyril Cohen</span> I am very bad at reading coq code, apparently...</p>

<a name="133797191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133797191" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133797191">Johan Commelin (Sep 12 2018 at 15:05)</a>:</h4>
<p>I'm trying to prove <code>all_iff_LR</code> in Lean. I'm exploding into different cases. Is there a good strategy to prove this by induction?</p>

<a name="133797194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133797194" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133797194">Johan Commelin (Sep 12 2018 at 15:05)</a>:</h4>
<p>Do you case on <code>i &lt; j</code> or something similar?</p>

<a name="133797383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133797383" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133797383">Cyril Cohen (Sep 12 2018 at 15:09)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span>  I am using a lemma saying (roughly) that a function <code>f : nat -&gt; T</code> respects the order (<code>&lt;</code> for nat, and an arbitrary order on <code>T</code> (<code>-&gt;</code> on <code>Prop</code> in our case)) if one can prove that <code>f i  &lt; f (i + 1)</code> (or <code>f i -&gt; f (i + 1)</code> in our case). Only then, I do an induction.</p>

<a name="133797460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133797460" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133797460">Johan Commelin (Sep 12 2018 at 15:10)</a>:</h4>
<p>Hmm, I see. That seems smart.</p>

<a name="133797517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133797517" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133797517">Johan Commelin (Sep 12 2018 at 15:11)</a>:</h4>
<p>So now I need to find that lemma in mathlib. <span class="user-mention" data-user-id="110064">@Kenny Lau</span> Do you know the function that Cyril is talking about?</p>

<a name="133797578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133797578" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133797578">Kenny Lau (Sep 12 2018 at 15:12)</a>:</h4>
<p>is it even in mathlib?</p>

<a name="133797582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133797582" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133797582">Kenny Lau (Sep 12 2018 at 15:12)</a>:</h4>
<p>I'd just use induction to prove it</p>

<a name="133797584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133797584" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133797584">Johan Commelin (Sep 12 2018 at 15:12)</a>:</h4>
<p>Dunno.</p>

<a name="133798133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133798133" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133798133">Johan Commelin (Sep 12 2018 at 15:22)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">foobar</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">X</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">monotone</span> <span class="n">f</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">f</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">h</span> <span class="n">i</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">le_succ</span> <span class="n">i</span><span class="o">)</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">H</span><span class="o">,</span>
    <span class="n">unfold</span> <span class="n">monotone</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">h</span> <span class="k">with</span> <span class="n">x</span> <span class="n">h</span> <span class="n">ih</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">le_trans</span> <span class="n">ih</span> <span class="o">(</span><span class="n">H</span> <span class="n">x</span><span class="o">)</span> <span class="o">}</span>
  <span class="o">}</span>
<span class="kn">end</span>
</pre></div>

<a name="133798146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133798146" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133798146">Johan Commelin (Sep 12 2018 at 15:22)</a>:</h4>
<p>It still needs a name and golfing (-;</p>

<a name="133802962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133802962" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133802962">Johan Commelin (Sep 12 2018 at 16:37)</a>:</h4>
<p>Ok, I'm making slow progress. I'll try to post something later tonight.</p>

<a name="133803540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133803540" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133803540">Johan Commelin (Sep 12 2018 at 16:46)</a>:</h4>
<p><span class="user-mention" data-user-id="110524">@Scott Morrison</span> <span class="user-mention" data-user-id="110111">@Keeley Hoek</span>  I think I found a missing feature in <code>tidy</code>. It doesn't split <code>\iff</code> in the assumptions into two implications. If it did, I guess it could have solved more of my goals.</p>

<a name="133804789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133804789" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133804789">Keeley Hoek (Sep 12 2018 at 17:07)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> Could you give me an example? In the (admittedly baby) example</p>
<div class="codehilite"><pre><span></span>constants a b : Prop

def lol : iff a b := begin
  tidy,
  admit
end
</pre></div>


<p><code>tidy</code> does do what you're saying, I think.</p>

<a name="133804897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133804897" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133804897">Keeley Hoek (Sep 12 2018 at 17:09)</a>:</h4>
<p>Or are you talking about <code>tidy</code> not converting <code>iff</code> hypotheses into a pair of <code>implies</code> hypotheses? Maybe it should do that...</p>

<a name="133805759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133805759" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133805759">Keeley Hoek (Sep 12 2018 at 17:22)</a>:</h4>
<p>For the latter, give <a href="https://github.com/leanprover/mathlib/pull/344" target="_blank" title="https://github.com/leanprover/mathlib/pull/344">https://github.com/leanprover/mathlib/pull/344</a> (i.e. <a href="https://github.com/leanprover-community/mathlib/tree/auto-cases-iff" target="_blank" title="https://github.com/leanprover-community/mathlib/tree/auto-cases-iff">https://github.com/leanprover-community/mathlib/tree/auto-cases-iff</a>) a try.</p>

<a name="133811896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133811896" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133811896">Johan Commelin (Sep 12 2018 at 18:53)</a>:</h4>
<p><span class="user-mention" data-user-id="110111">@Keeley Hoek</span> Cool! That kills of another goal (-;</p>

<a name="133812980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133812980" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133812980">Mario Carneiro (Sep 12 2018 at 19:14)</a>:</h4>
<p>What was wrong with the sketch I gave earlier for <code>TFAE_of_cycle</code>? It should be isomorphic to cyril's definition</p>

<a name="133813298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133813298" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133813298">Keeley Hoek (Sep 12 2018 at 19:21)</a>:</h4>
<p>that <code>list.chain</code> syntax is sick Mario</p>

<a name="133814801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133814801" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133814801">Mario Carneiro (Sep 12 2018 at 19:46)</a>:</h4>
<p>Here's the whole proof:</p>
<div class="codehilite"><pre><span></span>namespace list

@[simp] def last&#39; {α} : α → list α → α
| a []     := a
| a (b::l) := last&#39; b l

theorem last&#39;_mem {α} : ∀ a l, @last&#39; α a l ∈ a :: l
| a []     := or.inl rfl
| a (b::l) := or.inr (last&#39;_mem b l)

def TFAE (l : list Prop) : Prop := ∀ x ∈ l, ∀ y ∈ l, x ↔ y

theorem TFAE_nil : TFAE [] := forall_mem_nil _
theorem TFAE_singleton (p) : TFAE [p] := by simp [TFAE]

theorem TFAE_cons_of_mem {a b} {l : list Prop} (h : b ∈ l) :
  TFAE (a::l) ↔ (a ↔ b) ∧ TFAE l :=
⟨λ H, ⟨H a (by simp) b (or.inr h), λ p hp q hq, H _ (or.inr hp) _ (or.inr hq)⟩,
 begin
   rintro ⟨ab, H⟩ p (rfl | hp) q (rfl | hq),
   { refl },
   { exact ab.trans (H _ h _ hq) },
   { exact (ab.trans (H _ h _ hp)).symm },
   { exact H _ hp _ hq }
 end⟩

theorem TFAE_cons_cons {a b} {l : list Prop} : TFAE (a::b::l) ↔ (a ↔ b) ∧ TFAE (b::l) :=
TFAE_cons_of_mem (or.inl rfl)

theorem TFAE_of_cycle {a b} {l : list Prop} :
  list.chain (→) a (b::l) → (last&#39; b l → a) → TFAE (a::b::l) :=
begin
  induction l with c l IH generalizing a b; simp [TFAE_cons_cons, TFAE_singleton] at *,
  { exact iff.intro },
  intros ab bc ch la,
  have := IH bc ch (ab ∘ la),
  exact ⟨⟨ab, la ∘ (this.2 c (or.inl rfl) _ (last&#39;_mem _ _)).1 ∘ bc⟩, this⟩
end

theorem TFAE.out {l} (h : TFAE l) (n₁ n₂)
 (h₁ : n₁ &lt; list.length l . tactic.exact_dec_trivial)
 (h₂ : n₂ &lt; list.length l . tactic.exact_dec_trivial) :
  list.nth_le l n₁ h₁ ↔ list.nth_le l n₂ h₂ :=
h _ (list.nth_le_mem _ _ _) _ (list.nth_le_mem _ _ _)

theorem TFAE_test (x y : ℕ) : TFAE [true, x = x, y = y] :=
TFAE_of_cycle (by simp) (λ _, trivial)

example (x y : ℕ) : x = x ↔ y = y := (TFAE_test x y).out 1 2

end list
</pre></div>

<a name="133814995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133814995" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133814995">Mario Carneiro (Sep 12 2018 at 19:49)</a>:</h4>
<p>There is a theorem that says that you can put a <code>list.chain</code> together over a transitive relation, but I had to prove the rest by induction anyway so it wasn't necessary</p>

<a name="133815251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133815251" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133815251">Johan Commelin (Sep 12 2018 at 19:53)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> I think the only thing that was wrong with it was that I didn't understand what you were doing...</p>

<a name="133815331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133815331" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133815331">Mario Carneiro (Sep 12 2018 at 19:54)</a>:</h4>
<p><code>list.chain</code> says that you have forward implications along the list, <code>last l -&gt; a</code> gives the final backward arrow</p>

<a name="133815344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133815344" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133815344">Mario Carneiro (Sep 12 2018 at 19:55)</a>:</h4>
<p>and they are both defined naturally by recursion making the proofs easy</p>

<a name="133815437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133815437" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133815437">Johan Commelin (Sep 12 2018 at 19:56)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Ok, so I was almost done with a slightly clunkier implementation. <span class="emoji emoji-1f606" title="lol">:lol:</span></p>

<a name="133815453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133815453" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133815453">Johan Commelin (Sep 12 2018 at 19:56)</a>:</h4>
<p>Would you mind pushing your stuff to a <code>tfae</code> branch on community?</p>

<a name="133815472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133815472" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133815472">Johan Commelin (Sep 12 2018 at 19:57)</a>:</h4>
<p>I think we should put everything into a <code>tfae</code> namespace.</p>

<a name="133815506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133815506" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133815506">Mario Carneiro (Sep 12 2018 at 19:58)</a>:</h4>
<p>I would just put it all in <code>list.basic</code></p>

<a name="133815535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133815535" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133815535">Mario Carneiro (Sep 12 2018 at 19:58)</a>:</h4>
<p>and in the <code>list</code> namespace, as you can see</p>

<a name="133815542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133815542" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133815542">Johan Commelin (Sep 12 2018 at 19:58)</a>:</h4>
<p>Ok, fine with me.</p>

<a name="133815556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133815556" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133815556">Johan Commelin (Sep 12 2018 at 19:58)</a>:</h4>
<p>Do you want to capitalise TFAE?</p>

<a name="133815569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133815569" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133815569">Mario Carneiro (Sep 12 2018 at 19:59)</a>:</h4>
<p>dunno, seemed nicer that way</p>

<a name="133815582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133815582" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133815582">Mario Carneiro (Sep 12 2018 at 19:59)</a>:</h4>
<p><code>tfae</code> could be misread?</p>

<a name="133815591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133815591" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133815591">Johan Commelin (Sep 12 2018 at 19:59)</a>:</h4>
<p>Maybe. <code>TFAE</code> feels like shouting.</p>

<a name="133815594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133815594" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133815594">Johan Commelin (Sep 12 2018 at 19:59)</a>:</h4>
<p>I wouldn't mind having <code>tfae</code>.</p>

<a name="133815600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133815600" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133815600">Mario Carneiro (Sep 12 2018 at 19:59)</a>:</h4>
<p>it's always the way I see it on the blackboard</p>

<a name="133815668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133815668" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133815668">Johan Commelin (Sep 12 2018 at 20:00)</a>:</h4>
<p>That is true. But on the blackboard I also see <code>Lemma</code> and <code>Thm</code>...</p>

<a name="133815706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133815706" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133815706">Mario Carneiro (Sep 12 2018 at 20:01)</a>:</h4>
<p>I would also not have any notation. for me <code>tfae [p, q, r]</code> is sufficient</p>

<a name="133815719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133815719" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133815719">Mario Carneiro (Sep 12 2018 at 20:01)</a>:</h4>
<p><code>[&lt;-&gt; p, q, r]</code> doesn't seem to buy much</p>

<a name="133815762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133815762" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133815762">Johan Commelin (Sep 12 2018 at 20:02)</a>:</h4>
<p>Right, I also came to that conclusion</p>

<a name="133815778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133815778" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133815778">Johan Commelin (Sep 12 2018 at 20:02)</a>:</h4>
<p>It is even easier to read.</p>

<a name="133815782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133815782" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133815782">Mario Carneiro (Sep 12 2018 at 20:02)</a>:</h4>
<p>(none of this is to cast aspersions on Cyril's work; the style and design decisions are different there)</p>

<a name="133815809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133815809" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133815809">Johan Commelin (Sep 12 2018 at 20:03)</a>:</h4>
<p>If you push your stuff, I would like to see if I can do anything with <code>tfae_of_graph</code>.</p>

<a name="133815842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133815842" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133815842">Johan Commelin (Sep 12 2018 at 20:03)</a>:</h4>
<p>Some how you need to show that the transitive closure of the relation that is your graph is everything. Would an <code>auto_param</code> be able to do that?</p>

<a name="133816149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816149" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133816149">Mario Carneiro (Sep 12 2018 at 20:09)</a>:</h4>
<p>you are talking about Cyril's extension? I wouldn't want to try that without using a tactic to guide the whole process</p>

<a name="133816223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816223" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133816223">Johan Commelin (Sep 12 2018 at 20:10)</a>:</h4>
<p>Why not?</p>

<a name="133816232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816232" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133816232">Mario Carneiro (Sep 12 2018 at 20:10)</a>:</h4>
<p>because the number of goals is very nonuniform</p>

<a name="133816246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816246" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133816246">Mario Carneiro (Sep 12 2018 at 20:10)</a>:</h4>
<p>the types are too complicated to get much help from lean</p>

<a name="133816275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816275" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133816275">Mario Carneiro (Sep 12 2018 at 20:11)</a>:</h4>
<p>again, this reflects a difference in design from Coq. It's easier to do strongly connected checking in the kernel in Coq</p>

<a name="133816318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816318" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133816318">Mario Carneiro (Sep 12 2018 at 20:12)</a>:</h4>
<p>in lean we would do it with a tactic</p>

<a name="133816459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816459" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133816459">Johan Commelin (Sep 12 2018 at 20:15)</a>:</h4>
<p>Pseudo-code:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">tfae_of_graph</span> <span class="o">(</span><span class="n">Ps</span> <span class="o">:</span> <span class="n">list</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="n">x</span> <span class="n">fin</span> <span class="n">n</span><span class="o">))</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">proof_that_G_generates_everything</span><span class="o">)</span>
<span class="o">(</span><span class="n">proofs</span> <span class="o">:</span> <span class="err">\</span><span class="k">forall</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">)</span> <span class="err">\</span><span class="k">in</span> <span class="n">G</span><span class="o">,</span> <span class="n">Ps</span> <span class="n">i</span> <span class="err">\</span><span class="n">implies</span> <span class="n">Ps</span> <span class="n">j</span><span class="o">)</span> <span class="o">:</span> <span class="n">tfae</span> <span class="n">Ps</span>
</pre></div>

<a name="133816476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816476" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133816476">Johan Commelin (Sep 12 2018 at 20:15)</a>:</h4>
<p>Ok, I agree that maybe the Lean way is to use tactics</p>

<a name="133816547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816547" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133816547">Mario Carneiro (Sep 12 2018 at 20:16)</a>:</h4>
<p>You would have to supply <code>proofs</code> manually which is not nice</p>

<a name="133816551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816551" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133816551">Johan Commelin (Sep 12 2018 at 20:16)</a>:</h4>
<p>I don't know anything about <code>auto_param</code>s but I would definitely want <code>H</code> to be automated by some tactic.</p>

<a name="133816571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816571" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133816571">Johan Commelin (Sep 12 2018 at 20:17)</a>:</h4>
<p>Right, so <code>proofs</code> better be a list of <code>mvar</code>s, is that what you mean?</p>

<a name="133816572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816572" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133816572">Patrick Massot (Sep 12 2018 at 20:17)</a>:</h4>
<p>this would not be interactive because of the proofs parameter</p>

<a name="133816600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816600" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133816600">Johan Commelin (Sep 12 2018 at 20:17)</a>:</h4>
<p>Well, if you <code>apply</code> it, you would then be left with a goal that asks for <code>proofs</code>.</p>

<a name="133816605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816605" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133816605">Mario Carneiro (Sep 12 2018 at 20:17)</a>:</h4>
<p>Here's a conjecture: Given any SC graph on 1...n, there is a way to connect 1-2, 2-3, ..., n-1 by disjoint paths in the graph</p>

<a name="133816612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816612" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133816612">Johan Commelin (Sep 12 2018 at 20:17)</a>:</h4>
<p>And you would want to split that into a bunch of goals.</p>

<a name="133816675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816675" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133816675">Johan Commelin (Sep 12 2018 at 20:18)</a>:</h4>
<p>What is SC?</p>

<a name="133816691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816691" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133816691">Mario Carneiro (Sep 12 2018 at 20:18)</a>:</h4>
<p>strongly connected</p>

<a name="133816707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816707" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133816707">Johan Commelin (Sep 12 2018 at 20:19)</a>:</h4>
<p>I see.</p>

<a name="133816728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816728" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133816728">Mario Carneiro (Sep 12 2018 at 20:19)</a>:</h4>
<p>if true, the generalization is always redundant</p>

<a name="133816808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816808" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133816808">Mario Carneiro (Sep 12 2018 at 20:20)</a>:</h4>
<p>if you supply 1&lt;-&gt;2 and 2&lt;-&gt;3 then you have four proofs, and you could have just composed the proofs 3-&gt;2 and 2-&gt;1 to get a result in the form for <code>tfae_of_cycle</code></p>

<a name="133816824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816824" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133816824">Johan Commelin (Sep 12 2018 at 20:20)</a>:</h4>
<p>Here is a graph: <code>1 -&gt; 3 -&gt; 2 -&gt; 1</code></p>

<a name="133816848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816848" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133816848">Mario Carneiro (Sep 12 2018 at 20:21)</a>:</h4>
<p>of course</p>

<a name="133816862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816862" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133816862">Johan Commelin (Sep 12 2018 at 20:21)</a>:</h4>
<p>Did I misunderstand your conjecture?</p>

<a name="133816867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816867" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133816867">Mario Carneiro (Sep 12 2018 at 20:21)</a>:</h4>
<p>so I guess we need a theorem about permuting the graph</p>

<a name="133816870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816870" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133816870">Mario Carneiro (Sep 12 2018 at 20:21)</a>:</h4>
<p>no, that's a counterexample</p>

<a name="133816918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816918" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133816918">Johan Commelin (Sep 12 2018 at 20:22)</a>:</h4>
<p>I'dd just do a <code>meta</code> dfs</p>

<a name="133834471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133834471" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133834471">Mario Carneiro (Sep 12 2018 at 20:22)</a>:</h4>
<p>new conjecture: there is a way to permute the vertices so that the first conjecture holds</p>

<a name="133834478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133834478" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133834478">Johan Commelin (Sep 12 2018 at 20:22)</a>:</h4>
<p>That is trivial</p>

<a name="133834483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133834483" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133834483">Mario Carneiro (Sep 12 2018 at 20:22)</a>:</h4>
<p>is it?</p>

<a name="133834484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133834484" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133834484">Johan Commelin (Sep 12 2018 at 20:22)</a>:</h4>
<p>Hmm, maybe not.</p>

<a name="133834580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133834580" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133834580">Johan Commelin (Sep 12 2018 at 20:24)</a>:</h4>
<p>But, why do you not want to reuse edges?</p>

<a name="133834619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133834619" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133834619">Mario Carneiro (Sep 12 2018 at 20:25)</a>:</h4>
<p>because that way you can achieve the same with a straight line proof where you inline the relevant parts in each subproof</p>

<a name="133834636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133834636" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133834636">Mario Carneiro (Sep 12 2018 at 20:25)</a>:</h4>
<p>i.e. the proof 3-&gt;2 only appears as part of the proof 3-&gt;1 in my example</p>

<a name="133834680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133834680" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133834680">Mario Carneiro (Sep 12 2018 at 20:26)</a>:</h4>
<p>so it doesn't need to be stored and reused</p>

<a name="133834686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133834686" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133834686">Johan Commelin (Sep 12 2018 at 20:26)</a>:</h4>
<p>Here is another graph: <code>1 -&gt; 2 -&gt; 3 -&gt; 1;   2 -&gt; 4 -&gt; 1;   2 -&gt; 5 -&gt; 1</code></p>

<a name="133834726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133834726" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133834726">Mario Carneiro (Sep 12 2018 at 20:27)</a>:</h4>
<p>foiled again</p>

<a name="133834833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133834833" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133834833">Johan Commelin (Sep 12 2018 at 20:29)</a>:</h4>
<p>Hmm, you don't even need vertex <code>5</code>.</p>

<a name="133834839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133834839" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133834839">Mario Carneiro (Sep 12 2018 at 20:29)</a>:</h4>
<p>okay so we definitely need a tactic to manage this kind of structure</p>

<a name="133834952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133834952" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133834952">Johan Commelin (Sep 12 2018 at 20:30)</a>:</h4>
<p>So the tactic takes a graph as input, and then proves that it is SC, and generates a list of goals, right?</p>

<a name="133834966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133834966" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133834966">Mario Carneiro (Sep 12 2018 at 20:31)</a>:</h4>
<p>yes</p>

<a name="133834999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133834999" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133834999">Reid Barton (Sep 12 2018 at 20:31)</a>:</h4>
<p>it might be worth considering the aforementioned <a href="https://stacks.math.columbia.edu/tag/04GG" target="_blank" title="https://stacks.math.columbia.edu/tag/04GG">https://stacks.math.columbia.edu/tag/04GG</a> when imagining what the UI might look like</p>

<a name="133835001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835001" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133835001">Patrick Massot (Sep 12 2018 at 20:31)</a>:</h4>
<p>Do we really want the tactic to decide on a list of implications to prove? Sometimes there will be several solutions, some easier than others</p>

<a name="133835061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835061" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133835061">Johan Commelin (Sep 12 2018 at 20:32)</a>:</h4>
<p>No, you provide a list of edges.</p>

<a name="133835070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835070" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133835070">Johan Commelin (Sep 12 2018 at 20:32)</a>:</h4>
<p>You get to prove those. And the tactic shows that this is enough.</p>

<a name="133835078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835078" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133835078">Patrick Massot (Sep 12 2018 at 20:32)</a>:</h4>
<p>ok, I prefer that</p>

<a name="133835080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835080" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133835080">Reid Barton (Sep 12 2018 at 20:32)</a>:</h4>
<p>for example, listing all the edges and then, separately, all the proofs might be less nice than being able to interleave them</p>

<a name="133835110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835110" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133835110">Mario Carneiro (Sep 12 2018 at 20:33)</a>:</h4>
<p>My suggestion: suppose the goal is <code>tfae [p1, p2, p3, p4, p5]</code>, then you can call <code>tfae [1 -&gt; 2, 2 -&gt; 3, 3 -&gt; 1, 2 -&gt; 4, 4 -&gt; 1, 1 &lt;-&gt; 5]</code> and get six goals like <code>|- p1 -&gt; p2</code> and <code>|- p1 &lt;-&gt; p5</code></p>

<a name="133835123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835123" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133835123">Johan Commelin (Sep 12 2018 at 20:33)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span>  Hmmm... but then it feels like you'll need a separate mode, like <code>conv</code> and <code>calc</code>.</p>

<a name="133835191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835191" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133835191">Mario Carneiro (Sep 12 2018 at 20:34)</a>:</h4>
<p>ooh, should it be zero-based indexing?</p>

<a name="133835197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835197" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133835197">Johan Commelin (Sep 12 2018 at 20:34)</a>:</h4>
<p>In principal that is fine, but in practice we see that <code>conv</code> is limited by the fact that not all tactics that we'dd like to be there actually work.</p>

<a name="133835221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835221" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133835221">Johan Commelin (Sep 12 2018 at 20:35)</a>:</h4>
<p>I guess <code>0</code>-based is easier to implement. But I don't know if it is user friendly.</p>

<a name="133835257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835257" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133835257">Mario Carneiro (Sep 12 2018 at 20:35)</a>:</h4>
<p>1 based is probably more user friendly, but I'm sure it will surprise someone either way</p>

<a name="133835270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835270" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133835270">Johan Commelin (Sep 12 2018 at 20:36)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Do you think Reid's idea can be implemented in usual tactic mode?</p>

<a name="133835323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835323" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133835323">Reid Barton (Sep 12 2018 at 20:36)</a>:</h4>
<p>maybe rather than a plain list in tfae we should use an association list indexed by<br>
<code>inductive roman_number | i | ii | iii | iv | ...</code></p>

<a name="133835342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835342" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133835342">Mario Carneiro (Sep 12 2018 at 20:36)</a>:</h4>
<p>and how long does that <code>...</code> go? :P</p>

<a name="133835351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835351" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133835351">Johan Commelin (Sep 12 2018 at 20:37)</a>:</h4>
<p>at least till <code>xiii</code></p>

<a name="133835362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835362" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133835362">Mario Carneiro (Sep 12 2018 at 20:37)</a>:</h4>
<p>anyway it's not an actual type, it's just an input format</p>

<a name="133835398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835398" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133835398">Mario Carneiro (Sep 12 2018 at 20:37)</a>:</h4>
<p><code>1 -&gt; 2</code> isn't well typed</p>

<a name="133835403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835403" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133835403">Reid Barton (Sep 12 2018 at 20:37)</a>:</h4>
<p>What I really mean though is if you actually had 13 things to prove equivalent, you wouldn't really want to have to count them whether you use 0-based or 1-based indexing</p>

<a name="133835410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835410" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133835410">Mario Carneiro (Sep 12 2018 at 20:37)</a>:</h4>
<p>neither is <code>i -&gt; ii</code></p>

<a name="133835478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835478" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133835478">Mario Carneiro (Sep 12 2018 at 20:38)</a>:</h4>
<p>I don't see an alternative</p>

<a name="133835493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835493" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133835493">Mario Carneiro (Sep 12 2018 at 20:38)</a>:</h4>
<p>lean can try to give you help in filling out the tactic arguments, but that's it</p>

<a name="133835504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835504" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133835504">Johan Commelin (Sep 12 2018 at 20:39)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> Do you have an idea for an "interleaving UI"?</p>

<a name="133835523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835523" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133835523">Johan Commelin (Sep 12 2018 at 20:39)</a>:</h4>
<p>syntax, I mean</p>

<a name="133835532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835532" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133835532">Johan Commelin (Sep 12 2018 at 20:39)</a>:</h4>
<p>What would you like to write?</p>

<a name="133835541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835541" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133835541">Mario Carneiro (Sep 12 2018 at 20:39)</a>:</h4>
<p>it sounds like what <code>case</code> does, but in that case you already know what the goals are</p>

<a name="133835603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835603" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133835603">Reid Barton (Sep 12 2018 at 20:40)</a>:</h4>
<p>something like <code>case</code> in terms of syntax, yeah</p>

<a name="133835610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835610" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133835610">Johan Commelin (Sep 12 2018 at 20:40)</a>:</h4>
<p><code>have : i -&gt; ii := bla</code></p>

<a name="133835657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835657" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133835657">Mario Carneiro (Sep 12 2018 at 20:41)</a>:</h4>
<p><code>tfae</code> could take an <code>itactic</code> argument, I'm not sure if the parsing will work but then you could have one huge tactic with subblocks like:</p>
<div class="codehilite"><pre><span></span>tfae:
1 -&gt; 2 {
  ...
}
2 -&gt; 1 {
  ...
},
</pre></div>

<a name="133835674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835674" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133835674">Johan Commelin (Sep 12 2018 at 20:41)</a>:</h4>
<p>And then, somehow Lean should keep track of them. And once you think you are done, you type <code>tfae_done</code>, and it checks that your graph is SC.</p>

<a name="133835723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835723" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133835723">Mario Carneiro (Sep 12 2018 at 20:42)</a>:</h4>
<p>in my example it's just one tactic invocation (note lack of comma)</p>

<a name="133835740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835740" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133835740">Johan Commelin (Sep 12 2018 at 20:42)</a>:</h4>
<p>I see. And inside the <code>{ ... }</code> you would be in regular tactic mode?</p>

<a name="133835743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835743" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133835743">Mario Carneiro (Sep 12 2018 at 20:42)</a>:</h4>
<p>yes</p>

<a name="133835752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835752" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133835752">Johan Commelin (Sep 12 2018 at 20:42)</a>:</h4>
<p>Then I think that syntax is really cool!</p>

<a name="133835762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835762" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133835762">Mario Carneiro (Sep 12 2018 at 20:43)</a>:</h4>
<p>I don't know if I can make it work though</p>

<a name="133835777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835777" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133835777">Mario Carneiro (Sep 12 2018 at 20:43)</a>:</h4>
<p><code>itactic</code> isn't a parser</p>

<a name="133835780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835780" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133835780">Johan Commelin (Sep 12 2018 at 20:43)</a>:</h4>
<p>I know that I can't</p>

<a name="133835811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835811" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133835811">Johan Commelin (Sep 12 2018 at 20:43)</a>:</h4>
<p>I think I would call the tactic <code>tfae_cases</code></p>

<a name="133835929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835929" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133835929">Mario Carneiro (Sep 12 2018 at 20:45)</a>:</h4>
<p>I would stick to my original proposal though, these syntaxes are crazy</p>

<a name="133835982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835982" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133835982">Mario Carneiro (Sep 12 2018 at 20:46)</a>:</h4>
<p>you can put the numbers in comments if you forgot which is which</p>

<a name="133835987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835987" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133835987">Johan Commelin (Sep 12 2018 at 20:46)</a>:</h4>
<p>Ok, too bad.</p>

<a name="133836020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836020" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133836020">Johan Commelin (Sep 12 2018 at 20:47)</a>:</h4>
<p>But, if you think it is really hard to do, then I won't even try thinking about it (-;</p>

<a name="133836027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836027" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133836027">Mario Carneiro (Sep 12 2018 at 20:47)</a>:</h4>
<p>also you could have <code>tfae?</code> which would just print out a numbered list of the elements of the <code>tfae</code> for referral</p>

<a name="133836058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836058" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133836058">Johan Commelin (Sep 12 2018 at 20:48)</a>:</h4>
<p>It should be a hole command (-;</p>

<a name="133836111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836111" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133836111">Johan Commelin (Sep 12 2018 at 20:48)</a>:</h4>
<p>And fill out those comments!</p>

<a name="133836117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836117" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133836117">Mario Carneiro (Sep 12 2018 at 20:48)</a>:</h4>
<p>I want more "implicit" hole commands (without the <code>{!!}</code> markers), but alas</p>

<a name="133836226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836226" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133836226">Johan Commelin (Sep 12 2018 at 20:50)</a>:</h4>
<p>Mario, could we have <code>have : tfae_case i ii := ...</code></p>

<a name="133836245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836245" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133836245">Johan Commelin (Sep 12 2018 at 20:50)</a>:</h4>
<p>and then a finishing tactic <code>tfae_done</code></p>

<a name="133836275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836275" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133836275">Reid Barton (Sep 12 2018 at 20:50)</a>:</h4>
<p>Oh, <code>have</code> is a better analogy. I would certainly be happy with <code>have_tfae 1 -&gt; 3, blah, have_tfae ..., ..., tfae_finish</code></p>

<a name="133836289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836289" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133836289">Mario Carneiro (Sep 12 2018 at 20:51)</a>:</h4>
<p>sorry, that's not well typed. The best you can do is <code>have : p1 -&gt; p2</code> and have <code>tfae_done</code> figure it out</p>

<a name="133836317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836317" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133836317">Johan Commelin (Sep 12 2018 at 20:51)</a>:</h4>
<p>But it's just notation, like before...</p>

<a name="133836325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836325" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133836325">Johan Commelin (Sep 12 2018 at 20:52)</a>:</h4>
<p>Ok, my example won't work.</p>

<a name="133836366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836366" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133836366">Johan Commelin (Sep 12 2018 at 20:52)</a>:</h4>
<p>But Reid's could, not?</p>

<a name="133836369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836369" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133836369">Reid Barton (Sep 12 2018 at 20:52)</a>:</h4>
<p>It would need to refer to the goal</p>

<a name="133836372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836372" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133836372">Reid Barton (Sep 12 2018 at 20:52)</a>:</h4>
<p>Yours I mean</p>

<a name="133836377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836377" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133836377">Mario Carneiro (Sep 12 2018 at 20:52)</a>:</h4>
<p>Actually <code>have_tfae 1 -&gt; 3</code> might make sense: if the goal is <code>tfae [p1, ..., p5]</code> then it is just the same as <code>have : p1 -&gt; p3</code></p>

<a name="133836402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836402" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133836402">Johan Commelin (Sep 12 2018 at 20:52)</a>:</h4>
<p>Exactly. (And can we make it <code>tfae_have</code>?)</p>

<a name="133836445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836445" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133836445">Reid Barton (Sep 12 2018 at 20:53)</a>:</h4>
<p>It should also support &lt;-&gt; btw</p>

<a name="133836448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836448" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133836448">Johan Commelin (Sep 12 2018 at 20:53)</a>:</h4>
<p>So the <code>tfae_have</code> should generate a new goal, and record an edge in some graph. And then <code>tfae_finish</code> checks that the graph is SC.</p>

<a name="133836450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836450" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133836450">Mario Carneiro (Sep 12 2018 at 20:54)</a>:</h4>
<p>naturally</p>

<a name="133836501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836501" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133836501">Johan Commelin (Sep 12 2018 at 20:54)</a>:</h4>
<p>I really like where this is going!</p>

<a name="133836507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836507" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133836507">Mario Carneiro (Sep 12 2018 at 20:54)</a>:</h4>
<p><code>tfae_have</code> doesn't need to do anything</p>

<a name="133836510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836510" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133836510">Reid Barton (Sep 12 2018 at 20:54)</a>:</h4>
<p><code>tfae_finish</code> could almost just be <code>solve_by_elim</code> it seems</p>

<a name="133836546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836546" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133836546">Johan Commelin (Sep 12 2018 at 20:55)</a>:</h4>
<p>A smart <code>tfae_finish</code> could suggest a list of edges that still needs to be done...</p>

<a name="133836571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836571" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133836571">Mario Carneiro (Sep 12 2018 at 20:55)</a>:</h4>
<p><code>tfae_finish</code> has to apply <code>tfae_of_cycle</code>, reduce the subproofs to implications of the given stuff, and then use the existing implications</p>

<a name="133836620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836620" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133836620">Mario Carneiro (Sep 12 2018 at 20:56)</a>:</h4>
<p>and produce any unproven parts as subgoals</p>

<a name="133836630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836630" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133836630">Mario Carneiro (Sep 12 2018 at 20:56)</a>:</h4>
<p>that way you can use <code>tfae</code> either forwards or backwards</p>

<a name="133836644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836644" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133836644">Johan Commelin (Sep 12 2018 at 20:57)</a>:</h4>
<p>What would those unproven parts look like?</p>

<a name="133836660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836660" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133836660">Johan Commelin (Sep 12 2018 at 20:57)</a>:</h4>
<p>Just unproven edges in the default cycle?</p>

<a name="133836666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836666" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133836666">Mario Carneiro (Sep 12 2018 at 20:57)</a>:</h4>
<p>yes</p>

<a name="133836684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836684" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133836684">Johan Commelin (Sep 12 2018 at 20:57)</a>:</h4>
<p>Ok, so by default <code>tfae_finish</code> generates <code>n</code> goals.</p>

<a name="133836737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836737" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133836737">Mario Carneiro (Sep 12 2018 at 20:58)</a>:</h4>
<p>(I would just call this one <code>tfae</code> btw)</p>

<a name="133836752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836752" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133836752">Johan Commelin (Sep 12 2018 at 20:58)</a>:</h4>
<p>If you want to use it both forwards and backward, that makes sense.</p>

<a name="133836773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836773" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133836773">Johan Commelin (Sep 12 2018 at 20:59)</a>:</h4>
<p>Semantically I don't like <code>tfae</code>, but short names are useful.</p>

<a name="133836787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836787" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133836787">Mario Carneiro (Sep 12 2018 at 20:59)</a>:</h4>
<p><code>tfae</code> can still take a list of edges, and it would just add to this the list of edges that have already been <code>have</code>'d</p>

<a name="133837161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133837161" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133837161">Johan Commelin (Sep 12 2018 at 21:04)</a>:</h4>
<p>Ok, once this tactic is there, we need to make sure <code>obviously</code> in fact tackles the first nine cases of the Hensel's lemma TFAE proof.</p>

<a name="133837469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133837469" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133837469">Reid Barton (Sep 12 2018 at 21:09)</a>:</h4>
<p>tpwe = the preceding were equivalent for the finisher</p>

<a name="133866415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133866415" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133866415">Cyril Cohen (Sep 13 2018 at 09:00)</a>:</h4>
<blockquote>
<p>you can put the numbers in comments if you forgot which is which</p>
</blockquote>
<p>That's what I do</p>

<a name="133872603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133872603" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133872603">Keeley Hoek (Sep 13 2018 at 11:33)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> is there a version of <code>chain</code> which lets me apply a function to each pair?</p>

<a name="133872777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133872777" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133872777">Scott Morrison (Sep 13 2018 at 11:36)</a>:</h4>
<p>What do you mean, <span class="user-mention" data-user-id="110111">@Keeley Hoek</span>?</p>

<a name="133873151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133873151" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133873151">Keeley Hoek (Sep 13 2018 at 11:44)</a>:</h4>
<p>id like to apply an <code>α → α → β</code> function to pairs of adjacent elements of a <code>list α</code>, and get a <code>list β</code>. It feels a bit like <code>chain</code> but not just for <code>Prop</code>s</p>

<a name="133898963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133898963" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133898963">Johan Commelin (Sep 13 2018 at 19:07)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Are you working on this tactic? Or do you think this could be a good exercise for me trying to learn how to write tactics?</p>

<a name="133899025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133899025" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133899025">Mario Carneiro (Sep 13 2018 at 19:08)</a>:</h4>
<p>I'm not working on it right now. If you would like to try your hand at it, go ahead</p>

<a name="133899046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133899046" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#133899046">Mario Carneiro (Sep 13 2018 at 19:08)</a>:</h4>
<p><span class="user-mention" data-user-id="110111">@Keeley Hoek</span> I would suggest defining an element of <code>α × β</code> using <code>list.foldl</code></p>

<a name="134684999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/134684999" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#134684999">Johan Commelin (Sep 26 2018 at 17:52)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> <span class="user-mention" data-user-id="110026">@Simon Hudon</span> and me have worked on this a bit. There is now a PR: <a href="https://github.com/leanprover/mathlib/pull/373" target="_blank" title="https://github.com/leanprover/mathlib/pull/373">https://github.com/leanprover/mathlib/pull/373</a></p>

<a name="135159468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/135159468" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#135159468">Johan Commelin (Oct 04 2018 at 10:33)</a>:</h4>
<p><span class="user-mention" data-user-id="110294">@Johannes Hölzl</span>  <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Is there anything blocking this PR? I've been hitting a couple of "the following are equivalent" lemmas recently, and I wouldn't mind using this machinery.</p>

<a name="135159627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/135159627" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#135159627">Johannes Hölzl (Oct 04 2018 at 10:37)</a>:</h4>
<p>Looks good for me. I'm fine with merging it.</p>

<a name="135159652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/135159652" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#135159652">Johannes Hölzl (Oct 04 2018 at 10:37)</a>:</h4>
<p>I don't know if Mario still has some concerns?</p>

<a name="135176877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/135176877" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#135176877">Mario Carneiro (Oct 04 2018 at 15:02)</a>:</h4>
<p>no, I have just been busy with school. Go ahead and merge it if you have looked it over.</p>

<a name="135178091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/135178091" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/86753TFAE.html#135178091">Johannes Hölzl (Oct 04 2018 at 15:08)</a>:</h4>
<p>okay I merged it</p>


{% endraw %}
