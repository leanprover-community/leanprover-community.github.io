---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/11403reflexivetransitiveclosureandrecursion.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/11403reflexivetransitiveclosureandrecursion.html">reflexive-transitive closure and recursion</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="127960102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reflexive-transitive%20closure%20and%20recursion/near/127960102" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11403reflexivetransitiveclosureandrecursion.html#127960102">Shachar Itzhaky (Jun 12 2018 at 15:47)</a>:</h4>
<p>Lean has a transitive closure but I want a reflexive-transitive one. So I wrote the following definition:</p>
<div class="codehilite"><pre><span></span><span class="kn">variable</span> <span class="o">{</span><span class="n">D</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span>
<span class="kn">variable</span> <span class="n">R</span> <span class="o">:</span> <span class="n">D</span> <span class="bp">-&gt;</span> <span class="n">D</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span>

<span class="kn">inductive</span> <span class="n">rtc</span> <span class="o">:</span> <span class="n">D</span> <span class="bp">-&gt;</span> <span class="n">D</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">refl</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">s</span><span class="o">,</span> <span class="n">rtc</span> <span class="n">s</span> <span class="n">s</span>
<span class="bp">|</span> <span class="n">step</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">s</span> <span class="n">u</span> <span class="n">t</span><span class="o">),</span> <span class="n">R</span> <span class="n">s</span> <span class="n">u</span> <span class="bp">→</span> <span class="n">rtc</span> <span class="n">u</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">rtc</span> <span class="n">s</span> <span class="n">t</span>
</pre></div>


<p>I was happy that without knowing much Lean upfront, I was able to prove a simple theorem.</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">rtc_trans</span> <span class="o">:</span> <span class="k">forall</span> <span class="o">(</span><span class="n">s</span> <span class="n">u</span> <span class="n">t</span> <span class="o">:</span> <span class="n">D</span><span class="o">),</span> <span class="n">rtc</span> <span class="n">R</span> <span class="n">s</span> <span class="n">u</span> <span class="bp">-&gt;</span> <span class="n">rtc</span> <span class="n">R</span> <span class="n">u</span> <span class="n">t</span> <span class="bp">-&gt;</span> <span class="n">rtc</span> <span class="n">R</span> <span class="n">s</span> <span class="n">t</span> <span class="o">:=</span>
  <span class="k">begin</span>
    <span class="n">intros</span> <span class="n">s</span> <span class="n">u</span> <span class="n">t</span> <span class="n">H1</span> <span class="n">H2</span><span class="o">,</span> <span class="n">induction</span> <span class="n">H1</span><span class="o">,</span> <span class="o">{</span> <span class="n">exact</span> <span class="n">H2</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">apply</span> <span class="n">rtc</span><span class="bp">.</span><span class="n">step</span><span class="o">,</span> <span class="n">apply</span> <span class="n">H1_a</span><span class="o">,</span> <span class="n">apply</span> <span class="n">H1_ih</span><span class="o">,</span> <span class="n">apply</span> <span class="n">H2</span> <span class="o">}</span>
  <span class="kn">end</span>
</pre></div>


<p>The proof utilizes <code>rtc.drec</code>. Which is fine. But it would be very illustrative to carry out the same proof via a recursive definition. This, however, requires a <code>match</code>, and I was not able to destructure <code>rtc R s t</code> in any way:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">hmm</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">D</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">rtc</span> <span class="n">R</span> <span class="n">s</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">H</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">rtc</span><span class="bp">.</span><span class="n">refl</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">true</span><span class="bp">.</span><span class="n">intro</span>
  <span class="bp">|</span> <span class="n">rtc</span><span class="bp">.</span><span class="n">step</span> <span class="n">R</span> <span class="n">u</span> <span class="bp">_</span> <span class="n">su</span> <span class="n">ut</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">true</span><span class="bp">.</span><span class="n">intro</span>
</pre></div>


<p>This fails to typecheck because <code>rtc.refl _ _</code> gets the type <code>rtc R _x _x</code>, which does not unify with <code>rtc R s t</code>. While the error message sounds reasonable, it sounds weird that there is an inductive type that cannot be <code>match</code>ed on. Is there any way around that?</p>

<a name="127960356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reflexive-transitive%20closure%20and%20recursion/near/127960356" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11403reflexivetransitiveclosureandrecursion.html#127960356">Kenny Lau (Jun 12 2018 at 15:52)</a>:</h4>
<p>put the hypothesis after the colon and use the equation compiler instead of <code>match</code></p>

<a name="127960364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reflexive-transitive%20closure%20and%20recursion/near/127960364" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11403reflexivetransitiveclosureandrecursion.html#127960364">Kenny Lau (Jun 12 2018 at 15:52)</a>:</h4>
<p>put everything after the colon</p>

<a name="127960374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reflexive-transitive%20closure%20and%20recursion/near/127960374" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11403reflexivetransitiveclosureandrecursion.html#127960374">Johannes Hölzl (Jun 12 2018 at 15:53)</a>:</h4>
<p>In mahlib we have the reflexive transitive closure: <a href="https://github.com/leanprover/mathlib/blob/master/logic/relation.lean#L61" target="_blank" title="https://github.com/leanprover/mathlib/blob/master/logic/relation.lean#L61">https://github.com/leanprover/mathlib/blob/master/logic/relation.lean#L61</a></p>

<a name="127960479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reflexive-transitive%20closure%20and%20recursion/near/127960479" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11403reflexivetransitiveclosureandrecursion.html#127960479">Johannes Hölzl (Jun 12 2018 at 15:55)</a>:</h4>
<p><code>match</code> can do cases on <code>rtc</code> but you need to give it the allowance, e.g. one of <code>s</code> and <code>t</code> in <code>rtc s t</code> should be a variable, and you need to pass this variable into <code>match</code> so that it can change it, a.l.a <code>match s, h : rtc s t where _, rtc.refl _ := ... end</code></p>

<a name="127977723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reflexive-transitive%20closure%20and%20recursion/near/127977723" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11403reflexivetransitiveclosureandrecursion.html#127977723">Shachar Itzhaky (Jun 12 2018 at 22:23)</a>:</h4>
<p>Thanks... I know nothing about the equation compiler and I am still struggling with dependent match but at least fixing one side of the rtc to a variable makes sense to me. I am trying to encode a system that has both unfolding rules --- one that unfolds the first step of the path, and one that unfolds the last step. I will probably define those as two inductive Props and prove their equivalence.</p>
<p>What is the meaning of the <code>refl</code> constructor having an empty implicit parameter list <code>{}</code>?</p>

<a name="127977878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reflexive-transitive%20closure%20and%20recursion/near/127977878" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11403reflexivetransitiveclosureandrecursion.html#127977878">Andrew Ashworth (Jun 12 2018 at 22:27)</a>:</h4>
<p>it is an instruction to lean to infer the implicit argument from the return type</p>

<a name="127977884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reflexive-transitive%20closure%20and%20recursion/near/127977884" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11403reflexivetransitiveclosureandrecursion.html#127977884">Andrew Ashworth (Jun 12 2018 at 22:27)</a>:</h4>
<p>consider </p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">sum</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">inl</span> <span class="o">{}</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">sum</span>
<span class="bp">|</span> <span class="n">inr</span> <span class="o">{}</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">sum</span>
</pre></div>

<a name="127977895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reflexive-transitive%20closure%20and%20recursion/near/127977895" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11403reflexivetransitiveclosureandrecursion.html#127977895">Andrew Ashworth (Jun 12 2018 at 22:27)</a>:</h4>
<p>here the empty implicit parameter list is an annotation to infer the type alpha in <code>inl</code> and beta in <code>inr</code></p>

<a name="127978043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reflexive-transitive%20closure%20and%20recursion/near/127978043" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11403reflexivetransitiveclosureandrecursion.html#127978043">Andrew Ashworth (Jun 12 2018 at 22:31)</a>:</h4>
<p>hrm, maybe not the greatest example since the definition goes through without the brackets anyway...</p>

<a name="127978175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reflexive-transitive%20closure%20and%20recursion/near/127978175" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11403reflexivetransitiveclosureandrecursion.html#127978175">Andrew Ashworth (Jun 12 2018 at 22:35)</a>:</h4>
<p>ok, if you paste this</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">sum&#39;</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">inl</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">sum&#39;</span>
<span class="bp">|</span> <span class="n">inr</span> <span class="o">{}</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">sum&#39;</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">sum&#39;</span>
</pre></div>

<a name="127978178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reflexive-transitive%20closure%20and%20recursion/near/127978178" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11403reflexivetransitiveclosureandrecursion.html#127978178">Andrew Ashworth (Jun 12 2018 at 22:35)</a>:</h4>
<p>then you'll see a difference in how lean evaluates the expression</p>

<a name="127978234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reflexive-transitive%20closure%20and%20recursion/near/127978234" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11403reflexivetransitiveclosureandrecursion.html#127978234">Shachar Itzhaky (Jun 12 2018 at 22:36)</a>:</h4>
<p>Ok, so in fact the <code>{}</code> is for <em>beta</em>  in <code>inl</code> (since alpha is already there).</p>

<a name="127978248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reflexive-transitive%20closure%20and%20recursion/near/127978248" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11403reflexivetransitiveclosureandrecursion.html#127978248">Andrew Ashworth (Jun 12 2018 at 22:37)</a>:</h4>
<p>oops, haha</p>

<a name="127978250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reflexive-transitive%20closure%20and%20recursion/near/127978250" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11403reflexivetransitiveclosureandrecursion.html#127978250">Andrew Ashworth (Jun 12 2018 at 22:37)</a>:</h4>
<p>yes</p>

<a name="127978257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reflexive-transitive%20closure%20and%20recursion/near/127978257" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11403reflexivetransitiveclosureandrecursion.html#127978257">Shachar Itzhaky (Jun 12 2018 at 22:37)</a>:</h4>
<p>How does Lean know that alpha has to be implicit, in inl without the <code>{}</code>?</p>

<a name="127978303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reflexive-transitive%20closure%20and%20recursion/near/127978303" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11403reflexivetransitiveclosureandrecursion.html#127978303">Shachar Itzhaky (Jun 12 2018 at 22:38)</a>:</h4>
<p>Oh silly me, of course the first parameter is of type alpha.</p>

<a name="127978461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reflexive-transitive%20closure%20and%20recursion/near/127978461" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11403reflexivetransitiveclosureandrecursion.html#127978461">Shachar Itzhaky (Jun 12 2018 at 22:43)</a>:</h4>
<p>Ok, this was immaterial to the discussion of matches, back to struggling with <code>match s, h : rtc R s t</code> then. Can anyone explain that cryptic line above?</p>

<a name="127978796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reflexive-transitive%20closure%20and%20recursion/near/127978796" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11403reflexivetransitiveclosureandrecursion.html#127978796">Shachar Itzhaky (Jun 12 2018 at 22:53)</a>:</h4>
<p>I didn't manage to put the type annotation <code>H : rtc R s t</code> but the match seemed to work even without it, by virtue of having <code>s</code> available to the equation compiler perhaps?</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">hmm</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">D</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">rtc</span> <span class="n">R</span> <span class="n">s</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">s</span><span class="o">,</span> <span class="n">H</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rtc</span><span class="bp">.</span><span class="n">refl</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">h</span><span class="o">,</span> <span class="n">trivial</span>
  <span class="bp">|</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rtc</span><span class="bp">.</span><span class="n">step</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">h</span><span class="o">,</span> <span class="n">trivial</span>
</pre></div>


<p>I am a bit perplexed still by the fact that the match branches have type <code>?? -&gt; true</code> rather than just <code>true</code>...</p>

<a name="127979054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reflexive-transitive%20closure%20and%20recursion/near/127979054" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11403reflexivetransitiveclosureandrecursion.html#127979054">Andrew Ashworth (Jun 12 2018 at 22:59)</a>:</h4>
<p>if you had to write out the definition by hand using <code>rtc.drec_on</code> or <code>rtc.rec_on</code>, how would you avoid the first argument? (match uses those under the hood iirc, but somebody correct me if I'm mistaken)</p>

<a name="127979117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reflexive-transitive%20closure%20and%20recursion/near/127979117" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11403reflexivetransitiveclosureandrecursion.html#127979117">Andrew Ashworth (Jun 12 2018 at 23:00)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">hmm&#39;</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">D</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">rtc</span> <span class="n">R</span> <span class="n">s</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span>
<span class="n">rtc</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">H</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">true</span><span class="bp">.</span><span class="n">intro</span><span class="o">)</span>
  <span class="o">(</span><span class="k">by</span> <span class="n">intros</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">true</span><span class="bp">.</span><span class="n">intro</span><span class="o">)</span>
</pre></div>

<a name="127979287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reflexive-transitive%20closure%20and%20recursion/near/127979287" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11403reflexivetransitiveclosureandrecursion.html#127979287">Shachar Itzhaky (Jun 12 2018 at 23:05)</a>:</h4>
<p>Yes, it looks like it does — it just clashes somehow with my understanding of Type Theory and CIC (where there is a <code>fix</code> construct).</p>

<a name="127979411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reflexive-transitive%20closure%20and%20recursion/near/127979411" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11403reflexivetransitiveclosureandrecursion.html#127979411">Shachar Itzhaky (Jun 12 2018 at 23:09)</a>:</h4>
<p>BTW the compiler seems to make quite a monster out of my small match:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">ReflexiveTransitiveClosure</span><span class="bp">.</span><span class="n">hmm</span><span class="bp">._</span><span class="n">match_1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">D</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="n">D</span> <span class="bp">→</span> <span class="n">D</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="bp">_</span><span class="n">a</span> <span class="o">:</span> <span class="n">D</span><span class="o">),</span> <span class="n">rtc</span> <span class="n">R</span> <span class="bp">_</span><span class="n">a</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">true</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="o">{</span><span class="n">D</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="n">D</span> <span class="bp">→</span> <span class="n">D</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="bp">_</span><span class="n">a</span> <span class="o">:</span> <span class="n">D</span><span class="o">)</span> <span class="o">(</span><span class="bp">_</span><span class="n">a_1</span> <span class="o">:</span> <span class="n">rtc</span> <span class="n">R</span> <span class="bp">_</span><span class="n">a</span> <span class="n">t</span><span class="o">),</span>
  <span class="n">rtc</span><span class="bp">.</span><span class="n">dcases_on</span> <span class="bp">_</span><span class="n">a_1</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">H_1</span> <span class="o">:</span> <span class="n">t</span> <span class="bp">=</span> <span class="bp">_</span><span class="n">a</span><span class="o">),</span> <span class="n">eq</span><span class="bp">.</span><span class="n">rec</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="bp">_</span><span class="n">a</span> <span class="o">:</span> <span class="n">rtc</span> <span class="n">R</span> <span class="n">t</span> <span class="n">t</span><span class="o">)</span> <span class="o">(</span><span class="n">H_2</span> <span class="o">:</span> <span class="bp">_</span><span class="n">a</span> <span class="bp">==</span> <span class="n">rtc</span><span class="bp">.</span><span class="n">refl</span><span class="o">),</span> <span class="n">id_rhs</span> <span class="n">true</span> <span class="n">trivial</span><span class="o">)</span> <span class="n">H_1</span> <span class="bp">_</span><span class="n">a_1</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">D</span><span class="o">)</span> <span class="o">{</span><span class="n">t_2</span> <span class="o">:</span> <span class="n">D</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">rtc</span> <span class="n">R</span> <span class="bp">_</span><span class="n">a</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">a_1</span> <span class="o">:</span> <span class="n">R</span> <span class="n">u</span> <span class="n">t_2</span><span class="o">)</span> <span class="o">(</span><span class="n">H_1</span> <span class="o">:</span> <span class="n">t</span> <span class="bp">=</span> <span class="n">t_2</span><span class="o">),</span>
       <span class="n">eq</span><span class="bp">.</span><span class="n">rec</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a_1</span> <span class="o">:</span> <span class="n">R</span> <span class="n">u</span> <span class="n">t</span><span class="o">)</span> <span class="o">(</span><span class="n">H_2</span> <span class="o">:</span> <span class="bp">_</span><span class="n">a_1</span> <span class="bp">==</span> <span class="n">rtc</span><span class="bp">.</span><span class="n">step</span> <span class="n">u</span> <span class="n">a</span> <span class="n">a_1</span><span class="o">),</span> <span class="n">id_rhs</span> <span class="n">true</span> <span class="n">trivial</span><span class="o">)</span> <span class="n">H_1</span> <span class="n">a_1</span><span class="o">)</span>
    <span class="o">(</span><span class="n">eq</span><span class="bp">.</span><span class="n">refl</span> <span class="n">t</span><span class="o">)</span>
    <span class="o">(</span><span class="n">heq</span><span class="bp">.</span><span class="n">refl</span> <span class="bp">_</span><span class="n">a_1</span><span class="o">)</span>
</pre></div>

<a name="127979551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reflexive-transitive%20closure%20and%20recursion/near/127979551" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11403reflexivetransitiveclosureandrecursion.html#127979551">Andrew Ashworth (Jun 12 2018 at 23:13)</a>:</h4>
<p>i don't know if this is any prettier to you </p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">hmm&#39;</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">D</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">rtc</span> <span class="n">R</span> <span class="n">s</span> <span class="n">t</span><span class="o">),</span> <span class="n">true</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="n">rtc</span><span class="bp">.</span><span class="n">refl</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">)</span> <span class="o">:=</span> <span class="n">true</span><span class="bp">.</span><span class="n">intro</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="n">rtc</span><span class="bp">.</span><span class="n">step</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="o">:=</span> <span class="n">true</span><span class="bp">.</span><span class="n">intro</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">hmm&#39;</span><span class="bp">._</span><span class="n">main</span>
</pre></div>

<a name="127979666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reflexive-transitive%20closure%20and%20recursion/near/127979666" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11403reflexivetransitiveclosureandrecursion.html#127979666">Andrew Ashworth (Jun 12 2018 at 23:16)</a>:</h4>
<p>when I want a definition that unfolds nicely I tend to write it out by hand using the appropriate recursion lemma. If you use the equation compiler as I did above, the main def is somewhat ugly but it generates quite nice ._eqn1, ._eqn2 branches</p>

<a name="127995826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reflexive-transitive%20closure%20and%20recursion/near/127995826" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11403reflexivetransitiveclosureandrecursion.html#127995826">Shachar Itzhaky (Jun 13 2018 at 08:04)</a>:</h4>
<p>Yes, I ended up doing that myself, eventually. I found <code>hmm'._main</code> but what are <code>._eqn1</code>, <code>._eqn2</code>?</p>
<p>At any rate, the purpose of this mental exercise was to demonstrate that explicit induction and "normal" recursion coincide, so of course I could write it with <code>rec_on</code> but that would miss the point...</p>

<a name="127996308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reflexive-transitive%20closure%20and%20recursion/near/127996308" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11403reflexivetransitiveclosureandrecursion.html#127996308">Kevin Buzzard (Jun 13 2018 at 08:20)</a>:</h4>
<p>You can try <code>#print prefix hmm'</code> to see everything starting <code>hmm'.</code></p>

<a name="127996316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reflexive-transitive%20closure%20and%20recursion/near/127996316" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11403reflexivetransitiveclosureandrecursion.html#127996316">Kevin Buzzard (Jun 13 2018 at 08:20)</a>:</h4>
<p>although in the back of my mind I think there might be an easier way of just seeing the equation lemmas...</p>

<a name="128002149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reflexive-transitive%20closure%20and%20recursion/near/128002149" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11403reflexivetransitiveclosureandrecursion.html#128002149">Shachar Itzhaky (Jun 13 2018 at 10:52)</a>:</h4>
<p>I somehow get <code>no declaration starting with prefix 'hmm''</code>.</p>

<a name="128002289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reflexive-transitive%20closure%20and%20recursion/near/128002289" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11403reflexivetransitiveclosureandrecursion.html#128002289">Mario Carneiro (Jun 13 2018 at 10:56)</a>:</h4>
<p>In lean, type ascriptions have required parentheses, it should be <code>(H : rtc R s t)</code> not <code>H : rtc R s t</code></p>

<a name="128002346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reflexive-transitive%20closure%20and%20recursion/near/128002346" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11403reflexivetransitiveclosureandrecursion.html#128002346">Shachar Itzhaky (Jun 13 2018 at 10:58)</a>:</h4>
<p>I was convinced I tried that when the original suggestion didn't work... but yeah, parenthesis do the trick! Although, as I said, the definition goes through without the ascription as well.</p>

<a name="128002348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reflexive-transitive%20closure%20and%20recursion/near/128002348" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11403reflexivetransitiveclosureandrecursion.html#128002348">Mario Carneiro (Jun 13 2018 at 10:58)</a>:</h4>
<p>Lean is a bit limited in its ability to do induction on inductive predicates using the equation compiler. I recommend using the <code>induction</code> tactic instead if you have any problems with writing it the way Andrew suggested</p>

<a name="128002364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reflexive-transitive%20closure%20and%20recursion/near/128002364" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11403reflexivetransitiveclosureandrecursion.html#128002364">Shachar Itzhaky (Jun 13 2018 at 10:59)</a>:</h4>
<p>Yes, I will reiterate: using tactic mode as well as <code>rec_on</code> were pretty smooth. The reason I am in this discussion is that I wanted to demonstrate to my students how induction is just a form of recursion that they know from programming.</p>

<a name="128002429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reflexive-transitive%20closure%20and%20recursion/near/128002429" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11403reflexivetransitiveclosureandrecursion.html#128002429">Mario Carneiro (Jun 13 2018 at 11:00)</a>:</h4>
<p>I usually point at the type of rec_on, remark that it looks a lot like induction, and then use it to define a recursive function and also prove some property about it</p>

<a name="128002441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reflexive-transitive%20closure%20and%20recursion/near/128002441" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11403reflexivetransitiveclosureandrecursion.html#128002441">Shachar Itzhaky (Jun 13 2018 at 11:01)</a>:</h4>
<p><span class="emoji emoji-1f44d" title="thumbs up">:thumbs_up:</span> I assume this is "the Lean way" then.</p>

<a name="128002498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reflexive-transitive%20closure%20and%20recursion/near/128002498" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11403reflexivetransitiveclosureandrecursion.html#128002498">Mario Carneiro (Jun 13 2018 at 11:03)</a>:</h4>
<p>In the case of an inductive predicate like <code>rtc</code>, it actually can't be used for recursion, since it has small elimination</p>

<a name="128002499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reflexive-transitive%20closure%20and%20recursion/near/128002499" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11403reflexivetransitiveclosureandrecursion.html#128002499">Mario Carneiro (Jun 13 2018 at 11:03)</a>:</h4>
<p>it can only be used to prove props</p>

<a name="128002543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reflexive-transitive%20closure%20and%20recursion/near/128002543" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11403reflexivetransitiveclosureandrecursion.html#128002543">Mario Carneiro (Jun 13 2018 at 11:04)</a>:</h4>
<p>If you put the inductive type in <code>Type</code> though it could</p>

<a name="128002564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reflexive-transitive%20closure%20and%20recursion/near/128002564" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11403reflexivetransitiveclosureandrecursion.html#128002564">Shachar Itzhaky (Jun 13 2018 at 11:05)</a>:</h4>
<p>Of course. The analogue that I can refer to is that in Coq I wrote the same proof, once with <code>induction</code>, and once with <code>Fixpoint</code> -- of course, since you destructure the <code>Prop</code> inside the def, the function must return a <code>Prop</code>.</p>

<a name="128002573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reflexive-transitive%20closure%20and%20recursion/near/128002573" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11403reflexivetransitiveclosureandrecursion.html#128002573">Shachar Itzhaky (Jun 13 2018 at 11:05)</a>:</h4>
<p>I still see that as a form of recursion though, since it's expressed via <code>Fixpoint</code>.</p>


{% endraw %}

{% include archive_update.html %}