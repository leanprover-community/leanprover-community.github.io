---
layout: archive
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/22256coolpaperonreification.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/22256coolpaperonreification.html">cool paper on reification</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="127486086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cool%20paper%20on%20reification/near/127486086" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22256coolpaperonreification.html#127486086">Andrew Ashworth (Jun 03 2018 at 02:15)</a>:</h4>
<p>just in case anybody else is interested in proofs by reflection: <a href="https://people.csail.mit.edu/jgross/personal-website/papers/2018-reification-by-parametricity-itp-draft.pdf" target="_blank" title="https://people.csail.mit.edu/jgross/personal-website/papers/2018-reification-by-parametricity-itp-draft.pdf">https://people.csail.mit.edu/jgross/personal-website/papers/2018-reification-by-parametricity-itp-draft.pdf</a></p>

<a name="127486131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cool%20paper%20on%20reification/near/127486131" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22256coolpaperonreification.html#127486131">Andrew Ashworth (Jun 03 2018 at 02:17)</a>:</h4>
<p>it's my favorite topic right now since i'm trying to teach myself how to write reflective tactics in lean</p>

<a name="127486177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cool%20paper%20on%20reification/near/127486177" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22256coolpaperonreification.html#127486177">Andrew Ashworth (Jun 03 2018 at 02:18)</a>:</h4>
<p>i wish i was in oxford so i could attend the workshops at ITP :|</p>

<a name="127486552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cool%20paper%20on%20reification/near/127486552" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22256coolpaperonreification.html#127486552">Andrew Ashworth (Jun 03 2018 at 02:32)</a>:</h4>
<p>does lean have a <code>vm_compute</code> equivalent?</p>

<a name="127486600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cool%20paper%20on%20reification/near/127486600" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22256coolpaperonreification.html#127486600">Mario Carneiro (Jun 03 2018 at 02:34)</a>:</h4>
<p>No. <span class="user-mention" data-user-id="110865">@Jeremy Avigad</span> This paper relates to our discussion about proof by <code>#eval</code></p>

<a name="127486602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cool%20paper%20on%20reification/near/127486602" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22256coolpaperonreification.html#127486602">Simon Hudon (Jun 03 2018 at 02:34)</a>:</h4>
<p>I had a conversation with <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> a while back on proofs by reflection. He was pointing out to me that they are not as beneficial in Lean as they are in Coq because of some details of computation in the kernel</p>

<a name="127486604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cool%20paper%20on%20reification/near/127486604" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22256coolpaperonreification.html#127486604">Simon Hudon (Jun 03 2018 at 02:34)</a>:</h4>
<p>I don't remember which detail that was</p>

<a name="127486617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cool%20paper%20on%20reification/near/127486617" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22256coolpaperonreification.html#127486617">Mario Carneiro (Jun 03 2018 at 02:35)</a>:</h4>
<p>It's possible to do proof by reflection using the <em>kernel</em> for computation, but it's not very fast</p>

<a name="127486658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cool%20paper%20on%20reification/near/127486658" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22256coolpaperonreification.html#127486658">Mario Carneiro (Jun 03 2018 at 02:36)</a>:</h4>
<p>doing proof by reflection using the VM is not supported (directly)</p>

<a name="127486661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cool%20paper%20on%20reification/near/127486661" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22256coolpaperonreification.html#127486661">Mario Carneiro (Jun 03 2018 at 02:36)</a>:</h4>
<p>but you can use tactics, computing in the VM, to craft appropriate theorems as certificates for the kernel</p>

<a name="127486668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cool%20paper%20on%20reification/near/127486668" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22256coolpaperonreification.html#127486668">Andrew Ashworth (Jun 03 2018 at 02:37)</a>:</h4>
<p>is there an example of that in lean? I think the idea of verified decision procedures is very appealing theoretically</p>

<a name="127486669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cool%20paper%20on%20reification/near/127486669" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22256coolpaperonreification.html#127486669">Mario Carneiro (Jun 03 2018 at 02:37)</a>:</h4>
<p><code>norm_num</code> and <code>ring</code> use this latter strategy</p>

<a name="127486708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cool%20paper%20on%20reification/near/127486708" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22256coolpaperonreification.html#127486708">Mario Carneiro (Jun 03 2018 at 02:38)</a>:</h4>
<p><code>cooper</code> uses kernel reflection, and <code>vm_cooper</code> uses "tactic reflection"</p>

<a name="127486709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cool%20paper%20on%20reification/near/127486709" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22256coolpaperonreification.html#127486709">Andrew Ashworth (Jun 03 2018 at 02:38)</a>:</h4>
<p>and in lean 4, i think we will be able to extract tactics and use them?</p>

<a name="127486711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cool%20paper%20on%20reification/near/127486711" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22256coolpaperonreification.html#127486711">Mario Carneiro (Jun 03 2018 at 02:38)</a>:</h4>
<p>sure, that's one thing compilation should allow</p>

<a name="127486712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cool%20paper%20on%20reification/near/127486712" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22256coolpaperonreification.html#127486712">Andrew Ashworth (Jun 03 2018 at 02:38)</a>:</h4>
<p>not tactics, i mean regular function defs</p>

<a name="127486718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cool%20paper%20on%20reification/near/127486718" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22256coolpaperonreification.html#127486718">Andrew Ashworth (Jun 03 2018 at 02:39)</a>:</h4>
<p>so we could extract the <code>check_is_even</code> program as described in the paper and have it run in C++</p>

<a name="127486719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cool%20paper%20on%20reification/near/127486719" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22256coolpaperonreification.html#127486719">Mario Carneiro (Jun 03 2018 at 02:39)</a>:</h4>
<p>You can <code>#eval check_is_even</code> currently</p>

<a name="127486756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cool%20paper%20on%20reification/near/127486756" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22256coolpaperonreification.html#127486756">Mario Carneiro (Jun 03 2018 at 02:40)</a>:</h4>
<p>to run in the VM</p>

<a name="127486764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cool%20paper%20on%20reification/near/127486764" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22256coolpaperonreification.html#127486764">Mario Carneiro (Jun 03 2018 at 02:40)</a>:</h4>
<p>or you can <code>#reduce check_is_even</code> to run in the kernel</p>

<a name="127487123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cool%20paper%20on%20reification/near/127487123" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22256coolpaperonreification.html#127487123">Andrew Ashworth (Jun 03 2018 at 02:55)</a>:</h4>
<p>but, in a sense, we can't reason about vm evaluation, it's outside lean, is my current understanding</p>

<a name="127487175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cool%20paper%20on%20reification/near/127487175" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22256coolpaperonreification.html#127487175">Andrew Ashworth (Jun 03 2018 at 02:57)</a>:</h4>
<p>if there was a <code>#eval that produced exprs</code> we could though</p>

<a name="127487290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cool%20paper%20on%20reification/near/127487290" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22256coolpaperonreification.html#127487290">Mario Carneiro (Jun 03 2018 at 03:01)</a>:</h4>
<p>no but we can trust the results</p>

<a name="127487328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cool%20paper%20on%20reification/near/127487328" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22256coolpaperonreification.html#127487328">Mario Carneiro (Jun 03 2018 at 03:02)</a>:</h4>
<p>like if we evaluate a <code>bool</code> expr and get <code>tt</code> we believe the same should hold true of reduce</p>

<a name="127487339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cool%20paper%20on%20reification/near/127487339" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22256coolpaperonreification.html#127487339">Mario Carneiro (Jun 03 2018 at 03:02)</a>:</h4>
<p>The reasoning would go into the definition of the function being evaluated itself</p>

<a name="127487721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cool%20paper%20on%20reification/near/127487721" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22256coolpaperonreification.html#127487721">Andrew Ashworth (Jun 03 2018 at 03:16)</a>:</h4>
<p>reasoning would go into the definition? do you have a concrete example? I don't quite follow. As I understand it the kernel is quite strict. If we use nat, it will reduce everything strictly using the zero / succ nat representation. However, vm evaluation might use a bignum library for speed. How can we say their behavior is equivalent?<br>
(maybe I should just be reading more about reflection / I don't understand how Lean uses GMP)</p>

<a name="127487986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cool%20paper%20on%20reification/near/127487986" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22256coolpaperonreification.html#127487986">Mario Carneiro (Jun 03 2018 at 03:25)</a>:</h4>
<p>The assumption, the trust, goes into assuming that the VM respects the lean model. You verify the lean model</p>

<a name="127488045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cool%20paper%20on%20reification/near/127488045" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22256coolpaperonreification.html#127488045">Andrew Ashworth (Jun 03 2018 at 03:26)</a>:</h4>
<p>ah, gotcha</p>

<a name="127488054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cool%20paper%20on%20reification/near/127488054" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22256coolpaperonreification.html#127488054">Mario Carneiro (Jun 03 2018 at 03:27)</a>:</h4>
<p>But that's not much different from assuming the kernel is correctly implemented in C++. You expand your trust level a bit and get fast evaluation</p>

<a name="127488200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cool%20paper%20on%20reification/near/127488200" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22256coolpaperonreification.html#127488200">Andrew Ashworth (Jun 03 2018 at 03:31)</a>:</h4>
<p>it's interesting to me that reflection is slow because generating the reified syntax and reducing the output of the interpretation function are such huge constant overheads. I would've guessed that the manipulations you might do on the AST you create would've been a bigger deal in practice for most problems</p>

<a name="127495213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cool%20paper%20on%20reification/near/127495213" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22256coolpaperonreification.html#127495213">Andrew Ashworth (Jun 03 2018 at 08:21)</a>:</h4>
<p>well, you weren't kidding about kernel computation</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">is_even</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">is_even</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">ssuc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">is_even</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">is_even</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">))</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">prove_even</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span> <span class="bp">`</span><span class="o">[</span><span class="n">repeat</span> <span class="o">{</span><span class="n">constructor</span><span class="o">}]</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">is_even</span> <span class="mi">2000</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">do</span> <span class="n">timetac</span> <span class="s2">&quot;&quot;</span> <span class="n">prove_even</span>

<span class="n">def</span> <span class="n">check_is_even</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero</span> <span class="o">:=</span> <span class="n">tt</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero</span><span class="o">)</span> <span class="o">:=</span> <span class="n">ff</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n&#39;</span><span class="o">))</span> <span class="o">:=</span> <span class="n">check_is_even</span> <span class="n">n&#39;</span>

<span class="n">local</span> <span class="n">attribute</span> <span class="o">[</span><span class="n">elab_as_eliminator</span><span class="o">]</span> <span class="n">nat</span><span class="bp">.</span><span class="n">case_strong_induction_on</span>
<span class="kn">theorem</span> <span class="n">cie_sound</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">check_is_even</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">tt</span> <span class="bp">→</span> <span class="n">is_even</span> <span class="n">n</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">case_strong_induction_on</span> <span class="n">n</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">is_even</span><span class="bp">.</span><span class="n">zero</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">n&#39;</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">n&#39;</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">h₁</span> <span class="n">h₂</span><span class="o">,</span> <span class="k">have</span> <span class="n">h₃</span> <span class="o">:</span> <span class="n">check_is_even</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">ff</span><span class="o">,</span> <span class="k">from</span> <span class="n">rfl</span><span class="o">,</span> <span class="k">by</span> <span class="n">contradiction</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">m</span> <span class="n">h₁</span> <span class="n">h₂</span> <span class="n">h₃</span><span class="o">,</span> <span class="n">is_even</span><span class="bp">.</span><span class="n">ssuc</span> <span class="bp">_</span> <span class="o">((</span><span class="n">h₂</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">le_succ</span> <span class="n">m</span><span class="o">)</span> <span class="n">h₃</span><span class="o">)))</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">is_even</span> <span class="mi">2000</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">do</span> <span class="n">timetac</span> <span class="s2">&quot;&quot;</span> <span class="bp">`</span><span class="o">[</span><span class="n">exact</span> <span class="n">cie_sound</span> <span class="mi">2000</span> <span class="n">rfl</span><span class="o">]</span>
</pre></div>


{% endraw %}
