---
layout: archive
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/18651canonicallyidentifyingtwotypes.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html">"canonically" identifying two types</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="125765228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125765228" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125765228">Kevin Buzzard (Apr 27 2018 at 09:02)</a>:</h4>
<p>How can I beef up "equiv" into "canonical isomorphism"?</p>

<a name="125765384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125765384" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125765384">Kevin Buzzard (Apr 27 2018 at 09:08)</a>:</h4>
<p>I think that's my question.</p>

<a name="125765424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125765424" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125765424">Kevin Buzzard (Apr 27 2018 at 09:08)</a>:</h4>
<p>I will formulate something a bit more precise in a sec.</p>

<a name="125765431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125765431" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125765431">Mario Carneiro (Apr 27 2018 at 09:08)</a>:</h4>
<p>Q1: what does that mean? Is "isomorphism" sufficient?</p>

<a name="125768206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768206" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768206">Kevin Buzzard (Apr 27 2018 at 10:28)</a>:</h4>
<p>The proof of <code>funext</code> uses quot.sound</p>

<a name="125768208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768208" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768208">Kevin Buzzard (Apr 27 2018 at 10:28)</a>:</h4>
<p>but if we restrict to two types in the same universe</p>

<a name="125768222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768222" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768222">Kevin Buzzard (Apr 27 2018 at 10:29)</a>:</h4>
<div class="codehilite"><pre><span></span>  <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">f₁</span> <span class="n">f₂</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">β</span> <span class="n">x</span><span class="o">},</span>
    <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">f₁</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">f₂</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="n">f₁</span> <span class="bp">=</span> <span class="n">f₂</span>
</pre></div>

<a name="125768229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768229" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768229">Kevin Buzzard (Apr 27 2018 at 10:29)</a>:</h4>
<p>so a slightly weaker result</p>

<a name="125768230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768230" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768230">Kevin Buzzard (Apr 27 2018 at 10:29)</a>:</h4>
<p>can one prove this without quot.sound?</p>

<a name="125768288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768288" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768288">Kevin Buzzard (Apr 27 2018 at 10:30)</a>:</h4>
<p>I'm trying to work out what a mathematician means when they say that two objects are "canonically isomorphic".</p>

<a name="125768292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768292" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768292">Kevin Buzzard (Apr 27 2018 at 10:30)</a>:</h4>
<p>To coin a phrase, it's like pornography.</p>

<a name="125768294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768294" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768294">Kevin Buzzard (Apr 27 2018 at 10:30)</a>:</h4>
<p>You know it when you see it.</p>

<a name="125768300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768300" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768300">Kevin Buzzard (Apr 27 2018 at 10:30)</a>:</h4>
<p>I have not yet found a formulation that I like in dependent type theory.</p>

<a name="125768308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768308" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768308">Kevin Buzzard (Apr 27 2018 at 10:31)</a>:</h4>
<p>and I think that this is an underlying source of some of my frustrations in trying to do mathematics in Lean.</p>

<a name="125768310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768310" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768310">Kevin Buzzard (Apr 27 2018 at 10:31)</a>:</h4>
<p>Here's a probably much easier question:</p>

<a name="125768312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768312" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768312">Kevin Buzzard (Apr 27 2018 at 10:31)</a>:</h4>
<p>what's the inverse of funext called?</p>

<a name="125768335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768335" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768335">Kenny Lau (Apr 27 2018 at 10:32)</a>:</h4>
<p><code>congr_fun</code></p>

<a name="125768354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768354" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768354">Kenny Lau (Apr 27 2018 at 10:32)</a>:</h4>
<p>wait, inverse not converse</p>

<a name="125768366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768366" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768366">Kevin Buzzard (Apr 27 2018 at 10:32)</a>:</h4>
<p>that's what I wanted</p>

<a name="125768367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768367" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768367">Kevin Buzzard (Apr 27 2018 at 10:32)</a>:</h4>
<p>no axioms</p>

<a name="125768368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768368" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768368">Kevin Buzzard (Apr 27 2018 at 10:32)</a>:</h4>
<p>different universes</p>

<a name="125768378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768378" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768378">Kenny Lau (Apr 27 2018 at 10:33)</a>:</h4>
<p>inverse?</p>

<a name="125768380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768380" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768380">Kenny Lau (Apr 27 2018 at 10:33)</a>:</h4>
<p>not A implies not B?</p>

<a name="125768381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768381" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768381">Kevin Buzzard (Apr 27 2018 at 10:33)</a>:</h4>
<p>Is it possible to express the notion that two types are "the same" without ever mentioning any terms?</p>

<a name="125768383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768383" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768383">Kenny Lau (Apr 27 2018 at 10:33)</a>:</h4>
<p><code>==</code></p>

<a name="125768388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768388" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768388">Kevin Buzzard (Apr 27 2018 at 10:33)</a>:</h4>
<p>Kenny you answered my question</p>

<a name="125768435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768435" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768435">Kenny Lau (Apr 27 2018 at 10:34)</a>:</h4>
<p>inverse is <code>mt \o congr_fun</code> :P</p>

<a name="125768436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768436" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768436">Kevin Buzzard (Apr 27 2018 at 10:34)</a>:</h4>
<p>Here are two notions of being "close to each other in type theory", which in my mind are both certainly implied by being "the same".</p>

<a name="125768448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768448" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768448">Kevin Buzzard (Apr 27 2018 at 10:35)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">universe</span> <span class="n">zfc</span>
<span class="c1">--#print extfun_app</span>

<span class="c1">-- Here is a notion from dependent type theory.</span>
<span class="c">/-</span><span class="cm">- `α ≃ β` is the type of functions from `α → β` with a two-sided inverse. -/</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">zfc</span><span class="o">}</span>

<span class="kn">structure</span> <span class="n">equiv</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">zfc</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">zfc</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_fun</span>    <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>
<span class="o">(</span><span class="n">inv_fun</span>   <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">left_inv</span>  <span class="o">:</span> <span class="n">function</span><span class="bp">.</span><span class="n">left_inverse</span> <span class="n">inv_fun</span> <span class="n">to_fun</span><span class="o">)</span>
<span class="o">(</span><span class="n">right_inv</span> <span class="o">:</span> <span class="n">function</span><span class="bp">.</span><span class="n">right_inverse</span> <span class="n">inv_fun</span> <span class="n">to_fun</span><span class="o">)</span>


<span class="kn">variable</span> <span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>
<span class="kn">variable</span> <span class="o">(</span><span class="n">inv_fun</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>

<span class="bp">#</span><span class="n">reduce</span> <span class="n">function</span><span class="bp">.</span><span class="n">left_inverse</span> <span class="n">inv_fun</span> <span class="n">to_fun</span>
<span class="c1">-- ∀ (x : α), to_fun (inv_fun x) = x</span>
<span class="c1">-- note round brackets -- explicitly demand the term</span>

<span class="bp">#</span><span class="n">reduce</span> <span class="n">function</span><span class="bp">.</span><span class="n">right_inverse</span> <span class="n">inv_fun</span> <span class="n">to_fun</span>
<span class="c1">-- ∀ (x : β), to_fun (inv_fun x) = x</span>
<span class="c1">-- note round brackets -- explicitly demand the term</span>

<span class="c1">-- Here is a notion from category theory, translated into dependent type theory.</span>
<span class="c">/-</span><span class="cm">- The notion of being isomorphic in a category  -/</span>
<span class="kn">structure</span> <span class="n">isom</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">zfc</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">zfc</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>
<span class="o">(</span><span class="n">inv_fun</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">left_inv</span> <span class="o">:</span> <span class="n">inv_fun</span> <span class="err">∘</span> <span class="n">to_fun</span> <span class="bp">=</span> <span class="n">id</span><span class="o">)</span>
<span class="o">(</span><span class="n">right_inv</span> <span class="o">:</span> <span class="n">to_fun</span> <span class="err">∘</span> <span class="n">inv_fun</span> <span class="bp">=</span> <span class="n">id</span><span class="o">)</span>
</pre></div>

<a name="125768450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768450" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768450">Kevin Buzzard (Apr 27 2018 at 10:35)</a>:</h4>
<p>I have stuck to one universe</p>

<a name="125768463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768463" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768463">Kevin Buzzard (Apr 27 2018 at 10:36)</a>:</h4>
<p>because I am a traditionalist</p>

<a name="125768494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768494" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768494">Kevin Buzzard (Apr 27 2018 at 10:36)</a>:</h4>
<p>Why does Lean prefer <code>equiv</code> (which is in core Lean) to <code>isom</code>?</p>

<a name="125768495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768495" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768495">Kevin Buzzard (Apr 27 2018 at 10:36)</a>:</h4>
<p>Is <code>isom</code> in there somewhere?</p>

<a name="125768496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768496" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768496">Kevin Buzzard (Apr 27 2018 at 10:36)</a>:</h4>
<p>These structures are canonically isomorphic, but I don't know the definition of canonically isomorphic</p>

<a name="125768502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768502" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768502">Kenny Lau (Apr 27 2018 at 10:37)</a>:</h4>
<p>because <code>equiv</code> is more usable</p>

<a name="125768503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768503" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768503">Kevin Buzzard (Apr 27 2018 at 10:37)</a>:</h4>
<p>but in dependent type theory the only way I know to construct bijective maps between them is using quot.sound</p>

<a name="125768504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768504" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768504">Kenny Lau (Apr 27 2018 at 10:37)</a>:</h4>
<p>Just look at my proof in the other thread</p>

<a name="125768505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768505" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768505">Kenny Lau (Apr 27 2018 at 10:37)</a>:</h4>
<p>before and after changing composition equality</p>

<a name="125768508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768508" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768508">Kevin Buzzard (Apr 27 2018 at 10:37)</a>:</h4>
<p>Is it just universally true that equiv is better than isom?</p>

<a name="125768548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768548" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768548">Kevin Buzzard (Apr 27 2018 at 10:38)</a>:</h4>
<p>I don't know what other thread you're talking about.</p>

<a name="125768549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768549" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768549">Kevin Buzzard (Apr 27 2018 at 10:38)</a>:</h4>
<p>But I would genuinely be interested to know.</p>

<a name="125768552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768552" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768552">Kevin Buzzard (Apr 27 2018 at 10:38)</a>:</h4>
<p>My memory is not what it was.</p>

<a name="125768576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768576" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768576">Kevin Buzzard (Apr 27 2018 at 10:40)</a>:</h4>
<p>Anyway, I was wondering whether if one stuck to one universe, whether the restricted funext, which sounds to me like it could logically be a strictly weaker assertion, could be proved without the axiom.</p>

<a name="125768619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768619" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768619">Kenny Lau (Apr 27 2018 at 10:40)</a>:</h4>
<p><a href="#narrow/stream/113488-general/topic/proof.20of.20the.20five.20lemma" title="#narrow/stream/113488-general/topic/proof.20of.20the.20five.20lemma">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/proof.20of.20the.20five.20lemma</a></p>

<a name="125768685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768685" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768685">Kevin Buzzard (Apr 27 2018 at 10:42)</a>:</h4>
<p>Mario, I ultimately want to formalise some possibly specialised notion of being canonically isomorphic, which I can use to do amazing rewrites which a mathematician does all the time but which I find difficult to do in dependent type theory. My problem in dependent type theory is that I sometimes run into terms which are not definitionally equal, but which are "only" canonically isomorphic.</p>

<a name="125768686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768686" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768686">Kevin Buzzard (Apr 27 2018 at 10:42)</a>:</h4>
<p>Because I am facing quite a tedious job otherwise</p>

<a name="125768742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768742" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768742">Kevin Buzzard (Apr 27 2018 at 10:45)</a>:</h4>
<p>I think I want to make a new structure which is more useful to me than definitional equivalence.</p>

<a name="125768743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768743" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768743">Kevin Buzzard (Apr 27 2018 at 10:45)</a>:</h4>
<p>It is not Lean's <code>=</code> because I want it to apply to terms of different types.</p>

<a name="125768788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768788" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768788">Kevin Buzzard (Apr 27 2018 at 10:46)</a>:</h4>
<p>and I am quite happy to restrict to objects within one universe</p>

<a name="125768795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768795" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768795">Kenny Lau (Apr 27 2018 at 10:47)</a>:</h4>
<p>why don't you just quotient everything with equiv</p>

<a name="125768899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768899" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768899">Kevin Buzzard (Apr 27 2018 at 10:51)</a>:</h4>
<p>Wow, props can be equal : <code>@eq</code> is defined on <code>Sort u_1</code></p>

<a name="125768902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768902" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768902">Kevin Buzzard (Apr 27 2018 at 10:51)</a>:</h4>
<p>Is that concept used?</p>

<a name="125768904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768904" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768904">Kevin Buzzard (Apr 27 2018 at 10:51)</a>:</h4>
<p>being canonically isomorphic only applies to types.</p>

<a name="125768943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768943" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768943">Kenny Lau (Apr 27 2018 at 10:52)</a>:</h4>
<blockquote>
<p>Is that concept used?</p>
</blockquote>
<p>a lot</p>

<a name="125768944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768944" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768944">Kenny Lau (Apr 27 2018 at 10:52)</a>:</h4>
<p>but mostly in <code>simp</code></p>

<a name="125768945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768945" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768945">Kenny Lau (Apr 27 2018 at 10:52)</a>:</h4>
<p><code>simp</code> rewrites Props</p>

<a name="125768948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125768948" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125768948">Kenny Lau (Apr 27 2018 at 10:52)</a>:</h4>
<p>using <code>propext</code></p>

<a name="125769002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769002" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769002">Kevin Buzzard (Apr 27 2018 at 10:54)</a>:</h4>
<p>Is this in Lean or mathlib:</p>

<a name="125769003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769003" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769003">Kevin Buzzard (Apr 27 2018 at 10:54)</a>:</h4>
<p><code>instance group_of_equiv [group α] (H : equiv α β) : group β := sorry</code></p>

<a name="125769014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769014" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769014">Kevin Buzzard (Apr 27 2018 at 10:55)</a>:</h4>
<p>If alpha and beta are canonically isomorphic, then any group structure on alpha trivially gives you a group structure on beta, any mathematician knows that.</p>

<a name="125769069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769069" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769069">Scott Morrison (Apr 27 2018 at 10:57)</a>:</h4>
<p>I am slowly coming around to the opinion that "canonical" as used by mathematicans doesn't actually mean much, but is instead code for "we both know what is going on, and I'm just confirming that you one you have in mind is probably the one I have in mind too".</p>

<a name="125769113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769113" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769113">Kevin Buzzard (Apr 27 2018 at 10:58)</a>:</h4>
<p><code>instance set_equiv_of_equiv (H : equiv α β) : equiv (set α) (set β) := sorry</code></p>

<a name="125769114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769114" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769114">Kevin Buzzard (Apr 27 2018 at 10:58)</a>:</h4>
<p>doesn't typecheck</p>

<a name="125769115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769115" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769115">Kevin Buzzard (Apr 27 2018 at 10:58)</a>:</h4>
<p><code>equiv</code> is not a class</p>

<a name="125769125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769125" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769125">Kevin Buzzard (Apr 27 2018 at 10:59)</a>:</h4>
<p>but if <code>\a</code> and <code>\b</code> are canonically isomorphic, then so are their power sets -- any mathematician knows that.</p>

<a name="125769131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769131" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769131">Scott Morrison (Apr 27 2018 at 11:00)</a>:</h4>
<p>We could make <code>equiv</code> a class, and have the convention that we'll only even make instances that "every mathematician knows is the right one".</p>

<a name="125769182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769182" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769182">Kevin Buzzard (Apr 27 2018 at 11:00)</a>:</h4>
<p>But do I want to restrict myself like that?</p>

<a name="125769184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769184" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769184">Kevin Buzzard (Apr 27 2018 at 11:00)</a>:</h4>
<p>I am not sure</p>

<a name="125769185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769185" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769185">Kevin Buzzard (Apr 27 2018 at 11:00)</a>:</h4>
<p>There are two abelian groups which show up in the Langlands Philosophy</p>

<a name="125769188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769188" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769188">Kevin Buzzard (Apr 27 2018 at 11:00)</a>:</h4>
<p>And the Langlands Philosophy says that they are canonically isomorphic</p>

<a name="125769195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769195" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769195">Scott Morrison (Apr 27 2018 at 11:01)</a>:</h4>
<p>Well... an isomorphism from <code>a</code> to <code>b</code> gives an isomorphism from <code>2^a</code> to <code>2^b</code>, sure. If you bless one as canonical, I guess that blesses the result as canonical too.</p>

<a name="125769198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769198" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769198">Kevin Buzzard (Apr 27 2018 at 11:01)</a>:</h4>
<p>In fact, more generally there are two non-abelian groups which show up and Langlands conjectures that they are canonically isomorphic, and this is one of the reasons that we call it philosophy sometimes -- it is not quite mathematics.</p>

<a name="125769202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769202" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769202">Kevin Buzzard (Apr 27 2018 at 11:01)</a>:</h4>
<p>But back to the abelian groups</p>

<a name="125769206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769206" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769206">Scott Morrison (Apr 27 2018 at 11:01)</a>:</h4>
<p>But by that do you just mean that there's a particularly interesting/sensible isomorphism between them, and the point is not to say "these are isomorphic", but "this is an isomorphism between ..."?</p>

<a name="125769246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769246" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769246">Kevin Buzzard (Apr 27 2018 at 11:02)</a>:</h4>
<p>Mathematicians have written down not just one, but two canonical isomorphisms between these groups!</p>

<a name="125769247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769247" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769247">Kevin Buzzard (Apr 27 2018 at 11:02)</a>:</h4>
<p>And they're different!</p>

<a name="125769249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769249" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769249">Kevin Buzzard (Apr 27 2018 at 11:02)</a>:</h4>
<p>One is called "global class field theory normalised so that uniformisers become identified with geometric Frobenius"</p>

<a name="125769255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769255" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769255">Scott Morrison (Apr 27 2018 at 11:03)</a>:</h4>
<p>So what does canonical mean here? (I am not really confident in my skepticism of the word "canonical". I am happy to come back to the fold if the story is good.)</p>

<a name="125769256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769256" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769256">Kevin Buzzard (Apr 27 2018 at 11:03)</a>:</h4>
<p>and the other is called "global class field theory normalised so that uniformisers become identified with arithmetic Frobenius"</p>

<a name="125769260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769260" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769260">Kevin Buzzard (Apr 27 2018 at 11:03)</a>:</h4>
<p>The two canonical isomorphisms between the groups are related. If we write the group law multiplicatively, as is standard,</p>

<a name="125769261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769261" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769261">Kevin Buzzard (Apr 27 2018 at 11:03)</a>:</h4>
<p>then if one of them is f(x)=y</p>

<a name="125769263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769263" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769263">Kevin Buzzard (Apr 27 2018 at 11:04)</a>:</h4>
<p>the other is f(x)=1/y</p>

<a name="125769303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769303" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769303">Kevin Buzzard (Apr 27 2018 at 11:04)</a>:</h4>
<p>and mathematicians choose at random which one to use</p>

<a name="125769305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769305" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769305">Kevin Buzzard (Apr 27 2018 at 11:04)</a>:</h4>
<p>and some even sometimes forget to say which one</p>

<a name="125769308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769308" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769308">Kevin Buzzard (Apr 27 2018 at 11:04)</a>:</h4>
<p>perhaps because the one they used was the most common one when the paper was written</p>

<a name="125769321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769321" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769321">Kevin Buzzard (Apr 27 2018 at 11:05)</a>:</h4>
<p>So I am pretty sure I want to allow myself more than one canonical isomorphism between two objects</p>

<a name="125769721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769721" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769721">Johan Commelin (Apr 27 2018 at 11:18)</a>:</h4>
<p>So, here is Kevin's remark in a down to earth example: every abelian group has a canonical automorphism, and in fact, it has two of those: the identity, and the map <code>a \mapsto -a</code>.</p>

<a name="125769731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769731" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769731">Kevin Buzzard (Apr 27 2018 at 11:19)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> -- you wrote my function! Many thanks!</p>

<a name="125769733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769733" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769733">Johan Commelin (Apr 27 2018 at 11:19)</a>:</h4>
<p>Of course, in the case of automorphisms, we agree that <code>id</code> is slightly more canonical then the -1 map</p>

<a name="125769777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769777" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769777">Kevin Buzzard (Apr 27 2018 at 11:20)</a>:</h4>
<p>But these were two different groups</p>

<a name="125769778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769778" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769778">Kevin Buzzard (Apr 27 2018 at 11:20)</a>:</h4>
<p>and this has caused confusion in the mathematical community</p>

<a name="125769779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769779" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769779">Johan Commelin (Apr 27 2018 at 11:20)</a>:</h4>
<p>Exactly</p>

<a name="125769781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769781" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769781">Kevin Buzzard (Apr 27 2018 at 11:20)</a>:</h4>
<p>I think that's interesting.</p>

<a name="125769782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769782" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769782">Kevin Buzzard (Apr 27 2018 at 11:20)</a>:</h4>
<p>Nowadays people are careful to state which of the normalisations they are using</p>

<a name="125769789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769789" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769789">Kevin Buzzard (Apr 27 2018 at 11:21)</a>:</h4>
<p>and unfortunately, and perhaps counter-intuitively, it can sometimes be a little tricky to figure out how to translate the statements of theorems proved using one convention into the analogous statements about the same objects had we used the other convention in the paper.</p>

<a name="125769790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769790" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769790">Johan Commelin (Apr 27 2018 at 11:21)</a>:</h4>
<p>But Kevin, if we go for the restricted version of canonical first. The one that Scott suggested. That would already be incredibly helpful, right?</p>

<a name="125769831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769831" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769831">Kenny Lau (Apr 27 2018 at 11:22)</a>:</h4>
<blockquote>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> -- you wrote my function! Many thanks!</p>
</blockquote>
<p>which function?</p>

<a name="125769835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769835" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769835">Johan Commelin (Apr 27 2018 at 11:22)</a>:</h4>
<p>If there is one 'blessed' isomorphism, it can be traced through al sorts of constructions, and induce 'blessed' equivalences/isomorphism between other objects</p>

<a name="125769837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769837" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769837">Johan Commelin (Apr 27 2018 at 11:22)</a>:</h4>
<p>Like with power sets, or group structures, etc...</p>

<a name="125769838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769838" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769838">Kevin Buzzard (Apr 27 2018 at 11:22)</a>:</h4>
<blockquote>
<p>But by that do you just mean that there's a particularly interesting/sensible isomorphism between them, and the point is not to say "these are isomorphic", but "this is an isomorphism between ..."?</p>
</blockquote>
<p>I am quite happy to state the isomorphism. But what I want from it is a huge quota of free constructions and proofs.</p>

<a name="125769894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769894" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769894">Kevin Buzzard (Apr 27 2018 at 11:25)</a>:</h4>
<p>I want <code>canonical_isomorphism</code> to extend (possibly a restricted universe version of) <code>equiv</code></p>

<a name="125769898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769898" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769898">Johan Commelin (Apr 27 2018 at 11:25)</a>:</h4>
<p>At the Lean wizards: Kevin is pointing out an incredibly important thing. As in, it is a difference in kind, not just a difference in degree.</p>

<a name="125769901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769901" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769901">Johan Commelin (Apr 27 2018 at 11:25)</a>:</h4>
<p>It will give super-linear improvements in the de Bruijn factor.</p>

<a name="125769922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769922" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769922">Kevin Buzzard (Apr 27 2018 at 11:26)</a>:</h4>
<p>and I want functions like</p>

<a name="125769942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769942" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769942">Kevin Buzzard (Apr 27 2018 at 11:26)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">instance</span> <span class="n">group_of_equiv</span> <span class="o">[</span><span class="n">group</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">canonically_isomorphic</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">group</span> <span class="n">β</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>

<a name="125769947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769947" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769947">Kenny Lau (Apr 27 2018 at 11:26)</a>:</h4>
<p>transport of structure</p>

<a name="125769951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769951" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769951">Kenny Lau (Apr 27 2018 at 11:26)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> maybe you could automate this?</p>

<a name="125769952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769952" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769952">Johan Commelin (Apr 27 2018 at 11:26)</a>:</h4>
<p>I personally feel (but I'm a novice) that this is one of the big road blocks for formalisation of a lot of maths in the algebraic geometry corner</p>

<a name="125769959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769959" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769959">Kevin Buzzard (Apr 27 2018 at 11:27)</a>:</h4>
<p>I have this big Pokemon to kill</p>

<a name="125769960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769960" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769960">Kevin Buzzard (Apr 27 2018 at 11:27)</a>:</h4>
<p>called proof that an affine scheme is a scheme</p>

<a name="125769962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769962" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769962">Kevin Buzzard (Apr 27 2018 at 11:27)</a>:</h4>
<p>and it is now in its final stage</p>

<a name="125769967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769967" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769967">Kevin Buzzard (Apr 27 2018 at 11:27)</a>:</h4>
<p>and I want to destroy it with a one liner like this</p>

<a name="125769968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769968" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769968">Chris Hughes (Apr 27 2018 at 11:27)</a>:</h4>
<p>What happened to Kenny's idea of quotienting by isomorphism?</p>

<a name="125769969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125769969" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125769969">Kenny Lau (Apr 27 2018 at 11:27)</a>:</h4>
<p>Chris Hughes appears</p>

<a name="125770009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770009" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770009">Kevin Buzzard (Apr 27 2018 at 11:28)</a>:</h4>
<p>I don't know how to implement that</p>

<a name="125770012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770012" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770012">Kevin Buzzard (Apr 27 2018 at 11:28)</a>:</h4>
<p>Did you see my "three lemma" Chris?</p>

<a name="125770014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770014" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770014">Johan Commelin (Apr 27 2018 at 11:28)</a>:</h4>
<p>What exactly does Kenny mean by "quotienting by isomorphism"?</p>

<a name="125770016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770016" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770016">Johan Commelin (Apr 27 2018 at 11:28)</a>:</h4>
<p>Because that might be to crude...</p>

<a name="125770017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770017" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770017">Kevin Buzzard (Apr 27 2018 at 11:28)</a>:</h4>
<p>I want to prove that if <code>A -&gt; B -&gt; C</code> is exact and we are given isomorphisms <code>A -&gt; A'</code> and <code>B -&gt; B'</code> and <code>C -&gt; C'</code></p>

<a name="125770027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770027" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770027">Kevin Buzzard (Apr 27 2018 at 11:29)</a>:</h4>
<p>then there is a completely obvious new exact sequence <code>A' -&gt; B' -&gt; C'</code></p>

<a name="125770029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770029" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770029">Kenny Lau (Apr 27 2018 at 11:29)</a>:</h4>
<p>I already proved it</p>

<a name="125770030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770030" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770030">Kevin Buzzard (Apr 27 2018 at 11:29)</a>:</h4>
<p>I know</p>

<a name="125770034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770034" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770034">Kevin Buzzard (Apr 27 2018 at 11:29)</a>:</h4>
<p>but i don't want you to spend 70 lines proving it</p>

<a name="125770037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770037" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770037">Kevin Buzzard (Apr 27 2018 at 11:29)</a>:</h4>
<p>I want to to agree with me that it is obvious</p>

<a name="125770038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770038" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770038">Kevin Buzzard (Apr 27 2018 at 11:29)</a>:</h4>
<p>and hence is only worth one line</p>

<a name="125770086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770086" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770086">Kevin Buzzard (Apr 27 2018 at 11:30)</a>:</h4>
<p>because a mathematician is capable of replacing <code>B</code> with the canonically isomorphic <code>B'</code> in one line</p>

<a name="125770090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770090" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770090">Kevin Buzzard (Apr 27 2018 at 11:30)</a>:</h4>
<p>so I can prove the theorem in 3 lines</p>

<a name="125770092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770092" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770092">Kevin Buzzard (Apr 27 2018 at 11:30)</a>:</h4>
<p>and I don't see anything wrong with my proof</p>

<a name="125770095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770095" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770095">Kevin Buzzard (Apr 27 2018 at 11:30)</a>:</h4>
<p>at every stage the next line is "do the obvious thing"</p>

<a name="125770106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770106" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770106">Kevin Buzzard (Apr 27 2018 at 11:31)</a>:</h4>
<blockquote>
<p>but i don't want you to spend 70 lines proving it</p>
</blockquote>
<p>... by which I mean</p>

<a name="125770108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770108" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770108">Kevin Buzzard (Apr 27 2018 at 11:31)</a>:</h4>
<p>thank you very much Kenny for proving the result for me</p>

<a name="125770112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770112" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770112">Kevin Buzzard (Apr 27 2018 at 11:31)</a>:</h4>
<p>and don't you think it's interesting that it took 70 lines</p>

<a name="125770117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770117" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770117">Kevin Buzzard (Apr 27 2018 at 11:31)</a>:</h4>
<p>but for the purposes of this thread I want 3 lines</p>

<a name="125770160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770160" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770160">Kenny Lau (Apr 27 2018 at 11:32)</a>:</h4>
<p>lol</p>

<a name="125770163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770163" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770163">Kevin Buzzard (Apr 27 2018 at 11:32)</a>:</h4>
<p>I want to <code>rw [H : canonically_isomorphic A A']</code></p>

<a name="125770164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770164" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770164">Kevin Buzzard (Apr 27 2018 at 11:32)</a>:</h4>
<p>and then you can guess the rest</p>

<a name="125770166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770166" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770166">Johan Commelin (Apr 27 2018 at 11:32)</a>:</h4>
<p><code>[...] := by repeat {transport_de_structure}</code></p>

<a name="125770173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770173" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770173">Kevin Buzzard (Apr 27 2018 at 11:33)</a>:</h4>
<p>This is exactly another one of those concepts which I have been interested in all my life but have only really now found the language to talk about them in</p>

<a name="125770225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770225" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770225">Kevin Buzzard (Apr 27 2018 at 11:34)</a>:</h4>
<p>and perhaps this is very difficult to do in dependent type theory</p>

<a name="125770229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770229" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770229">Kevin Buzzard (Apr 27 2018 at 11:34)</a>:</h4>
<p>because replacing <code>f A</code> with <code>f A'</code> can be quite complicated in general</p>

<a name="125770232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770232" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770232">Kevin Buzzard (Apr 27 2018 at 11:34)</a>:</h4>
<p>but the point is that <code>A</code> and <code>A'</code> are <em>mathematical objects</em></p>

<a name="125770235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770235" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770235">Kevin Buzzard (Apr 27 2018 at 11:35)</a>:</h4>
<p>not these stupid general types</p>

<a name="125770246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770246" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770246">Kevin Buzzard (Apr 27 2018 at 11:35)</a>:</h4>
<p>and so what I am hoping is that for a possibly restricted class of types there is some powerful relation on them</p>

<a name="125770285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770285" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770285">Kevin Buzzard (Apr 27 2018 at 11:36)</a>:</h4>
<p>called "canonically isomorphic"</p>

<a name="125770291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770291" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770291">Kevin Buzzard (Apr 27 2018 at 11:36)</a>:</h4>
<p>which you construct with functions in both directions, proofs that the composites are the identity either way (as in equiv not isom), and a little bit of extra magic</p>

<a name="125770294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770294" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770294">Kevin Buzzard (Apr 27 2018 at 11:36)</a>:</h4>
<p>possibly</p>

<a name="125770300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770300" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770300">Kevin Buzzard (Apr 27 2018 at 11:37)</a>:</h4>
<p>and then for hopefully a class of types including the kind of types showing up in mathematics</p>

<a name="125770348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770348" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770348">Kevin Buzzard (Apr 27 2018 at 11:38)</a>:</h4>
<p>a lot of stuff can be moved around painlessly, substituting one type for a canonically isomorphic one.</p>

<a name="125770352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770352" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770352">Kevin Buzzard (Apr 27 2018 at 11:38)</a>:</h4>
<p>So who fancies proving <code>equiv A B -&gt; scheme A -&gt; scheme B</code></p>

<a name="125770366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770366" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770366">Kevin Buzzard (Apr 27 2018 at 11:39)</a>:</h4>
<p>Wait, for what generality is this true?</p>

<a name="125770369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770369" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770369">Johan Commelin (Apr 27 2018 at 11:39)</a>:</h4>
<p>Hmmm, Kevin, I think there are two things at play</p>

<a name="125770417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770417" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770417">Johan Commelin (Apr 27 2018 at 11:40)</a>:</h4>
<p>There is functoriality, and transport de structure</p>

<a name="125770419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770419" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770419">Johan Commelin (Apr 27 2018 at 11:40)</a>:</h4>
<p>and they are related, but slightly different</p>

<a name="125770423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770423" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770423">Johan Commelin (Apr 27 2018 at 11:41)</a>:</h4>
<p>I don't know exactly how to explain the difference</p>

<a name="125770428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770428" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770428">Johan Commelin (Apr 27 2018 at 11:41)</a>:</h4>
<p>(And maybe they actually are not)</p>

<a name="125770430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770430" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770430">Chris Hughes (Apr 27 2018 at 11:41)</a>:</h4>
<p>Is this totally disgusting?</p>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">isom</span> <span class="o">(</span><span class="n">G</span> <span class="n">H</span> <span class="o">:</span> <span class="err">Σ</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">,</span> <span class="n">group</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">G</span><span class="bp">.</span><span class="mi">1</span> <span class="err">≃</span> <span class="n">H</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span>
<span class="o">(</span><span class="n">to_fun_hom</span> <span class="o">:</span> <span class="bp">@</span><span class="n">is_group_hom</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">G</span><span class="bp">.</span><span class="mi">2</span> <span class="n">H</span><span class="bp">.</span><span class="mi">2</span> <span class="n">f</span><span class="bp">.</span><span class="n">to_fun</span><span class="o">)</span>
<span class="o">(</span><span class="n">inv_fun_hom</span> <span class="o">:</span> <span class="bp">@</span><span class="n">is_group_hom</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">H</span><span class="bp">.</span><span class="mi">2</span> <span class="n">G</span><span class="bp">.</span><span class="mi">2</span> <span class="n">f</span><span class="bp">.</span><span class="n">inv_fun</span><span class="o">)</span>

<span class="n">def</span> <span class="n">is_isom</span> <span class="o">(</span><span class="n">G</span> <span class="n">H</span> <span class="o">:</span> <span class="err">Σ</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">,</span> <span class="n">group</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">nonempty</span> <span class="o">(</span><span class="n">isom</span> <span class="n">G</span> <span class="n">H</span><span class="o">)</span>
</pre></div>

<a name="125770537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770537" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770537">Scott Morrison (Apr 27 2018 at 11:45)</a>:</h4>
<p>Really you want to prove <code>equiv A B -&gt; equiv (scheme A) (scheme B)</code>.</p>

<a name="125770539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770539" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770539">Johan Commelin (Apr 27 2018 at 11:45)</a>:</h4>
<p>Chris, but what does it do?</p>

<a name="125770580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770580" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770580">Scott Morrison (Apr 27 2018 at 11:46)</a>:</h4>
<p>Or even better: <code>scheme</code> is an endofunctor of the category of types and equivalences.</p>

<a name="125770581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770581" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770581">Johan Commelin (Apr 27 2018 at 11:46)</a>:</h4>
<p>Isn't that too general? You need some ring structures flying around, right?</p>

<a name="125770633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770633" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770633">Scott Morrison (Apr 27 2018 at 11:48)</a>:</h4>
<p>I'm not sure what you mean, Johan. How would rings come into the picture? We're just doing abstract nonsense with types here.</p>

<a name="125770638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770638" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770638">Chris Hughes (Apr 27 2018 at 11:49)</a>:</h4>
<p>If you quotient then you can rw. That's the idea. But it might be completely useless.</p>

<a name="125770639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770639" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770639">Johan Commelin (Apr 27 2018 at 11:49)</a>:</h4>
<p>Scott, never mind, you are right</p>

<a name="125770686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770686" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770686">Johan Commelin (Apr 27 2018 at 11:50)</a>:</h4>
<p>Ok, so then we want your proposed theorem to come for free. Does that make sense?</p>

<a name="125770688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770688" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770688">Johan Commelin (Apr 27 2018 at 11:50)</a>:</h4>
<p>And then, if we have an actual equivalence between A and B, we get an equivalence between (scheme A) and (scheme B) for free</p>

<a name="125770702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770702" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770702">Johan Commelin (Apr 27 2018 at 11:51)</a>:</h4>
<p>And I guess it comes for free for all endofunctors, and endofunctors compose</p>

<a name="125770708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770708" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770708">Johan Commelin (Apr 27 2018 at 11:52)</a>:</h4>
<p>So we might need to mark lots of definitions with [endofunctor]</p>

<a name="125770751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770751" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770751">Johan Commelin (Apr 27 2018 at 11:52)</a>:</h4>
<p>And maybe then we are happy?</p>

<a name="125770752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770752" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770752">Scott Morrison (Apr 27 2018 at 11:52)</a>:</h4>
<p>So... which functions <code>F : Type × ... × Type → Type</code> extend to endofunctors of <code>Equiv</code> (the category of types and equivalences)?</p>

<a name="125770754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770754" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770754">Kevin Buzzard (Apr 27 2018 at 11:52)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span>

<span class="kn">theorem</span> <span class="n">over_optimistic</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">equiv</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
<span class="n">equiv</span> <span class="o">(</span><span class="n">F</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">F</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>

<a name="125770755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770755" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770755">Scott Morrison (Apr 27 2018 at 11:52)</a>:</h4>
<p>Most things I can think of...</p>

<a name="125770758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770758" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770758">Kenny Lau (Apr 27 2018 at 11:52)</a>:</h4>
<blockquote>
<p>Is this totally disgusting?</p>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">isom</span> <span class="o">(</span><span class="n">G</span> <span class="n">H</span> <span class="o">:</span> <span class="err">Σ</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">,</span> <span class="n">group</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">G</span><span class="bp">.</span><span class="mi">1</span> <span class="err">≃</span> <span class="n">H</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span>
<span class="o">(</span><span class="n">to_fun_hom</span> <span class="o">:</span> <span class="bp">@</span><span class="n">is_group_hom</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">G</span><span class="bp">.</span><span class="mi">2</span> <span class="n">H</span><span class="bp">.</span><span class="mi">2</span> <span class="n">f</span><span class="bp">.</span><span class="n">to_fun</span><span class="o">)</span>
<span class="o">(</span><span class="n">inv_fun_hom</span> <span class="o">:</span> <span class="bp">@</span><span class="n">is_group_hom</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">H</span><span class="bp">.</span><span class="mi">2</span> <span class="n">G</span><span class="bp">.</span><span class="mi">2</span> <span class="n">f</span><span class="bp">.</span><span class="n">inv_fun</span><span class="o">)</span>

<span class="n">def</span> <span class="n">is_isom</span> <span class="o">(</span><span class="n">G</span> <span class="n">H</span> <span class="o">:</span> <span class="err">Σ</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">,</span> <span class="n">group</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">nonempty</span> <span class="o">(</span><span class="n">isom</span> <span class="n">G</span> <span class="n">H</span><span class="o">)</span>
</pre></div>


</blockquote>
<p>the last parameter is redundant</p>

<a name="125770760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770760" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770760">Kenny Lau (Apr 27 2018 at 11:52)</a>:</h4>
<p>proof: exercise for M1P2</p>

<a name="125770764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770764" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770764">Kevin Buzzard (Apr 27 2018 at 11:52)</a>:</h4>
<p>Chris -- I know it can be done! My point is that I should not be wasting my time having to do it!</p>

<a name="125770830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770830" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770830">Scott Morrison (Apr 27 2018 at 11:55)</a>:</h4>
<p>I need someone who actually groks type theory to give a counterexample to Kevin's <code>over_optimistic</code>. :-)</p>

<a name="125770836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770836" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770836">Kevin Buzzard (Apr 27 2018 at 11:55)</a>:</h4>
<p>So my <code>over_optimistic</code> question is a question for the CS people. Presumably that is not provable. I am very unfussed about you using any of Lean's axioms here. Is</p>

<a name="125770840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770840" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770840">Kevin Buzzard (Apr 27 2018 at 11:55)</a>:</h4>
<p>...yeah what Scott said</p>

<a name="125770845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770845" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770845">Kevin Buzzard (Apr 27 2018 at 11:55)</a>:</h4>
<p>The thing is that for the types I am most interested in when I am doing mathematics</p>

<a name="125770847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770847" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770847">Kevin Buzzard (Apr 27 2018 at 11:55)</a>:</h4>
<p>like groups and rings</p>

<a name="125770851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770851" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770851">Kevin Buzzard (Apr 27 2018 at 11:56)</a>:</h4>
<p>the proof is "it's trivial"</p>

<a name="125770891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770891" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770891">Scott Morrison (Apr 27 2018 at 11:56)</a>:</h4>
<p>(and lists and manifolds and braided monoidal categories)</p>

<a name="125770892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770892" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770892">Kevin Buzzard (Apr 27 2018 at 11:56)</a>:</h4>
<p>exactly</p>

<a name="125770897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770897" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770897">Kevin Buzzard (Apr 27 2018 at 11:57)</a>:</h4>
<p>I have run into a ridiculous issue in my schemes code and Kenny has dug me out of a hole with 70 lines of code which no human should have to write</p>

<a name="125770902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770902" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770902">Kevin Buzzard (Apr 27 2018 at 11:57)</a>:</h4>
<p>and indeed no mention is made of the argument in the stacks project</p>

<a name="125770903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770903" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770903">Kevin Buzzard (Apr 27 2018 at 11:57)</a>:</h4>
<p>which is written in ZFC</p>

<a name="125770905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770905" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770905">Kevin Buzzard (Apr 27 2018 at 11:57)</a>:</h4>
<p>This is an area where translation to DTT seems hard</p>

<a name="125770949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770949" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770949">Kevin Buzzard (Apr 27 2018 at 11:58)</a>:</h4>
<p>currently</p>

<a name="125770951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770951" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770951">Kevin Buzzard (Apr 27 2018 at 11:58)</a>:</h4>
<p>I have some "canonically isomorphic" objects</p>

<a name="125770954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770954" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770954">Kevin Buzzard (Apr 27 2018 at 11:58)</a>:</h4>
<p>and whilst I don't know what that means</p>

<a name="125770961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770961" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770961">Johan Commelin (Apr 27 2018 at 11:59)</a>:</h4>
<p>Hmmmz where is <code>left_inverse</code> defined again?</p>

<a name="125770962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770962" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770962">Scott Morrison (Apr 27 2018 at 11:59)</a>:</h4>
<p>I fear that someone is about to come along and say: "HoTT!"</p>

<a name="125770966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770966" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770966">Johan Commelin (Apr 27 2018 at 11:59)</a>:</h4>
<p>Yes, I was about to do that</p>

<a name="125770974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770974" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770974">Johan Commelin (Apr 27 2018 at 11:59)</a>:</h4>
<p>For 30 minutes I had the urge to say that I think this is <em>exactly</em> what Voevodsky tried to solve. His answer was HoTT</p>

<a name="125770976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125770976" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125770976">Scott Morrison (Apr 27 2018 at 11:59)</a>:</h4>
<p>Voevodsky said things like: "the point is you can actually say what you mean by transport of structure"...</p>

<a name="125771023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771023" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771023">Kenny Lau (Apr 27 2018 at 12:00)</a>:</h4>
<blockquote>
<p>Hmmmz where is <code>left_inverse</code> defined again?</p>
</blockquote>
<p>ctrl shift f</p>

<a name="125771039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771039" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771039">Kevin Buzzard (Apr 27 2018 at 12:01)</a>:</h4>
<p>I do know that from the fact that they are all canonically isomorphic that I can prove all the hypotheses in Kenny's theorem</p>

<a name="125771040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771040" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771040">Kevin Buzzard (Apr 27 2018 at 12:01)</a>:</h4>
<p>Kenny has taken the problem down one level</p>

<a name="125771041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771041" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771041">Kevin Buzzard (Apr 27 2018 at 12:01)</a>:</h4>
<p>there is a really weird part of the argument actually, which is worth mentioning here and is evidence to suggest that I am living in a dream world.</p>

<a name="125771042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771042" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771042">Kevin Buzzard (Apr 27 2018 at 12:01)</a>:</h4>
<p>I have B canonically isomorphic to B' (I have the maps)</p>

<a name="125771043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771043" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771043">Kevin Buzzard (Apr 27 2018 at 12:01)</a>:</h4>
<p>I have A canonically isomorphic to A' (in the sense that I have a structure which is an approximation to such a thing, and will do for now)</p>

<a name="125771044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771044" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771044">Kevin Buzzard (Apr 27 2018 at 12:01)</a>:</h4>
<p>but the proofs are going to be really tedious</p>

<a name="125771048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771048" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771048">Kevin Buzzard (Apr 27 2018 at 12:01)</a>:</h4>
<p>and I can prove that the diagram commutes</p>

<a name="125771087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771087" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771087">Kevin Buzzard (Apr 27 2018 at 12:02)</a>:</h4>
<p>my chat is being garbled</p>

<a name="125771098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771098" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771098">Scott Morrison (Apr 27 2018 at 12:02)</a>:</h4>
<p>(So which bits are by Kenny, and which by "Kevin"? :-)</p>

<a name="125771103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771103" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771103">Kevin Buzzard (Apr 27 2018 at 12:02)</a>:</h4>
<p>but one of the arguments that it commutes is : ring hom x is the same as ring hom x' because they're both the unique ring hom</p>

<a name="125771104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771104" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771104">Kevin Buzzard (Apr 27 2018 at 12:03)</a>:</h4>
<p>and similarly ring hom y = ring hom y'</p>

<a name="125771111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771111" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771111">Kevin Buzzard (Apr 27 2018 at 12:03)</a>:</h4>
<p>and now we deduce that group hom x+y equals group hom x'+y'</p>

<a name="125771114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771114" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771114">Kevin Buzzard (Apr 27 2018 at 12:03)</a>:</h4>
<p>not from the universal property itself, in some sense</p>

<a name="125771116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771116" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771116">Kevin Buzzard (Apr 27 2018 at 12:04)</a>:</h4>
<p>well, from some shadow of the universal property applied to +</p>

<a name="125771226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771226" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771226">Scott Morrison (Apr 27 2018 at 12:06)</a>:</h4>
<p>Does anyone know how things like <code>@[derive decidable_eq]</code> work?</p>

<a name="125771235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771235" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771235">Scott Morrison (Apr 27 2018 at 12:07)</a>:</h4>
<p>Perhaps we can have <code>@[derive transportable]</code>, so when you write</p>

<a name="125771245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771245" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771245">Scott Morrison (Apr 27 2018 at 12:07)</a>:</h4>
<div class="codehilite"><pre><span></span>@[derive transportable]
structure Scheme (a : Type) := ...
</pre></div>

<a name="125771290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771290" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771290">Scott Morrison (Apr 27 2018 at 12:08)</a>:</h4>
<p>we automatically get an instance of <code>transportable Scheme</code>, which just means Scheme is functorial w.r.t equiv.</p>

<a name="125771300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771300" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771300">Johan Commelin (Apr 27 2018 at 12:09)</a>:</h4>
<p>That was what I was hinting at with the [endofunctor] annotations</p>

<a name="125771303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771303" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771303">Johan Commelin (Apr 27 2018 at 12:09)</a>:</h4>
<p>But: I don't know lean...</p>

<a name="125771306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771306" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771306">Scott Morrison (Apr 27 2018 at 12:09)</a>:</h4>
<p>ah, I see!</p>

<a name="125771310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771310" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771310">Scott Morrison (Apr 27 2018 at 12:09)</a>:</h4>
<p>Good suggestion. :-)</p>

<a name="125771311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771311" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771311">Johan Commelin (Apr 27 2018 at 12:09)</a>:</h4>
<p>Well, your suggestion is clearly more fleshed out.</p>

<a name="125771358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771358" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771358">Sebastian Ullrich (Apr 27 2018 at 12:10)</a>:</h4>
<p><span class="user-mention" data-user-id="110524">@Scott Morrison</span> Take a look at <a href="https://github.com/leanprover/lean/blob/f59c2f0ef59fdc1833b6ead6adca721123bd7932/library/init/meta/derive.lean#L19-L22" target="_blank" title="https://github.com/leanprover/lean/blob/f59c2f0ef59fdc1833b6ead6adca721123bd7932/library/init/meta/derive.lean#L19-L22">https://github.com/leanprover/lean/blob/f59c2f0ef59fdc1833b6ead6adca721123bd7932/library/init/meta/derive.lean#L19-L22</a></p>

<a name="125771419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771419" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771419">Johan Commelin (Apr 27 2018 at 12:12)</a>:</h4>
<blockquote>
<p>we automatically get an instance of <code>transportable Scheme</code>, which just means Scheme is functorial w.r.t equiv.</p>
</blockquote>
<p>In other words, that <code>over_optimistic Scheme</code> is a theorem, right?</p>

<a name="125771433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771433" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771433">Scott Morrison (Apr 27 2018 at 12:13)</a>:</h4>
<p>Well, even more than just <code>over_optimistic Scheme</code>.</p>

<a name="125771479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771479" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771479">Scott Morrison (Apr 27 2018 at 12:14)</a>:</h4>
<p>We want to know that the <code>equiv</code>s  you get at the <code>Scheme</code> level compose in the same way they did on the original types.</p>

<a name="125771491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771491" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771491">Kevin Buzzard (Apr 27 2018 at 12:14)</a>:</h4>
<p>So let's not jump the gun -- can you prove if A equiv B then a ring on A gives a ring on B?</p>

<a name="125771503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771503" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771503">Kenny Lau (Apr 27 2018 at 12:15)</a>:</h4>
<p>in 70 lines?</p>

<a name="125771507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771507" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771507">Kevin Buzzard (Apr 27 2018 at 12:15)</a>:</h4>
<p>:-)</p>

<a name="125771513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771513" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771513">Kevin Buzzard (Apr 27 2018 at 12:15)</a>:</h4>
<p>Kenny I'm sure you could do it in ten</p>

<a name="125771516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771516" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771516">Scott Morrison (Apr 27 2018 at 12:16)</a>:</h4>
<p>Sure we can do it on <code>ring</code>, or any given example. (Or rather: Kenny can :-)</p>

<a name="125771559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771559" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771559">Kevin Buzzard (Apr 27 2018 at 12:16)</a>:</h4>
<p>I mean</p>

<a name="125771560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771560" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771560">Scott Morrison (Apr 27 2018 at 12:16)</a>:</h4>
<p>but it seems rather likely that the computer can do it too, by looking at the structure fields, and working out where the parameter types appear, and plugging appropriate copies of the equivalence or its inverse everywhere.</p>

<a name="125771565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771565" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771565">Kevin Buzzard (Apr 27 2018 at 12:16)</a>:</h4>
<p>right</p>

<a name="125771569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771569" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771569">Scott Morrison (Apr 27 2018 at 12:17)</a>:</h4>
<p>For many simple types (list, ring, ...) this is certainly going to work.</p>

<a name="125771573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771573" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771573">Kevin Buzzard (Apr 27 2018 at 12:17)</a>:</h4>
<p>I mean "prove it without ploughing through the axioms"</p>

<a name="125771584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771584" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771584">Scott Morrison (Apr 27 2018 at 12:17)</a>:</h4>
<p>You mean ploughing through the axioms of "ring"?</p>

<a name="125771586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771586" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771586">Kevin Buzzard (Apr 27 2018 at 12:17)</a>:</h4>
<p>yes, I want a one-line proof</p>

<a name="125771624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771624" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771624">Kevin Buzzard (Apr 27 2018 at 12:18)</a>:</h4>
<p>that if A equiv B then a ring structure on A gives one on B</p>

<a name="125771629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771629" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771629">Kevin Buzzard (Apr 27 2018 at 12:18)</a>:</h4>
<p>does that exist?</p>

<a name="125771631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771631" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771631">Kevin Buzzard (Apr 27 2018 at 12:18)</a>:</h4>
<p>Could it be a tactic?</p>

<a name="125771632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771632" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771632">Scott Morrison (Apr 27 2018 at 12:18)</a>:</h4>
<p>No, I think in general there just isn't a one-line proof, that would work unchanged if your substituted ring for group.</p>

<a name="125771633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771633" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771633">Kevin Buzzard (Apr 27 2018 at 12:18)</a>:</h4>
<p>Is it already a theorem?</p>

<a name="125771634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771634" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771634">Scott Morrison (Apr 27 2018 at 12:18)</a>:</h4>
<p>but yes, it can easily be a tactic</p>

<a name="125771636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771636" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771636">Kevin Buzzard (Apr 27 2018 at 12:18)</a>:</h4>
<p>and the tactic would sometimes fail?</p>

<a name="125771637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771637" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771637">Scott Morrison (Apr 27 2018 at 12:19)</a>:</h4>
<p>and it can be one that's easy to use: just add @[derive transportable] in front of every structure.</p>

<a name="125771643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771643" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771643">Scott Morrison (Apr 27 2018 at 12:19)</a>:</h4>
<p>and yes, conceivably it might sometime fail, but I don't see where yet</p>

<a name="125771644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771644" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771644">Kevin Buzzard (Apr 27 2018 at 12:19)</a>:</h4>
<p>I have no understanding at all the moment anyone says <code>transportable</code></p>

<a name="125771653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771653" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771653">Scott Morrison (Apr 27 2018 at 12:19)</a>:</h4>
<p>(In fact, I'm really upset that I don't see where it might fail. I'll buy anyone a beer who explains a counterexample to Kevin's <code>over_optimistic</code> :-)</p>

<a name="125771654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771654" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771654">Scott Morrison (Apr 27 2018 at 12:20)</a>:</h4>
<p>Sorry, I made up the word <code>transportable</code> just now.</p>

<a name="125771695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771695" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771695">Kenny Lau (Apr 27 2018 at 12:20)</a>:</h4>
<p>heh?</p>

<a name="125771702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771702" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771702">Kenny Lau (Apr 27 2018 at 12:20)</a>:</h4>
<p>I mean, f can send int to empty and nat to unit</p>

<a name="125771703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771703" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771703">Scott Morrison (Apr 27 2018 at 12:20)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>, do you understand what I mean by "the category of types and equivalences"?</p>

<a name="125771706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771706" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771706">Kenny Lau (Apr 27 2018 at 12:20)</a>:</h4>
<p>so int and nat are equivalent but empty and unit are not</p>

<a name="125771709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771709" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771709">Kevin Buzzard (Apr 27 2018 at 12:20)</a>:</h4>
<p>not yet</p>

<a name="125771711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771711" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771711">Kevin Buzzard (Apr 27 2018 at 12:20)</a>:</h4>
<p>Maybe I do understand</p>

<a name="125771712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771712" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771712">Kevin Buzzard (Apr 27 2018 at 12:20)</a>:</h4>
<p>Are the objects all in one universe?</p>

<a name="125771719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771719" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771719">Scott Morrison (Apr 27 2018 at 12:21)</a>:</h4>
<p>But Kenny, how would you actually construct such an <code>f</code> in Lean?</p>

<a name="125771721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771721" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771721">Johan Commelin (Apr 27 2018 at 12:21)</a>:</h4>
<p><span class="user-mention" data-user-id="110524">@Scott Morrison</span> Just write down the definition of <code>structure transportable (F : Type* \to Type*)</code></p>

<a name="125771725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771725" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771725">Johan Commelin (Apr 27 2018 at 12:21)</a>:</h4>
<p>/me has never written a structure in Lean before, otherwise he would do it</p>

<a name="125771726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771726" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771726">Johan Commelin (Apr 27 2018 at 12:21)</a>:</h4>
<p>Or should it be a class?</p>

<a name="125771767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771767" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771767">Johan Commelin (Apr 27 2018 at 12:22)</a>:</h4>
<p>So that <code>@[derive]</code> will automagically create instances of that class</p>

<a name="125771784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771784" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771784">Johan Commelin (Apr 27 2018 at 12:23)</a>:</h4>
<p>/me goes back to TPIL</p>

<a name="125771827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771827" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771827">Scott Morrison (Apr 27 2018 at 12:24)</a>:</h4>
<div class="codehilite"><pre><span></span>class transportable (f : Type u → Type u) :=
(on_equiv : Π {α β : Type u} (e : equiv α β), equiv (f α) (f β))
(on_refl  : Π (α : Type u), on_equiv (equiv.refl α) = equiv.refl (f α))
(on_trans : Π {α β γ : Type u} (d : equiv α β) (e : equiv β γ), on_equiv (equiv.trans d e) = equiv.trans (on_equiv d) (on_equiv e))
</pre></div>

<a name="125771839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771839" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771839">Scott Morrison (Apr 27 2018 at 12:25)</a>:</h4>
<p>and I claim that <span class="user-mention" data-user-id="110026">@Simon Hudon</span> knows how to implement @[derive transportable] for many type constructors. :-)</p>

<a name="125771889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771889" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771889">Johan Commelin (Apr 27 2018 at 12:27)</a>:</h4>
<p>Yes, that would be very cool</p>

<a name="125771933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771933" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771933">Scott Morrison (Apr 27 2018 at 12:28)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>, this is just saying we have a category which I'll call <code>Equiv</code>, whose objects are <code>Type u</code> for some universe <code>u</code>, and the homs between <code>\a</code> and <code>\b</code> are just <code>equiv \a \b</code>. Then a function  <code>f : Type u -&gt; Type u</code> is "transportable" exactly if it extends to a functor <code>Equiv \to Equiv</code> (i.e. <code>f</code> is what that functor does on objects).</p>

<a name="125771950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771950" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771950">Johan Commelin (Apr 27 2018 at 12:29)</a>:</h4>
<p>Can we have different universes?</p>

<a name="125771951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771951" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771951">Scott Morrison (Apr 27 2018 at 12:29)</a>:</h4>
<p>sure.</p>

<a name="125771952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771952" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771952">Johan Commelin (Apr 27 2018 at 12:29)</a>:</h4>
<p>In other words, <code>f</code> need not be "strictly endo"</p>

<a name="125771964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125771964" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125771964">Scott Morrison (Apr 27 2018 at 12:30)</a>:</h4>
<p>(It's important that all the universes in classes are visible in the class parameters, but here they would be visible in the parameter <code>f : Type u -&gt; Type v</code>.)</p>

<a name="125772036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125772036" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125772036">Scott Morrison (Apr 27 2018 at 12:31)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>  --- I'm not at all sure if this is useful. It may be saying simple things in complicated ways, that don't actually solve your problems. But perhaps it does. (And if it does, I'm guessing automatically generating instances of <code>transportable</code> could be achieved within a few days (/weeks if Simon doesn't want to help :-)).</p>

<a name="125772091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125772091" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125772091">Johan Commelin (Apr 27 2018 at 12:33)</a>:</h4>
<blockquote>
<div class="codehilite"><pre><span></span><span class="kn">instance</span> <span class="n">group_of_equiv</span> <span class="o">[</span><span class="n">group</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">canonically_isomorphic</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">group</span> <span class="n">β</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>


</blockquote>
<p>It would solve things like this, if I'm not mistaken</p>

<a name="125772095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125772095" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125772095">Simon Hudon (Apr 27 2018 at 12:33)</a>:</h4>
<blockquote>
<p>and I claim that <span class="user-mention" data-user-id="110026">@Simon Hudon</span> knows how to implement @[derive transportable] for many type constructors. :-)</p>
</blockquote>
<p>Do you have a proof of that?</p>

<a name="125772098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125772098" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125772098">Johan Commelin (Apr 27 2018 at 12:33)</a>:</h4>
<p>Yes, you are working on it</p>

<a name="125772141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125772141" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125772141">Scott Morrison (Apr 27 2018 at 12:34)</a>:</h4>
<p>:-)</p>

<a name="125772144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125772144" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125772144">Johan Commelin (Apr 27 2018 at 12:34)</a>:</h4>
<p>And it seems that you get a beer if you can prove that you can't do it in one go...</p>

<a name="125772149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125772149" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125772149">Scott Morrison (Apr 27 2018 at 12:35)</a>:</h4>
<p>(Sorry, I don't mean to say things like this to pressure you into doing things. Just to express my gratitude for all your recent help! No good deed goes unpunished...)</p>

<a name="125772211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125772211" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125772211">Johan Commelin (Apr 27 2018 at 12:36)</a>:</h4>
<p>Learning how to write tactics and such is on my todo list</p>

<a name="125772214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125772214" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125772214">Johan Commelin (Apr 27 2018 at 12:36)</a>:</h4>
<p>But I first need to get two papers out of the door...</p>

<a name="125772215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125772215" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125772215">Simon Hudon (Apr 27 2018 at 12:36)</a>:</h4>
<p>(Haha! No worries! Can people hear us when we whisper in here?)</p>

<a name="125772225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125772225" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125772225">Simon Hudon (Apr 27 2018 at 12:37)</a>:</h4>
<p>Yeah and writing tutorials about it is on mine</p>

<a name="125772269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125772269" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125772269">Simon Hudon (Apr 27 2018 at 12:38)</a>:</h4>
<p>I can look into it. I still don't know much about <code>derive</code> but I need to understand it for <code>traversable</code>. I can kill two birds with one stone</p>

<a name="125772286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125772286" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125772286">Chris Hughes (Apr 27 2018 at 12:39)</a>:</h4>
<p>Would it help to make everything isomorphic to a type a type class, and then prove things about the class of isomorphic types? Might be completely stupid.</p>

<a name="125772496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125772496" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125772496">Johan Commelin (Apr 27 2018 at 12:44)</a>:</h4>
<p>Well, you loose track of different isomorphisms between the same to types</p>

<a name="125772500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125772500" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125772500">Johan Commelin (Apr 27 2018 at 12:44)</a>:</h4>
<p>And that will create trouble down the road, I guess</p>

<a name="125773177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125773177" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125773177">Simon Hudon (Apr 27 2018 at 13:03)</a>:</h4>
<p>Type classes are really better when instances are unique. Lean does not enforce that idea but conceptually, if the type class is not unique, the instance is an implicit argument everywhere but the exact choice of instance makes a big difference.</p>

<a name="125773186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125773186" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125773186">Simon Hudon (Apr 27 2018 at 13:03)</a>:</h4>
<p>It's like you're omitting a central piece of information every time</p>

<a name="125773189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125773189" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125773189">Johan Commelin (Apr 27 2018 at 13:03)</a>:</h4>
<p>But for Scott's proposal, that would be the case, right?</p>

<a name="125773404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125773404" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125773404">Simon Hudon (Apr 27 2018 at 13:09)</a>:</h4>
<p>You mean the instance would be unique?</p>

<a name="125773683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125773683" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125773683">Johan Commelin (Apr 27 2018 at 13:16)</a>:</h4>
<p>I think so</p>

<a name="125773687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125773687" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125773687">Johan Commelin (Apr 27 2018 at 13:16)</a>:</h4>
<p>You derive an instance, right.</p>

<a name="125773694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125773694" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125773694">Johan Commelin (Apr 27 2018 at 13:16)</a>:</h4>
<p>So there is only one of them. And people just shouldn't define additional instances</p>

<a name="125773760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125773760" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125773760">Simon Hudon (Apr 27 2018 at 13:18)</a>:</h4>
<p>What if other instances could be useful?</p>

<a name="125773770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125773770" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125773770">Simon Hudon (Apr 27 2018 at 13:18)</a>:</h4>
<p>Sorry, I'm kind of jumping in the middle here so I'm missing some context</p>

<a name="125773771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125773771" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125773771">Johan Commelin (Apr 27 2018 at 13:18)</a>:</h4>
<p>Hmm, we only want to use the fact that the class is inhabited</p>

<a name="125773775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125773775" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125773775">Johan Commelin (Apr 27 2018 at 13:18)</a>:</h4>
<p>Ok, so this is the thing</p>

<a name="125773782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125773782" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125773782">Simon Hudon (Apr 27 2018 at 13:19)</a>:</h4>
<p>Is it meant to be used with type constructors like <code>list</code>?</p>

<a name="125773783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125773783" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125773783">Johan Commelin (Apr 27 2018 at 13:19)</a>:</h4>
<p>Say you have two types. <code>A</code> and <code>B</code></p>

<a name="125773790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125773790" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125773790">Johan Commelin (Apr 27 2018 at 13:19)</a>:</h4>
<p>and you know that <code>A</code> is a group. You also know <code>equiv A B</code></p>

<a name="125773794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125773794" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125773794">Johan Commelin (Apr 27 2018 at 13:19)</a>:</h4>
<p>Then we would like to know that <code>B</code> is also a group.</p>

<a name="125773799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125773799" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125773799">Johan Commelin (Apr 27 2018 at 13:19)</a>:</h4>
<p>And we want Lean to do this for us.</p>

<a name="125773858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125773858" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125773858">Johan Commelin (Apr 27 2018 at 13:20)</a>:</h4>
<p>So, after lots of discussions, Scott came up with a strategy.</p>

<a name="125773864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125773864" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125773864">Johan Commelin (Apr 27 2018 at 13:20)</a>:</h4>
<p>We define a class <code>transportable</code> (or some other name, but mathematicians know this fact as "transport of structure")</p>

<a name="125773868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125773868" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125773868">Johan Commelin (Apr 27 2018 at 13:21)</a>:</h4>
<p>And we tag lots of definitions with <code>@[derive transportable]</code></p>

<a name="125773873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125773873" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125773873">Johan Commelin (Apr 27 2018 at 13:21)</a>:</h4>
<p>And then, MAGIC!</p>

<a name="125773886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125773886" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125773886">Johan Commelin (Apr 27 2018 at 13:21)</a>:</h4>
<p>In particular, you can only derive transportable for things of type <code>Type u \to Type v</code></p>

<a name="125773944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125773944" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125773944">Simon Hudon (Apr 27 2018 at 13:22)</a>:</h4>
<p>In this case, that would be <code>group</code>, right?</p>

<a name="125773947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125773947" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125773947">Johan Commelin (Apr 27 2018 at 13:22)</a>:</h4>
<p>And if <code>f</code> and <code>g</code> are two things that are <code>transportable</code>, then we want <code>(f,g)</code> to also be transportable, by some fact that we hope <em>you</em> can prove</p>

<a name="125773955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125773955" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125773955">Johan Commelin (Apr 27 2018 at 13:22)</a>:</h4>
<p>Right, <code>group</code>, <code>ring</code> etc should be examples</p>

<a name="125773969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125773969" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125773969">Simon Hudon (Apr 27 2018 at 13:23)</a>:</h4>
<p>I see, I see. That actually seems like a good use of classes</p>

<a name="125773978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125773978" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125773978">Johan Commelin (Apr 27 2018 at 13:23)</a>:</h4>
<p>and if something is defined as a <code>structure</code>, hopefully we can also derive this from how its built.</p>

<a name="125773986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125773986" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125773986">Simon Hudon (Apr 27 2018 at 13:24)</a>:</h4>
<p>I'll look into doing that. If I could have a use case, that would help a lot</p>

<a name="125774035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125774035" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125774035">Johan Commelin (Apr 27 2018 at 13:24)</a>:</h4>
<p>And so we only need some really basic things where we actually <em>prove</em> that we have an instance. The rest is done by <code>derive</code> and <em>us</em> putting annotations in mathlib.</p>

<a name="125774046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125774046" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125774046">Johan Commelin (Apr 27 2018 at 13:25)</a>:</h4>
<p><span class="user-mention" data-user-id="110524">@Scott Morrison</span> Is that a faithful representation of your ideas?</p>

<a name="125774143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125774143" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125774143">Johan Commelin (Apr 27 2018 at 13:27)</a>:</h4>
<p><span class="user-mention" data-user-id="110026">@Simon Hudon</span> The use case is that Kevin is now facing a goal that would follow from this (and probably tomorrow he has another dozen). A mathematician would spend at most 3 words to "prove" such a fact. Kenny needed 70 lines to prove this particular goal of Kevin. But a variant of that goal can pop up any time.</p>

<a name="125774155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125774155" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125774155">Scott Morrison (Apr 27 2018 at 13:27)</a>:</h4>
<p>Here's a mockup of what we want:</p>
<div class="codehilite"><pre><span></span>class canonical_equiv (α : Sort*) (β : Sort*) extends equiv α β.

class transportable (f : Type u → Type u) :=
(on_equiv : Π {α β : Type u} (e : equiv α β), equiv (f α) (f β))
(on_refl  : Π (α : Type u), on_equiv (equiv.refl α) = equiv.refl (f α))
(on_trans : Π {α β γ : Type u} (d : equiv α β) (e : equiv β γ), on_equiv (equiv.trans d e) = equiv.trans (on_equiv d) (on_equiv e))

-- Finally a command like: `initialize_transport group` would create the next two declarations automagically:

def group.transportable : transportable group := sorry
instance group.transport {α β : Type u} [R : group α] [e : canonical_equiv α β] : group β := (@transportable.on_equiv group group.transportable _ _ e.to_equiv).to_fun R
</pre></div>

<a name="125774206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125774206" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125774206">Scott Morrison (Apr 27 2018 at 13:28)</a>:</h4>
<p>The challenge is to implement the command <code>initialize_transport</code> (sounds like Star Trek! :-)</p>

<a name="125774254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125774254" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125774254">Scott Morrison (Apr 27 2018 at 13:29)</a>:</h4>
<p>It will need to inspect its argument, which will be something like <code>ring</code> or <code>list</code>, and create an instance of <code>transportable ring</code> or <code>transportable list</code>, etc.</p>

<a name="125774269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125774269" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125774269">Scott Morrison (Apr 27 2018 at 13:30)</a>:</h4>
<p>(i.e. fill in the <code>sorry</code> above)</p>

<a name="125774306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125774306" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125774306">Scott Morrison (Apr 27 2018 at 13:30)</a>:</h4>
<p>The final step of <code>initialize_transport</code> is trivial: just emit the final instance declaration above.</p>

<a name="125774314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125774314" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125774314">Johan Commelin (Apr 27 2018 at 13:30)</a>:</h4>
<p>Right, so <code>initialize_transport</code> (or <code>derive_transportable</code>) would look at <code>group</code> and say, oh, I know how to transport <code>mul</code> and <code>inv</code> and <code>one</code> from <code>A</code> to <code>B</code></p>

<a name="125774315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125774315" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125774315">Scott Morrison (Apr 27 2018 at 13:31)</a>:</h4>
<p>Exactly.</p>

<a name="125774323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125774323" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125774323">Johan Commelin (Apr 27 2018 at 13:31)</a>:</h4>
<p>Because those are just functions... and someone told me how to do that</p>

<a name="125774325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125774325" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125774325">Scott Morrison (Apr 27 2018 at 13:31)</a>:</h4>
<p>I don't have a strong sense of how hard that it. :-)</p>

<a name="125774327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125774327" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125774327">Simon Hudon (Apr 27 2018 at 13:31)</a>:</h4>
<p>Nice idea :)</p>

<a name="125774336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125774336" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125774336">Simon Hudon (Apr 27 2018 at 13:31)</a>:</h4>
<p>I think keep it as my treat today between writing sessions</p>

<a name="125774337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125774337" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125774337">Scott Morrison (Apr 27 2018 at 13:31)</a>:</h4>
<p>But basically the thing you hand to <code>initialize_transport</code> will usually just be some inductive type</p>

<a name="125774338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125774338" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125774338">Johan Commelin (Apr 27 2018 at 13:31)</a>:</h4>
<p>And then there are the axioms, and it should be able to transport their proof as well...</p>

<a name="125774379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125774379" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125774379">Scott Morrison (Apr 27 2018 at 13:32)</a>:</h4>
<p>(e.g. a structure)</p>

<a name="125774383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125774383" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125774383">Johan Commelin (Apr 27 2018 at 13:32)</a>:</h4>
<p>And now you want to "inductively" deduce that almost everything a mathematician like Kevin would define is an example of <code>transportable</code></p>

<a name="125774407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125774407" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125774407">Scott Morrison (Apr 27 2018 at 13:33)</a>:</h4>
<p>Yes: more advanced versions of <code>initialize_transport</code> will probably do some induction: notice that internal features have already been provided with instance of transportable, and make sure of that.</p>

<a name="125774420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125774420" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125774420">Scott Morrison (Apr 27 2018 at 13:33)</a>:</h4>
<p>I should sleep, but I'll try to think of examples of wanting to do that while I sleep. :-)</p>

<a name="125774470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125774470" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125774470">Simon Hudon (Apr 27 2018 at 13:34)</a>:</h4>
<p>Awesome! That sounds like sweet dreams</p>

<a name="125775365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125775365" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125775365">Johan Commelin (Apr 27 2018 at 13:56)</a>:</h4>
<p>Here are some more basics. But I think you already got the idea.</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span>

<span class="n">class</span> <span class="n">transportable</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">on_equiv</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">equiv</span> <span class="n">α</span> <span class="n">β</span><span class="o">),</span> <span class="n">equiv</span> <span class="o">(</span><span class="n">f</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">β</span><span class="o">))</span>
<span class="o">(</span><span class="n">on_refl</span>  <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">),</span> <span class="n">on_equiv</span> <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">refl</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">refl</span> <span class="o">(</span><span class="n">f</span> <span class="n">α</span><span class="o">))</span>
<span class="o">(</span><span class="n">on_trans</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">equiv</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">equiv</span> <span class="n">β</span> <span class="n">γ</span><span class="o">),</span> <span class="n">on_equiv</span> <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">trans</span> <span class="n">d</span> <span class="n">e</span><span class="o">)</span> <span class="bp">=</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">on_equiv</span> <span class="n">d</span><span class="o">)</span> <span class="o">(</span><span class="n">on_equiv</span> <span class="n">e</span><span class="o">))</span>

<span class="c1">-- Our goal is an automagic proof of the following</span>
<span class="kn">theorem</span> <span class="n">group</span><span class="bp">.</span><span class="n">transportable</span> <span class="o">:</span> <span class="n">transportable</span> <span class="n">group</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="c1">-- These we might need to define and prove by hand</span>
<span class="n">def</span> <span class="n">Const</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span><span class="o">,</span> <span class="n">punit</span>
<span class="n">def</span> <span class="n">Fun</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span> <span class="n">β</span><span class="o">,</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span>
<span class="n">def</span> <span class="n">Prod</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span> <span class="n">β</span><span class="o">,</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">β</span>
<span class="n">def</span> <span class="n">Swap</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span> <span class="n">β</span><span class="o">,</span> <span class="n">β</span> <span class="bp">×</span> <span class="n">α</span>

<span class="kn">lemma</span> <span class="n">Const</span><span class="bp">.</span><span class="n">transportable</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">transportable</span> <span class="n">Const</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kn">lemma</span> <span class="n">Fun</span><span class="bp">.</span><span class="n">transportable</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">transportable</span> <span class="o">(</span><span class="n">Fun</span> <span class="n">α</span><span class="o">))</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kn">lemma</span> <span class="n">Prod</span><span class="bp">.</span><span class="n">transportable</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">transportable</span> <span class="o">(</span><span class="n">Prod</span> <span class="n">α</span><span class="o">))</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kn">lemma</span> <span class="n">Swap</span><span class="bp">.</span><span class="n">transportable</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">transportable</span> <span class="o">(</span><span class="n">Swap</span> <span class="n">α</span><span class="o">))</span> <span class="o">:=</span> <span class="n">sorry</span>


<span class="c1">-- And then we can define</span>
<span class="n">def</span> <span class="n">Hom1</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">β</span><span class="o">,</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span>
<span class="n">def</span> <span class="n">Hom2</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span><span class="o">,</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span>
<span class="n">def</span> <span class="n">Aut</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span><span class="o">,</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span>

<span class="c1">-- And hopefully automagically derive</span>
<span class="kn">lemma</span> <span class="n">Hom1</span><span class="bp">.</span><span class="n">transportable</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">transportable</span> <span class="o">(</span><span class="n">Hom1</span> <span class="n">α</span><span class="o">))</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kn">lemma</span> <span class="n">Hom2</span><span class="bp">.</span><span class="n">transportable</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">transportable</span> <span class="o">(</span><span class="n">Hom1</span> <span class="n">β</span><span class="o">))</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kn">lemma</span> <span class="n">Aut</span><span class="bp">.</span><span class="n">transportable</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">transportable</span> <span class="n">Aut</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="c1">-- If we have all these in place...</span>
<span class="c1">-- A bit of magic might actually be able to derive `group.transportable` on line 11.</span>
<span class="c1">-- After all, a group just is a type plus some functions... and we can now transport functions.</span>
</pre></div>

<a name="125775387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125775387" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125775387">Johan Commelin (Apr 27 2018 at 13:57)</a>:</h4>
<p>Aah, and to prove the axioms for the transported functions, we need to be able to transport propositions</p>

<a name="125775647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125775647" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125775647">Simon Hudon (Apr 27 2018 at 14:02)</a>:</h4>
<p>Thanks! Transporting propositions shouldn't be too hard. I have a few ideas on how to do it</p>

<a name="125775719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125775719" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125775719">Simon Hudon (Apr 27 2018 at 14:04)</a>:</h4>
<p>With my recent popularity, maybe I should cash in on this new market: <a href="/user_uploads/3121/boyZ4T9BeLmq-lWnSs0tiqdb/IMG_8067.jpeg" target="_blank" title="IMG_8067.jpeg">IMG_8067.jpeg</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/boyZ4T9BeLmq-lWnSs0tiqdb/IMG_8067.jpeg" target="_blank" title="IMG_8067.jpeg"><img src="/user_uploads/3121/boyZ4T9BeLmq-lWnSs0tiqdb/IMG_8067.jpeg"></a></div>

<a name="125779148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125779148" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125779148">Kevin Buzzard (Apr 27 2018 at 15:27)</a>:</h4>
<p>I have proved the fundamental theorem of <code>has_mul</code></p>

<a name="125779150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125779150" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125779150">Kevin Buzzard (Apr 27 2018 at 15:27)</a>:</h4>
<p>What a great way to spend a day.</p>

<a name="125779199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125779199" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125779199">Kenny Lau (Apr 27 2018 at 15:28)</a>:</h4>
<p>what is that theorem?</p>

<a name="125779205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125779205" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125779205">Kevin Buzzard (Apr 27 2018 at 15:28)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">universe</span> <span class="n">zfc_u</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">zfc_u</span><span class="o">}</span>

<span class="c1">-- ideas around the concept of α being canonically isomorphic to β</span>

<span class="kn">namespace</span> <span class="n">zfc</span>

<span class="c1">-- mod of equiv so I can save typing</span>
<span class="kn">structure</span> <span class="n">equiv&#39;</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">zfc_u</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">zfc_u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">i</span>    <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>
<span class="o">(</span><span class="n">j</span>    <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">ij</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">j</span> <span class="o">(</span><span class="n">i</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">ji</span>  <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">β</span><span class="o">),</span> <span class="n">i</span> <span class="o">(</span><span class="n">j</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span>

<span class="c1">-- it&#39;s equiv to equiv, it is absolutely fundamental for the notion of canonical isomorphism, and I like</span>
<span class="c1">-- the notation better because it gets everywhere.</span>

<span class="c1">--#print has_mul</span>
<span class="c1">--@[class]</span>
<span class="c1">--structure has_mul : Type u → Type u</span>
<span class="c1">--fields:</span>
<span class="c1">--has_mul.mul : Π {α : Type u} [c : has_mul α], α → α → α</span>

<span class="c1">-- Fundamental theorem of has_mul</span>

<span class="c1">--#print prefix has_mul -- stuff</span>
<span class="c1">--set_option pp.notation false</span>
<span class="kn">definition</span> <span class="n">equiv_mul</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">zfc_u</span><span class="o">}</span> <span class="o">:</span> <span class="n">equiv&#39;</span> <span class="n">α</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">equiv&#39;</span> <span class="o">(</span><span class="n">has_mul</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">has_mul</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">E</span><span class="o">,</span>
<span class="o">{</span> <span class="n">i</span> <span class="o">:=</span>  <span class="bp">λ</span> <span class="n">αmul</span><span class="o">,</span><span class="bp">⟨λ</span> <span class="n">b1</span> <span class="n">b2</span><span class="o">,</span> <span class="n">E</span><span class="bp">.</span><span class="n">i</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_mul</span><span class="bp">.</span><span class="n">mul</span> <span class="n">α</span> <span class="n">αmul</span> <span class="o">(</span><span class="n">E</span><span class="bp">.</span><span class="n">j</span> <span class="n">b1</span><span class="o">)</span> <span class="o">(</span><span class="n">E</span><span class="bp">.</span><span class="n">j</span> <span class="n">b2</span><span class="o">))</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">j</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">βmul</span><span class="o">,</span><span class="bp">⟨λ</span> <span class="n">a1</span> <span class="n">a2</span><span class="o">,</span> <span class="n">E</span><span class="bp">.</span><span class="n">j</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_mul</span><span class="bp">.</span><span class="n">mul</span> <span class="n">β</span> <span class="n">βmul</span> <span class="o">(</span><span class="n">E</span><span class="bp">.</span><span class="n">i</span> <span class="n">a1</span><span class="o">)</span> <span class="o">(</span><span class="n">E</span><span class="bp">.</span><span class="n">i</span> <span class="n">a2</span><span class="o">))</span><span class="bp">⟩</span><span class="o">,</span> <span class="c1">-- didn&#39;t I just write that?</span>
                                                                      <span class="c1">-- should we introduce E-dual?</span>
  <span class="n">ij</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="k">begin</span>
    <span class="n">cases</span> <span class="n">f</span><span class="o">,</span> <span class="c1">-- aargh why do I struggle</span>
    <span class="n">suffices</span> <span class="o">:</span>  <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a1</span> <span class="n">a2</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">E</span><span class="bp">.</span><span class="n">j</span> <span class="o">(</span><span class="n">E</span><span class="bp">.</span><span class="n">i</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">E</span><span class="bp">.</span><span class="n">j</span> <span class="o">(</span><span class="n">E</span><span class="bp">.</span><span class="n">i</span> <span class="n">a1</span><span class="o">))</span> <span class="o">(</span><span class="n">E</span><span class="bp">.</span><span class="n">j</span> <span class="o">(</span><span class="n">E</span><span class="bp">.</span><span class="n">i</span> <span class="n">a2</span><span class="o">)))))</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a1</span> <span class="n">a2</span><span class="o">,</span> <span class="n">f</span> <span class="n">a1</span> <span class="n">a2</span><span class="o">),</span>
      <span class="k">by</span> <span class="n">rw</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">funext</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">E</span><span class="bp">.</span><span class="n">ij</span><span class="o">,</span><span class="n">E</span><span class="bp">.</span><span class="n">ji</span><span class="o">],</span> <span class="c1">-- got there in the end</span>
  <span class="kn">end</span><span class="o">,</span>
  <span class="n">ji</span> <span class="o">:=</span> <span class="c1">-- I can&#39;t even do this in term mode so I just copy out the entire tactic mode proof again.</span>
 <span class="bp">λ</span> <span class="n">g</span><span class="o">,</span> <span class="k">begin</span>
    <span class="n">cases</span> <span class="n">g</span><span class="o">,</span> <span class="c1">-- aargh why do I struggle</span>
    <span class="n">suffices</span> <span class="o">:</span>  <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">b1</span> <span class="n">b2</span> <span class="o">:</span> <span class="n">β</span><span class="o">),</span> <span class="n">E</span><span class="bp">.</span><span class="n">i</span> <span class="o">(</span><span class="n">E</span><span class="bp">.</span><span class="n">j</span> <span class="o">(</span><span class="n">g</span> <span class="o">(</span><span class="n">E</span><span class="bp">.</span><span class="n">i</span> <span class="o">(</span><span class="n">E</span><span class="bp">.</span><span class="n">j</span> <span class="n">b1</span><span class="o">))</span> <span class="o">(</span><span class="n">E</span><span class="bp">.</span><span class="n">i</span> <span class="o">(</span><span class="n">E</span><span class="bp">.</span><span class="n">j</span> <span class="n">b2</span><span class="o">)))))</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">b1</span> <span class="n">b2</span><span class="o">,</span> <span class="n">g</span> <span class="n">b1</span> <span class="n">b2</span><span class="o">),</span>
      <span class="k">by</span> <span class="n">rw</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">funext</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">E</span><span class="bp">.</span><span class="n">ij</span><span class="o">,</span><span class="n">E</span><span class="bp">.</span><span class="n">ji</span><span class="o">],</span> <span class="c1">-- got there in the end</span>
  <span class="kn">end</span><span class="o">,</span> <span class="c1">-- didn&#39;t I just write that?</span>
<span class="o">}</span>
</pre></div>

<a name="125779217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125779217" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125779217">Kevin Buzzard (Apr 27 2018 at 15:28)</a>:</h4>
<p>it is <code>equiv_mul</code></p>

<a name="125779219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125779219" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125779219">Kevin Buzzard (Apr 27 2018 at 15:28)</a>:</h4>
<p>but it would be happily renamed</p>

<a name="125779251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125779251" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125779251">Kenny Lau (Apr 27 2018 at 15:29)</a>:</h4>
<p>that's quite interesting</p>

<a name="125779255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125779255" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125779255">Kevin Buzzard (Apr 27 2018 at 15:29)</a>:</h4>
<p><span class="user-mention" data-user-id="110026">@Simon Hudon</span> Can you see that I repeat every line of code twice?</p>

<a name="125779259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125779259" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125779259">Kevin Buzzard (Apr 27 2018 at 15:29)</a>:</h4>
<p>I have this vague idea that this is not best practice</p>

<a name="125779350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125779350" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125779350">Simon Hudon (Apr 27 2018 at 15:31)</a>:</h4>
<p>No, you're right. I think this should and could be derived automatically.</p>

<a name="125779523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125779523" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125779523">Kevin Buzzard (Apr 27 2018 at 15:35)</a>:</h4>
<blockquote>
<p>Would it help to make everything isomorphic to a type a type class, and then prove things about the class of isomorphic types? Might be completely stupid.</p>
</blockquote>
<p>I am just catching up with chat. I've been trying to work out some of these proofs by hand.</p>

<a name="125779529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125779529" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125779529">Kevin Buzzard (Apr 27 2018 at 15:35)</a>:</h4>
<p>That sounds like a really cool idea though</p>

<a name="125779575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125779575" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125779575">Kevin Buzzard (Apr 27 2018 at 15:36)</a>:</h4>
<p>By the way -- the reason I did <code>has_mul</code> is that there is another type class which I am targetting.</p>

<a name="125779576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125779576" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125779576">Kenny Lau (Apr 27 2018 at 15:36)</a>:</h4>
<blockquote>
<blockquote>
<p>Would it help to make everything isomorphic to a type a type class, and then prove things about the class of isomorphic types? Might be completely stupid.</p>
</blockquote>
<p>I am just catching up with chat. I've been trying to work out some of these proofs by hand.</p>
</blockquote>
<p>it's called cardinal</p>

<a name="125779586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125779586" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125779586">Kevin Buzzard (Apr 27 2018 at 15:36)</a>:</h4>
<p>:-)</p>

<a name="125779603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125779603" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125779603">Kevin Buzzard (Apr 27 2018 at 15:37)</a>:</h4>
<p>Is <code>cardinal</code> a far more useful object than I had realised?</p>

<a name="125779608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125779608" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125779608">Kenny Lau (Apr 27 2018 at 15:37)</a>:</h4>
<p>no</p>

<a name="125779610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125779610" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125779610">Kevin Buzzard (Apr 27 2018 at 15:37)</a>:</h4>
<p>:-)</p>

<a name="125779618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125779618" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125779618">Kevin Buzzard (Apr 27 2018 at 15:37)</a>:</h4>
<p>Kenny can you prove the fundamental theorem of ring?</p>

<a name="125779624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125779624" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125779624">Kenny Lau (Apr 27 2018 at 15:37)</a>:</h4>
<p>I can, but I won't</p>

<a name="125779628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125779628" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125779628">Kevin Buzzard (Apr 27 2018 at 15:37)</a>:</h4>
<p>how many lines would it take you</p>

<a name="125779631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125779631" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125779631">Kevin Buzzard (Apr 27 2018 at 15:37)</a>:</h4>
<p>the fundamental theorem of ring is a trivial result</p>

<a name="125779653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125779653" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125779653">Kevin Buzzard (Apr 27 2018 at 15:38)</a>:</h4>
<p>I wanna build a tactic :-)</p>

<a name="125779672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125779672" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125779672">Kenny Lau (Apr 27 2018 at 15:38)</a>:</h4>
<p>a ring has many structures, you know</p>

<a name="125779687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125779687" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125779687">Kevin Buzzard (Apr 27 2018 at 15:38)</a>:</h4>
<p>yeah and you solve them all with the same tactic</p>

<a name="125780187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125780187" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125780187">Kevin Buzzard (Apr 27 2018 at 15:48)</a>:</h4>
<p>rofl</p>

<a name="125780189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125780189" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125780189">Kenny Lau (Apr 27 2018 at 15:48)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span>

<span class="n">def</span> <span class="n">transport_ring</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="err">≃</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">ring</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">add</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">f</span><span class="bp">.</span><span class="n">symm</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">f</span><span class="bp">.</span><span class="n">symm</span> <span class="n">y</span><span class="o">),</span>
  <span class="n">zero</span> <span class="o">:=</span> <span class="n">f</span> <span class="mi">0</span><span class="o">,</span>
  <span class="n">neg</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="bp">-</span><span class="n">f</span><span class="bp">.</span><span class="n">symm</span> <span class="n">x</span><span class="o">),</span>
  <span class="n">mul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">f</span><span class="bp">.</span><span class="n">symm</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">f</span><span class="bp">.</span><span class="n">symm</span> <span class="n">y</span><span class="o">),</span>
  <span class="n">one</span> <span class="o">:=</span> <span class="n">f</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">add_assoc</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span><span class="bp">;</span> <span class="k">from</span> <span class="n">add_assoc</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">zero_add</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span><span class="bp">;</span> <span class="k">from</span> <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">apply_eq_iff_eq_inverse_apply</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="o">(</span><span class="n">zero_add</span> <span class="bp">_</span><span class="o">),</span>
  <span class="n">add_zero</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span><span class="bp">;</span> <span class="k">from</span> <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">apply_eq_iff_eq_inverse_apply</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="o">(</span><span class="n">add_zero</span> <span class="bp">_</span><span class="o">),</span>
  <span class="n">add_left_neg</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span><span class="bp">;</span> <span class="k">from</span> <span class="n">add_left_neg</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">add_comm</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span><span class="bp">;</span> <span class="k">from</span> <span class="n">add_comm</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">mul_assoc</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span><span class="bp">;</span> <span class="k">from</span> <span class="n">mul_assoc</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">one_mul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span><span class="bp">;</span> <span class="k">from</span> <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">apply_eq_iff_eq_inverse_apply</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="o">(</span><span class="n">one_mul</span> <span class="bp">_</span><span class="o">),</span>
  <span class="n">mul_one</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span><span class="bp">;</span> <span class="k">from</span> <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">apply_eq_iff_eq_inverse_apply</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="o">(</span><span class="n">mul_one</span> <span class="bp">_</span><span class="o">),</span>
  <span class="n">left_distrib</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span><span class="bp">;</span> <span class="k">from</span> <span class="n">left_distrib</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">right_distrib</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span><span class="bp">;</span> <span class="k">from</span> <span class="n">right_distrib</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="o">}</span>
</pre></div>

<a name="125780193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125780193" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125780193">Kevin Buzzard (Apr 27 2018 at 15:48)</a>:</h4>
<p>I have proved the fundamental theorem of mul</p>

<a name="125780198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125780198" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125780198">Kevin Buzzard (Apr 27 2018 at 15:49)</a>:</h4>
<p>and now I have to prove the fundamental theorem of add</p>

<a name="125780201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125780201" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125780201">Kenny Lau (Apr 27 2018 at 15:49)</a>:</h4>
<p>why would I do that</p>

<a name="125780202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125780202" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125780202">Kevin Buzzard (Apr 27 2018 at 15:49)</a>:</h4>
<p>but add is canonically isomorphic to mul</p>

<a name="125780203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125780203" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125780203">Kenny Lau (Apr 27 2018 at 15:49)</a>:</h4>
<p>I just said I won't</p>

<a name="125780204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125780204" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125780204">Kevin Buzzard (Apr 27 2018 at 15:49)</a>:</h4>
<p>I am doing it</p>

<a name="125780209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125780209" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125780209">Kenny Lau (Apr 27 2018 at 15:49)</a>:</h4>
<p>done 10 mins</p>

<a name="125780212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125780212" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125780212">Kevin Buzzard (Apr 27 2018 at 15:49)</a>:</h4>
<p>I just do a regular expression substitution</p>

<a name="125780213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125780213" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125780213">Kevin Buzzard (Apr 27 2018 at 15:49)</a>:</h4>
<p>and I have the fundamental theorem of add</p>

<a name="125780215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125780215" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125780215">Kenny Lau (Apr 27 2018 at 15:49)</a>:</h4>
<p>you win</p>

<a name="125780217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125780217" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125780217">Kevin Buzzard (Apr 27 2018 at 15:49)</a>:</h4>
<p>but I would rather have a tactic</p>

<a name="125780310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125780310" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125780310">Kenny Lau (Apr 27 2018 at 15:51)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span>
<span class="n">def</span> <span class="n">why_would_one</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">has_add</span> <span class="n">α</span> <span class="err">≃</span> <span class="n">has_mul</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">f</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">f</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">f</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">f</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">f</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">f</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">rfl</span> <span class="o">}</span>
</pre></div>

<a name="125780411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125780411" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125780411">Patrick Massot (Apr 27 2018 at 15:53)</a>:</h4>
<p>It reminds me of the situation with <a href="https://github.com/PatrickMassot/lean-differential-topology/commit/f47348abf8515e23bd485683d8b351c7fd89c70f#diff-bbdfb4d2f4b405102cb35c772afdd2cc" target="_blank" title="https://github.com/PatrickMassot/lean-differential-topology/commit/f47348abf8515e23bd485683d8b351c7fd89c70f#diff-bbdfb4d2f4b405102cb35c772afdd2cc">https://github.com/PatrickMassot/lean-differential-topology/commit/f47348abf8515e23bd485683d8b351c7fd89c70f#diff-bbdfb4d2f4b405102cb35c772afdd2cc</a> which was automated into <a href="https://github.com/leanprover/mathlib/blob/master/algebra/pi_instances.lean#L56" target="_blank" title="https://github.com/leanprover/mathlib/blob/master/algebra/pi_instances.lean#L56">https://github.com/leanprover/mathlib/blob/master/algebra/pi_instances.lean#L56</a></p>

<a name="125780413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125780413" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125780413">Patrick Massot (Apr 27 2018 at 15:54)</a>:</h4>
<p>So I'm pretty optimistic there will be a tactic</p>

<a name="125780457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125780457" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125780457">Patrick Massot (Apr 27 2018 at 15:54)</a>:</h4>
<p>What would be even better would be Simon getting tired of writing our tactics and writing tactic writing tutorials instead</p>

<a name="125780460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125780460" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125780460">Kenny Lau (Apr 27 2018 at 15:54)</a>:</h4>
<p>aha</p>

<a name="125780466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125780466" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125780466">Kenny Lau (Apr 27 2018 at 15:54)</a>:</h4>
<p>Give a man a fish, and you feed him for a day; show him how to catch fish, and you feed him for a lifetime.</p>

<a name="125780685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125780685" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125780685">Kevin Buzzard (Apr 27 2018 at 15:59)</a>:</h4>
<p>I made an instance</p>

<a name="125780692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125780692" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125780692">Kevin Buzzard (Apr 27 2018 at 15:59)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">definition</span> <span class="n">mul_is_add</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">zfc_u</span><span class="o">}</span> <span class="o">:</span> <span class="n">equiv&#39;</span> <span class="o">(</span><span class="n">has_mul</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">has_add</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">i</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">mul</span><span class="bp">⟩</span><span class="o">,</span><span class="bp">⟨</span><span class="n">mul</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">j</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">mul</span><span class="bp">⟩</span><span class="o">,</span><span class="bp">⟨</span><span class="n">mul</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">ij</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">x</span><span class="bp">⟩</span><span class="o">,</span><span class="k">begin</span> <span class="c1">-- *sigh*</span>
    <span class="n">constructor</span><span class="o">,</span>
  <span class="kn">end</span> <span class="o">,</span>
  <span class="n">ji</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">z</span><span class="bp">⟩</span><span class="o">,</span> <span class="k">by</span> <span class="n">constructor</span>
<span class="o">}</span>
</pre></div>

<a name="125780697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125780697" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125780697">Kenny Lau (Apr 27 2018 at 15:59)</a>:</h4>
<p>but that's what I just did</p>

<a name="125780700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125780700" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125780700">Kevin Buzzard (Apr 27 2018 at 15:59)</a>:</h4>
<p>I am behind</p>

<a name="125780739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125780739" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125780739">Kevin Buzzard (Apr 27 2018 at 16:00)</a>:</h4>
<p>I am working it all out myself</p>

<a name="125780745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125780745" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125780745">Kenny Lau (Apr 27 2018 at 16:00)</a>:</h4>
<p>nice</p>

<a name="125780753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125780753" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125780753">Sean Leather (Apr 27 2018 at 16:00)</a>:</h4>
<blockquote>
<p>Give a man a fish, and you feed him for a day; show him how to catch fish, and you feed him for a lifetime.</p>
</blockquote>
<p>Unless there is no body of water nearby...</p>

<a name="125780788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125780788" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125780788">Kevin Buzzard (Apr 27 2018 at 16:01)</a>:</h4>
<p>OK Kenny, well done on ring. My next challenge for you is <code>topological_field</code></p>

<a name="125780794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125780794" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125780794">Kenny Lau (Apr 27 2018 at 16:01)</a>:</h4>
<p>nope.</p>

<a name="125780796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125780796" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125780796">Kevin Buzzard (Apr 27 2018 at 16:01)</a>:</h4>
<p>and it's a challenge to Simon as well</p>

<a name="125780910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125780910" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125780910">Kevin Buzzard (Apr 27 2018 at 16:03)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span>

<span class="n">def</span> <span class="n">transport_ring</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_field</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="err">≃</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">topological_field</span> <span class="n">β</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>

<a name="125780912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125780912" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125780912">Kevin Buzzard (Apr 27 2018 at 16:03)</a>:</h4>
<p>Who will win out of man and machine</p>

<a name="125780962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125780962" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125780962">Kevin Buzzard (Apr 27 2018 at 16:04)</a>:</h4>
<p>and I am sitting here in ZFC and remarking that it is trivial</p>

<a name="125781022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125781022" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125781022">Kevin Buzzard (Apr 27 2018 at 16:06)</a>:</h4>
<p>Aah Kenny I just saw your has_mul</p>

<a name="125781063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125781063" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125781063">Kevin Buzzard (Apr 27 2018 at 16:06)</a>:</h4>
<p>well I proved the fundamental theorem of has_mul before</p>

<a name="125781069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125781069" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125781069">Kevin Buzzard (Apr 27 2018 at 16:06)</a>:</h4>
<p>so can you now deduce the fundamental theorem of has_add?</p>

<a name="125781632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125781632" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125781632">Andrew Ashworth (Apr 27 2018 at 16:20)</a>:</h4>
<p>did you take a look at the <code>transfer</code> paper I linked way back? That's how in core lean they move proofs between <code>int</code> and <code>(a , b) : nat * nat</code>, which (and maybe I'm not understanding the details here very well) is your problem of transporting proofs between isomorphic types?</p>

<a name="125781815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125781815" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125781815">Andrew Ashworth (Apr 27 2018 at 16:26)</a>:</h4>
<p>also as far as I can tell from my (limited) experience with hott; isomorphisms are just as hard to deal with as they are in dtt, there's no magic sauce rewriting. you can try reading <a href="https://github.com/cmu-phil/Spectral" target="_blank" title="https://github.com/cmu-phil/Spectral">https://github.com/cmu-phil/Spectral</a>, which is a lean repository about the Serre spectral sequence</p>

<a name="125781820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125781820" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125781820">Andrew Ashworth (Apr 27 2018 at 16:26)</a>:</h4>
<p>I have no idea what a spectral sequence might be, but you can see that dealing with isomorphisms is no easier from reading the source code...</p>

<a name="125781905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125781905" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125781905">Kevin Buzzard (Apr 27 2018 at 16:29)</a>:</h4>
<p>Kenny I thought of a much easier challenge for you</p>

<a name="125781906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125781906" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125781906">Kevin Buzzard (Apr 27 2018 at 16:29)</a>:</h4>
<p><a href="https://github.com/kbuzzard/xena/tree/master/canonical_isomorphism" target="_blank" title="https://github.com/kbuzzard/xena/tree/master/canonical_isomorphism">https://github.com/kbuzzard/xena/tree/master/canonical_isomorphism</a></p>

<a name="125781909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125781909" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125781909">Kevin Buzzard (Apr 27 2018 at 16:29)</a>:</h4>
<p>much less boring than topological fields</p>

<a name="125781965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125781965" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125781965">Kevin Buzzard (Apr 27 2018 at 16:30)</a>:</h4>
<p>can you define <code>mul_to_add</code> at the bottom?</p>

<a name="125781997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125781997" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125781997">Mario Carneiro (Apr 27 2018 at 16:31)</a>:</h4>
<p>The <code>over_optimistic</code> theorem is a weak form of univalence. To see how they are related, just plug in <code>eq A</code> for the function <code>F</code>; then <code>A = A</code> is equiv to <code>A = B</code> and hence the latter is also inhabited. It is currently an open question whether this theorem is consistent with lean, but I believe it to be. (It is inconsistent with VM evaluation though.)</p>
<p>The second part of this conversation has developed a plan for showing that even if you can't prove that all functions are functorial, you might be able to show that all definable functions are functorial by working in the metatheory (i.e. giving a tactic that produces the required term). It is not contradictory that it might be possible that all lean definable terms are functorial in an appropriate sense even if you can't prove it for <em>all</em> terms, as the internal theory understands the quantifier. So this is not a "proof or counterexample" kind of question.</p>
<p>This topic is usually known in the type theory literature as "parametricity", and it is on my todo list for my paper.</p>

<a name="125782104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125782104" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125782104">Kevin Buzzard (Apr 27 2018 at 16:34)</a>:</h4>
<p><code>definition mul_to_add {α β : Type} : equiv' α β → equiv' (has_add α) (has_add β) := sorry</code></p>

<a name="125782105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125782105" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125782105">Johan Commelin (Apr 27 2018 at 16:34)</a>:</h4>
<p>Right, so we are kind of proposing a pragmatic approach to HoTT and univalence</p>

<a name="125782114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125782114" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125782114">Johan Commelin (Apr 27 2018 at 16:35)</a>:</h4>
<p>Kevin, did you see Scott's proposal for a class + decorators?</p>

<a name="125782122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125782122" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125782122">Johan Commelin (Apr 27 2018 at 16:35)</a>:</h4>
<p>I think you won't need to prove any of these "fundamental theorems" anymore, once we get that implemented</p>

<a name="125782181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125782181" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125782181">Kevin Buzzard (Apr 27 2018 at 16:37)</a>:</h4>
<p>So in layman's terms, when can I expect a three-line proof of <code>exact_sequence A B C -&gt; exact_sequence A' B' C'</code> which is just three rewrites?</p>

<a name="125782183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125782183" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125782183">Kevin Buzzard (Apr 27 2018 at 16:37)</a>:</h4>
<p>I would be very happy to work on such a thing</p>

<a name="125782184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125782184" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125782184">Kevin Buzzard (Apr 27 2018 at 16:37)</a>:</h4>
<p>because I really want it :-)</p>

<a name="125782188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125782188" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125782188">Kevin Buzzard (Apr 27 2018 at 16:37)</a>:</h4>
<p>Can I incorporate Scott's proposal into my proofs somehow?</p>

<a name="125782195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125782195" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125782195">Kevin Buzzard (Apr 27 2018 at 16:38)</a>:</h4>
<p>Or is Scott's code purely for someone who is writing a tactic?</p>

<a name="125782232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125782232" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125782232">Kevin Buzzard (Apr 27 2018 at 16:38)</a>:</h4>
<p>I just find these quite fun and satisfying to do by hand, and I feel like if I try to get really good at them</p>

<a name="125782238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125782238" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125782238">Kevin Buzzard (Apr 27 2018 at 16:38)</a>:</h4>
<p>then I might understand better how to write a tactic which is doing some of the job for me</p>

<a name="125782248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125782248" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125782248">Kevin Buzzard (Apr 27 2018 at 16:39)</a>:</h4>
<p>I would be very happy if anyone wanted to comment on <a href="https://github.com/kbuzzard/xena/blob/master/canonical_isomorphism/canonically_isomorphic.lean" target="_blank" title="https://github.com/kbuzzard/xena/blob/master/canonical_isomorphism/canonically_isomorphic.lean">https://github.com/kbuzzard/xena/blob/master/canonical_isomorphism/canonically_isomorphic.lean</a></p>

<a name="125782252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125782252" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125782252">Kevin Buzzard (Apr 27 2018 at 16:39)</a>:</h4>
<p>I would really like to get some canonical proofs.</p>

<a name="125782255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125782255" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125782255">Kevin Buzzard (Apr 27 2018 at 16:39)</a>:</h4>
<p>Kenny can you beat any of mine?</p>

<a name="125782394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125782394" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125782394">Johan Commelin (Apr 27 2018 at 16:43)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> No, we can't use Scott's proposal yet. The idea is that someone proves inductively the <em>universal</em> fundamental theorem for structures (or probably: inductive types). And then we only need to prove the fundamental theorem for some basic types and we will get all the others for free.</p>

<a name="125782443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125782443" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125782443">Johan Commelin (Apr 27 2018 at 16:44)</a>:</h4>
<p>And it seems like Simon thought this was interesting, and might try to implement it pretty soon.</p>

<a name="125782446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125782446" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125782446">Kevin Buzzard (Apr 27 2018 at 16:44)</a>:</h4>
<p>Can you formalise what you think the universal fundamental theorem is?</p>

<a name="125782448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125782448" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125782448">Johan Commelin (Apr 27 2018 at 16:44)</a>:</h4>
<p>Hmm, I don't know enough lean yet.</p>

<a name="125782453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125782453" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125782453">Johan Commelin (Apr 27 2018 at 16:45)</a>:</h4>
<p>Actually, no.</p>

<a name="125782457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125782457" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125782457">Kevin Buzzard (Apr 27 2018 at 16:45)</a>:</h4>
<p>Can <span class="user-mention" data-user-id="110524">@Scott Morrison</span> or <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> ?</p>

<a name="125782461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125782461" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125782461">Kevin Buzzard (Apr 27 2018 at 16:45)</a>:</h4>
<p>Is there some kind of conjecture we can make?</p>

<a name="125782462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125782462" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125782462">Kevin Buzzard (Apr 27 2018 at 16:45)</a>:</h4>
<p>and give a constructive proof?</p>

<a name="125782464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125782464" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125782464">Johan Commelin (Apr 27 2018 at 16:45)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> The idea is that we "tag" every structure for which we want to prove it. And then actually Lean does it itself.</p>

<a name="125782466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125782466" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125782466">Kevin Buzzard (Apr 27 2018 at 16:45)</a>:</h4>
<p>so like the type class inference machinery?</p>

<a name="125782467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125782467" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125782467">Johan Commelin (Apr 27 2018 at 16:45)</a>:</h4>
<p>This is what the <code>@[derive transportable]</code> should do</p>

<a name="125782510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125782510" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125782510">Kevin Buzzard (Apr 27 2018 at 16:46)</a>:</h4>
<p>so can one formulate some theorem which should be true for every...something...which is tagged with this tag?</p>

<a name="125782511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125782511" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125782511">Johan Commelin (Apr 27 2018 at 16:46)</a>:</h4>
<p>Lean will see that you are defining some <code>structure</code> and for all its fields it already knows that they are transportable. And thus it proves a theorem for the new structure as well.</p>

<a name="125782512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125782512" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125782512">Kevin Buzzard (Apr 27 2018 at 16:46)</a>:</h4>
<p>In Lean, I mean?</p>

<a name="125782514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125782514" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125782514">Kevin Buzzard (Apr 27 2018 at 16:46)</a>:</h4>
<p>What will the theorem be?</p>

<a name="125782516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125782516" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125782516">Johan Commelin (Apr 27 2018 at 16:47)</a>:</h4>
<p>Yes. That theorem is your <code>over_optimistic</code></p>

<a name="125782521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125782521" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125782521">Kevin Buzzard (Apr 27 2018 at 16:47)</a>:</h4>
<p>I see.</p>

<a name="125782526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125782526" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125782526">Kevin Buzzard (Apr 27 2018 at 16:47)</a>:</h4>
<p>And we should be able to prove it for all F tagged with some tag</p>

<a name="125782527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125782527" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125782527">Kevin Buzzard (Apr 27 2018 at 16:47)</a>:</h4>
<p>...automatically?</p>

<a name="125782528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125782528" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125782528">Johan Commelin (Apr 27 2018 at 16:47)</a>:</h4>
<p>Well, not <em>we</em> but even Lean</p>

<a name="125782529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125782529" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125782529">Johan Commelin (Apr 27 2018 at 16:47)</a>:</h4>
<p>After we taught it the ultimate basics.</p>

<a name="125782530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125782530" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125782530">Kevin Buzzard (Apr 27 2018 at 16:47)</a>:</h4>
<p>and this would be...a tactic?</p>

<a name="125782572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125782572" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125782572">Johan Commelin (Apr 27 2018 at 16:48)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> Again, I'm not a meta-expert. But basically, it will be an automatically applied tactic.</p>

<a name="125782573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125782573" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125782573">Johan Commelin (Apr 27 2018 at 16:48)</a>:</h4>
<p>This is what <code>derive</code> seems to do...</p>

<a name="125782580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125782580" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125782580">Johan Commelin (Apr 27 2018 at 16:49)</a>:</h4>
<p>But, I now I'm in waters that I don't really know</p>

<a name="125782587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125782587" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125782587">Kevin Buzzard (Apr 27 2018 at 16:49)</a>:</h4>
<p>I have been fretting over what canonical isomorphism means for many years now</p>

<a name="125782596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125782596" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125782596">Johan Commelin (Apr 27 2018 at 16:49)</a>:</h4>
<p>See also my snippet:<br>
<a href="#narrow/stream/113488-general/subject/.22canonically.22.20identifying.20two.20types/near/125775365" title="#narrow/stream/113488-general/subject/.22canonically.22.20identifying.20two.20types/near/125775365">https://leanprover.zulipchat.com/#narrow/stream/113488-general/subject/.22canonically.22.20identifying.20two.20types/near/125775365</a></p>

<a name="125782646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125782646" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125782646">Kevin Buzzard (Apr 27 2018 at 16:50)</a>:</h4>
<p><a href="https://mathoverflow.net/a/19663" target="_blank" title="https://mathoverflow.net/a/19663">https://mathoverflow.net/a/19663</a></p>

<a name="125782704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125782704" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125782704">Kenny Lau (Apr 27 2018 at 16:52)</a>:</h4>
<blockquote>
<p>Kenny can you beat any of mine?</p>
</blockquote>
<p><a href="https://github.com/kckennylau/Lean/blob/master/canonically_isomorphic.lean" target="_blank" title="https://github.com/kckennylau/Lean/blob/master/canonically_isomorphic.lean">https://github.com/kckennylau/Lean/blob/master/canonically_isomorphic.lean</a></p>

<a name="125782724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125782724" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125782724">Kevin Buzzard (Apr 27 2018 at 16:53)</a>:</h4>
<p>So is this <code>transportable</code> class some completely well-known and well-studied class in type theory?</p>

<a name="125782965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125782965" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125782965">Johan Commelin (Apr 27 2018 at 16:59)</a>:</h4>
<p>I think at least in <em>homotopy</em> type theory</p>

<a name="125783111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125783111" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125783111">Johan Commelin (Apr 27 2018 at 17:03)</a>:</h4>
<p>I like your MO answer</p>

<a name="125783470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125783470" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125783470">Kevin Buzzard (Apr 27 2018 at 17:13)</a>:</h4>
<p>How do I reduce this goal</p>
<div class="codehilite"><pre><span></span><span class="err">⊢</span> <span class="o">{</span><span class="n">to_fun</span> <span class="o">:=</span> <span class="n">A1</span><span class="o">,</span>
     <span class="n">inv_fun</span> <span class="o">:=</span> <span class="n">A2</span><span class="o">,</span>
     <span class="n">left_inv</span> <span class="o">:=</span> <span class="mi">3</span><span class="o">,</span>
     <span class="n">right_inv</span> <span class="o">:=</span> <span class="n">A4</span><span class="o">}</span> <span class="bp">=</span>
    <span class="o">{</span><span class="n">to_fun</span> <span class="o">:=</span> <span class="n">B1</span><span class="o">,</span> <span class="n">inv_fun</span> <span class="o">:=</span> <span class="n">B2</span><span class="o">,</span> <span class="n">left_inv</span> <span class="o">:=</span> <span class="n">B3</span><span class="o">,</span> <span class="n">right_inv</span> <span class="o">:=</span> <span class="n">B4</span><span class="o">}</span>
</pre></div>


<p>into the four goals <code>A1=B1</code>, <code>A2=B2</code> etc?</p>

<a name="125783473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125783473" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125783473">Kenny Lau (Apr 27 2018 at 17:13)</a>:</h4>
<p><code>congr</code></p>

<a name="125783548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125783548" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125783548">Patrick Massot (Apr 27 2018 at 17:15)</a>:</h4>
<blockquote>
<p>So in layman's terms, when can I expect a three-line proof of <code>exact_sequence A B C -&gt; exact_sequence A' B' C'</code> which is just three rewrites?</p>
</blockquote>
<p>What I'm going to write is not what you are hoping for, and unrelated to the big dreams of general transport of structures</p>

<a name="125783550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125783550" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125783550">Patrick Massot (Apr 27 2018 at 17:15)</a>:</h4>
<p>But I still think it's useful</p>

<a name="125783589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125783589" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125783589">Patrick Massot (Apr 27 2018 at 17:16)</a>:</h4>
<p>I spend most of my Lean time being frustrated by obvious statements, and then see Mario prove them</p>

<a name="125783597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125783597" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125783597">Kenny Lau (Apr 27 2018 at 17:16)</a>:</h4>
<blockquote>
<p>How do I reduce this goal</p>
<div class="codehilite"><pre><span></span><span class="err">⊢</span> <span class="o">{</span><span class="n">to_fun</span> <span class="o">:=</span> <span class="n">A1</span><span class="o">,</span>
     <span class="n">inv_fun</span> <span class="o">:=</span> <span class="n">A2</span><span class="o">,</span>
     <span class="n">left_inv</span> <span class="o">:=</span> <span class="mi">3</span><span class="o">,</span>
     <span class="n">right_inv</span> <span class="o">:=</span> <span class="n">A4</span><span class="o">}</span> <span class="bp">=</span>
    <span class="o">{</span><span class="n">to_fun</span> <span class="o">:=</span> <span class="n">B1</span><span class="o">,</span> <span class="n">inv_fun</span> <span class="o">:=</span> <span class="n">B2</span><span class="o">,</span> <span class="n">left_inv</span> <span class="o">:=</span> <span class="n">B3</span><span class="o">,</span> <span class="n">right_inv</span> <span class="o">:=</span> <span class="n">B4</span><span class="o">}</span>
</pre></div>


<p>into the four goals <code>A1=B1</code>, <code>A2=B2</code> etc?</p>
</blockquote>
<p>oh and that should be part of your interface</p>

<a name="125783603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125783603" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125783603">Patrick Massot (Apr 27 2018 at 17:16)</a>:</h4>
<p>In my experience, what happens is my mind refuses to decompose the statement and/or think about the proper setup</p>

<a name="125783609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125783609" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125783609">Patrick Massot (Apr 27 2018 at 17:16)</a>:</h4>
<p>Then Mario decomposes the problem into three or four lemmas and each of them is a one-liner</p>

<a name="125783626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125783626" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125783626">Patrick Massot (Apr 27 2018 at 17:17)</a>:</h4>
<p>So let me try a decomposition in your case</p>

<a name="125783679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125783679" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125783679">Patrick Massot (Apr 27 2018 at 17:18)</a>:</h4>
<p>I would define sequences of rings and maps between them (assuming we don't have an abelian categories lib right now).</p>

<a name="125783698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125783698" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125783698">Patrick Massot (Apr 27 2018 at 17:18)</a>:</h4>
<p>And the corresponding maps, ie sequences of maps with all squares commuting</p>

<a name="125783713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125783713" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125783713">Patrick Massot (Apr 27 2018 at 17:19)</a>:</h4>
<p>Then define complexes as sequences where two consecutive maps compose to zero</p>

<a name="125783772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125783772" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125783772">Patrick Massot (Apr 27 2018 at 17:20)</a>:</h4>
<p>prove isomorphic sequences have conjugated maps</p>

<a name="125783774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125783774" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125783774">Patrick Massot (Apr 27 2018 at 17:20)</a>:</h4>
<p>deduce a sequence isomorphic to a complex is a complex</p>

<a name="125783775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125783775" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125783775">Patrick Massot (Apr 27 2018 at 17:20)</a>:</h4>
<p>define homology of complexes</p>

<a name="125783782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125783782" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125783782">Patrick Massot (Apr 27 2018 at 17:20)</a>:</h4>
<p>define exact sequences as acyclic complexes</p>

<a name="125783788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125783788" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125783788">Patrick Massot (Apr 27 2018 at 17:21)</a>:</h4>
<p>prove isomorphic complexes have isomorphic homology</p>

<a name="125783798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125783798" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125783798">Patrick Massot (Apr 27 2018 at 17:21)</a>:</h4>
<p>deduce your lemma (and the version with n rings instead of only 3)</p>

<a name="125783804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125783804" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125783804">Patrick Massot (Apr 27 2018 at 17:21)</a>:</h4>
<p>I'm not saying the total number of lines will be 3</p>

<a name="125783846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125783846" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125783846">Patrick Massot (Apr 27 2018 at 17:22)</a>:</h4>
<p>But all those definitions and lemmas will be needed very soon anyway</p>

<a name="125783853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125783853" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125783853">Patrick Massot (Apr 27 2018 at 17:22)</a>:</h4>
<p>(with more definitions of course, especially homotopy equivalences and quasi-iso)</p>

<a name="125783920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125783920" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125783920">Patrick Massot (Apr 27 2018 at 17:24)</a>:</h4>
<p>You also want a lemma relating my definition of exact sequence to the direct one</p>

<a name="125783929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125783929" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125783929">Patrick Massot (Apr 27 2018 at 17:24)</a>:</h4>
<p>So, the proof of your lemma wouldn't by three <code>rw</code> by three <code>apply</code> (or one <code>simp</code> maybe)</p>

<a name="125783955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125783955" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125783955">Kenny Lau (Apr 27 2018 at 17:26)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">equiv&#39;</span><span class="bp">.</span><span class="n">ext</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">zfc_u</span><span class="o">}</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">{</span><span class="n">e₁</span> <span class="n">e₂</span> <span class="o">:</span> <span class="n">equiv&#39;</span> <span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">e₁</span><span class="bp">.</span><span class="n">i</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">e₂</span><span class="bp">.</span><span class="n">i</span> <span class="n">x</span><span class="o">),</span> <span class="n">e₁</span> <span class="bp">=</span> <span class="n">e₂</span>
<span class="bp">|</span> <span class="bp">⟨</span><span class="n">i₁</span><span class="o">,</span> <span class="n">j₁</span><span class="o">,</span> <span class="n">ij₁</span><span class="o">,</span> <span class="n">ji₁</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">i₂</span><span class="o">,</span> <span class="n">j₂</span><span class="o">,</span> <span class="n">ij₂</span><span class="o">,</span> <span class="n">ji₂</span><span class="bp">⟩</span> <span class="n">H</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">congr</span><span class="o">,</span> <span class="o">{</span> <span class="n">funext</span><span class="o">,</span> <span class="n">apply</span> <span class="n">H</span> <span class="o">},</span>
  <span class="n">simp</span> <span class="n">at</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">funext</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="err">←</span> <span class="n">ji₁</span> <span class="n">x</span><span class="o">,</span> <span class="n">ij₁</span><span class="o">,</span> <span class="n">H</span><span class="o">,</span> <span class="n">ij₂</span><span class="o">]</span>
<span class="kn">end</span>
</pre></div>

<a name="125783964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125783964" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125783964">Kenny Lau (Apr 27 2018 at 17:26)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span></p>

<a name="125784003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784003" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784003">Johan Commelin (Apr 27 2018 at 17:26)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> Sweet.</p>

<a name="125784017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784017" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784017">Kevin Buzzard (Apr 27 2018 at 17:27)</a>:</h4>
<p>I did Level 1 of Johan's level set!</p>

<a name="125784020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784020" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784020">Kenny Lau (Apr 27 2018 at 17:27)</a>:</h4>
<p>what level set?</p>

<a name="125784021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784021" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784021">Kevin Buzzard (Apr 27 2018 at 17:27)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="c1">-- level 1</span>
<span class="kn">lemma</span> <span class="n">Const</span><span class="bp">.</span><span class="n">transportable</span> <span class="o">:</span> <span class="o">(</span><span class="n">transportable</span> <span class="n">Const</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">on_equiv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span> <span class="n">β</span> <span class="n">H</span><span class="o">,</span><span class="bp">⟨λ</span> <span class="bp">_</span><span class="o">,</span><span class="n">punit</span><span class="bp">.</span><span class="n">star</span><span class="o">,</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span><span class="n">punit</span><span class="bp">.</span><span class="n">star</span><span class="o">,</span><span class="bp">λ</span> <span class="n">α</span><span class="o">,</span><span class="k">begin</span> <span class="n">cases</span> <span class="n">α</span><span class="o">,</span><span class="n">simp</span> <span class="kn">end</span><span class="o">,</span><span class="bp">λ</span> <span class="n">α</span><span class="o">,</span><span class="k">begin</span> <span class="n">cases</span> <span class="n">α</span><span class="o">,</span><span class="n">simp</span> <span class="kn">end</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="c1">--I was repeating myself in that last line.</span>
  <span class="n">on_refl</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span><span class="o">,</span><span class="k">begin</span>
  <span class="n">congr</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">funext</span> <span class="n">s</span><span class="o">,</span><span class="n">cases</span> <span class="n">s</span><span class="o">,</span><span class="n">refl</span><span class="o">},</span>
  <span class="o">{</span> <span class="n">funext</span> <span class="n">s</span><span class="o">,</span><span class="n">cases</span> <span class="n">s</span><span class="o">,</span><span class="n">refl</span><span class="o">}</span> <span class="c1">-- I just wrote this</span>
  <span class="kn">end</span><span class="o">,</span>
  <span class="n">on_trans</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="n">Hαβ</span> <span class="n">Hβγ</span><span class="o">,</span><span class="k">by</span> <span class="n">congr</span>
  <span class="o">}</span>
</pre></div>

<a name="125784073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784073" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784073">Johan Commelin (Apr 27 2018 at 17:28)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> <br>
<a href="#narrow/stream/113488-general/subject/.22canonically.22.20identifying.20two.20types/near/125775365" title="#narrow/stream/113488-general/subject/.22canonically.22.20identifying.20two.20types/near/125775365">https://leanprover.zulipchat.com/#narrow/stream/113488-general/subject/.22canonically.22.20identifying.20two.20types/near/125775365</a></p>

<a name="125784079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784079" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784079">Kevin Buzzard (Apr 27 2018 at 17:28)</a>:</h4>
<p>Patrick I think your proof is very different to Kenny's</p>

<a name="125784083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784083" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784083">Kevin Buzzard (Apr 27 2018 at 17:28)</a>:</h4>
<p>and I like it much better</p>

<a name="125784090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784090" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784090">Kenny Lau (Apr 27 2018 at 17:29)</a>:</h4>
<p>what is his proof?</p>

<a name="125784095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784095" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784095">Kevin Buzzard (Apr 27 2018 at 17:29)</a>:</h4>
<p>and I think that perhaps when Mario said earlier that Kenny should "work on his long game", maybe he meant thinking like this</p>

<a name="125784104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784104" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784104">Johan Commelin (Apr 27 2018 at 17:29)</a>:</h4>
<p>Well, I think we ultimately should have Patrick's idea and Scott's proposal work together.</p>

<a name="125784107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784107" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784107">Kevin Buzzard (Apr 27 2018 at 17:29)</a>:</h4>
<p>Kenny</p>

<a name="125784109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784109" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784109">Kevin Buzzard (Apr 27 2018 at 17:30)</a>:</h4>
<p>I put the levels up on xena</p>

<a name="125784161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784161" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784161">Johan Commelin (Apr 27 2018 at 17:30)</a>:</h4>
<p>In other words, a whole series of definitions, that are all tagged with <code>@[derive transport_of_structure]</code></p>

<a name="125784167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784167" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784167">Johan Commelin (Apr 27 2018 at 17:30)</a>:</h4>
<p>And then we get Kevin's requested lemma for free</p>

<a name="125784240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784240" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784240">Kevin Buzzard (Apr 27 2018 at 17:32)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> <a href="https://github.com/kbuzzard/xena/tree/master/canonical_isomorphism" target="_blank" title="https://github.com/kbuzzard/xena/tree/master/canonical_isomorphism">https://github.com/kbuzzard/xena/tree/master/canonical_isomorphism</a></p>

<a name="125784241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784241" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784241">Kevin Buzzard (Apr 27 2018 at 17:32)</a>:</h4>
<p>I am one ahead of you</p>

<a name="125784242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784242" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784242">Kenny Lau (Apr 27 2018 at 17:32)</a>:</h4>
<p>thx</p>

<a name="125784245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784245" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784245">Kevin Buzzard (Apr 27 2018 at 17:33)</a>:</h4>
<p>on the Johan challenge</p>

<a name="125784262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784262" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784262">Kevin Buzzard (Apr 27 2018 at 17:33)</a>:</h4>
<p><a href="https://github.com/kbuzzard/xena/blob/master/canonical_isomorphism/johan_challenge.lean" target="_blank" title="https://github.com/kbuzzard/xena/blob/master/canonical_isomorphism/johan_challenge.lean">https://github.com/kbuzzard/xena/blob/master/canonical_isomorphism/johan_challenge.lean</a></p>

<a name="125784265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784265" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784265">Kenny Lau (Apr 27 2018 at 17:33)</a>:</h4>
<p>and then <code>derive</code> will work?</p>

<a name="125784267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784267" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784267">Kenny Lau (Apr 27 2018 at 17:33)</a>:</h4>
<p>How does <code>derive</code> work?</p>

<a name="125784271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784271" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784271">Kevin Buzzard (Apr 27 2018 at 17:33)</a>:</h4>
<p>we have to work at the start</p>

<a name="125784272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784272" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784272">Kevin Buzzard (Apr 27 2018 at 17:33)</a>:</h4>
<p>and then the machines take over</p>

<a name="125784313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784313" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784313">Kevin Buzzard (Apr 27 2018 at 17:34)</a>:</h4>
<p>and then I can have a three line proof of the three lemma</p>

<a name="125784322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784322" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784322">Kevin Buzzard (Apr 27 2018 at 17:34)</a>:</h4>
<p>saying that if A -&gt; B -&gt; C is exact then A' -&gt; B' -&gt; C' is exact</p>

<a name="125784326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784326" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784326">Kevin Buzzard (Apr 27 2018 at 17:34)</a>:</h4>
<p>all I have to do is prove some diagrams commute</p>

<a name="125784328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784328" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784328">Kevin Buzzard (Apr 27 2018 at 17:34)</a>:</h4>
<p>and say that some things are canonically isomorphic</p>

<a name="125784330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784330" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784330">Kevin Buzzard (Apr 27 2018 at 17:34)</a>:</h4>
<p>which is obvious in ZFC</p>

<a name="125784346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784346" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784346">Kevin Buzzard (Apr 27 2018 at 17:35)</a>:</h4>
<p>Mathematicians will not use this software unless they can do stuff that they find easy in maths, in Lean</p>

<a name="125784350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784350" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784350">Kevin Buzzard (Apr 27 2018 at 17:35)</a>:</h4>
<p>and I thought that I enjoyed doing algebraic geometry in Lean</p>

<a name="125784351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784351" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784351">Kevin Buzzard (Apr 27 2018 at 17:35)</a>:</h4>
<p>until I ran into this issue</p>

<a name="125784352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784352" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784352">Kenny Lau (Apr 27 2018 at 17:35)</a>:</h4>
<p>I mean, the mechanism behind <code>@[derive __]</code></p>

<a name="125784397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784397" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784397">Kevin Buzzard (Apr 27 2018 at 17:36)</a>:</h4>
<p>Either Simon will write it</p>

<a name="125784399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784399" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784399">Kevin Buzzard (Apr 27 2018 at 17:36)</a>:</h4>
<p>or Scott will write it</p>

<a name="125784400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784400" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784400">Kevin Buzzard (Apr 27 2018 at 17:36)</a>:</h4>
<p>or I will have to write it</p>

<a name="125784401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784401" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784401">Kevin Buzzard (Apr 27 2018 at 17:36)</a>:</h4>
<p>with their help</p>

<a name="125784403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784403" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784403">Kevin Buzzard (Apr 27 2018 at 17:36)</a>:</h4>
<p>or you can write it</p>

<a name="125784404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784404" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784404">Kevin Buzzard (Apr 27 2018 at 17:36)</a>:</h4>
<p>or Chris</p>

<a name="125784414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784414" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784414">Kevin Buzzard (Apr 27 2018 at 17:36)</a>:</h4>
<p>Maybe it would be trivial for Mario, I have no idea</p>

<a name="125784416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784416" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784416">Kenny Lau (Apr 27 2018 at 17:36)</a>:</h4>
<p>you're this close from listing everyone's name</p>

<a name="125784419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784419" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784419">Kenny Lau (Apr 27 2018 at 17:36)</a>:</h4>
<p>this close.</p>

<a name="125784424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784424" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784424">Kevin Buzzard (Apr 27 2018 at 17:37)</a>:</h4>
<p>but I can certainly believe that the more easy levels we solve by hand</p>

<a name="125784430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784430" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784430">Kevin Buzzard (Apr 27 2018 at 17:37)</a>:</h4>
<p>the easier it will be to write the tactic</p>

<a name="125784434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784434" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784434">Kevin Buzzard (Apr 27 2018 at 17:37)</a>:</h4>
<p>and I really like solving these levels</p>

<a name="125784438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784438" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784438">Kevin Buzzard (Apr 27 2018 at 17:37)</a>:</h4>
<p>they're even better then Zelda</p>

<a name="125784445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784445" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784445">Kenny Lau (Apr 27 2018 at 17:37)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">class</span> <span class="n">transportable</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">on_equiv</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">equiv</span> <span class="n">α</span> <span class="n">β</span><span class="o">),</span> <span class="n">equiv</span> <span class="o">(</span><span class="n">f</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">β</span><span class="o">))</span>
<span class="o">(</span><span class="n">on_refl</span>  <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">),</span> <span class="n">on_equiv</span> <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">refl</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">refl</span> <span class="o">(</span><span class="n">f</span> <span class="n">α</span><span class="o">))</span>
<span class="o">(</span><span class="n">on_trans</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">equiv</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">equiv</span> <span class="n">β</span> <span class="n">γ</span><span class="o">),</span> <span class="n">on_equiv</span> <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">trans</span> <span class="n">d</span> <span class="n">e</span><span class="o">)</span> <span class="bp">=</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">on_equiv</span> <span class="n">d</span><span class="o">)</span> <span class="o">(</span><span class="n">on_equiv</span> <span class="n">e</span><span class="o">))</span>
</pre></div>

<a name="125784446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784446" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784446">Kenny Lau (Apr 27 2018 at 17:37)</a>:</h4>
<p>functor :D</p>

<a name="125784510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784510" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784510">Kenny Lau (Apr 27 2018 at 17:38)</a>:</h4>
<p>why no use symbol?</p>

<a name="125784511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784511" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784511">Johan Commelin (Apr 27 2018 at 17:38)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> <a href="https://github.com/leanprover/lean/blob/f59c2f0ef59fdc1833b6ead6adca721123bd7932/library/init/meta/derive.lean#L19-L22" target="_blank" title="https://github.com/leanprover/lean/blob/f59c2f0ef59fdc1833b6ead6adca721123bd7932/library/init/meta/derive.lean#L19-L22">https://github.com/leanprover/lean/blob/f59c2f0ef59fdc1833b6ead6adca721123bd7932/library/init/meta/derive.lean#L19-L22</a><br>
and also L44-L45</p>

<a name="125784584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784584" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784584">Johan Commelin (Apr 27 2018 at 17:40)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> It is indeed a functor, but only on equivalences. That is how Scott first defined it (informally). But I guess we might not want this def'n to depend on a category lib. The category lib probably wants to depend on transport of structure...</p>

<a name="125784596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784596" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784596">Johan Commelin (Apr 27 2018 at 17:40)</a>:</h4>
<p>By the way, I suggest a name for the tactic that proves transport of structure: <code>chuck_norris</code></p>

<a name="125784599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784599" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784599">Kevin Buzzard (Apr 27 2018 at 17:40)</a>:</h4>
<p>Kenny feel free to make the file a lot better</p>

<a name="125784606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784606" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784606">Kevin Buzzard (Apr 27 2018 at 17:41)</a>:</h4>
<p>+1 for <code>chuck_norris</code></p>

<a name="125784607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784607" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784607">Kevin Buzzard (Apr 27 2018 at 17:41)</a>:</h4>
<p>but I would be happy to hear alternatives</p>

<a name="125784613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784613" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784613">Kevin Buzzard (Apr 27 2018 at 17:41)</a>:</h4>
<p>One of the reasons people go on about <code>sledgehammer</code></p>

<a name="125784616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784616" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784616">Kevin Buzzard (Apr 27 2018 at 17:41)</a>:</h4>
<p>is that it has a really cool name</p>

<a name="125784617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784617" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784617">Kevin Buzzard (Apr 27 2018 at 17:41)</a>:</h4>
<p>and <code>crush</code> too</p>

<a name="125784621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784621" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784621">Kevin Buzzard (Apr 27 2018 at 17:41)</a>:</h4>
<p>I would vote for any Pokemon move name</p>

<a name="125784755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125784755" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125784755">Kenny Lau (Apr 27 2018 at 17:45)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">Const</span><span class="bp">.</span><span class="n">transportable</span> <span class="o">:</span> <span class="o">(</span><span class="n">transportable</span> <span class="n">Const</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">on_equiv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span> <span class="n">β</span> <span class="n">e</span><span class="o">,</span> <span class="bp">⟨λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">punit</span><span class="bp">.</span><span class="n">star</span><span class="o">,</span> <span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">punit</span><span class="bp">.</span><span class="n">star</span><span class="o">,</span> <span class="bp">λ</span> <span class="bp">⟨⟩</span><span class="o">,</span> <span class="n">rfl</span> <span class="o">,</span> <span class="bp">λ</span> <span class="bp">⟨⟩</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">on_refl</span>  <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span><span class="o">,</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">ext</span> <span class="bp">_</span> <span class="bp">_</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">⟨⟩</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">on_trans</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">,</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">ext</span> <span class="bp">_</span> <span class="bp">_</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">⟨⟩</span><span class="o">,</span> <span class="n">rfl</span> <span class="o">}</span>

<span class="kn">lemma</span> <span class="n">Fun</span><span class="bp">.</span><span class="n">transportable</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">transportable</span> <span class="o">(</span><span class="n">Fun</span> <span class="n">α</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">on_equiv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">β</span> <span class="n">γ</span> <span class="n">e</span><span class="o">,</span> <span class="bp">⟨λ</span> <span class="n">f</span> <span class="n">x</span><span class="o">,</span> <span class="n">e</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">),</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">x</span><span class="o">,</span> <span class="n">e</span><span class="bp">.</span><span class="n">symm</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">),</span>
    <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">funext</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">e</span><span class="bp">.</span><span class="n">inverse_apply_apply</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">),</span>
    <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">funext</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">e</span><span class="bp">.</span><span class="n">apply_inverse_apply</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">on_refl</span>  <span class="o">:=</span> <span class="bp">λ</span> <span class="n">β</span><span class="o">,</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">ext</span> <span class="bp">_</span> <span class="bp">_</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">on_trans</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">β</span> <span class="n">γ</span> <span class="n">δ</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">,</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">ext</span> <span class="bp">_</span> <span class="bp">_</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">rfl</span> <span class="o">}</span>
</pre></div>

<a name="125785025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125785025" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125785025">Kenny Lau (Apr 27 2018 at 17:52)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">prod</span><span class="bp">.</span><span class="n">ext&#39;</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">H1</span> <span class="o">:</span> <span class="n">p</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">=</span> <span class="n">q</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">H2</span> <span class="o">:</span> <span class="n">p</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">=</span> <span class="n">q</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">q</span> <span class="o">:=</span>
<span class="n">prod</span><span class="bp">.</span><span class="n">ext</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">⟨</span><span class="n">H1</span><span class="o">,</span> <span class="n">H2</span><span class="bp">⟩</span>

<span class="kn">lemma</span> <span class="n">Prod</span><span class="bp">.</span><span class="n">transportable</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">transportable</span> <span class="o">(</span><span class="n">Prod</span> <span class="n">α</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">on_equiv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">β</span> <span class="n">γ</span> <span class="n">e</span><span class="o">,</span> <span class="bp">⟨λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span> <span class="n">e</span> <span class="n">x</span><span class="bp">.</span><span class="mi">2</span><span class="o">),</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span> <span class="n">e</span><span class="bp">.</span><span class="n">symm</span> <span class="n">x</span><span class="bp">.</span><span class="mi">2</span><span class="o">),</span>
    <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">prod</span><span class="bp">.</span><span class="n">ext&#39;</span> <span class="n">rfl</span> <span class="err">$</span> <span class="n">e</span><span class="bp">.</span><span class="n">inverse_apply_apply</span> <span class="n">f</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
    <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">prod</span><span class="bp">.</span><span class="n">ext&#39;</span> <span class="n">rfl</span> <span class="err">$</span> <span class="n">e</span><span class="bp">.</span><span class="n">apply_inverse_apply</span> <span class="n">f</span><span class="bp">.</span><span class="mi">2</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">on_refl</span>  <span class="o">:=</span> <span class="bp">λ</span> <span class="n">β</span><span class="o">,</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">ext</span> <span class="bp">_</span> <span class="bp">_</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">prod</span><span class="bp">.</span><span class="n">ext&#39;</span> <span class="n">rfl</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">on_trans</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">β</span> <span class="n">γ</span> <span class="n">δ</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">,</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">ext</span> <span class="bp">_</span> <span class="bp">_</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">rfl</span> <span class="o">}</span>

<span class="kn">lemma</span> <span class="n">Swap</span><span class="bp">.</span><span class="n">transportable</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">transportable</span> <span class="o">(</span><span class="n">Swap</span> <span class="n">α</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">on_equiv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">β</span> <span class="n">γ</span> <span class="n">e</span><span class="o">,</span> <span class="bp">⟨λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">e</span> <span class="n">x</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span> <span class="n">x</span><span class="bp">.</span><span class="mi">2</span><span class="o">),</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">e</span><span class="bp">.</span><span class="n">symm</span> <span class="n">x</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span> <span class="n">x</span><span class="bp">.</span><span class="mi">2</span><span class="o">),</span>
    <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">prod</span><span class="bp">.</span><span class="n">ext&#39;</span> <span class="o">(</span><span class="n">e</span><span class="bp">.</span><span class="n">inverse_apply_apply</span> <span class="n">f</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span> <span class="n">rfl</span><span class="o">,</span>
    <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">prod</span><span class="bp">.</span><span class="n">ext&#39;</span> <span class="o">(</span><span class="n">e</span><span class="bp">.</span><span class="n">apply_inverse_apply</span> <span class="n">f</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">on_refl</span>  <span class="o">:=</span> <span class="bp">λ</span> <span class="n">β</span><span class="o">,</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">ext</span> <span class="bp">_</span> <span class="bp">_</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">prod</span><span class="bp">.</span><span class="n">ext&#39;</span> <span class="n">rfl</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">on_trans</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">β</span> <span class="n">γ</span> <span class="n">δ</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">,</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">ext</span> <span class="bp">_</span> <span class="bp">_</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">rfl</span> <span class="o">}</span>
</pre></div>

<a name="125785027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125785027" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125785027">Kenny Lau (Apr 27 2018 at 17:52)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span></p>

<a name="125785091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125785091" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125785091">Kenny Lau (Apr 27 2018 at 17:54)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">Hom1</span><span class="bp">.</span><span class="n">transportable</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">transportable</span> <span class="o">(</span><span class="n">Hom1</span> <span class="n">α</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">Fun</span><span class="bp">.</span><span class="n">transportable</span> <span class="n">α</span>
</pre></div>


<p>?</p>

<a name="125785192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125785192" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125785192">Kevin Buzzard (Apr 27 2018 at 17:56)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="c1">-- level 2</span>
<span class="kn">lemma</span> <span class="n">Fun</span><span class="bp">.</span><span class="n">transportable</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">transportable</span> <span class="o">(</span><span class="n">Fun</span> <span class="n">α</span><span class="o">))</span> <span class="o">:=</span> <span class="o">{</span>
    <span class="n">on_equiv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">β</span> <span class="n">γ</span> <span class="n">Hβγ</span><span class="o">,</span><span class="bp">⟨</span>
        <span class="bp">λ</span> <span class="n">f</span> <span class="n">a</span><span class="o">,</span><span class="n">Hβγ</span><span class="bp">.</span><span class="n">to_fun</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">),</span>
        <span class="bp">λ</span> <span class="n">f</span> <span class="n">a</span><span class="o">,</span><span class="n">Hβγ</span><span class="bp">.</span><span class="n">inv_fun</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">),</span>
        <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span><span class="k">by</span> <span class="n">funext</span> <span class="n">a</span><span class="bp">;</span><span class="n">exact</span> <span class="n">Hβγ</span><span class="bp">.</span><span class="n">left_inv</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">),</span>
        <span class="bp">λ</span> <span class="n">g</span><span class="o">,</span><span class="k">by</span> <span class="n">funext</span> <span class="n">a</span><span class="bp">;</span><span class="n">exact</span> <span class="n">Hβγ</span><span class="bp">.</span><span class="n">right_inv</span> <span class="o">(</span><span class="n">g</span> <span class="n">a</span><span class="o">)</span>
    <span class="bp">⟩</span><span class="o">,</span>
    <span class="n">on_refl</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">β</span><span class="o">,</span><span class="k">by</span> <span class="n">congr</span><span class="o">,</span>
    <span class="n">on_trans</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">β</span> <span class="n">γ</span> <span class="n">δ</span> <span class="n">Hβγ</span> <span class="n">Hγδ</span><span class="o">,</span><span class="k">by</span> <span class="n">congr</span>
<span class="o">}</span>
</pre></div>

<a name="125785196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125785196" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125785196">Kevin Buzzard (Apr 27 2018 at 17:57)</a>:</h4>
<p>I see you caught up :-)</p>

<a name="125785199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125785199" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125785199">Kenny Lau (Apr 27 2018 at 17:57)</a>:</h4>
<p>I'm faster :P</p>

<a name="125785256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125785256" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125785256">Kevin Buzzard (Apr 27 2018 at 17:58)</a>:</h4>
<p>Kenny you repeat yourself in your code</p>

<a name="125785259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125785259" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125785259">Kevin Buzzard (Apr 27 2018 at 17:58)</a>:</h4>
<p>you say most things twice</p>

<a name="125785261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125785261" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125785261">Kevin Buzzard (Apr 27 2018 at 17:58)</a>:</h4>
<p>this means it is bad code, right?</p>

<a name="125785263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125785263" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125785263">Kevin Buzzard (Apr 27 2018 at 17:58)</a>:</h4>
<p>Can you write better code?</p>

<a name="125785264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125785264" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125785264">Kenny Lau (Apr 27 2018 at 17:58)</a>:</h4>
<p>let's see whether you can avoid repeating yourself lol</p>

<a name="125785268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125785268" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125785268">Kevin Buzzard (Apr 27 2018 at 17:58)</a>:</h4>
<p>You know the dual of an equiv is an equiv</p>

<a name="125785278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125785278" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125785278">Kevin Buzzard (Apr 27 2018 at 17:59)</a>:</h4>
<p>I repeat myself IRL</p>

<a name="125785354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125785354" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125785354">Kevin Buzzard (Apr 27 2018 at 18:00)</a>:</h4>
<blockquote>
<p>I'm faster :P</p>
</blockquote>
<p>Yes but you're working on my conjecture ;-)</p>

<a name="125785534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125785534" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125785534">Kenny Lau (Apr 27 2018 at 18:05)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">Hom1</span><span class="bp">.</span><span class="n">transportable</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">transportable</span> <span class="o">(</span><span class="n">Hom1</span> <span class="n">α</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">Fun</span><span class="bp">.</span><span class="n">transportable</span> <span class="n">α</span>

<span class="kn">lemma</span> <span class="n">Hom2</span><span class="bp">.</span><span class="n">transportable</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">transportable</span> <span class="o">(</span><span class="n">Hom2</span> <span class="n">β</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">on_equiv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span> <span class="n">γ</span> <span class="n">e</span><span class="o">,</span> <span class="bp">⟨λ</span> <span class="n">f</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">e</span><span class="bp">.</span><span class="n">symm</span> <span class="n">x</span><span class="o">),</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">e</span> <span class="n">x</span><span class="o">),</span>
    <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">funext</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">congr_arg</span> <span class="n">f</span> <span class="err">$</span> <span class="n">e</span><span class="bp">.</span><span class="n">inverse_apply_apply</span> <span class="n">x</span><span class="o">,</span>
    <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">funext</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">congr_arg</span> <span class="n">f</span> <span class="err">$</span> <span class="n">e</span><span class="bp">.</span><span class="n">apply_inverse_apply</span> <span class="n">x</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">on_refl</span>  <span class="o">:=</span> <span class="bp">λ</span> <span class="n">β</span><span class="o">,</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">ext</span> <span class="bp">_</span> <span class="bp">_</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">on_trans</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">β</span> <span class="n">γ</span> <span class="n">δ</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">,</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">ext</span> <span class="bp">_</span> <span class="bp">_</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">rfl</span> <span class="o">}</span>

<span class="kn">lemma</span> <span class="n">Aut</span><span class="bp">.</span><span class="n">transportable</span> <span class="o">:</span> <span class="o">(</span><span class="n">transportable</span> <span class="n">Aut</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">on_equiv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span> <span class="n">β</span> <span class="n">e</span><span class="o">,</span> <span class="bp">⟨λ</span> <span class="n">f</span> <span class="n">x</span><span class="o">,</span> <span class="n">e</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">e</span><span class="bp">.</span><span class="n">symm</span> <span class="n">x</span><span class="o">)),</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">x</span><span class="o">,</span> <span class="n">e</span><span class="bp">.</span><span class="n">symm</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">e</span> <span class="n">x</span><span class="o">)),</span>
    <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">funext</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span><span class="o">,</span>
    <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">funext</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">on_refl</span>  <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span><span class="o">,</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">ext</span> <span class="bp">_</span> <span class="bp">_</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">funext</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">on_trans</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">,</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">ext</span> <span class="bp">_</span> <span class="bp">_</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">funext</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="o">}</span>
</pre></div>

<a name="125785536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125785536" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125785536">Kevin Buzzard (Apr 27 2018 at 18:05)</a>:</h4>
<p>Kenny my proof of <code>Const.transportable.on_trans</code> is better than yours</p>

<a name="125785577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125785577" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125785577">Kenny Lau (Apr 27 2018 at 18:06)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> all done. now I can shorten my proof lol</p>

<a name="125785585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125785585" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125785585">Kenny Lau (Apr 27 2018 at 18:06)</a>:</h4>
<p>well</p>

<a name="125785587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125785587" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125785587">Kevin Buzzard (Apr 27 2018 at 18:06)</a>:</h4>
<p><code>on_trans := λ α β γ Hαβ Hβγ,by congr</code></p>

<a name="125785589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125785589" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125785589">Kenny Lau (Apr 27 2018 at 18:06)</a>:</h4>
<p>I like term mode :P</p>

<a name="125785592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125785592" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125785592">Kevin Buzzard (Apr 27 2018 at 18:06)</a>:</h4>
<p>don't you lie to me</p>

<a name="125785593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125785593" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125785593">Kevin Buzzard (Apr 27 2018 at 18:06)</a>:</h4>
<p>you like golf</p>

<a name="125785595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125785595" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125785595">Kenny Lau (Apr 27 2018 at 18:06)</a>:</h4>
<p>lol</p>

<a name="125785599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125785599" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125785599">Kevin Buzzard (Apr 27 2018 at 18:06)</a>:</h4>
<p>:-)</p>

<a name="125785704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125785704" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125785704">Kevin Buzzard (Apr 27 2018 at 18:09)</a>:</h4>
<p>in <code>Fun_transportable.on_equiv</code> you have <code>e.inverse_apply_apply (f x)</code></p>

<a name="125785712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125785712" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125785712">Kevin Buzzard (Apr 27 2018 at 18:09)</a>:</h4>
<p>and I have <code>e.left_inv (f a)</code></p>

<a name="125785733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125785733" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125785733">Kevin Buzzard (Apr 27 2018 at 18:10)</a>:</h4>
<p>which is better?</p>

<a name="125785854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125785854" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125785854">Kenny Lau (Apr 27 2018 at 18:13)</a>:</h4>
<p>they say <code>e.symm</code> and etc are more idiomatic</p>

<a name="125785871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125785871" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125785871">Kenny Lau (Apr 27 2018 at 18:13)</a>:</h4>
<p>because they are actually simp lemmas</p>

<a name="125785877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125785877" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125785877">Kenny Lau (Apr 27 2018 at 18:13)</a>:</h4>
<p>so I can just replace it with <code>by simp</code> and outgolf you</p>

<a name="125785886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125785886" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125785886">Kevin Buzzard (Apr 27 2018 at 18:14)</a>:</h4>
<p>So I should switch to all this <code>apply_inverse_apply</code> stuff?</p>

<a name="125785929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125785929" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125785929">Kenny Lau (Apr 27 2018 at 18:14)</a>:</h4>
<p>no, you should use <code>simp</code></p>

<a name="125785930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125785930" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125785930">Kevin Buzzard (Apr 27 2018 at 18:14)</a>:</h4>
<p>And you use <code>coe_to_fun</code> to get the function directly?</p>

<a name="125785934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125785934" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125785934">Kenny Lau (Apr 27 2018 at 18:14)</a>:</h4>
<p>yes</p>

<a name="125786016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125786016" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125786016">Kevin Buzzard (Apr 27 2018 at 18:16)</a>:</h4>
<p>OK I pushed</p>

<a name="125786025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125786025" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125786025">Kevin Buzzard (Apr 27 2018 at 18:16)</a>:</h4>
<p><a href="https://github.com/kbuzzard/xena/blob/master/canonical_isomorphism/johan_challenge.lean" target="_blank" title="https://github.com/kbuzzard/xena/blob/master/canonical_isomorphism/johan_challenge.lean">https://github.com/kbuzzard/xena/blob/master/canonical_isomorphism/johan_challenge.lean</a></p>

<a name="125786034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125786034" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125786034">Kevin Buzzard (Apr 27 2018 at 18:17)</a>:</h4>
<p>has levels 1 and 2 solved</p>

<a name="125786043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125786043" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125786043">Kevin Buzzard (Apr 27 2018 at 18:17)</a>:</h4>
<p>and I'll now look at your other work Kenny</p>

<a name="125786048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125786048" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125786048">Kevin Buzzard (Apr 27 2018 at 18:17)</a>:</h4>
<p>Let me know if you think the solutions can be improved <span class="user-mention" data-user-id="110064">@Kenny Lau</span></p>

<a name="125786270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125786270" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125786270">Kenny Lau (Apr 27 2018 at 18:22)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">refl</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span>

<span class="n">class</span> <span class="n">transportable</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">on_equiv</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">equiv</span> <span class="n">α</span> <span class="n">β</span><span class="o">),</span> <span class="n">equiv</span> <span class="o">(</span><span class="n">f</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">β</span><span class="o">))</span>
<span class="o">(</span><span class="n">on_refl</span>  <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">),</span> <span class="n">on_equiv</span> <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">refl</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">refl</span> <span class="o">(</span><span class="n">f</span> <span class="n">α</span><span class="o">))</span>
<span class="o">(</span><span class="n">on_trans</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">equiv</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">equiv</span> <span class="n">β</span> <span class="n">γ</span><span class="o">),</span> <span class="n">on_equiv</span> <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">trans</span> <span class="n">d</span> <span class="n">e</span><span class="o">)</span> <span class="bp">=</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">on_equiv</span> <span class="n">d</span><span class="o">)</span> <span class="o">(</span><span class="n">on_equiv</span> <span class="n">e</span><span class="o">))</span>

<span class="c1">-- Our goal is an automagic proof of the following (level 20)</span>
<span class="kn">theorem</span> <span class="n">group</span><span class="bp">.</span><span class="n">transportable</span> <span class="o">:</span> <span class="n">transportable</span> <span class="n">group</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="c1">-- These we might need to define and prove by hand</span>
<span class="n">def</span> <span class="n">Const</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span><span class="o">,</span> <span class="n">punit</span>
<span class="n">def</span> <span class="n">Fun</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span> <span class="n">β</span><span class="o">,</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span>
<span class="n">def</span> <span class="n">Prod</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span> <span class="n">β</span><span class="o">,</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">β</span>
<span class="n">def</span> <span class="n">Swap</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span> <span class="n">β</span><span class="o">,</span> <span class="n">β</span> <span class="bp">×</span> <span class="n">α</span>

<span class="c1">-- level 1</span>
<span class="kn">lemma</span> <span class="n">Const</span><span class="bp">.</span><span class="n">transportable</span> <span class="o">:</span> <span class="o">(</span><span class="n">transportable</span> <span class="n">Const</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">on_equiv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span> <span class="n">β</span> <span class="n">e</span><span class="o">,</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">punit_equiv_punit</span><span class="o">,</span>
  <span class="n">on_refl</span>  <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span><span class="o">,</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">ext</span> <span class="bp">_</span> <span class="bp">_</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">⟨⟩</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">on_trans</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">,</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">ext</span> <span class="bp">_</span> <span class="bp">_</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">⟨⟩</span><span class="o">,</span> <span class="n">rfl</span> <span class="o">}</span>

<span class="kn">lemma</span> <span class="n">Fun</span><span class="bp">.</span><span class="n">transportable</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">transportable</span> <span class="o">(</span><span class="n">Fun</span> <span class="n">α</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">on_equiv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">β</span> <span class="n">γ</span> <span class="n">e</span><span class="o">,</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">arrow_congr</span> <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">refl</span> <span class="n">α</span><span class="o">)</span> <span class="n">e</span><span class="o">,</span>
  <span class="n">on_refl</span>  <span class="o">:=</span> <span class="bp">λ</span> <span class="n">β</span><span class="o">,</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">ext</span> <span class="bp">_</span> <span class="bp">_</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">on_trans</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">β</span> <span class="n">γ</span> <span class="n">δ</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">,</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">ext</span> <span class="bp">_</span> <span class="bp">_</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">funext</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span>
    <span class="k">by</span> <span class="n">cases</span> <span class="n">e1</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">e2</span><span class="bp">;</span> <span class="n">refl</span> <span class="o">}</span>

<span class="kn">theorem</span> <span class="n">prod</span><span class="bp">.</span><span class="n">ext&#39;</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">H1</span> <span class="o">:</span> <span class="n">p</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">=</span> <span class="n">q</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">H2</span> <span class="o">:</span> <span class="n">p</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">=</span> <span class="n">q</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">q</span> <span class="o">:=</span>
<span class="n">prod</span><span class="bp">.</span><span class="n">ext</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">⟨</span><span class="n">H1</span><span class="o">,</span> <span class="n">H2</span><span class="bp">⟩</span>

<span class="kn">lemma</span> <span class="n">Prod</span><span class="bp">.</span><span class="n">transportable</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">transportable</span> <span class="o">(</span><span class="n">Prod</span> <span class="n">α</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">on_equiv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">β</span> <span class="n">γ</span> <span class="n">e</span><span class="o">,</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">prod_congr</span> <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">refl</span> <span class="n">α</span><span class="o">)</span> <span class="n">e</span><span class="o">,</span>
  <span class="n">on_refl</span>  <span class="o">:=</span> <span class="bp">λ</span> <span class="n">β</span><span class="o">,</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">ext</span> <span class="bp">_</span> <span class="bp">_</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="bp">⟩</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">on_trans</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">β</span> <span class="n">γ</span> <span class="n">δ</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">,</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">ext</span> <span class="bp">_</span> <span class="bp">_</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="bp">⟩</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">}</span>

<span class="kn">lemma</span> <span class="n">Swap</span><span class="bp">.</span><span class="n">transportable</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">transportable</span> <span class="o">(</span><span class="n">Swap</span> <span class="n">α</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">on_equiv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">β</span> <span class="n">γ</span> <span class="n">e</span><span class="o">,</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">prod_congr</span> <span class="n">e</span> <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">refl</span> <span class="n">α</span><span class="o">),</span>
  <span class="n">on_refl</span>  <span class="o">:=</span> <span class="bp">λ</span> <span class="n">β</span><span class="o">,</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">ext</span> <span class="bp">_</span> <span class="bp">_</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="bp">⟩</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">on_trans</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">β</span> <span class="n">γ</span> <span class="n">δ</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">,</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">ext</span> <span class="bp">_</span> <span class="bp">_</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="bp">⟩</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">}</span>

<span class="c1">-- And then we can define</span>
<span class="n">def</span> <span class="n">Hom1</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">β</span><span class="o">,</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span>
<span class="n">def</span> <span class="n">Hom2</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span><span class="o">,</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span>
<span class="n">def</span> <span class="n">Aut</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span><span class="o">,</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span>

<span class="c1">-- And hopefully automagically derive</span>
<span class="kn">lemma</span> <span class="n">Hom1</span><span class="bp">.</span><span class="n">transportable</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">transportable</span> <span class="o">(</span><span class="n">Hom1</span> <span class="n">α</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">Fun</span><span class="bp">.</span><span class="n">transportable</span> <span class="n">α</span>

<span class="kn">lemma</span> <span class="n">Hom2</span><span class="bp">.</span><span class="n">transportable</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">transportable</span> <span class="o">(</span><span class="n">Hom2</span> <span class="n">β</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">on_equiv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span> <span class="n">γ</span> <span class="n">e</span><span class="o">,</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">arrow_congr</span> <span class="n">e</span> <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">refl</span> <span class="n">β</span><span class="o">),</span>
  <span class="n">on_refl</span>  <span class="o">:=</span> <span class="bp">λ</span> <span class="n">β</span><span class="o">,</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">ext</span> <span class="bp">_</span> <span class="bp">_</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">on_trans</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">β</span> <span class="n">γ</span> <span class="n">δ</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">,</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">ext</span> <span class="bp">_</span> <span class="bp">_</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">funext</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span>
    <span class="k">by</span> <span class="n">cases</span> <span class="n">e1</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">e2</span><span class="bp">;</span> <span class="n">refl</span> <span class="o">}</span>

<span class="kn">lemma</span> <span class="n">Aut</span><span class="bp">.</span><span class="n">transportable</span> <span class="o">:</span> <span class="o">(</span><span class="n">transportable</span> <span class="n">Aut</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">on_equiv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span> <span class="n">β</span> <span class="n">e</span><span class="o">,</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">arrow_congr</span> <span class="n">e</span> <span class="n">e</span><span class="o">,</span>
  <span class="n">on_refl</span>  <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span><span class="o">,</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">ext</span> <span class="bp">_</span> <span class="bp">_</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">funext</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">on_trans</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">,</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">ext</span> <span class="bp">_</span> <span class="bp">_</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">funext</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span>
    <span class="k">by</span> <span class="n">cases</span> <span class="n">e1</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">e2</span><span class="bp">;</span> <span class="n">refl</span> <span class="o">}</span>

<span class="c1">-- If we have all these in place...</span>
<span class="c1">-- A bit of magic might actually be able to derive `group.transportable` on line 11.</span>
<span class="c1">-- After all, a group just is a type plus some functions... and we can now transport functions.</span>
</pre></div>

<a name="125786273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125786273" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125786273">Kenny Lau (Apr 27 2018 at 18:22)</a>:</h4>
<p>golfed</p>

<a name="125786284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125786284" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125786284">Kenny Lau (Apr 27 2018 at 18:23)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span></p>

<a name="125786301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125786301" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125786301">Kenny Lau (Apr 27 2018 at 18:23)</a>:</h4>
<p><a href="https://github.com/kckennylau/Lean/blob/master/johan_challenge.lean" target="_blank" title="https://github.com/kckennylau/Lean/blob/master/johan_challenge.lean">https://github.com/kckennylau/Lean/blob/master/johan_challenge.lean</a></p>

<a name="125787049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125787049" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125787049">Kevin Buzzard (Apr 27 2018 at 18:40)</a>:</h4>
<p>This is looking good</p>

<a name="125787068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125787068" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125787068">Kenny Lau (Apr 27 2018 at 18:41)</a>:</h4>
<p>unfortunately, they wrote a destructor for <code>equiv.prod_congr</code> but not <code>equiv.arrow_congr</code></p>

<a name="125787133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125787133" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125787133">Kevin Buzzard (Apr 27 2018 at 18:42)</a>:</h4>
<p>Wooah what is going on in that proof of <code>Prod.transportable.on_equiv</code></p>

<a name="125787138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125787138" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125787138">Kenny Lau (Apr 27 2018 at 18:42)</a>:</h4>
<p>that's the example of a good destructor</p>

<a name="125787210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125787210" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125787210">Kevin Buzzard (Apr 27 2018 at 18:44)</a>:</h4>
<p>kenny you still didn't beat the boss</p>

<a name="125787228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125787228" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125787228">Kenny Lau (Apr 27 2018 at 18:45)</a>:</h4>
<p>who is the boss?</p>

<a name="125787429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125787429" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125787429">Kevin Buzzard (Apr 27 2018 at 18:50)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> Kenny did all your levels</p>

<a name="125787430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125787430" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125787430">Kevin Buzzard (Apr 27 2018 at 18:50)</a>:</h4>
<p>except for group</p>

<a name="125787432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125787432" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125787432">Kenny Lau (Apr 27 2018 at 18:50)</a>:</h4>
<p>I thought <code>group</code> is to be automated lol</p>

<a name="125787439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125787439" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125787439">Kevin Buzzard (Apr 27 2018 at 18:50)</a>:</h4>
<p><a href="https://github.com/kckennylau/Lean/blob/master/johan_challenge.lean" target="_blank" title="https://github.com/kckennylau/Lean/blob/master/johan_challenge.lean">https://github.com/kckennylau/Lean/blob/master/johan_challenge.lean</a></p>

<a name="125787450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125787450" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125787450">Kevin Buzzard (Apr 27 2018 at 18:51)</a>:</h4>
<p>So I think that you were looking for destructors in <code>equiv.lean</code></p>

<a name="125787454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125787454" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125787454">Kevin Buzzard (Apr 27 2018 at 18:51)</a>:</h4>
<p>which is a really good place to look for them</p>

<a name="125787504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125787504" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125787504">Kevin Buzzard (Apr 27 2018 at 18:52)</a>:</h4>
<p><span class="user-mention" data-user-id="110026">@Simon Hudon</span> what is the next move?</p>

<a name="125787520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125787520" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125787520">Kevin Buzzard (Apr 27 2018 at 18:53)</a>:</h4>
<p>Are these solutions in any way useful to help writing a general tactic which would prove <code>equiv a b -&gt; equiv (topological_field a) (topological_field b)</code>?</p>

<a name="125787526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125787526" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125787526">Kevin Buzzard (Apr 27 2018 at 18:53)</a>:</h4>
<p>What needs to be done next?</p>

<a name="125787601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125787601" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125787601">Simon Hudon (Apr 27 2018 at 18:56)</a>:</h4>
<p>I'm looking into automating those proofs. I'm keeping it for later tonight, when I've met my writing goals for the week</p>

<a name="125787647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125787647" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125787647">Simon Hudon (Apr 27 2018 at 18:56)</a>:</h4>
<p>I have a tactic, <code>refine_struct</code>, on the back burner which I might have to finish to facilitate this exercise</p>

<a name="125787731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125787731" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125787731">Kevin Buzzard (Apr 27 2018 at 18:59)</a>:</h4>
<p>Simon is there anything I can do to help?</p>

<a name="125787876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125787876" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125787876">Simon Hudon (Apr 27 2018 at 19:02)</a>:</h4>
<p>Thanks for offering. Are you thinking of something in particular?</p>

<a name="125787888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125787888" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125787888">Kevin Buzzard (Apr 27 2018 at 19:03)</a>:</h4>
<p>I don't understand how <a href="#narrow/stream/113488-general/subject/proof.20of.20the.20five.20lemma/near/125768238" title="#narrow/stream/113488-general/subject/proof.20of.20the.20five.20lemma/near/125768238">https://leanprover.zulipchat.com/#narrow/stream/113488-general/subject/proof.20of.20the.20five.20lemma/near/125768238</a> fits into the picture</p>

<a name="125787896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125787896" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125787896">Kevin Buzzard (Apr 27 2018 at 19:03)</a>:</h4>
<p>Simon I am just interested in the question and it's the weekend</p>

<a name="125787907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125787907" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125787907">Kevin Buzzard (Apr 27 2018 at 19:03)</a>:</h4>
<p>I really enjoyed playing some of Johan's levels</p>

<a name="125787910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125787910" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125787910">Kenny Lau (Apr 27 2018 at 19:03)</a>:</h4>
<p>I enjoyed outgolfing kevin :P</p>

<a name="125787954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125787954" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125787954">Kevin Buzzard (Apr 27 2018 at 19:04)</a>:</h4>
<p>and I wondered if you might say something of the form "please give me a human proof of <code>foo.transportable</code></p>

<a name="125787958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125787958" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125787958">Kevin Buzzard (Apr 27 2018 at 19:04)</a>:</h4>
<p>because these proofs are all really easy to do</p>

<a name="125787960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125787960" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125787960">Kevin Buzzard (Apr 27 2018 at 19:04)</a>:</h4>
<p>because Kenny has found a million tricks</p>

<a name="125787970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125787970" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125787970">Kevin Buzzard (Apr 27 2018 at 19:04)</a>:</h4>
<p>so the two motivations for doing more levels are</p>

<a name="125787971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125787971" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125787971">Kevin Buzzard (Apr 27 2018 at 19:05)</a>:</h4>
<p>(1) it's fun</p>

<a name="125787980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125787980" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125787980">Kevin Buzzard (Apr 27 2018 at 19:05)</a>:</h4>
<p>(2) it might help you see patterns</p>

<a name="125787984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125787984" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125787984">Kevin Buzzard (Apr 27 2018 at 19:05)</a>:</h4>
<p>(3) it might be necessary to get the automation off the ground</p>

<a name="125788036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125788036" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125788036">Simon Hudon (Apr 27 2018 at 19:06)</a>:</h4>
<p>I don't know how much fun it would be but how do you feel about writing a few sentences on some of the tricks that Kenny found?</p>

<a name="125788097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125788097" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125788097">Simon Hudon (Apr 27 2018 at 19:08)</a>:</h4>
<p>... or a minimal example for them</p>

<a name="125788446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125788446" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125788446">Johan Commelin (Apr 27 2018 at 19:17)</a>:</h4>
<p>Ok, really cool</p>

<a name="125788486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125788486" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125788486">Johan Commelin (Apr 27 2018 at 19:18)</a>:</h4>
<p>I knew that Hom1 would be easy, given Fun</p>

<a name="125788500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125788500" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125788500">Johan Commelin (Apr 27 2018 at 19:18)</a>:</h4>
<p>But currying should also help, right?</p>

<a name="125788504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125788504" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125788504">Johan Commelin (Apr 27 2018 at 19:18)</a>:</h4>
<p>to express some of the lemmas in terms of others...</p>

<a name="125788596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125788596" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125788596">Johan Commelin (Apr 27 2018 at 19:21)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> You did not dissappoint me (-;</p>

<a name="125788603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125788603" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125788603">Kenny Lau (Apr 27 2018 at 19:21)</a>:</h4>
<p>:D</p>

<a name="125788704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125788704" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125788704">Johan Commelin (Apr 27 2018 at 19:23)</a>:</h4>
<p>By the way, what do you think... <code>transportable</code> or <code>transport_of_structure</code> ?</p>

<a name="125788707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125788707" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125788707">Johan Commelin (Apr 27 2018 at 19:23)</a>:</h4>
<p>I think I actually prefer the latter...</p>

<a name="125788792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125788792" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125788792">Johan Commelin (Apr 27 2018 at 19:25)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> <code>Aut = Fun \circ Prod</code>. Doesn't that help?</p>

<a name="125788837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125788837" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125788837">Johan Commelin (Apr 27 2018 at 19:26)</a>:</h4>
<p>I hope it does... because that is how a mathematician would prove it...</p>

<a name="125788844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125788844" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125788844">Johan Commelin (Apr 27 2018 at 19:26)</a>:</h4>
<p>Aaah, so maybe here is "level 3": show that transportable stuff composes</p>

<a name="125788852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125788852" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125788852">Johan Commelin (Apr 27 2018 at 19:27)</a>:</h4>
<p>Lean is a nightmare on the machine that I am typing on.</p>

<a name="125788859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125788859" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125788859">Johan Commelin (Apr 27 2018 at 19:27)</a>:</h4>
<p>So I can't actually do anything myself (-;</p>

<a name="125788866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125788866" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125788866">Patrick Massot (Apr 27 2018 at 19:27)</a>:</h4>
<p>Have you compiled mathlib on this machine?</p>

<a name="125788873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125788873" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125788873">Johan Commelin (Apr 27 2018 at 19:28)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> If you are looking for another small challenge, maybe show that if <code>f</code> and <code>g</code> are transportable, then so is <code>g \circ f</code>.</p>

<a name="125788917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125788917" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125788917">Johan Commelin (Apr 27 2018 at 19:28)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> An old version... it took more then an hour and the machine was unusable and almost overheating.</p>

<a name="125788922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125788922" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125788922">Kenny Lau (Apr 27 2018 at 19:28)</a>:</h4>
<blockquote>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> <code>Aut = Fun \circ Prod</code>. Doesn't that help?</p>
</blockquote>
<p>unfortunately the transitive destructor is not available :P</p>

<a name="125788929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125788929" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125788929">Johan Commelin (Apr 27 2018 at 19:29)</a>:</h4>
<p>This is a Thinkpad X61: older than my kids...</p>

<a name="125788933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125788933" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125788933">Kenny Lau (Apr 27 2018 at 19:29)</a>:</h4>
<p>I might have to prove those destructors</p>

<a name="125788938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125788938" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125788938">Johan Commelin (Apr 27 2018 at 19:29)</a>:</h4>
<p>That sounds like it is useful</p>

<a name="125789003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125789003" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125789003">Kenny Lau (Apr 27 2018 at 19:30)</a>:</h4>
<p>oh that isn't a transitive destructor though</p>

<a name="125789007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125789007" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125789007">Kenny Lau (Apr 27 2018 at 19:30)</a>:</h4>
<p>I mean, <code>@[trans]</code> won't work</p>

<a name="125789226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125789226" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125789226">Kevin Buzzard (Apr 27 2018 at 19:37)</a>:</h4>
<p>here is a recent Lean tip -- occasionally get your file and give it a good shake</p>

<a name="125789235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125789235" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125789235">Kenny Lau (Apr 27 2018 at 19:37)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> how is Aut = Fun \o Prod?</p>

<a name="125789241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125789241" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125789241">Kevin Buzzard (Apr 27 2018 at 19:37)</a>:</h4>
<p>I think Gabriel changed the VS Code Lean extension</p>

<a name="125789244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125789244" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125789244">Kevin Buzzard (Apr 27 2018 at 19:37)</a>:</h4>
<p>so it only compiles parts of the file</p>

<a name="125789246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125789246" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125789246">Kevin Buzzard (Apr 27 2018 at 19:37)</a>:</h4>
<p>and sometimes it can get confused</p>

<a name="125789247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125789247" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125789247">Kenny Lau (Apr 27 2018 at 19:37)</a>:</h4>
<p>the compiler is very slow for me recently</p>

<a name="125789249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125789249" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125789249">Kenny Lau (Apr 27 2018 at 19:37)</a>:</h4>
<p>I often have to wait 10+ minutes before things compile</p>

<a name="125789250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125789250" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125789250">Kevin Buzzard (Apr 27 2018 at 19:37)</a>:</h4>
<p>and giving it a shake works well for me</p>

<a name="125789253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125789253" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125789253">Kevin Buzzard (Apr 27 2018 at 19:37)</a>:</h4>
<p>oh that's not good</p>

<a name="125789302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125789302" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125789302">Johan Commelin (Apr 27 2018 at 19:38)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> That was a bit of a brain-fart. Sorry</p>

<a name="125789314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125789314" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125789314">Kenny Lau (Apr 27 2018 at 19:39)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">local</span> <span class="n">attribute</span> <span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">transportable</span><span class="bp">.</span><span class="n">on_refl</span> <span class="n">transportable</span><span class="bp">.</span><span class="n">on_trans</span>

<span class="n">def</span> <span class="n">transportable</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">)</span>
  <span class="o">[</span><span class="n">transportable</span> <span class="n">f</span><span class="o">]</span> <span class="o">[</span><span class="n">transportable</span> <span class="n">g</span><span class="o">]</span> <span class="o">:</span> <span class="n">transportable</span> <span class="o">(</span><span class="n">g</span> <span class="err">∘</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">on_equiv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span> <span class="n">β</span> <span class="n">e</span><span class="o">,</span> <span class="k">show</span> <span class="n">g</span> <span class="o">(</span><span class="n">f</span> <span class="n">α</span><span class="o">)</span> <span class="err">≃</span> <span class="n">g</span> <span class="o">(</span><span class="n">f</span> <span class="n">β</span><span class="o">),</span> <span class="k">from</span> <span class="n">transportable</span><span class="bp">.</span><span class="n">on_equiv</span> <span class="n">g</span> <span class="o">(</span><span class="n">transportable</span><span class="bp">.</span><span class="n">on_equiv</span> <span class="n">f</span> <span class="n">e</span><span class="o">),</span>
  <span class="n">on_refl</span>  <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">on_trans</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="n">e₁</span> <span class="n">e₂</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">}</span>
</pre></div>

<a name="125789315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125789315" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125789315">Johan Commelin (Apr 27 2018 at 19:39)</a>:</h4>
<p>Mi mas go slip nau. Gutpela wok olgeta! Lukim!</p>

<a name="125789317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125789317" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125789317">Kenny Lau (Apr 27 2018 at 19:39)</a>:</h4>
<p>I like my addition</p>

<a name="125789318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125789318" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125789318">Kenny Lau (Apr 27 2018 at 19:39)</a>:</h4>
<p><a href="https://github.com/kckennylau/Lean/blob/master/johan_challenge.lean" target="_blank" title="https://github.com/kckennylau/Lean/blob/master/johan_challenge.lean">https://github.com/kckennylau/Lean/blob/master/johan_challenge.lean</a></p>

<a name="125789320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125789320" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125789320">Kevin Buzzard (Apr 27 2018 at 19:39)</a>:</h4>
<blockquote>
<p>I don't know how much fun it would be but how do you feel about writing a few sentences on some of the tricks that Kenny found?</p>
</blockquote>
<p>I would love to do that.</p>

<a name="125789322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125789322" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125789322">Kenny Lau (Apr 27 2018 at 19:39)</a>:</h4>
<p>tok pisin :o</p>

<a name="125789327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125789327" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125789327">Johan Commelin (Apr 27 2018 at 19:39)</a>:</h4>
<p>Em nau.</p>

<a name="125790151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125790151" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125790151">Kevin Buzzard (Apr 27 2018 at 20:01)</a>:</h4>
<p>Hey! <code>topological_ring _</code> is a <code>Prop</code> not a <code>Type</code></p>

<a name="125790167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125790167" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125790167">Kevin Buzzard (Apr 27 2018 at 20:01)</a>:</h4>
<p><code>theorem topological_ring.transportable : transportable topological_ring := sorry</code></p>

<a name="125790210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125790210" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125790210">Kevin Buzzard (Apr 27 2018 at 20:02)</a>:</h4>
<p>gives an error</p>

<a name="125790214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125790214" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125790214">Kevin Buzzard (Apr 27 2018 at 20:02)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">transportable</span> <span class="n">topological_ring</span>
<span class="n">term</span>
  <span class="n">topological_ring</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="bp">Π</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="err">?</span><span class="o">)</span> <span class="o">[</span><span class="bp">_</span><span class="n">inst_1</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="bp">_</span><span class="n">inst_2</span> <span class="o">:</span> <span class="n">ring</span> <span class="n">α</span><span class="o">],</span> <span class="kt">Prop</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="err">?</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="kt">Type</span> <span class="err">?</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="err">?</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="o">(</span><span class="err">?</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="err">?</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span>
</pre></div>

<a name="125790240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125790240" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125790240">Kevin Buzzard (Apr 27 2018 at 20:03)</a>:</h4>
<p>My new toy is broken</p>

<a name="125790251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125790251" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125790251">Kevin Buzzard (Apr 27 2018 at 20:03)</a>:</h4>
<p><code>class transportable (f : Type u → Type v) :=</code></p>

<a name="125790311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125790311" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125790311">Kevin Buzzard (Apr 27 2018 at 20:04)</a>:</h4>
<p>it's not that it's a prop</p>

<a name="125790314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125790314" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125790314">Kevin Buzzard (Apr 27 2018 at 20:04)</a>:</h4>
<p>is the issue that it's not a function?</p>

<a name="125790321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125790321" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125790321">Kenny Lau (Apr 27 2018 at 20:04)</a>:</h4>
<p>right</p>

<a name="125790331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125790331" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125790331">Kevin Buzzard (Apr 27 2018 at 20:04)</a>:</h4>
<p>but a topological ring is the same as a group</p>

<a name="125790357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125790357" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125790357">Kevin Buzzard (Apr 27 2018 at 20:05)</a>:</h4>
<p>if I have a topological ring structure on X and a canonical isomorphism <code>X -&gt; Y</code> then I want a topological ring structure on <code>Y</code></p>

<a name="125790950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125790950" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125790950">Kevin Buzzard (Apr 27 2018 at 20:19)</a>:</h4>
<p>What is <code>theorem topological_ring.transportable </code> ?</p>

<a name="125791009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125791009" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125791009">Kevin Buzzard (Apr 27 2018 at 20:20)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">analysis</span><span class="bp">.</span><span class="n">topology</span><span class="bp">.</span><span class="n">topological_structures</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">topological_ring</span>
</pre></div>

<a name="125791026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125791026" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125791026">Kevin Buzzard (Apr 27 2018 at 20:20)</a>:</h4>
<p>this doesn't typecheck</p>

<a name="125791027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125791027" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125791027">Kevin Buzzard (Apr 27 2018 at 20:21)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">topological_ring</span><span class="bp">.</span><span class="n">transportable</span> <span class="o">:</span> <span class="n">transportable</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">R</span> <span class="o">:</span> <span class="o">(</span><span class="err">Σ</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">),</span> <span class="o">(</span><span class="n">topological_space</span> <span class="n">α</span><span class="o">)</span> <span class="bp">×</span> <span class="o">(</span><span class="n">ring</span> <span class="n">α</span><span class="o">))</span> <span class="o">,</span>
    <span class="bp">@</span><span class="n">topological_ring</span> <span class="n">R</span><span class="bp">.</span><span class="n">fst</span> <span class="o">(</span><span class="n">R</span><span class="bp">.</span><span class="n">snd</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="o">(</span><span class="n">R</span><span class="bp">.</span><span class="n">snd</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>

<a name="125791031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125791031" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125791031">Kevin Buzzard (Apr 27 2018 at 20:21)</a>:</h4>
<p>What am I doing wrong?</p>

<a name="125791039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125791039" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125791039">Kevin Buzzard (Apr 27 2018 at 20:21)</a>:</h4>
<p>Simon -- I was writing some goals in the docs</p>

<a name="125791044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125791044" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125791044">Kevin Buzzard (Apr 27 2018 at 20:21)</a>:</h4>
<p>and transfer of a topological ring structure is one of the goals</p>

<a name="125791207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125791207" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125791207">Kevin Buzzard (Apr 27 2018 at 20:25)</a>:</h4>
<p>we can write this</p>

<a name="125791210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125791210" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125791210">Kevin Buzzard (Apr 27 2018 at 20:25)</a>:</h4>
<p><code>def transport_ring {α β : Type} [topological_field α] (f : α ≃ β) : topological_field β := sorry</code></p>

<a name="125791214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125791214" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125791214">Kevin Buzzard (Apr 27 2018 at 20:25)</a>:</h4>
<p>but I don't understand how to embed it in the <code>transportable</code> class</p>

<a name="125792177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125792177" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125792177">Kevin Buzzard (Apr 27 2018 at 20:48)</a>:</h4>
<p>Kenny you posted this earlier:</p>

<a name="125792187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125792187" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125792187">Kevin Buzzard (Apr 27 2018 at 20:49)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span>

<span class="n">def</span> <span class="n">transport_ring</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="err">≃</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">ring</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">add</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">f</span><span class="bp">.</span><span class="n">symm</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">f</span><span class="bp">.</span><span class="n">symm</span> <span class="n">y</span><span class="o">),</span>
  <span class="n">zero</span> <span class="o">:=</span> <span class="n">f</span> <span class="mi">0</span><span class="o">,</span>
  <span class="n">neg</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="bp">-</span><span class="n">f</span><span class="bp">.</span><span class="n">symm</span> <span class="n">x</span><span class="o">),</span>
  <span class="n">mul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">f</span><span class="bp">.</span><span class="n">symm</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">f</span><span class="bp">.</span><span class="n">symm</span> <span class="n">y</span><span class="o">),</span>
  <span class="n">one</span> <span class="o">:=</span> <span class="n">f</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">add_assoc</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span><span class="bp">;</span> <span class="k">from</span> <span class="n">add_assoc</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">zero_add</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span><span class="bp">;</span> <span class="k">from</span> <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">apply_eq_iff_eq_inverse_apply</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="o">(</span><span class="n">zero_add</span> <span class="bp">_</span><span class="o">),</span>
  <span class="n">add_zero</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span><span class="bp">;</span> <span class="k">from</span> <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">apply_eq_iff_eq_inverse_apply</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="o">(</span><span class="n">add_zero</span> <span class="bp">_</span><span class="o">),</span>
  <span class="n">add_left_neg</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span><span class="bp">;</span> <span class="k">from</span> <span class="n">add_left_neg</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">add_comm</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span><span class="bp">;</span> <span class="k">from</span> <span class="n">add_comm</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">mul_assoc</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span><span class="bp">;</span> <span class="k">from</span> <span class="n">mul_assoc</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">one_mul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span><span class="bp">;</span> <span class="k">from</span> <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">apply_eq_iff_eq_inverse_apply</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="o">(</span><span class="n">one_mul</span> <span class="bp">_</span><span class="o">),</span>
  <span class="n">mul_one</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span><span class="bp">;</span> <span class="k">from</span> <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">apply_eq_iff_eq_inverse_apply</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="o">(</span><span class="n">mul_one</span> <span class="bp">_</span><span class="o">),</span>
  <span class="n">left_distrib</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span><span class="bp">;</span> <span class="k">from</span> <span class="n">left_distrib</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">right_distrib</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span><span class="bp">;</span> <span class="k">from</span> <span class="n">right_distrib</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="o">}</span>
</pre></div>

<a name="125792191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125792191" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125792191">Kevin Buzzard (Apr 27 2018 at 20:49)</a>:</h4>
<p>and if I change the top lines to</p>

<a name="125792208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125792208" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125792208">Kevin Buzzard (Apr 27 2018 at 20:49)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span>
<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span>
<span class="n">def</span> <span class="n">transport_ring</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="err">≃</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">ring</span> <span class="n">β</span> <span class="o">:=</span>
</pre></div>

<a name="125792210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125792210" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125792210">Kevin Buzzard (Apr 27 2018 at 20:49)</a>:</h4>
<p>then your code doesn't compile any more</p>

<a name="125792257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125792257" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125792257">Kenny Lau (Apr 27 2018 at 20:50)</a>:</h4>
<p>this is interesting</p>

<a name="125792259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125792259" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125792259">Kevin Buzzard (Apr 27 2018 at 20:50)</a>:</h4>
<p>Are you only proving <code>transport_ring</code> for types in the same universe, and is this easier to do than the general case?</p>

<a name="125792706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125792706" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125792706">Kevin Buzzard (Apr 27 2018 at 21:00)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span>
<span class="kn">import</span> <span class="n">analysis</span><span class="bp">.</span><span class="n">topology</span><span class="bp">.</span><span class="n">topological_structures</span>

<span class="n">def</span> <span class="n">transport_topological_ring</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span>
  <span class="o">[</span><span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">topological_ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="err">≃</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="bp">@</span><span class="n">topological_ring</span> <span class="n">β</span> <span class="n">sorry</span> <span class="n">sorry</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>

<a name="125792744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125792744" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125792744">Chris Hughes (Apr 27 2018 at 21:01)</a>:</h4>
<p>I doesn't seem like it would be any easier in the same universe.</p>

<a name="125792746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125792746" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125792746">Kevin Buzzard (Apr 27 2018 at 21:01)</a>:</h4>
<p>Least it typechecks</p>

<a name="125792751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125792751" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125792751">Kevin Buzzard (Apr 27 2018 at 21:01)</a>:</h4>
<p>I tried putting Kenny's proof into the same universe and there were still errors</p>

<a name="125792754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125792754" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125792754">Kevin Buzzard (Apr 27 2018 at 21:01)</a>:</h4>
<p>there are universe subtleties I don't understand</p>

<a name="125792796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125792796" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125792796">Kevin Buzzard (Apr 27 2018 at 21:02)</a>:</h4>
<p>Chris this is all your fault :-)</p>

<a name="125792804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125792804" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125792804">Kevin Buzzard (Apr 27 2018 at 21:02)</a>:</h4>
<p>You proved the lemma only for rings canonically isomorphic to the rings I wanted</p>

<a name="125795177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125795177" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125795177">Reid Barton (Apr 27 2018 at 22:05)</a>:</h4>
<p>By adding more <code>transportable</code> classes for type constructors with multiple arguments, we could extend these ideas to situations where we have an isomorphism which respects some existing structure and we want to transport some additional structure (or property) across it. Here is a sketch of the idea: <a href="https://gist.github.com/rwbarton/d847ef6d1783f0d0859eb80de8327bad" target="_blank" title="https://gist.github.com/rwbarton/d847ef6d1783f0d0859eb80de8327bad">https://gist.github.com/rwbarton/d847ef6d1783f0d0859eb80de8327bad</a></p>

<a name="125795238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125795238" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125795238">Reid Barton (Apr 27 2018 at 22:06)</a>:</h4>
<p>The key point is the definition</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">is_homeomorphism</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">tα</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">tβ</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">α</span> <span class="err">≃</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">tβ</span> <span class="bp">=</span> <span class="n">transport</span> <span class="n">topological_space</span> <span class="n">e</span> <span class="n">tα</span>
</pre></div>


<p>which seems to be more fundamental than the category-style definition "continuous function with a continuous inverse", since the definition of <code>transport</code> does not even need the notion of continuous function.</p>

<a name="125795266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125795266" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125795266">Kevin Buzzard (Apr 27 2018 at 22:07)</a>:</h4>
<p>This proof does not work:</p>

<a name="125795307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125795307" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125795307">Kevin Buzzard (Apr 27 2018 at 22:08)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">Const</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span><span class="o">,</span> <span class="n">punit</span>
<span class="kn">lemma</span> <span class="n">Const</span><span class="bp">.</span><span class="n">transportable</span> <span class="o">:</span> <span class="o">(</span><span class="n">transportable</span> <span class="n">Const</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">on_equiv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span> <span class="n">β</span> <span class="n">e</span><span class="o">,</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">punit_equiv_punit</span><span class="o">,</span>
  <span class="n">on_refl</span>  <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span><span class="o">,</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">ext</span> <span class="bp">_</span> <span class="bp">_</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">⟨⟩</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">on_trans</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">,</span> <span class="k">by</span> <span class="n">congr</span><span class="o">}</span>
</pre></div>

<a name="125795310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125795310" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125795310">Kevin Buzzard (Apr 27 2018 at 22:08)</a>:</h4>
<p>but this proof works:</p>

<a name="125795316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125795316" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125795316">Kevin Buzzard (Apr 27 2018 at 22:08)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">Const</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span><span class="o">,</span> <span class="n">punit</span>
<span class="kn">lemma</span> <span class="n">Const</span><span class="bp">.</span><span class="n">transportable</span> <span class="o">:</span> <span class="o">(</span><span class="n">transportable</span> <span class="n">Const</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">on_equiv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span> <span class="n">β</span> <span class="n">e</span><span class="o">,</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">punit_equiv_punit</span><span class="o">,</span>
  <span class="n">on_refl</span>  <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span><span class="o">,</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">ext</span> <span class="bp">_</span> <span class="bp">_</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">⟨⟩</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">on_trans</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">,</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">ext</span> <span class="bp">_</span> <span class="bp">_</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">⟨⟩</span><span class="o">,</span> <span class="n">rfl</span> <span class="o">}</span>
</pre></div>

<a name="125795325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125795325" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125795325">Kevin Buzzard (Apr 27 2018 at 22:09)</a>:</h4>
<p>and this proof works:</p>

<a name="125795331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125795331" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125795331">Kevin Buzzard (Apr 27 2018 at 22:09)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">Const&#39;</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span><span class="o">,</span> <span class="n">punit</span>
<span class="kn">lemma</span> <span class="n">Const&#39;</span><span class="bp">.</span><span class="n">transportable</span> <span class="o">:</span> <span class="o">(</span><span class="n">transportable</span> <span class="n">Const</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">on_equiv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span> <span class="n">β</span> <span class="n">H</span><span class="o">,</span><span class="bp">⟨λ</span> <span class="bp">_</span><span class="o">,</span><span class="n">punit</span><span class="bp">.</span><span class="n">star</span><span class="o">,</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span><span class="n">punit</span><span class="bp">.</span><span class="n">star</span><span class="o">,</span><span class="bp">λ</span> <span class="bp">⟨⟩</span><span class="o">,</span><span class="n">rfl</span><span class="o">,</span><span class="bp">λ</span> <span class="bp">⟨⟩</span><span class="o">,</span><span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">on_refl</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span><span class="o">,</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">ext</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">⟨⟩</span><span class="o">,</span><span class="n">rfl</span><span class="o">),</span>
  <span class="n">on_trans</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="n">Hαβ</span> <span class="n">Hβγ</span><span class="o">,</span><span class="k">by</span> <span class="n">congr</span>
  <span class="o">}</span>
</pre></div>

<a name="125795386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125795386" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125795386">Kevin Buzzard (Apr 27 2018 at 22:10)</a>:</h4>
<p>I am interested in the idea of filling in fields using tactics but I can only use <code>congr</code> if I set it up in a certain way</p>

<a name="125795472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125795472" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125795472">Kevin Buzzard (Apr 27 2018 at 22:12)</a>:</h4>
<blockquote>
<p>did you take a look at the <code>transfer</code> paper I linked way back? That's how in core lean they move proofs between <code>int</code> and <code>(a , b) : nat * nat</code>, which (and maybe I'm not understanding the details here very well) is your problem of transporting proofs between isomorphic types?</p>
</blockquote>
<p>Can you remind me of the link?</p>

<a name="125795475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125795475" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125795475">Kevin Buzzard (Apr 27 2018 at 22:12)</a>:</h4>
<p><span class="user-mention" data-user-id="110025">@Andrew Ashworth</span></p>

<a name="125795476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125795476" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125795476">Kevin Buzzard (Apr 27 2018 at 22:12)</a>:</h4>
<p>My search skills are weak today</p>

<a name="125795552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125795552" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125795552">Kevin Buzzard (Apr 27 2018 at 22:14)</a>:</h4>
<blockquote>
<p>The key point is the definition</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">is_homeomorphism</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">tα</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">tβ</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">α</span> <span class="err">≃</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">tβ</span> <span class="bp">=</span> <span class="n">transport</span> <span class="n">topological_space</span> <span class="n">e</span> <span class="n">tα</span>
</pre></div>


<p>which seems to be more fundamental than the category-style definition "continuous function with a continuous inverse", since the definition of <code>transport</code> does not even need the notion of continuous function.</p>
</blockquote>
<p>At some point I am going to want more than just an equiv -- I will want that two canonical isomorphisms <code>equiv A A'</code> and <code>equiv B B'</code> commute with some given maps <code>A -&gt; B</code> and <code>A' -&gt; B'</code> which are both "defined naturally".</p>

<a name="125795611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125795611" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125795611">Kevin Buzzard (Apr 27 2018 at 22:16)</a>:</h4>
<p>For example Reid, I proved that if <code>D(g) sub D(f)</code> then not only is <code>f</code> a unit in <code>R[1/g]</code>, but the rings <code>R[1/g]</code> and <code>R[1/f][1/gbar]</code> were canonically isomorphic, where <code>gbar</code> is the image of <code>g</code> in <code>R[1/f]</code></p>

<a name="125795634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125795634" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125795634">Kevin Buzzard (Apr 27 2018 at 22:17)</a>:</h4>
<p>And by "prove that they're canonically isomorphic" I mean in practice that I proved that I could write down an isomorphism of R-algebras which was also the unique R-algebra homomorphism in either direction.</p>

<a name="125795640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125795640" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125795640">Kevin Buzzard (Apr 27 2018 at 22:17)</a>:</h4>
<p>and I am pretty sure that I don't need to prove any more "canonicalness" for my application to schemes.</p>

<a name="125795686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125795686" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125795686">Kevin Buzzard (Apr 27 2018 at 22:18)</a>:</h4>
<p>The idea is that <code>f : R</code> is now fixed</p>

<a name="125795695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125795695" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125795695">Kevin Buzzard (Apr 27 2018 at 22:18)</a>:</h4>
<p>and <code>g : { g : R // D(g) sub D(f) }</code> varies</p>

<a name="125795699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125795699" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125795699">Kevin Buzzard (Apr 27 2018 at 22:18)</a>:</h4>
<p>and <code>A g := R[1/g]</code></p>

<a name="125795702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125795702" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125795702">Kevin Buzzard (Apr 27 2018 at 22:19)</a>:</h4>
<p>and <code>A' g := R[1/f][1/gbar]</code></p>

<a name="125795711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125795711" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125795711">Kevin Buzzard (Apr 27 2018 at 22:19)</a>:</h4>
<p>Does this fit into your "extra structure" idea?</p>

<a name="125795894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125795894" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125795894">Reid Barton (Apr 27 2018 at 22:24)</a>:</h4>
<p><code>B</code> is <code>A g'</code> for another <code>g'</code>?</p>

<a name="125795909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125795909" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125795909">Reid Barton (Apr 27 2018 at 22:25)</a>:</h4>
<p>Or something else entirely?</p>

<a name="125795971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125795971" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125795971">Kenny Lau (Apr 27 2018 at 22:26)</a>:</h4>
<p>I'm back</p>

<a name="125796055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125796055" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125796055">Reid Barton (Apr 27 2018 at 22:28)</a>:</h4>
<p>It sounds like you want to prove that your isomorphism between <code>R[1/g]</code> and <code>R[1/f][1/gbar]</code> is natural (in the category theory sense) when these two localization constructions are viewed as functors of something (R and/or g?), and that is probably not a purely formal fact that follows from transporting across "equalities". (On the other hand, it is probably a slightly less formal fact that follows easily from some universal property.)</p>

<a name="125796240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125796240" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125796240">Kevin Buzzard (Apr 27 2018 at 22:33)</a>:</h4>
<p>docs</p>

<a name="125796244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125796244" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125796244">Kevin Buzzard (Apr 27 2018 at 22:33)</a>:</h4>
<p><a href="https://github.com/kbuzzard/xena/blob/master/canonical_isomorphism/canonical.md" target="_blank" title="https://github.com/kbuzzard/xena/blob/master/canonical_isomorphism/canonical.md">https://github.com/kbuzzard/xena/blob/master/canonical_isomorphism/canonical.md</a></p>

<a name="125796245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125796245" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125796245">Kevin Buzzard (Apr 27 2018 at 22:33)</a>:</h4>
<p>permanlink</p>

<a name="125796294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125796294" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125796294">Kenny Lau (Apr 27 2018 at 22:34)</a>:</h4>
<p>speaking of which, it's almost a month since your last post in xena</p>

<a name="125796296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125796296" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125796296">Kevin Buzzard (Apr 27 2018 at 22:34)</a>:</h4>
<p>don't know how to do permalink</p>

<a name="125796298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125796298" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125796298">Kenny Lau (Apr 27 2018 at 22:34)</a>:</h4>
<p><a href="https://github.com/kbuzzard/xena/blob/e77228397ad21215a927f93d315edf3cbadbc567/canonical_isomorphism/canonical.md" target="_blank" title="https://github.com/kbuzzard/xena/blob/e77228397ad21215a927f93d315edf3cbadbc567/canonical_isomorphism/canonical.md">https://github.com/kbuzzard/xena/blob/e77228397ad21215a927f93d315edf3cbadbc567/canonical_isomorphism/canonical.md</a></p>

<a name="125796299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125796299" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125796299">Kenny Lau (Apr 27 2018 at 22:34)</a>:</h4>
<p>there you go</p>

<a name="125796303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125796303" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125796303">Kenny Lau (Apr 27 2018 at 22:35)</a>:</h4>
<p>try deleting the file :P</p>

<a name="125796305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125796305" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125796305">Kevin Buzzard (Apr 27 2018 at 22:35)</a>:</h4>
<p>I want to focus on schemes Kenny, and I guess the situation is that it would be nice to resolve this canonical isomorphism issue before I go any further</p>

<a name="125796313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125796313" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125796313">Kevin Buzzard (Apr 27 2018 at 22:35)</a>:</h4>
<p>I will probably blog about this though</p>

<a name="125796317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125796317" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125796317">Kenny Lau (Apr 27 2018 at 22:35)</a>:</h4>
<p>should I write a guest post</p>

<a name="125796376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125796376" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125796376">Reid Barton (Apr 27 2018 at 22:36)</a>:</h4>
<p>(You can click on the commit id near the right side of the blue bar, and then View)</p>

<a name="125796713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125796713" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125796713">Reid Barton (Apr 27 2018 at 22:45)</a>:</h4>
<p>Let me address the question at the end of those docs, since your "three lemma" was what prompted the gist I linked earlier.<br>
You could define a structure indexed on A B C that consists of abelian group structures on A B C and group homomorphisms f : A -&gt; B and g : B -&gt; C. The input to the "three lemma" is an isomorphism of such structures.<br>
The further structure would be exactness of the sequence, i.e., the equation ker g = im f; that's what you want to transport to the new sequence.</p>

<a name="125796852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125796852" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125796852">Reid Barton (Apr 27 2018 at 22:49)</a>:</h4>
<p>Simply transporting the combined structure of "being an exact sequence" across your isomorphisms A -&gt; A', B -&gt; B', C -&gt; C' won't be enough, since you also need to know that the transported group structures and maps agree with your original ones.</p>

<a name="125796860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125796860" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125796860">Reid Barton (Apr 27 2018 at 22:49)</a>:</h4>
<p>(for which you need precisely that the maps are group isomorphisms and the squares commute)</p>

<a name="125796932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125796932" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125796932">Reid Barton (Apr 27 2018 at 22:51)</a>:</h4>
<p>I guess if you had lemmas to calculate the components of the transported structure, then that would be another way to do it.</p>

<a name="125797044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125797044" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125797044">Reid Barton (Apr 27 2018 at 22:54)</a>:</h4>
<p>I need to make dinner but I'll try to produce some example code later</p>

<a name="125797105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125797105" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125797105">Kevin Buzzard (Apr 27 2018 at 22:56)</a>:</h4>
<p>I see! I find it much easier to understand this example.</p>

<a name="125797107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125797107" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125797107">Kevin Buzzard (Apr 27 2018 at 22:57)</a>:</h4>
<p>So one makes a new structure</p>

<a name="125797113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125797113" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125797113">Kevin Buzzard (Apr 27 2018 at 22:57)</a>:</h4>
<p>and then attempts to transport it</p>

<a name="125797115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125797115" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125797115">Kevin Buzzard (Apr 27 2018 at 22:57)</a>:</h4>
<p>This sounds like a beautiful way of thinking about it.</p>

<a name="125797487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125797487" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125797487">Kevin Buzzard (Apr 27 2018 at 23:07)</a>:</h4>
<p>Kenny you are welcome to write a guest post</p>

<a name="125797493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125797493" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125797493">Kevin Buzzard (Apr 27 2018 at 23:07)</a>:</h4>
<p>On whatever topic you like</p>

<a name="125798645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125798645" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125798645">Andrew Ashworth (Apr 27 2018 at 23:40)</a>:</h4>
<p>the transfer paper is here:  <a href="https://www21.in.tum.de/~kuncar/documents/huffman-kuncar-cpp2013.pdf" target="_blank" title="https://www21.in.tum.de/~kuncar/documents/huffman-kuncar-cpp2013.pdf">https://www21.in.tum.de/~kuncar/documents/huffman-kuncar-cpp2013.pdf</a></p>

<a name="125798996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125798996" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125798996">Kevin Buzzard (Apr 27 2018 at 23:50)</a>:</h4>
<p>Thanks Andrew.</p>

<a name="125799001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125799001" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125799001">Kevin Buzzard (Apr 27 2018 at 23:51)</a>:</h4>
<p>Reid -- you probably know the full story anyway, but let me spell it out.</p>

<a name="125799058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125799058" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125799058">Kevin Buzzard (Apr 27 2018 at 23:52)</a>:</h4>
<p>Chris proved a lemma saying that if <code>R</code> is a ring and <code>f1,f2,...,fn</code> are elements which generate the unit ideal, then the structure sheaf on Spec(R) satisfies the sheaf axiom with respect to the open cover D(f1),..,D(fn).</p>

<a name="125799065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125799065" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125799065">Kevin Buzzard (Apr 27 2018 at 23:53)</a>:</h4>
<p>Formally, as you know, this says that the canonical map from <code>R</code> to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Π</mi><mi>i</mi></msub><mi>R</mi><mo>[</mo><mn>1</mn><mi mathvariant="normal">/</mi><msub><mi>f</mi><mi>i</mi></msub><mo>]</mo></mrow><annotation encoding="application/x-tex">\Pi_i R[1/f_i]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathrm">Π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mord mathrm">/</span><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mclose">]</span></span></span></span> is an injection,</p>

<a name="125799110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125799110" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125799110">Kevin Buzzard (Apr 27 2018 at 23:54)</a>:</h4>
<p>with image equal to the kernel of the usual map <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Π</mi><mi>i</mi></msub><mi>R</mi><mo>[</mo><mn>1</mn><mi mathvariant="normal">/</mi><msub><mi>f</mi><mi>i</mi></msub><mo>]</mo><mo>→</mo><msub><mi mathvariant="normal">Π</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mi>R</mi><mo>[</mo><mn>1</mn><mi mathvariant="normal">/</mi><msub><mi>f</mi><mi>i</mi></msub><msub><mi>f</mi><mi>j</mi></msub><mo>]</mo></mrow><annotation encoding="application/x-tex">\Pi_i R[1/f_i] \to \Pi_{i,j} R[1/f_if_j]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="base"><span class="mord"><span class="mord mathrm">Π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mord mathrm">/</span><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mclose">]</span><span class="mrel">→</span><span class="mord"><span class="mord mathrm">Π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"></span></span></span></span></span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mord mathrm">/</span><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"></span></span></span></span></span><span class="mclose">]</span></span></span></span></p>

<a name="125799118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125799118" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125799118">Kevin Buzzard (Apr 27 2018 at 23:54)</a>:</h4>
<p>and note that this latter map sends <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>s</mi><mi>i</mi></msub><msub><mo>)</mo><mrow><mi>i</mi><mo>∈</mo><mi>I</mi></mrow></msub></mrow><annotation encoding="application/x-tex">(s_i)_{i\in I}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">(</span><span class="mord"><span class="mord mathit">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">i</span><span class="mrel mtight">∈</span><span class="mord mathit mtight" style="margin-right:0.07847em;">I</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.17737em;"></span></span></span></span></span></span></span></span> to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>s</mi><mi>i</mi></msub><mo>−</mo><msub><mi>s</mi><mi>j</mi></msub><msub><mo>)</mo><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">(s_i-s_j)_{i,j}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="base"><span class="mopen">(</span><span class="mord"><span class="mord mathit">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mbin">−</span><span class="mord"><span class="mord mathit">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"></span></span></span></span></span></span></span></span></p>

<a name="125799120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125799120" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125799120">Kevin Buzzard (Apr 27 2018 at 23:55)</a>:</h4>
<p>which is not a ring homomorphism</p>

<a name="125799128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125799128" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125799128">Kevin Buzzard (Apr 27 2018 at 23:55)</a>:</h4>
<p>but it is a difference of two such</p>

<a name="125799133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125799133" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125799133">Kevin Buzzard (Apr 27 2018 at 23:55)</a>:</h4>
<p>and hence the whole map is a group homomorphism</p>

<a name="125799137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125799137" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125799137">Kevin Buzzard (Apr 27 2018 at 23:55)</a>:</h4>
<p>Now I have done some abstract ring theory in Lean over the last few weeks, working on "an interface for localisation"</p>

<a name="125799181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125799181" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125799181">Kevin Buzzard (Apr 27 2018 at 23:56)</a>:</h4>
<p>and I have now proved some technical lemma which says that if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo>(</mo><mi>g</mi><mo>)</mo><mo>⊆</mo><mi>D</mi><mo>(</mo><mi>f</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">D(g)\subseteq D(f)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mclose">)</span><span class="mrel">⊆</span><span class="mord mathit" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span> then <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo>[</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>g</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">R[1/g]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mclose">]</span></span></span></span> is canonically isomorphic to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo>[</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>f</mi><mo>]</mo><mo>[</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>g</mi><mi>b</mi><mi>a</mi><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">R[1/f][1/gbar]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">b</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span></p>

<a name="125799182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125799182" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125799182">Kevin Buzzard (Apr 27 2018 at 23:56)</a>:</h4>
<p>with <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>b</mi><mi>a</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">gbar</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">b</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.02778em;">r</span></span></span></span> the image of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.03588em;">g</span></span></span></span></p>

<a name="125799191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125799191" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125799191">Kevin Buzzard (Apr 27 2018 at 23:57)</a>:</h4>
<p>and canonical isomorphism for me at this point means that we are given an element of <code>equiv</code> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>R</mi><mo>[</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>g</mi><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">(R[1/g])</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>R</mi><mo>[</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>f</mi><mo>]</mo><mo>[</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>g</mi><mi>b</mi><mi>a</mi><mi>r</mi><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">(R[1/f][1/gbar])</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">b</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></p>

<a name="125799193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125799193" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125799193">Kevin Buzzard (Apr 27 2018 at 23:57)</a>:</h4>
<p>(maths notation is better than Lean)</p>

<a name="125799194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125799194" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125799194">Kevin Buzzard (Apr 27 2018 at 23:57)</a>:</h4>
<p>with the following wonderful properties:</p>

<a name="125799236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125799236" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125799236">Kevin Buzzard (Apr 27 2018 at 23:58)</a>:</h4>
<p>1) the functions are ring homs (and hence ring isoms)</p>

<a name="125799238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125799238" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125799238">Kevin Buzzard (Apr 27 2018 at 23:58)</a>:</h4>
<p>2) The only <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.00773em;">R</span></span></span></span>-algebra hom from <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo>[</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>g</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">R[1/g]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mclose">]</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo>[</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>f</mi><mo>]</mo><mo>[</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>g</mi><mi>b</mi><mi>a</mi><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">R[1/f][1/gbar]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">b</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> is our given element.</p>

<a name="125799246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125799246" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125799246">Kevin Buzzard (Apr 27 2018 at 23:59)</a>:</h4>
<p>I am _hoping_ that this is a good definition of "canonical isomorphism" here.</p>

<a name="125799249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125799249" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125799249">Kevin Buzzard (Apr 27 2018 at 23:59)</a>:</h4>
<p>These are the facts which I isolated as important</p>

<a name="125799250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125799250" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125799250">Kevin Buzzard (Apr 27 2018 at 23:59)</a>:</h4>
<p>I made a structure for each of them</p>

<a name="125799308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125799308" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125799308">Kevin Buzzard (Apr 28 2018 at 00:00)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">R_alg_equiv</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">comm</span>
<span class="bp">_</span><span class="n">ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">(</span><span class="n">sα</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">sβ</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">ring_equiv</span> <span class="n">α</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">R_alg_hom</span> <span class="o">:</span> <span class="n">sβ</span> <span class="bp">=</span> <span class="n">to_fun</span> <span class="err">∘</span> <span class="n">sα</span><span class="o">)</span>
</pre></div>

<a name="125799360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125799360" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125799360">Kevin Buzzard (Apr 28 2018 at 00:02)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">is_unique_R_alg_hom</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">β</span><span class="o">]</span>
<span class="o">(</span><span class="n">sα</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">sβ</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">[</span><span class="n">is_ring_hom</span> <span class="n">sα</span><span class="o">]</span> <span class="o">[</span><span class="n">is_ring_hom</span> <span class="n">sβ</span><span class="o">]</span> <span class="o">[</span><span class="n">is_ring_hom</span> <span class="n">f</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">R_alg_hom</span> <span class="o">:</span> <span class="n">sβ</span> <span class="bp">=</span> <span class="n">f</span> <span class="err">∘</span> <span class="n">sα</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_unique</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">[</span><span class="n">is_ring_hom</span> <span class="n">g</span><span class="o">],</span> <span class="n">sβ</span> <span class="bp">=</span> <span class="n">g</span> <span class="err">∘</span> <span class="n">sα</span> <span class="bp">→</span> <span class="n">g</span> <span class="bp">=</span> <span class="n">f</span><span class="o">)</span>
</pre></div>

<a name="125799370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125799370" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125799370">Kevin Buzzard (Apr 28 2018 at 00:02)</a>:</h4>
<p>(NB it was <code>is_unique_R_alg_hom</code> which I noticed was not a <code>Prop</code> even though it could be -- I made it a Prop.)</p>

<a name="125799381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125799381" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125799381">Kevin Buzzard (Apr 28 2018 at 00:03)</a>:</h4>
<p>I have lots of cunning ways of producing unique R-algebra homs</p>

<a name="125799386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125799386" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125799386">Kevin Buzzard (Apr 28 2018 at 00:03)</a>:</h4>
<p>for example given a ring hom <code>R -&gt; \beta</code> with the property that every element of a mult subset <code>S</code> gets sent to a unit</p>

<a name="125799428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125799428" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125799428">Kevin Buzzard (Apr 28 2018 at 00:04)</a>:</h4>
<p>I have a unique <code>R</code>-alg com <code>R[1/S] -&gt; beta</code></p>

<a name="125799431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125799431" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125799431">Kevin Buzzard (Apr 28 2018 at 00:04)</a>:</h4>
<p>I am hoping that the ideas I already have will be enough to see me through</p>

<a name="125799440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125799440" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125799440">Kevin Buzzard (Apr 28 2018 at 00:05)</a>:</h4>
<p>so I am going to try and define the structures that we want to identify and then see if I can figure out what needs doing.</p>

<a name="125799448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125799448" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125799448">Kevin Buzzard (Apr 28 2018 at 00:05)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> In short I am saying that your proof of exactness being preserved stinks</p>

<a name="125799454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125799454" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125799454">Kevin Buzzard (Apr 28 2018 at 00:05)</a>:</h4>
<p>and it would be better to have a proof which looks a whole lot more abstract</p>

<a name="125799497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125799497" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125799497">Kevin Buzzard (Apr 28 2018 at 00:06)</a>:</h4>
<p>because then when next week I have to prove something ten times longer but just as trivial</p>

<a name="125799500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125799500" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125799500">Kevin Buzzard (Apr 28 2018 at 00:06)</a>:</h4>
<p>we can get xena to do it for us</p>

<a name="125800546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125800546" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125800546">Scott Morrison (Apr 28 2018 at 00:38)</a>:</h4>
<p>Wow... a lot happened while I slept. :-)</p>

<a name="125800763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125800763" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125800763">Simon Hudon (Apr 28 2018 at 00:43)</a>:</h4>
<p>Let this be a lesson to you: don't sleep</p>

<a name="125801226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125801226" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125801226">Kevin Buzzard (Apr 28 2018 at 00:59)</a>:</h4>
<p>Does this look OK:</p>

<a name="125801228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125801228" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125801228">Kevin Buzzard (Apr 28 2018 at 01:00)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span>
<span class="c1">-- recall the interface for equiv:</span>
<span class="c1">-- C : equiv α β;</span>
<span class="c1">-- the function is C, the function the other way is C.symm, which is also the equiv the other way</span>
<span class="c1">-- and the proofs are C.inverse_apply_apply and C.apply_inverse_apply</span>
<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="n">u&#39;</span> <span class="n">v&#39;</span> <span class="n">w&#39;</span>

<span class="kn">open</span> <span class="n">equiv</span>

<span class="c1">-- Scott&#39;s basic class.</span>
<span class="n">class</span> <span class="n">transportable</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">on_equiv</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">equiv</span> <span class="n">α</span> <span class="n">β</span><span class="o">),</span> <span class="n">equiv</span> <span class="o">(</span><span class="n">f</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">β</span><span class="o">))</span>
<span class="o">(</span><span class="n">on_refl</span>  <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">),</span> <span class="n">on_equiv</span> <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">refl</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">refl</span> <span class="o">(</span><span class="n">f</span> <span class="n">α</span><span class="o">))</span>
<span class="o">(</span><span class="n">on_trans</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">equiv</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">equiv</span> <span class="n">β</span> <span class="n">γ</span><span class="o">),</span> <span class="n">on_equiv</span> <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">trans</span> <span class="n">d</span> <span class="n">e</span><span class="o">)</span> <span class="bp">=</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">on_equiv</span> <span class="n">d</span><span class="o">)</span> <span class="o">(</span><span class="n">on_equiv</span> <span class="n">e</span><span class="o">))</span>

<span class="kn">variables</span>
<span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">}</span> <span class="o">{</span><span class="n">α&#39;</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u&#39;</span><span class="o">}</span> <span class="o">{</span><span class="n">β&#39;</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v&#39;</span><span class="o">}</span> <span class="o">{</span><span class="n">γ&#39;</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w&#39;</span><span class="o">}</span>

<span class="kn">structure</span> <span class="n">canonically_isomorphic_functions</span>
<span class="o">(</span><span class="n">Cα</span> <span class="o">:</span> <span class="n">equiv</span> <span class="n">α</span> <span class="n">α&#39;</span><span class="o">)</span> <span class="o">(</span><span class="n">Cβ</span> <span class="o">:</span> <span class="n">equiv</span> <span class="n">β</span> <span class="n">β&#39;</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">f&#39;</span> <span class="o">:</span> <span class="n">α&#39;</span> <span class="bp">→</span> <span class="n">β&#39;</span><span class="o">)</span> <span class="c1">-- extends equiv α α&#39;, equiv β β&#39;</span>
<span class="o">:=</span>
<span class="o">(</span><span class="n">commutes</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">Cβ</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f&#39;</span> <span class="o">(</span><span class="n">Cα</span> <span class="n">a</span><span class="o">))</span>
<span class="c1">-- is there a better way to do this with &quot;extends&quot;?</span>

<span class="c1">-- Do I need an interface for this? Why can&#39;t I make this a simp lemma?</span>
<span class="kn">theorem</span> <span class="n">canonically_isomorphic_functions</span><span class="bp">.</span><span class="n">diag_commutes</span>
<span class="o">(</span><span class="n">Cα</span> <span class="o">:</span> <span class="n">equiv</span> <span class="n">α</span> <span class="n">α&#39;</span><span class="o">)</span> <span class="o">(</span><span class="n">Cβ</span> <span class="o">:</span> <span class="n">equiv</span> <span class="n">β</span> <span class="n">β&#39;</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">f&#39;</span> <span class="o">:</span> <span class="n">α&#39;</span> <span class="bp">→</span> <span class="n">β&#39;</span><span class="o">)</span>
<span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">canonically_isomorphic_functions</span> <span class="n">Cα</span> <span class="n">Cβ</span> <span class="n">f</span> <span class="n">f&#39;</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">Cβ</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f&#39;</span> <span class="o">(</span><span class="n">Cα</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="n">C</span><span class="bp">.</span><span class="n">commutes</span>

<span class="kn">definition</span> <span class="n">canonically_isomorphic_functions</span><span class="bp">.</span><span class="n">refl</span> <span class="o">:</span>
<span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">),</span> <span class="n">canonically_isomorphic_functions</span>
<span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">refl</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">refl</span> <span class="n">β</span><span class="o">)</span> <span class="n">f</span> <span class="n">f</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span> <span class="n">β</span> <span class="n">f</span><span class="o">,</span><span class="bp">⟨λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span>

<span class="kn">definition</span> <span class="n">canonically_isomorphic_functions</span><span class="bp">.</span><span class="n">symm</span> <span class="o">:</span>
<span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">f&#39;</span> <span class="o">:</span> <span class="n">α&#39;</span> <span class="bp">→</span> <span class="n">β&#39;</span><span class="o">)</span> <span class="o">(</span><span class="n">Cα</span> <span class="o">:</span> <span class="n">equiv</span> <span class="n">α</span> <span class="n">α&#39;</span><span class="o">)</span> <span class="o">(</span><span class="n">Cβ</span> <span class="o">:</span> <span class="n">equiv</span> <span class="n">β</span> <span class="n">β&#39;</span><span class="o">),</span>
<span class="n">canonically_isomorphic_functions</span> <span class="n">Cα</span> <span class="n">Cβ</span> <span class="n">f</span> <span class="n">f&#39;</span> <span class="bp">→</span>
<span class="n">canonically_isomorphic_functions</span> <span class="n">Cα</span><span class="bp">.</span><span class="n">symm</span> <span class="n">Cβ</span><span class="bp">.</span><span class="n">symm</span> <span class="n">f&#39;</span> <span class="n">f</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">f</span> <span class="n">f&#39;</span> <span class="n">Cα</span> <span class="n">Cβ</span> <span class="n">Cf</span><span class="o">,</span><span class="bp">⟨λ</span> <span class="n">a&#39;</span><span class="o">,</span><span class="k">begin</span>
  <span class="n">suffices</span> <span class="o">:</span> <span class="n">Cβ</span><span class="bp">.</span><span class="n">symm</span> <span class="o">(</span><span class="n">f&#39;</span> <span class="o">(</span><span class="n">Cα</span> <span class="o">(</span><span class="n">Cα</span><span class="bp">.</span><span class="n">symm</span> <span class="n">a&#39;</span><span class="o">)))</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">Cα</span><span class="bp">.</span><span class="n">symm</span> <span class="n">a&#39;</span><span class="o">),</span>
    <span class="k">by</span> <span class="n">simpa</span> <span class="kn">using</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">suffices</span> <span class="o">:</span> <span class="n">Cβ</span><span class="bp">.</span><span class="n">symm</span> <span class="o">(</span><span class="n">Cβ</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">Cα</span><span class="bp">.</span><span class="n">symm</span> <span class="n">a&#39;</span><span class="o">)))</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">Cα</span><span class="bp">.</span><span class="n">symm</span> <span class="n">a&#39;</span><span class="o">),</span>
    <span class="k">by</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">Cf</span><span class="bp">.</span><span class="n">commutes</span> <span class="o">(</span><span class="n">Cα</span><span class="bp">.</span><span class="n">symm</span> <span class="n">a&#39;</span><span class="o">)],</span>
  <span class="n">simp</span><span class="o">,</span>
<span class="kn">end</span>
<span class="bp">⟩</span>


<span class="kn">definition</span> <span class="n">canonically_isomorphic_functions</span><span class="bp">.</span><span class="n">trans</span> <span class="o">:</span>
<span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">f&#39;</span> <span class="o">:</span> <span class="n">α&#39;</span> <span class="bp">→</span> <span class="n">β&#39;</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span> <span class="o">(</span><span class="n">g&#39;</span> <span class="o">:</span> <span class="n">β&#39;</span> <span class="bp">→</span> <span class="n">γ&#39;</span><span class="o">)</span>
<span class="o">(</span><span class="n">Cα</span> <span class="o">:</span> <span class="n">equiv</span> <span class="n">α</span> <span class="n">α&#39;</span><span class="o">)</span> <span class="o">(</span><span class="n">Cβ</span> <span class="o">:</span> <span class="n">equiv</span> <span class="n">β</span> <span class="n">β&#39;</span><span class="o">)</span> <span class="o">(</span><span class="n">Cγ</span> <span class="o">:</span> <span class="n">equiv</span> <span class="n">γ</span> <span class="n">γ&#39;</span><span class="o">),</span>
<span class="n">canonically_isomorphic_functions</span> <span class="n">Cα</span> <span class="n">Cβ</span> <span class="n">f</span> <span class="n">f&#39;</span> <span class="bp">→</span>
<span class="n">canonically_isomorphic_functions</span> <span class="n">Cβ</span> <span class="n">Cγ</span> <span class="n">g</span> <span class="n">g&#39;</span> <span class="bp">→</span>
<span class="n">canonically_isomorphic_functions</span> <span class="n">Cα</span> <span class="n">Cγ</span> <span class="o">(</span><span class="n">g</span> <span class="err">∘</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">g&#39;</span> <span class="err">∘</span> <span class="n">f&#39;</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">f</span> <span class="n">f&#39;</span> <span class="n">g</span> <span class="n">g&#39;</span> <span class="n">Cα</span> <span class="n">Cβ</span> <span class="n">Cγ</span> <span class="n">Cf</span> <span class="n">Cg</span><span class="o">,</span><span class="bp">⟨λ</span> <span class="n">a</span><span class="o">,</span><span class="k">begin</span>
  <span class="k">show</span> <span class="n">Cγ</span> <span class="o">(</span><span class="n">g</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">))</span> <span class="bp">=</span> <span class="n">g&#39;</span> <span class="o">(</span><span class="n">f&#39;</span> <span class="o">(</span><span class="n">Cα</span> <span class="n">a</span><span class="o">)),</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">Cg</span><span class="bp">.</span><span class="n">commutes</span><span class="o">,</span><span class="n">Cf</span><span class="bp">.</span><span class="n">commutes</span><span class="o">]</span>
<span class="kn">end</span><span class="bp">⟩</span>
</pre></div>

<a name="125801279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125801279" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125801279">Kevin Buzzard (Apr 28 2018 at 01:00)</a>:</h4>
<p>Scott, I was inspired by your structure</p>

<a name="125801280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125801280" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125801280">Kevin Buzzard (Apr 28 2018 at 01:00)</a>:</h4>
<p>Did you see the docs?</p>

<a name="125801284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125801284" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125801284">Kevin Buzzard (Apr 28 2018 at 01:00)</a>:</h4>
<p>It's a summary of what happened</p>

<a name="125801299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125801299" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125801299">Kevin Buzzard (Apr 28 2018 at 01:01)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> Can you fit these canonically isomorphic functions into your way of thinking?</p>

<a name="125801342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125801342" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125801342">Kevin Buzzard (Apr 28 2018 at 01:02)</a>:</h4>
<p><span class="user-mention" data-user-id="110524">@Scott Morrison</span> Johan expanded out your idea into a series of little definitions</p>

<a name="125801345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125801345" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125801345">Kevin Buzzard (Apr 28 2018 at 01:02)</a>:</h4>
<p>And <span class="user-mention" data-user-id="110064">@Kenny Lau</span> filled them all in</p>

<a name="125801346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125801346" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125801346">Kevin Buzzard (Apr 28 2018 at 01:02)</a>:</h4>
<p><a href="https://github.com/kckennylau/Lean/blob/master/johan_challenge.lean" target="_blank" title="https://github.com/kckennylau/Lean/blob/master/johan_challenge.lean">https://github.com/kckennylau/Lean/blob/master/johan_challenge.lean</a></p>

<a name="125801350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125801350" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125801350">Kevin Buzzard (Apr 28 2018 at 01:02)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> wrote something I didn't understand yet:</p>

<a name="125801351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125801351" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125801351">Kevin Buzzard (Apr 28 2018 at 01:02)</a>:</h4>
<p><a href="https://gist.github.com/rwbarton/d847ef6d1783f0d0859eb80de8327bad" target="_blank" title="https://gist.github.com/rwbarton/d847ef6d1783f0d0859eb80de8327bad">https://gist.github.com/rwbarton/d847ef6d1783f0d0859eb80de8327bad</a></p>

<a name="125801359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125801359" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125801359">Kevin Buzzard (Apr 28 2018 at 01:03)</a>:</h4>
<p>and I wrote some docs</p>

<a name="125801360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125801360" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125801360">Kevin Buzzard (Apr 28 2018 at 01:03)</a>:</h4>
<p><a href="https://github.com/kbuzzard/xena/blob/e77228397ad21215a927f93d315edf3cbadbc567/canonical_isomorphism/canonical.md" target="_blank" title="https://github.com/kbuzzard/xena/blob/e77228397ad21215a927f93d315edf3cbadbc567/canonical_isomorphism/canonical.md">https://github.com/kbuzzard/xena/blob/e77228397ad21215a927f93d315edf3cbadbc567/canonical_isomorphism/canonical.md</a></p>

<a name="125801407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125801407" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125801407">Kevin Buzzard (Apr 28 2018 at 01:04)</a>:</h4>
<p>and now I am wondering about whether it's a good idea to think of the concept that a square with equivs down the sides commutes</p>

<a name="125801411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125801411" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125801411">Kevin Buzzard (Apr 28 2018 at 01:04)</a>:</h4>
<p>as an equiv between the other two sides</p>

<a name="125801426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125801426" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125801426">Kevin Buzzard (Apr 28 2018 at 01:05)</a>:</h4>
<p>The definition doesn't seem to fit into your "transportable" yoga</p>

<a name="125801480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125801480" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125801480">Kevin Buzzard (Apr 28 2018 at 01:06)</a>:</h4>
<p>and this</p>

<a name="125801481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125801481" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125801481">Kevin Buzzard (Apr 28 2018 at 01:06)</a>:</h4>
<p><code>theorem topological_ring.transportable : transportable topological_ring := sorry</code></p>

<a name="125801482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125801482" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125801482">Kevin Buzzard (Apr 28 2018 at 01:06)</a>:</h4>
<p>is a type mismatch</p>

<a name="125801490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125801490" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125801490">Kevin Buzzard (Apr 28 2018 at 01:07)</a>:</h4>
<p>but on the other hand I am pretty sure I want to transport topological rings</p>

<a name="125801495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125801495" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125801495">Kevin Buzzard (Apr 28 2018 at 01:07)</a>:</h4>
<p><span class="user-mention" data-user-id="110026">@Simon Hudon</span> I wrote docs</p>

<a name="125801497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125801497" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125801497">Kevin Buzzard (Apr 28 2018 at 01:07)</a>:</h4>
<p>Do you want me to add anything else?</p>

<a name="125801499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125801499" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125801499">Kevin Buzzard (Apr 28 2018 at 01:07)</a>:</h4>
<p>I am currently working on formalising a high-level proof of the exactness statement I want</p>

<a name="125801605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125801605" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125801605">Reid Barton (Apr 28 2018 at 01:10)</a>:</h4>
<p>I haven't really caught up on any of the recent discussion, but regarding the commutative square with two equivs <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>e</mi><mi>A</mi></msub><mo>:</mo><mi>A</mi><mo>→</mo><msup><mi>A</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">e_A : A \to A'</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:0.901892em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mrel">:</span><span class="mord mathit">A</span><span class="mrel">→</span><span class="mord"><span class="mord mathit">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>e</mi><mi>B</mi></msub><mo>:</mo><mi>B</mi><mo>→</mo><msup><mi>B</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">e_B : B \to B'</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:0.901892em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mrel">:</span><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mrel">→</span><span class="mord"><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>, my current way of thinking about this is that transporting the structure of a map <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">f : A \to B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mrel">:</span><span class="mord mathit">A</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span> along these two equivs produces a map <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>A</mi><mo mathvariant="normal">′</mo></msup><mo>→</mo><msup><mi>B</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">A' \to B'</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:0.751892em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathit">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">′</span></span></span></span></span></span></span></span></span><span class="mrel">→</span><span class="mord"><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> which will be given by the formula <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>e</mi><mi>B</mi></msub><mo>∘</mo><mi>f</mi><mo>∘</mo><msubsup><mi>e</mi><mi>A</mi><mrow><mo>−</mo><mn>1</mn></mrow></msubsup></mrow><annotation encoding="application/x-tex">e_B \circ f \circ e_A^{-1}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.854239em;"></span><span class="strut bottom" style="height:1.14777em;vertical-align:-0.293531em;"></span><span class="base"><span class="mord"><span class="mord mathit">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mbin">∘</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mbin">∘</span><span class="mord"><span class="mord mathit">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.854239em;"><span style="top:-2.4064690000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">A</span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathrm mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.293531em;"></span></span></span></span></span></span></span></span></p>

<a name="125801610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125801610" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125801610">Reid Barton (Apr 28 2018 at 01:10)</a>:</h4>
<p>and the condition that your square commutes can then be reinterpreted as saying that the bottom map is the map that you get by transporting the top map along the sides</p>

<a name="125801620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125801620" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125801620">Kevin Buzzard (Apr 28 2018 at 01:11)</a>:</h4>
<p>So is this a relation between <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">f'</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> like <code>equiv</code>?</p>

<a name="125801622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125801622" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125801622">Kevin Buzzard (Apr 28 2018 at 01:11)</a>:</h4>
<p>Or is this a transportation of the structure?</p>

<a name="125801623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125801623" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125801623">Simon Hudon (Apr 28 2018 at 01:11)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> Thanks! </p>
<blockquote>
<p>I am currently working on formalising a high-level proof of the exactness statement I want</p>
</blockquote>
<p>That's a good idea. Maybe apologize everywhere you'd expect to derive a transferable instance</p>

<a name="125801661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125801661" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125801661">Kevin Buzzard (Apr 28 2018 at 01:12)</a>:</h4>
<p>Right</p>

<a name="125801664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125801664" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125801664">Kevin Buzzard (Apr 28 2018 at 01:12)</a>:</h4>
<p>or admit defeat</p>

<a name="125801665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125801665" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125801665">Reid Barton (Apr 28 2018 at 01:12)</a>:</h4>
<p>Which in turn, is going to be the condition you need to know that the fact that you transported across the isomorphisms (like exactness) is actually about your original maps A' -&gt; B' -&gt; C'.</p>

<a name="125803762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125803762" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125803762">Reid Barton (Apr 28 2018 at 02:33)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> I finished writing up the proof of the "three lemma" from <code>transportable</code> instances/lemmas which could plausibly be autogenerated. It's still pretty gross and could probably use some refinement.<br>
<a href="https://gist.github.com/rwbarton/08924014ebc7b1cf68ec624989249aff" target="_blank" title="https://gist.github.com/rwbarton/08924014ebc7b1cf68ec624989249aff">https://gist.github.com/rwbarton/08924014ebc7b1cf68ec624989249aff</a></p>

<a name="125804891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125804891" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125804891">Reid Barton (Apr 28 2018 at 03:18)</a>:</h4>
<p>Updated version uses a simp attribute to handle all the goals at once</p>

<a name="125805096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125805096" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125805096">Reid Barton (Apr 28 2018 at 03:26)</a>:</h4>
<p><span class="user-mention" data-user-id="110026">@Simon Hudon</span>, you might also be interested in the above--stuff defined as <code>magic</code> is what I would like to have autogenerated</p>

<a name="125805104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125805104" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125805104">Johan Commelin (Apr 28 2018 at 03:27)</a>:</h4>
<blockquote>
<p>By adding more <code>transportable</code> classes for type constructors with multiple arguments, we could extend these ideas to situations where we have an isomorphism which respects some existing structure and we want to transport some additional structure (or property) across it. Here is a sketch of the idea: <a href="https://gist.github.com/rwbarton/d847ef6d1783f0d0859eb80de8327bad" target="_blank" title="https://gist.github.com/rwbarton/d847ef6d1783f0d0859eb80de8327bad">https://gist.github.com/rwbarton/d847ef6d1783f0d0859eb80de8327bad</a></p>
</blockquote>
<p>I want some emphasis on this remark by Reid.</p>

<a name="125805143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125805143" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125805143">Johan Commelin (Apr 28 2018 at 03:28)</a>:</h4>
<p>This is very important. And our current proposal does not fit...</p>

<a name="125805146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125805146" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125805146">Johan Commelin (Apr 28 2018 at 03:29)</a>:</h4>
<p>So, how about this: Every time we define/prove a coercion, we also derive <code>transportable2</code> in the other direction.</p>

<a name="125805153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125805153" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125805153">Johan Commelin (Apr 28 2018 at 03:29)</a>:</h4>
<p>Which means, if you have two <code>int</code> that are equal, and one of them came from a <code>nat</code>, then the other one came from the same <code>nat</code></p>

<a name="125805210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125805210" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125805210">Johan Commelin (Apr 28 2018 at 03:31)</a>:</h4>
<p>But also, if you have a <code>ring R</code> that is group-isomorphic to some <code>group G</code>, then you get a ring structure on <code>G</code> for free, and the underlying group structure of this new ring structure is exactly the group structure on <code>G</code> that you started with.</p>

<a name="125805211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125805211" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125805211">Johan Commelin (Apr 28 2018 at 03:31)</a>:</h4>
<p>I think coercions exactly determine where transport of structure applies.</p>

<a name="125805440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125805440" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125805440">Johan Commelin (Apr 28 2018 at 03:41)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> Is what I'm saying canonically isomorphic to your remarks? I.e., did I transport the structure of your remarks?</p>

<a name="125806580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125806580" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125806580">Kevin Buzzard (Apr 28 2018 at 04:20)</a>:</h4>
<p>So I pushed my work on "canonically isomorphic functions" between canonically isomorphic types</p>

<a name="125806581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125806581" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125806581">Kevin Buzzard (Apr 28 2018 at 04:20)</a>:</h4>
<p><a href="https://github.com/kbuzzard/xena/blob/master/canonical_isomorphism/sheaf_canonical.lean" target="_blank" title="https://github.com/kbuzzard/xena/blob/master/canonical_isomorphism/sheaf_canonical.lean">https://github.com/kbuzzard/xena/blob/master/canonical_isomorphism/sheaf_canonical.lean</a></p>

<a name="125806594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125806594" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125806594">Kevin Buzzard (Apr 28 2018 at 04:21)</a>:</h4>
<p>Let me state what I think the state of things is</p>

<a name="125806595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125806595" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125806595">Kevin Buzzard (Apr 28 2018 at 04:21)</a>:</h4>
<p>We had an idea about defining a class called transportable</p>

<a name="125806597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125806597" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125806597">Kevin Buzzard (Apr 28 2018 at 04:21)</a>:</h4>
<p>and I want to define a structure called a canonical isomorphism</p>

<a name="125806598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125806598" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125806598">Kevin Buzzard (Apr 28 2018 at 04:21)</a>:</h4>
<p>which doesn't have to be the maths one</p>

<a name="125806638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125806638" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125806638">Kevin Buzzard (Apr 28 2018 at 04:22)</a>:</h4>
<p>but it has to be good enough to deal the mortal blow to the final boss in affine schemes.</p>

<a name="125806648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125806648" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125806648">Kevin Buzzard (Apr 28 2018 at 04:23)</a>:</h4>
<p>Transportable originally ate a function <code>Type -&gt; Type</code> or perhaps <code>Type u -&gt; Type v</code> depending on what mood people were in. Because this is a CS thing I suppose we will end up with <code>Type u -&gt; Type v</code></p>

<a name="125806649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125806649" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125806649">Kevin Buzzard (Apr 28 2018 at 04:23)</a>:</h4>
<p>But now we want it to eat more</p>

<a name="125806690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125806690" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125806690">Kevin Buzzard (Apr 28 2018 at 04:24)</a>:</h4>
<p>for example we want it to eat the instance of the type class resolution system which sends a ring to an additive group</p>

<a name="125806699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125806699" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125806699">Kevin Buzzard (Apr 28 2018 at 04:25)</a>:</h4>
<p>and spit out a theorem that says that if a equiv a' then the square commutes up to definitional equality.</p>

<a name="125806700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125806700" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125806700">Kevin Buzzard (Apr 28 2018 at 04:25)</a>:</h4>
<p>by which I mean Lean definitional equality, ideally.</p>

<a name="125806742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125806742" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125806742">Kevin Buzzard (Apr 28 2018 at 04:26)</a>:</h4>
<p>the square goes from ring a to ring a' on the top, from group a to group a' on the bottom, and the maps down are coming from the type class inference system</p>

<a name="125806745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125806745" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125806745">Kevin Buzzard (Apr 28 2018 at 04:27)</a>:</h4>
<p>So which instances of type class inference will commute with equiv in this way?</p>

<a name="125806802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125806802" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125806802">Kevin Buzzard (Apr 28 2018 at 04:29)</a>:</h4>
<p>Can we not _assume_ that if alpha is a type which happens to have both a group structure and a ring structure then the group structure associated to the ring structure is the one which the type class inference system would associate to the ring structure?</p>

<a name="125806803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125806803" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125806803">Kevin Buzzard (Apr 28 2018 at 04:29)</a>:</h4>
<p>Because if this is not the case then the Diamond is nigh, right?</p>

<a name="125806843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125806843" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125806843">Kevin Buzzard (Apr 28 2018 at 04:30)</a>:</h4>
<p>So this would seem like the correct theorem to prove</p>

<a name="125806848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125806848" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125806848">Kevin Buzzard (Apr 28 2018 at 04:30)</a>:</h4>
<p>Oh I have a question <span class="user-mention" data-user-id="112680">@Johan Commelin</span> !</p>

<a name="125806849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125806849" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125806849">Reid Barton (Apr 28 2018 at 04:30)</a>:</h4>
<p>Kevin, I'm not sure how helpful this remark will be, but your <code>canonically_isomorphic_functions Cα Cβ f f'</code> is in my setup <code>f' = transport2 (→) Cα Cβ f</code></p>

<a name="125806850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125806850" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125806850">Kevin Buzzard (Apr 28 2018 at 04:30)</a>:</h4>
<p>Do you know those WIP docs?</p>

<a name="125806852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125806852" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125806852">Andrew Ashworth (Apr 28 2018 at 04:30)</a>:</h4>
<p>a tactic that takes two types, a function relating the two, and from Prop (input 1) return Prop (input 2), is that what people are discussing?</p>

<a name="125806853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125806853" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125806853">Kevin Buzzard (Apr 28 2018 at 04:30)</a>:</h4>
<p>Mario gave me an example of a way to break the type class resolution system in a really annoying way</p>

<a name="125806858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125806858" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125806858">Kevin Buzzard (Apr 28 2018 at 04:31)</a>:</h4>
<p>What happens if you try and prove that those maps are all canonical?</p>

<a name="125806861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125806861" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125806861">Kevin Buzzard (Apr 28 2018 at 04:31)</a>:</h4>
<p>Does that make any sense?</p>

<a name="125806863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125806863" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125806863">Kevin Buzzard (Apr 28 2018 at 04:31)</a>:</h4>
<p>Reid, I am sure you are thinking about it in a better way than me</p>

<a name="125806865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125806865" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125806865">Kevin Buzzard (Apr 28 2018 at 04:31)</a>:</h4>
<p>and I am absolutely convinved that we should get this as abstract as possible</p>

<a name="125806866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125806866" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125806866">Kevin Buzzard (Apr 28 2018 at 04:31)</a>:</h4>
<p>thanks for the pointer!</p>

<a name="125806904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125806904" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125806904">Johan Commelin (Apr 28 2018 at 04:32)</a>:</h4>
<p><span class="user-mention" data-user-id="110025">@Andrew Ashworth</span> Yes, more or less.</p>

<a name="125806908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125806908" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125806908">Reid Barton (Apr 28 2018 at 04:32)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span>, I'm not sure what you mean by coercion. Are you talking about <code>has_coe</code>?</p>

<a name="125806909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125806909" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125806909">Johan Commelin (Apr 28 2018 at 04:32)</a>:</h4>
<p><span class="user-mention" data-user-id="110025">@Andrew Ashworth</span> The basic example. Given <code>a b : Type</code>, <code>equiv a b</code> and also <code>[group a]</code> we want to automagically have <code>group b</code></p>

<a name="125806915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125806915" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125806915">Andrew Ashworth (Apr 28 2018 at 04:33)</a>:</h4>
<p>i'll mention again the transfer tactic in core lean that produces <code>int</code> from <code>pairs of nat</code>, and the paper that describes it is linked earlier... unless i'm totally off-base</p>

<a name="125806917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125806917" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125806917">Johan Commelin (Apr 28 2018 at 04:33)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> I'm still a novice. But I guess that is what I mean.</p>

<a name="125806918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125806918" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125806918">Kevin Buzzard (Apr 28 2018 at 04:33)</a>:</h4>
<p><a href="https://github.com/kbuzzard/mathlib/blob/WIP_docs/docs/WIPs/type_class_inference.md" target="_blank" title="https://github.com/kbuzzard/mathlib/blob/WIP_docs/docs/WIPs/type_class_inference.md">https://github.com/kbuzzard/mathlib/blob/WIP_docs/docs/WIPs/type_class_inference.md</a></p>

<a name="125806958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125806958" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125806958">Kevin Buzzard (Apr 28 2018 at 04:34)</a>:</h4>
<p>In the "to be tidied" section</p>

<a name="125806960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125806960" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125806960">Kevin Buzzard (Apr 28 2018 at 04:34)</a>:</h4>
<p>there is Mario busting the type class inference system</p>

<a name="125806962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125806962" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125806962">Kevin Buzzard (Apr 28 2018 at 04:34)</a>:</h4>
<p>following an idea of mine</p>

<a name="125806963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125806963" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125806963">Kevin Buzzard (Apr 28 2018 at 04:34)</a>:</h4>
<p>trying to find a fairly explicit example of how it can bust</p>

<a name="125806966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125806966" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125806966">Kevin Buzzard (Apr 28 2018 at 04:35)</a>:</h4>
<p>because two natural numbers are equal but the proof is not "rfl"</p>

<a name="125807014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807014" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807014">Kevin Buzzard (Apr 28 2018 at 04:36)</a>:</h4>
<p>The type class system breaks quite badly if you find two different ways of getting from A to B</p>

<a name="125807015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807015" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807015">Kevin Buzzard (Apr 28 2018 at 04:36)</a>:</h4>
<p>On the other hand I am pretty sure that I want to allow more than one canonical isomorphism between two objects</p>

<a name="125807021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807021" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807021">Andrew Ashworth (Apr 28 2018 at 04:37)</a>:</h4>
<p>transfer in action: constructing an efficient representation of <code>int</code> from the pre-int pair of nat... <a href="https://github.com/leanprover/lean/blob/master/library/init/data/int/basic.lean" target="_blank" title="https://github.com/leanprover/lean/blob/master/library/init/data/int/basic.lean">https://github.com/leanprover/lean/blob/master/library/init/data/int/basic.lean</a></p>

<a name="125807022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807022" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807022">Kevin Buzzard (Apr 28 2018 at 04:37)</a>:</h4>
<p>For example I think I want the sum of two canonical isomorphisms from a group to a group to be a canonical isomorphism</p>

<a name="125807024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807024" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807024">Kevin Buzzard (Apr 28 2018 at 04:37)</a>:</h4>
<p>I know int.basic pretty well</p>

<a name="125807025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807025" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807025">Kevin Buzzard (Apr 28 2018 at 04:37)</a>:</h4>
<p>What does this have to do with anything?</p>

<a name="125807026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807026" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807026">Kevin Buzzard (Apr 28 2018 at 04:37)</a>:</h4>
<p>I understand the int typeclass</p>

<a name="125807066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807066" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807066">Kevin Buzzard (Apr 28 2018 at 04:38)</a>:</h4>
<p>and you are saying that int canonically bijects with nat + nat?</p>

<a name="125807067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807067" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807067">Kevin Buzzard (Apr 28 2018 at 04:38)</a>:</h4>
<p>I would say that that bijection is not canonical</p>

<a name="125807068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807068" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807068">Kevin Buzzard (Apr 28 2018 at 04:38)</a>:</h4>
<p>It's a junk theorem I think</p>

<a name="125807069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807069" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807069">Kevin Buzzard (Apr 28 2018 at 04:38)</a>:</h4>
<p>In a parallel universe int was constructed as a quotient type on nat x nat</p>

<a name="125807072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807072" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807072">Kevin Buzzard (Apr 28 2018 at 04:39)</a>:</h4>
<p>or one day Leo changes int to this</p>

<a name="125807075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807075" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807075">Kevin Buzzard (Apr 28 2018 at 04:39)</a>:</h4>
<p>and nobody notices</p>

<a name="125807076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807076" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807076">Kevin Buzzard (Apr 28 2018 at 04:39)</a>:</h4>
<p>because maybe we all use the int interface</p>

<a name="125807079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807079" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807079">Andrew Ashworth (Apr 28 2018 at 04:39)</a>:</h4>
<p>isn't that the tactic machinery you're interested in, however?</p>

<a name="125807080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807080" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807080">Kevin Buzzard (Apr 28 2018 at 04:39)</a>:</h4>
<p>Evidence that that bijection is not canonical is that it does not behave well with respect to arithmetic operations like +</p>

<a name="125807081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807081" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807081">Kevin Buzzard (Apr 28 2018 at 04:39)</a>:</h4>
<p>Oh -- I see</p>

<a name="125807084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807084" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807084">Johan Commelin (Apr 28 2018 at 04:39)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> Concerning Mario's example. Basically, you prove that <code>nat \times nat</code> has a ring structure, and then coerce by taking the sum. But the sum is not a ring homomorphism... Is that what is going on?</p>

<a name="125807085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807085" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807085">Kevin Buzzard (Apr 28 2018 at 04:39)</a>:</h4>
<p>I'm afraid my eyes glaze over whenever I see tactic machinery</p>

<a name="125807123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807123" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807123">Kevin Buzzard (Apr 28 2018 at 04:40)</a>:</h4>
<p>I don't understand it at all</p>

<a name="125807133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807133" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807133">Reid Barton (Apr 28 2018 at 04:40)</a>:</h4>
<p>It actually is using <code>nat \times nat</code>.</p>

<a name="125807134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807134" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807134">Kevin Buzzard (Apr 28 2018 at 04:40)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> no multiplication is involved</p>

<a name="125807151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807151" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807151">Kevin Buzzard (Apr 28 2018 at 04:41)</a>:</h4>
<p>no multiplication of nats at least</p>

<a name="125807153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807153" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807153">Kenny Lau (Apr 28 2018 at 04:41)</a>:</h4>
<blockquote>
<p>because maybe we all use the int interface</p>
</blockquote>
<p>nope. lots of things in mathlib use the definition of int</p>

<a name="125807156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807156" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807156">Kevin Buzzard (Apr 28 2018 at 04:41)</a>:</h4>
<p>Johan -- the only canonical thing you are allowed to do with nats is add them up in Mario's example</p>

<a name="125807157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807157" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807157">Kevin Buzzard (Apr 28 2018 at 04:41)</a>:</h4>
<p>So there's a type which carries a nat</p>

<a name="125807194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807194" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807194">Kevin Buzzard (Apr 28 2018 at 04:42)</a>:</h4>
<p>and one which carries two nats</p>

<a name="125807197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807197" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807197">Kevin Buzzard (Apr 28 2018 at 04:42)</a>:</h4>
<p>and the type class inference system will take you from the two nat guys to the one nat guys by just adding up their two nats</p>

<a name="125807198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807198" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807198">Johan Commelin (Apr 28 2018 at 04:42)</a>:</h4>
<p>Ah, sorry, brainfarting again</p>

<a name="125807202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807202" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807202">Kevin Buzzard (Apr 28 2018 at 04:42)</a>:</h4>
<p>But there is also this product construction</p>

<a name="125807203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807203" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807203">Reid Barton (Apr 28 2018 at 04:43)</a>:</h4>
<p>Er, to clarify, the <code>int</code> transfer stuff (which I don't know anything about) uses <code>nat \times nat</code></p>

<a name="125807209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807209" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807209">Kevin Buzzard (Apr 28 2018 at 04:43)</a>:</h4>
<p>and you just add up the nats</p>

<a name="125807214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807214" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807214">Kevin Buzzard (Apr 28 2018 at 04:43)</a>:</h4>
<p>so now there's two ways of getting from a pair <code>(a,b)</code> of two-nat guys</p>

<a name="125807215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807215" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807215">Kevin Buzzard (Apr 28 2018 at 04:43)</a>:</h4>
<p>to one one-nat guy</p>

<a name="125807256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807256" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807256">Kevin Buzzard (Apr 28 2018 at 04:44)</a>:</h4>
<p>and <code>(r+s)+(t+u)</code> is not definitionally equal to <code>(r+t)+(s+u)</code></p>

<a name="125807257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807257" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807257">Kevin Buzzard (Apr 28 2018 at 04:44)</a>:</h4>
<p>you need a proof by induction for that</p>

<a name="125807259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807259" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807259">Johan Commelin (Apr 28 2018 at 04:44)</a>:</h4>
<p>Right, that's what is going on</p>

<a name="125807264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807264" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807264">Kevin Buzzard (Apr 28 2018 at 04:45)</a>:</h4>
<p>and then rw stops working</p>

<a name="125807268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807268" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807268">Kevin Buzzard (Apr 28 2018 at 04:45)</a>:</h4>
<p>because rw keeps track of the exact definitions of the instances</p>

<a name="125807269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807269" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807269">Kevin Buzzard (Apr 28 2018 at 04:45)</a>:</h4>
<p>no</p>

<a name="125807270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807270" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807270">Kevin Buzzard (Apr 28 2018 at 04:45)</a>:</h4>
<p>the types keep track</p>

<a name="125807271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807271" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807271">Johan Commelin (Apr 28 2018 at 04:45)</a>:</h4>
<p><span class="user-mention" data-user-id="110025">@Andrew Ashworth</span> Which lines should we look at, to see transfer in action, in int/basic.lean</p>

<a name="125807273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807273" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807273">Kevin Buzzard (Apr 28 2018 at 04:45)</a>:</h4>
<p>and rw looks at the types</p>

<a name="125807315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807315" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807315">Andrew Ashworth (Apr 28 2018 at 04:46)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> line 399 proves the integers form a ring</p>

<a name="125807324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807324" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807324">Andrew Ashworth (Apr 28 2018 at 04:47)</a>:</h4>
<p>the setup starts at line 269</p>

<a name="125807367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807367" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807367">Johan Commelin (Apr 28 2018 at 04:48)</a>:</h4>
<p>I have the instinctive feeling that this is related, but somewhat different from what we are discussing.</p>

<a name="125807370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807370" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807370">Kevin Buzzard (Apr 28 2018 at 04:49)</a>:</h4>
<p>I guess I understand much less of this part of int.nat than I remembered</p>

<a name="125807375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807375" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807375">Kevin Buzzard (Apr 28 2018 at 04:49)</a>:</h4>
<p>what is all this rel stuff?</p>

<a name="125807378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807378" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807378">Johan Commelin (Apr 28 2018 at 04:49)</a>:</h4>
<p>But maybe I don't get what this part of the file is trying to prove</p>

<a name="125807437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807437" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807437">Kevin Buzzard (Apr 28 2018 at 04:50)</a>:</h4>
<p>I see.</p>

<a name="125807439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807439" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807439">Kevin Buzzard (Apr 28 2018 at 04:50)</a>:</h4>
<p><code>rel_int_nat_nat (z : int)</code></p>

<a name="125807442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807442" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807442">Kevin Buzzard (Apr 28 2018 at 04:51)</a>:</h4>
<p>is the set of pairs (a,b) in nat x nat</p>

<a name="125807446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807446" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807446">Kevin Buzzard (Apr 28 2018 at 04:51)</a>:</h4>
<p>such that a - b = z</p>

<a name="125807447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807447" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807447">Kevin Buzzard (Apr 28 2018 at 04:51)</a>:</h4>
<p>so it's the equivalence class</p>

<a name="125807486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807486" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807486">Johan Commelin (Apr 28 2018 at 04:52)</a>:</h4>
<p><span class="user-mention" data-user-id="110025">@Andrew Ashworth</span> Are you saying: there is a ring structure on a quotient of <code>nat \times nat</code> and there is a bijection between <code>Z</code> and this quotient. And this is how we transfer the ring structure onto <code>Z</code></p>

<a name="125807487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807487" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807487">Johan Commelin (Apr 28 2018 at 04:52)</a>:</h4>
<p>Is that what is going on?</p>

<a name="125807489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807489" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807489">Johan Commelin (Apr 28 2018 at 04:52)</a>:</h4>
<p>I think it is. And if so, that is a perfect example.</p>

<a name="125807490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807490" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807490">Kevin Buzzard (Apr 28 2018 at 04:52)</a>:</h4>
<p>So there's all this rel stuff</p>

<a name="125807492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807492" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807492">Kevin Buzzard (Apr 28 2018 at 04:52)</a>:</h4>
<p>and suddenly there are some transfer tactics and it's all over.</p>

<a name="125807493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807493" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807493">Kevin Buzzard (Apr 28 2018 at 04:52)</a>:</h4>
<p>Who wrote that stuff?</p>

<a name="125807494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807494" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807494">Andrew Ashworth (Apr 28 2018 at 04:53)</a>:</h4>
<p>johannes hoezl</p>

<a name="125807499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807499" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807499">Johan Commelin (Apr 28 2018 at 04:53)</a>:</h4>
<blockquote>
<p>Who wrote that stuff?</p>
</blockquote>
<p><code>git blame</code></p>

<a name="125807501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807501" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807501">Johan Commelin (Apr 28 2018 at 04:53)</a>:</h4>
<p><a href="https://github.com/leanprover/lean/blame/f59c2f0ef59fdc1833b6ead6adca721123bd7932/library/init/data/int/basic.lean#L393" target="_blank" title="https://github.com/leanprover/lean/blame/f59c2f0ef59fdc1833b6ead6adca721123bd7932/library/init/data/int/basic.lean#L393">https://github.com/leanprover/lean/blame/f59c2f0ef59fdc1833b6ead6adca721123bd7932/library/init/data/int/basic.lean#L393</a></p>

<a name="125807543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807543" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807543">Johan Commelin (Apr 28 2018 at 04:54)</a>:</h4>
<p>Andrew, so now, we want to abstract this notion of transfer, and automatically derive it for lots of structures, given equivalences between types.</p>

<a name="125807544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807544" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807544">Kevin Buzzard (Apr 28 2018 at 04:54)</a>:</h4>
<p>I see</p>

<a name="125807545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807545" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807545">Kevin Buzzard (Apr 28 2018 at 04:54)</a>:</h4>
<p>Maybe he has something to say about what it means to be canonically isomorphic.</p>

<a name="125807546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807546" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807546">Kevin Buzzard (Apr 28 2018 at 04:54)</a>:</h4>
<p>Johannes introduced the transfer method</p>

<a name="125807594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807594" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807594">Kevin Buzzard (Apr 28 2018 at 04:56)</a>:</h4>
<p>Scott introduced this class with this cool <code>transportable</code> name and I've spent some time over the last 24 hours (I should probably sleep at some point) creating instances of this class and moving them around.</p>

<a name="125807597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807597" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807597">Kevin Buzzard (Apr 28 2018 at 04:56)</a>:</h4>
<p>What started me off was Johan's list of levels</p>

<a name="125807600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807600" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807600">Kevin Buzzard (Apr 28 2018 at 04:56)</a>:</h4>
<p>If we have a more general idea</p>

<a name="125807601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807601" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807601">Kevin Buzzard (Apr 28 2018 at 04:56)</a>:</h4>
<p>do we have another game to play?</p>

<a name="125807647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807647" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807647">Kevin Buzzard (Apr 28 2018 at 04:58)</a>:</h4>
<p>Johan -- here's how to catch an instance of the type class resolution system</p>

<a name="125807648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807648" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807648">Kevin Buzzard (Apr 28 2018 at 04:58)</a>:</h4>
<div class="codehilite"><pre><span></span>theorem T {α : Type u} [ring α] : add_group α := by apply_instance
#print T
</pre></div>

<a name="125807654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807654" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807654">Kevin Buzzard (Apr 28 2018 at 04:59)</a>:</h4>
<p><code>apply_instance</code> is a tactic which tries to solve things by type class inference</p>

<a name="125807659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807659" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807659">Johan Commelin (Apr 28 2018 at 04:59)</a>:</h4>
<p>Ok, let me think about how that might be useful</p>

<a name="125807683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807683" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807683">Kevin Buzzard (Apr 28 2018 at 05:00)</a>:</h4>
<p>Unfortunately I don't think we have an instance of <code>transportable add_group</code> yet</p>

<a name="125807701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807701" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807701">Kevin Buzzard (Apr 28 2018 at 05:00)</a>:</h4>
<p>Kenny wrote the ring one</p>

<a name="125807702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807702" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807702">Kevin Buzzard (Apr 28 2018 at 05:00)</a>:</h4>
<p>and one could copy</p>

<a name="125807706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807706" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807706">Kevin Buzzard (Apr 28 2018 at 05:00)</a>:</h4>
<p>These maps are in general forgetful functors</p>

<a name="125807707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807707" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807707">Reid Barton (Apr 28 2018 at 05:00)</a>:</h4>
<p>I think you would just delete all the lines which don't appear in <code>add_group</code>, yeah.</p>

<a name="125807708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807708" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807708">Reid Barton (Apr 28 2018 at 05:01)</a>:</h4>
<p>Then I guess your square involving forgetful functors and transported equivalences ought to commute definitionally</p>

<a name="125807716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807716" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807716">Kevin Buzzard (Apr 28 2018 at 05:01)</a>:</h4>
<div class="codehilite"><pre><span></span>@[instance, priority 100]
def add_comm_group.to_add_group : Π (α : Type u) [s : add_comm_group α], add_group α :=
λ (α : Type u) [s : add_comm_group α],
  {add := add_comm_group.add s,
   add_assoc := _,
   zero := add_comm_group.zero α s,
   zero_add := _,
   add_zero := _,
   neg := add_comm_group.neg s,
   add_left_neg := _}
</pre></div>

<a name="125807717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807717" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807717">Kevin Buzzard (Apr 28 2018 at 05:01)</a>:</h4>
<p>I am sure it will</p>

<a name="125807758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807758" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807758">Kevin Buzzard (Apr 28 2018 at 05:02)</a>:</h4>
<p>A different class of instance is the following:</p>

<a name="125807771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807771" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807771">Kevin Buzzard (Apr 28 2018 at 05:03)</a>:</h4>
<p>Wait</p>

<a name="125807772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807772" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807772">Kevin Buzzard (Apr 28 2018 at 05:03)</a>:</h4>
<p>this fails:</p>

<a name="125807803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807803" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807803">Kevin Buzzard (Apr 28 2018 at 05:04)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">T</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">group</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span>
<span class="n">group</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">β</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span>
</pre></div>

<a name="125807814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807814" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807814">Kevin Buzzard (Apr 28 2018 at 05:04)</a>:</h4>
<p>I was assuming "product of groups is a group" would be there</p>

<a name="125807815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807815" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807815">Kevin Buzzard (Apr 28 2018 at 05:04)</a>:</h4>
<p>Maybe it's in mathlib</p>

<a name="125807912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807912" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807912">Reid Barton (Apr 28 2018 at 05:08)</a>:</h4>
<p>I think you're talking about instances like</p>
<div class="codehilite"><pre><span></span><span class="kn">instance</span> <span class="n">blah</span> <span class="o">[</span><span class="n">ring</span> <span class="n">t</span><span class="o">]</span> <span class="o">:</span> <span class="n">some_other_thing</span> <span class="n">t</span> <span class="o">:=</span> <span class="bp">...</span>
</pre></div>

<a name="125807968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125807968" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125807968">Reid Barton (Apr 28 2018 at 05:11)</a>:</h4>
<p>Which is essentially just some arbitrary user-defined function <code>ring t \to some_other_thing t</code></p>

<a name="125808150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125808150" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125808150">Reid Barton (Apr 28 2018 at 05:19)</a>:</h4>
<p>So now your question from earlier becomes whether an arbitrary function of type <code>Π α : Type, ring α → add_comm_group α</code> will commute with the equivalences <code>ring α ≃ ring β</code>, <code>add_comm_group α ≃ add_comm_group β</code> obtained by transportation of structure along an equivalence <code>α ≃ β</code>.  The answer is (probably) that it is true for every function you can define in Lean, but you can't prove it as a theorem within Lean that applies to an arbitrary function. This is parametricity again</p>

<a name="125808311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125808311" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125808311">Johan Commelin (Apr 28 2018 at 05:25)</a>:</h4>
<p>Ok, and now we need some magic to automaticlly prove it for every function that we define.</p>

<a name="125808314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125808314" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125808314">Johan Commelin (Apr 28 2018 at 05:26)</a>:</h4>
<p>And then we don't care that we can't prove it for arbitrary functions. And we don't have to repeat ourselves in dozens of tiny variations.</p>

<a name="125808358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125808358" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125808358">Kevin Buzzard (Apr 28 2018 at 05:26)</a>:</h4>
<p>Here's an instance for "product of groups is a group"</p>

<a name="125808359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125808359" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125808359">Kevin Buzzard (Apr 28 2018 at 05:27)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">definition</span> <span class="n">prod_group</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">HG</span> <span class="o">:</span> <span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">HH</span> <span class="o">:</span> <span class="n">group</span> <span class="n">H</span><span class="o">]</span> <span class="o">:</span> <span class="n">group</span> <span class="o">(</span><span class="n">G</span> <span class="bp">×</span> <span class="n">H</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">mul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">g1</span><span class="o">,</span><span class="n">h1</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">g2</span><span class="o">,</span><span class="n">h2</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">g1</span> <span class="bp">*</span> <span class="n">g2</span><span class="o">,</span><span class="n">h1</span> <span class="bp">*</span> <span class="n">h2</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">mul_assoc</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">g1</span><span class="o">,</span><span class="n">h1</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">g2</span><span class="o">,</span><span class="n">h2</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">g3</span><span class="o">,</span><span class="n">h3</span><span class="bp">⟩</span><span class="o">,</span><span class="n">prod</span><span class="bp">.</span><span class="n">ext</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">⟨</span><span class="n">mul_assoc</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span><span class="n">mul_assoc</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_⟩</span><span class="o">,</span>
  <span class="n">one</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">HG</span><span class="bp">.</span><span class="n">one</span><span class="o">,</span><span class="n">HH</span><span class="bp">.</span><span class="n">one</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">one_mul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">g</span><span class="o">,</span><span class="n">h</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">prod</span><span class="bp">.</span><span class="n">ext</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">⟨</span><span class="n">one_mul</span> <span class="bp">_</span><span class="o">,</span><span class="n">one_mul</span> <span class="bp">_⟩</span><span class="o">,</span>
  <span class="n">mul_one</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">g</span><span class="o">,</span><span class="n">h</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">prod</span><span class="bp">.</span><span class="n">ext</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">⟨</span><span class="n">mul_one</span> <span class="bp">_</span><span class="o">,</span><span class="n">mul_one</span> <span class="bp">_⟩</span><span class="o">,</span>
  <span class="n">inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">g</span><span class="o">,</span><span class="n">h</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">group</span><span class="bp">.</span><span class="n">inv</span> <span class="n">g</span><span class="o">,</span><span class="n">group</span><span class="bp">.</span><span class="n">inv</span> <span class="n">h</span><span class="bp">⟩</span><span class="o">,</span><span class="c1">--begin end,--λ ⟨g,h⟩, ⟨HG.inv g,HH.inv h⟩,</span>
  <span class="n">mul_left_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">g</span><span class="o">,</span><span class="n">h</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">prod</span><span class="bp">.</span><span class="n">ext</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">⟨</span><span class="n">mul_left_inv</span> <span class="n">g</span><span class="o">,</span><span class="n">mul_left_inv</span> <span class="n">h</span><span class="bp">⟩</span>
<span class="o">}</span>
</pre></div>

<a name="125808360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125808360" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125808360">Reid Barton (Apr 28 2018 at 05:27)</a>:</h4>
<p>Yes, though it doesn't sound very easy, because the meta-level argument is some induction over the definition of the function, and I'm not sure whether a tactic even has access to the syntactic definition of a function</p>

<a name="125808365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125808365" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125808365">Reid Barton (Apr 28 2018 at 05:27)</a>:</h4>
<p>Maybe Mario could comment when he reappears</p>

<a name="125808463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125808463" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125808463">Johan Commelin (Apr 28 2018 at 05:30)</a>:</h4>
<blockquote>
<p>I'm not sure whether a tactic even has access to the syntactic definition of a function</p>
</blockquote>
<p>Right. This is the important question. If one of the Lean experts could help out, that would be awesome.</p>

<a name="125808787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125808787" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125808787">Scott Morrison (Apr 28 2018 at 05:43)</a>:</h4>
<p>Yes, in the tactic world we can look at the syntactic definitions of things.</p>

<a name="125808826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125808826" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125808826">Scott Morrison (Apr 28 2018 at 05:44)</a>:</h4>
<p>It's all just <code>expr</code>s.</p>

<a name="125813008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125813008" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125813008">Mario Carneiro (Apr 28 2018 at 08:33)</a>:</h4>
<p>Geez, you guys work too fast. I was going to say as a followup to my last post that parametricity is not as simple as <code>transportable</code>, and it seems like you are already running into its limitations. The problem is that it only works for unary type operators <code>Type u -&gt; Type v</code>, but for the induction to work you need a parametricity statement for many different sorts of higher order type operators. For example, a <code>Type -&gt; Type -&gt; Type</code> operator is parametric if whenever <code>A ~= A'</code> and <code>B ~= B'</code> then <code>F A B ~= F A B</code>. A <code>(Type -&gt; Type) -&gt; Type</code> operator is parametric if whenever <code>F</code> and <code>F'</code> are such that <code>A ~= A'</code> implies <code>F A ~= F' A'</code>, then <code>G F ~= G F'</code>.</p>
<p>There is some recursive definition of parametric that goes over the type of the higher-order functor, but you can't even define this recursion in lean since <code>Type</code> is not inductively generated by the Pi type and other stuff. But you can define tactics that produce such definitions, and tactics that prove that everything you care about satisfy its appropriate parametricity theorem. This is what "Theorems for free!" is about.</p>

<a name="125813265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125813265" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125813265">Mario Carneiro (Apr 28 2018 at 08:43)</a>:</h4>
<p>Also, in the presence of <code>choice</code> parametricity fails, so it's not actually true that all lean-definable terms are parametric. For example, given choice you have that everything is decidable, in particular type equality, so you can make definitions like <code>if x = nat then nat else empty</code> which is nonempty on <code>nat</code> and empty on <code>int</code> even though <code>nat ~= int</code>.</p>

<a name="125813314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125813314" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125813314">Mario Carneiro (Apr 28 2018 at 08:45)</a>:</h4>
<p>Or at least, that would be a counterexample if you knew <code>nat != int</code>. This comes back to the possible consistency of <code>A ~= B -&gt; A = B</code>; assuming it's consistent with lean <code>nat != int</code> is not provable, although there are certainly models of lean which refute <code>nat = int</code>.</p>

<a name="125819688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125819688" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125819688">Johan Commelin (Apr 28 2018 at 13:11)</a>:</h4>
<p><span class="user-mention" data-user-id="110524">@Scott Morrison</span> There you have your counterexample.</p>

<a name="125820700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125820700" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125820700">Kevin Buzzard (Apr 28 2018 at 13:52)</a>:</h4>
<p>I am not interested in weird questions about whether int is equal to nat.</p>

<a name="125820703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125820703" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125820703">Kevin Buzzard (Apr 28 2018 at 13:52)</a>:</h4>
<p>It seems to me that a canonical isomorphism is a pair of things</p>

<a name="125820705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125820705" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125820705">Kenny Lau (Apr 28 2018 at 13:52)</a>:</h4>
<p>I don't remember anyone asking your opinion :P</p>

<a name="125820706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125820706" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125820706">Kevin Buzzard (Apr 28 2018 at 13:53)</a>:</h4>
<p>firstly an equiv</p>

<a name="125820707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125820707" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125820707">Kevin Buzzard (Apr 28 2018 at 13:53)</a>:</h4>
<p>:-)</p>

<a name="125820710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125820710" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125820710">Kevin Buzzard (Apr 28 2018 at 13:53)</a>:</h4>
<p>and secondly a promise</p>

<a name="125820714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125820714" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125820714">Kevin Buzzard (Apr 28 2018 at 13:53)</a>:</h4>
<p>and the promise is that you promise not to do stuff which isn't respected by the equiv</p>

<a name="125820716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125820716" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125820716">Kevin Buzzard (Apr 28 2018 at 13:53)</a>:</h4>
<p>And in ZFC this promise is brushed under the carpet and there is a gentleman's agreement</p>

<a name="125820756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125820756" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125820756">Kevin Buzzard (Apr 28 2018 at 13:54)</a>:</h4>
<p>and all good mathematicians are aware of the agreement</p>

<a name="125820760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125820760" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125820760">Kevin Buzzard (Apr 28 2018 at 13:54)</a>:</h4>
<p>But in dependent type theory we have a bunch of uncultured computer scientists</p>

<a name="125820761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125820761" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125820761">Kevin Buzzard (Apr 28 2018 at 13:54)</a>:</h4>
<p>who don't know our gentlemanly ways</p>

<a name="125820763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125820763" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125820763">Kevin Buzzard (Apr 28 2018 at 13:54)</a>:</h4>
<p>and they are asking to see more details of the promise</p>

<a name="125820764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125820764" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125820764">Kevin Buzzard (Apr 28 2018 at 13:54)</a>:</h4>
<p>and what is worse</p>

<a name="125820768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125820768" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125820768">Kevin Buzzard (Apr 28 2018 at 13:55)</a>:</h4>
<p>they are demanding that we keep our promises.</p>

<a name="125820772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125820772" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125820772">Kevin Buzzard (Apr 28 2018 at 13:55)</a>:</h4>
<p>They are not buying the argument that we are gentlemen who keep our promises</p>

<a name="125820773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125820773" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125820773">Kevin Buzzard (Apr 28 2018 at 13:55)</a>:</h4>
<p>they want to see proof</p>

<a name="125820777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125820777" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125820777">Kevin Buzzard (Apr 28 2018 at 13:55)</a>:</h4>
<p>so now it is the mathematician's job to give them that proof.</p>

<a name="125820819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125820819" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125820819">Kevin Buzzard (Apr 28 2018 at 13:56)</a>:</h4>
<p>There is a wonderful story which goes back to a paper by Dick Gross in the early 1990s which was crucial in Wiles' original proof of Fermat's Last Theorem</p>

<a name="125820820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125820820" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125820820">Kenny Lau (Apr 28 2018 at 13:56)</a>:</h4>
<blockquote>
<p>But in dependent type theory we have a bunch of uncultured computer scientists</p>
</blockquote>
<p>right. you just said this in front of a bunch of computer scientists.</p>

<a name="125820823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125820823" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125820823">Kevin Buzzard (Apr 28 2018 at 13:56)</a>:</h4>
<p>Kenny: my provocative language is intentional</p>

<a name="125820829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125820829" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125820829">Kevin Buzzard (Apr 28 2018 at 13:57)</a>:</h4>
<p>I am trying to isolate what I believe is an important issue</p>

<a name="125820831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125820831" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125820831">Kevin Buzzard (Apr 28 2018 at 13:57)</a>:</h4>
<p>and I am using provocative language in an attempt to explain it and to get people interested in it.</p>

<a name="125820832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125820832" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125820832">Kevin Buzzard (Apr 28 2018 at 13:57)</a>:</h4>
<p>The story is that Dick Gross needed to analyse two cohomology groups</p>

<a name="125820872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125820872" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125820872">Kevin Buzzard (Apr 28 2018 at 13:58)</a>:</h4>
<p>and these cohomology groups were coming from two completely different cohomology theories</p>

<a name="125820874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125820874" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125820874">Kevin Buzzard (Apr 28 2018 at 13:58)</a>:</h4>
<p>but someone had written down a map between them which was completely natural and depended on no choices</p>

<a name="125820876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125820876" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125820876">Kevin Buzzard (Apr 28 2018 at 13:58)</a>:</h4>
<p>and they had proved that this map was an isomorphism</p>

<a name="125820877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125820877" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125820877">Kevin Buzzard (Apr 28 2018 at 13:58)</a>:</h4>
<p>and had asserted that it was a canonical isomorphism</p>

<a name="125820879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125820879" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125820879">Kevin Buzzard (Apr 28 2018 at 13:58)</a>:</h4>
<p>and we all believed them</p>

<a name="125820885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125820885" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125820885">Kevin Buzzard (Apr 28 2018 at 13:59)</a>:</h4>
<p>And Dick Gross needed to use some extra structure on these cohomology theories</p>

<a name="125820887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125820887" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125820887">Kevin Buzzard (Apr 28 2018 at 13:59)</a>:</h4>
<p>each of the cohomology theories came with a bunch of linear maps called Hecke operators</p>

<a name="125820890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125820890" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125820890">Kevin Buzzard (Apr 28 2018 at 13:59)</a>:</h4>
<p>which are completely canonically defined operators</p>

<a name="125820941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125820941" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125820941">Kevin Buzzard (Apr 28 2018 at 14:00)</a>:</h4>
<p>and Gross asserted without proof that the canonical isomorphism identified the canonically-defined actions of the Hecke operators on each of the theories</p>

<a name="125820943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125820943" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125820943">Kevin Buzzard (Apr 28 2018 at 14:00)</a>:</h4>
<p>and the referee was Jean-Pierre Serre</p>

<a name="125820944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125820944" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125820944">Kevin Buzzard (Apr 28 2018 at 14:00)</a>:</h4>
<p>and he caught this</p>

<a name="125820945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125820945" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125820945">Kevin Buzzard (Apr 28 2018 at 14:00)</a>:</h4>
<p>and he demanded that Gross prove it</p>

<a name="125820948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125820948" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125820948">Kevin Buzzard (Apr 28 2018 at 14:00)</a>:</h4>
<p>and this would have held up publication of this important paper for probably quite some time</p>

<a name="125820949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125820949" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125820949">Kevin Buzzard (Apr 28 2018 at 14:00)</a>:</h4>
<p>so Gross said no</p>

<a name="125820958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125820958" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125820958">Kevin Buzzard (Apr 28 2018 at 14:01)</a>:</h4>
<p>and instead he wrote in the introduction to his paper that his theorem depended on unchecked compatibilities between canonically defined operators on canonically isomorphic objects</p>

<a name="125820999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125820999" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125820999">Kevin Buzzard (Apr 28 2018 at 14:02)</a>:</h4>
<p>And Brian Conrad got a student of his to work out the details and the student wrote an entire PhD thesis checking that the diagrams did indeed commute</p>

<a name="125821000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125821000" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125821000">Kevin Buzzard (Apr 28 2018 at 14:02)</a>:</h4>
<p>because the proof was by no means formal</p>

<a name="125821001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125821001" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125821001">Kevin Buzzard (Apr 28 2018 at 14:02)</a>:</h4>
<p>and I am now wondering</p>

<a name="125821002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125821002" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125821002">Kevin Buzzard (Apr 28 2018 at 14:02)</a>:</h4>
<p>whether actually</p>

<a name="125821005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125821005" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125821005">Kevin Buzzard (Apr 28 2018 at 14:02)</a>:</h4>
<p>one could write a tactic to prove that theorem</p>

<a name="125821006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125821006" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125821006">Kevin Buzzard (Apr 28 2018 at 14:02)</a>:</h4>
<p>That would be an extraordinary project</p>

<a name="125821009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125821009" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125821009">Kevin Buzzard (Apr 28 2018 at 14:03)</a>:</h4>
<p>because that would be a computer not only checking the main result of a Stanford student's PhD thesis</p>

<a name="125821013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125821013" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125821013">Kevin Buzzard (Apr 28 2018 at 14:03)</a>:</h4>
<p>it would be a computer program which automatically generated the main result of a Stanford student's PhD thesis.</p>

<a name="125821014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125821014" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125821014">Kevin Buzzard (Apr 28 2018 at 14:03)</a>:</h4>
<p>A _mathematics_ student.</p>

<a name="125821053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125821053" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125821053">Kevin Buzzard (Apr 28 2018 at 14:04)</a>:</h4>
<p>And the reason a tactic might be able to prove this</p>

<a name="125821054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125821054" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125821054">Kevin Buzzard (Apr 28 2018 at 14:04)</a>:</h4>
<p>would be that when you prove that various maps are isomorphisms</p>

<a name="125821055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125821055" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125821055">Kevin Buzzard (Apr 28 2018 at 14:04)</a>:</h4>
<p>you don't just say "they are canonical"</p>

<a name="125821056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125821056" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125821056">Kevin Buzzard (Apr 28 2018 at 14:05)</a>:</h4>
<p>you write down what you mean, properly</p>

<a name="125821063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125821063" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125821063">Kevin Buzzard (Apr 28 2018 at 14:05)</a>:</h4>
<p>and then you check that all the operations that you do respect the canonical maps</p>

<a name="125822241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125822241" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125822241">Kevin Buzzard (Apr 28 2018 at 14:53)</a>:</h4>
<p>OK so here is a challenge to the mathematics / computer science community:</p>

<a name="125822282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125822282" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125822282">Kevin Buzzard (Apr 28 2018 at 14:54)</a>:</h4>
<p>write a tactic which proves that Gross' canonically defined Hecke operators on his canonically isomorphic spaces all match up with each other</p>

<a name="125822286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125822286" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125822286">Kevin Buzzard (Apr 28 2018 at 14:55)</a>:</h4>
<p>That sounds like a really fun project</p>

<a name="125822290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125822290" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125822290">Kevin Buzzard (Apr 28 2018 at 14:55)</a>:</h4>
<p>because it will need a mix of genuinely deep mathematics</p>

<a name="125822291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125822291" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125822291">Kenny Lau (Apr 28 2018 at 14:55)</a>:</h4>
<p>for M1R?</p>

<a name="125822292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125822292" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125822292">Kevin Buzzard (Apr 28 2018 at 14:55)</a>:</h4>
<p>and clever programming</p>

<a name="125822293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125822293" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125822293">Kevin Buzzard (Apr 28 2018 at 14:55)</a>:</h4>
<p>Kenny, that would be a great first year project :-)</p>

<a name="125822295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125822295" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125822295">Kevin Buzzard (Apr 28 2018 at 14:55)</a>:</h4>
<p>It would be an even better PhD project.</p>

<a name="125826517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125826517" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125826517">Simon Hudon (Apr 28 2018 at 17:43)</a>:</h4>
<blockquote>
<blockquote>
<p>But in dependent type theory we have a bunch of uncultured computer scientists</p>
</blockquote>
<p>right. you just said this in front of a bunch of computer scientists.</p>
</blockquote>
<p>I'm not sure if it's that I'm too uncultured to be insulted but it feels like Kevin paid the CS / formal methods community a beautiful compliment</p>

<a name="125827355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125827355" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125827355">Johan Commelin (Apr 28 2018 at 18:16)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> I love this story!</p>

<a name="125827363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125827363" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125827363">Johan Commelin (Apr 28 2018 at 18:17)</a>:</h4>
<p>Is this story only oral folklore? Or is there some written version (besides what you just wrote down in the chat)? I would love to be able to point others towards this story</p>

<a name="125831766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125831766" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125831766">Kevin Buzzard (Apr 28 2018 at 21:13)</a>:</h4>
<p>just google for Bryden Cais' PhD thesis</p>

<a name="125831768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125831768" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125831768">Kevin Buzzard (Apr 28 2018 at 21:13)</a>:</h4>
<p>I think it would be an absolutely monumental challenge to get a computer to prove it</p>

<a name="125831809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125831809" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125831809">Kevin Buzzard (Apr 28 2018 at 21:14)</a>:</h4>
<p>but anyone who tried would probably learn a lot about what a mathematician means when they say something is canonical</p>

<a name="125831813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125831813" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125831813">Kevin Buzzard (Apr 28 2018 at 21:14)</a>:</h4>
<p>Bryden is in AZ now</p>

<a name="125831822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125831822" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125831822">Kevin Buzzard (Apr 28 2018 at 21:15)</a>:</h4>
<p>and go from there to Dick Gross' paper</p>

<a name="125831862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125831862" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125831862">Kevin Buzzard (Apr 28 2018 at 21:16)</a>:</h4>
<p>and see the explanation about the unchecked compatibilities, a throw-away "well this is not 100% rigorous" admission in a paper which a few years later was to play a fundamental role in Wiles' proof of Fermat's Last Theorem.</p>

<a name="125831863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125831863" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125831863">Kevin Buzzard (Apr 28 2018 at 21:16)</a>:</h4>
<p>And mathematicans worried not one jot</p>

<a name="125831864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125831864" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125831864">Kevin Buzzard (Apr 28 2018 at 21:16)</a>:</h4>
<p>See Wiles' FLT paper and verify it references Gross' paper.</p>

<a name="125831872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125831872" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125831872">Kevin Buzzard (Apr 28 2018 at 21:17)</a>:</h4>
<p>perhaps because one day we knew a computer would come along and check the details.</p>

<a name="125831918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125831918" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125831918">Kevin Buzzard (Apr 28 2018 at 21:18)</a>:</h4>
<p>I bet Taylor-Wiles (the paper that fills in the gap) references the paper too.</p>

<a name="125831926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125831926" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125831926">Kevin Buzzard (Apr 28 2018 at 21:19)</a>:</h4>
<p>Absolutely wonderful.</p>

<a name="125831927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125831927" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125831927">Kevin Buzzard (Apr 28 2018 at 21:19)</a>:</h4>
<p>I just checked.</p>

<a name="125831928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125831928" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125831928">Kevin Buzzard (Apr 28 2018 at 21:19)</a>:</h4>
<p><a href="http://www.math.ias.edu/~rtaylor/hecke.pdf" target="_blank" title="http://www.math.ias.edu/~rtaylor/hecke.pdf">http://www.math.ias.edu/~rtaylor/hecke.pdf</a></p>

<a name="125831931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125831931" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125831931">Kevin Buzzard (Apr 28 2018 at 21:19)</a>:</h4>
<p>Seminal paper by Taylor and Wiles filling in the gap in Wiles' proof of Fermat's Last Theorem.</p>

<a name="125831933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125831933" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125831933">Kevin Buzzard (Apr 28 2018 at 21:19)</a>:</h4>
<p>Theorem: We fill in a gap.</p>

<a name="125831935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125831935" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125831935">Kevin Buzzard (Apr 28 2018 at 21:19)</a>:</h4>
<p>Footnote: WARNING : paper contains gap</p>

<a name="125831980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125831980" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125831980">Kevin Buzzard (Apr 28 2018 at 21:20)</a>:</h4>
<p>but we're not worried about that one</p>

<a name="125831986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125831986" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125831986">Kevin Buzzard (Apr 28 2018 at 21:21)</a>:</h4>
<p>And there was me thinking we were doing ZFC</p>

<a name="125831987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125831987" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125831987">Kevin Buzzard (Apr 28 2018 at 21:21)</a>:</h4>
<p>When did we stop?</p>

<a name="125832031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125832031" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125832031">Kevin Buzzard (Apr 28 2018 at 21:22)</a>:</h4>
<p>Bryden Cais thesis 2007, 12 years after FLT proved.</p>

<a name="125832033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125832033" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125832033">Kevin Buzzard (Apr 28 2018 at 21:22)</a>:</h4>
<p>You know what, I am pretty sure that the experts knew that there was a way around Gross' problems.</p>

<a name="125832036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125832036" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125832036">Kevin Buzzard (Apr 28 2018 at 21:23)</a>:</h4>
<p>So probably nobody made a fuss</p>

<a name="125832040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125832040" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125832040">Kevin Buzzard (Apr 28 2018 at 21:23)</a>:</h4>
<p>they only occurred in certain "higher weight" situations</p>

<a name="125832042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125832042" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125832042">Kevin Buzzard (Apr 28 2018 at 21:23)</a>:</h4>
<p>and the applications to FLT may not need that level of generality</p>

<a name="125832043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125832043" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125832043">Kevin Buzzard (Apr 28 2018 at 21:23)</a>:</h4>
<p>but I'm not sure you'll find a published explanation of this</p>

<a name="125832083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125832083" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125832083">Kevin Buzzard (Apr 28 2018 at 21:24)</a>:</h4>
<p>I'll ask Conrad whether he thinks his student proved Fermat's Last Theorem</p>

<a name="125834143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125834143" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125834143">Scott Morrison (Apr 28 2018 at 22:47)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> ,</p>
<blockquote>
<p><span class="user-mention" data-user-id="110524">@Scott Morrison</span> There you have your counterexample.</p>
</blockquote>
<p>I haven't quite caught up on this thread, but does this mean that "in the presence of <code>choice</code> I owe <span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  a beer"? Ok, I'll honour that anyway.</p>

<a name="125839073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125839073" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125839073">Reid Barton (Apr 29 2018 at 02:02)</a>:</h4>
<p>Do we have parametricity for things which are not <code>noncomputable</code>?</p>

<a name="125839370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125839370" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125839370">Kevin Buzzard (Apr 29 2018 at 02:15)</a>:</h4>
<p>I will remark that the thing I want to prove is functorial, is noncomputable.</p>

<a name="125839420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125839420" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125839420">Kevin Buzzard (Apr 29 2018 at 02:16)</a>:</h4>
<p>attempting to make it computable would not be a question I was that interested in</p>

<a name="125839421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125839421" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125839421">Kevin Buzzard (Apr 29 2018 at 02:16)</a>:</h4>
<p>but I am unsure as to whether or not it can be done. This goes back to the old question of how to represent the functions on a standard open in an affine scheme</p>

<a name="125846328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125846328" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125846328">Johan Commelin (Apr 29 2018 at 07:11)</a>:</h4>
<p><span class="user-mention" data-user-id="110524">@Scott Morrison</span> I guess so... you didn't post any formal requirements, and I am not a judge (-;</p>

<a name="125854648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854648" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854648">Kevin Buzzard (Apr 29 2018 at 13:04)</a>:</h4>
<p>Church numerals are kind of cool</p>

<a name="125854656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854656" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854656">Kenny Lau (Apr 29 2018 at 13:05)</a>:</h4>
<p>what is that message related to?</p>

<a name="125854697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854697" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854697">Kevin Buzzard (Apr 29 2018 at 13:06)</a>:</h4>
<p><a href="https://github.com/kbuzzard/xena/blob/06476597bd53a111bb3060d2d583e04c972d5204/canonical_isomorphism/church_blog_questions.lean" target="_blank" title="https://github.com/kbuzzard/xena/blob/06476597bd53a111bb3060d2d583e04c972d5204/canonical_isomorphism/church_blog_questions.lean">https://github.com/kbuzzard/xena/blob/06476597bd53a111bb3060d2d583e04c972d5204/canonical_isomorphism/church_blog_questions.lean</a></p>

<a name="125854698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854698" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854698">Kevin Buzzard (Apr 29 2018 at 13:06)</a>:</h4>
<p>Kenny, there are some more challenges for you</p>

<a name="125854699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854699" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854699">Kenny Lau (Apr 29 2018 at 13:06)</a>:</h4>
<p>nice, i love challenges</p>

<a name="125854700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854700" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854700">Kevin Buzzard (Apr 29 2018 at 13:06)</a>:</h4>
<p>I'm sure you won't have much trouble with succ, add and mul</p>

<a name="125854701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854701" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854701">Kevin Buzzard (Apr 29 2018 at 13:06)</a>:</h4>
<p>do you know how to do pow?</p>

<a name="125854702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854702" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854702">Kevin Buzzard (Apr 29 2018 at 13:06)</a>:</h4>
<p>And what about Ackermann?</p>

<a name="125854707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854707" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854707">Kenny Lau (Apr 29 2018 at 13:07)</a>:</h4>
<p>oh i thought you were talking about those proofs in your file</p>

<a name="125854708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854708" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854708">Kevin Buzzard (Apr 29 2018 at 13:07)</a>:</h4>
<p>And can you prove the equiv?</p>

<a name="125854709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854709" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854709">Kenny Lau (Apr 29 2018 at 13:07)</a>:</h4>
<p>they aren't equivalent</p>

<a name="125854710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854710" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854710">Kevin Buzzard (Apr 29 2018 at 13:07)</a>:</h4>
<p>The link I just posted is to a file with some sorries</p>

<a name="125854711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854711" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854711">Kevin Buzzard (Apr 29 2018 at 13:07)</a>:</h4>
<p>but I can fill in some of the sorries</p>

<a name="125854712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854712" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854712">Kenny Lau (Apr 29 2018 at 13:07)</a>:</h4>
<p>they aren't provable</p>

<a name="125854713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854713" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854713">Kevin Buzzard (Apr 29 2018 at 13:07)</a>:</h4>
<p>stop</p>

<a name="125854714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854714" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854714">Kevin Buzzard (Apr 29 2018 at 13:07)</a>:</h4>
<p>some are provable because I proved them</p>

<a name="125854715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854715" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854715">Kevin Buzzard (Apr 29 2018 at 13:07)</a>:</h4>
<p>you need to look at the file</p>

<a name="125854752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854752" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854752">Kevin Buzzard (Apr 29 2018 at 13:08)</a>:</h4>
<p>for each sorry in the file, either fill it in, or tell me confidently that it cannot be filled in</p>

<a name="125854755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854755" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854755">Kevin Buzzard (Apr 29 2018 at 13:08)</a>:</h4>
<p>that's your challenge</p>

<a name="125854756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854756" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854756">Kenny Lau (Apr 29 2018 at 13:08)</a>:</h4>
<p>ok</p>

<a name="125854757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854757" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854757">Kenny Lau (Apr 29 2018 at 13:08)</a>:</h4>
<p>I saw the word blog :D</p>

<a name="125854758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854758" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854758">Kevin Buzzard (Apr 29 2018 at 13:08)</a>:</h4>
<p>yes, I am going to write another blog post</p>

<a name="125854760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854760" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854760">Kevin Buzzard (Apr 29 2018 at 13:08)</a>:</h4>
<p>talking of blog posts</p>

<a name="125854761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854761" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854761">Kevin Buzzard (Apr 29 2018 at 13:08)</a>:</h4>
<p>I have a file which is both beautiful and disgusting</p>

<a name="125854767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854767" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854767">Kevin Buzzard (Apr 29 2018 at 13:09)</a>:</h4>
<p>beautiful because all the proofs are really uncluttered</p>

<a name="125854768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854768" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854768">Kenny Lau (Apr 29 2018 at 13:09)</a>:</h4>
<p>that tone in <code>KB doesn't understand</code> though lmao</p>

<a name="125854769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854769" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854769">Kevin Buzzard (Apr 29 2018 at 13:09)</a>:</h4>
<p>disgusting because I use constants</p>

<a name="125854814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854814" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854814">Kevin Buzzard (Apr 29 2018 at 13:10)</a>:</h4>
<p>Kenny -- is nat some inductive type which is somehow canonically associated to the Pi type of church numerals?</p>

<a name="125854815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854815" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854815">Kevin Buzzard (Apr 29 2018 at 13:10)</a>:</h4>
<p>look at my definition of <code>to_nat</code></p>

<a name="125854816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854816" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854816">Kevin Buzzard (Apr 29 2018 at 13:11)</a>:</h4>
<p>it takes all the ingredients of nat exactly once, and nothing more</p>

<a name="125854821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854821" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854821">Kenny Lau (Apr 29 2018 at 13:11)</a>:</h4>
<p>sure, <code>Π X : Type, (X → X) → X → X</code> is the Church encoding of the type <code>nat</code></p>

<a name="125854822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854822" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854822">Kevin Buzzard (Apr 29 2018 at 13:11)</a>:</h4>
<p>I don't know what that means</p>

<a name="125854823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854823" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854823">Kevin Buzzard (Apr 29 2018 at 13:11)</a>:</h4>
<p>which types have a church encoding?</p>

<a name="125854824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854824" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854824">Kenny Lau (Apr 29 2018 at 13:11)</a>:</h4>
<p>inductive types I guess</p>

<a name="125854825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854825" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854825">Kenny Lau (Apr 29 2018 at 13:11)</a>:</h4>
<p>not very sure</p>

<a name="125854826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854826" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854826">Kenny Lau (Apr 29 2018 at 13:12)</a>:</h4>
<p>maybe pi types as well</p>

<a name="125854865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854865" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854865">Kevin Buzzard (Apr 29 2018 at 13:12)</a>:</h4>
<p>so you cannot formalise the assertion you just made?</p>

<a name="125854866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854866" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854866">Kevin Buzzard (Apr 29 2018 at 13:12)</a>:</h4>
<p>You are making some informal statement?</p>

<a name="125854867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854867" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854867">Kenny Lau (Apr 29 2018 at 13:12)</a>:</h4>
<p>I don't know everything about church encoding</p>

<a name="125854868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854868" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854868">Kevin Buzzard (Apr 29 2018 at 13:12)</a>:</h4>
<p>but is there some rigorous statement that an expert can make?</p>

<a name="125854869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854869" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854869">Kenny Lau (Apr 29 2018 at 13:12)</a>:</h4>
<p>I believe so</p>

<a name="125854870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854870" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854870">Kevin Buzzard (Apr 29 2018 at 13:12)</a>:</h4>
<p>"church encoding" has a formal definition?</p>

<a name="125854876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854876" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854876">Kevin Buzzard (Apr 29 2018 at 13:13)</a>:</h4>
<p>What is the church encoding of a scheme?</p>

<a name="125854877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854877" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854877">Kevin Buzzard (Apr 29 2018 at 13:13)</a>:</h4>
<p>what is the church encoding of int as defined in Lean?</p>

<a name="125854878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854878" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854878">Kevin Buzzard (Apr 29 2018 at 13:13)</a>:</h4>
<p>what is the church encoding of list?</p>

<a name="125854879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854879" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854879">Kevin Buzzard (Apr 29 2018 at 13:13)</a>:</h4>
<p>what is the church encoding of bool?</p>

<a name="125854880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854880" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854880">Kevin Buzzard (Apr 29 2018 at 13:13)</a>:</h4>
<p>what is the church encoding of false?</p>

<a name="125854881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854881" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854881">Kenny Lau (Apr 29 2018 at 13:14)</a>:</h4>
<blockquote>
<p>what is the church encoding of bool?</p>
</blockquote>
<p><code>X -&gt; X -&gt; X</code> :P</p>

<a name="125854918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854918" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854918">Kenny Lau (Apr 29 2018 at 13:14)</a>:</h4>
<blockquote>
<p>what is the church encoding of false?</p>
</blockquote>
<p><code>X</code></p>

<a name="125854921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854921" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854921">Kevin Buzzard (Apr 29 2018 at 13:14)</a>:</h4>
<p>Does the church encoding of anything just have one type X?</p>

<a name="125854922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854922" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854922">Kenny Lau (Apr 29 2018 at 13:14)</a>:</h4>
<blockquote>
<p>Does the church encoding of anything just have one type X?</p>
</blockquote>
<p>didn't I just answer that question</p>

<a name="125854923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854923" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854923">Kevin Buzzard (Apr 29 2018 at 13:14)</a>:</h4>
<p>No</p>

<a name="125854924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854924" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854924">Kevin Buzzard (Apr 29 2018 at 13:14)</a>:</h4>
<p>you only answered it for bool and false</p>

<a name="125854930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854930" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854930">Kevin Buzzard (Apr 29 2018 at 13:15)</a>:</h4>
<p>and nat</p>

<a name="125854931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854931" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854931">Kenny Lau (Apr 29 2018 at 13:15)</a>:</h4>
<p>what do you mean by one type X?</p>

<a name="125854932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854932" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854932">Kevin Buzzard (Apr 29 2018 at 13:15)</a>:</h4>
<p>I mean that all your answers so far (for nat, bool and false) only had one letter in</p>

<a name="125854972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854972" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854972">Kenny Lau (Apr 29 2018 at 13:16)</a>:</h4>
<p>oh, I misunderstood "anything"</p>

<a name="125854973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125854973" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125854973">Kenny Lau (Apr 29 2018 at 13:16)</a>:</h4>
<p>english ~</p>

<a name="125855019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125855019" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125855019">Kevin Buzzard (Apr 29 2018 at 13:18)</a>:</h4>
<p>did you do ack yet?</p>

<a name="125855020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125855020" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125855020">Kenny Lau (Apr 29 2018 at 13:18)</a>:</h4>
<p>I've been searching church encoding online</p>

<a name="125855021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125855021" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125855021">Kevin Buzzard (Apr 29 2018 at 13:18)</a>:</h4>
<p>here's a much easier</p>

<a name="125855022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125855022" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125855022">Kevin Buzzard (Apr 29 2018 at 13:18)</a>:</h4>
<p>one</p>

<a name="125855023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125855023" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125855023">Kevin Buzzard (Apr 29 2018 at 13:18)</a>:</h4>
<p><code>pred</code></p>

<a name="125855028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125855028" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125855028">Kevin Buzzard (Apr 29 2018 at 13:19)</a>:</h4>
<p>The untyped lambda calculus is so last year</p>

<a name="125855030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125855030" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125855030">Kevin Buzzard (Apr 29 2018 at 13:19)</a>:</h4>
<p>I want to know how it works in Lean</p>

<a name="125855068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125855068" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125855068">Kevin Buzzard (Apr 29 2018 at 13:20)</a>:</h4>
<p>although these questions might not be good for this thread, because did you say that it was not true that nat was equiv to church nat?</p>

<a name="125855071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125855071" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125855071">Kevin Buzzard (Apr 29 2018 at 13:20)</a>:</h4>
<p>or not provable?</p>

<a name="125855072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125855072" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125855072">Kenny Lau (Apr 29 2018 at 13:20)</a>:</h4>
<p>if your functions are computable, then I believe they will represent some natural number</p>

<a name="125855075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125855075" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125855075">Kenny Lau (Apr 29 2018 at 13:20)</a>:</h4>
<p>but noncomputable functions are permitted in Lean, breaking the equivalence</p>

<a name="125855076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125855076" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125855076">Kenny Lau (Apr 29 2018 at 13:20)</a>:</h4>
<p>(but I can't give you any example :P)</p>

<a name="125855124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125855124" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125855124">Kevin Buzzard (Apr 29 2018 at 13:23)</a>:</h4>
<p>So one can write down a <code>noncomputable</code> church nat which is provably not in the image of <code>of_nat</code>?</p>

<a name="125855127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125855127" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125855127">Kenny Lau (Apr 29 2018 at 13:23)</a>:</h4>
<p>I don't know</p>

<a name="125855128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125855128" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125855128">Kenny Lau (Apr 29 2018 at 13:23)</a>:</h4>
<p>maybe you can write something like <code>if X == int then _ else _</code></p>

<a name="125855129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125855129" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125855129">Kevin Buzzard (Apr 29 2018 at 13:23)</a>:</h4>
<p>well maybe it won't come up in the mechanics exam</p>

<a name="125855130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125855130" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125855130">Kenny Lau (Apr 29 2018 at 13:23)</a>:</h4>
<p>...</p>

<a name="125855214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125855214" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125855214">Kenny Lau (Apr 29 2018 at 13:27)</a>:</h4>
<blockquote>
<p>what is the church encoding of list?</p>
</blockquote>
<p><code>list A = X -&gt; (A -&gt; X -&gt; X) -&gt; X</code> I guess. can't find anything online</p>

<a name="125855302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125855302" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125855302">Kenny Lau (Apr 29 2018 at 13:30)</a>:</h4>
<blockquote>
<p>what is the church encoding of int as defined in Lean?</p>
</blockquote>
<p><code>nat -&gt; nat -&gt; X</code>, I guess</p>

<a name="125855303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125855303" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125855303">Kevin Buzzard (Apr 29 2018 at 13:30)</a>:</h4>
<p>that doesn't look like something that Church would like</p>

<a name="125855304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125855304" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125855304">Kevin Buzzard (Apr 29 2018 at 13:30)</a>:</h4>
<p>it has something in which isn't X</p>

<a name="125855309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125855309" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125855309">Kevin Buzzard (Apr 29 2018 at 13:31)</a>:</h4>
<p>or -&gt; or ()</p>

<a name="125855311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125855311" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125855311">Kevin Buzzard (Apr 29 2018 at 13:31)</a>:</h4>
<p>Is it OK?</p>

<a name="125855313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125855313" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125855313">Kenny Lau (Apr 29 2018 at 13:31)</a>:</h4>
<p>but <code>list</code> isn't a type</p>

<a name="125855314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125855314" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125855314">Kenny Lau (Apr 29 2018 at 13:31)</a>:</h4>
<p><code>list</code> is a function from types to types</p>

<a name="125855315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125855315" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125855315">Kevin Buzzard (Apr 29 2018 at 13:31)</a>:</h4>
<p>I see</p>

<a name="125855317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125855317" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125855317">Kevin Buzzard (Apr 29 2018 at 13:31)</a>:</h4>
<p>I thought those were types too ;-)</p>

<a name="125855354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125855354" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125855354">Kevin Buzzard (Apr 29 2018 at 13:32)</a>:</h4>
<p><a href="https://github.com/kbuzzard/xena/blob/master/canonical_isomorphism/church_blog_questions.lean" target="_blank" title="https://github.com/kbuzzard/xena/blob/master/canonical_isomorphism/church_blog_questions.lean">https://github.com/kbuzzard/xena/blob/master/canonical_isomorphism/church_blog_questions.lean</a></p>

<a name="125855356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125855356" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125855356">Kenny Lau (Apr 29 2018 at 13:32)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="bp">#</span><span class="kn">check</span> <span class="n">list</span>
<span class="c1">--list : Type u_1 → Type u_1</span>
</pre></div>

<a name="125855358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125855358" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125855358">Kevin Buzzard (Apr 29 2018 at 13:32)</a>:</h4>
<p>I slightly updated the church numerals file</p>

<a name="125855359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125855359" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125855359">Kevin Buzzard (Apr 29 2018 at 13:32)</a>:</h4>
<p>I am a bit unclear about what is provable and what isn't.</p>

<a name="125855364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125855364" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125855364">Kevin Buzzard (Apr 29 2018 at 13:33)</a>:</h4>
<p>I also have a file with some solutions in</p>

<a name="125855370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125855370" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125855370">Kevin Buzzard (Apr 29 2018 at 13:33)</a>:</h4>
<p>and the only reason I did not push it</p>

<a name="125855372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125855372" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125855372">Kevin Buzzard (Apr 29 2018 at 13:33)</a>:</h4>
<p>is because the definition of <code>pow</code> on church nats is so beautiful that I wanted to let you find it if you hadn't seen it already</p>

<a name="125856002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125856002" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125856002">Kenny Lau (Apr 29 2018 at 13:58)</a>:</h4>
<p>interesting</p>

<a name="125856248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125856248" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125856248">Kevin Buzzard (Apr 29 2018 at 14:09)</a>:</h4>
<p>I am finally trying to write down a "canonical isomorphism" proof of the result I need to apply Chris' Lemma to the affine scheme boss</p>

<a name="125856249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125856249" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125856249">Kevin Buzzard (Apr 29 2018 at 14:09)</a>:</h4>
<p>Does this structure already have a name?</p>

<a name="125856250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125856250" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125856250">Kevin Buzzard (Apr 29 2018 at 14:09)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">is_unique_ring_hom</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">ring</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">[</span><span class="n">is_ring_hom</span> <span class="n">f</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">is_unique</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">[</span><span class="n">is_ring_hom</span> <span class="n">g</span><span class="o">],</span> <span class="n">g</span> <span class="bp">=</span> <span class="n">f</span><span class="o">)</span>
</pre></div>

<a name="125856294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125856294" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125856294">Kevin Buzzard (Apr 29 2018 at 14:10)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">class</span> <span class="n">is_ring_hom</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">ring</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">map_add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span><span class="o">},</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span>
<span class="o">(</span><span class="n">map_mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span><span class="o">},</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span>
<span class="o">(</span><span class="n">map_one</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span>
</pre></div>

<a name="125856305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125856305" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125856305">Kevin Buzzard (Apr 29 2018 at 14:11)</a>:</h4>
<p>(sorry, I was half rings and half commutative rings)</p>

<a name="125856306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125856306" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125856306">Kevin Buzzard (Apr 29 2018 at 14:11)</a>:</h4>
<p>(I am all rings now)</p>

<a name="125856635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125856635" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125856635">Kenny Lau (Apr 29 2018 at 14:24)</a>:</h4>
<p>I don't think it has a name</p>

<a name="125858145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125858145" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125858145">Kenny Lau (Apr 29 2018 at 15:26)</a>:</h4>
<p><a href="https://github.com/kckennylau/Lean/blob/master/church_blog_questions.lean" target="_blank" title="https://github.com/kckennylau/Lean/blob/master/church_blog_questions.lean">https://github.com/kckennylau/Lean/blob/master/church_blog_questions.lean</a></p>

<a name="125858173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125858173" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125858173">Kenny Lau (Apr 29 2018 at 15:26)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> I don't think Ack can be done</p>

<a name="125858640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125858640" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125858640">Kevin Buzzard (Apr 29 2018 at 15:44)</a>:</h4>
<p>What is your opinion of the other <code>sorry</code>s?</p>

<a name="125858642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125858642" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125858642">Kenny Lau (Apr 29 2018 at 15:44)</a>:</h4>
<p>can't be done</p>

<a name="125858654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125858654" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125858654">Kevin Buzzard (Apr 29 2018 at 15:45)</a>:</h4>
<p>Are there any for which you feel that you can convince me rigorously that they can't be done?</p>

<a name="125858655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125858655" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125858655">Kenny Lau (Apr 29 2018 at 15:45)</a>:</h4>
<p>the last one, I think</p>

<a name="125858697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125858697" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125858697">Kevin Buzzard (Apr 29 2018 at 15:46)</a>:</h4>
<p><code>theorem is_it_true (X : Type) (f : X → X) (x : X) : f x = x := sorry</code></p>

<a name="125858700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125858700" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125858700">Kevin Buzzard (Apr 29 2018 at 15:46)</a>:</h4>
<p>that theorem looks really appealing to me</p>

<a name="125858703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125858703" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125858703">Kenny Lau (Apr 29 2018 at 15:46)</a>:</h4>
<p>I think you want <code>f : \Pi X : Type, X \to X</code></p>

<a name="125859158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125859158" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125859158">Kevin Buzzard (Apr 29 2018 at 16:04)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="c1">-- bad church numeral</span>
<span class="n">local</span> <span class="n">attribute</span> <span class="o">[</span><span class="kn">instance</span><span class="o">]</span> <span class="n">classical</span><span class="bp">.</span><span class="n">prop_decidable</span>
<span class="n">noncomputable</span> <span class="kn">definition</span> <span class="n">satan</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="n">dite</span> <span class="o">(</span><span class="n">X</span> <span class="bp">=</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">H</span><span class="o">,</span><span class="k">begin</span> <span class="k">show</span> <span class="n">X</span><span class="o">,</span><span class="n">rw</span> <span class="n">H</span><span class="o">,</span><span class="n">rw</span> <span class="n">H</span> <span class="n">at</span> <span class="n">x</span><span class="o">,</span><span class="n">exact</span> <span class="n">x</span> <span class="kn">end</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="n">satan</span> <span class="o">:</span> <span class="n">chℕ</span><span class="o">)</span> <span class="c1">-- 1 everywhere apart from nat, where it&#39;s zero</span>

<span class="kn">theorem</span> <span class="n">satan_is_bad</span> <span class="o">:</span> <span class="n">of_nat</span> <span class="o">(</span><span class="n">to_nat</span> <span class="n">satan</span><span class="o">)</span> <span class="bp">=</span> <span class="n">satan</span> <span class="bp">→</span> <span class="n">false</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intro</span> <span class="n">H</span><span class="o">,</span>
<span class="k">have</span> <span class="n">H2</span> <span class="o">:</span> <span class="o">(</span><span class="n">of_nat</span> <span class="o">(</span><span class="n">to_nat</span> <span class="n">satan</span><span class="o">))</span> <span class="n">bool</span> <span class="n">bnot</span> <span class="n">tt</span> <span class="bp">=</span> <span class="n">satan</span> <span class="n">bool</span> <span class="n">bnot</span> <span class="n">tt</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">H</span><span class="o">,</span>
<span class="c1">-- now what?</span>
<span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>

<a name="125859159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125859159" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125859159">Kevin Buzzard (Apr 29 2018 at 16:04)</a>:</h4>
<p>Trying to write down a counterexample</p>

<a name="125859165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125859165" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125859165">Kenny Lau (Apr 29 2018 at 16:05)</a>:</h4>
<p>aha, I used <code>==</code> and I failed</p>

<a name="125859169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125859169" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125859169">Kenny Lau (Apr 29 2018 at 16:05)</a>:</h4>
<p>turns out you need <code>=</code> instead</p>

<a name="125859170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125859170" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125859170">Kevin Buzzard (Apr 29 2018 at 16:05)</a>:</h4>
<p>well, it typechecks</p>

<a name="125859171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125859171" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125859171">Kevin Buzzard (Apr 29 2018 at 16:05)</a>:</h4>
<p>but it's not over yet</p>

<a name="125859172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125859172" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125859172">Kevin Buzzard (Apr 29 2018 at 16:05)</a>:</h4>
<p>unless you see that it's over</p>

<a name="125859211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125859211" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125859211">Kenny Lau (Apr 29 2018 at 16:06)</a>:</h4>
<p>so what is your thought and why are you stuck?</p>

<a name="125860599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125860599" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125860599">Kevin Buzzard (Apr 29 2018 at 16:59)</a>:</h4>
<p>well presumably now I have to prove things like bool ne nat</p>

<a name="125860603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125860603" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125860603">Kenny Lau (Apr 29 2018 at 16:59)</a>:</h4>
<p>oh I thought you can just feed in <code>bool</code> to both sides</p>

<a name="125860604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125860604" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125860604">Kenny Lau (Apr 29 2018 at 16:59)</a>:</h4>
<p>and have one side give <code>ff</code> and the other side give <code>tt</code></p>

<a name="125860693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125860693" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125860693">Kevin Buzzard (Apr 29 2018 at 17:02)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">satan_is_bad</span> <span class="o">:</span> <span class="n">of_nat</span> <span class="o">(</span><span class="n">to_nat</span> <span class="n">satan</span><span class="o">)</span> <span class="bp">=</span> <span class="n">satan</span> <span class="bp">→</span> <span class="n">false</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intro</span> <span class="n">H</span><span class="o">,</span>
<span class="k">have</span> <span class="n">H2</span> <span class="o">:</span> <span class="o">(</span><span class="n">of_nat</span> <span class="o">(</span><span class="n">to_nat</span> <span class="n">satan</span><span class="o">))</span> <span class="n">bool</span> <span class="n">bnot</span> <span class="n">tt</span> <span class="bp">=</span> <span class="n">satan</span> <span class="n">bool</span> <span class="n">bnot</span> <span class="n">tt</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">H</span><span class="o">,</span>
<span class="n">unfold</span> <span class="n">to_nat</span> <span class="n">at</span> <span class="n">H2</span><span class="o">,</span>
<span class="n">unfold</span> <span class="n">satan</span> <span class="n">at</span> <span class="n">H2</span><span class="o">,</span>
<span class="n">simp</span> <span class="n">at</span> <span class="n">H2</span><span class="o">,</span>
<span class="n">change</span> <span class="n">tt</span> <span class="bp">=</span> <span class="bp">_</span> <span class="n">at</span> <span class="n">H2</span><span class="o">,</span>
<span class="c1">-- H2 : tt = dite (bool = ℕ) (λ (H : bool = ℕ), eq.mpr _ (eq.mp _ tt)) (λ (_x : ¬bool = ℕ), ff)</span>
<span class="c1">-- now what?</span>
<span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>

<a name="125860695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125860695" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125860695">Kevin Buzzard (Apr 29 2018 at 17:02)</a>:</h4>
<p>if only I had a good destructor for dite</p>

<a name="125860700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125860700" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125860700">Kenny Lau (Apr 29 2018 at 17:03)</a>:</h4>
<p>oh, you need to prove that <code>bool</code> and <code>nat</code> are not equal lol</p>

<a name="125860701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125860701" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125860701">Kevin Buzzard (Apr 29 2018 at 17:03)</a>:</h4>
<p>exactly</p>

<a name="125860741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125860741" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125860741">Kenny Lau (Apr 29 2018 at 17:04)</a>:</h4>
<p>cardinality <span class="emoji emoji-1f923" title="rolling on the floor laughing">:rolling_on_the_floor_laughing:</span></p>

<a name="125860751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125860751" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125860751">Kevin Buzzard (Apr 29 2018 at 17:05)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">satan_is_bad</span> <span class="o">:</span> <span class="n">of_nat</span> <span class="o">(</span><span class="n">to_nat</span> <span class="n">satan</span><span class="o">)</span> <span class="bp">=</span> <span class="n">satan</span> <span class="bp">→</span> <span class="n">false</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intro</span> <span class="n">H</span><span class="o">,</span>
<span class="k">have</span> <span class="n">H2</span> <span class="o">:</span> <span class="o">(</span><span class="n">of_nat</span> <span class="o">(</span><span class="n">to_nat</span> <span class="n">satan</span><span class="o">))</span> <span class="n">bool</span> <span class="n">bnot</span> <span class="n">tt</span> <span class="bp">=</span> <span class="n">satan</span> <span class="n">bool</span> <span class="n">bnot</span> <span class="n">tt</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">H</span><span class="o">,</span>
<span class="n">unfold</span> <span class="n">to_nat</span> <span class="n">at</span> <span class="n">H2</span><span class="o">,</span>
<span class="n">unfold</span> <span class="n">satan</span> <span class="n">at</span> <span class="n">H2</span><span class="o">,</span>
<span class="n">simp</span> <span class="n">at</span> <span class="n">H2</span><span class="o">,</span>
<span class="n">change</span> <span class="n">tt</span> <span class="bp">=</span> <span class="bp">_</span> <span class="n">at</span> <span class="n">H2</span><span class="o">,</span>
<span class="n">suffices</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">bool</span> <span class="bp">=</span> <span class="bp">ℕ</span><span class="o">),</span>
<span class="n">simp</span> <span class="o">[</span><span class="n">this</span><span class="o">]</span> <span class="n">at</span> <span class="n">H2</span><span class="o">,</span><span class="n">assumption</span><span class="o">,</span>
<span class="c1">-- ⊢ ¬bool = ℕ</span>
<span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>

<a name="125860752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125860752" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125860752">Kevin Buzzard (Apr 29 2018 at 17:05)</a>:</h4>
<p>Indeed it's the only problem left</p>

<a name="125860753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125860753" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125860753">Kenny Lau (Apr 29 2018 at 17:05)</a>:</h4>
<p>if they're equal then their cardinality is equal</p>

<a name="125860754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125860754" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125860754">Kenny Lau (Apr 29 2018 at 17:05)</a>:</h4>
<p>but bool is finite</p>

<a name="125860756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125860756" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125860756">Kevin Buzzard (Apr 29 2018 at 17:06)</a>:</h4>
<p>can you do it?</p>

<a name="125860795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125860795" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125860795">Kenny Lau (Apr 29 2018 at 17:06)</a>:</h4>
<p>heh...</p>

<a name="125860798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125860798" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125860798">Kevin Buzzard (Apr 29 2018 at 17:06)</a>:</h4>
<p><code>example : ¬bool = ℕ := sorry</code></p>

<a name="125860850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125860850" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125860850">Kenny Lau (Apr 29 2018 at 17:09)</a>:</h4>
<p>tactic mode slows things down</p>

<a name="125861579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125861579" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125861579">Reid Barton (Apr 29 2018 at 17:38)</a>:</h4>
<p>It would be a lot easier if you changed <code>bool</code> to <code>empty</code></p>

<a name="125861595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125861595" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125861595">Kenny Lau (Apr 29 2018 at 17:38)</a>:</h4>
<p>hmm</p>

<a name="125861598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125861598" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125861598">Kenny Lau (Apr 29 2018 at 17:38)</a>:</h4>
<p>maybe we should use <code>false</code> instead</p>

<a name="125862258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125862258" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125862258">Kevin Buzzard (Apr 29 2018 at 18:03)</a>:</h4>
<p>the proof crucially uses "this map X -&gt; X is not this other map"</p>

<a name="125862261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125862261" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125862261">Kevin Buzzard (Apr 29 2018 at 18:03)</a>:</h4>
<p>so I can't see how we can use empty or false :-/</p>

<a name="125862304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125862304" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125862304">Kevin Buzzard (Apr 29 2018 at 18:04)</a>:</h4>
<p>but we can use any type which is provably not \N and which provably has a map which is not the identity map</p>

<a name="125862356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125862356" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125862356">Reid Barton (Apr 29 2018 at 18:06)</a>:</h4>
<p>Oh I see, sorry</p>

<a name="125862365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125862365" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125862365">Kenny Lau (Apr 29 2018 at 18:07)</a>:</h4>
<p>I have never proved that two types are not the same</p>

<a name="125862409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125862409" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125862409">Kevin Buzzard (Apr 29 2018 at 18:08)</a>:</h4>
<p>I think there is some notion of finite and infinite, and it will be known that bool is finite and nat is infinite</p>

<a name="125862410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125862410" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125862410">Kevin Buzzard (Apr 29 2018 at 18:09)</a>:</h4>
<p>of course a = b implies a equiv b</p>

<a name="125862415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125862415" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125862415">Kevin Buzzard (Apr 29 2018 at 18:09)</a>:</h4>
<p>by rw</p>

<a name="125862416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125862416" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125862416">Kenny Lau (Apr 29 2018 at 18:09)</a>:</h4>
<blockquote>
<p>by rw</p>
</blockquote>
<p><strong>by <code>eq.rec_on</code></strong></p>

<a name="125862427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125862427" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125862427">Kevin Buzzard (Apr 29 2018 at 18:09)</a>:</h4>
<p>that's what I said</p>

<a name="125862429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125862429" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125862429">Kenny Lau (Apr 29 2018 at 18:09)</a>:</h4>
<p>:P</p>

<a name="125862430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125862430" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125862430">Kevin Buzzard (Apr 29 2018 at 18:09)</a>:</h4>
<p>:-)</p>

<a name="125862640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125862640" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125862640">Reid Barton (Apr 29 2018 at 18:16)</a>:</h4>
<p>As a further step, you could try adding the "free theorem" for the type <code>Π X : Type, (X → X) → X → X</code> as a field of your church numerals and then see if you can prove <code>of_nat (to_nat c) = c</code></p>

<a name="125863436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125863436" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125863436">Chris Hughes (Apr 29 2018 at 18:45)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">finite</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">bool</span> <span class="bp">≠</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span>
<span class="k">by</span> <span class="n">haveI</span> <span class="o">:</span> <span class="n">fintype</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="n">eq</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">h</span> <span class="o">(</span><span class="k">by</span> <span class="n">apply_instance</span><span class="o">)</span><span class="bp">;</span>
<span class="n">exact</span> <span class="n">set</span><span class="bp">.</span><span class="n">not_injective_nat_fintype</span> <span class="bp">@</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ_inj</span>
</pre></div>

<a name="125863443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125863443" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125863443">Kenny Lau (Apr 29 2018 at 18:45)</a>:</h4>
<p>lol</p>

<a name="125863503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125863503" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125863503">Chris Hughes (Apr 29 2018 at 18:47)</a>:</h4>
<p>Not very often you get to use <code>eq.rec_on</code> for something that's not a prop.</p>

<a name="125863505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125863505" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125863505">Kenny Lau (Apr 29 2018 at 18:47)</a>:</h4>
<p>it is a prop</p>

<a name="125863554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125863554" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125863554">Chris Hughes (Apr 29 2018 at 18:49)</a>:</h4>
<p><code>fintype</code> isn't</p>

<a name="125863556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125863556" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125863556">Kenny Lau (Apr 29 2018 at 18:49)</a>:</h4>
<p>oh, I misunderstood</p>

<a name="125863558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125863558" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125863558">Kenny Lau (Apr 29 2018 at 18:49)</a>:</h4>
<p>your proof makes me laugh for some reason</p>

<a name="125863615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125863615" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125863615">Kevin Buzzard (Apr 29 2018 at 18:50)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">satan_is_bad</span> <span class="o">:</span> <span class="n">of_nat</span> <span class="o">(</span><span class="n">to_nat</span> <span class="n">satan</span><span class="o">)</span> <span class="bp">=</span> <span class="n">satan</span> <span class="bp">→</span> <span class="n">false</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intro</span> <span class="n">H</span><span class="o">,</span>
<span class="k">have</span> <span class="n">H2</span> <span class="o">:</span> <span class="o">(</span><span class="n">of_nat</span> <span class="o">(</span><span class="n">to_nat</span> <span class="n">satan</span><span class="o">))</span> <span class="n">bool</span> <span class="n">bnot</span> <span class="n">tt</span> <span class="bp">=</span> <span class="n">satan</span> <span class="n">bool</span> <span class="n">bnot</span> <span class="n">tt</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">H</span><span class="o">,</span>
<span class="n">unfold</span> <span class="n">to_nat</span> <span class="n">at</span> <span class="n">H2</span><span class="o">,</span>
<span class="n">unfold</span> <span class="n">satan</span> <span class="n">at</span> <span class="n">H2</span><span class="o">,</span>
<span class="n">simp</span> <span class="n">at</span> <span class="n">H2</span><span class="o">,</span>
<span class="n">change</span> <span class="n">tt</span> <span class="bp">=</span> <span class="bp">_</span> <span class="n">at</span> <span class="n">H2</span><span class="o">,</span>
<span class="n">suffices</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">bool</span> <span class="bp">=</span> <span class="bp">ℕ</span><span class="o">),</span>
<span class="n">simp</span> <span class="o">[</span><span class="n">this</span><span class="o">]</span> <span class="n">at</span> <span class="n">H2</span><span class="o">,</span><span class="n">assumption</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">bool_not_nat</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>

<a name="125863618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125863618" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125863618">Kevin Buzzard (Apr 29 2018 at 18:50)</a>:</h4>
<p>so it really is not provable</p>

<a name="125863622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125863622" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125863622">Kenny Lau (Apr 29 2018 at 18:50)</a>:</h4>
<p>nice!</p>

<a name="125863668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125863668" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125863668">Chris Hughes (Apr 29 2018 at 18:52)</a>:</h4>
<p>What's satan?</p>

<a name="125863675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125863675" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125863675">Kenny Lau (Apr 29 2018 at 18:53)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">noncomputable</span> <span class="kn">definition</span> <span class="n">satan</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="n">dite</span> <span class="o">(</span><span class="n">X</span> <span class="bp">=</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">H</span><span class="o">,</span><span class="k">begin</span> <span class="k">show</span> <span class="n">X</span><span class="o">,</span><span class="n">rw</span> <span class="n">H</span><span class="o">,</span><span class="n">rw</span> <span class="n">H</span> <span class="n">at</span> <span class="n">x</span><span class="o">,</span><span class="n">exact</span> <span class="n">x</span> <span class="kn">end</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span>
</pre></div>

<a name="125863766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125863766" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125863766">Chris Hughes (Apr 29 2018 at 18:56)</a>:</h4>
<p>What's <code>of_nat</code>?</p>

<a name="125863768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125863768" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125863768">Kenny Lau (Apr 29 2018 at 18:56)</a>:</h4>
<p><a href="https://github.com/kbuzzard/xena/blob/master/canonical_isomorphism/church_blog_questions.lean" target="_blank" title="https://github.com/kbuzzard/xena/blob/master/canonical_isomorphism/church_blog_questions.lean">https://github.com/kbuzzard/xena/blob/master/canonical_isomorphism/church_blog_questions.lean</a></p>

<a name="125863920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125863920" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125863920">Chris Hughes (Apr 29 2018 at 19:02)</a>:</h4>
<p>What's the purpose of church nats?</p>

<a name="125863925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125863925" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125863925">Kenny Lau (Apr 29 2018 at 19:03)</a>:</h4>
<p>to defeat satan</p>

<a name="125863926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125863926" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125863926">Kenny Lau (Apr 29 2018 at 19:03)</a>:</h4>
<p>well church numerals is an essential part of lambda calculus</p>

<a name="125864023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125864023" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125864023">Chris Hughes (Apr 29 2018 at 19:07)</a>:</h4>
<p>Am i doing something wrong</p>
<div class="codehilite"><pre><span></span><span class="c1">--KB can&#39;t do this one. Is it unprovable? If so, move definition of to_nat much further down.</span>
<span class="kn">example</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">chℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">to_nat</span> <span class="o">(</span><span class="n">succ</span> <span class="n">m</span><span class="o">)</span> <span class="bp">=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="o">(</span><span class="n">to_nat</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>

<a name="125864024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125864024" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125864024">Kenny Lau (Apr 29 2018 at 19:07)</a>:</h4>
<p>I also used <code>rfl</code> lol</p>

<a name="125864232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125864232" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125864232">Chris Hughes (Apr 29 2018 at 19:15)</a>:</h4>
<p>Is this cheating?</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">add</span> <span class="o">:</span> <span class="n">chℕ</span> <span class="bp">→</span> <span class="n">chℕ</span> <span class="bp">→</span> <span class="n">chℕ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">of_nat</span> <span class="o">(</span><span class="n">to_nat</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">to_nat</span> <span class="n">b</span><span class="o">)</span>
</pre></div>

<a name="125864240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125864240" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125864240">Kenny Lau (Apr 29 2018 at 19:15)</a>:</h4>
<p>yes it is</p>

<a name="125864756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125864756" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125864756">Chris Hughes (Apr 29 2018 at 19:36)</a>:</h4>
<p>Stuck on add_succ</p>

<a name="125864757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125864757" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125864757">Kenny Lau (Apr 29 2018 at 19:36)</a>:</h4>
<p>you can do it</p>

<a name="125864775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125864775" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125864775">Chris Hughes (Apr 29 2018 at 19:37)</a>:</h4>
<p>Is it even true? There are loads of chnats that aren't constructed from naturals.</p>

<a name="125864776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125864776" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125864776">Kenny Lau (Apr 29 2018 at 19:37)</a>:</h4>
<p>it is true</p>

<a name="125864913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125864913" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125864913">Chris Hughes (Apr 29 2018 at 19:43)</a>:</h4>
<p>Are you sure <code>add_succ</code> is true? <code>succ_add</code> certainly is. I think it's the wrong approach to try to prove that.</p>

<a name="125864952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125864952" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125864952">Kenny Lau (Apr 29 2018 at 19:44)</a>:</h4>
<p>depends on your definition of add</p>

<a name="125865010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125865010" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125865010">Chris Hughes (Apr 29 2018 at 19:47)</a>:</h4>
<p><code> λ a b X f, (a X f) ∘ (b X f)</code></p>

<a name="125865013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125865013" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125865013">Kenny Lau (Apr 29 2018 at 19:47)</a>:</h4>
<p>then destruct <code>a</code></p>

<a name="125865054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125865054" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125865054">Chris Hughes (Apr 29 2018 at 19:48)</a>:</h4>
<p>I proved of_nat_add without it, so I'm okay.</p>

<a name="125865060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125865060" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125865060">Chris Hughes (Apr 29 2018 at 19:49)</a>:</h4>
<p>I ended up with this</p>
<div class="codehilite"><pre><span></span>m n : chℕ,
X : Type,
f : X → X,
x : X
⊢ m X f (f (n X f x)) = f (m X f (n X f x))
</pre></div>

<a name="125865063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125865063" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125865063">Kenny Lau (Apr 29 2018 at 19:49)</a>:</h4>
<p>what is the theorem?</p>

<a name="125865243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125865243" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125865243">Chris Hughes (Apr 29 2018 at 19:56)</a>:</h4>
<p>m + succ n = succ (m + n)</p>

<a name="125865246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125865246" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125865246">Kenny Lau (Apr 29 2018 at 19:56)</a>:</h4>
<p>oh...</p>

<a name="125865249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125865249" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125865249">Kenny Lau (Apr 29 2018 at 19:57)</a>:</h4>
<p>sorry</p>

<a name="125865253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125865253" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125865253">Kenny Lau (Apr 29 2018 at 19:57)</a>:</h4>
<p>I thought it was one of the questions from the file and then I reflexively answered that it's true</p>

<a name="125865379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125865379" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125865379">Kevin Buzzard (Apr 29 2018 at 20:01)</a>:</h4>
<p>Apparently defining pred is interesting</p>

<a name="125865486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125865486" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125865486">Chris Hughes (Apr 29 2018 at 20:04)</a>:</h4>
<p>pretty sure <code>add_comm</code> isn't true. all you need is two functions whose composition doesn't commute surely?</p>

<a name="125865785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125865785" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125865785">Chris Hughes (Apr 29 2018 at 20:16)</a>:</h4>
<p>Just disproved <code>add_comm</code></p>

<a name="125865788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125865788" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125865788">Kenny Lau (Apr 29 2018 at 20:17)</a>:</h4>
<p>nice!</p>

<a name="125865903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125865903" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125865903">Kevin Buzzard (Apr 29 2018 at 20:20)</a>:</h4>
<p>the problem is that a church numeral has to be defined on every type</p>

<a name="125865910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125865910" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125865910">Kevin Buzzard (Apr 29 2018 at 20:21)</a>:</h4>
<p>If you were to specialise to one specific type X then they won't commute</p>

<a name="125865915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125865915" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125865915">Kenny Lau (Apr 29 2018 at 20:21)</a>:</h4>
<p>the problem is that noncomputable functions exist</p>

<a name="125865916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125865916" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125865916">Kevin Buzzard (Apr 29 2018 at 20:21)</a>:</h4>
<p>right</p>

<a name="125865922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125865922" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125865922">Kenny Lau (Apr 29 2018 at 20:21)</a>:</h4>
<p>now I haven't even started dinner and you have already finished it</p>

<a name="125865924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125865924" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125865924">Kevin Buzzard (Apr 29 2018 at 20:21)</a>:</h4>
<p>also right</p>

<a name="125865927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125865927" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125865927">Kevin Buzzard (Apr 29 2018 at 20:21)</a>:</h4>
<p>but I have a lot of tidying up to do</p>

<a name="125865967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125865967" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125865967">Kenny Lau (Apr 29 2018 at 20:22)</a>:</h4>
<p>heh</p>

<a name="125866020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125866020" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125866020">Chris Hughes (Apr 29 2018 at 20:24)</a>:</h4>
<blockquote>
<p>the problem is that a church numeral has to be defined on every type<br>
If you were to specialise to one specific type X then they won't commute</p>
</blockquote>
<p>What do you mean?</p>

<a name="125866185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125866185" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125866185">Chris Hughes (Apr 29 2018 at 20:31)</a>:</h4>
<p>I fixed has_pow <code>instance : has_pow chℕ chℕ := ⟨pow⟩</code></p>

<a name="125866347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125866347" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125866347">Kevin Buzzard (Apr 29 2018 at 20:36)</a>:</h4>
<p>I mean that you can't say "I can think of a type X and two functions f and g which don't commute, so done", because a church numeral is defined on all types</p>

<a name="125866350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125866350" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125866350">Kevin Buzzard (Apr 29 2018 at 20:36)</a>:</h4>
<p>But of course if you do the trick I did then this gets round it, at a cost of making the function noncomputable</p>

<a name="125866405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125866405" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125866405">Chris Hughes (Apr 29 2018 at 20:38)</a>:</h4>
<p>You can.</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">not_add_comm</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">chℕ</span><span class="o">,</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">≠</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">X</span> <span class="n">f</span> <span class="n">x</span><span class="o">,</span> <span class="n">dite</span> <span class="o">(</span><span class="bp">ℕ</span> <span class="bp">=</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">eq</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">h</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="o">(</span><span class="n">eq</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">h</span><span class="bp">.</span><span class="n">symm</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)))</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">x</span><span class="o">),</span>
<span class="bp">λ</span> <span class="n">X</span> <span class="n">f</span> <span class="n">x</span><span class="o">,</span> <span class="n">dite</span> <span class="o">(</span><span class="bp">ℕ</span> <span class="bp">=</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">eq</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">h</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="o">(</span><span class="n">eq</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">h</span><span class="bp">.</span><span class="n">symm</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)))</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">x</span><span class="o">),</span>
<span class="bp">λ</span> <span class="n">h</span><span class="o">,</span>
<span class="k">begin</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="n">congr_fun</span> <span class="n">h</span> <span class="bp">ℕ</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="n">congr_fun</span> <span class="n">this</span> <span class="n">id</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="n">congr_fun</span> <span class="n">this</span> <span class="mi">0</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">has_add</span><span class="bp">.</span><span class="n">add</span><span class="o">,</span> <span class="n">add</span><span class="o">]</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">absurd</span> <span class="n">this</span> <span class="n">dec_trivial</span><span class="o">,</span>
<span class="kn">end</span><span class="bp">⟩</span>
</pre></div>


<p>Are you saying that the definition is not correct?</p>

<a name="125866797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125866797" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125866797">Chris Hughes (Apr 29 2018 at 20:52)</a>:</h4>
<p>Or maybe my definition of add is incorrect.</p>

<a name="125867627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125867627" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125867627">Chris Hughes (Apr 29 2018 at 21:27)</a>:</h4>
<p>I disproved <code>free_chnat</code> as well</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">free_chnat</span> <span class="o">:</span> <span class="bp">¬∀</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">),</span> <span class="bp">∀</span> <span class="n">f</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">B</span><span class="o">,</span>
<span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">chℕ</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">,</span> <span class="n">r</span> <span class="o">(</span><span class="n">A</span> <span class="bp">→</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">g</span><span class="o">,</span> <span class="n">f</span><span class="o">)</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">r</span> <span class="o">(</span><span class="n">A</span> <span class="bp">→</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">g</span><span class="o">,</span> <span class="n">g</span><span class="o">)</span> <span class="n">f</span> <span class="n">a</span>
 <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="k">begin</span>
 <span class="k">let</span> <span class="n">r</span> <span class="o">:</span> <span class="n">chℕ</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">X</span> <span class="n">f</span> <span class="n">x</span><span class="o">,</span> <span class="n">dite</span> <span class="o">((</span><span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">eq</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">h</span>
    <span class="o">(</span><span class="k">let</span> <span class="n">f</span> <span class="o">:</span> <span class="o">(</span><span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">eq</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">h</span><span class="bp">.</span><span class="n">symm</span> <span class="n">f</span> <span class="k">in</span>
    <span class="n">ite</span> <span class="o">(</span><span class="n">f</span> <span class="bp">=</span> <span class="n">id</span><span class="o">)</span> <span class="n">id</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ</span><span class="o">))</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">x</span><span class="o">)),</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="o">(</span><span class="n">h</span> <span class="bp">ℕ</span> <span class="bp">ℕ</span> <span class="n">id</span> <span class="n">r</span> <span class="mi">8</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">h₁</span> <span class="o">:</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">id</span><span class="o">)</span> <span class="bp">≠</span> <span class="n">id</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">absurd</span> <span class="o">(</span><span class="n">congr_fun</span> <span class="o">(</span><span class="n">congr_fun</span> <span class="n">h</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ</span><span class="o">)</span> <span class="mi">0</span><span class="o">)</span> <span class="n">dec_trivial</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h₂</span> <span class="o">:</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">g</span><span class="o">)</span> <span class="bp">=</span> <span class="n">id</span> <span class="o">:=</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">r</span><span class="o">,</span> <span class="n">id</span><span class="o">,</span> <span class="n">h₁</span><span class="o">,</span> <span class="n">h₂</span><span class="o">]</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">absurd</span> <span class="n">this</span> <span class="n">dec_trivial</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>

<a name="125867731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125867731" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125867731">Kevin Buzzard (Apr 29 2018 at 21:30)</a>:</h4>
<p>yes, those free theorems aren't very good are they</p>

<a name="125867733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125867733" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125867733">Kevin Buzzard (Apr 29 2018 at 21:30)</a>:</h4>
<p>I would ask for my money back</p>

<a name="125867740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125867740" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125867740">Kevin Buzzard (Apr 29 2018 at 21:31)</a>:</h4>
<p>The free theorem for <code>Pi X, X</code> is: for all X, for all f : X -&gt; X, for all x : X, f x = x :-)</p>

<a name="125867742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125867742" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125867742">Chris Hughes (Apr 29 2018 at 21:31)</a>:</h4>
<p>Is it because we're defining church numerals as something bigger than those that can be constructed from nats?</p>

<a name="125867746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125867746" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125867746">Kevin Buzzard (Apr 29 2018 at 21:31)</a>:</h4>
<p>I think constructively it's very difficult to tell the difference between church numerals and numerals</p>

<a name="125867785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125867785" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125867785">Kevin Buzzard (Apr 29 2018 at 21:32)</a>:</h4>
<p>you have to use this dite trick and make it noncomputable</p>

<a name="125867790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125867790" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125867790">Chris Hughes (Apr 29 2018 at 21:32)</a>:</h4>
<p>Probably. But that doesn't make the lemmas true. It just makes them undisprovable</p>

<a name="125867798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125867798" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125867798">Kevin Buzzard (Apr 29 2018 at 21:33)</a>:</h4>
<p>I think that in some other logics they might be provable</p>

<a name="125867799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125867799" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125867799">Kevin Buzzard (Apr 29 2018 at 21:33)</a>:</h4>
<p>I am certainly not an expert in these variants of the lambda calculus</p>

<a name="125867837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125867837" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125867837">Kevin Buzzard (Apr 29 2018 at 21:34)</a>:</h4>
<p>Chris I have been failing to apply your lemma :-)</p>

<a name="125867845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125867845" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125867845">Chris Hughes (Apr 29 2018 at 21:34)</a>:</h4>
<p>The 00EJ?</p>

<a name="125867846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125867846" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125867846">Kevin Buzzard (Apr 29 2018 at 21:34)</a>:</h4>
<p>yes</p>

<a name="125867849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125867849" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125867849">Chris Hughes (Apr 29 2018 at 21:34)</a>:</h4>
<p>Because of the isomorphism problem?</p>

<a name="125867856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125867856" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125867856">Kevin Buzzard (Apr 29 2018 at 21:35)</a>:</h4>
<p>I have some situation with a bunch of types each of which are canonically isomorphic to your types that you proved something about</p>

<a name="125867858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125867858" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125867858">Kevin Buzzard (Apr 29 2018 at 21:35)</a>:</h4>
<p>but I have got distracted</p>

<a name="125867867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125867867" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125867867">Kevin Buzzard (Apr 29 2018 at 21:35)</a>:</h4>
<p>and am trying to write quite a high-level proof which mirrors how I actually think about the question</p>

<a name="125867920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125867920" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125867920">Chris Hughes (Apr 29 2018 at 21:37)</a>:</h4>
<p>Did the tactics session get anywhere?</p>

<a name="125867966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125867966" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125867966">Kevin Buzzard (Apr 29 2018 at 21:38)</a>:</h4>
<p>There was a preliminary idea about how to model the notion of being canonically isomorphic</p>

<a name="125867967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125867967" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125867967">Chris Hughes (Apr 29 2018 at 21:38)</a>:</h4>
<p>To make tactics that prove it's a ring?</p>

<a name="125867968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125867968" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125867968">Kevin Buzzard (Apr 29 2018 at 21:38)</a>:</h4>
<p>but then we realised that it wasn't strong enough</p>

<a name="125867980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125867980" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125867980">Kevin Buzzard (Apr 29 2018 at 21:38)</a>:</h4>
<p>and I am now trying to write down some abstract ideas at a high level to see if I can make any sense out of them</p>

<a name="125867989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125867989" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125867989">Kevin Buzzard (Apr 29 2018 at 21:39)</a>:</h4>
<p>It seems to me that when a mathematician says that two things are canonically isomorphic they are making a promise</p>

<a name="125867990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125867990" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125867990">Chris Hughes (Apr 29 2018 at 21:39)</a>:</h4>
<p>I don't understand how it could have been someone's PhD project to prove a result still held for an isomorphic thing</p>

<a name="125867993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125867993" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125867993">Kevin Buzzard (Apr 29 2018 at 21:40)</a>:</h4>
<p>the project did something else</p>

<a name="125868035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868035" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868035">Kevin Buzzard (Apr 29 2018 at 21:40)</a>:</h4>
<p>but this came out in the wash</p>

<a name="125868040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868040" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868040">Kevin Buzzard (Apr 29 2018 at 21:40)</a>:</h4>
<p>But the problem was hard</p>

<a name="125868041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868041" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868041">Chris Hughes (Apr 29 2018 at 21:40)</a>:</h4>
<p>I see.</p>

<a name="125868042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868042" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868042">Kevin Buzzard (Apr 29 2018 at 21:40)</a>:</h4>
<p>Here was the problem.</p>

<a name="125868045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868045" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868045">Kevin Buzzard (Apr 29 2018 at 21:40)</a>:</h4>
<p>We have two finite-dimensional vector spaces V and W</p>

<a name="125868048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868048" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868048">Kevin Buzzard (Apr 29 2018 at 21:40)</a>:</h4>
<p>and we have two linear maps T : V -&gt; V and T' : W -&gt; W</p>

<a name="125868053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868053" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868053">Kevin Buzzard (Apr 29 2018 at 21:40)</a>:</h4>
<p>and T and T' are both defined "by using the same sort of ideas"</p>

<a name="125868059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868059" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868059">Kevin Buzzard (Apr 29 2018 at 21:41)</a>:</h4>
<p>but on two different spaces</p>

<a name="125868069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868069" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868069">Kevin Buzzard (Apr 29 2018 at 21:41)</a>:</h4>
<p>and then there's a theorem that there's a "canonical isomorphism" phi from V to W</p>

<a name="125868070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868070" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868070">Kevin Buzzard (Apr 29 2018 at 21:41)</a>:</h4>
<p>which means "an isomorphism which somehow dropped out really nicely"</p>

<a name="125868112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868112" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868112">Kevin Buzzard (Apr 29 2018 at 21:42)</a>:</h4>
<p>and what Dick Gross used without proof was that phi (T v) = T' (phi v)</p>

<a name="125868117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868117" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868117">Kevin Buzzard (Apr 29 2018 at 21:42)</a>:</h4>
<p>for all v</p>

<a name="125868120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868120" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868120">Kevin Buzzard (Apr 29 2018 at 21:42)</a>:</h4>
<p>and his proof was not a formal one</p>

<a name="125868122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868122" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868122">Kevin Buzzard (Apr 29 2018 at 21:42)</a>:</h4>
<p>his proof was "this must be true because that's surely how it works"</p>

<a name="125868124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868124" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868124">Kevin Buzzard (Apr 29 2018 at 21:42)</a>:</h4>
<p>"because everything is canonical"</p>

<a name="125868133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868133" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868133">Kevin Buzzard (Apr 29 2018 at 21:43)</a>:</h4>
<p>V and W were two different cohomology theories attached to the same space</p>

<a name="125868143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868143" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868143">Kevin Buzzard (Apr 29 2018 at 21:44)</a>:</h4>
<p>and T and T' were defined using some other spaces (the same other spaces for T and T')</p>

<a name="125868187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868187" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868187">Kevin Buzzard (Apr 29 2018 at 21:44)</a>:</h4>
<p>e.g. maps between spaces often induce maps between cohomology theories</p>

<a name="125868188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868188" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868188">Kevin Buzzard (Apr 29 2018 at 21:44)</a>:</h4>
<p>but it was just a case of making sure that all the diagrams commuted</p>

<a name="125868195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868195" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868195">Kevin Buzzard (Apr 29 2018 at 21:45)</a>:</h4>
<p>and some of the definition were done using very abstract algebra and the diagrams were difficult to chase</p>

<a name="125868198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868198" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868198">Simon Hudon (Apr 29 2018 at 21:45)</a>:</h4>
<p>Short digression:</p>
<p>I'm working on deriving <code>transportable</code>. Do you guys have a preference between making such instances lemmas (i.e. you can't unfold them) or definitions?</p>

<a name="125868201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868201" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868201">Kevin Buzzard (Apr 29 2018 at 21:45)</a>:</h4>
<p>that's an interesting question Simon</p>

<a name="125868243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868243" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868243">Kevin Buzzard (Apr 29 2018 at 21:46)</a>:</h4>
<p>transportable is what we can transfer equiv over, right?</p>

<a name="125868246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868246" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868246">Simon Hudon (Apr 29 2018 at 21:46)</a>:</h4>
<p>Exactly</p>

<a name="125868250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868250" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868250">Simon Hudon (Apr 29 2018 at 21:46)</a>:</h4>
<p>Here's the class:</p>
<div class="codehilite"><pre><span></span>class transportable (f : Type u → Type v) :=
(on_equiv : Π {α β : Type u} (e : equiv α β), equiv (f α) (f β))
(on_refl  : Π (α : Type u), on_equiv (equiv.refl α) = equiv.refl (f α))
(on_trans : Π {α β γ : Type u} (d : equiv α β) (e : equiv β γ), on_equiv (equiv.trans d e) = equiv.trans (on_equiv d) (on_equiv e))
</pre></div>

<a name="125868260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868260" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868260">Kevin Buzzard (Apr 29 2018 at 21:47)</a>:</h4>
<p>I guess if I had a group on X and an equiv from X to Y I'd definitely like to be able to get at the induced group on Y</p>

<a name="125868302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868302" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868302">Simon Hudon (Apr 29 2018 at 21:48)</a>:</h4>
<p>Ah very good. Right now, the instances I'm generating are kind of messy. I'll try to structure them so that you can look into them then</p>

<a name="125868306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868306" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868306">Kevin Buzzard (Apr 29 2018 at 21:48)</a>:</h4>
<p>but that might be a different question</p>

<a name="125868317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868317" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868317">Kevin Buzzard (Apr 29 2018 at 21:49)</a>:</h4>
<p>I am not sure I can give a definitive answer to your question</p>

<a name="125868319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868319" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868319">Simon Hudon (Apr 29 2018 at 21:49)</a>:</h4>
<p>If I don't structure them but I make them definitions, you still benefit from defeq</p>

<a name="125868375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868375" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868375">Kevin Buzzard (Apr 29 2018 at 21:50)</a>:</h4>
<p>My impression was that for theoretical reasons some people wanted things more general than maps between types to be transportable</p>

<a name="125868378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868378" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868378">Simon Hudon (Apr 29 2018 at 21:50)</a>:</h4>
<p>You mean like groups, rings, etc?</p>

<a name="125868427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868427" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868427">Kevin Buzzard (Apr 29 2018 at 21:52)</a>:</h4>
<p>I think the issue raised was that if X and Y were equiv and then X got a group structure, then Y would get a group structure, but if then X got a ring structure on top of that, which induced the group structure, then one would want to push over both the ring structure on Y and the proof that the ring structure on Y reduced to the group structure</p>

<a name="125868428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868428" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868428">Kevin Buzzard (Apr 29 2018 at 21:52)</a>:</h4>
<p>But I am not too worried about this at the minute. We might just want to try a prototype at the minute</p>

<a name="125868429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868429" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868429">Kevin Buzzard (Apr 29 2018 at 21:52)</a>:</h4>
<p>to see if we can get anything working</p>

<a name="125868438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868438" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868438">Kevin Buzzard (Apr 29 2018 at 21:53)</a>:</h4>
<p>I have thought about this a certain amount today. If X and Y have extra structure, e.g. if they're both rings, then there is ring_equiv, which equiv + assumption that the maps are ring isomorphisms</p>

<a name="125868440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868440" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868440">Simon Hudon (Apr 29 2018 at 21:53)</a>:</h4>
<p>Cool. I'm going to push it on a repo on Github before making a PR for mathlib. This way you can play with it and tell me what you need</p>

<a name="125868481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868481" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868481">Kevin Buzzard (Apr 29 2018 at 21:54)</a>:</h4>
<p>And if two things are ring-equiv then you can get some more theorems</p>

<a name="125868482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868482" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868482">Kevin Buzzard (Apr 29 2018 at 21:54)</a>:</h4>
<p>e.g. if something is a module for one ring then it becomes a module for the other ring</p>

<a name="125868485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868485" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868485">Kevin Buzzard (Apr 29 2018 at 21:54)</a>:</h4>
<p>That would not be true if the rings were just equiv</p>

<a name="125868492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868492" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868492">Simon Hudon (Apr 29 2018 at 21:55)</a>:</h4>
<p>That's going to be interesting. I'll have to think on how to do that</p>

<a name="125868493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868493" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868493">Kevin Buzzard (Apr 29 2018 at 21:55)</a>:</h4>
<p>So some wise people made some comments about this earlier</p>

<a name="125868496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868496" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868496">Simon Hudon (Apr 29 2018 at 21:55)</a>:</h4>
<blockquote>
<p>That would not be true if the rings were just equiv</p>
</blockquote>
<p>Does that mean ring-equiv also asserts that the ring operations respect the underlying isomorphism?</p>

<a name="125868536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868536" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868536">Kevin Buzzard (Apr 29 2018 at 21:56)</a>:</h4>
<p>right</p>

<a name="125868539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868539" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868539">Kevin Buzzard (Apr 29 2018 at 21:56)</a>:</h4>
<p>If X is a ring</p>

<a name="125868540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868540" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868540">Kevin Buzzard (Apr 29 2018 at 21:56)</a>:</h4>
<p>then this means in practice that you have add and mul and neg and one and zero</p>

<a name="125868541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868541" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868541">Kevin Buzzard (Apr 29 2018 at 21:56)</a>:</h4>
<p>and all of those transfer</p>

<a name="125868542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868542" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868542">Kevin Buzzard (Apr 29 2018 at 21:56)</a>:</h4>
<p>so if you have an equiv X = Y</p>

<a name="125868543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868543" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868543">Simon Hudon (Apr 29 2018 at 21:56)</a>:</h4>
<p>Right and you need access to their definitions</p>

<a name="125868549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868549" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868549">Kevin Buzzard (Apr 29 2018 at 21:57)</a>:</h4>
<p>then you can transfer them all over from X to Y</p>

<a name="125868552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868552" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868552">Kevin Buzzard (Apr 29 2018 at 21:57)</a>:</h4>
<p>On the other hand if X and Y are already rings</p>

<a name="125868553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868553" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868553">Kevin Buzzard (Apr 29 2018 at 21:57)</a>:</h4>
<p>and you decide that there's a canonical isomorphism between them</p>

<a name="125868555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868555" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868555">Kevin Buzzard (Apr 29 2018 at 21:57)</a>:</h4>
<p>then you're going to have to prove that the add mul neg etc all transfer over from one to the other</p>

<a name="125868556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868556" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868556">Kevin Buzzard (Apr 29 2018 at 21:57)</a>:</h4>
<p>and once you've done that, you have a better class of equiv which is specifically for rings</p>

<a name="125868596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868596" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868596">Kevin Buzzard (Apr 29 2018 at 21:58)</a>:</h4>
<p>and you can prove more theorems with it</p>

<a name="125868604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868604" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868604">Kevin Buzzard (Apr 29 2018 at 21:58)</a>:</h4>
<p>each of which is trivial to a mathematician</p>

<a name="125868610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868610" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868610">Kevin Buzzard (Apr 29 2018 at 21:59)</a>:</h4>
<p>such as "oh look, M is a free R-module and R is isomorphic to S so M is now a free S-module"</p>

<a name="125868661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868661" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868661">Kevin Buzzard (Apr 29 2018 at 22:00)</a>:</h4>
<p>or "M is a Noetherian Cohen-Macauley R-module which is R-generated by these three elements and R is isomorphic to S so now M is a Noetherian Cohen-Macauley S-module which is S-generated by these three elements"</p>

<a name="125868662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868662" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868662">Kevin Buzzard (Apr 29 2018 at 22:00)</a>:</h4>
<p>and the definition of Cohen-Macauley is pretty complicated</p>

<a name="125868663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868663" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868663">Kevin Buzzard (Apr 29 2018 at 22:00)</a>:</h4>
<p>but it complies with the unwritten promise</p>

<a name="125868667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868667" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868667">Kevin Buzzard (Apr 29 2018 at 22:01)</a>:</h4>
<p>which is that it only depends on the underlying ring up to ring-isomorphism</p>

<a name="125868678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868678" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868678">Kevin Buzzard (Apr 29 2018 at 22:01)</a>:</h4>
<p>It seems to me that mathematicians have got a really good intuitive feeling for these promises</p>

<a name="125868728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868728" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868728">Simon Hudon (Apr 29 2018 at 22:03)</a>:</h4>
<p>Nice</p>

<a name="125868774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868774" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868774">Simon Hudon (Apr 29 2018 at 22:05)</a>:</h4>
<p>Given a structure like group or ring, if you derive <code>transportable</code> it gives automatically the isomorphism between the properties of the structures whenever you have an isomorphism between two types</p>

<a name="125868815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125868815" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125868815">Simon Hudon (Apr 29 2018 at 22:06)</a>:</h4>
<p>I'm getting close to a complete derivation and it works with group so far. It will be fun to see you try it with other structures</p>

<a name="125874746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125874746" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125874746">Mario Carneiro (Apr 30 2018 at 02:00)</a>:</h4>
<blockquote>
<p>The free theorem for <code>Pi X, X</code> is: for all X, for all f : X -&gt; X, for all x : X, f x = x :-)</p>
</blockquote>
<p>That's not correct. You need to quantify over polymorphic functions: for all f : (\forall X, X -&gt; X), for all X, for all x : X, f X x = x</p>

<a name="125874930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125874930" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125874930">Mario Carneiro (Apr 30 2018 at 02:08)</a>:</h4>
<p>As Kenny and others have noted, the definition of chN is not correct in dependent type theories like lean because there are additional polymorphic functions that are not parametric. However, you can repair the church nat construction by taking a subtype to enforce that the polymorphic functions are functorial. For example, church unit is:</p>
<div class="codehilite"><pre><span></span>def ch_unit := { f : ∀ X : Type, X → X // ∀ (X Y) (g : X → Y) x, f Y (g x) = g (f X x) }
</pre></div>


<p>Can you see the correct condition for church nat?</p>

<a name="125874995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125874995" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125874995">Mario Carneiro (Apr 30 2018 at 02:11)</a>:</h4>
<p>By the way, to generate the type of a church encoding, the idea is just look at the recursor for the inductive type. For example, ignoring dependencies in the motive, the type of nat.rec is <code>∀ C, C → (C → C) → ℕ → C</code>, so if you move the <code>ℕ → </code>to the beginning this is exactly the canonical map from N to chN (and the remainder <code>∀ C, C → (C → C) → C</code> is chN itself). (The ordering of the two arguments is not important, and only reflects that <code>zero</code> is the first constructor and <code>succ</code> is the second.)</p>

<a name="125875260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125875260" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125875260">Reid Barton (Apr 30 2018 at 02:21)</a>:</h4>
<p><span class="user-mention" data-user-id="110026">@Simon Hudon</span>, did you see <a href="https://gist.github.com/rwbarton/08924014ebc7b1cf68ec624989249aff" target="_blank" title="https://gist.github.com/rwbarton/08924014ebc7b1cf68ec624989249aff">https://gist.github.com/rwbarton/08924014ebc7b1cf68ec624989249aff</a>?</p>

<a name="125875554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125875554" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125875554">Reid Barton (Apr 30 2018 at 02:32)</a>:</h4>
<p>I'm thinking now that having a <code>class</code> is problematic because the type of the transport function depends on the parameters of the structure in a way that I don't think can be encoded in a <code>class</code> declaration. Plus I don't see any real advantage to having the class anyways. Rather we could just generate definitions <code>group.transport</code>, <code>ring.transport</code> etc.</p>

<a name="125875922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125875922" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125875922">Simon Hudon (Apr 30 2018 at 02:44)</a>:</h4>
<p>I don't think I see your point</p>

<a name="125875971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125875971" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125875971">Reid Barton (Apr 30 2018 at 02:46)</a>:</h4>
<p>My two messages above are unrelated to each other</p>

<a name="125875978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125875978" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125875978">Reid Barton (Apr 30 2018 at 02:47)</a>:</h4>
<p>so I'm not sure what the point that you don't see is <span class="emoji emoji-1f642" title="simple smile">:simple_smile:</span></p>

<a name="125876020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125876020" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125876020">Reid Barton (Apr 30 2018 at 02:48)</a>:</h4>
<p>The gist is supposed to be an example of what we want to have autogenerated: everything defined by <code>magic</code></p>

<a name="125876032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125876032" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125876032">Reid Barton (Apr 30 2018 at 02:49)</a>:</h4>
<p>But making <code>group.transportable</code> be an instance of a class is unnecessary and in general awkward (my gist already contains three classes, and if there are dependencies between the parameters of a structure then things get even more complicated)</p>

<a name="125876229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125876229" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125876229">Simon Hudon (Apr 30 2018 at 02:54)</a>:</h4>
<p>Does your gist illustrate the awkwardness that you're referring to?</p>

<a name="125876246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125876246" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125876246">Reid Barton (Apr 30 2018 at 02:55)</a>:</h4>
<p>To the extent that I already had to define three separate classes <code>transportable</code>, <code>transportable2</code>, <code>transportable3</code></p>

<a name="125876252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125876252" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125876252">Reid Barton (Apr 30 2018 at 02:55)</a>:</h4>
<p>It doesn't illustrate what happens when there are dependencies between arguments</p>

<a name="125876298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125876298" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125876298">Simon Hudon (Apr 30 2018 at 02:56)</a>:</h4>
<p>But if you don't make them classes you still need to define records, no?</p>

<a name="125876311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125876311" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125876311">Reid Barton (Apr 30 2018 at 02:57)</a>:</h4>
<p>Well the instance called <code>group.transportable</code> is only really used as <code>transport group</code>, so <code>transport group</code> can just be named <code>group.transport</code> and no need for a structure.</p>

<a name="125876352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125876352" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125876352">Reid Barton (Apr 30 2018 at 02:58)</a>:</h4>
<p>If we need the <code>on_refl</code> and <code>on_trans</code> fields then they can be called <code>group.transport_on_refl</code> or something</p>

<a name="125876409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125876409" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125876409">Reid Barton (Apr 30 2018 at 03:00)</a>:</h4>
<p>By analogy, there's no class that contains all the <code>.rec</code> functions which are defined for inductive types</p>

<a name="125876510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125876510" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125876510">Simon Hudon (Apr 30 2018 at 03:04)</a>:</h4>
<p>I see that you're arguing against the necessity. I don't see any issue with using a class nonetheless. And the upside of having one is that it allows you to generalize lemmas or definitions. It might be that, as you seem to suggest, there's no ground breaking theorems about those classes. It can still allow you to reduce the boilerplate code</p>

<a name="125876762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125876762" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125876762">Reid Barton (Apr 30 2018 at 03:14)</a>:</h4>
<p>Well at a minimum, you'd need one class per number of type arguments, unless there is a clever way to express <code>transportable2</code> in terms of <code>transportable</code> twice.</p>

<a name="125876766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125876766" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125876766">Reid Barton (Apr 30 2018 at 03:14)</a>:</h4>
<p>I'm not entirely sure what should happen when there are dependencies between arguments. <a href="https://gist.github.com/rwbarton/d847ef6d1783f0d0859eb80de8327bad" target="_blank" title="https://gist.github.com/rwbarton/d847ef6d1783f0d0859eb80de8327bad">https://gist.github.com/rwbarton/d847ef6d1783f0d0859eb80de8327bad</a> shows one possibility. Here <code>t1_space</code> has two arguments, a type <code>α</code> and a topology on <code>α</code>. Since the second argument is not a type, there is no equivalence in that position.</p>

<a name="125877059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125877059" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125877059">Simon Hudon (Apr 30 2018 at 03:27)</a>:</h4>
<p>Having three separate classes does not seem like much of a problem to me. But you can probably equate <code>transportable2 f</code> to <code>transportable (uncurry f)</code>, that way, you can use some of the same definitions for both. And for dependent arguments, if it's more trouble than it's worth, you may have a more ad hoc approach (without classes) for those cases.</p>

<a name="125880638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125880638" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125880638">Mario Carneiro (Apr 30 2018 at 05:54)</a>:</h4>
<p>The range of possible <code>transportable</code> classes is unbounded, not just because of things like <code>transportable2</code> for other values of 2 but also because of higher order functors like <code>(Type -&gt; Type) -&gt; Type</code>, and Pi types like <code>\forall A, group A -&gt; Type</code>. If a tactic generated the transportable theorem for a functor, it would need to select the theorem statement from an unbounded class of statements, namely the "free theorems"</p>

<a name="125880688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125880688" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125880688">Mario Carneiro (Apr 30 2018 at 05:56)</a>:</h4>
<p>You can express <code>transportable2</code> in a more modular way, by generalizing <code>equiv</code>. Define an <code>~=</code> relation on (many) types by induction as follows: If <code>x y : Type</code> then <code>x ~= y</code> means <code>equiv x y</code> (i.e. the usual sense), and if <code>f g : A -&gt; B</code> then <code>f ~= g</code> iff <code>\forall x y, x ~= y -&gt; f x ~= g y</code>. Then <code>transportable x</code> means <code>x ~= x</code>. This generalizes <code>transportable2</code> and <code>transportable3</code>, and also yields transportable for <code>F : (Type -&gt; Type) -&gt; Type</code>, asserting that if <code>f ~= g</code> at <code>Type -&gt; Type</code> then <code>F f ~= F g</code>.</p>

<a name="125881912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125881912" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125881912">Kevin Buzzard (Apr 30 2018 at 06:49)</a>:</h4>
<blockquote>
<p>As Kenny and others have noted, the definition of chN is not correct in dependent type theories like lean because there are additional polymorphic functions that are not parametric. However, you can repair the church nat construction by taking a subtype to enforce that the polymorphic functions are functorial.</p>
</blockquote>
<p>You have put the "free theorem" in with the definition! It really is free now :-)</p>

<a name="125881965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125881965" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125881965">Kevin Buzzard (Apr 30 2018 at 06:51)</a>:</h4>
<p>If you demand that a church numeral is functorial, then the naturals are a universal object because they are freely generated by <code>x : X</code> (zero) and <code>f : X -&gt; X</code> (succ), so any church numeral will be determined by its behaviour on the universal object, with proof by a trivial diagram chase.</p>

<a name="125881967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125881967" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125881967">Kevin Buzzard (Apr 30 2018 at 06:51)</a>:</h4>
<p>And so a church numeral is uniquely determined by what it does on nat, which is precisely the missing theorem for proving the equiv between church nat and nat</p>

<a name="125882007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125882007" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125882007">Kevin Buzzard (Apr 30 2018 at 06:52)</a>:</h4>
<p>A follow-up to the paper should be "Dependent type theory : extra conditions for free"</p>

<a name="125882009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125882009" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125882009">Kevin Buzzard (Apr 30 2018 at 06:53)</a>:</h4>
<p>doesn't sound as marketable</p>

<a name="125882053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125882053" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125882053">Kevin Buzzard (Apr 30 2018 at 06:54)</a>:</h4>
<p>Initially I had thought that church numerals were just some stupid trick for encoding nat. I hadn't until now realised that they were a literal translation of the inductive definition of nat into another language.</p>

<a name="125882071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125882071" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125882071">Kevin Buzzard (Apr 30 2018 at 06:55)</a>:</h4>
<p>But I hadn't got the translation quite right -- I was using the definition I found in Software Foundations. Maybe they are the translation into some other flavour of theory e.g. some lambda calculus thing</p>

<a name="125882116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125882116" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125882116">Kevin Buzzard (Apr 30 2018 at 06:56)</a>:</h4>
<p>So satan was bad after all -- he shouldn't really be allowed to be a church nat because he's not functorial enough.</p>

<a name="125958209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125958209" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125958209">Kevin Buzzard (May 01 2018 at 19:16)</a>:</h4>
<p>Some more church nat puzzles</p>

<a name="125958215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125958215" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125958215">Kevin Buzzard (May 01 2018 at 19:16)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">chℕ</span> <span class="o">:=</span> <span class="bp">Π</span> <span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">,</span> <span class="o">(</span><span class="n">X</span> <span class="bp">→</span> <span class="n">X</span><span class="o">)</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">X</span>

<span class="kn">namespace</span> <span class="n">chnat</span>

<span class="kn">open</span> <span class="n">nat</span>

<span class="kn">definition</span> <span class="n">to_nat</span> <span class="o">:</span> <span class="n">chℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">m</span><span class="o">,</span> <span class="n">m</span> <span class="bp">ℕ</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="mi">0</span>

<span class="n">def</span> <span class="n">of_nat</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">chℕ</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">zero</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">X</span> <span class="n">f</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">X</span> <span class="n">f</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">of_nat</span> <span class="n">n</span> <span class="n">X</span> <span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="c1">-- f (f^n x)</span>

<span class="kn">definition</span> <span class="n">of_nat&#39;</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">chℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">X</span> <span class="n">f</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">X</span> <span class="n">f</span> <span class="n">x</span><span class="o">,</span> <span class="n">of_nat&#39;</span> <span class="n">n</span> <span class="n">X</span> <span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="c1">-- f^n (f x)</span>

<span class="kn">theorem</span> <span class="n">nat_of_chnat_of_nat</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">to_nat</span> <span class="o">(</span><span class="n">of_nat</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kn">theorem</span> <span class="n">nat_of_chnat_of_nat&#39;</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">to_nat</span> <span class="o">(</span><span class="n">of_nat&#39;</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kn">theorem</span> <span class="n">of_nat&#39;_is_of_nat</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">of_nat</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">of_nat&#39;</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">end</span> <span class="n">chnat</span>
</pre></div>

<a name="125958222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/125958222" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#125958222">Kevin Buzzard (May 01 2018 at 19:16)</a>:</h4>
<p>I haven't proved all of them, I expected them all to be true.</p>

<a name="126359013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/126359013" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#126359013">Kevin Buzzard (May 10 2018 at 10:37)</a>:</h4>
<p>The typeclass <code>is_group_hom</code> (in <code>algebra/group.lean</code> in mathlib) transports across a lot of structure</p>

<a name="126359063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/126359063" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#126359063">Kevin Buzzard (May 10 2018 at 10:39)</a>:</h4>
<p>For example, <code>equiv.Pi_congr_right</code> says that if (F i) and (G i) biject for all i, then Pi i, F i bijects with Pi i, G i</p>

<a name="126359070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/126359070" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#126359070">Kevin Buzzard (May 10 2018 at 10:39)</a>:</h4>
<p>but if the bijections are all group homs then the product bijection is also a group hom</p>

<a name="126359073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/126359073" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#126359073">Kevin Buzzard (May 10 2018 at 10:39)</a>:</h4>
<p>and the proof is idea-free</p>

<a name="126359117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/126359117" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#126359117">Kevin Buzzard (May 10 2018 at 10:40)</a>:</h4>
<p>so instead of having to write my own instance for this (which I just did)</p>

<a name="126359133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/126359133" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#126359133">Kevin Buzzard (May 10 2018 at 10:40)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">instance</span> <span class="n">is_add_group_hom</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">Pi_congr_right</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">γ</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">γ</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">add_group</span> <span class="o">(</span><span class="n">F</span> <span class="n">i</span><span class="o">)]</span>
<span class="o">[</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">add_group</span> <span class="o">(</span><span class="n">G</span> <span class="n">i</span><span class="o">)]</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">γ</span><span class="o">,</span> <span class="n">F</span> <span class="n">i</span> <span class="err">≃</span> <span class="n">G</span> <span class="n">i</span><span class="o">)</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">is_add_group_hom</span> <span class="o">(</span><span class="n">H</span> <span class="n">i</span><span class="o">)]</span> <span class="o">:</span>
 <span class="n">is_add_group_hom</span> <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">Pi_congr_right</span> <span class="n">H</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">funext</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span>
 <span class="k">show</span> <span class="n">H</span> <span class="n">i</span> <span class="o">((</span><span class="n">a</span> <span class="n">i</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">b</span> <span class="n">i</span><span class="o">))</span> <span class="bp">=</span> <span class="n">H</span> <span class="n">i</span> <span class="o">(</span><span class="n">a</span> <span class="n">i</span><span class="o">)</span> <span class="bp">+</span> <span class="n">H</span> <span class="n">i</span> <span class="o">(</span><span class="n">b</span> <span class="n">i</span><span class="o">),</span>
</pre></div>

<a name="126359135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/126359135" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#126359135">Kevin Buzzard (May 10 2018 at 10:40)</a>:</h4>
<p>(OK so it was additive group homs, which is a slightly different typeclass)</p>

<a name="126359143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/126359143" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#126359143">Kevin Buzzard (May 10 2018 at 10:41)</a>:</h4>
<p>this should surely have been auto-generated for me when the type class inference system realised I needed it. Right?</p>

<a name="126359150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/126359150" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#126359150">Kevin Buzzard (May 10 2018 at 10:41)</a>:</h4>
<p>Similarly, given</p>

<a name="126359187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/126359187" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#126359187">Kevin Buzzard (May 10 2018 at 10:42)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">definition</span> <span class="n">Pi_lift_map₁</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">γ</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">γ</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>
  <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">γ</span><span class="o">,</span> <span class="n">F</span> <span class="n">i</span> <span class="bp">→</span> <span class="n">G</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">Π</span> <span class="n">i</span><span class="o">,</span> <span class="n">F</span> <span class="n">i</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">Π</span> <span class="n">i</span><span class="o">,</span> <span class="n">G</span> <span class="n">i</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">Fi</span> <span class="n">i</span><span class="o">,</span> <span class="n">H</span> <span class="n">i</span> <span class="o">(</span><span class="n">Fi</span> <span class="n">i</span><span class="o">)</span>
</pre></div>

<a name="126359192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/126359192" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#126359192">Kevin Buzzard (May 10 2018 at 10:42)</a>:</h4>
<p>I should get a free instance of "all the H i are group homs implies their product is"</p>

<a name="126359252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/126359252" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#126359252">Kenny Lau (May 10 2018 at 10:45)</a>:</h4>
<p>that's the UMP of product right</p>

<a name="126359306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/126359306" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#126359306">Kevin Buzzard (May 10 2018 at 10:46)</a>:</h4>
<p>Pi_lift_map2 is the UMP of product</p>

<a name="126359317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/126359317" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#126359317">Mario Carneiro (May 10 2018 at 10:47)</a>:</h4>
<p>This is not exactly trivial. It's conceivable it falls out of the <code>Pi_instance</code> tactic stuff, but you do have to make use of some lemmas and funext in appropriate places</p>

<a name="126359366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/126359366" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#126359366">Kevin Buzzard (May 10 2018 at 10:48)</a>:</h4>
<p>I would like to make Lean behave more like a mathematician</p>

<a name="126359369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/126359369" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#126359369">Kevin Buzzard (May 10 2018 at 10:48)</a>:</h4>
<p>and mathematicians know that the function one is easy</p>

<a name="126359371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/126359371" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#126359371">Kevin Buzzard (May 10 2018 at 10:48)</a>:</h4>
<p>and they instantly deduce the equiv one</p>

<a name="126359372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/126359372" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#126359372">Mario Carneiro (May 10 2018 at 10:48)</a>:</h4>
<p>I can see <code>simp</code> being able to do this one with some hints</p>

<a name="126359376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/126359376" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#126359376">Mario Carneiro (May 10 2018 at 10:49)</a>:</h4>
<p>the equiv one is literally the same theorem though</p>

<a name="126359382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/126359382" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#126359382">Kevin Buzzard (May 10 2018 at 10:49)</a>:</h4>
<p>There's a meta-hint for this sort of thing</p>

<a name="126359384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/126359384" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#126359384">Mario Carneiro (May 10 2018 at 10:49)</a>:</h4>
<p>that is trivial even by lean's standards</p>

<a name="126359385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/126359385" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#126359385">Kevin Buzzard (May 10 2018 at 10:49)</a>:</h4>
<p>"To prove axiom X for the product, use axiom X on the factors"</p>

<a name="126359388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/126359388" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#126359388">Kevin Buzzard (May 10 2018 at 10:49)</a>:</h4>
<p>I agree it's the same theorem, that's why it has the same proof</p>

<a name="126359391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/126359391" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#126359391">Kevin Buzzard (May 10 2018 at 10:49)</a>:</h4>
<p>but you told me to write it twice</p>

<a name="126359392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/126359392" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#126359392">Kevin Buzzard (May 10 2018 at 10:49)</a>:</h4>
<p>because you said Lean needs to be told it twice</p>

<a name="126359393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/126359393" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#126359393">Kevin Buzzard (May 10 2018 at 10:49)</a>:</h4>
<p>Right?</p>

<a name="126359394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/126359394" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#126359394">Mario Carneiro (May 10 2018 at 10:50)</a>:</h4>
<p>you should apply the theorem, not prove it twice</p>

<a name="126359445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/126359445" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#126359445">Kevin Buzzard (May 10 2018 at 10:50)</a>:</h4>
<p>heh</p>

<a name="126359447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/126359447" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#126359447">Mario Carneiro (May 10 2018 at 10:50)</a>:</h4>
<p>def X := proof, def Y := X</p>

<a name="126359507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/126359507" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#126359507">Kevin Buzzard (May 10 2018 at 10:52)</a>:</h4>
<p>ha ha</p>

<a name="126359509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/126359509" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#126359509">Kevin Buzzard (May 10 2018 at 10:52)</a>:</h4>
<p>proof <code>is_add_group_hom.Pi_lift H</code> fails</p>

<a name="126359510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/126359510" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#126359510">Kevin Buzzard (May 10 2018 at 10:52)</a>:</h4>
<p>proof <code>is_add_group_hom.Pi_lift (λ i, H i)</code> succeeds</p>

<a name="126359518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/126359518" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#126359518">Kevin Buzzard (May 10 2018 at 10:53)</a>:</h4>
<p>Lean knows it's looking for something of a certain type lam i, map</p>

<a name="126359519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/126359519" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#126359519">Kevin Buzzard (May 10 2018 at 10:53)</a>:</h4>
<p>and H i is an equiv which coerces to map</p>

<a name="126359520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/126359520" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#126359520">Kevin Buzzard (May 10 2018 at 10:53)</a>:</h4>
<p>but it's not smart enough to do it without the i</p>

<a name="126360142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/126360142" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#126360142">Mario Carneiro (May 10 2018 at 11:11)</a>:</h4>
<p>what about <code>is_add_group_hom.Pi_lift _</code>?</p>

<a name="126365134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/126365134" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#126365134">Kevin Buzzard (May 10 2018 at 13:37)</a>:</h4>
<p>nope</p>

<a name="135390412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22canonically%22%20identifying%20two%20types/near/135390412" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/18651canonicallyidentifyingtwotypes.html#135390412">Kevin Buzzard (Oct 08 2018 at 09:20)</a>:</h4>
<p>Ooh look, this is back in the days when I used to post one paragraph as ten one-sentence posts.</p>
<p>I finally got around to making this an issue.</p>
<p><a href="https://github.com/leanprover/mathlib/issues/408" target="_blank" title="https://github.com/leanprover/mathlib/issues/408">https://github.com/leanprover/mathlib/issues/408</a></p>


{% endraw %}
