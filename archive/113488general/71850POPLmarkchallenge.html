---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/71850POPLmarkchallenge.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html">POPLmark challenge</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="186924030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186924030" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186924030">Tim Daly (Jan 29 2020 at 20:11)</a>:</h4>
<p>(<a href="https://blog.sigplan.org/2020/01/29/mechanized-proofs-for-pl-past-present-and-future" target="_blank" title="https://blog.sigplan.org/2020/01/29/mechanized-proofs-for-pl-past-present-and-future">https://blog.sigplan.org/2020/01/29/mechanized-proofs-for-pl-past-present-and-future</a>) POPLmark challenge is about Mechanized Proofs for Programming Languages. Lean is not just about mechanizing formal mathematics. It is also about mechanizing computational mathematics (at least from my opinionated viewpoint).   So besides pushing into the Math dept. we need to push into CS departments.</p>

<a name="186924244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186924244" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186924244">Tim Daly (Jan 29 2020 at 20:13)</a>:</h4>
<p>CMU has Frank Pfenning, Bob Harper, and Karl Crary, all in CS and all doing related work, just not in Lean. What would it take to "Buzzard" the CS community?</p>

<a name="186924317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186924317" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186924317">Johan Commelin (Jan 29 2020 at 20:14)</a>:</h4>
<p>It would take a buzzard...</p>

<a name="186924969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186924969" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186924969">Tim Daly (Jan 29 2020 at 20:22)</a>:</h4>
<p>We have mathlib for the formal crowd. Perhaps we can import the Standard ML kinds of support into a proglib, which would contain definitions, axioms, and theorems related to code.</p>

<a name="186925427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186925427" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186925427">Tim Daly (Jan 29 2020 at 20:28)</a>:</h4>
<p>From the talk... The paper abstract reads:<br>
How close are we to a world where every paper on progamming languages is accompanied by an electronic appendix with machine-checked proofs?<br>
We propose an initial set of benchmarks for measuring progress in this area. Based on the metatheory of System $F_&lt;$, a typed lambda-calculus with second-order polymorphism, subtyping, and records, these benchmarks embody many aspects of programming languages that are challenging to formalize: variable binding at both the term and type levels, syntactic forms with variable numbers of components (including binders), and proofs demanding complex induction principles. We hopt that these benchmarks will help clarify the current state of the art, provide a basis for comparing competing technologies, and motivate further research.</p>

<a name="186928605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186928605" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186928605">Tim Daly (Jan 29 2020 at 21:05)</a>:</h4>
<p>One of the likely side-effects of a proglib (vs mathlib) would be developing program generation from Lean proofs. This isn't of much interest to the formal math approach but would be to the computational math crowd (aka me :-) )</p>

<a name="186934837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186934837" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186934837">Patrick Massot (Jan 29 2020 at 22:18)</a>:</h4>
<blockquote>
<p>CMU has Frank Pfenning, Bob Harper, and Karl Crary, all in CS and all doing related work, just not in Lean. What would it take to "Buzzard" the CS community?</p>
</blockquote>
<p>I don't want to minimize Kevin's work, but it looks like this forum gives you a very distorted view of the reality of maths departments. To finite order, nothing changed. Any effect is beyond what Taylor expansions can see. The number of mathematicians using a proof assistant may have been multiplied by 20 in the last two years, but it is still very very very close to zero in proportion.</p>

<a name="186935818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186935818" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186935818">Tim Daly (Jan 29 2020 at 22:31)</a>:</h4>
<p>I did a survey of the connection between ITP and Computer Algebra. I can only name one person (James Davenport) who appears in both bibliographies. So I know that this is at the "not even noise" level. But I have a "30 Year Horizon" view and I believe the connection must arrive in the long term. In particular, the subset of programming that involves computer algebra seems most likely to be automated since the specifications of the algorithms are already (reasonably well) known.</p>
<p>I'm spending the evening digging up information on TWELF and Standard ML, looking for something that could serve as a kernel of "proglib" in Lean. If Lean could produce ML programs from proofs that would be a major advance for Lean.</p>
<p>The fact that nobody knows how to do this is what makes it research.</p>

<a name="186935971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186935971" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186935971">Simon Cruanes (Jan 29 2020 at 22:33)</a>:</h4>
<p>By producing ML programs from proofs, are you referring to something similar to Coq's extraction to OCaml?</p>

<a name="186936005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186936005" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186936005">Simon Cruanes (Jan 29 2020 at 22:33)</a>:</h4>
<p>(extracting programs from proof assistants seem relatively common to me, Isabelle/HOL even has components to extract imperative programs)</p>

<a name="186936123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186936123" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186936123">Tim Daly (Jan 29 2020 at 22:34)</a>:</h4>
<p>Yes. Lean should be able to extract a program from a proof. I'd rather it could extract SPAD (Axiom's language) programs as SPAD is dependently typed but ML might be easier as some of the other systems could provide validation.</p>

<a name="186936287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186936287" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186936287">Tim Daly (Jan 29 2020 at 22:37)</a>:</h4>
<p>One interesting thought would be to try to build 'proglib' so that everything has a programming language representation. Sort of "designed to be executed". I'm not sure yet how this can be done, of course.</p>

<a name="186936382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186936382" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186936382">Reid Barton (Jan 29 2020 at 22:38)</a>:</h4>
<p>Lean is already a programming language, so you can take the program extraction to be the identity.</p>

<a name="186936431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186936431" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186936431">Tim Daly (Jan 29 2020 at 22:39)</a>:</h4>
<p>I'm not sure what the execution semantics are for the proofs I've read.</p>

<a name="186936439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186936439" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186936439">Reid Barton (Jan 29 2020 at 22:40)</a>:</h4>
<p>In Lean 4, this will sometimes even be a sensible thing to do. But a lot depends on the original proof. For example, if it is nonconstructive, then it has no computational meaning.</p>

<a name="186936486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186936486" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186936486">Reid Barton (Jan 29 2020 at 22:40)</a>:</h4>
<p>Because those proofs were not intended to be executed, most likely</p>

<a name="186936551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186936551" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186936551">Simon Cruanes (Jan 29 2020 at 22:41)</a>:</h4>
<p>If you want to write verified programs, why consider them as proofs and not as normal values? This way you can write programs in a readable way, and prove properties about them separately (which is done in CFML, CompCert, etc. afaik)</p>

<a name="186936598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186936598" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186936598">Tim Daly (Jan 29 2020 at 22:42)</a>:</h4>
<p>My thought (and what I'm using as a basis for reading) is that I'm looking for a translation from program -&gt; Lean -&gt; program that is 1-1 (or some near approach). I've found some ML and TWELF papers so I'm reading.</p>

<a name="186937441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186937441" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186937441">Tim Daly (Jan 29 2020 at 22:55)</a>:</h4>
<p><span class="user-mention" data-user-id="132878">@Simon Cruanes</span>  I have programs written in a reasonable way (e.g. GCD, Groebner, etc) and specifications for them. But there needs to be some deeper, automated connection from these programs to Lean and back so they can be trusted. Otherwise it feels like "hand waving" (at least to me).</p>

<a name="186941949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186941949" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186941949">Tim Daly (Jan 29 2020 at 23:59)</a>:</h4>
<p>There is an interesting split I've come to recognize between the ITP approach and the Type-Theory approach to things, despite the fact that they both seem to use the same judgments. ITP systems tend toward "tactics" whereas the Type-Theory approach tends to use unification.</p>

<a name="186946526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186946526" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186946526">Simon Cruanes (Jan 30 2020 at 01:16)</a>:</h4>
<p>In my (limited) view of the field, it seems like most big programs that are verified in ITPs are all based on the separation of the program to prove and the properties on the program (even CompCert, and of course, SEL4, CakeML, etc.).<br>
I'm not aware of any actual big program written as a proof following the CH correspondence. I'd love be to proven wrong though!</p>

<a name="186947152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186947152" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186947152">Tim Daly (Jan 30 2020 at 01:27)</a>:</h4>
<p>Axiom is a collection of mathematical algorithms. Rather than prove a large program, my effort is to prove the individual algorithms. So, for instance, GCD has a specification and an implementation. There are several interesting questions that arise. Axiom actually has 22 different GCD algorithms (e.g. GCD for polynomials, Nats, etc). How can these algorithms be proven correct. How can they be proven correct in such a way that Lean can verify the proof, allowing Lean to use Axiom as an Oracle for a GCD computation.</p>

<a name="186947505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186947505" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186947505">Tim Daly (Jan 30 2020 at 01:32)</a>:</h4>
<p>Nat in Axiom is called NonNegativeInteger (NNI). The definitions, axioms, and theorems available to the NNI Domain (an Axiom term for an implementation) are all inherited. The NNI Domain also includes a "carrier" (called a REP) which specifies how elements are implemented. So, given group theory axioms (e.g. associativity), a representation, a specification, and an algorithm... use Lean's group theory and Nat, as well as pre- and post-conditions and loop invariants to prove the GCD correct in Lean.</p>

<a name="186947534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186947534" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186947534">Simon Cruanes (Jan 30 2020 at 01:33)</a>:</h4>
<p>So what language is the algorithm expressed in?</p>

<a name="186947615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186947615" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186947615">Tim Daly (Jan 30 2020 at 01:34)</a>:</h4>
<p>SPAD, a dependently typed language built on Common Lisp. (See <a href="https://github.com/daly/PDFS/blob/master/bookvol0.pdf" target="_blank" title="https://github.com/daly/PDFS/blob/master/bookvol0.pdf">https://github.com/daly/PDFS/blob/master/bookvol0.pdf</a>)</p>

<a name="186947718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186947718" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186947718">Tim Daly (Jan 30 2020 at 01:36)</a>:</h4>
<p>In an ideal world a GCD algorithm would be transformed into a Lean proof object, proven, and then re-generated from the proof object. The proof then becomes a certificate you can hand to a proof-checker.</p>

<a name="186947833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186947833" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186947833">Simon Cruanes (Jan 30 2020 at 01:39)</a>:</h4>
<p>Oh damn, I didn't realize it was <em>that</em> axiom, the CASâ€¦ :o</p>

<a name="186947904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186947904" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186947904">Tim Daly (Jan 30 2020 at 01:40)</a>:</h4>
<p>There are a lot of "Axiom" things around, including the new Axiom that is working on space ships. But, yes, this is the Axiom originally from IBM Research and I'm one of the original people to blame. :-)</p>

<a name="186948018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186948018" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186948018">Simon Cruanes (Jan 30 2020 at 01:43)</a>:</h4>
<blockquote>
<p>There are a lot of "Axiom" things around</p>
</blockquote>
<p>well of course, that's why we have the Axiom of choice!</p>

<a name="186948041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186948041" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186948041">Tim Daly (Jan 30 2020 at 01:43)</a>:</h4>
<p>2 points on that one. I am SO stealing that.</p>

<a name="186948534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186948534" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186948534">Tim Daly (Jan 30 2020 at 01:53)</a>:</h4>
<p>Axiom's byline is "The 30 Year Horizon" but I think you just came up with a "near miss".</p>

<a name="186948614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186948614" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186948614">Simon Cruanes (Jan 30 2020 at 01:56)</a>:</h4>
<p>you can display a catchphrase randomly sampled on the website :)</p>


{% endraw %}

{% include archive_update.html %}