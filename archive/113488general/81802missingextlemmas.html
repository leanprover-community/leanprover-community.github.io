---
layout: archive
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/81802missingextlemmas.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html">missing ext lemmas?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="135088491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135088491" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135088491">Johan Commelin (Oct 03 2018 at 08:22)</a>:</h4>
<p>How many of the following should be marked with <code>@[extensionality]</code>?</p>
<div class="codehilite"><pre><span></span><span class="n">data</span><span class="bp">/</span><span class="n">buffer</span><span class="bp">/</span><span class="n">basic</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">lemma</span> <span class="n">ext</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">b₁</span> <span class="n">b₂</span> <span class="o">:</span> <span class="n">buffer</span> <span class="n">α</span><span class="o">},</span> <span class="n">to_list</span> <span class="n">b₁</span> <span class="bp">=</span> <span class="n">to_list</span> <span class="n">b₂</span> <span class="bp">→</span> <span class="n">b₁</span> <span class="bp">=</span> <span class="n">b₂</span>
<span class="n">data</span><span class="bp">/</span><span class="n">equiv</span><span class="bp">/</span><span class="n">basic</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">lemma</span> <span class="n">ext</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">equiv</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">:=</span>
<span class="n">data</span><span class="bp">/</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">lemma</span> <span class="n">ext</span> <span class="o">:</span> <span class="bp">∀</span><span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span><span class="err">₀</span> <span class="n">β</span><span class="o">},</span> <span class="o">(</span><span class="bp">∀</span><span class="n">a</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">g</span> <span class="n">a</span><span class="o">)</span> <span class="bp">→</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span>
<span class="n">data</span><span class="bp">/</span><span class="n">list</span><span class="bp">/</span><span class="n">basic</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">lemma</span> <span class="n">foldl_ext</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
<span class="n">data</span><span class="bp">/</span><span class="n">list</span><span class="bp">/</span><span class="n">basic</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">lemma</span> <span class="n">foldr_ext</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span>
<span class="n">data</span><span class="bp">/</span><span class="n">prod</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">lemma</span> <span class="n">ext</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span> <span class="n">p</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">=</span> <span class="n">q</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">→</span> <span class="n">p</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">=</span> <span class="n">q</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">→</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">q</span> <span class="o">:=</span>
<span class="n">data</span><span class="bp">/</span><span class="n">subtype</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">lemma</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">ext</span> <span class="o">{</span><span class="n">a1</span> <span class="n">a2</span> <span class="o">:</span> <span class="o">{</span><span class="n">x</span> <span class="bp">//</span> <span class="n">β</span> <span class="n">x</span><span class="o">}}</span> <span class="o">:</span> <span class="n">a1</span> <span class="bp">=</span> <span class="n">a2</span> <span class="bp">↔</span> <span class="n">a1</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="n">a2</span><span class="bp">.</span><span class="n">val</span> <span class="o">:=</span>
<span class="n">data</span><span class="bp">/</span><span class="n">subtype</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">lemma</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">coe_ext</span> <span class="o">{</span><span class="n">a1</span> <span class="n">a2</span> <span class="o">:</span> <span class="o">{</span><span class="n">x</span> <span class="bp">//</span> <span class="n">β</span> <span class="n">x</span><span class="o">}}</span> <span class="o">:</span> <span class="n">a1</span> <span class="bp">=</span> <span class="n">a2</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">a1</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a2</span> <span class="o">:=</span>
<span class="n">logic</span><span class="bp">/</span><span class="n">function</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">lemma</span> <span class="n">hfunext</span> <span class="o">{</span><span class="n">α</span> <span class="n">α&#39;</span><span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">Sort</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">β&#39;</span> <span class="o">:</span> <span class="n">α&#39;</span> <span class="bp">→</span> <span class="n">Sort</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="bp">Π</span><span class="n">a</span><span class="o">,</span> <span class="n">β</span> <span class="n">a</span><span class="o">}</span> <span class="o">{</span><span class="n">f&#39;</span> <span class="o">:</span> <span class="bp">Π</span><span class="n">a</span><span class="o">,</span> <span class="n">β&#39;</span> <span class="n">a</span><span class="o">}</span>
<span class="n">order</span><span class="bp">/</span><span class="n">filter</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">protected</span> <span class="kn">lemma</span> <span class="n">ext</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">s</span><span class="o">,</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">f</span><span class="bp">.</span><span class="n">sets</span> <span class="bp">↔</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">g</span><span class="bp">.</span><span class="n">sets</span><span class="o">)</span> <span class="bp">→</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">:=</span>
<span class="n">category</span><span class="bp">/</span><span class="n">applicative</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">applicative</span><span class="bp">.</span><span class="n">ext</span> <span class="o">{</span><span class="n">F</span><span class="o">}</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">A1</span> <span class="o">:</span> <span class="n">applicative</span> <span class="n">F</span><span class="o">}</span> <span class="o">{</span><span class="n">A2</span> <span class="o">:</span> <span class="n">applicative</span> <span class="n">F</span><span class="o">}</span>
<span class="n">category</span><span class="bp">/</span><span class="n">functor</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">functor</span><span class="bp">.</span><span class="n">ext</span> <span class="o">{</span><span class="n">F</span><span class="o">}</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">F1</span> <span class="o">:</span> <span class="n">functor</span> <span class="n">F</span><span class="o">}</span> <span class="o">{</span><span class="n">F2</span> <span class="o">:</span> <span class="n">functor</span> <span class="n">F</span><span class="o">}</span>
<span class="n">data</span><span class="bp">/</span><span class="n">analysis</span><span class="bp">/</span><span class="n">topology</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">ext</span> <span class="o">[</span><span class="n">T</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">σ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">ctop</span> <span class="n">α</span> <span class="n">σ</span><span class="o">}</span>
<span class="n">data</span><span class="bp">/</span><span class="n">complex</span><span class="bp">/</span><span class="n">basic</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">ext</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">z</span> <span class="n">w</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">},</span> <span class="n">z</span><span class="bp">.</span><span class="n">re</span> <span class="bp">=</span> <span class="n">w</span><span class="bp">.</span><span class="n">re</span> <span class="bp">→</span> <span class="n">z</span><span class="bp">.</span><span class="n">im</span> <span class="bp">=</span> <span class="n">w</span><span class="bp">.</span><span class="n">im</span> <span class="bp">→</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">w</span>
<span class="n">data</span><span class="bp">/</span><span class="n">finset</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">ext</span> <span class="o">{</span><span class="n">s₁</span> <span class="n">s₂</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">s₁</span> <span class="bp">=</span> <span class="n">s₂</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">s₁</span> <span class="bp">↔</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">s₂</span> <span class="o">:=</span>
<span class="n">data</span><span class="bp">/</span><span class="n">list</span><span class="bp">/</span><span class="n">basic</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">ext</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">},</span> <span class="o">(</span><span class="bp">∀</span><span class="n">n</span><span class="o">,</span> <span class="n">nth</span> <span class="n">l₁</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">nth</span> <span class="n">l₂</span> <span class="n">n</span><span class="o">)</span> <span class="bp">→</span> <span class="n">l₁</span> <span class="bp">=</span> <span class="n">l₂</span>
<span class="n">data</span><span class="bp">/</span><span class="n">list</span><span class="bp">/</span><span class="n">perm</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">perm_ext</span> <span class="o">{</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">d₁</span> <span class="o">:</span> <span class="n">nodup</span> <span class="n">l₁</span><span class="o">)</span> <span class="o">(</span><span class="n">d₂</span> <span class="o">:</span> <span class="n">nodup</span> <span class="n">l₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">l₁</span> <span class="bp">~</span> <span class="n">l₂</span> <span class="bp">↔</span> <span class="bp">∀</span><span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">l₁</span> <span class="bp">↔</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">l₂</span> <span class="o">:=</span>
<span class="n">data</span><span class="bp">/</span><span class="n">multiset</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">ext</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">t</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">count</span> <span class="n">a</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">count</span> <span class="n">a</span> <span class="n">t</span> <span class="o">:=</span>
<span class="n">data</span><span class="bp">/</span><span class="n">multiset</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">nodup_ext</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">nodup</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">nodup</span> <span class="n">t</span> <span class="bp">→</span> <span class="o">(</span><span class="n">s</span> <span class="bp">=</span> <span class="n">t</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">s</span> <span class="bp">↔</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">t</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">data</span><span class="bp">/</span><span class="n">multiset</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">erase_dup_ext</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">erase_dup</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">erase_dup</span> <span class="n">t</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">s</span> <span class="bp">↔</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">t</span> <span class="o">:=</span>
<span class="n">data</span><span class="bp">/</span><span class="n">option</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">ext</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">o₁</span> <span class="n">o₂</span> <span class="o">:</span> <span class="n">option</span> <span class="n">α</span><span class="o">},</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">o₁</span> <span class="bp">↔</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">o₂</span><span class="o">)</span> <span class="bp">→</span> <span class="n">o₁</span> <span class="bp">=</span> <span class="n">o₂</span>
<span class="n">data</span><span class="bp">/</span><span class="n">real</span><span class="bp">/</span><span class="n">cau_seq</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">ext</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">cau_seq</span> <span class="n">β</span> <span class="n">abv</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">g</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">:=</span>
<span class="n">data</span><span class="bp">/</span><span class="n">semiquot</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">ext</span> <span class="o">{</span><span class="n">q₁</span> <span class="n">q₂</span> <span class="o">:</span> <span class="n">semiquot</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">q₁</span> <span class="bp">=</span> <span class="n">q₂</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">q₁</span> <span class="bp">↔</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">q₂</span> <span class="o">:=</span>
<span class="n">data</span><span class="bp">/</span><span class="n">seq</span><span class="bp">/</span><span class="n">wseq</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">ext</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">wseq</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">nth</span> <span class="n">s</span> <span class="n">n</span> <span class="bp">~</span> <span class="n">nth</span> <span class="n">t</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">~</span> <span class="n">t</span> <span class="o">:=</span>
<span class="n">data</span><span class="bp">/</span><span class="n">set</span><span class="bp">/</span><span class="n">basic</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">set_coe</span><span class="bp">.</span><span class="n">ext</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">s</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="err">↑</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="err">↑</span><span class="n">b</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span>
<span class="n">data</span><span class="bp">/</span><span class="n">set</span><span class="bp">/</span><span class="n">basic</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">ext</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">a</span> <span class="bp">↔</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span>
<span class="n">group_theory</span><span class="bp">/</span><span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">protected</span> <span class="kn">theorem</span> <span class="n">ext</span> <span class="o">(</span><span class="n">g</span> <span class="n">h</span> <span class="o">:</span> <span class="n">free_abelian_group</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>
<span class="n">linear_algebra</span><span class="bp">/</span><span class="n">linear_map_module</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">ext</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">A</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">B</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">=</span> <span class="n">B</span> <span class="o">:=</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">eq</span> <span class="err">$</span> <span class="n">funext</span> <span class="n">h</span>
<span class="n">linear_algebra</span><span class="bp">/</span><span class="n">tensor_product</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">to_module</span><span class="bp">.</span><span class="n">ext</span> <span class="o">{</span><span class="n">g</span> <span class="n">h</span> <span class="o">:</span> <span class="n">M</span> <span class="err">⊗</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">P</span><span class="o">}</span>
<span class="n">number_theory</span><span class="bp">/</span><span class="n">dioph</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span>  <span class="kn">theorem</span> <span class="n">ext</span> <span class="o">{</span><span class="n">S</span> <span class="n">S&#39;</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)}</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">dioph</span> <span class="n">S</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span><span class="n">v</span><span class="o">,</span> <span class="n">S</span> <span class="n">v</span> <span class="bp">↔</span> <span class="n">S&#39;</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="n">dioph</span> <span class="n">S&#39;</span> <span class="o">:=</span>
<span class="n">number_theory</span><span class="bp">/</span><span class="n">pell</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span>  <span class="kn">theorem</span> <span class="n">ext</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">z</span> <span class="n">w</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="err">√</span><span class="n">d</span><span class="o">},</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">w</span> <span class="bp">↔</span> <span class="n">z</span><span class="bp">.</span><span class="n">re</span> <span class="bp">=</span> <span class="n">w</span><span class="bp">.</span><span class="n">re</span> <span class="bp">∧</span> <span class="n">z</span><span class="bp">.</span><span class="n">im</span> <span class="bp">=</span> <span class="n">w</span><span class="bp">.</span><span class="n">im</span>
<span class="n">order</span><span class="bp">/</span><span class="n">basic</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">preorder</span><span class="bp">.</span><span class="n">ext</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">preorder</span> <span class="n">α</span><span class="o">}</span>
<span class="n">order</span><span class="bp">/</span><span class="n">basic</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">partial_order</span><span class="bp">.</span><span class="n">ext</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">partial_order</span> <span class="n">α</span><span class="o">}</span>
<span class="n">order</span><span class="bp">/</span><span class="n">basic</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">linear_order</span><span class="bp">.</span><span class="n">ext</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">linear_order</span> <span class="n">α</span><span class="o">}</span>
<span class="n">order</span><span class="bp">/</span><span class="n">bounded_lattice</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">order_top</span><span class="bp">.</span><span class="n">ext</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">order_top</span> <span class="n">α</span><span class="o">}</span>
<span class="n">order</span><span class="bp">/</span><span class="n">bounded_lattice</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">order_bot</span><span class="bp">.</span><span class="n">ext</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">order_bot</span> <span class="n">α</span><span class="o">}</span>
<span class="n">order</span><span class="bp">/</span><span class="n">bounded_lattice</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">bounded_lattice</span><span class="bp">.</span><span class="n">ext</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">bounded_lattice</span> <span class="n">α</span><span class="o">}</span>
<span class="n">order</span><span class="bp">/</span><span class="n">lattice</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">semilattice_sup</span><span class="bp">.</span><span class="n">ext</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">semilattice_sup</span> <span class="n">α</span><span class="o">}</span>
<span class="n">order</span><span class="bp">/</span><span class="n">lattice</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">semilattice_inf</span><span class="bp">.</span><span class="n">ext</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">semilattice_inf</span> <span class="n">α</span><span class="o">}</span>
<span class="n">order</span><span class="bp">/</span><span class="n">lattice</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">lattice</span><span class="bp">.</span><span class="n">ext</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">lattice</span> <span class="n">α</span><span class="o">}</span>
<span class="n">set_theory</span><span class="bp">/</span><span class="n">zfc</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">ext</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">pSet</span><span class="o">),</span> <span class="n">equiv</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">x</span> <span class="err">⊆</span> <span class="n">y</span> <span class="bp">∧</span> <span class="n">y</span> <span class="err">⊆</span> <span class="n">x</span><span class="o">)</span>
<span class="n">set_theory</span><span class="bp">/</span><span class="n">zfc</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">mem</span><span class="bp">.</span><span class="n">ext</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">pSet</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">}},</span> <span class="o">(</span><span class="bp">∀</span><span class="n">w</span><span class="o">:</span><span class="n">pSet</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">},</span> <span class="n">w</span> <span class="err">∈</span> <span class="n">x</span> <span class="bp">↔</span> <span class="n">w</span> <span class="err">∈</span> <span class="n">y</span><span class="o">)</span> <span class="bp">→</span> <span class="n">equiv</span> <span class="n">x</span> <span class="n">y</span>
<span class="n">set_theory</span><span class="bp">/</span><span class="n">zfc</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">ext</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">Set</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">}}</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span><span class="n">z</span><span class="o">:</span><span class="n">Set</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">},</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">x</span> <span class="bp">↔</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">y</span><span class="o">)</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span>
</pre></div>

<a name="135088502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135088502" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135088502">Johan Commelin (Oct 03 2018 at 08:22)</a>:</h4>
<p>Is it worth going through this list. Or have people done that before, and decided that this should not get the <code>extensionality</code> attribute?</p>

<a name="135089015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135089015" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135089015">Kenny Lau (Oct 03 2018 at 08:37)</a>:</h4>
<p>thanks for bringing this up</p>

<a name="135089062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135089062" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135089062">Patrick Massot (Oct 03 2018 at 08:38)</a>:</h4>
<p>I think it's worth going through the list</p>

<a name="135089070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135089070" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135089070">Simon Hudon (Oct 03 2018 at 08:39)</a>:</h4>
<p>I, for one, have not done it and I was working on the basis of "let's add them when we need them" after I added the most obvious ones.</p>

<a name="135089396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135089396" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135089396">Johan Commelin (Oct 03 2018 at 08:46)</a>:</h4>
<p>Can someone give an entry on the list that should <em>not</em> be tagged with the <code>extensionality</code> attribute? If I understand the reason, then I might be able to go through the list myself.</p>

<a name="135089575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135089575" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135089575">Simon Hudon (Oct 03 2018 at 08:50)</a>:</h4>
<p><code>set_theory/zfc.lean:theorem equiv.ext</code></p>

<a name="135089902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135089902" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135089902">Scott Morrison (Oct 03 2018 at 08:58)</a>:</h4>
<p>You missed <code>yoneda.ext</code> :-). (Perhaps because it's a <code>def</code>?)  Anyway, it probably shouldn't have <code>@[extensionality]</code>.</p>

<a name="135089964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135089964" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135089964">Simon Hudon (Oct 03 2018 at 08:59)</a>:</h4>
<p>Also, I wouldn't tag <code>semilattice_sup.ext_sup</code></p>

<a name="135090054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135090054" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135090054">Johan Commelin (Oct 03 2018 at 09:00)</a>:</h4>
<p>Can you explain why?</p>

<a name="135090064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135090064" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135090064">Johan Commelin (Oct 03 2018 at 09:00)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> Indeed, I only looked for lemmas and theorems</p>

<a name="135090608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135090608" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135090608">Simon Hudon (Oct 03 2018 at 09:11)</a>:</h4>
<p>It's a comparison of class instances rather than the objects themselves. It seems like it could produce surprising results</p>

<a name="135090806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135090806" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135090806">Johan Commelin (Oct 03 2018 at 09:15)</a>:</h4>
<p>Ok, I see. <span class="user-mention" data-user-id="110294">@Johannes Hölzl</span> Does it make sense to create an <code>extensionality</code> PR that adds about 40 <code>extensionality</code> attributes?</p>

<a name="135090874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135090874" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135090874">Johannes Hölzl (Oct 03 2018 at 09:16)</a>:</h4>
<p>Do we have 40 types? Are sensible? Also be careful that they don't overlap.</p>

<a name="135090907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135090907" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135090907">Johan Commelin (Oct 03 2018 at 09:17)</a>:</h4>
<p>See the list I posted above.</p>

<a name="135090923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135090923" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135090923">Johan Commelin (Oct 03 2018 at 09:17)</a>:</h4>
<p>Simon mentioned a couple that shouldn't be tagged, but I think a lot of them could reasonably be tagged.</p>

<a name="135091116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135091116" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135091116">Simon Hudon (Oct 03 2018 at 09:21)</a>:</h4>
<p>Some of them are equivalences while <code>ext</code> uses implications. When I encounter such lemma, I rename them <code>ext_iff</code> so that I can add a <code>ext</code> lemma as an implication</p>

<a name="135097606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135097606" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135097606">Johannes Hölzl (Oct 03 2018 at 11:51)</a>:</h4>
<p>also before you add the extensionality lemmas we should change the semantics of <code>ext</code>. Instead of applying all possible extensionality lemmas it should only work along the names given by the user, or accept <code>*</code> to apply all.</p>

<a name="135097698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135097698" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135097698">Johan Commelin (Oct 03 2018 at 11:53)</a>:</h4>
<p>Hmm, ok. Do you mean you want people to write <code>ext set</code> or <code>ext subtype</code> etc...?</p>

<a name="135097745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135097745" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135097745">Simon Hudon (Oct 03 2018 at 11:54)</a>:</h4>
<p>Right now, <code>ext</code> detects the type of the arguments (e.g. set) and only tries relevant extensionality lemmas</p>

<a name="135097758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135097758" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135097758">Simon Hudon (Oct 03 2018 at 11:54)</a>:</h4>
<p>It used to be that functional extensionality might be selected for the equality of two sets. It's no longer the case.</p>

<a name="135097764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135097764" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135097764">Patrick Massot (Oct 03 2018 at 11:54)</a>:</h4>
<p>Johannes, that would be very sad</p>

<a name="135097769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135097769" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135097769">Patrick Massot (Oct 03 2018 at 11:54)</a>:</h4>
<p>I like to type <code>ext</code> and Lean figures out what I mean</p>

<a name="135097780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135097780" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135097780">Johannes Hölzl (Oct 03 2018 at 11:55)</a>:</h4>
<p>and I hate it to add an attribute and half of mathlib breaks</p>

<a name="135097781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135097781" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135097781">Mario Carneiro (Oct 03 2018 at 11:55)</a>:</h4>
<p>Johannes this was implemented recently, like simon says</p>

<a name="135097790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135097790" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135097790">Johannes Hölzl (Oct 03 2018 at 11:55)</a>:</h4>
<p>okay, thats good!</p>

<a name="135097800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135097800" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135097800">Mario Carneiro (Oct 03 2018 at 11:55)</a>:</h4>
<p>You don't need to say <code>ext set</code>, it looks at the type of the objects in the equality in the goal</p>

<a name="135097851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135097851" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135097851">Simon Hudon (Oct 03 2018 at 11:56)</a>:</h4>
<p>It's also tolerant on the kind of relation you can prove but I think sticking close to <code>=</code> is a good idea.</p>

<a name="135097866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135097866" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135097866">Mario Carneiro (Oct 03 2018 at 11:57)</a>:</h4>
<p>But this also means that you essentially want one extensionality lemma for each type, so no multiples, and no equalities over generic types</p>

<a name="135097868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135097868" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135097868">Johan Commelin (Oct 03 2018 at 11:57)</a>:</h4>
<p>Right, but <code>functor.ext</code> seems like a good exception</p>

<a name="135097939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135097939" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135097939">Mario Carneiro (Oct 03 2018 at 11:58)</a>:</h4>
<p>If there are multiple candidates for extensionality, e.g. <code>roption.ext</code> vs <code>roption.ext'</code> then you have to think about which one is better general-purpose and pick one</p>

<a name="135097970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135097970" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135097970">Simon Hudon (Oct 03 2018 at 11:59)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> I'm tempted to agree with you but technically, there's no reason why <code>functor.ext</code> wouldn't work as an extensionality lemma</p>

<a name="135097992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135097992" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135097992">Johan Commelin (Oct 03 2018 at 11:59)</a>:</h4>
<p><span class="user-mention" data-user-id="110026">@Simon Hudon</span> I meant that it is an exception to sticking to <code>=</code></p>

<a name="135097994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135097994" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135097994">Mario Carneiro (Oct 03 2018 at 11:59)</a>:</h4>
<p>Also keep in mind that <code>ext</code> will apply all extensionality lemmas it can all the way down so you don't want loopable hypotheses</p>

<a name="135098052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135098052" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135098052">Simon Hudon (Oct 03 2018 at 12:00)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> You can also give the most general one a lower priority</p>

<a name="135098057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135098057" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135098057">Johan Commelin (Oct 03 2018 at 12:00)</a>:</h4>
<p>Or we want <code>ext</code> to take an optional <code>small_nat</code> argument like <code>congr</code></p>

<a name="135098062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135098062" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135098062">Johan Commelin (Oct 03 2018 at 12:00)</a>:</h4>
<p>Or <code>congr'</code>, whatever</p>

<a name="135098066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135098066" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135098066">Simon Hudon (Oct 03 2018 at 12:00)</a>:</h4>
<p>It already does: <code>ext : 3</code></p>

<a name="135098081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135098081" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135098081">Mario Carneiro (Oct 03 2018 at 12:01)</a>:</h4>
<p>AFAIK competing extensionality lemmas always apply in the same generality, they just have different hypotheses, so giving priority wouldn't help</p>

<a name="135098082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135098082" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135098082">Simon Hudon (Oct 03 2018 at 12:01)</a>:</h4>
<p>But I think Mario is right. There has to be a sense that something decreases as we keep applying <code>ext</code>, for instance the complexity of the objects being compared</p>

<a name="135098144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135098144" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135098144">Simon Hudon (Oct 03 2018 at 12:02)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> I don't understand what you mean by "in the same generality"</p>

<a name="135098185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135098185" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135098185">Mario Carneiro (Oct 03 2018 at 12:04)</a>:</h4>
<p>Most theorems that could qualify as <code>@[extensionality]</code> have a conclusion <code>(a : T) = b</code>, so if this is the goal then all extensionalities for T will apply</p>

<a name="135098270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135098270" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135098270">Mario Carneiro (Oct 03 2018 at 12:05)</a>:</h4>
<p>With other kinds of theorems there might be a difference in generality like if one theorem only has say <code>F a = G b</code> in the conclusion, but with extensionality lemmas it's always <code>a = b</code> where <code>a</code> and <code>b</code> match anything in the type</p>

<a name="135098278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135098278" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135098278">Simon Hudon (Oct 03 2018 at 12:05)</a>:</h4>
<p>You could see one lemma being <code>(a : set α) = b</code> and another be <code>(a : set (list α)) = b</code>. The first one is the most general one although both would be attempted</p>

<a name="135098339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135098339" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135098339">Mario Carneiro (Oct 03 2018 at 12:06)</a>:</h4>
<p>I suppose that is a possibility, but so far I don't think we have any such "composite extensionality lemmas"</p>

<a name="135098348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135098348" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135098348">Mario Carneiro (Oct 03 2018 at 12:06)</a>:</h4>
<p>it's always a constant or type constructor applied to variables</p>

<a name="135098445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135098445" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135098445">Mario Carneiro (Oct 03 2018 at 12:08)</a>:</h4>
<p>Looking at the list, I see <code>free_abelian_group.ext</code> and <code>to_module.ext</code> have composite types, and <code>dioph</code> has something that isn't an extensionality at all</p>

<a name="135098492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135098492" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135098492">Mario Carneiro (Oct 03 2018 at 12:09)</a>:</h4>
<p>I don't think <code>free_abelian_group.ext</code> qualifies as an extensionality, this is some kind of yoneda thing</p>

<a name="135133090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135133090" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135133090">Patrick Massot (Oct 03 2018 at 20:53)</a>:</h4>
<p>what about <code>topological_space_eq</code>?</p>

<a name="135133135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135133135" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html#135133135">Patrick Massot (Oct 03 2018 at 20:54)</a>:</h4>
<p>yes</p>


{% endraw %}
