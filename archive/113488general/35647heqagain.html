---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/35647heqagain.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html">heq again</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="133673026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133673026" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133673026">Reid Barton (Sep 10 2018 at 16:24)</a>:</h4>
<p>Hmm, I wasn't expecting this to work.</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">types_eq_of_heq</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">==</span> <span class="n">b</span><span class="o">),</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">β</span>
<span class="bp">|</span> <span class="n">α</span> <span class="n">a</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="n">heq</span><span class="bp">.</span><span class="n">refl</span> <span class="bp">_</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>

<a name="133673064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133673064" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133673064">Kenny Lau (Sep 10 2018 at 16:25)</a>:</h4>
<p>why not?</p>

<a name="133673078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133673078" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133673078">Kenny Lau (Sep 10 2018 at 16:25)</a>:</h4>
<p>casing on <code>h</code> makes sure that the types are equal and the arguments are equal</p>

<a name="133673143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133673143" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133673143">Reid Barton (Sep 10 2018 at 16:26)</a>:</h4>
<p>Mostly because I haven't seen this fact in core or mathlib, so I guess I assumed it was not provable.</p>

<a name="133673150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133673150" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133673150">Reid Barton (Sep 10 2018 at 16:26)</a>:</h4>
<p>Now I have a followup question about <code>congr</code>.</p>

<a name="133673156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133673156" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133673156">Reid Barton (Sep 10 2018 at 16:26)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span>

<span class="kn">section</span>
<span class="kn">parameters</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">α&#39;</span> <span class="n">β&#39;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">hα</span> <span class="o">:</span> <span class="n">F</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">F</span> <span class="n">α&#39;</span><span class="o">)</span> <span class="o">(</span><span class="n">hβ</span> <span class="o">:</span> <span class="n">F</span> <span class="n">β</span> <span class="bp">=</span> <span class="n">F</span> <span class="n">β&#39;</span><span class="o">)</span>
<span class="kn">parameters</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">F</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">F</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">f&#39;</span> <span class="o">:</span> <span class="n">F</span> <span class="n">α&#39;</span> <span class="bp">→</span> <span class="n">F</span> <span class="n">β&#39;</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">==</span> <span class="n">f&#39;</span><span class="o">)</span>
<span class="n">include</span> <span class="n">hα</span> <span class="n">hβ</span> <span class="n">h</span>

<span class="n">def</span> <span class="n">fns</span> <span class="o">:=</span> <span class="err">Σ&#39;</span> <span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="n">F</span><span class="o">,</span> <span class="n">X</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">→</span> <span class="n">Y</span><span class="bp">.</span><span class="mi">1</span>
<span class="n">def</span> <span class="n">g</span> <span class="o">:</span> <span class="n">fns</span> <span class="o">:=</span> <span class="bp">⟨⟨</span><span class="n">F</span> <span class="n">α</span><span class="o">,</span> <span class="n">α</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">F</span> <span class="n">β</span><span class="o">,</span> <span class="n">β</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">f</span><span class="bp">⟩</span>
<span class="n">def</span> <span class="n">g&#39;</span> <span class="o">:</span> <span class="n">fns</span> <span class="o">:=</span> <span class="bp">⟨⟨</span><span class="n">F</span> <span class="n">α&#39;</span><span class="o">,</span> <span class="n">α&#39;</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">F</span> <span class="n">β&#39;</span><span class="o">,</span> <span class="n">β&#39;</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">f&#39;</span><span class="bp">⟩</span>

<span class="n">def</span> <span class="n">e</span> <span class="o">:</span> <span class="n">g</span> <span class="bp">=</span> <span class="n">g&#39;</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">dsimp</span> <span class="o">[</span><span class="n">g</span><span class="o">,</span> <span class="n">g&#39;</span><span class="o">],</span>
  <span class="c">/-</span><span class="cm"> ⊢ ⟨⟨F α, _⟩, ⟨⟨F β, _⟩, f⟩⟩ = ⟨⟨F α&#39;, _⟩, ⟨⟨F β&#39;, _⟩, f&#39;⟩⟩ -/</span>
  <span class="c">/-</span><span class="cm"> How to proceed? My solution: -/</span>
  <span class="n">congr&#39;</span> <span class="mi">1</span><span class="o">,</span> <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hα</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">congr&#39;</span> <span class="mi">1</span><span class="o">,</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">hα</span> <span class="o">},</span> <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hβ</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">],</span>
<span class="kn">end</span>

<span class="kn">end</span>
</pre></div>

<a name="133673185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133673185" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133673185">Kenny Lau (Sep 10 2018 at 16:27)</a>:</h4>
<p>are you going to livestream?</p>

<a name="133673186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133673186" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133673186">Mario Carneiro (Sep 10 2018 at 16:27)</a>:</h4>
<p><code>type_eq_of_heq</code></p>

<a name="133673196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133673196" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133673196">Reid Barton (Sep 10 2018 at 16:27)</a>:</h4>
<p>I'm annoyed about this <code>{ rw hα }</code> thing. The goal there is</p>
<div class="codehilite"><pre><span></span><span class="err">⊢</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">Y</span> <span class="o">:</span> <span class="o">{</span><span class="n">x</span> <span class="bp">//</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="n">F</span><span class="o">}),</span> <span class="n">F</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">Y</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">Y</span> <span class="o">:</span> <span class="o">{</span><span class="n">x</span> <span class="bp">//</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="n">F</span><span class="o">}),</span> <span class="n">F</span> <span class="n">α&#39;</span> <span class="bp">→</span> <span class="n">Y</span><span class="bp">.</span><span class="n">val</span>
</pre></div>


<p>which I think is trying to say that when I do the second <code>congr'</code>, the types of the two sides are equal.</p>

<a name="133673243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133673243" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133673243">Reid Barton (Sep 10 2018 at 16:28)</a>:</h4>
<p>Wow, my grep skills failed</p>

<a name="133673266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133673266" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133673266">Reid Barton (Sep 10 2018 at 16:29)</a>:</h4>
<p>If I put <code>{ admit }</code> there, the rest of the proof seems to go through fine. So couldn't <code>congr'</code> deduce that the types are equal after the fact, using <code>type_eq_of_heq</code>?</p>

<a name="133673394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133673394" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133673394">Reid Barton (Sep 10 2018 at 16:32)</a>:</h4>
<p>Here's a dumber example.</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span> <span class="bp">==</span> <span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">congr</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p>There are four goals, <code>⊢ α = β</code> twice and <code>⊢ a == b</code> twice. But I can get the former from the latter.</p>

<a name="133673520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133673520" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133673520">Reid Barton (Sep 10 2018 at 16:35)</a>:</h4>
<p>Or a nicer presentation</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">{</span><span class="n">α</span> <span class="n">α&#39;</span> <span class="n">β</span> <span class="n">β&#39;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">a&#39;</span> <span class="o">:</span> <span class="n">α&#39;</span><span class="o">)</span> <span class="o">(</span><span class="n">b&#39;</span> <span class="o">:</span> <span class="n">β&#39;</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="bp">==</span> <span class="o">(</span><span class="n">a&#39;</span><span class="o">,</span> <span class="n">b&#39;</span><span class="o">)</span> <span class="o">:=</span>
</pre></div>

<a name="133673525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133673525" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133673525">Kenny Lau (Sep 10 2018 at 16:36)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span>

<span class="kn">section</span>
<span class="kn">parameters</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">α&#39;</span> <span class="n">β&#39;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">hα</span> <span class="o">:</span> <span class="n">F</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">F</span> <span class="n">α&#39;</span><span class="o">)</span> <span class="o">(</span><span class="n">hβ</span> <span class="o">:</span> <span class="n">F</span> <span class="n">β</span> <span class="bp">=</span> <span class="n">F</span> <span class="n">β&#39;</span><span class="o">)</span>
<span class="kn">parameters</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">F</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">F</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">f&#39;</span> <span class="o">:</span> <span class="n">F</span> <span class="n">α&#39;</span> <span class="bp">→</span> <span class="n">F</span> <span class="n">β&#39;</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">==</span> <span class="n">f&#39;</span><span class="o">)</span>
<span class="n">include</span> <span class="n">hα</span> <span class="n">hβ</span> <span class="n">h</span>

<span class="n">def</span> <span class="n">fns</span> <span class="o">:=</span> <span class="err">Σ&#39;</span> <span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="n">F</span><span class="o">,</span> <span class="n">X</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">→</span> <span class="n">Y</span><span class="bp">.</span><span class="mi">1</span>
<span class="n">def</span> <span class="n">g</span> <span class="o">:</span> <span class="n">fns</span> <span class="o">:=</span> <span class="bp">⟨⟨</span><span class="n">F</span> <span class="n">α</span><span class="o">,</span> <span class="n">α</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">F</span> <span class="n">β</span><span class="o">,</span> <span class="n">β</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">f</span><span class="bp">⟩</span>
<span class="n">def</span> <span class="n">g&#39;</span> <span class="o">:</span> <span class="n">fns</span> <span class="o">:=</span> <span class="bp">⟨⟨</span><span class="n">F</span> <span class="n">α&#39;</span><span class="o">,</span> <span class="n">α&#39;</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">F</span> <span class="n">β&#39;</span><span class="o">,</span> <span class="n">β&#39;</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">f&#39;</span><span class="bp">⟩</span>

<span class="n">def</span> <span class="n">e</span> <span class="o">:</span> <span class="n">g</span> <span class="bp">=</span> <span class="n">g&#39;</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">g</span><span class="o">,</span> <span class="n">g&#39;</span><span class="o">],</span>
  <span class="n">congr</span><span class="bp">;</span> <span class="n">try</span> <span class="o">{</span><span class="n">assumption</span><span class="o">},</span>
  <span class="n">ext</span> <span class="n">Y</span><span class="o">,</span> <span class="n">rw</span> <span class="n">hα</span>
<span class="kn">end</span>

<span class="kn">end</span>
</pre></div>

<a name="133673613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133673613" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133673613">Reid Barton (Sep 10 2018 at 16:37)</a>:</h4>
<p>The <code>ext Y, rw hα</code> part is still there, though. That's the only part I care about because it seems unnecessary.<br>
In my real use case, I have three of them and they are bigger</p>

<a name="133673768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133673768" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133673768">Reid Barton (Sep 10 2018 at 16:41)</a>:</h4>
<p>Does <code>set_option trace.congr_lemma true</code> do anything?</p>

<a name="133673872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133673872" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133673872">Reid Barton (Sep 10 2018 at 16:43)</a>:</h4>
<p>Kenny, I was thinking I would try this evening US eastern time today, maybe a bit late for you</p>

<a name="133674237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133674237" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133674237">Mario Carneiro (Sep 10 2018 at 16:51)</a>:</h4>
<p>That's a pretty messy goal. I would clean it up by hand as follows:</p>
<div class="codehilite"><pre><span></span>begin
  let G := λ A B (f : A → B) h h&#39;, (⟨⟨A, h⟩, ⟨B, h&#39;⟩, f⟩ : fns),
  suffices : ∀ {f f&#39; h₁ h₂ h₃ h₄}, f == f&#39; →
    G (F α) (F β) f h₁ h₂ = G (F α&#39;) (F β&#39;) f&#39; h₃ h₄, exact this h,
  rw [hα, hβ], intros, congr&#39;, apply eq_of_heq a
end
</pre></div>

<a name="133674250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133674250" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133674250">Mario Carneiro (Sep 10 2018 at 16:51)</a>:</h4>
<p>I would avoid having type equalities and heqs in the hypotheses to begin with</p>

<a name="133674301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133674301" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133674301">Mario Carneiro (Sep 10 2018 at 16:52)</a>:</h4>
<p><code>congr</code> is clearly dropping the ball here. There are lots of superfluous goals being generated</p>

<a name="133674319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133674319" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133674319">Mario Carneiro (Sep 10 2018 at 16:53)</a>:</h4>
<p>But usually you don't want to deduce a type equality from a heq; rather you want to assume the type equality and prove a regular equality dependent on it</p>

<a name="133674335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133674335" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133674335">Kenny Lau (Sep 10 2018 at 16:53)</a>:</h4>
<p>is there any way to prove this goal?</p>

<a name="133674338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133674338" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133674338">Kenny Lau (Sep 10 2018 at 16:53)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span>

<span class="kn">section</span>
<span class="kn">parameters</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">α&#39;</span> <span class="n">β&#39;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">hα</span> <span class="o">:</span> <span class="n">F</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">F</span> <span class="n">α&#39;</span><span class="o">)</span> <span class="o">(</span><span class="n">hβ</span> <span class="o">:</span> <span class="n">F</span> <span class="n">β</span> <span class="bp">=</span> <span class="n">F</span> <span class="n">β&#39;</span><span class="o">)</span>
<span class="kn">parameters</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">F</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">F</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">f&#39;</span> <span class="o">:</span> <span class="n">F</span> <span class="n">α&#39;</span> <span class="bp">→</span> <span class="n">F</span> <span class="n">β&#39;</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">==</span> <span class="n">f&#39;</span><span class="o">)</span>
<span class="n">include</span> <span class="n">hα</span> <span class="n">hβ</span> <span class="n">h</span>

<span class="n">def</span> <span class="n">fns</span> <span class="o">:=</span> <span class="err">Σ&#39;</span> <span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="n">F</span><span class="o">,</span> <span class="n">X</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">→</span> <span class="n">Y</span><span class="bp">.</span><span class="mi">1</span>
<span class="n">def</span> <span class="n">g</span> <span class="o">:</span> <span class="n">fns</span> <span class="o">:=</span> <span class="bp">⟨⟨</span><span class="n">F</span> <span class="n">α</span><span class="o">,</span> <span class="n">α</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">F</span> <span class="n">β</span><span class="o">,</span> <span class="n">β</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">f</span><span class="bp">⟩</span>
<span class="n">def</span> <span class="n">g&#39;</span> <span class="o">:</span> <span class="n">fns</span> <span class="o">:=</span> <span class="bp">⟨⟨</span><span class="n">F</span> <span class="n">α&#39;</span><span class="o">,</span> <span class="n">α&#39;</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">F</span> <span class="n">β&#39;</span><span class="o">,</span> <span class="n">β&#39;</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">f&#39;</span><span class="bp">⟩</span>

<span class="kn">set_option</span> <span class="n">pp</span><span class="bp">.</span><span class="n">proofs</span> <span class="n">true</span>
<span class="kn">theorem</span> <span class="n">e</span> <span class="o">:</span> <span class="n">g</span> <span class="bp">=</span> <span class="n">g&#39;</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">fapply</span> <span class="n">psigma</span><span class="bp">.</span><span class="n">eq</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">eq</span> <span class="n">hα</span> <span class="o">},</span>
  <span class="n">fapply</span> <span class="n">psigma</span><span class="bp">.</span><span class="n">eq</span><span class="o">,</span>
  <span class="o">{</span> <span class="c">/-</span><span class="cm"> (eq.rec_on (subtype.eq hα) (g.snd)).fst = (g&#39;.snd).fst -/</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="kn">end</span>
</pre></div>

<a name="133674402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133674402" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133674402">Reid Barton (Sep 10 2018 at 16:54)</a>:</h4>
<p>Well how about the following modification to <code>congr</code>. After each single layer of <code>congr</code>, try filling each of the new goals by applying <code>exact type_eq_of_heq ?m_i</code> where <code>?m_i</code> is the metavariable of each other goal.</p>

<a name="133674429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133674429" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133674429">Mario Carneiro (Sep 10 2018 at 16:55)</a>:</h4>
<p>That's not what you want though. You will have to deduce those type equalities anyway in order to prove the heq</p>

<a name="133674434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133674434" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133674434">Reid Barton (Sep 10 2018 at 16:55)</a>:</h4>
<p>But I didn't!</p>

<a name="133674447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133674447" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133674447">Reid Barton (Sep 10 2018 at 16:56)</a>:</h4>
<p>I happen to have the heq lying around, and where I proved it, the type equalities were obvious</p>

<a name="133674498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133674498" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133674498">Mario Carneiro (Sep 10 2018 at 16:56)</a>:</h4>
<p>You satisfied the type equality proof by <code>assumption</code></p>

<a name="133674522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133674522" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133674522">Reid Barton (Sep 10 2018 at 16:57)</a>:</h4>
<p>Which type equality proof?</p>

<a name="133674533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133674533" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133674533">Mario Carneiro (Sep 10 2018 at 16:57)</a>:</h4>
<p><code>hα</code></p>

<a name="133674581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133674581" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133674581">Mario Carneiro (Sep 10 2018 at 16:58)</a>:</h4>
<p>and <code>hβ</code> later in the proof</p>

<a name="133674591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133674591" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133674591">Reid Barton (Sep 10 2018 at 16:58)</a>:</h4>
<p>Right, but then there is an inner proof obligation I have to take care of, the one I solve using <code>{ rw hα }</code></p>

<a name="133674615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133674615" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133674615">Reid Barton (Sep 10 2018 at 16:59)</a>:</h4>
<p>Let me put up my real code</p>

<a name="133674626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133674626" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133674626">Mario Carneiro (Sep 10 2018 at 16:59)</a>:</h4>
<p>you have to solve that anyway</p>

<a name="133674682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133674682" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133674682">Reid Barton (Sep 10 2018 at 17:00)</a>:</h4>
<p>No, it follows from being able to solve the rest of the goals</p>

<a name="133674706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133674706" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133674706">Mario Carneiro (Sep 10 2018 at 17:00)</a>:</h4>
<p>how?</p>

<a name="133674714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133674714" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133674714">Reid Barton (Sep 10 2018 at 17:00)</a>:</h4>
<p>By <code>type_eq_of_heq</code>. Right?</p>

<a name="133674717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133674717" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133674717">Mario Carneiro (Sep 10 2018 at 17:00)</a>:</h4>
<p>applied to what?</p>

<a name="133674730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133674730" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133674730">Reid Barton (Sep 10 2018 at 17:01)</a>:</h4>
<p>Isn't it the same thing as this?</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">{</span><span class="n">α</span> <span class="n">α&#39;</span> <span class="n">β</span> <span class="n">β&#39;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">a&#39;</span> <span class="o">:</span> <span class="n">α&#39;</span><span class="o">)</span> <span class="o">(</span><span class="n">b&#39;</span> <span class="o">:</span> <span class="n">β&#39;</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">==</span> <span class="n">a&#39;</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">==</span> <span class="n">b&#39;</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="bp">==</span> <span class="o">(</span><span class="n">a&#39;</span><span class="o">,</span> <span class="n">b&#39;</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">congr</span><span class="o">,</span> <span class="o">{</span> <span class="n">exact</span> <span class="n">type_eq_of_heq</span> <span class="n">ha</span> <span class="o">},</span> <span class="o">{</span> <span class="n">exact</span> <span class="n">type_eq_of_heq</span> <span class="n">hb</span> <span class="o">},</span> <span class="o">{</span> <span class="n">exact</span> <span class="n">ha</span> <span class="o">},</span> <span class="o">{</span> <span class="n">exact</span> <span class="n">hb</span> <span class="o">}</span>
<span class="kn">end</span>
</pre></div>

<a name="133674845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133674845" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133674845">Mario Carneiro (Sep 10 2018 at 17:03)</a>:</h4>
<p>sure, but this is an unrealistic goal. Where are you going to get those heqs without a type equality?</p>

<a name="133674859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133674859" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133674859">Reid Barton (Sep 10 2018 at 17:03)</a>:</h4>
<p>so in my real code it happens here <a href="https://gist.github.com/rwbarton/dfb90b2552f09b51798bb52af9948d48#file-filtered-lean-L249" target="_blank" title="https://gist.github.com/rwbarton/dfb90b2552f09b51798bb52af9948d48#file-filtered-lean-L249">https://gist.github.com/rwbarton/dfb90b2552f09b51798bb52af9948d48#file-filtered-lean-L249</a></p>

<a name="133674928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133674928" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133674928">Reid Barton (Sep 10 2018 at 17:05)</a>:</h4>
<p>S is the image of a functor F : I -&gt; C considered as a subgraph, defined here <a href="https://gist.github.com/rwbarton/dfb90b2552f09b51798bb52af9948d48#file-filtered-lean-L87" target="_blank" title="https://gist.github.com/rwbarton/dfb90b2552f09b51798bb52af9948d48#file-filtered-lean-L87">https://gist.github.com/rwbarton/dfb90b2552f09b51798bb52af9948d48#file-filtered-lean-L87</a></p>

<a name="133675006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133675006" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133675006">Mario Carneiro (Sep 10 2018 at 17:07)</a>:</h4>
<p>can you MWE the state just before the <code>rintro</code>?</p>

<a name="133675033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133675033" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133675033">Mario Carneiro (Sep 10 2018 at 17:07)</a>:</h4>
<p>or maybe just after</p>

<a name="133675129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133675129" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133675129">Reid Barton (Sep 10 2018 at 17:09)</a>:</h4>
<p>It should be more or less what I pasted originally.<br>
Note <code>hg : functor.map F ((⟨i', ⟨j', g⟩⟩.snd).snd) == f</code>, which came from the definition of <code>S</code></p>

<a name="133675183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133675183" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133675183">Reid Barton (Sep 10 2018 at 17:10)</a>:</h4>
<p>Corresponding to my original <code>(h : f == f')</code></p>

<a name="133675193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133675193" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133675193">Mario Carneiro (Sep 10 2018 at 17:10)</a>:</h4>
<p>I want to catch the state before the type equalities enter the context</p>

<a name="133675269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133675269" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133675269">Reid Barton (Sep 10 2018 at 17:12)</a>:</h4>
<p>Ah, so you mean <code>hi', hj'</code></p>

<a name="133675288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133675288" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133675288">Mario Carneiro (Sep 10 2018 at 17:12)</a>:</h4>
<p>ideally you should be able to match on <code>hi', hj', hg</code> and save all the mess</p>

<a name="133675304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133675304" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133675304">Mario Carneiro (Sep 10 2018 at 17:13)</a>:</h4>
<p>don't match on <code>⟨X, i, rfl⟩, ⟨Y, j, rfl⟩</code>, just do <code>⟨X, _⟩, ⟨Y, _⟩</code></p>

<a name="133675399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133675399" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133675399">Reid Barton (Sep 10 2018 at 17:15)</a>:</h4>
<p>Hmm, I will try that</p>

<a name="133675614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133675614" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133675614">Reid Barton (Sep 10 2018 at 17:19)</a>:</h4>
<p>Meanwhile I updated the gist with a version which is not M, but should be a WE</p>

<a name="133675723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133675723" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133675723">Reid Barton (Sep 10 2018 at 17:21)</a>:</h4>
<p>Oh, there is a trick in <code>F ijg.1 = X ∧ F ijg.2.1 = Y ∧ ...</code>. That is not just <code>X</code>, but <code>X.val</code></p>

<a name="133675726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133675726" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133675726">Reid Barton (Sep 10 2018 at 17:21)</a>:</h4>
<p>because of my representation of a subgraph, which I now infinitely regret</p>

<a name="133675824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133675824" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133675824">Reid Barton (Sep 10 2018 at 17:23)</a>:</h4>
<p>I have a subgraph as (1) a subset of the vertices, (2) for each pair of vertices in that set (as a subtype), a subset of the edges between them</p>

<a name="133675941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133675941" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133675941">Mario Carneiro (Sep 10 2018 at 17:25)</a>:</h4>
<p>works for me:</p>
<div class="codehilite"><pre><span></span>    rintro ⟨⟨X, _⟩, ⟨Y, _⟩, ⟨f, ⟨i, j, g⟩, ⟨⟩, ⟨⟩, ⟨⟩⟩⟩,
    exact ⟨⟨i, j, g⟩, rfl⟩,
</pre></div>

<a name="133676015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133676015" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133676015">Mario Carneiro (Sep 10 2018 at 17:26)</a>:</h4>
<p>using <code>rfl</code> instead of <code>⟨⟩</code> calls <code>subst</code> instead of <code>cases</code>, and <code>subst</code> is not sufficiently aggressive wrt definitionally unfolding one side to a variable</p>

<a name="133676023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133676023" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133676023">Reid Barton (Sep 10 2018 at 17:27)</a>:</h4>
<p>Ahh</p>

<a name="133676103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133676103" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133676103">Mario Carneiro (Sep 10 2018 at 17:28)</a>:</h4>
<p>I would suggest, if you are okay with the added verbosity, that you use an inductive type to define your hom sets instead of ands of eqs and heqs</p>

<a name="133676111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133676111" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133676111">Reid Barton (Sep 10 2018 at 17:28)</a>:</h4>
<p>I see</p>
<div class="codehilite"><pre><span></span><span class="n">rfl</span> <span class="o">:</span> <span class="err">⇑</span><span class="n">F</span> <span class="o">(</span><span class="bp">⟨</span><span class="n">i&#39;</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">j&#39;</span><span class="o">,</span> <span class="n">g</span><span class="bp">⟩⟩.</span><span class="n">fst</span><span class="o">)</span> <span class="bp">=</span> <span class="err">↑</span><span class="bp">⟨</span><span class="n">X</span><span class="o">,</span> <span class="n">b_fst_property</span><span class="bp">⟩</span><span class="o">,</span>
</pre></div>

<a name="133676128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133676128" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133676128">Mario Carneiro (Sep 10 2018 at 17:29)</a>:</h4>
<p>it names the variable <code>rfl</code> before substing, I think</p>

<a name="133676134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133676134" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133676134">Reid Barton (Sep 10 2018 at 17:29)</a>:</h4>
<p>Looks that way.</p>

<a name="133676219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133676219" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133676219">Reid Barton (Sep 10 2018 at 17:30)</a>:</h4>
<p>that's a whole lot better, thanks!</p>

<a name="133676236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133676236" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133676236">Reid Barton (Sep 10 2018 at 17:30)</a>:</h4>
<p>You mean, in the definition of S?</p>

<a name="133676240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133676240" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133676240">Mario Carneiro (Sep 10 2018 at 17:30)</a>:</h4>
<p>yes</p>

<a name="133676274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133676274" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133676274">Mario Carneiro (Sep 10 2018 at 17:31)</a>:</h4>
<p>it's up to you, you can use tricks like this to match on it either way</p>

<a name="133676290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133676290" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133676290">Reid Barton (Sep 10 2018 at 17:31)</a>:</h4>
<p>oh, I could replace the whole <code>λ X Y, {f | ∃ (ijg : Σ (i j : I), i ⟶ j), F ijg.1 = X ∧ F ijg.2.1 = Y ∧ F.map ijg.2.2 == f}</code> with an inductive type I guess</p>

<a name="133676299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133676299" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133676299">Mario Carneiro (Sep 10 2018 at 17:31)</a>:</h4>
<p>right</p>

<a name="133676371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133676371" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133676371">Mario Carneiro (Sep 10 2018 at 17:32)</a>:</h4>
<p>it would give nicer equations, but if this is a one-off it's probably not worth it</p>

<a name="133676380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133676380" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133676380">Reid Barton (Sep 10 2018 at 17:32)</a>:</h4>
<p>and elsewhere I have similar constructions, like the union of a family of subgraphs</p>

<a name="133676387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133676387" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133676387">Reid Barton (Sep 10 2018 at 17:33)</a>:</h4>
<p>Yeah, I'm not sure I will need any of these constructions more than once, inside the associated proof</p>

<a name="133676399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133676399" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133676399">Reid Barton (Sep 10 2018 at 17:33)</a>:</h4>
<p>But a good technique to keep in mind</p>

<a name="133676456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133676456" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133676456">Mario Carneiro (Sep 10 2018 at 17:34)</a>:</h4>
<p>oh, looks like you don't even need to match on <code>ijg</code> in that proof</p>

<a name="133676522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133676522" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133676522">Reid Barton (Sep 10 2018 at 17:35)</a>:</h4>
<p>Yep</p>

<a name="133676543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133676543" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133676543">Reid Barton (Sep 10 2018 at 17:35)</a>:</h4>
<p>I think I know what happened here</p>

<a name="133676558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133676558" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133676558">Reid Barton (Sep 10 2018 at 17:35)</a>:</h4>
<p>I started without the <code>F ijg.1 = X ∧ F ijg.2.1 = Y ∧ </code> part</p>

<a name="133676605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133676605" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133676605">Reid Barton (Sep 10 2018 at 17:36)</a>:</h4>
<p>in the definition of S. And then I realized that wasn't going to work</p>

<a name="133676623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133676623" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133676623">Reid Barton (Sep 10 2018 at 17:36)</a>:</h4>
<p>but I think I had already written the <code>⟨X, i, rfl⟩, ⟨Y, j, rfl⟩</code> patterns</p>

<a name="133676760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133676760" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133676760">Mario Carneiro (Sep 10 2018 at 17:39)</a>:</h4>
<p>yeah, of course you can't deduce <code>X = X'</code> and <code>Y = Y'</code> from <code>X ⟶ Y = X' ⟶ Y'</code></p>

<a name="133676778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133676778" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133676778">Mario Carneiro (Sep 10 2018 at 17:39)</a>:</h4>
<p>not for function types and definitely not for homsets</p>

<a name="133676917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133676917" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133676917">Reid Barton (Sep 10 2018 at 17:41)</a>:</h4>
<p>Although it curiously would not even matter for the cardinality estimate I need to do here, because it would blow things up by a factor of less than <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span></p>

<a name="133676941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133676941" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133676941">Reid Barton (Sep 10 2018 at 17:41)</a>:</h4>
<p>But anyways, that's when I started to wonder: would it be better to just define the edges as <code>(mors : set (Σ X Y, X ⟶ Y))</code></p>

<a name="133677178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133677178" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133677178">Mario Carneiro (Sep 10 2018 at 17:45)</a>:</h4>
<p>I'm inclined to say no, although possibly you might want <code>homs</code> to be defined on all objects, not just those in the subset</p>

<a name="133677188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133677188" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133677188">Mario Carneiro (Sep 10 2018 at 17:45)</a>:</h4>
<p>and just require that it be empty outside the subset</p>

<a name="133677264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133677264" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133677264">Mario Carneiro (Sep 10 2018 at 17:46)</a>:</h4>
<div class="codehilite"><pre><span></span>structure subgraph (C : Type u) [small_category C] : Type u :=
(objs : set C)
(homs : Π X Y : C, set (X ⟶ Y))
(dom_mem : Π X Y f, f ∈ homs X Y → X ∈ objs)
(cod_mem : Π X Y f, f ∈ homs X Y → Y ∈ objs)
</pre></div>

<a name="133677305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133677305" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133677305">Reid Barton (Sep 10 2018 at 17:47)</a>:</h4>
<p>Right, I would need those last two fields anyways. Just a difference between <code>set (Σ X Y, X ⟶ Y)</code> and <code>Π X Y : C, set (X ⟶ Y)</code></p>

<a name="133677362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133677362" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133677362">Mario Carneiro (Sep 10 2018 at 17:48)</a>:</h4>
<p>having a big sigma will make things more complicated with heqs and stuff as you've seen</p>

<a name="133677367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133677367" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133677367">Reid Barton (Sep 10 2018 at 17:48)</a>:</h4>
<p>Given that some of the things I do are look at the cardinality of the set of edges, and form the union of subgraphs</p>

<a name="133677381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133677381" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133677381">Reid Barton (Sep 10 2018 at 17:48)</a>:</h4>
<p>but I guess those are not significantly harder with the Pi approach</p>

<a name="133677396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq%20again/near/133677396" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35647heqagain.html#133677396">Mario Carneiro (Sep 10 2018 at 17:48)</a>:</h4>
<p>I think <code>arrows := Σ X Y, X ⟶ Y</code> is a useful definition in a category though</p>


{% endraw %}

{% include archive_update.html %}