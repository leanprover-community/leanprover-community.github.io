---
layout: archive
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/96988abrfl.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html">`a = b := rfl`</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="131994333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131994333" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131994333">Kevin Buzzard (Aug 12 2018 at 11:48)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">definition</span> <span class="n">xena</span><span class="bp">.</span><span class="n">zero</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="mi">0</span>

<span class="kn">theorem</span> <span class="n">easy</span> <span class="o">:</span> <span class="n">xena</span><span class="bp">.</span><span class="n">zero</span> <span class="bp">=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>


<p>I usually stop thinking when it's got to this point -- my zeros are equal by definition and we're done. Yesterday, perhaps inspired by Ed's barrage, which reminded me how little I still knew about some aspects of Lean, I decided to dig a bit deeper into this easy theorem. I tried to take it apart completely given what I knew.</p>
<p>Setting <code>pp.all true</code> shows me that my goal is</p>
<div class="codehilite"><pre><span></span>@eq.{1} nat xena.zero nat.zero
</pre></div>


<p>which is fine. My first question is how <code>rfl</code> is proving this. I'm assuming that the output of <code>#print rfl</code> is the code that's being run here. </p>
<div class="codehilite"><pre><span></span>@[pattern]
def rfl : ∀ {α : Sort u} {a : α}, @eq.{u} α a a :=
λ {α : Sort u} {a : α}, @eq.refl.{u} α a
</pre></div>


<p>I have some things to solve here. I will set <code>u=1</code> for the universe, and now for the <code>{}</code> brackets I need to solve for <code>α</code> and <code>a</code>. Well <code>α</code> is easy, it's <code>nat</code>, but for <code>a</code> I seem to have two choices. <code>a = xena.zero</code> and <code>a=nat.zero</code> and neither of them are on the face of it right. One seems to create a term of type <code>@eq.{1} nat xena.zero xena.zero</code> and the other a term of type <code>@eq.{1} nat nat.zero nat.zero</code>. </p>
<p>Whichever one Lean chooses, it -- by which I mean <em>something</em> -- is now faced with the problem that I am claiming that two types are equal when they are not literally the same thing. The same what? The same expressions? </p>
<p>Proving that these two types are equal (<code>@eq.{1} nat xena.zero nat.zero</code> and <code>@eq.{1} nat a a</code> for whatever <code>rfl</code> decided to let <code>a</code> be -- how do I find out, by the way?) seems to be a case of proving <code>xena.zero</code> and <code>nat.zero</code> are the same term of type <code>nat</code>. So Lean has somehow now reduced to checking that these terms are the same. But the expressions (if they are expressions) are presumably different. </p>
<p>What presumably happens next is that Lean has to try and check that both terms evaluate to the same term of type <code>nat</code>. Now <code>nat.zero</code> seems like it's somehow "fully evaluated" -- <code>#print nat.zero</code> indicates that it's a constructor of <code>nat</code> and we somehow can't get any further. On the other hand, <code>#print xena.zero</code> seems to indicate that more work needs to be done. The parser, or something, has interpreted <code>0 : nat</code> as <code>@has_zero.zero.{0} nat nat.has_zero</code>. I can't quite work out how -- <code>0</code> does not seem to be notation. I think Mario once told me that it was the "number literal parser" which changes <code>0</code> to <code>@has_zero.zero.{0} nat nat.has_zero</code>. So...<em>something</em> is now faced with the of verifying that <code>@has_zero.zero.{0} nat nat.has_zero</code> evaluates to <code>nat.zero</code>. I can understand that <code>nat.has_zero</code> has magically appeared because the type class inference system produced it, and looking at the definition of <code>has_zero.zero</code> I can see that this term evaluates to <code>nat.has_zero.zero</code>. This is a funny...term? expr? because I can't <code>#print</code> it even though I can <code>#check</code> it. I can <code>#reduce</code> it but I feel like this might be cheating -- I can <code>#reduce xena.zero</code> and everything gets unravelled. What is <code>#reduce</code> doing here? Is this all the alpha-equivalence beta-reduction stuff? </p>
<p>Feeling like <code>#reduce nat.has_zero.zero</code> was cheating, I right-clicked on it -- I don't know any other way of seeing the definition, because <code>#print</code> doesn't work and <code>#reduce</code> does too much. Is there a way to investivate more carefully what type class inference did here? Right-clicking takes me to core Lean where I find <code>instance : has_zero nat := ⟨nat.zero⟩</code>, so indeed it was <code>nat.zero</code> after all.</p>
<p>Whose job am I doing here? What does all this have to do with <code>expr</code>s and <code>pexpr</code>s?</p>

<a name="131994536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131994536" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131994536">Mario Carneiro (Aug 12 2018 at 11:57)</a>:</h4>
<p>You are doing the job of the kernel here, which is unfortunately not so verbose when it does things</p>

<a name="131994590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131994590" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131994590">Mario Carneiro (Aug 12 2018 at 11:59)</a>:</h4>
<blockquote>
<p>for whatever rfl decided to let a be -- how do I find out, by the way?</p>
</blockquote>
<p>If you <code>#print easy</code> with <code>pp.all</code> you will see <code>@rfl.{1} nat xena.zero</code>, so rfl chose the LHS, forcing it to check <code>@eq.{1} nat xena.zero xena.zero =?= @eq.{1} nat xena.zero nat.zero</code>.</p>

<a name="131994704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131994704" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131994704">Kevin Buzzard (Aug 12 2018 at 12:03)</a>:</h4>
<p>I've seen you write <code>=?=</code> many times here, and I still don't know what it means. I understand that the job Lean has to somehow do is to check LHS = RHS. What does <code>=?=</code> indicate though?</p>

<a name="131994706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131994706" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131994706">Mario Carneiro (Aug 12 2018 at 12:03)</a>:</h4>
<p>It is a defeq "goal"</p>

<a name="131994709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131994709" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131994709">Kenny Lau (Aug 12 2018 at 12:03)</a>:</h4>
<p>so a sort of unification, I guess</p>

<a name="131994748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131994748" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131994748">Kevin Buzzard (Aug 12 2018 at 12:04)</a>:</h4>
<p>And what thing solves this goal? The kernel? Can we be more precise? Is it anything to do with the unifier or elaborator or something?</p>

<a name="131994751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131994751" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131994751">Mario Carneiro (Aug 12 2018 at 12:04)</a>:</h4>
<p>yes, it is used in unification and also pure defeq checking</p>

<a name="131994758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131994758" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131994758">Mario Carneiro (Aug 12 2018 at 12:04)</a>:</h4>
<p>the elaborator also solves this problem (both the kernel and the elaborator have slightly different approaches to solving defeq problems)</p>

<a name="131994760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131994760" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131994760">Kevin Buzzard (Aug 12 2018 at 12:05)</a>:</h4>
<p>Right, I think I've also seen it in the context <code>?m_1 =?= nat</code> with metavariables. That's the same usage?</p>

<a name="131994771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131994771" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131994771">Mario Carneiro (Aug 12 2018 at 12:05)</a>:</h4>
<p>yes</p>

<a name="131994773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131994773" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131994773">Kevin Buzzard (Aug 12 2018 at 12:05)</a>:</h4>
<p>So at any stage in time, does Lean have a list of <code>A =?= B</code> goals?</p>

<a name="131994827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131994827" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131994827">Mario Carneiro (Aug 12 2018 at 12:07)</a>:</h4>
<p>somewhere deep in the kernel, yes, more or less, although that list is spread over the recursive calls to <code>is_def_eq</code> rather than explicitly maintained</p>

<a name="131994964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131994964" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131994964">Kevin Buzzard (Aug 12 2018 at 12:11)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="c">/-</span><span class="cm">- Succeeds if `t` and `s` can be unified using the given transparency setting. -/</span>
<span class="n">meta</span> <span class="kn">constant</span> <span class="n">unify</span> <span class="o">(</span><span class="n">t</span> <span class="n">s</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">(</span><span class="n">md</span> <span class="o">:=</span> <span class="n">semireducible</span><span class="o">)</span> <span class="o">(</span><span class="n">approx</span> <span class="o">:=</span> <span class="n">ff</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span>
<span class="c">/-</span><span class="cm">- Similar to `unify`, but it treats metavariables as constants. -/</span>
<span class="n">meta</span> <span class="kn">constant</span> <span class="n">is_def_eq</span> <span class="o">(</span><span class="n">t</span> <span class="n">s</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">(</span><span class="n">md</span> <span class="o">:=</span> <span class="n">semireducible</span><span class="o">)</span> <span class="o">(</span><span class="n">approx</span> <span class="o">:=</span> <span class="n">ff</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span>
</pre></div>


<p>The fact that these are constants somehow indicates that they are not written in Lean but perhaps in C++. How does Lean know that these are any different to <code>meta constant foo : nat</code> ? And what told Lean to use <code>is_def_eq</code>? Again is this something written in <code>C++</code>? I don't want to read any <code>C++</code> at this point, but I'd like to be able to get as far as it (hence at some point I'm going to have to read some tactic code, but not today)</p>

<a name="131995011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995011" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131995011">Mario Carneiro (Aug 12 2018 at 12:12)</a>:</h4>
<p>Here's the process for checking defeq:</p>
<ul>
<li>Since <code>eq</code> is an axiomatic constant, it can't be unfolded, so it checks that the parts are equal, reducing to <code>xena.zero =?= nat.zero</code>.</li>
<li>Since <code>xena.zero</code> has greater definitional height, and <code>nat.zero</code> is a constant anyway, it unfolds <code>xena.zero := @has_zero.zero.{0} nat nat.has_zero</code>.</li>
<li><code>has_zero.zero</code> is a builtin projection, which I'm not sure how lean handles - if it is unfolded you see a macro for the projection and it's tricky to unfold these. For now let's just pretend that this term is an axiomatic constant.</li>
<li>Since <code>has_zero.zero</code> is a projection, it tries to reduce the major premise, which is <code>nat.has_zero</code>.</li>
<li>Since <code>nat.has_zero</code> is a definition, it is unfolded, to <code>@has_zero.mk.{0} nat nat.zero</code>.</li>
<li>Since <code>has_zero.mk</code> is a constructor, unfolding stops.</li>
<li>Now we have <code>@has_zero.zero.{0} nat (@has_zero.mk.{0} nat nat.zero)</code>, which is a projection applied to a constructor, so it iota reduces to <code>nat.zero</code>.</li>
<li>We now have to show <code>nat.zero =?= nat.zero</code>, so we are done.</li>
</ul>

<a name="131995021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995021" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131995021">Mario Carneiro (Aug 12 2018 at 12:13)</a>:</h4>
<p>Those constants are written in C++; they hook into the elaborator code for defeq and unification</p>

<a name="131995076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995076" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131995076">Mario Carneiro (Aug 12 2018 at 12:15)</a>:</h4>
<p>They are not any different from other meta constants, but when you <code>#eval</code> a meta constant it checks if it has builtin code for the constant</p>
<div class="codehilite"><pre><span></span>meta constant foo : nat
#eval foo
-- code generation failed, VM does not have code for &#39;foo&#39;
#eval (undefined : nat)
-- undefined
</pre></div>

<a name="131995164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995164" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131995164">Mario Carneiro (Aug 12 2018 at 12:17)</a>:</h4>
<p>the <code>DECLARE_VM_BUILTIN</code> function in C++ hooks a C++ function to a meta constant by name, so if you want to find out what function handles <code>unify</code>, say, you can just look for this in the code</p>

<a name="131995218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995218" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131995218">Kevin Buzzard (Aug 12 2018 at 12:18)</a>:</h4>
<p>Is there a formal definition of "axiomatic constant"? I thought <code>eq</code> was a Pi type and <code>nat.zero</code> was a constructor. They're also both constants somehow?</p>

<a name="131995229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995229" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131995229">Mario Carneiro (Aug 12 2018 at 12:19)</a>:</h4>
<p><code>eq</code> has <em>type</em> <code>Π {α : Sort u}, α → α → Prop</code> but it has no <em>definition</em></p>

<a name="131995283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995283" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131995283">Mario Carneiro (Aug 12 2018 at 12:20)</a>:</h4>
<p>similarly <code>nat.zero : nat</code> but <code>nat.zero :=</code> nothing</p>

<a name="131995306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995306" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131995306">Mario Carneiro (Aug 12 2018 at 12:21)</a>:</h4>
<p>yes there is a formal definition. These are both constants introduced through the declaration of an inductive type. If you recall each inductive type comes axiomatically with a type (being declared), a list of constructors, and a recursor</p>

<a name="131995321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995321" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131995321">Kevin Buzzard (Aug 12 2018 at 12:21)</a>:</h4>
<p>Yes, inductive types I'm completely happy with.</p>

<a name="131995326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995326" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131995326">Kevin Buzzard (Aug 12 2018 at 12:22)</a>:</h4>
<p>I see. <code>#print eq</code> and <code>#print nat.zero</code> both return answers with no <code>:=</code> in</p>

<a name="131995369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995369" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131995369">Mario Carneiro (Aug 12 2018 at 12:22)</a>:</h4>
<p>the important part is that this is a way to introduce constants that have no definition</p>

<a name="131995373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995373" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131995373">Mario Carneiro (Aug 12 2018 at 12:22)</a>:</h4>
<p>all constants are either axiomatic from an inductive, declared via <code>axiom</code> or <code>constant</code>, or are definitions</p>

<a name="131995382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995382" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131995382">Mario Carneiro (Aug 12 2018 at 12:23)</a>:</h4>
<p>or are <code>quot</code>, <code>quot.mk</code>, <code>quot.lift</code> or <code>quot.sound</code> which are special</p>

<a name="131995385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995385" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131995385">Kevin Buzzard (Aug 12 2018 at 12:23)</a>:</h4>
<p>So the type, the constructors and the recursor for an inductive type are all constants?</p>

<a name="131995389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995389" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131995389">Mario Carneiro (Aug 12 2018 at 12:23)</a>:</h4>
<p>yes</p>

<a name="131995442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995442" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131995442">Mario Carneiro (Aug 12 2018 at 12:24)</a>:</h4>
<p>Above I pretended that the projection of a structure is also a constant, but I'm not sure if lean unfolds that too</p>

<a name="131995451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995451" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131995451">Kevin Buzzard (Aug 12 2018 at 12:24)</a>:</h4>
<p>I'm happy with the explanation that "it's iota reduction"</p>

<a name="131995462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995462" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131995462">Mario Carneiro (Aug 12 2018 at 12:25)</a>:</h4>
<p>technically the projections are defined in terms of the recursor, with a major premise like <code>(\lam x y z, y)</code>, and it's an iota reduction and some betas to get to where I said</p>

<a name="131995505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995505" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131995505">Kevin Buzzard (Aug 12 2018 at 12:26)</a>:</h4>
<p><code>#print has_zero.zero</code> seems to give out some sort of junk answer -- it has no content somehow</p>

<a name="131995507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995507" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131995507">Mario Carneiro (Aug 12 2018 at 12:26)</a>:</h4>
<p><code>has_zero.zero</code> is apparently defined in terms of a macro, also called <code>has_zero.zero</code></p>

<a name="131995517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995517" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131995517">Kevin Buzzard (Aug 12 2018 at 12:27)</a>:</h4>
<p>Oh so that's a different <code>has_zero.zero</code> in the output?</p>

<a name="131995518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995518" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131995518">Kenny Lau (Aug 12 2018 at 12:27)</a>:</h4>
<p>so basically <code>eq</code> is a constant and <code>eq a a</code> for every <code>a</code> is an axiom</p>

<a name="131995557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995557" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131995557">Kevin Buzzard (Aug 12 2018 at 12:28)</a>:</h4>
<p><code>eq a a</code> is a proposition and I know a way of constructing a term of that type</p>

<a name="131995559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995559" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131995559">Kenny Lau (Aug 12 2018 at 12:29)</a>:</h4>
<p>ok</p>

<a name="131995739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995739" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131995739">Mario Carneiro (Aug 12 2018 at 12:35)</a>:</h4>
<p>ah, unfolding success</p>
<div class="codehilite"><pre><span></span><span class="kn">open</span> <span class="n">tactic</span>
<span class="n">run_cmd</span> <span class="n">do</span>
  <span class="n">d</span> <span class="err">←</span> <span class="n">get_decl</span> <span class="bp">``</span><span class="n">has_zero</span><span class="bp">.</span><span class="n">zero</span><span class="o">,</span>
  <span class="n">expr</span><span class="bp">.</span><span class="n">lam</span> <span class="n">n</span> <span class="n">u</span> <span class="n">bi</span> <span class="n">v</span> <span class="err">←</span> <span class="n">return</span> <span class="n">d</span><span class="bp">.</span><span class="n">value</span><span class="o">,</span>
  <span class="n">x</span> <span class="err">←</span> <span class="n">mk_local&#39;</span> <span class="n">n</span> <span class="n">u</span> <span class="n">bi</span><span class="o">,</span>
  <span class="n">expr</span><span class="bp">.</span><span class="n">lam</span> <span class="n">n</span> <span class="n">u</span> <span class="n">bi</span> <span class="n">v</span> <span class="err">←</span> <span class="n">return</span> <span class="o">(</span><span class="n">v</span><span class="bp">.</span><span class="n">instantiate_var</span> <span class="n">x</span><span class="o">),</span>
  <span class="n">c</span> <span class="err">←</span> <span class="n">mk_local&#39;</span> <span class="n">n</span> <span class="n">u</span> <span class="n">bi</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">v</span> <span class="o">:=</span> <span class="n">v</span><span class="bp">.</span><span class="n">instantiate_var</span> <span class="n">c</span><span class="o">,</span>
  <span class="n">trace</span> <span class="n">v</span><span class="o">,</span>
  <span class="c1">-- [has_zero.zero c]</span>
  <span class="n">whnf</span> <span class="n">v</span> <span class="bp">&gt;&gt;=</span> <span class="n">trace</span>
<span class="c1">-- @has_zero.rec.{u+1 u} α (λ [c : has_zero.{u} α], α) (λ (zero : α), zero) c</span>
</pre></div>

<a name="131995789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995789" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131995789">Mario Carneiro (Aug 12 2018 at 12:36)</a>:</h4>
<p>I am sure there is a function for opening the lambdas there at the beginning, but I've forgotten what it is</p>

<a name="131996289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131996289" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131996289">Kevin Buzzard (Aug 12 2018 at 12:54)</a>:</h4>
<p>Aah this is what I want to see. I have an underlying question really, which is basically how I can do all the unfolding which I did "on paper" above, but step by step, within Lean.</p>

<a name="131996368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131996368" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131996368">Mario Carneiro (Aug 12 2018 at 12:57)</a>:</h4>
<p>the key step there is <code>whnf</code></p>

<a name="131996373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131996373" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131996373">Mario Carneiro (Aug 12 2018 at 12:57)</a>:</h4>
<p>which will unfold a term until it hits a constructor, a pi, or other constant at head position</p>

<a name="131996413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131996413" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131996413">Mario Carneiro (Aug 12 2018 at 12:58)</a>:</h4>
<p>the name means "weak head normal form"</p>

<a name="131996658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131996658" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131996658">Kevin Buzzard (Aug 12 2018 at 13:07)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">definition</span> <span class="n">xena</span><span class="bp">.</span><span class="n">zero</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="mi">0</span>

<span class="kn">open</span> <span class="n">tactic</span>
<span class="n">run_cmd</span> <span class="n">do</span>
  <span class="n">whnf</span> <span class="bp">``</span><span class="n">xena</span><span class="bp">.</span><span class="n">zero</span> <span class="bp">&gt;&gt;=</span> <span class="n">trace</span> <span class="c1">-- fails because I wrote nonsense</span>
</pre></div>


<p>How do I get to the <code>expr</code>? Ooh this might be in PIL.</p>

<a name="131996713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131996713" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131996713">Mario Carneiro (Aug 12 2018 at 13:08)</a>:</h4>
<p>that's what the first lines are for</p>

<a name="131996726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131996726" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131996726">Mario Carneiro (Aug 12 2018 at 13:09)</a>:</h4>
<p><code>get_decl</code> gets a declaration, from which you can get the value with <code>d.value</code></p>

<a name="131996786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131996786" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131996786">Mario Carneiro (Aug 12 2018 at 13:10)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">open</span> <span class="n">tactic</span>
<span class="n">run_cmd</span> <span class="n">do</span>
  <span class="n">d</span> <span class="err">←</span> <span class="n">get_decl</span> <span class="bp">``</span><span class="n">xena</span><span class="bp">.</span><span class="n">zero</span><span class="o">,</span>
  <span class="n">whnf</span> <span class="n">d</span><span class="bp">.</span><span class="n">value</span> <span class="bp">&gt;&gt;=</span> <span class="n">trace</span> <span class="c1">-- nat.zero</span>
</pre></div>

<a name="131996842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131996842" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131996842">Mario Carneiro (Aug 12 2018 at 13:12)</a>:</h4>
<p>alternatively, you could just construct the expression <code>xena.zero</code> and reduce that, rather than getting the definition of <code>xena.zero</code> to reduce as I just did</p>
<div class="codehilite"><pre><span></span><span class="n">run_cmd</span> <span class="n">do</span>
  <span class="n">e</span> <span class="err">←</span> <span class="n">mk_const</span> <span class="bp">``</span><span class="n">xena</span><span class="bp">.</span><span class="n">zero</span><span class="o">,</span>
  <span class="n">whnf</span> <span class="n">e</span> <span class="bp">&gt;&gt;=</span> <span class="n">trace</span> <span class="c1">-- nat.zero</span>
</pre></div>

<a name="131996843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131996843" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131996843">Mario Carneiro (Aug 12 2018 at 13:12)</a>:</h4>
<p><code>whnf `(xena.zero) &gt;&gt;= trace</code> also works</p>

<a name="131996853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131996853" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131996853">Kevin Buzzard (Aug 12 2018 at 13:13)</a>:</h4>
<p>I don't see <code>nat.zero</code> -- I just see <code>0</code>. This is the pretty printer folding stuff up again, I guess?</p>

<a name="131996855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131996855" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131996855">Mario Carneiro (Aug 12 2018 at 13:13)</a>:</h4>
<p>I have <code>pp.all</code> enabled</p>

<a name="131996856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131996856" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131996856">Kevin Buzzard (Aug 12 2018 at 13:13)</a>:</h4>
<p>got it -- so have I now</p>

<a name="131996901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131996901" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131996901">Mario Carneiro (Aug 12 2018 at 13:14)</a>:</h4>
<p>right, the pretty printer prints <code>nat.zero</code> as <code>0</code>. Which is actually kind of confusing since that would usually be reserved for <code>@has_zero.zero _ _</code></p>

<a name="131996904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131996904" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131996904">Kevin Buzzard (Aug 12 2018 at 13:14)</a>:</h4>
<p>So it's all happening too fast -- <code>whnf</code> turns <code>xena.zero</code> straight into <code>nat.zero</code> like <code>#reduce</code>?</p>

<a name="131996916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131996916" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131996916">Mario Carneiro (Aug 12 2018 at 13:15)</a>:</h4>
<p>right, <code>whnf</code> unfolds definitions until it reaches something which isn't a definition</p>

<a name="131996926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131996926" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131996926">Mario Carneiro (Aug 12 2018 at 13:15)</a>:</h4>
<p>it is similar to <code>#reduce</code>, but it doesn't reduce everything, only stuff at the head</p>

<a name="131996972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131996972" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131996972">Mario Carneiro (Aug 12 2018 at 13:16)</a>:</h4>
<p>for example:</p>
<div class="codehilite"><pre><span></span><span class="n">run_cmd</span> <span class="n">whnf</span> <span class="bp">`</span><span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">xena</span><span class="bp">.</span><span class="n">zero</span><span class="o">)</span> <span class="bp">&gt;&gt;=</span> <span class="n">trace</span> <span class="c1">-- λ (x : nat), xena.zero</span>
</pre></div>

<a name="131996982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131996982" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131996982">Kevin Buzzard (Aug 12 2018 at 13:17)</a>:</h4>
<p><code>d.value</code> seems to have type <code>expr bool.tt</code>. What's that bool doing there?</p>

<a name="131996986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131996986" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131996986">Mario Carneiro (Aug 12 2018 at 13:17)</a>:</h4>
<p>the idea is that if <code>e1</code> unfolds to <code>sum A B</code> and <code>e2</code> unfolds to <code>prod C D</code>, then it is impossible for <code>e1 == e2</code></p>

<a name="131997025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131997025" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131997025">Mario Carneiro (Aug 12 2018 at 13:18)</a>:</h4>
<p>even if <code>A B C D</code> are not completely unfolded</p>

<a name="131997026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131997026" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131997026">Kevin Buzzard (Aug 12 2018 at 13:18)</a>:</h4>
<p>What does <code>==</code> mean?</p>

<a name="131997028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131997028" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131997028">Mario Carneiro (Aug 12 2018 at 13:18)</a>:</h4>
<p>defeq</p>

<a name="131997030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131997030" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131997030">Kevin Buzzard (Aug 12 2018 at 13:19)</a>:</h4>
<p>It's different to <code>=</code> because if two things are equal they must have the same type.</p>

<a name="131997038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131997038" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131997038">Mario Carneiro (Aug 12 2018 at 13:19)</a>:</h4>
<p>it's not heq, I should use a better notation</p>

<a name="131997041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131997041" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131997041">Kevin Buzzard (Aug 12 2018 at 13:19)</a>:</h4>
<p>Oh I see</p>

<a name="131997042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131997042" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131997042">Mario Carneiro (Aug 12 2018 at 13:19)</a>:</h4>
<p>defeq things have to have the same type btw</p>

<a name="131997043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131997043" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131997043">Kevin Buzzard (Aug 12 2018 at 13:19)</a>:</h4>
<p>great</p>

<a name="131997088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131997088" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131997088">Mario Carneiro (Aug 12 2018 at 13:20)</a>:</h4>
<p><code>expr tt</code> is <code>expr</code> and <code>expr ff</code> is <code>pexpr</code></p>

<a name="131997092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131997092" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131997092">Kevin Buzzard (Aug 12 2018 at 13:20)</a>:</h4>
<p>Oh!</p>

<a name="131997094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131997094" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131997094">Mario Carneiro (Aug 12 2018 at 13:20)</a>:</h4>
<p>they have the same definition as inductive types so this saves some duplication</p>

<a name="131997095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131997095" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131997095">Kevin Buzzard (Aug 12 2018 at 13:20)</a>:</h4>
<p>Oh these are optional paramaters</p>

<a name="131997237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131997237" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96988abrfl.html#131997237">Kevin Buzzard (Aug 12 2018 at 13:25)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">run_cmd</span> <span class="n">do</span>
  <span class="n">e</span> <span class="err">←</span> <span class="n">mk_const</span> <span class="bp">``</span><span class="n">xena</span><span class="bp">.</span><span class="n">zero</span><span class="o">,</span>
  <span class="n">return</span> <span class="n">e</span> <span class="bp">&gt;&gt;=</span> <span class="n">trace</span>
</pre></div>


<p>woo I wrote something that worked.</p>


{% endraw %}
