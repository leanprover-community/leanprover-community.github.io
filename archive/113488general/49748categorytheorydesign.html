---
layout: archive
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/49748categorytheorydesign.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html">category theory design</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="131997040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/131997040" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#131997040">Scott Morrison (Aug 12 2018 at 13:19)</a>:</h4>
<p>I spent some time this afternoon trying out three different implementations of products/equalizers/pullbacks. If anyone has a moment to have a look at them, I'd very much appreciate it. It's all in &lt;<a href="https://github.com/semorrison/lean-category-theory-pr/blob/limits/src/categories/universal/default.lean" target="_blank" title="https://github.com/semorrison/lean-category-theory-pr/blob/limits/src/categories/universal/default.lean">https://github.com/semorrison/lean-category-theory-pr/blob/limits/src/categories/universal/default.lean</a>&gt;.</p>

<a name="131997093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/131997093" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#131997093">Scott Morrison (Aug 12 2018 at 13:20)</a>:</h4>
<p>To try them out, I proved that the category of types has equalizers, pullbacks, and binary products.<br>
Rather beautifully, using <code>obviously</code> you can write exactly the same proof for all three versions:<br>
you just specify the shape, and <code>obviously</code> deals with the variations in what's required to check the universal<br>
properties.</p>

<a name="131997103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/131997103" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#131997103">Scott Morrison (Aug 12 2018 at 13:21)</a>:</h4>
<p>e.g. </p>
<div class="codehilite"><pre><span></span>instance : has_equalizers (Type u) :=
{ equalizer := λ Y Z f g, { X := { y : Y // f y = g y }, ι := subtype.val, w := by obviously, h := by obviously } }
</pre></div>

<a name="131997163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/131997163" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#131997163">Kevin Buzzard (Aug 12 2018 at 13:23)</a>:</h4>
<p>I feel out of my depth commenting on your work Scott. For me the proof of the pudding will be in the eating. Are we still a long way from me defining a presheaf on the adic space <code>Spa A</code> to be a functor from some category of open sets to the category whose objects are pairs consisting of a topological ring and some open subring with some properties?</p>

<a name="131997218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/131997218" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#131997218">Scott Morrison (Aug 12 2018 at 13:24)</a>:</h4>
<p>We're ... getting there.</p>

<a name="131997222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/131997222" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#131997222">Scott Morrison (Aug 12 2018 at 13:25)</a>:</h4>
<p>For me the eating is all about the fact that I don't need to write any proofs of boring statements, and _that_ I'm feeling pretty happy about.</p>

<a name="131997234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/131997234" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#131997234">Mario Carneiro (Aug 12 2018 at 13:25)</a>:</h4>
<p>Could we have a coercion from <code>span</code> and friends to the object?</p>

<a name="131997235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/131997235" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#131997235">Scott Morrison (Aug 12 2018 at 13:25)</a>:</h4>
<p>The big unknown step in getting to what you want is that we'll need to do enriched categories, and I haven't even started thinking about that.</p>

<a name="131997239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/131997239" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#131997239">Scott Morrison (Aug 12 2018 at 13:25)</a>:</h4>
<p>Sure, those coercions would be nice.</p>

<a name="131997278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/131997278" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#131997278">Scott Morrison (Aug 12 2018 at 13:26)</a>:</h4>
<p>I went with very short, nondescript field names for these structures, but attempted to be very uniform. To me the naming looks terrible, so if anyone has comments there I'm all ears. :-)</p>

<a name="131997291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/131997291" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#131997291">Mario Carneiro (Aug 12 2018 at 13:28)</a>:</h4>
<p>it didn't cry out to me as much as previous commits, so I guess that's a step forward?</p>

<a name="131997330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/131997330" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#131997330">Scott Morrison (Aug 12 2018 at 13:28)</a>:</h4>
<p>:-)</p>

<a name="131997331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/131997331" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#131997331">Mario Carneiro (Aug 12 2018 at 13:28)</a>:</h4>
<p>uniform naming is good</p>

<a name="131997340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/131997340" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#131997340">Scott Morrison (Aug 12 2018 at 13:29)</a>:</h4>
<p>I really love <span class="user-mention" data-user-id="110032">@Reid Barton</span>'s approach, which I implemented as <code>version_2</code> in that file. The fact that <code>obviously</code> just worked out the box to prove the category of types has all these things in Reid's approach made me very happy.</p>

<a name="131997387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/131997387" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#131997387">Mario Carneiro (Aug 12 2018 at 13:30)</a>:</h4>
<p>what is <code>is_equiv</code>?</p>

<a name="131997389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/131997389" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#131997389">Scott Morrison (Aug 12 2018 at 13:30)</a>:</h4>
<p>Having <code>obviously</code> handle <code>version_1</code> (essentially what <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> and I discussed earlier today) took a bit of tweaking, and in the end requires two hints.</p>

<a name="131997396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/131997396" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#131997396">Scott Morrison (Aug 12 2018 at 13:31)</a>:</h4>
<p>It's defined at the top of the file, as <code>is_iso</code> in the category of types: an explicit inverse function</p>

<a name="131997399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/131997399" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#131997399">Scott Morrison (Aug 12 2018 at 13:31)</a>:</h4>
<p>I can change it to something <code>equiv</code>, of course. :-)</p>

<a name="131997402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/131997402" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#131997402">Mario Carneiro (Aug 12 2018 at 13:31)</a>:</h4>
<p>I'm not sold on maximum compactification of statements. We did a lot of this in the filter/topology section, and it often made proofs longer</p>

<a name="131997445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/131997445" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#131997445">Scott Morrison (Aug 12 2018 at 13:32)</a>:</h4>
<p>Ok. Well, for now it's easy for me to continue experimenting with all three versions. They have very similar interface, except for how the universal properties are packaged.</p>

<a name="131997457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/131997457" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#131997457">Scott Morrison (Aug 12 2018 at 13:33)</a>:</h4>
<p>And for the first thing I tried to prove, all three versions admitted (the same) "shortest possible proofs".</p>

<a name="131997506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/131997506" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#131997506">Scott Morrison (Aug 12 2018 at 13:34)</a>:</h4>
<p>Just as an example, in <code>version_2</code> the proof of the field <code>h</code> in <code>has_equalizers</code> that <code>obviously</code> finds is:</p>
<div class="codehilite"><pre><span></span>/- obviously says: -/
intros X&#39;,
dsimp at *,
fsplit,
work_on_goal 0 {
  intros a a_1,
  cases a,
  have congr_fun_a_property_a_1 := congr_fun a_property a_1,
  fsplit,
  work_on_goal 0 {
  solve_by_elim
},
  work_on_goal 0 {
  simp at *,
  solve_by_elim
}
}, work_on_goal 0 {
  ext1,
  ext1,
  ext1,
  refl
}, work_on_goal 0 {
  ext1,
  ext1,
  ext1,
  cases x,
  refl
}
</pre></div>

<a name="131997530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/131997530" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#131997530">Scott Morrison (Aug 12 2018 at 13:35)</a>:</h4>
<p>where in <code>version_0</code> <code>obviously</code> finds</p>
<div class="codehilite"><pre><span></span>/- obviously says: -/
fsplit,
work_on_goal 0 {
  intros X&#39; k w a,
  have congr_fun_w_a := congr_fun w a,
  dsimp at *,
  fsplit,
  work_on_goal 0 {
  solve_by_elim
},
  work_on_goal 0 {
  simp at *,
  solve_by_elim
}
}, work_on_goal 0 {
  intros X&#39; k w,
  refl
}, work_on_goal 0 {
  dsimp at *,
  fsplit,
  intros Z_1 g_1 h w,
  ext1,
  have congr_fun_w_x := congr_fun w x,
  ext1,
  solve_by_elim
}
</pre></div>

<a name="131997582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/131997582" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#131997582">Mario Carneiro (Aug 12 2018 at 13:36)</a>:</h4>
<p>where is unfolding of the definitions happening?</p>

<a name="131997584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/131997584" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#131997584">Mario Carneiro (Aug 12 2018 at 13:36)</a>:</h4>
<p>what is <code>fsplit</code></p>

<a name="131997587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/131997587" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#131997587">Scott Morrison (Aug 12 2018 at 13:36)</a>:</h4>
<p><code>fsplit</code> is just <code>split</code>, but not reordering the new goals</p>

<a name="131997590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/131997590" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#131997590">Scott Morrison (Aug 12 2018 at 13:36)</a>:</h4>
<p>sorry, needs a better name</p>

<a name="131997607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/131997607" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#131997607">Scott Morrison (Aug 12 2018 at 13:37)</a>:</h4>
<p>(i.e. the goals for <code>fsplit</code> on a structure are the fields in order, whereas for <code>split</code> the dependent ones come first.)</p>

<a name="131997736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/131997736" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#131997736">Mario Carneiro (Aug 12 2018 at 13:41)</a>:</h4>
<p>Another version of <code>version_1</code> is to use <code>Σ!</code></p>

<a name="131997775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/131997775" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#131997775">Mario Carneiro (Aug 12 2018 at 13:42)</a>:</h4>
<p>which was once created but doesn't seem to exist anymore</p>

<a name="131997776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/131997776" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#131997776">Mario Carneiro (Aug 12 2018 at 13:42)</a>:</h4>
<p>but you can guess what the definition was given <code>∃!</code></p>

<a name="131997825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/131997825" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#131997825">Mario Carneiro (Aug 12 2018 at 13:45)</a>:</h4>
<p>one thing I like about <code>version_0.is_binary_product</code> is that the uniqueness is equational</p>

<a name="131997834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/131997834" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#131997834">Mario Carneiro (Aug 12 2018 at 13:45)</a>:</h4>
<p>Do you know if there is an equational expression for the others?</p>

<a name="131997882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/131997882" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#131997882">Mario Carneiro (Aug 12 2018 at 13:46)</a>:</h4>
<p>I don't really understand <code>version_0.is_equalizer.uniq</code></p>

<a name="131997956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/131997956" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#131997956">Scott Morrison (Aug 12 2018 at 13:49)</a>:</h4>
<p>Hmm... maybe I got that one wrong. Let's see. Uniqueness is meant to say if you have a function <code>h : X' -&gt; Y</code> so <code>h then f = h then g</code>, and two different factorisations of <code>h</code> as <code>h_1 then i</code> and <code>h_2 then i</code>, then <code>h_1 = h_2</code>.</p>

<a name="131997966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/131997966" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#131997966">Mario Carneiro (Aug 12 2018 at 13:50)</a>:</h4>
<p>I think for mathlib, I'll vote for version_0 with the others proved as lemmas</p>

<a name="131998023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/131998023" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#131998023">Mario Carneiro (Aug 12 2018 at 13:50)</a>:</h4>
<p>I know it's wordy, but it's also perspicuous</p>

<a name="131998042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/131998042" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#131998042">Mario Carneiro (Aug 12 2018 at 13:51)</a>:</h4>
<p>we should save the slick version for a theorem</p>

<a name="131998097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/131998097" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#131998097">Mario Carneiro (Aug 12 2018 at 13:52)</a>:</h4>
<p>you will notice that <a href="https://en.wikipedia.org/wiki/Product_(category_theory)" target="_blank" title="https://en.wikipedia.org/wiki/Product_(category_theory)">https://en.wikipedia.org/wiki/Product_(category_theory)</a> gives essentially version_0 as its definition</p>

<a name="131998239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/131998239" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#131998239">Scott Morrison (Aug 12 2018 at 13:56)</a>:</h4>
<p>I think what I said for <code>version_0.is_equalizer.uniq</code> is correct, but absolutely that should be a lemma, not the official statement.</p>

<a name="131998367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/131998367" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#131998367">Scott Morrison (Aug 12 2018 at 14:00)</a>:</h4>
<p>Hopefully <span class="user-mention" data-user-id="110032">@Reid Barton</span> will have a look later, and comment too. He's already implemented quite a lot using something very close to <code>version_2</code>.</p>

<a name="132125040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/132125040" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#132125040">Reid Barton (Aug 14 2018 at 17:50)</a>:</h4>
<p>Hi, I've been traveling recently (and also dealing with a broken laptop power supply) but I should be able to take a look within a couple of days.</p>

<a name="132473102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/132473102" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#132473102">Reid Barton (Aug 20 2018 at 18:34)</a>:</h4>
<p>Returning to this topic. I have a few general comments.</p>

<a name="132473442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/132473442" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#132473442">Reid Barton (Aug 20 2018 at 18:40)</a>:</h4>
<ul>
<li>
<p>I think it's rather important to include the <code>is_*</code> structures (like <code>is_pullback</code>, etc.) and to define the structures like <code>pullback</code> in terms of them. The <code>is_pullback</code> type is useful to express concepts like "the functor G : D -&gt; C preserves pullbacks", that is, "the image under G of a pullback diagram is again a pullback", especially in the absence of completeness assumptions on D and C. In terms of just <code>pullback</code>, the conclusion would have to include an existential and a bunch of equalities.</p>
<p>All of Scott's versions in the file linked above follow this form. I only mention point because I think Scott's library used to define <code>pullback</code> without <code>is_pullback</code>, and I've become convinced of the importance of the <code>is_*</code> structures from experience with applications.</p>
</li>
</ul>

<a name="132474260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/132474260" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#132474260">Reid Barton (Aug 20 2018 at 18:55)</a>:</h4>
<ul>
<li>
<p>In the end, I don't think it's terribly important for applications which definition is adopted as the official definition, especially since projection notation makes it pretty easy for a structure to behave as though it has an entirely different set of fields. The biggest effect will be when constructing <code>is_pullback</code> values, since as far as I know the record <code>{ ... }</code> notation can only be used with the actual fields of the structure. For this reason alone, maybe taking the "explicit" version as the definition would be preferable, as it has the most fields (there's not much pain in using an explicit function as an "alternative constructor", when that function has just one or two arguments).</p>
<p>I did find both the "explicit" and "bijective" styles useful in different situations. I'm slightly surprised that <code>obviously</code> was able to provide all the limit constructions for the category of sets, I mean, types, using any of the definition styles. I guess <code>tauto</code> is pretty good at guessing how to do product-type constructions. I suspect if you tried to build colimits, you'd need to do more hand-holding. At any rate, when I proved that topological spaces have coproducts and coequalizers, I found it easier to do the construction using the "explicit" style; when I thought about what I would need to do in the "bijective" style, it amounted to checking the "explicit" style conditions first anyways. On the other hand, for proving facts about colimits, I made use of the "bijective" style using some <code>bij_on</code> machinery. This wasn't that easy to set up, but I'm reasonably happy with how the proofs turned out. They seem preferable to endless diagram chases--unless possibly the computer can just do the entire diagram chasing argument, in which case I won't complain about how long it is!</p>
</li>
</ul>

<a name="132474513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/132474513" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#132474513">Reid Barton (Aug 20 2018 at 19:00)</a>:</h4>
<ul>
<li>About constructive vs classical universal properties--I've been assuming that the constructive notions are preferable, but I haven't actually experimented with the alternative, that is, making the <code>is_*</code> structures into Props rather than subsingletons. All I can report here is that using the constructive notions hasn't presented me with any major obstacles.</li>
</ul>

<a name="132474628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/132474628" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#132474628">Reid Barton (Aug 20 2018 at 19:02)</a>:</h4>
<p>I find it a bit curious that Mario thinks the wikipedia definition is essentially Scott's "explicit" definition. To me, it's not even obvious that the "explicit" <code>is_product</code> structure is a subsingleton, but wikipedia definitely defines a proposition!</p>

<a name="132474662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/132474662" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#132474662">Reid Barton (Aug 20 2018 at 19:03)</a>:</h4>
<p>The "explicit" definition looks like someone took the wikipedia definition and ran it through a compiler, and what came out is this structure with four fields.<br>
In math we don't even really have a specific name for the function which takes a map into X and a map into Y and produces a map into X x Y, besides the "induced" map or something.</p>

<a name="132474906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/132474906" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#132474906">Reid Barton (Aug 20 2018 at 19:08)</a>:</h4>
<p>But in any case, the order is different. First we require a property of the (potential) product diagram, "for all ..., there exists a unique ... such that blah blah", and then call the diagram a product. Then, optionally, we could name the function that is determined by this relationship, but mostly we don't bother.</p>

<a name="132474943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/132474943" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#132474943">Reid Barton (Aug 20 2018 at 19:09)</a>:</h4>
<p>With a constructive unique existential quantifier, you could just translate the definition word-for-word into Lean.<br>
But in any case, like I said above, I don't think the exact choice of definition is that important.</p>

<a name="132475609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/132475609" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#132475609">Reid Barton (Aug 20 2018 at 19:23)</a>:</h4>
<p>Here's a very simple example of using the "bijective" style to prove a fact about products: namely that products are associative up to isomorphism. Suppose I have (X x Y) x Z and X x (Y x Z). Then for any object A, I get, on the one hand, a bijection between Hom(A, (X x Y) x Z) and (Hom(A, X) x Hom(A, Y)) x Hom(A, Z), and on the other hand a bijection between Hom(A, X x (Y x Z)) and Hom(A, X) x (Hom(A, Y) x Hom(A, Z)). Composing these together with the associativity isomorphism for products of sets, I get an isomorphism Hom(A, (X x Y) x Z) ~= Hom(A, X x (Y x Z)), which means that I have an isomorphism between (X x Y) x Z and X x (Y x Z), by Yoneda.</p>

<a name="132475710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/132475710" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#132475710">Johan Commelin (Aug 20 2018 at 19:25)</a>:</h4>
<p>Is Yoneda already in Lean?</p>

<a name="132475783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/132475783" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#132475783">Reid Barton (Aug 20 2018 at 19:26)</a>:</h4>
<p>If I were to use the explicit/first-order definition of products directly, I would need to manually build the comparison map by pairing the maps (X x Y) x Z -&gt; X and (X x Y) x Z -&gt; Y x Z given by, respectively, projection on the first component twice and (the pairing of the maps (X x Y) -&gt; Y and ...), and then construct the inverse map in the same fashion, and then finally check that the compositions are the identity, which means checking that each projection is the identity, which is going to involve a whole lot of applications of the axioms of a product object.</p>

<a name="132475837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/132475837" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#132475837">Reid Barton (Aug 20 2018 at 19:27)</a>:</h4>
<p>Similarly, I would prefer to show that right adjoints preserve products by a calculation along the lines of<br>
Hom(A, G(X x Y)) = Hom(FA, X x Y) = Hom(FA, X) x Hom(FA, Y) = Hom(A, GX) x Hom(A, GY)<br>
although I think that in this case, the first-order approach is also not so difficult</p>

<a name="132476073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/132476073" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#132476073">Reid Barton (Aug 20 2018 at 19:32)</a>:</h4>
<p>I think Scott's library has some version of Yoneda. The version I used is just a couple lines to prove, although I did sweep some questions of naturality in A under the rug.</p>

<a name="132476207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/132476207" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#132476207">Reid Barton (Aug 20 2018 at 19:36)</a>:</h4>
<p>(For reference, I proved that left adjoints preserve pushouts in <a href="https://github.com/rwbarton/lean-homotopy-theory/blob/lean-3.4.1/src/categories/preserves_colimits.lean#L44-L82" target="_blank" title="https://github.com/rwbarton/lean-homotopy-theory/blob/lean-3.4.1/src/categories/preserves_colimits.lean#L44-L82">https://github.com/rwbarton/lean-homotopy-theory/blob/lean-3.4.1/src/categories/preserves_colimits.lean#L44-L82</a>, although the proof is still not as polished as I'd like. The basic structure is analogous to what I wrote above though.)</p>

<a name="132476804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/132476804" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#132476804">Johan Commelin (Aug 20 2018 at 19:49)</a>:</h4>
<p>I would like to first have a proof that left adjoints preserve arbitrary colimits, and then deduce the fact about push-outs by specialisation. How hard do you think that will be?</p>

<a name="132477332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/132477332" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#132477332">Reid Barton (Aug 20 2018 at 19:59)</a>:</h4>
<p>I had a hard time when I tried to deduce existence of pullbacks from completeness quite some time ago, but now I think I know how to go about it.</p>

<a name="132477463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/132477463" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#132477463">Reid Barton (Aug 20 2018 at 20:01)</a>:</h4>
<p>One should describe the indexing category for the pullback in terms of generators and relations (of course, there are no relations in this case) because one needs to describe functors from the indexing category in terms of concrete data</p>

<a name="132536953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/132536953" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#132536953">Scott Morrison (Aug 21 2018 at 19:31)</a>:</h4>
<p>Thanks, <span class="user-mention" data-user-id="110032">@Reid Barton</span>, for all the remarks. I'm rewriting my file about limits again now, and I think what I'm doing is compatible with everything you've said. The "explicit" version comes first, and the other two viewpoints are available as lemmas and alternative constructors.</p>

<a name="132537150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/132537150" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#132537150">Scott Morrison (Aug 21 2018 at 19:34)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> I have Yoneda at &lt;<a href="https://github.com/semorrison/lean-category-theory/blob/master/src/categories/yoneda.lean" target="_blank" title="https://github.com/semorrison/lean-category-theory/blob/master/src/categories/yoneda.lean">https://github.com/semorrison/lean-category-theory/blob/master/src/categories/yoneda.lean</a>&gt;. <code>obviously</code> just plows through all the boring bits.</p>

<a name="132559544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/132559544" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#132559544">Johan Commelin (Aug 22 2018 at 05:25)</a>:</h4>
<p>I'm also interested in what the plans are for the limit/colimit duality? Are we going to define things twice, or in terms of <code>op</code>? Or both? I don't have any experience with this... but I guess it is something that will pop up pretty soon.</p>

<a name="132559605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/132559605" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#132559605">Scott Morrison (Aug 22 2018 at 05:27)</a>:</h4>
<p>For now I'm going to write out everything twice, with painful copy-paste-replace.</p>

<a name="132559606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/132559606" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#132559606">Scott Morrison (Aug 22 2018 at 05:27)</a>:</h4>
<p>:-(</p>

<a name="132559651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/132559651" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#132559651">Scott Morrison (Aug 22 2018 at 05:28)</a>:</h4>
<p>I've been thinking I should learn how to write an analogue of <code>to_additive</code>, or something even more general.</p>

<a name="132559662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/132559662" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#132559662">Scott Morrison (Aug 22 2018 at 05:28)</a>:</h4>
<p>We certainly need to have separate definitions for limits and colimits (and all the specialisations, equalizers, coequalizers, etc), and theorems relating a limit and a colimit in the opposite category.</p>

<a name="132559673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/132559673" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#132559673">Scott Morrison (Aug 22 2018 at 05:29)</a>:</h4>
<p>The only question is whether the "other half" of the definitions are written by hand. (And whether those theorems are automatically generated.)</p>

<a name="132559783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/132559783" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#132559783">Johan Commelin (Aug 22 2018 at 05:32)</a>:</h4>
<p>Hmmm, <code>to_opposite</code> or <code>to_dual</code> might be a nice way of dealing with this! Especially if it could also generate the "linking" theorems.</p>

<a name="132559795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/132559795" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#132559795">Johan Commelin (Aug 22 2018 at 05:33)</a>:</h4>
<p>I remember that some time ago there was a bit of chat about whether <code>op op C</code> was defeq to <code>C</code>. Would that help here?</p>

<a name="132560744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/132560744" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#132560744">Scott Morrison (Aug 22 2018 at 06:02)</a>:</h4>
<p>Certainly <code>op op C</code> is defeq to <code>C</code>, since <code>op C := C</code>. I think you mean</p>
<div class="codehilite"><pre><span></span>variables {C : Type u₁} [𝒞 : category.{u₁ v₁} C]
include 𝒞

@[simp] lemma foo : @category_theory.opposite (Cᵒᵖ) (@category_theory.opposite C 𝒞) = 𝒞 := sorry
</pre></div>


<p>which is not a <code>rfl</code> lemma.</p>

<a name="132560807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/132560807" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#132560807">Scott Morrison (Aug 22 2018 at 06:04)</a>:</h4>
<p>Of course it is true, e.g. by</p>
<div class="codehilite"><pre><span></span>@[simp] lemma foo : @category_theory.opposite (Cᵒᵖ) (@category_theory.opposite C 𝒞) = 𝒞 :=
begin
  tactic.unfreeze_local_instances,
  cases 𝒞,
  unfold category_theory.opposite,
  congr,
end
</pre></div>

<a name="132560811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/132560811" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#132560811">Scott Morrison (Aug 22 2018 at 06:04)</a>:</h4>
<p>but I think the natural isomorphism is more useful.</p>

<a name="132563707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/132563707" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#132563707">Johan Commelin (Aug 22 2018 at 07:29)</a>:</h4>
<p>Right, I meant your <code>foo</code>.</p>

<a name="132582012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/132582012" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#132582012">Reid Barton (Aug 22 2018 at 14:41)</a>:</h4>
<p>Oh interesting. I read a paper on the design of a category theory library for HoTT/Coq, and they had to jump through some extra hoops to account for the fact that associativity in C^op is the <code>eq.symm</code> of associativity in C</p>

<a name="132582027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/132582027" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#132582027">Reid Barton (Aug 22 2018 at 14:41)</a>:</h4>
<p>But I guess that doesn't show up here, because of proof irrelevance.</p>

<a name="132583989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/132583989" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#132583989">Reid Barton (Aug 22 2018 at 15:11)</a>:</h4>
<p>The <code>op op C = C</code> question comes up if you want to dualize colimits back into limits.</p>

<a name="132584060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/132584060" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#132584060">Reid Barton (Aug 22 2018 at 15:12)</a>:</h4>
<p>Let's suppose that we've defined a diagram in C to be a pushout when the corresponding diagram in C^op is a pullback</p>

<a name="132584082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/132584082" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#132584082">Reid Barton (Aug 22 2018 at 15:13)</a>:</h4>
<p>Now we have some result about pushouts, for example: In a model category, a pushout of a cofibration is a cofibration.</p>

<a name="132584188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/132584188" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#132584188">Reid Barton (Aug 22 2018 at 15:14)</a>:</h4>
<p>And we want to conclude the dual statement, namely that a pullback of a fibration is a fibration. The opposite of a model category is again a model category, with cofibrations and fibrations interchanged, so this is true by duality.<br>
(For whatever reason, it's normal in the model category literature to prove things on the "left" side and deduce the corresponding statements on the "right" side by duality, so let's just assume that we want to do it this way rather than the other way around.)</p>

<a name="132584285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/132584285" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#132584285">Reid Barton (Aug 22 2018 at 15:16)</a>:</h4>
<p>The obvious approach is to apply the statement we already know to C^op, since C^op is also a model category.<br>
Then we obtain: A pushout (in C^op) of a cofibration (in C^op) is a cofibration (in C^op).<br>
We know that a cofibration in C^op corresponds to a fibration in C. Now we have a pushout in C^op. By definition, this is a pullback in (C^op)^op.</p>

<a name="132584297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/132584297" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#132584297">Reid Barton (Aug 22 2018 at 15:16)</a>:</h4>
<p>In order to conclude the statement we want, we need to know (C^op)^op = C.</p>

<a name="132584415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/132584415" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#132584415">Reid Barton (Aug 22 2018 at 15:18)</a>:</h4>
<p>Which is true, they are propositionally equal.<br>
If we have some tactic which proves the dual version of a statement from the original statement, then it can insert this propositional equality and it's no big deal.<br>
If we want to directly define the proof of the dual statement as <em>equal</em> to the original proof (with C^op substituted for C), then this will only succeed if (C^op)^op = C definitionally.</p>

<a name="132584511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/132584511" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#132584511">Reid Barton (Aug 22 2018 at 15:20)</a>:</h4>
<p>And it's frustratingly close to being true--the proof is just this <code>cases 𝒞</code>. If we had definitional equality for structures, then (C^op)^op would be definitionally equal to C, I think.</p>

<a name="132584633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/category%20theory%20design/near/132584633" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49748categorytheorydesign.html#132584633">Reid Barton (Aug 22 2018 at 15:22)</a>:</h4>
<p>If, instead of proving a theorem ("the pushout of a cofibration is a cofibration"), we were constructing a canonical isomorphism or something, I can imagine that the propositional equality (C^op)^op = C could get in the way of later reasoning about the thing we constructed</p>


{% endraw %}
