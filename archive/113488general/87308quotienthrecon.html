---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/87308quotienthrecon.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html">quotient.hrec_on₂</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="130971695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130971695" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130971695">Sean Leather (Aug 06 2018 at 11:09)</a>:</h4>
<p>I've got a <a href="https://github.com/spl/lean-finmap/blob/fb3f562de05059f136f855b88bf616c8aac7f365/src/data/multiset/dict.lean#L162-L172" target="_blank" title="https://github.com/spl/lean-finmap/blob/fb3f562de05059f136f855b88bf616c8aac7f365/src/data/multiset/dict.lean#L162-L172">definition</a>:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">kunion</span> <span class="o">:</span> <span class="n">m₁</span><span class="bp">.</span><span class="n">nodup_keys</span> <span class="bp">→</span> <span class="n">m₂</span><span class="bp">.</span><span class="n">nodup_keys</span> <span class="bp">→</span> <span class="n">multiset</span> <span class="o">(</span><span class="n">sigma</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">quotient</span><span class="bp">.</span><span class="n">hrec_on₂</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m₁</span> <span class="n">m₂</span> <span class="o">:</span> <span class="n">multiset</span> <span class="o">(</span><span class="n">sigma</span> <span class="n">β</span><span class="o">)),</span> <span class="n">m₁</span><span class="bp">.</span><span class="n">nodup_keys</span> <span class="bp">→</span> <span class="n">m₂</span><span class="bp">.</span><span class="n">nodup_keys</span> <span class="bp">→</span> <span class="n">multiset</span> <span class="o">(</span><span class="n">sigma</span> <span class="n">β</span><span class="o">))</span>
  <span class="n">m₁</span> <span class="n">m₂</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="o">(</span><span class="n">d₁</span> <span class="o">:</span> <span class="n">l₁</span><span class="bp">.</span><span class="n">nodup_keys</span><span class="o">)</span> <span class="o">(</span><span class="n">d₂</span> <span class="o">:</span> <span class="n">l₂</span><span class="bp">.</span><span class="n">nodup_keys</span><span class="o">),</span> <span class="n">l₁</span><span class="bp">.</span><span class="n">kunion</span> <span class="n">l₂</span><span class="o">)</span> <span class="err">$</span>
    <span class="bp">λ</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="n">l₃</span> <span class="n">l₄</span> <span class="n">p₁₃</span> <span class="n">p₂₄</span><span class="o">,</span>
    <span class="n">hfunext</span> <span class="o">(</span><span class="k">by</span> <span class="n">rw</span> <span class="n">perm_nodup_keys</span> <span class="n">p₁₃</span><span class="o">)</span> <span class="err">$</span>
      <span class="bp">λ</span> <span class="o">(</span><span class="n">d₁</span> <span class="o">:</span> <span class="n">l₁</span><span class="bp">.</span><span class="n">nodup_keys</span><span class="o">)</span> <span class="o">(</span><span class="n">d₃</span> <span class="o">:</span> <span class="n">l₃</span><span class="bp">.</span><span class="n">nodup_keys</span><span class="o">)</span> <span class="bp">_</span><span class="o">,</span>
      <span class="n">hfunext</span> <span class="o">(</span><span class="k">by</span> <span class="n">rw</span> <span class="n">perm_nodup_keys</span> <span class="n">p₂₄</span><span class="o">)</span> <span class="err">$</span>
        <span class="bp">λ</span> <span class="o">(</span><span class="n">d₂</span> <span class="o">:</span> <span class="n">l₂</span><span class="bp">.</span><span class="n">nodup_keys</span><span class="o">)</span> <span class="o">(</span><span class="n">d₄</span> <span class="o">:</span> <span class="n">l₄</span><span class="bp">.</span><span class="n">nodup_keys</span><span class="o">)</span> <span class="bp">_</span><span class="o">,</span>
        <span class="n">heq_of_eq</span> <span class="err">$</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">sound</span> <span class="err">$</span> <span class="n">perm_kunion</span> <span class="n">d₂</span> <span class="n">d₄</span> <span class="n">p₁₃</span> <span class="n">p₂₄</span>

<span class="n">local</span> <span class="kn">infixr</span> <span class="bp">`</span> <span class="n">k</span><span class="err">∪</span> <span class="bp">`</span><span class="o">:</span><span class="mi">67</span> <span class="o">:=</span> <span class="n">kunion</span>
</pre></div>


<p>and I want to prove the left and right units:</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">zero_kunion</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">multiset</span> <span class="o">(</span><span class="n">sigma</span> <span class="n">β</span><span class="o">)}</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">m</span><span class="bp">.</span><span class="n">nodup_keys</span><span class="o">),</span> <span class="n">nodup_keys_zero</span> <span class="n">k</span><span class="err">∪</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">m</span>
<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">kunion_zero</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">multiset</span> <span class="o">(</span><span class="n">sigma</span> <span class="n">β</span><span class="o">)}</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">m</span><span class="bp">.</span><span class="n">nodup_keys</span><span class="o">),</span> <span class="n">d</span> <span class="n">k</span><span class="err">∪</span> <span class="n">nodup_keys_zero</span> <span class="bp">=</span> <span class="n">m</span>
</pre></div>


<p>I'm stuck on how to proceed. If I use <code>quotient.induction_on m</code>, I just unfold until I get down to <code>quot.rec_on ↑(hd :: tl)</code> or <code>quot.rec_on ↑nil</code>, but I don't know how to go further. (At one point, I believe I even made the simplifier loop infinitely.)</p>
<p>Any suggestions on how to prove these?</p>

<a name="130971867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130971867" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130971867">Mario Carneiro (Aug 06 2018 at 11:12)</a>:</h4>
<p>Wow, that's a weird notation</p>

<a name="130971872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130971872" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130971872">Mario Carneiro (Aug 06 2018 at 11:12)</a>:</h4>
<p>does it have to be a partial function?</p>

<a name="130971983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130971983" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130971983">Sean Leather (Aug 06 2018 at 11:15)</a>:</h4>
<blockquote>
<p>does it have to be a partial function?</p>
</blockquote>
<p>I don't follow you.</p>

<a name="130972034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130972034" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130972034">Mario Carneiro (Aug 06 2018 at 11:16)</a>:</h4>
<p>you could make it return empty when the inputs don't have <code>nodup_keys</code></p>

<a name="130972054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130972054" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130972054">Mario Carneiro (Aug 06 2018 at 11:17)</a>:</h4>
<p>or it could be a <code>roption</code> if you are worried about the performance cost of checking <code>nodup_keys</code></p>

<a name="130972218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130972218" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130972218">Sean Leather (Aug 06 2018 at 11:21)</a>:</h4>
<p>Sorry, Mario, your  use of “it” in multiple places is a bit too vague for me. Are you suggesting I use a different definition for <code>kunion</code>? If so, what is the type signature you're referring to?</p>

<a name="130972526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130972526" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130972526">Sean Leather (Aug 06 2018 at 11:28)</a>:</h4>
<p>Btw, I'm not asking for a completed solution. You're welcome to give me only hints or suggestions. <span class="emoji emoji-263a" title="smile">:smile:</span></p>

<a name="130972544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130972544" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130972544">Reid Barton (Aug 06 2018 at 11:29)</a>:</h4>
<p>I think <code>def kunion : multiset (sigma β) → multiset (sigma β) → roption (multiset (sigma β))</code> and then prove that <code>kunion</code> is defined exactly when each <code>multiset</code> is <code>nodup_keys</code></p>

<a name="130972612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130972612" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130972612">Sean Leather (Aug 06 2018 at 11:31)</a>:</h4>
<p>Reid: Hmm, okay, thanks.</p>

<a name="130972673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130972673" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130972673">Sean Leather (Aug 06 2018 at 11:32)</a>:</h4>
<p>And what's the advantage to this approach? Is it simplicity of the definition and related theorems or performance or both?</p>

<a name="130972677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130972677" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130972677">Reid Barton (Aug 06 2018 at 11:32)</a>:</h4>
<p>Then you can avoid all this dependent eliminator stuff... although it's not clear to me whether your problem is related to this</p>

<a name="130972701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130972701" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130972701">Sean Leather (Aug 06 2018 at 11:33)</a>:</h4>
<p>Okay, well, I'll give it a shot.</p>

<a name="130972702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130972702" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130972702">Chris Hughes (Aug 06 2018 at 11:33)</a>:</h4>
<p>Just proving at <code> quotient.hrec_on_beta</code> lemma might help.</p>

<a name="130972707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130972707" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130972707">Reid Barton (Aug 06 2018 at 11:34)</a>:</h4>
<p>Yes. Is that <code>↑</code> just <code>quotient.mk</code>?</p>

<a name="130972756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130972756" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130972756">Sean Leather (Aug 06 2018 at 11:34)</a>:</h4>
<p>Yes, I think so.</p>

<a name="130972765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130972765" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130972765">Sean Leather (Aug 06 2018 at 11:34)</a>:</h4>
<p>Chris: I wondered the same thing. I'm not sure how to start with that.</p>

<a name="130972790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130972790" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130972790">Reid Barton (Aug 06 2018 at 11:35)</a>:</h4>
<p>Well, <code>quotient.rec_on</code> applied to <code>quotient.mk</code> should reduce...</p>

<a name="130972792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130972792" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130972792">Chris Hughes (Aug 06 2018 at 11:35)</a>:</h4>
<p>Or use <code>show</code></p>

<a name="130972893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130972893" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130972893">Sean Leather (Aug 06 2018 at 11:37)</a>:</h4>
<p>I suppose it would look something like:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">quot</span><span class="bp">.</span><span class="n">ind_beta</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">β</span> <span class="o">(</span><span class="n">quot</span><span class="bp">.</span><span class="n">mk</span> <span class="n">r</span> <span class="n">a</span><span class="o">))</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">ind</span> <span class="n">p</span> <span class="o">(</span><span class="n">quot</span><span class="bp">.</span><span class="n">mk</span> <span class="n">r</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">β</span> <span class="o">(</span><span class="n">quot</span><span class="bp">.</span><span class="n">mk</span> <span class="n">r</span> <span class="n">a</span><span class="o">))</span> <span class="bp">=</span> <span class="n">p</span> <span class="n">a</span>
</pre></div>

<a name="130974037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130974037" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130974037">Mario Carneiro (Aug 06 2018 at 12:00)</a>:</h4>
<p>that is trivially true, since both sides are propositions</p>

<a name="130974063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130974063" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130974063">Mario Carneiro (Aug 06 2018 at 12:01)</a>:</h4>
<p>The advantage of using <code>roption</code> is avoiding all the <code>hrec</code> mess. I've had to define partial functions over quotients before, and I wish I'd thought of this then</p>

<a name="130974158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130974158" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130974158">Sean Leather (Aug 06 2018 at 12:03)</a>:</h4>
<blockquote>
<p>that is trivially true, since both sides are propositions</p>
</blockquote>
<p>Are you referring to <code>quot.ind_beta</code>, which is in the core library, or something else?</p>
<blockquote>
<p>The advantage of using <code>roption</code> is avoiding all the <code>hrec</code> mess. I've had to define partial functions over quotients before, and I wish I'd thought of this then</p>
</blockquote>
<p>Great! I'm working on it now.</p>

<a name="130974410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130974410" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130974410">Reid Barton (Aug 06 2018 at 12:08)</a>:</h4>
<p>I think someone probably copied <code>lift_beta</code> to <code>ind_beta</code> without realizing it was rather unnecessary.</p>

<a name="130974532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130974532" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130974532">Sean Leather (Aug 06 2018 at 12:10)</a>:</h4>
<p>Ah! I see what you're saying now. I didn't look that closely at <code>ind_beta</code>.</p>

<a name="130974767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130974767" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130974767">Sean Leather (Aug 06 2018 at 12:14)</a>:</h4>
<p>This is definitely a much nicer definition:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">kunion&#39;</span> <span class="o">(</span><span class="n">m₁</span> <span class="n">m₂</span> <span class="o">:</span> <span class="n">multiset</span> <span class="o">(</span><span class="n">sigma</span> <span class="n">β</span><span class="o">))</span> <span class="o">:</span> <span class="n">roption</span> <span class="o">(</span><span class="n">multiset</span> <span class="o">(</span><span class="n">sigma</span> <span class="n">β</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">quotient</span><span class="bp">.</span><span class="n">lift_on₂</span> <span class="n">m₁</span> <span class="n">m₂</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">l₁</span> <span class="n">l₂</span><span class="o">,</span> <span class="n">roption</span><span class="bp">.</span><span class="n">mk</span> <span class="o">(</span><span class="n">l₁</span><span class="bp">.</span><span class="n">nodup_keys</span> <span class="bp">∧</span> <span class="n">l₂</span><span class="bp">.</span><span class="n">nodup_keys</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="o">(</span><span class="n">l₁</span><span class="bp">.</span><span class="n">kunion</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">multiset</span> <span class="o">(</span><span class="n">sigma</span> <span class="n">β</span><span class="o">))))</span> <span class="err">$</span>
  <span class="bp">λ</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="n">l₃</span> <span class="n">l₄</span> <span class="n">p₁₃</span> <span class="n">p₂₄</span><span class="o">,</span> <span class="n">roption</span><span class="bp">.</span><span class="n">ext&#39;</span>
    <span class="o">(</span><span class="n">and_congr</span> <span class="o">(</span><span class="n">perm_nodup_keys</span> <span class="n">p₁₃</span><span class="o">)</span> <span class="o">(</span><span class="n">perm_nodup_keys</span> <span class="n">p₂₄</span><span class="o">))</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="bp">⟨</span><span class="n">d₁</span><span class="o">,</span> <span class="n">d₂</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">d₃</span><span class="o">,</span> <span class="n">d₄</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">sound</span> <span class="err">$</span> <span class="n">perm_kunion</span> <span class="n">d₂</span> <span class="n">d₄</span> <span class="n">p₁₃</span> <span class="n">p₂₄</span><span class="o">)</span>
</pre></div>

<a name="130974979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130974979" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130974979">Mario Carneiro (Aug 06 2018 at 12:18)</a>:</h4>
<p>so now the theorem you want is either <code>m k∪ 0 = some m</code> or <code>m ∈ m k∪ 0</code> (they are equivalent)</p>

<a name="130975110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130975110" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130975110">Sean Leather (Aug 06 2018 at 12:20)</a>:</h4>
<p>Right.</p>

<a name="130975212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130975212" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130975212">Mario Carneiro (Aug 06 2018 at 12:22)</a>:</h4>
<p>and the coercion lemma you want says <code>l₁.nodup_keys → l₂.nodup_keys → ↑l₁ k∪ ↑l₂ = some (l₁.kunion l₂)</code></p>

<a name="130975700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130975700" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130975700">Sean Leather (Aug 06 2018 at 12:33)</a>:</h4>
<p>Got that, thanks. How should I coerce the 0 (<code>multiset.zero</code>) for <code>kunion' 0 ↑l</code>?</p>

<a name="130975782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130975782" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130975782">Sean Leather (Aug 06 2018 at 12:35)</a>:</h4>
<p>If I do <code>simp [has_zero.zero, multiset.zero]</code>, lean never ends.</p>

<a name="130975852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130975852" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130975852">Mario Carneiro (Aug 06 2018 at 12:37)</a>:</h4>
<p>you can just force it to unfold by applying <code>kunion_coe.trans _</code></p>

<a name="130975886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130975886" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130975886">Mario Carneiro (Aug 06 2018 at 12:37)</a>:</h4>
<p>or you can rewrite with <code>coe_nil_eq_zero</code></p>

<a name="130980496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130980496" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130980496">Sean Leather (Aug 06 2018 at 14:05)</a>:</h4>
<p>The aforementioned theorems:</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">zero_kunion</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">m</span><span class="bp">.</span><span class="n">nodup_keys</span><span class="o">),</span> <span class="n">kunion&#39;</span> <span class="mi">0</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">roption</span><span class="bp">.</span><span class="n">some</span> <span class="n">m</span> <span class="o">:=</span>
<span class="n">quotient</span><span class="bp">.</span><span class="n">induction_on</span> <span class="n">m</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="n">d</span><span class="o">,</span> <span class="o">(</span><span class="n">kunion_coe</span> <span class="n">nodup_keys_zero</span> <span class="n">d</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="n">rfl</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">kunion_zero</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">m</span><span class="bp">.</span><span class="n">nodup_keys</span><span class="o">),</span> <span class="n">kunion&#39;</span> <span class="n">m</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">roption</span><span class="bp">.</span><span class="n">some</span> <span class="n">m</span> <span class="o">:=</span>
<span class="n">quotient</span><span class="bp">.</span><span class="n">induction_on</span> <span class="n">m</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="n">d</span><span class="o">,</span> <span class="o">(</span><span class="n">kunion_coe</span> <span class="n">d</span> <span class="n">nodup_keys_zero</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="k">by</span> <span class="n">simp</span><span class="o">)</span>
</pre></div>

<a name="130981382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130981382" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130981382">Sean Leather (Aug 06 2018 at 14:21)</a>:</h4>
<p>One last related question: Now that I have an <code>roption</code>-wrapped <code>multiset</code>, how should I specify theorems that involve the result of <code>kunion'</code>? For example, I had:</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">mem_kunion</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">sigma</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">d₁</span> <span class="o">:</span> <span class="n">m₁</span><span class="bp">.</span><span class="n">nodup_keys</span><span class="o">)</span> <span class="o">(</span><span class="n">d₂</span> <span class="o">:</span> <span class="n">m₂</span><span class="bp">.</span><span class="n">nodup_keys</span><span class="o">),</span>
  <span class="n">disjoint</span> <span class="n">m₁</span><span class="bp">.</span><span class="n">keys</span> <span class="n">m₂</span><span class="bp">.</span><span class="n">keys</span> <span class="bp">→</span> <span class="o">(</span><span class="n">s</span> <span class="err">∈</span> <span class="n">d₁</span> <span class="n">k</span><span class="err">∪</span> <span class="n">d₂</span> <span class="bp">↔</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">m₁</span> <span class="bp">∨</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">m₂</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">quotient</span><span class="bp">.</span><span class="n">induction_on₂</span> <span class="n">m₁</span> <span class="n">m₂</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">mem_kunion_iff</span>
</pre></div>


<p>Should this become...?</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">mem_kunion&#39;</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">sigma</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">d₁</span> <span class="o">:</span> <span class="n">m₁</span><span class="bp">.</span><span class="n">nodup_keys</span><span class="o">)</span> <span class="o">(</span><span class="n">d₂</span> <span class="o">:</span> <span class="n">m₂</span><span class="bp">.</span><span class="n">nodup_keys</span><span class="o">),</span>
  <span class="n">disjoint</span> <span class="n">m₁</span><span class="bp">.</span><span class="n">keys</span> <span class="n">m₂</span><span class="bp">.</span><span class="n">keys</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">m</span> <span class="err">∈</span> <span class="n">kunion&#39;</span> <span class="n">m₁</span> <span class="n">m₂</span><span class="o">,</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">m</span> <span class="bp">↔</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">m₁</span> <span class="bp">∨</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">m₂</span> <span class="o">:=</span>
<span class="n">quotient</span><span class="bp">.</span><span class="n">induction_on₂</span> <span class="n">m₁</span> <span class="n">m₂</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="n">d₁</span> <span class="n">d₂</span> <span class="n">dk</span><span class="o">,</span>
  <span class="bp">⟨_</span><span class="o">,</span> <span class="n">roption</span><span class="bp">.</span><span class="n">eq_some_iff</span><span class="bp">.</span><span class="n">mp</span> <span class="o">(</span><span class="n">kunion_coe</span> <span class="n">d₁</span> <span class="n">d₂</span><span class="o">),</span> <span class="n">mem_kunion_iff</span> <span class="n">dk</span><span class="bp">⟩</span>
</pre></div>


<p>Specifically, I mean: should I use a pattern like <code>∃ m ∈ kunion' m₁ m₂, ...</code> for theorems like this, or is there a better way?</p>

<a name="130982225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130982225" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130982225">Mario Carneiro (Aug 06 2018 at 14:35)</a>:</h4>
<p>I would take <code>m ∈ kunion' m₁ m₂</code> as a hypothesis and prove <code>s ∈ m ↔ s ∈ m₁ ∨ s ∈ m₂</code></p>

<a name="130982297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130982297" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130982297">Mario Carneiro (Aug 06 2018 at 14:36)</a>:</h4>
<p>of course this hypothesis eliminates the need for d1 and d2</p>

<a name="130982374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130982374" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130982374">Mario Carneiro (Aug 06 2018 at 14:37)</a>:</h4>
<p>alternatively, you can define <code>kunion</code> as <code>(kunion' m1 m2).get &lt;d1, d2&gt;</code> and have all your old theorems back</p>

<a name="130991221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130991221" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130991221">Sean Leather (Aug 06 2018 at 17:07)</a>:</h4>
<p>True. I'm not sure which is a better definition to work with. If I were using the <code>multiset</code> interface directly, I would lean towards defining <code>kunion</code> as <code>(kunion' m1 m2).get &lt;d1, d2&gt;</code>. But since it's really meant to be the underlying implementation of <code>finmap</code>, perhaps it's not necessary.</p>

<a name="130991299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130991299" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130991299">Sean Leather (Aug 06 2018 at 17:08)</a>:</h4>
<p>Also, do you think I should use <code>roption</code> + <code>quotient.lift_on</code> consistently instead of <code>quotient.hrec_on</code>? I don't have any more uses of <code>quotient.hrec_on₂</code>, but I do have a number of uses of <code>quotient.hrec_on</code>.</p>

<a name="131028609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131028609" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131028609">Sean Leather (Aug 07 2018 at 07:50)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> I'd like to get your thoughts on this <span class="emoji emoji-1f446" title="point up">:point_up:</span>. I haven't had any problems with <code>quotient.hrec_on</code> up to now, but maybe things would just be nicer all around if I used <code>roption</code> more. I'm not sure.</p>

<a name="131028618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131028618" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131028618">Mario Carneiro (Aug 07 2018 at 07:51)</a>:</h4>
<p>I think if it works once, it will probably work again</p>

<a name="131028672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131028672" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131028672">Mario Carneiro (Aug 07 2018 at 07:52)</a>:</h4>
<p>Also, another option I forgot to mention was to make <code>kunion</code> a nondependent function, using the fact that <code>nodup_keys</code> is decidable</p>

<a name="131028674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131028674" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131028674">Sean Leather (Aug 07 2018 at 07:52)</a>:</h4>
<p>Just to be clear about what you mean, do you think I should change the defs <a href="https://github.com/spl/lean-finmap/blob/fb3f562de05059f136f855b88bf616c8aac7f365/src/data/multiset/dict.lean" target="_blank" title="https://github.com/spl/lean-finmap/blob/fb3f562de05059f136f855b88bf616c8aac7f365/src/data/multiset/dict.lean">here</a> to use <code>roption</code>?</p>

<a name="131028693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131028693" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131028693">Sean Leather (Aug 07 2018 at 07:53)</a>:</h4>
<p>(Just search for <code>hrec_on</code>.)</p>

<a name="131028697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131028697" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131028697">Mario Carneiro (Aug 07 2018 at 07:53)</a>:</h4>
<p>Even if we suppose that checking this is expensive, it doesn't matter if you are just using it as an abstract version so you can prove equations about it</p>

<a name="131028702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131028702" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131028702">Sean Leather (Aug 07 2018 at 07:53)</a>:</h4>
<blockquote>
<p>Also, another option I forgot to mention was to make <code>kunion</code> a nondependent function, using the fact that <code>nodup_keys</code> is decidable</p>
</blockquote>
<p>What do you mean by this?</p>

<a name="131028797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131028797" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131028797">Mario Carneiro (Aug 07 2018 at 07:55)</a>:</h4>
<p>define <code>kunion m1 m2 = if h : m1.nodup_keys /\ m2.nodup_keys then (kunion' m1 m2).get h else 0</code></p>

<a name="131028858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131028858" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131028858">Sean Leather (Aug 07 2018 at 07:56)</a>:</h4>
<p>That's an interesting suggestion.</p>

<a name="131028874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131028874" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131028874">Mario Carneiro (Aug 07 2018 at 07:57)</a>:</h4>
<p>in fact, even if <code>nodup_keys</code> wasn't decidable you could make this definition anyway noncomputably and just not use it for evaluation</p>

<a name="131029010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029010" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029010">Sean Leather (Aug 07 2018 at 08:00)</a>:</h4>
<p>Hmm, yes, I think I like this definition of <code>kunion</code>. I don't have to pass around the <code>m1.nodup_keys</code> everywhere.</p>

<a name="131029031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029031" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029031">Sean Leather (Aug 07 2018 at 08:01)</a>:</h4>
<p>Okay, well, I'll play around with it.</p>

<a name="131029032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029032" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029032">Mario Carneiro (Aug 07 2018 at 08:01)</a>:</h4>
<p>Yet more alternatively, you could define the subtype. Didn't you have <code>finmap</code> at one point for this?</p>

<a name="131029090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029090" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029090">Sean Leather (Aug 07 2018 at 08:02)</a>:</h4>
<p>I decided to go with the <code>structure</code> for the same reasons <code>finset</code> is a <code>structure</code>:</p>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">finmap</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">val</span> <span class="o">:</span> <span class="n">multiset</span> <span class="o">(</span><span class="n">sigma</span> <span class="n">β</span><span class="o">))</span>
<span class="o">(</span><span class="n">nodup_keys</span> <span class="o">:</span> <span class="n">val</span><span class="bp">.</span><span class="n">nodup_keys</span><span class="o">)</span>
</pre></div>

<a name="131029097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029097" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029097">Sean Leather (Aug 07 2018 at 08:02)</a>:</h4>
<p>Mainly, for type class instance resolution.</p>

<a name="131029099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029099" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029099">Mario Carneiro (Aug 07 2018 at 08:03)</a>:</h4>
<p>that's fine, my point was that you can define <code>finmap.rec_on</code> to encapsulate this definition pattern</p>

<a name="131029112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029112" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029112">Mario Carneiro (Aug 07 2018 at 08:03)</a>:</h4>
<p>and this way you never have to carry around any proofs since they are embedded in the type</p>

<a name="131029158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029158" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029158">Sean Leather (Aug 07 2018 at 08:04)</a>:</h4>
<p>You mean the <code>if h : m.nodup_keys ... then ... else ...</code> pattern?</p>

<a name="131029160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029160" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029160">Mario Carneiro (Aug 07 2018 at 08:04)</a>:</h4>
<p>no, the <code>roption</code> or <code>hrec_on</code> version</p>

<a name="131029167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029167" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029167">Mario Carneiro (Aug 07 2018 at 08:04)</a>:</h4>
<p>(it doesn't really matter too much which one you use, since it only has to be done once)</p>

<a name="131029228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029228" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029228">Sean Leather (Aug 07 2018 at 08:06)</a>:</h4>
<p>Oh.... I'm awfully dumb today. So, define a <code>finmap.rec_on</code> that takes an <code>roption (multiset (sigma β))</code> to a <code>finmap</code>?</p>

<a name="131029236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029236" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029236">Sean Leather (Aug 07 2018 at 08:07)</a>:</h4>
<p>Err, actually the arrow goes the other way...</p>

<a name="131029244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029244" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029244">Sean Leather (Aug 07 2018 at 08:07)</a>:</h4>
<p>Anyway, it'd be a higher-order function.</p>

<a name="131029247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029247" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029247">Sean Leather (Aug 07 2018 at 08:07)</a>:</h4>
<p>Yeah, I think I see it.</p>

<a name="131029289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029289" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029289">Mario Carneiro (Aug 07 2018 at 08:08)</a>:</h4>
<p><code>finmap.rec_on</code> takes a <code>finmap A B</code>, a function <code>list (sigma B) -&gt; C</code>, and a proof that this function is equal up to permutation when the arguments have <code>nodup_keys</code></p>

<a name="131029296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029296" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029296">Sean Leather (Aug 07 2018 at 08:08)</a>:</h4>
<p>Right.</p>

<a name="131029372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029372" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029372">Sean Leather (Aug 07 2018 at 08:10)</a>:</h4>
<p>So, given that, I would be skipping defining all of the defs and theorems for <code>multiset</code> and define them for only <code>list</code> and <code>finmap</code>?</p>

<a name="131029445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029445" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029445">Mario Carneiro (Aug 07 2018 at 08:13)</a>:</h4>
<p>right</p>

<a name="131029450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029450" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029450">Mario Carneiro (Aug 07 2018 at 08:13)</a>:</h4>
<p>You can reconstruct the multiset definitions from the finmap ones by the <code>if ... else 0</code> trick</p>

<a name="131029516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029516" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029516">Mario Carneiro (Aug 07 2018 at 08:15)</a>:</h4>
<p>I think multisets are a good stepping stone if you can actually define functions on them, but in your case the functions already have to assume nodup just to be well defined, so they've already jumped to finmap</p>

<a name="131029523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029523" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029523">Sean Leather (Aug 07 2018 at 08:15)</a>:</h4>
<p>That's true.</p>

<a name="131029576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029576" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029576">Sean Leather (Aug 07 2018 at 08:17)</a>:</h4>
<p>Okay, I'm convinced.</p>

<a name="131029713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029713" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029713">Mario Carneiro (Aug 07 2018 at 08:20)</a>:</h4>
<p>I notice you have theorems like <code> s.1 ∈ (m.map_snd f).keys ↔ s.1 ∈ m.keys</code> with several variations. Why isn't this just <code>(m.map_snd f).keys = m.keys</code>?</p>

<a name="131029750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029750" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029750">Sean Leather (Aug 07 2018 at 08:21)</a>:</h4>
<p>Because I use the <code>mem</code> one in the non-<code>mem</code>.</p>

<a name="131029791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029791" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029791">Sean Leather (Aug 07 2018 at 08:22)</a>:</h4>
<p>I suppose I don't have to.</p>

<a name="131029808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029808" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029808">Mario Carneiro (Aug 07 2018 at 08:23)</a>:</h4>
<p>the proof is just <code>map_comp</code></p>

<a name="131029819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029819" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029819">Mario Carneiro (Aug 07 2018 at 08:23)</a>:</h4>
<p>you shouldn't use <code>mem</code> to try to characterize a multiset, it gets messy</p>

<a name="131029874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029874" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029874">Sean Leather (Aug 07 2018 at 08:25)</a>:</h4>
<p>The other problem with the <code>map_snd</code>/<code>keys</code> theorems is that I wanted to use it in <code>finmap</code>, but the best I could come up with was using <code>[inhabited (∀ a, β₁ a)]</code>. I'm not happy with that solution.</p>

<a name="131029887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029887" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029887">Sean Leather (Aug 07 2018 at 08:25)</a>:</h4>
<blockquote>
<p>the proof is just <code>map_comp</code></p>
</blockquote>
<p>The proof of which?</p>

<a name="131029966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029966" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029966">Mario Carneiro (Aug 07 2018 at 08:27)</a>:</h4>
<p>I'm really confused about your confusion. It should be provable that <code>(m.map_snd f).keys = m.keys</code>, this makes the last 7 theorems or so unnecessary and it doesn't require any weird assumptions</p>

<a name="131030141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131030141" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131030141">Sean Leather (Aug 07 2018 at 08:31)</a>:</h4>
<p>Okay, I think I see what you're saying. I'll give it a shot.</p>

<a name="131030157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131030157" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131030157">Mario Carneiro (Aug 07 2018 at 08:31)</a>:</h4>
<p>wait, just the last 4. The ones about <code>(m.map f).keys</code> are a bit awkward because <code>f : sigma B1 -&gt; sigma B2</code> can mingle keys and values in an unpredictable way. How about defining <code>m.map f g</code> where <code>f : A1 -&gt; A2</code> and <code>g : ∀ a, B1 a -&gt; B2 (f a)</code>; then you should be able to prove <code>(m.map f g).keys = m.keys.map f</code> and life is good</p>

<a name="131030231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131030231" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131030231">Sean Leather (Aug 07 2018 at 08:33)</a>:</h4>
<p>Btw, did you mean <code>map_map</code> instead of <code>map_comp</code>?</p>

<a name="131030275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131030275" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131030275">Mario Carneiro (Aug 07 2018 at 08:34)</a>:</h4>
<p>yes</p>

<a name="131030288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131030288" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131030288">Mario Carneiro (Aug 07 2018 at 08:34)</a>:</h4>
<p>it's written backwards for simp lemmas because <code>comp</code> is dumb</p>

<a name="131030292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131030292" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131030292">Mario Carneiro (Aug 07 2018 at 08:34)</a>:</h4>
<p>so the name becomes <code>map_map</code> instead of <code>map_comp</code></p>

<a name="131093639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131093639" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131093639">Sean Leather (Aug 08 2018 at 07:53)</a>:</h4>
<p>I could only figure out how to do a general 2-arg <code>finmap</code> recursor using <code>quotient.hrec_on₂</code>:</p>
<div class="codehilite"><pre><span></span><span class="kn">protected</span> <span class="n">def</span> <span class="n">lrec_on₂</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">finmap</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span>
  <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">sigma</span> <span class="n">β</span><span class="o">)},</span> <span class="n">l₁</span><span class="bp">.</span><span class="n">nodup_keys</span> <span class="bp">→</span> <span class="n">l₂</span><span class="bp">.</span><span class="n">nodup_keys</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="n">l₃</span> <span class="n">l₄</span><span class="o">}</span> <span class="o">(</span><span class="n">p₁₃</span> <span class="o">:</span> <span class="n">l₁</span> <span class="bp">~</span> <span class="n">l₃</span><span class="o">)</span> <span class="o">(</span><span class="n">p₂₄</span> <span class="o">:</span> <span class="n">l₂</span> <span class="bp">~</span> <span class="n">l₄</span><span class="o">)</span> <span class="n">d₁</span> <span class="n">d₂</span> <span class="n">d₃</span> <span class="n">d₄</span><span class="o">,</span> <span class="n">φ</span> <span class="n">d₁</span> <span class="n">d₂</span> <span class="bp">=</span> <span class="n">φ</span> <span class="n">d₃</span> <span class="n">d₄</span><span class="o">)</span> <span class="o">:</span> <span class="n">γ</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">quotient</span><span class="bp">.</span><span class="n">hrec_on₂</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m₁</span> <span class="n">m₂</span> <span class="o">:</span> <span class="n">multiset</span> <span class="o">(</span><span class="n">sigma</span> <span class="n">β</span><span class="o">)),</span> <span class="n">m₁</span><span class="bp">.</span><span class="n">nodup_keys</span> <span class="bp">→</span> <span class="n">m₂</span><span class="bp">.</span><span class="n">nodup_keys</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span>
  <span class="n">f</span><span class="bp">.</span><span class="n">val</span> <span class="n">g</span><span class="bp">.</span><span class="n">val</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="o">(</span><span class="n">d₁</span> <span class="o">:</span> <span class="n">l₁</span><span class="bp">.</span><span class="n">nodup_keys</span><span class="o">)</span> <span class="o">(</span><span class="n">d₂</span> <span class="o">:</span> <span class="n">l₂</span><span class="bp">.</span><span class="n">nodup_keys</span><span class="o">),</span> <span class="n">φ</span> <span class="n">d₁</span> <span class="n">d₂</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="n">l₃</span> <span class="n">l₄</span> <span class="n">p₁₃</span> <span class="n">p₂₄</span><span class="o">,</span> <span class="n">hfunext</span> <span class="o">(</span><span class="k">by</span> <span class="n">rw</span> <span class="n">list</span><span class="bp">.</span><span class="n">perm_nodup_keys</span> <span class="n">p₁₃</span><span class="o">)</span> <span class="err">$</span>
    <span class="bp">λ</span> <span class="n">d₁</span> <span class="n">d₃</span> <span class="bp">_</span><span class="o">,</span> <span class="n">hfunext</span> <span class="o">(</span><span class="k">by</span> <span class="n">rw</span> <span class="n">list</span><span class="bp">.</span><span class="n">perm_nodup_keys</span> <span class="n">p₂₄</span><span class="o">)</span> <span class="err">$</span>
      <span class="bp">λ</span> <span class="n">d₂</span> <span class="n">d₄</span> <span class="bp">_</span><span class="o">,</span> <span class="n">heq_of_eq</span> <span class="err">$</span> <span class="n">c</span> <span class="n">p₁₃</span> <span class="n">p₂₄</span> <span class="n">d₁</span> <span class="n">d₂</span> <span class="n">d₃</span> <span class="n">d₄</span><span class="o">)</span>
  <span class="n">f</span><span class="bp">.</span><span class="n">nodup_keys</span> <span class="n">g</span><span class="bp">.</span><span class="n">nodup_keys</span>
</pre></div>


<p>I have a general 2-arg <code>finmap.lift_on₂</code>:</p>
<div class="codehilite"><pre><span></span><span class="kn">protected</span> <span class="n">def</span> <span class="n">lift_on₂</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">finmap</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span>
  <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">sigma</span> <span class="n">β</span><span class="o">)},</span> <span class="n">l₁</span><span class="bp">.</span><span class="n">nodup_keys</span> <span class="bp">→</span> <span class="n">l₂</span><span class="bp">.</span><span class="n">nodup_keys</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="n">l₃</span> <span class="n">l₄</span><span class="o">}</span> <span class="o">(</span><span class="n">p₁₃</span> <span class="o">:</span> <span class="n">l₁</span> <span class="bp">~</span> <span class="n">l₃</span><span class="o">)</span> <span class="o">(</span><span class="n">p₂₄</span> <span class="o">:</span> <span class="n">l₂</span> <span class="bp">~</span> <span class="n">l₄</span><span class="o">)</span> <span class="n">d₁</span> <span class="n">d₂</span> <span class="n">d₃</span> <span class="n">d₄</span><span class="o">,</span> <span class="n">φ</span> <span class="n">d₁</span> <span class="n">d₂</span> <span class="bp">=</span> <span class="n">φ</span> <span class="n">d₃</span> <span class="n">d₄</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">roption</span> <span class="n">γ</span> <span class="o">:=</span>
<span class="n">quotient</span><span class="bp">.</span><span class="n">lift_on₂</span> <span class="n">f</span><span class="bp">.</span><span class="n">val</span> <span class="n">g</span><span class="bp">.</span><span class="n">val</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">l₁</span> <span class="n">l₂</span><span class="o">,</span> <span class="n">roption</span><span class="bp">.</span><span class="n">mk</span> <span class="o">(</span><span class="n">l₁</span><span class="bp">.</span><span class="n">nodup_keys</span> <span class="bp">∧</span> <span class="n">l₂</span><span class="bp">.</span><span class="n">nodup_keys</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">⟨</span><span class="n">d₁</span><span class="o">,</span> <span class="n">d₂</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">φ</span> <span class="n">d₁</span> <span class="n">d₂</span><span class="o">))</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="n">l₃</span> <span class="n">l₄</span> <span class="n">p₁₃</span> <span class="n">p₂₄</span><span class="o">,</span> <span class="n">roption</span><span class="bp">.</span><span class="n">ext&#39;</span>
    <span class="o">(</span><span class="n">and_congr</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">perm_nodup_keys</span> <span class="n">p₁₃</span><span class="o">)</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">perm_nodup_keys</span> <span class="n">p₂₄</span><span class="o">))</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="bp">⟨</span><span class="n">d₁</span><span class="o">,</span> <span class="n">d₂</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">d₃</span><span class="o">,</span> <span class="n">d₄</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">c</span> <span class="n">p₁₃</span> <span class="n">p₂₄</span> <span class="n">d₁</span> <span class="n">d₂</span> <span class="n">d₃</span> <span class="n">d₄</span><span class="o">))</span>
</pre></div>


<p>But it seems like the <code>roption.dom</code> has a pair of lists, so this only seems useful in combination with <code>quotient.induction_on₂</code>. Is that right? Or can I do better?</p>

<a name="131094611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131094611" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131094611">Mario Carneiro (Aug 08 2018 at 08:24)</a>:</h4>
<p>What does the one arg version look like?</p>

<a name="131094622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131094622" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131094622">Sean Leather (Aug 08 2018 at 08:25)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">protected</span> <span class="n">def</span> <span class="n">lrec_on</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">finmap</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span>
  <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">sigma</span> <span class="n">β</span><span class="o">)},</span> <span class="n">l</span><span class="bp">.</span><span class="n">nodup_keys</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">l₁</span> <span class="n">l₂</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">l₁</span> <span class="bp">~</span> <span class="n">l₂</span><span class="o">)</span> <span class="n">d₁</span> <span class="n">d₂</span><span class="o">,</span> <span class="n">φ</span> <span class="n">d₁</span> <span class="bp">=</span> <span class="n">φ</span> <span class="n">d₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">γ</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">quotient</span><span class="bp">.</span><span class="n">hrec_on</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">multiset</span> <span class="o">(</span><span class="n">sigma</span> <span class="n">β</span><span class="o">)),</span> <span class="n">m</span><span class="bp">.</span><span class="n">nodup_keys</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span>
  <span class="n">f</span><span class="bp">.</span><span class="n">val</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">l</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">l</span><span class="bp">.</span><span class="n">nodup_keys</span><span class="o">),</span> <span class="n">φ</span> <span class="n">d</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="n">p</span><span class="o">,</span> <span class="n">hfunext</span> <span class="o">(</span><span class="k">by</span> <span class="n">rw</span> <span class="n">list</span><span class="bp">.</span><span class="n">perm_nodup_keys</span> <span class="n">p</span><span class="o">)</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">d₁</span> <span class="n">d₂</span> <span class="bp">_</span><span class="o">,</span> <span class="n">heq_of_eq</span> <span class="err">$</span> <span class="n">c</span> <span class="n">p</span> <span class="n">d₁</span> <span class="n">d₂</span><span class="o">)</span>
  <span class="n">f</span><span class="bp">.</span><span class="n">nodup_keys</span>
</pre></div>

<a name="131094845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131094845" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131094845">Sean Leather (Aug 08 2018 at 08:30)</a>:</h4>
<p>There are theorems where <code>quotient.induction_on₂</code> needs more than just <code>l₁.nodup_keys</code> and <code>l₂.nodup_keys</code>:</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">mem_kunion&#39;</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">sigma</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">d₁</span> <span class="o">:</span> <span class="n">m₁</span><span class="bp">.</span><span class="n">nodup_keys</span><span class="o">)</span> <span class="o">(</span><span class="n">d₂</span> <span class="o">:</span> <span class="n">m₂</span><span class="bp">.</span><span class="n">nodup_keys</span><span class="o">),</span>
  <span class="n">disjoint</span> <span class="n">m₁</span><span class="bp">.</span><span class="n">keys</span> <span class="n">m₂</span><span class="bp">.</span><span class="n">keys</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">m</span> <span class="err">∈</span> <span class="n">kunion&#39;</span> <span class="n">m₁</span> <span class="n">m₂</span><span class="o">,</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">m</span> <span class="bp">↔</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">m₁</span> <span class="bp">∨</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">m₂</span> <span class="o">:=</span>
<span class="n">quotient</span><span class="bp">.</span><span class="n">induction_on₂</span> <span class="n">m₁</span> <span class="n">m₂</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="n">d₁</span> <span class="n">d₂</span> <span class="n">dk</span><span class="o">,</span>
  <span class="bp">⟨_</span><span class="o">,</span> <span class="n">roption</span><span class="bp">.</span><span class="n">eq_some_iff</span><span class="bp">.</span><span class="n">mp</span> <span class="o">(</span><span class="n">kunion_coe</span> <span class="n">d₁</span> <span class="n">d₂</span><span class="o">),</span> <span class="n">mem_kunion_iff</span> <span class="n">dk</span><span class="bp">⟩</span>
</pre></div>


<p>So, I think the above <code>finmap.lift_on₂</code> definition makes sense.</p>

<a name="131098994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131098994" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131098994">Mario Carneiro (Aug 08 2018 at 10:10)</a>:</h4>
<p>I would suggest you state <code>lrec_on</code> like this:</p>
<div class="codehilite"><pre><span></span>protected def lrec_on {γ : Sort*} (f : finmap α β)
  (φ : list (sigma β) → γ)
  (c : ∀ {l₁ l₂} (p : l₁ ~ l₂), l₁.nodup_keys → l₂.nodup_keys → φ l₁ = φ l₂) : γ :=
</pre></div>


<p>Recall that we are trying to avoid partial functions. The function <code>φ</code> is defined on lists, so there presumably won't be any trouble making arbitrary choices that depend on the order</p>

<a name="131099010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131099010" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131099010">Mario Carneiro (Aug 08 2018 at 10:11)</a>:</h4>
<p>Given this it should not be hard to just iterate it twice to get <code>lrec_on₂</code></p>

<a name="131103716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131103716" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131103716">Sean Leather (Aug 08 2018 at 12:04)</a>:</h4>
<p>Okay, so I have the following.</p>
<p>My initial version:</p>
<div class="codehilite"><pre><span></span><span class="kn">protected</span> <span class="n">def</span> <span class="n">lrec_on</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">finmap</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span>
  <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">sigma</span> <span class="n">β</span><span class="o">)},</span> <span class="n">l</span><span class="bp">.</span><span class="n">nodup_keys</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">l₁</span> <span class="n">l₂</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">l₁</span> <span class="bp">~</span> <span class="n">l₂</span><span class="o">)</span> <span class="n">d₁</span> <span class="n">d₂</span><span class="o">,</span> <span class="n">φ</span> <span class="n">d₁</span> <span class="bp">=</span> <span class="n">φ</span> <span class="n">d₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">γ</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">quotient</span><span class="bp">.</span><span class="n">hrec_on</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">multiset</span> <span class="o">(</span><span class="n">sigma</span> <span class="n">β</span><span class="o">)),</span> <span class="n">m</span><span class="bp">.</span><span class="n">nodup_keys</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span>
  <span class="n">f</span><span class="bp">.</span><span class="n">val</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">l</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">l</span><span class="bp">.</span><span class="n">nodup_keys</span><span class="o">),</span> <span class="n">φ</span> <span class="n">d</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="n">p</span><span class="o">,</span> <span class="n">hfunext</span> <span class="o">(</span><span class="k">by</span> <span class="n">rw</span> <span class="n">list</span><span class="bp">.</span><span class="n">perm_nodup_keys</span> <span class="n">p</span><span class="o">)</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">d₁</span> <span class="n">d₂</span> <span class="bp">_</span><span class="o">,</span> <span class="n">heq_of_eq</span> <span class="err">$</span> <span class="n">c</span> <span class="n">p</span> <span class="n">d₁</span> <span class="n">d₂</span><span class="o">)</span>
  <span class="n">f</span><span class="bp">.</span><span class="n">nodup_keys</span>

<span class="n">def</span> <span class="n">erase</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">finmap</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">finmap</span> <span class="n">α</span> <span class="n">β</span> <span class="o">:=</span>
<span class="n">finmap</span><span class="bp">.</span><span class="n">lrec_on</span> <span class="n">f</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">l</span> <span class="n">d</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">l</span><span class="bp">.</span><span class="n">kerase</span> <span class="n">a</span><span class="o">,</span> <span class="n">list</span><span class="bp">.</span><span class="n">nodup_keys_kerase</span> <span class="n">a</span> <span class="n">d</span><span class="bp">⟩</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="n">p</span> <span class="n">d₁</span> <span class="n">d₂</span><span class="o">,</span> <span class="n">eq_of_veq</span> <span class="err">$</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">sound</span> <span class="err">$</span> <span class="n">list</span><span class="bp">.</span><span class="n">perm_kerase</span> <span class="n">a</span> <span class="n">d₁</span> <span class="n">d₂</span> <span class="n">p</span><span class="o">)</span>
</pre></div>


<p>Your suggestion:</p>
<div class="codehilite"><pre><span></span><span class="kn">protected</span> <span class="n">def</span> <span class="n">lrec_on&#39;</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">finmap</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span>
  <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">sigma</span> <span class="n">β</span><span class="o">)</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">l₁</span> <span class="n">l₂</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">l₁</span> <span class="bp">~</span> <span class="n">l₂</span><span class="o">),</span> <span class="n">l₁</span><span class="bp">.</span><span class="n">nodup_keys</span> <span class="bp">→</span> <span class="n">l₂</span><span class="bp">.</span><span class="n">nodup_keys</span> <span class="bp">→</span> <span class="n">φ</span> <span class="n">l₁</span> <span class="bp">=</span> <span class="n">φ</span> <span class="n">l₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">γ</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">quotient</span><span class="bp">.</span><span class="n">hrec_on</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">multiset</span> <span class="o">(</span><span class="n">sigma</span> <span class="n">β</span><span class="o">)),</span> <span class="n">m</span><span class="bp">.</span><span class="n">nodup_keys</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span>
  <span class="n">f</span><span class="bp">.</span><span class="n">val</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">l</span> <span class="bp">_</span><span class="o">,</span> <span class="n">φ</span> <span class="n">l</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="n">p</span><span class="o">,</span> <span class="n">hfunext</span> <span class="o">(</span><span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">list</span><span class="bp">.</span><span class="n">perm_nodup_keys</span> <span class="n">p</span><span class="o">])</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">d₁</span> <span class="n">d₂</span> <span class="bp">_</span><span class="o">,</span> <span class="n">heq_of_eq</span> <span class="err">$</span> <span class="n">c</span> <span class="n">p</span> <span class="n">d₁</span> <span class="n">d₂</span><span class="o">)</span>
  <span class="n">f</span><span class="bp">.</span><span class="n">nodup_keys</span>

<span class="n">def</span> <span class="n">erase&#39;</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">finmap</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">finmap</span> <span class="n">α</span> <span class="n">β</span> <span class="o">:=</span>
<span class="n">finmap</span><span class="bp">.</span><span class="n">lrec_on&#39;</span> <span class="n">f</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">l</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">l</span><span class="bp">.</span><span class="n">kerase</span> <span class="n">a</span><span class="o">,</span> <span class="n">list</span><span class="bp">.</span><span class="n">nodup_keys_kerase</span> <span class="n">a</span> <span class="bp">_⟩</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="n">p</span> <span class="n">d₁</span> <span class="n">d₂</span><span class="o">,</span> <span class="n">eq_of_veq</span> <span class="err">$</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">sound</span> <span class="err">$</span> <span class="n">list</span><span class="bp">.</span><span class="n">perm_kerase</span> <span class="n">a</span> <span class="n">d₁</span> <span class="n">d₂</span> <span class="n">p</span><span class="o">)</span>
</pre></div>


<p>I can define <code>erase</code> with <code>lrec_on</code>, but how do I define <code>erase'</code> with <code>lrec_on'</code>?</p>
<div class="codehilite"><pre><span></span><span class="n">error</span><span class="o">:</span> <span class="n">don&#39;t</span> <span class="n">know</span> <span class="n">how</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">placeholder</span>
<span class="kn">context</span><span class="o">:</span>
<span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_1</span> <span class="o">:</span> <span class="n">decidable_eq</span> <span class="n">α</span><span class="o">,</span>
<span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">,</span>
<span class="n">f</span> <span class="o">:</span> <span class="n">finmap</span> <span class="n">α</span> <span class="n">β</span><span class="o">,</span>
<span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span>
<span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">sigma</span> <span class="n">β</span><span class="o">)</span>
<span class="err">⊢</span> <span class="n">list</span><span class="bp">.</span><span class="n">nodup_keys</span> <span class="n">l</span>
</pre></div>


{% endraw %}

{% include archive_update.html %}