---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/87308quotienthrecon.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html">quotient.hrec_on₂</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="130971695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130971695" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130971695">Sean Leather (Aug 06 2018 at 21:09)</a>:</h4>
<p>I've got a <a href="https://github.com/spl/lean-finmap/blob/fb3f562de05059f136f855b88bf616c8aac7f365/src/data/multiset/dict.lean#L162-L172" target="_blank" title="https://github.com/spl/lean-finmap/blob/fb3f562de05059f136f855b88bf616c8aac7f365/src/data/multiset/dict.lean#L162-L172">definition</a>:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">kunion</span> <span class="o">:</span> <span class="n">m₁</span><span class="bp">.</span><span class="n">nodup_keys</span> <span class="bp">→</span> <span class="n">m₂</span><span class="bp">.</span><span class="n">nodup_keys</span> <span class="bp">→</span> <span class="n">multiset</span> <span class="o">(</span><span class="n">sigma</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">quotient</span><span class="bp">.</span><span class="n">hrec_on₂</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m₁</span> <span class="n">m₂</span> <span class="o">:</span> <span class="n">multiset</span> <span class="o">(</span><span class="n">sigma</span> <span class="n">β</span><span class="o">)),</span> <span class="n">m₁</span><span class="bp">.</span><span class="n">nodup_keys</span> <span class="bp">→</span> <span class="n">m₂</span><span class="bp">.</span><span class="n">nodup_keys</span> <span class="bp">→</span> <span class="n">multiset</span> <span class="o">(</span><span class="n">sigma</span> <span class="n">β</span><span class="o">))</span>
  <span class="n">m₁</span> <span class="n">m₂</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="o">(</span><span class="n">d₁</span> <span class="o">:</span> <span class="n">l₁</span><span class="bp">.</span><span class="n">nodup_keys</span><span class="o">)</span> <span class="o">(</span><span class="n">d₂</span> <span class="o">:</span> <span class="n">l₂</span><span class="bp">.</span><span class="n">nodup_keys</span><span class="o">),</span> <span class="n">l₁</span><span class="bp">.</span><span class="n">kunion</span> <span class="n">l₂</span><span class="o">)</span> <span class="err">$</span>
    <span class="bp">λ</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="n">l₃</span> <span class="n">l₄</span> <span class="n">p₁₃</span> <span class="n">p₂₄</span><span class="o">,</span>
    <span class="n">hfunext</span> <span class="o">(</span><span class="k">by</span> <span class="n">rw</span> <span class="n">perm_nodup_keys</span> <span class="n">p₁₃</span><span class="o">)</span> <span class="err">$</span>
      <span class="bp">λ</span> <span class="o">(</span><span class="n">d₁</span> <span class="o">:</span> <span class="n">l₁</span><span class="bp">.</span><span class="n">nodup_keys</span><span class="o">)</span> <span class="o">(</span><span class="n">d₃</span> <span class="o">:</span> <span class="n">l₃</span><span class="bp">.</span><span class="n">nodup_keys</span><span class="o">)</span> <span class="bp">_</span><span class="o">,</span>
      <span class="n">hfunext</span> <span class="o">(</span><span class="k">by</span> <span class="n">rw</span> <span class="n">perm_nodup_keys</span> <span class="n">p₂₄</span><span class="o">)</span> <span class="err">$</span>
        <span class="bp">λ</span> <span class="o">(</span><span class="n">d₂</span> <span class="o">:</span> <span class="n">l₂</span><span class="bp">.</span><span class="n">nodup_keys</span><span class="o">)</span> <span class="o">(</span><span class="n">d₄</span> <span class="o">:</span> <span class="n">l₄</span><span class="bp">.</span><span class="n">nodup_keys</span><span class="o">)</span> <span class="bp">_</span><span class="o">,</span>
        <span class="n">heq_of_eq</span> <span class="err">$</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">sound</span> <span class="err">$</span> <span class="n">perm_kunion</span> <span class="n">d₂</span> <span class="n">d₄</span> <span class="n">p₁₃</span> <span class="n">p₂₄</span>

<span class="n">local</span> <span class="kn">infixr</span> <span class="bp">`</span> <span class="n">k</span><span class="err">∪</span> <span class="bp">`</span><span class="o">:</span><span class="mi">67</span> <span class="o">:=</span> <span class="n">kunion</span>
</pre></div>


<p>and I want to prove the left and right units:</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">zero_kunion</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">multiset</span> <span class="o">(</span><span class="n">sigma</span> <span class="n">β</span><span class="o">)}</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">m</span><span class="bp">.</span><span class="n">nodup_keys</span><span class="o">),</span> <span class="n">nodup_keys_zero</span> <span class="n">k</span><span class="err">∪</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">m</span>
<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">kunion_zero</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">multiset</span> <span class="o">(</span><span class="n">sigma</span> <span class="n">β</span><span class="o">)}</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">m</span><span class="bp">.</span><span class="n">nodup_keys</span><span class="o">),</span> <span class="n">d</span> <span class="n">k</span><span class="err">∪</span> <span class="n">nodup_keys_zero</span> <span class="bp">=</span> <span class="n">m</span>
</pre></div>


<p>I'm stuck on how to proceed. If I use <code>quotient.induction_on m</code>, I just unfold until I get down to <code>quot.rec_on ↑(hd :: tl)</code> or <code>quot.rec_on ↑nil</code>, but I don't know how to go further. (At one point, I believe I even made the simplifier loop infinitely.)</p>
<p>Any suggestions on how to prove these?</p>

<a name="130971867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130971867" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130971867">Mario Carneiro (Aug 06 2018 at 21:12)</a>:</h4>
<p>Wow, that's a weird notation</p>

<a name="130971872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130971872" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130971872">Mario Carneiro (Aug 06 2018 at 21:12)</a>:</h4>
<p>does it have to be a partial function?</p>

<a name="130971983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130971983" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130971983">Sean Leather (Aug 06 2018 at 21:15)</a>:</h4>
<blockquote>
<p>does it have to be a partial function?</p>
</blockquote>
<p>I don't follow you.</p>

<a name="130972034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130972034" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130972034">Mario Carneiro (Aug 06 2018 at 21:16)</a>:</h4>
<p>you could make it return empty when the inputs don't have <code>nodup_keys</code></p>

<a name="130972054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130972054" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130972054">Mario Carneiro (Aug 06 2018 at 21:17)</a>:</h4>
<p>or it could be a <code>roption</code> if you are worried about the performance cost of checking <code>nodup_keys</code></p>

<a name="130972218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130972218" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130972218">Sean Leather (Aug 06 2018 at 21:21)</a>:</h4>
<p>Sorry, Mario, your  use of “it” in multiple places is a bit too vague for me. Are you suggesting I use a different definition for <code>kunion</code>? If so, what is the type signature you're referring to?</p>

<a name="130972526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130972526" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130972526">Sean Leather (Aug 06 2018 at 21:28)</a>:</h4>
<p>Btw, I'm not asking for a completed solution. You're welcome to give me only hints or suggestions. <span class="emoji emoji-263a" title="smile">:smile:</span></p>

<a name="130972544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130972544" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130972544">Reid Barton (Aug 06 2018 at 21:29)</a>:</h4>
<p>I think <code>def kunion : multiset (sigma β) → multiset (sigma β) → roption (multiset (sigma β))</code> and then prove that <code>kunion</code> is defined exactly when each <code>multiset</code> is <code>nodup_keys</code></p>

<a name="130972612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130972612" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130972612">Sean Leather (Aug 06 2018 at 21:31)</a>:</h4>
<p>Reid: Hmm, okay, thanks.</p>

<a name="130972673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130972673" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130972673">Sean Leather (Aug 06 2018 at 21:32)</a>:</h4>
<p>And what's the advantage to this approach? Is it simplicity of the definition and related theorems or performance or both?</p>

<a name="130972677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130972677" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130972677">Reid Barton (Aug 06 2018 at 21:32)</a>:</h4>
<p>Then you can avoid all this dependent eliminator stuff... although it's not clear to me whether your problem is related to this</p>

<a name="130972701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130972701" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130972701">Sean Leather (Aug 06 2018 at 21:33)</a>:</h4>
<p>Okay, well, I'll give it a shot.</p>

<a name="130972702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130972702" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130972702">Chris Hughes (Aug 06 2018 at 21:33)</a>:</h4>
<p>Just proving at <code> quotient.hrec_on_beta</code> lemma might help.</p>

<a name="130972707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130972707" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130972707">Reid Barton (Aug 06 2018 at 21:34)</a>:</h4>
<p>Yes. Is that <code>↑</code> just <code>quotient.mk</code>?</p>

<a name="130972756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130972756" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130972756">Sean Leather (Aug 06 2018 at 21:34)</a>:</h4>
<p>Yes, I think so.</p>

<a name="130972765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130972765" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130972765">Sean Leather (Aug 06 2018 at 21:34)</a>:</h4>
<p>Chris: I wondered the same thing. I'm not sure how to start with that.</p>

<a name="130972790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130972790" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130972790">Reid Barton (Aug 06 2018 at 21:35)</a>:</h4>
<p>Well, <code>quotient.rec_on</code> applied to <code>quotient.mk</code> should reduce...</p>

<a name="130972792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130972792" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130972792">Chris Hughes (Aug 06 2018 at 21:35)</a>:</h4>
<p>Or use <code>show</code></p>

<a name="130972893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130972893" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130972893">Sean Leather (Aug 06 2018 at 21:37)</a>:</h4>
<p>I suppose it would look something like:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">quot</span><span class="bp">.</span><span class="n">ind_beta</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">β</span> <span class="o">(</span><span class="n">quot</span><span class="bp">.</span><span class="n">mk</span> <span class="n">r</span> <span class="n">a</span><span class="o">))</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">ind</span> <span class="n">p</span> <span class="o">(</span><span class="n">quot</span><span class="bp">.</span><span class="n">mk</span> <span class="n">r</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">β</span> <span class="o">(</span><span class="n">quot</span><span class="bp">.</span><span class="n">mk</span> <span class="n">r</span> <span class="n">a</span><span class="o">))</span> <span class="bp">=</span> <span class="n">p</span> <span class="n">a</span>
</pre></div>

<a name="130974037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130974037" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130974037">Mario Carneiro (Aug 06 2018 at 22:00)</a>:</h4>
<p>that is trivially true, since both sides are propositions</p>

<a name="130974063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130974063" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130974063">Mario Carneiro (Aug 06 2018 at 22:01)</a>:</h4>
<p>The advantage of using <code>roption</code> is avoiding all the <code>hrec</code> mess. I've had to define partial functions over quotients before, and I wish I'd thought of this then</p>

<a name="130974158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130974158" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130974158">Sean Leather (Aug 06 2018 at 22:03)</a>:</h4>
<blockquote>
<p>that is trivially true, since both sides are propositions</p>
</blockquote>
<p>Are you referring to <code>quot.ind_beta</code>, which is in the core library, or something else?</p>
<blockquote>
<p>The advantage of using <code>roption</code> is avoiding all the <code>hrec</code> mess. I've had to define partial functions over quotients before, and I wish I'd thought of this then</p>
</blockquote>
<p>Great! I'm working on it now.</p>

<a name="130974410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130974410" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130974410">Reid Barton (Aug 06 2018 at 22:08)</a>:</h4>
<p>I think someone probably copied <code>lift_beta</code> to <code>ind_beta</code> without realizing it was rather unnecessary.</p>

<a name="130974532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130974532" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130974532">Sean Leather (Aug 06 2018 at 22:10)</a>:</h4>
<p>Ah! I see what you're saying now. I didn't look that closely at <code>ind_beta</code>.</p>

<a name="130974767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130974767" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130974767">Sean Leather (Aug 06 2018 at 22:14)</a>:</h4>
<p>This is definitely a much nicer definition:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">kunion&#39;</span> <span class="o">(</span><span class="n">m₁</span> <span class="n">m₂</span> <span class="o">:</span> <span class="n">multiset</span> <span class="o">(</span><span class="n">sigma</span> <span class="n">β</span><span class="o">))</span> <span class="o">:</span> <span class="n">roption</span> <span class="o">(</span><span class="n">multiset</span> <span class="o">(</span><span class="n">sigma</span> <span class="n">β</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">quotient</span><span class="bp">.</span><span class="n">lift_on₂</span> <span class="n">m₁</span> <span class="n">m₂</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">l₁</span> <span class="n">l₂</span><span class="o">,</span> <span class="n">roption</span><span class="bp">.</span><span class="n">mk</span> <span class="o">(</span><span class="n">l₁</span><span class="bp">.</span><span class="n">nodup_keys</span> <span class="bp">∧</span> <span class="n">l₂</span><span class="bp">.</span><span class="n">nodup_keys</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="o">(</span><span class="n">l₁</span><span class="bp">.</span><span class="n">kunion</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">multiset</span> <span class="o">(</span><span class="n">sigma</span> <span class="n">β</span><span class="o">))))</span> <span class="err">$</span>
  <span class="bp">λ</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="n">l₃</span> <span class="n">l₄</span> <span class="n">p₁₃</span> <span class="n">p₂₄</span><span class="o">,</span> <span class="n">roption</span><span class="bp">.</span><span class="n">ext&#39;</span>
    <span class="o">(</span><span class="n">and_congr</span> <span class="o">(</span><span class="n">perm_nodup_keys</span> <span class="n">p₁₃</span><span class="o">)</span> <span class="o">(</span><span class="n">perm_nodup_keys</span> <span class="n">p₂₄</span><span class="o">))</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="bp">⟨</span><span class="n">d₁</span><span class="o">,</span> <span class="n">d₂</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">d₃</span><span class="o">,</span> <span class="n">d₄</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">sound</span> <span class="err">$</span> <span class="n">perm_kunion</span> <span class="n">d₂</span> <span class="n">d₄</span> <span class="n">p₁₃</span> <span class="n">p₂₄</span><span class="o">)</span>
</pre></div>

<a name="130974979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130974979" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130974979">Mario Carneiro (Aug 06 2018 at 22:18)</a>:</h4>
<p>so now the theorem you want is either <code>m k∪ 0 = some m</code> or <code>m ∈ m k∪ 0</code> (they are equivalent)</p>

<a name="130975110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130975110" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130975110">Sean Leather (Aug 06 2018 at 22:20)</a>:</h4>
<p>Right.</p>

<a name="130975212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130975212" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130975212">Mario Carneiro (Aug 06 2018 at 22:22)</a>:</h4>
<p>and the coercion lemma you want says <code>l₁.nodup_keys → l₂.nodup_keys → ↑l₁ k∪ ↑l₂ = some (l₁.kunion l₂)</code></p>

<a name="130975700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130975700" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130975700">Sean Leather (Aug 06 2018 at 22:33)</a>:</h4>
<p>Got that, thanks. How should I coerce the 0 (<code>multiset.zero</code>) for <code>kunion' 0 ↑l</code>?</p>

<a name="130975782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130975782" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130975782">Sean Leather (Aug 06 2018 at 22:35)</a>:</h4>
<p>If I do <code>simp [has_zero.zero, multiset.zero]</code>, lean never ends.</p>

<a name="130975852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130975852" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130975852">Mario Carneiro (Aug 06 2018 at 22:37)</a>:</h4>
<p>you can just force it to unfold by applying <code>kunion_coe.trans _</code></p>

<a name="130975886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130975886" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130975886">Mario Carneiro (Aug 06 2018 at 22:37)</a>:</h4>
<p>or you can rewrite with <code>coe_nil_eq_zero</code></p>

<a name="130980496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130980496" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130980496">Sean Leather (Aug 07 2018 at 00:05)</a>:</h4>
<p>The aforementioned theorems:</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">zero_kunion</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">m</span><span class="bp">.</span><span class="n">nodup_keys</span><span class="o">),</span> <span class="n">kunion&#39;</span> <span class="mi">0</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">roption</span><span class="bp">.</span><span class="n">some</span> <span class="n">m</span> <span class="o">:=</span>
<span class="n">quotient</span><span class="bp">.</span><span class="n">induction_on</span> <span class="n">m</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="n">d</span><span class="o">,</span> <span class="o">(</span><span class="n">kunion_coe</span> <span class="n">nodup_keys_zero</span> <span class="n">d</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="n">rfl</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">kunion_zero</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">m</span><span class="bp">.</span><span class="n">nodup_keys</span><span class="o">),</span> <span class="n">kunion&#39;</span> <span class="n">m</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">roption</span><span class="bp">.</span><span class="n">some</span> <span class="n">m</span> <span class="o">:=</span>
<span class="n">quotient</span><span class="bp">.</span><span class="n">induction_on</span> <span class="n">m</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="n">d</span><span class="o">,</span> <span class="o">(</span><span class="n">kunion_coe</span> <span class="n">d</span> <span class="n">nodup_keys_zero</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="k">by</span> <span class="n">simp</span><span class="o">)</span>
</pre></div>

<a name="130981382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130981382" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130981382">Sean Leather (Aug 07 2018 at 00:21)</a>:</h4>
<p>One last related question: Now that I have an <code>roption</code>-wrapped <code>multiset</code>, how should I specify theorems that involve the result of <code>kunion'</code>? For example, I had:</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">mem_kunion</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">sigma</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">d₁</span> <span class="o">:</span> <span class="n">m₁</span><span class="bp">.</span><span class="n">nodup_keys</span><span class="o">)</span> <span class="o">(</span><span class="n">d₂</span> <span class="o">:</span> <span class="n">m₂</span><span class="bp">.</span><span class="n">nodup_keys</span><span class="o">),</span>
  <span class="n">disjoint</span> <span class="n">m₁</span><span class="bp">.</span><span class="n">keys</span> <span class="n">m₂</span><span class="bp">.</span><span class="n">keys</span> <span class="bp">→</span> <span class="o">(</span><span class="n">s</span> <span class="err">∈</span> <span class="n">d₁</span> <span class="n">k</span><span class="err">∪</span> <span class="n">d₂</span> <span class="bp">↔</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">m₁</span> <span class="bp">∨</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">m₂</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">quotient</span><span class="bp">.</span><span class="n">induction_on₂</span> <span class="n">m₁</span> <span class="n">m₂</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">mem_kunion_iff</span>
</pre></div>


<p>Should this become...?</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">mem_kunion&#39;</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">sigma</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">d₁</span> <span class="o">:</span> <span class="n">m₁</span><span class="bp">.</span><span class="n">nodup_keys</span><span class="o">)</span> <span class="o">(</span><span class="n">d₂</span> <span class="o">:</span> <span class="n">m₂</span><span class="bp">.</span><span class="n">nodup_keys</span><span class="o">),</span>
  <span class="n">disjoint</span> <span class="n">m₁</span><span class="bp">.</span><span class="n">keys</span> <span class="n">m₂</span><span class="bp">.</span><span class="n">keys</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">m</span> <span class="err">∈</span> <span class="n">kunion&#39;</span> <span class="n">m₁</span> <span class="n">m₂</span><span class="o">,</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">m</span> <span class="bp">↔</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">m₁</span> <span class="bp">∨</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">m₂</span> <span class="o">:=</span>
<span class="n">quotient</span><span class="bp">.</span><span class="n">induction_on₂</span> <span class="n">m₁</span> <span class="n">m₂</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="n">d₁</span> <span class="n">d₂</span> <span class="n">dk</span><span class="o">,</span>
  <span class="bp">⟨_</span><span class="o">,</span> <span class="n">roption</span><span class="bp">.</span><span class="n">eq_some_iff</span><span class="bp">.</span><span class="n">mp</span> <span class="o">(</span><span class="n">kunion_coe</span> <span class="n">d₁</span> <span class="n">d₂</span><span class="o">),</span> <span class="n">mem_kunion_iff</span> <span class="n">dk</span><span class="bp">⟩</span>
</pre></div>


<p>Specifically, I mean: should I use a pattern like <code>∃ m ∈ kunion' m₁ m₂, ...</code> for theorems like this, or is there a better way?</p>

<a name="130982225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130982225" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130982225">Mario Carneiro (Aug 07 2018 at 00:35)</a>:</h4>
<p>I would take <code>m ∈ kunion' m₁ m₂</code> as a hypothesis and prove <code>s ∈ m ↔ s ∈ m₁ ∨ s ∈ m₂</code></p>

<a name="130982297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130982297" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130982297">Mario Carneiro (Aug 07 2018 at 00:36)</a>:</h4>
<p>of course this hypothesis eliminates the need for d1 and d2</p>

<a name="130982374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130982374" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130982374">Mario Carneiro (Aug 07 2018 at 00:37)</a>:</h4>
<p>alternatively, you can define <code>kunion</code> as <code>(kunion' m1 m2).get &lt;d1, d2&gt;</code> and have all your old theorems back</p>

<a name="130991221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130991221" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130991221">Sean Leather (Aug 07 2018 at 03:07)</a>:</h4>
<p>True. I'm not sure which is a better definition to work with. If I were using the <code>multiset</code> interface directly, I would lean towards defining <code>kunion</code> as <code>(kunion' m1 m2).get &lt;d1, d2&gt;</code>. But since it's really meant to be the underlying implementation of <code>finmap</code>, perhaps it's not necessary.</p>

<a name="130991299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/130991299" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#130991299">Sean Leather (Aug 07 2018 at 03:08)</a>:</h4>
<p>Also, do you think I should use <code>roption</code> + <code>quotient.lift_on</code> consistently instead of <code>quotient.hrec_on</code>? I don't have any more uses of <code>quotient.hrec_on₂</code>, but I do have a number of uses of <code>quotient.hrec_on</code>.</p>

<a name="131028609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131028609" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131028609">Sean Leather (Aug 07 2018 at 17:50)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> I'd like to get your thoughts on this <span class="emoji emoji-1f446" title="point up">:point_up:</span>. I haven't had any problems with <code>quotient.hrec_on</code> up to now, but maybe things would just be nicer all around if I used <code>roption</code> more. I'm not sure.</p>

<a name="131028618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131028618" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131028618">Mario Carneiro (Aug 07 2018 at 17:51)</a>:</h4>
<p>I think if it works once, it will probably work again</p>

<a name="131028672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131028672" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131028672">Mario Carneiro (Aug 07 2018 at 17:52)</a>:</h4>
<p>Also, another option I forgot to mention was to make <code>kunion</code> a nondependent function, using the fact that <code>nodup_keys</code> is decidable</p>

<a name="131028674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131028674" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131028674">Sean Leather (Aug 07 2018 at 17:52)</a>:</h4>
<p>Just to be clear about what you mean, do you think I should change the defs <a href="https://github.com/spl/lean-finmap/blob/fb3f562de05059f136f855b88bf616c8aac7f365/src/data/multiset/dict.lean" target="_blank" title="https://github.com/spl/lean-finmap/blob/fb3f562de05059f136f855b88bf616c8aac7f365/src/data/multiset/dict.lean">here</a> to use <code>roption</code>?</p>

<a name="131028693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131028693" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131028693">Sean Leather (Aug 07 2018 at 17:53)</a>:</h4>
<p>(Just search for <code>hrec_on</code>.)</p>

<a name="131028697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131028697" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131028697">Mario Carneiro (Aug 07 2018 at 17:53)</a>:</h4>
<p>Even if we suppose that checking this is expensive, it doesn't matter if you are just using it as an abstract version so you can prove equations about it</p>

<a name="131028702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131028702" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131028702">Sean Leather (Aug 07 2018 at 17:53)</a>:</h4>
<blockquote>
<p>Also, another option I forgot to mention was to make <code>kunion</code> a nondependent function, using the fact that <code>nodup_keys</code> is decidable</p>
</blockquote>
<p>What do you mean by this?</p>

<a name="131028797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131028797" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131028797">Mario Carneiro (Aug 07 2018 at 17:55)</a>:</h4>
<p>define <code>kunion m1 m2 = if h : m1.nodup_keys /\ m2.nodup_keys then (kunion' m1 m2).get h else 0</code></p>

<a name="131028858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131028858" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131028858">Sean Leather (Aug 07 2018 at 17:56)</a>:</h4>
<p>That's an interesting suggestion.</p>

<a name="131028874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131028874" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131028874">Mario Carneiro (Aug 07 2018 at 17:57)</a>:</h4>
<p>in fact, even if <code>nodup_keys</code> wasn't decidable you could make this definition anyway noncomputably and just not use it for evaluation</p>

<a name="131029010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029010" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029010">Sean Leather (Aug 07 2018 at 18:00)</a>:</h4>
<p>Hmm, yes, I think I like this definition of <code>kunion</code>. I don't have to pass around the <code>m1.nodup_keys</code> everywhere.</p>

<a name="131029031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029031" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029031">Sean Leather (Aug 07 2018 at 18:01)</a>:</h4>
<p>Okay, well, I'll play around with it.</p>

<a name="131029032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029032" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029032">Mario Carneiro (Aug 07 2018 at 18:01)</a>:</h4>
<p>Yet more alternatively, you could define the subtype. Didn't you have <code>finmap</code> at one point for this?</p>

<a name="131029090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029090" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029090">Sean Leather (Aug 07 2018 at 18:02)</a>:</h4>
<p>I decided to go with the <code>structure</code> for the same reasons <code>finset</code> is a <code>structure</code>:</p>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">finmap</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">val</span> <span class="o">:</span> <span class="n">multiset</span> <span class="o">(</span><span class="n">sigma</span> <span class="n">β</span><span class="o">))</span>
<span class="o">(</span><span class="n">nodup_keys</span> <span class="o">:</span> <span class="n">val</span><span class="bp">.</span><span class="n">nodup_keys</span><span class="o">)</span>
</pre></div>

<a name="131029097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029097" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029097">Sean Leather (Aug 07 2018 at 18:02)</a>:</h4>
<p>Mainly, for type class instance resolution.</p>

<a name="131029099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029099" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029099">Mario Carneiro (Aug 07 2018 at 18:03)</a>:</h4>
<p>that's fine, my point was that you can define <code>finmap.rec_on</code> to encapsulate this definition pattern</p>

<a name="131029112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029112" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029112">Mario Carneiro (Aug 07 2018 at 18:03)</a>:</h4>
<p>and this way you never have to carry around any proofs since they are embedded in the type</p>

<a name="131029158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029158" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029158">Sean Leather (Aug 07 2018 at 18:04)</a>:</h4>
<p>You mean the <code>if h : m.nodup_keys ... then ... else ...</code> pattern?</p>

<a name="131029160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029160" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029160">Mario Carneiro (Aug 07 2018 at 18:04)</a>:</h4>
<p>no, the <code>roption</code> or <code>hrec_on</code> version</p>

<a name="131029167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029167" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029167">Mario Carneiro (Aug 07 2018 at 18:04)</a>:</h4>
<p>(it doesn't really matter too much which one you use, since it only has to be done once)</p>

<a name="131029228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029228" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029228">Sean Leather (Aug 07 2018 at 18:06)</a>:</h4>
<p>Oh.... I'm awfully dumb today. So, define a <code>finmap.rec_on</code> that takes an <code>roption (multiset (sigma β))</code> to a <code>finmap</code>?</p>

<a name="131029236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029236" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029236">Sean Leather (Aug 07 2018 at 18:07)</a>:</h4>
<p>Err, actually the arrow goes the other way...</p>

<a name="131029244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029244" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029244">Sean Leather (Aug 07 2018 at 18:07)</a>:</h4>
<p>Anyway, it'd be a higher-order function.</p>

<a name="131029247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029247" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029247">Sean Leather (Aug 07 2018 at 18:07)</a>:</h4>
<p>Yeah, I think I see it.</p>

<a name="131029289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029289" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029289">Mario Carneiro (Aug 07 2018 at 18:08)</a>:</h4>
<p><code>finmap.rec_on</code> takes a <code>finmap A B</code>, a function <code>list (sigma B) -&gt; C</code>, and a proof that this function is equal up to permutation when the arguments have <code>nodup_keys</code></p>

<a name="131029296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029296" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029296">Sean Leather (Aug 07 2018 at 18:08)</a>:</h4>
<p>Right.</p>

<a name="131029372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029372" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029372">Sean Leather (Aug 07 2018 at 18:10)</a>:</h4>
<p>So, given that, I would be skipping defining all of the defs and theorems for <code>multiset</code> and define them for only <code>list</code> and <code>finmap</code>?</p>

<a name="131029445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029445" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029445">Mario Carneiro (Aug 07 2018 at 18:13)</a>:</h4>
<p>right</p>

<a name="131029450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029450" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029450">Mario Carneiro (Aug 07 2018 at 18:13)</a>:</h4>
<p>You can reconstruct the multiset definitions from the finmap ones by the <code>if ... else 0</code> trick</p>

<a name="131029516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029516" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029516">Mario Carneiro (Aug 07 2018 at 18:15)</a>:</h4>
<p>I think multisets are a good stepping stone if you can actually define functions on them, but in your case the functions already have to assume nodup just to be well defined, so they've already jumped to finmap</p>

<a name="131029523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029523" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029523">Sean Leather (Aug 07 2018 at 18:15)</a>:</h4>
<p>That's true.</p>

<a name="131029576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029576" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029576">Sean Leather (Aug 07 2018 at 18:17)</a>:</h4>
<p>Okay, I'm convinced.</p>

<a name="131029713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029713" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029713">Mario Carneiro (Aug 07 2018 at 18:20)</a>:</h4>
<p>I notice you have theorems like <code> s.1 ∈ (m.map_snd f).keys ↔ s.1 ∈ m.keys</code> with several variations. Why isn't this just <code>(m.map_snd f).keys = m.keys</code>?</p>

<a name="131029750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029750" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029750">Sean Leather (Aug 07 2018 at 18:21)</a>:</h4>
<p>Because I use the <code>mem</code> one in the non-<code>mem</code>.</p>

<a name="131029791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029791" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029791">Sean Leather (Aug 07 2018 at 18:22)</a>:</h4>
<p>I suppose I don't have to.</p>

<a name="131029808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029808" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029808">Mario Carneiro (Aug 07 2018 at 18:23)</a>:</h4>
<p>the proof is just <code>map_comp</code></p>

<a name="131029819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029819" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029819">Mario Carneiro (Aug 07 2018 at 18:23)</a>:</h4>
<p>you shouldn't use <code>mem</code> to try to characterize a multiset, it gets messy</p>

<a name="131029874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029874" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029874">Sean Leather (Aug 07 2018 at 18:25)</a>:</h4>
<p>The other problem with the <code>map_snd</code>/<code>keys</code> theorems is that I wanted to use it in <code>finmap</code>, but the best I could come up with was using <code>[inhabited (∀ a, β₁ a)]</code>. I'm not happy with that solution.</p>

<a name="131029887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029887" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029887">Sean Leather (Aug 07 2018 at 18:25)</a>:</h4>
<blockquote>
<p>the proof is just <code>map_comp</code></p>
</blockquote>
<p>The proof of which?</p>

<a name="131029966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131029966" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131029966">Mario Carneiro (Aug 07 2018 at 18:27)</a>:</h4>
<p>I'm really confused about your confusion. It should be provable that <code>(m.map_snd f).keys = m.keys</code>, this makes the last 7 theorems or so unnecessary and it doesn't require any weird assumptions</p>

<a name="131030141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131030141" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131030141">Sean Leather (Aug 07 2018 at 18:31)</a>:</h4>
<p>Okay, I think I see what you're saying. I'll give it a shot.</p>

<a name="131030157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131030157" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131030157">Mario Carneiro (Aug 07 2018 at 18:31)</a>:</h4>
<p>wait, just the last 4. The ones about <code>(m.map f).keys</code> are a bit awkward because <code>f : sigma B1 -&gt; sigma B2</code> can mingle keys and values in an unpredictable way. How about defining <code>m.map f g</code> where <code>f : A1 -&gt; A2</code> and <code>g : ∀ a, B1 a -&gt; B2 (f a)</code>; then you should be able to prove <code>(m.map f g).keys = m.keys.map f</code> and life is good</p>

<a name="131030231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131030231" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131030231">Sean Leather (Aug 07 2018 at 18:33)</a>:</h4>
<p>Btw, did you mean <code>map_map</code> instead of <code>map_comp</code>?</p>

<a name="131030275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131030275" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131030275">Mario Carneiro (Aug 07 2018 at 18:34)</a>:</h4>
<p>yes</p>

<a name="131030288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131030288" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131030288">Mario Carneiro (Aug 07 2018 at 18:34)</a>:</h4>
<p>it's written backwards for simp lemmas because <code>comp</code> is dumb</p>

<a name="131030292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131030292" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131030292">Mario Carneiro (Aug 07 2018 at 18:34)</a>:</h4>
<p>so the name becomes <code>map_map</code> instead of <code>map_comp</code></p>

<a name="131093639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131093639" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131093639">Sean Leather (Aug 08 2018 at 17:53)</a>:</h4>
<p>I could only figure out how to do a general 2-arg <code>finmap</code> recursor using <code>quotient.hrec_on₂</code>:</p>
<div class="codehilite"><pre><span></span><span class="kn">protected</span> <span class="n">def</span> <span class="n">lrec_on₂</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">finmap</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span>
  <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">sigma</span> <span class="n">β</span><span class="o">)},</span> <span class="n">l₁</span><span class="bp">.</span><span class="n">nodup_keys</span> <span class="bp">→</span> <span class="n">l₂</span><span class="bp">.</span><span class="n">nodup_keys</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="n">l₃</span> <span class="n">l₄</span><span class="o">}</span> <span class="o">(</span><span class="n">p₁₃</span> <span class="o">:</span> <span class="n">l₁</span> <span class="bp">~</span> <span class="n">l₃</span><span class="o">)</span> <span class="o">(</span><span class="n">p₂₄</span> <span class="o">:</span> <span class="n">l₂</span> <span class="bp">~</span> <span class="n">l₄</span><span class="o">)</span> <span class="n">d₁</span> <span class="n">d₂</span> <span class="n">d₃</span> <span class="n">d₄</span><span class="o">,</span> <span class="n">φ</span> <span class="n">d₁</span> <span class="n">d₂</span> <span class="bp">=</span> <span class="n">φ</span> <span class="n">d₃</span> <span class="n">d₄</span><span class="o">)</span> <span class="o">:</span> <span class="n">γ</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">quotient</span><span class="bp">.</span><span class="n">hrec_on₂</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m₁</span> <span class="n">m₂</span> <span class="o">:</span> <span class="n">multiset</span> <span class="o">(</span><span class="n">sigma</span> <span class="n">β</span><span class="o">)),</span> <span class="n">m₁</span><span class="bp">.</span><span class="n">nodup_keys</span> <span class="bp">→</span> <span class="n">m₂</span><span class="bp">.</span><span class="n">nodup_keys</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span>
  <span class="n">f</span><span class="bp">.</span><span class="n">val</span> <span class="n">g</span><span class="bp">.</span><span class="n">val</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="o">(</span><span class="n">d₁</span> <span class="o">:</span> <span class="n">l₁</span><span class="bp">.</span><span class="n">nodup_keys</span><span class="o">)</span> <span class="o">(</span><span class="n">d₂</span> <span class="o">:</span> <span class="n">l₂</span><span class="bp">.</span><span class="n">nodup_keys</span><span class="o">),</span> <span class="n">φ</span> <span class="n">d₁</span> <span class="n">d₂</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="n">l₃</span> <span class="n">l₄</span> <span class="n">p₁₃</span> <span class="n">p₂₄</span><span class="o">,</span> <span class="n">hfunext</span> <span class="o">(</span><span class="k">by</span> <span class="n">rw</span> <span class="n">list</span><span class="bp">.</span><span class="n">perm_nodup_keys</span> <span class="n">p₁₃</span><span class="o">)</span> <span class="err">$</span>
    <span class="bp">λ</span> <span class="n">d₁</span> <span class="n">d₃</span> <span class="bp">_</span><span class="o">,</span> <span class="n">hfunext</span> <span class="o">(</span><span class="k">by</span> <span class="n">rw</span> <span class="n">list</span><span class="bp">.</span><span class="n">perm_nodup_keys</span> <span class="n">p₂₄</span><span class="o">)</span> <span class="err">$</span>
      <span class="bp">λ</span> <span class="n">d₂</span> <span class="n">d₄</span> <span class="bp">_</span><span class="o">,</span> <span class="n">heq_of_eq</span> <span class="err">$</span> <span class="n">c</span> <span class="n">p₁₃</span> <span class="n">p₂₄</span> <span class="n">d₁</span> <span class="n">d₂</span> <span class="n">d₃</span> <span class="n">d₄</span><span class="o">)</span>
  <span class="n">f</span><span class="bp">.</span><span class="n">nodup_keys</span> <span class="n">g</span><span class="bp">.</span><span class="n">nodup_keys</span>
</pre></div>


<p>I have a general 2-arg <code>finmap.lift_on₂</code>:</p>
<div class="codehilite"><pre><span></span><span class="kn">protected</span> <span class="n">def</span> <span class="n">lift_on₂</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">finmap</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span>
  <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">sigma</span> <span class="n">β</span><span class="o">)},</span> <span class="n">l₁</span><span class="bp">.</span><span class="n">nodup_keys</span> <span class="bp">→</span> <span class="n">l₂</span><span class="bp">.</span><span class="n">nodup_keys</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="n">l₃</span> <span class="n">l₄</span><span class="o">}</span> <span class="o">(</span><span class="n">p₁₃</span> <span class="o">:</span> <span class="n">l₁</span> <span class="bp">~</span> <span class="n">l₃</span><span class="o">)</span> <span class="o">(</span><span class="n">p₂₄</span> <span class="o">:</span> <span class="n">l₂</span> <span class="bp">~</span> <span class="n">l₄</span><span class="o">)</span> <span class="n">d₁</span> <span class="n">d₂</span> <span class="n">d₃</span> <span class="n">d₄</span><span class="o">,</span> <span class="n">φ</span> <span class="n">d₁</span> <span class="n">d₂</span> <span class="bp">=</span> <span class="n">φ</span> <span class="n">d₃</span> <span class="n">d₄</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">roption</span> <span class="n">γ</span> <span class="o">:=</span>
<span class="n">quotient</span><span class="bp">.</span><span class="n">lift_on₂</span> <span class="n">f</span><span class="bp">.</span><span class="n">val</span> <span class="n">g</span><span class="bp">.</span><span class="n">val</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">l₁</span> <span class="n">l₂</span><span class="o">,</span> <span class="n">roption</span><span class="bp">.</span><span class="n">mk</span> <span class="o">(</span><span class="n">l₁</span><span class="bp">.</span><span class="n">nodup_keys</span> <span class="bp">∧</span> <span class="n">l₂</span><span class="bp">.</span><span class="n">nodup_keys</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">⟨</span><span class="n">d₁</span><span class="o">,</span> <span class="n">d₂</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">φ</span> <span class="n">d₁</span> <span class="n">d₂</span><span class="o">))</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="n">l₃</span> <span class="n">l₄</span> <span class="n">p₁₃</span> <span class="n">p₂₄</span><span class="o">,</span> <span class="n">roption</span><span class="bp">.</span><span class="n">ext&#39;</span>
    <span class="o">(</span><span class="n">and_congr</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">perm_nodup_keys</span> <span class="n">p₁₃</span><span class="o">)</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">perm_nodup_keys</span> <span class="n">p₂₄</span><span class="o">))</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="bp">⟨</span><span class="n">d₁</span><span class="o">,</span> <span class="n">d₂</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">d₃</span><span class="o">,</span> <span class="n">d₄</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">c</span> <span class="n">p₁₃</span> <span class="n">p₂₄</span> <span class="n">d₁</span> <span class="n">d₂</span> <span class="n">d₃</span> <span class="n">d₄</span><span class="o">))</span>
</pre></div>


<p>But it seems like the <code>roption.dom</code> has a pair of lists, so this only seems useful in combination with <code>quotient.induction_on₂</code>. Is that right? Or can I do better?</p>

<a name="131094611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131094611" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131094611">Mario Carneiro (Aug 08 2018 at 18:24)</a>:</h4>
<p>What does the one arg version look like?</p>

<a name="131094622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131094622" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131094622">Sean Leather (Aug 08 2018 at 18:25)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">protected</span> <span class="n">def</span> <span class="n">lrec_on</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">finmap</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span>
  <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">sigma</span> <span class="n">β</span><span class="o">)},</span> <span class="n">l</span><span class="bp">.</span><span class="n">nodup_keys</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">l₁</span> <span class="n">l₂</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">l₁</span> <span class="bp">~</span> <span class="n">l₂</span><span class="o">)</span> <span class="n">d₁</span> <span class="n">d₂</span><span class="o">,</span> <span class="n">φ</span> <span class="n">d₁</span> <span class="bp">=</span> <span class="n">φ</span> <span class="n">d₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">γ</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">quotient</span><span class="bp">.</span><span class="n">hrec_on</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">multiset</span> <span class="o">(</span><span class="n">sigma</span> <span class="n">β</span><span class="o">)),</span> <span class="n">m</span><span class="bp">.</span><span class="n">nodup_keys</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span>
  <span class="n">f</span><span class="bp">.</span><span class="n">val</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">l</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">l</span><span class="bp">.</span><span class="n">nodup_keys</span><span class="o">),</span> <span class="n">φ</span> <span class="n">d</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="n">p</span><span class="o">,</span> <span class="n">hfunext</span> <span class="o">(</span><span class="k">by</span> <span class="n">rw</span> <span class="n">list</span><span class="bp">.</span><span class="n">perm_nodup_keys</span> <span class="n">p</span><span class="o">)</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">d₁</span> <span class="n">d₂</span> <span class="bp">_</span><span class="o">,</span> <span class="n">heq_of_eq</span> <span class="err">$</span> <span class="n">c</span> <span class="n">p</span> <span class="n">d₁</span> <span class="n">d₂</span><span class="o">)</span>
  <span class="n">f</span><span class="bp">.</span><span class="n">nodup_keys</span>
</pre></div>

<a name="131094845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131094845" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131094845">Sean Leather (Aug 08 2018 at 18:30)</a>:</h4>
<p>There are theorems where <code>quotient.induction_on₂</code> needs more than just <code>l₁.nodup_keys</code> and <code>l₂.nodup_keys</code>:</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">mem_kunion&#39;</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">sigma</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">d₁</span> <span class="o">:</span> <span class="n">m₁</span><span class="bp">.</span><span class="n">nodup_keys</span><span class="o">)</span> <span class="o">(</span><span class="n">d₂</span> <span class="o">:</span> <span class="n">m₂</span><span class="bp">.</span><span class="n">nodup_keys</span><span class="o">),</span>
  <span class="n">disjoint</span> <span class="n">m₁</span><span class="bp">.</span><span class="n">keys</span> <span class="n">m₂</span><span class="bp">.</span><span class="n">keys</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">m</span> <span class="err">∈</span> <span class="n">kunion&#39;</span> <span class="n">m₁</span> <span class="n">m₂</span><span class="o">,</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">m</span> <span class="bp">↔</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">m₁</span> <span class="bp">∨</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">m₂</span> <span class="o">:=</span>
<span class="n">quotient</span><span class="bp">.</span><span class="n">induction_on₂</span> <span class="n">m₁</span> <span class="n">m₂</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="n">d₁</span> <span class="n">d₂</span> <span class="n">dk</span><span class="o">,</span>
  <span class="bp">⟨_</span><span class="o">,</span> <span class="n">roption</span><span class="bp">.</span><span class="n">eq_some_iff</span><span class="bp">.</span><span class="n">mp</span> <span class="o">(</span><span class="n">kunion_coe</span> <span class="n">d₁</span> <span class="n">d₂</span><span class="o">),</span> <span class="n">mem_kunion_iff</span> <span class="n">dk</span><span class="bp">⟩</span>
</pre></div>


<p>So, I think the above <code>finmap.lift_on₂</code> definition makes sense.</p>

<a name="131098994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131098994" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131098994">Mario Carneiro (Aug 08 2018 at 20:10)</a>:</h4>
<p>I would suggest you state <code>lrec_on</code> like this:</p>
<div class="codehilite"><pre><span></span>protected def lrec_on {γ : Sort*} (f : finmap α β)
  (φ : list (sigma β) → γ)
  (c : ∀ {l₁ l₂} (p : l₁ ~ l₂), l₁.nodup_keys → l₂.nodup_keys → φ l₁ = φ l₂) : γ :=
</pre></div>


<p>Recall that we are trying to avoid partial functions. The function <code>φ</code> is defined on lists, so there presumably won't be any trouble making arbitrary choices that depend on the order</p>

<a name="131099010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131099010" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131099010">Mario Carneiro (Aug 08 2018 at 20:11)</a>:</h4>
<p>Given this it should not be hard to just iterate it twice to get <code>lrec_on₂</code></p>

<a name="131103716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotient.hrec_on%E2%82%82/near/131103716" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87308quotienthrecon.html#131103716">Sean Leather (Aug 08 2018 at 22:04)</a>:</h4>
<p>Okay, so I have the following.</p>
<p>My initial version:</p>
<div class="codehilite"><pre><span></span><span class="kn">protected</span> <span class="n">def</span> <span class="n">lrec_on</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">finmap</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span>
  <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">sigma</span> <span class="n">β</span><span class="o">)},</span> <span class="n">l</span><span class="bp">.</span><span class="n">nodup_keys</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">l₁</span> <span class="n">l₂</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">l₁</span> <span class="bp">~</span> <span class="n">l₂</span><span class="o">)</span> <span class="n">d₁</span> <span class="n">d₂</span><span class="o">,</span> <span class="n">φ</span> <span class="n">d₁</span> <span class="bp">=</span> <span class="n">φ</span> <span class="n">d₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">γ</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">quotient</span><span class="bp">.</span><span class="n">hrec_on</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">multiset</span> <span class="o">(</span><span class="n">sigma</span> <span class="n">β</span><span class="o">)),</span> <span class="n">m</span><span class="bp">.</span><span class="n">nodup_keys</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span>
  <span class="n">f</span><span class="bp">.</span><span class="n">val</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">l</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">l</span><span class="bp">.</span><span class="n">nodup_keys</span><span class="o">),</span> <span class="n">φ</span> <span class="n">d</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="n">p</span><span class="o">,</span> <span class="n">hfunext</span> <span class="o">(</span><span class="k">by</span> <span class="n">rw</span> <span class="n">list</span><span class="bp">.</span><span class="n">perm_nodup_keys</span> <span class="n">p</span><span class="o">)</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">d₁</span> <span class="n">d₂</span> <span class="bp">_</span><span class="o">,</span> <span class="n">heq_of_eq</span> <span class="err">$</span> <span class="n">c</span> <span class="n">p</span> <span class="n">d₁</span> <span class="n">d₂</span><span class="o">)</span>
  <span class="n">f</span><span class="bp">.</span><span class="n">nodup_keys</span>

<span class="n">def</span> <span class="n">erase</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">finmap</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">finmap</span> <span class="n">α</span> <span class="n">β</span> <span class="o">:=</span>
<span class="n">finmap</span><span class="bp">.</span><span class="n">lrec_on</span> <span class="n">f</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">l</span> <span class="n">d</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">l</span><span class="bp">.</span><span class="n">kerase</span> <span class="n">a</span><span class="o">,</span> <span class="n">list</span><span class="bp">.</span><span class="n">nodup_keys_kerase</span> <span class="n">a</span> <span class="n">d</span><span class="bp">⟩</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="n">p</span> <span class="n">d₁</span> <span class="n">d₂</span><span class="o">,</span> <span class="n">eq_of_veq</span> <span class="err">$</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">sound</span> <span class="err">$</span> <span class="n">list</span><span class="bp">.</span><span class="n">perm_kerase</span> <span class="n">a</span> <span class="n">d₁</span> <span class="n">d₂</span> <span class="n">p</span><span class="o">)</span>
</pre></div>


<p>Your suggestion:</p>
<div class="codehilite"><pre><span></span><span class="kn">protected</span> <span class="n">def</span> <span class="n">lrec_on&#39;</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">finmap</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span>
  <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">sigma</span> <span class="n">β</span><span class="o">)</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">l₁</span> <span class="n">l₂</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">l₁</span> <span class="bp">~</span> <span class="n">l₂</span><span class="o">),</span> <span class="n">l₁</span><span class="bp">.</span><span class="n">nodup_keys</span> <span class="bp">→</span> <span class="n">l₂</span><span class="bp">.</span><span class="n">nodup_keys</span> <span class="bp">→</span> <span class="n">φ</span> <span class="n">l₁</span> <span class="bp">=</span> <span class="n">φ</span> <span class="n">l₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">γ</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">quotient</span><span class="bp">.</span><span class="n">hrec_on</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">multiset</span> <span class="o">(</span><span class="n">sigma</span> <span class="n">β</span><span class="o">)),</span> <span class="n">m</span><span class="bp">.</span><span class="n">nodup_keys</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span>
  <span class="n">f</span><span class="bp">.</span><span class="n">val</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">l</span> <span class="bp">_</span><span class="o">,</span> <span class="n">φ</span> <span class="n">l</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="n">p</span><span class="o">,</span> <span class="n">hfunext</span> <span class="o">(</span><span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">list</span><span class="bp">.</span><span class="n">perm_nodup_keys</span> <span class="n">p</span><span class="o">])</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">d₁</span> <span class="n">d₂</span> <span class="bp">_</span><span class="o">,</span> <span class="n">heq_of_eq</span> <span class="err">$</span> <span class="n">c</span> <span class="n">p</span> <span class="n">d₁</span> <span class="n">d₂</span><span class="o">)</span>
  <span class="n">f</span><span class="bp">.</span><span class="n">nodup_keys</span>

<span class="n">def</span> <span class="n">erase&#39;</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">finmap</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">finmap</span> <span class="n">α</span> <span class="n">β</span> <span class="o">:=</span>
<span class="n">finmap</span><span class="bp">.</span><span class="n">lrec_on&#39;</span> <span class="n">f</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">l</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">l</span><span class="bp">.</span><span class="n">kerase</span> <span class="n">a</span><span class="o">,</span> <span class="n">list</span><span class="bp">.</span><span class="n">nodup_keys_kerase</span> <span class="n">a</span> <span class="bp">_⟩</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="n">p</span> <span class="n">d₁</span> <span class="n">d₂</span><span class="o">,</span> <span class="n">eq_of_veq</span> <span class="err">$</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">sound</span> <span class="err">$</span> <span class="n">list</span><span class="bp">.</span><span class="n">perm_kerase</span> <span class="n">a</span> <span class="n">d₁</span> <span class="n">d₂</span> <span class="n">p</span><span class="o">)</span>
</pre></div>


<p>I can define <code>erase</code> with <code>lrec_on</code>, but how do I define <code>erase'</code> with <code>lrec_on'</code>?</p>
<div class="codehilite"><pre><span></span><span class="n">error</span><span class="o">:</span> <span class="n">don&#39;t</span> <span class="n">know</span> <span class="n">how</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">placeholder</span>
<span class="kn">context</span><span class="o">:</span>
<span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_1</span> <span class="o">:</span> <span class="n">decidable_eq</span> <span class="n">α</span><span class="o">,</span>
<span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">,</span>
<span class="n">f</span> <span class="o">:</span> <span class="n">finmap</span> <span class="n">α</span> <span class="n">β</span><span class="o">,</span>
<span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span>
<span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">sigma</span> <span class="n">β</span><span class="o">)</span>
<span class="err">⊢</span> <span class="n">list</span><span class="bp">.</span><span class="n">nodup_keys</span> <span class="n">l</span>
</pre></div>


{% endraw %}
