---
layout: archive
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/45709appbuilderfailed.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/45709appbuilderfailed.html">app_builder failed</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="158875743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/app_builder%20failed/near/158875743" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/45709appbuilderfailed.html#158875743">Hans-Dieter Hiep (Feb 19 2019 at 12:02)</a>:</h4>
<p>Hi all! I have a question regarding mutual inductive definitions. The following definition:</p>
<div class="codehilite"><pre><span></span><span class="kn">set_option</span> <span class="n">trace</span><span class="bp">.</span><span class="n">app_builder</span> <span class="n">true</span>
<span class="n">mutual</span> <span class="kn">inductive</span> <span class="n">pexp</span><span class="o">,</span> <span class="n">farglist</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">tenv</span> <span class="n">self</span><span class="o">)</span>
<span class="k">with</span> <span class="n">pexp</span><span class="o">:</span> <span class="n">type</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="n">const</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">constant_name</span> <span class="n">α</span><span class="o">):</span> <span class="n">pexp</span> <span class="o">(</span><span class="n">result_type</span> <span class="n">c</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">function_name</span> <span class="n">α</span><span class="o">):</span>
    <span class="n">farglist</span> <span class="o">(</span><span class="n">args_type</span> <span class="n">f</span><span class="o">)</span> <span class="bp">→</span> <span class="n">pexp</span> <span class="o">(</span><span class="n">result_type</span> <span class="n">f</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">lookup</span> <span class="o">{</span><span class="n">ty</span> <span class="o">:</span> <span class="n">type</span> <span class="n">α</span><span class="o">}:</span> <span class="n">rvar</span> <span class="n">e</span> <span class="n">ty</span> <span class="bp">→</span> <span class="n">pexp</span> <span class="n">ty</span>
<span class="bp">|</span> <span class="n">requal</span> <span class="o">{</span><span class="n">c</span> <span class="o">:</span> <span class="n">class_name</span> <span class="n">α</span><span class="o">}:</span>
    <span class="n">pexp</span> <span class="o">(</span><span class="n">type</span><span class="bp">.</span><span class="n">ref</span> <span class="n">c</span><span class="o">)</span> <span class="bp">→</span> <span class="n">pexp</span> <span class="o">(</span><span class="n">type</span><span class="bp">.</span><span class="n">ref</span> <span class="n">c</span><span class="o">)</span> <span class="bp">→</span> <span class="n">pexp</span> <span class="o">(</span><span class="n">boolean</span> <span class="n">α</span><span class="o">)</span>
<span class="k">with</span> <span class="n">farglist</span><span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">type</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="n">nil</span><span class="o">:</span> <span class="n">farglist</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">{</span><span class="n">ty</span> <span class="o">:</span> <span class="n">type</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">type</span> <span class="n">α</span><span class="o">)}:</span>
    <span class="n">pexp</span> <span class="n">ty</span> <span class="bp">→</span> <span class="n">farglist</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">farglist</span> <span class="o">(</span><span class="n">ty</span><span class="bp">::</span><span class="n">l</span><span class="o">)</span>
</pre></div>


<p>Fails with the message:</p>
<div class="codehilite"><pre><span></span>[app_builder] failed to create an &#39;psigma&#39;-application, failed to solve unification constraint for #2 argument (?x_0 → Sort ? =?= type α → Type)
</pre></div>


<p>What can I do to resolve this error?</p>

<a name="158875895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/app_builder%20failed/near/158875895" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/45709appbuilderfailed.html#158875895">Hans-Dieter Hiep (Feb 19 2019 at 12:05)</a>:</h4>
<p>The same error occurs with a smaller definition too:</p>
<div class="codehilite"><pre><span></span><span class="kn">set_option</span> <span class="n">trace</span><span class="bp">.</span><span class="n">app_builder</span> <span class="n">true</span>
<span class="n">mutual</span> <span class="kn">inductive</span> <span class="n">pexp</span><span class="o">,</span> <span class="n">farglist</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">tenv</span> <span class="n">self</span><span class="o">)</span>
<span class="k">with</span> <span class="n">pexp</span><span class="o">:</span> <span class="n">type</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">const</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">constant_name</span> <span class="n">α</span><span class="o">):</span> <span class="n">pexp</span> <span class="o">(</span><span class="n">result_type</span> <span class="n">c</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">function_name</span> <span class="n">α</span><span class="o">):</span> <span class="n">pexp</span> <span class="o">(</span><span class="n">result_type</span> <span class="n">f</span><span class="o">)</span>
<span class="k">with</span> <span class="n">farglist</span><span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">type</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">nil</span><span class="o">:</span> <span class="n">farglist</span> <span class="o">[]</span>
</pre></div>

<a name="158898246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/app_builder%20failed/near/158898246" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/45709appbuilderfailed.html#158898246">Simon Hudon (Feb 19 2019 at 17:10)</a>:</h4>
<p>What about the definition of <code>type</code>?</p>

<a name="158902768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/app_builder%20failed/near/158902768" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/45709appbuilderfailed.html#158902768">Hans-Dieter Hiep (Feb 19 2019 at 18:01)</a>:</h4>
<p><code>type</code> is an inductive type:</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">type</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">names</span> <span class="n">α</span><span class="o">]</span>
<span class="bp">|</span> <span class="n">ref</span><span class="o">:</span> <span class="n">class_name</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">type</span>
<span class="bp">|</span> <span class="n">data</span><span class="o">:</span> <span class="n">record_name</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">type</span>
</pre></div>


<p>To work around, I have continued the formalisation with the "do it yourself" suggestion of Mario, without using nested/mutual. This works out quite well!</p>

<a name="158928167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/app_builder%20failed/near/158928167" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/45709appbuilderfailed.html#158928167">Floris van Doorn (Feb 19 2019 at 23:05)</a>:</h4>
<p>The following even smaller example does work for me:</p>
<div class="codehilite"><pre><span></span>variable {α : Type}
constant type : Type → Type
constant constant_name : Type → Type
constant result_type : constant_name α → type α
noncomputable def function_name := constant_name
constant unknown : Type
constant self : unknown
constant tenv : unknown → Type

set_option trace.app_builder true
mutual inductive pexp, farglist (e : tenv self)
with pexp : type α → Type 1
| const (c : constant_name α): pexp (result_type c)
| app (f : function_name α) : pexp (result_type f)
with farglist: list (type α) → Type 1
| nil: farglist []
</pre></div>


<p>Is the type of any of these definitions very different than what you have? I don't know how robust mutual inductive types are, maybe there is a bug there. One thing you might want to double check is whether there is a universe error? Does any of the definitions already land in <code>Type 1</code> (instead of <code>Type</code>/<code>Type 0</code>)?</p>

<a name="158928376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/app_builder%20failed/near/158928376" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/45709appbuilderfailed.html#158928376">Floris van Doorn (Feb 19 2019 at 23:08)</a>:</h4>
<p>If it's a bug within the compilation of mutual inductive types, then manually indexing the inductive type over <code>type α ⊕ list (type α)</code> is indeed the way to go, although probably a bit more annoying to work with.</p>

<a name="158928758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/app_builder%20failed/near/158928758" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/45709appbuilderfailed.html#158928758">Floris van Doorn (Feb 19 2019 at 23:12)</a>:</h4>
<p>Hmm... I can reproduce your error with the following setup:</p>
<div class="codehilite"><pre><span></span>constant names : Type → Type
attribute [class] names
constant type (α : Type) [names α] : Type
constant constant_name : Type → Type
constant result_type {α : Type} [names α] (c : constant_name α) : type α
noncomputable def function_name := constant_name
constant unknown : Type
constant self : unknown
constant tenv : unknown → Type

variables {α : Type} [names α]
set_option trace.app_builder true
mutual inductive pexp, farglist (e : tenv self)
with pexp: type α → Type
| const (c : constant_name α): pexp (result_type c)
| app (f : function_name α): pexp (result_type f)
with farglist: list (type α) → Type
| nil: farglist []
</pre></div>

<a name="158929174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/app_builder%20failed/near/158929174" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/45709appbuilderfailed.html#158929174">Floris van Doorn (Feb 19 2019 at 23:18)</a>:</h4>
<p>In my last minimal example (where I reproduced the error), I can do another workaround for this mutual inductive type, by giving all arguments to <code>type</code> explicitly:</p>
<div class="codehilite"><pre><span></span>variables {α : Type} [n : names α]
mutual inductive pexp, farglist (e : tenv self)
with pexp: @type α n → Type
| const (c : constant_name α): pexp (result_type c)
| app (f : function_name α): pexp (result_type f)
with farglist: list (@type α n) → Type
| nil: farglist []
</pre></div>


<p>I suspect that this workaround will also work in your case. There indeed seems to be a bug with type class inference in mutual inductive types.</p>

<a name="158959974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/app_builder%20failed/near/158959974" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/45709appbuilderfailed.html#158959974">Hans-Dieter Hiep (Feb 20 2019 at 09:14)</a>:</h4>
<p>Yes, I have indeed used class instances. Previously, I also encountered a problem with nested inductive definitions. Next time, I will remember to supply all implicit arguments. Thanks a lot, Floris!</p>


{% endraw %}
