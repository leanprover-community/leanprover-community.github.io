---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/79292eblast.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/79292eblast.html">eblast</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="160122443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/eblast/near/160122443" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/79292eblast.html#160122443">Jesse Michael Han (Mar 06 2019 at 18:44)</a>:</h4>
<p>I was quite amused to learn that <code>eblast</code> could do essentially all of last week's homework assignment for Jeremy's ITP course (I think <code>finish</code> is, for all practical purposes, stronger, and indeed suffices to replace all calls to <code>eblast</code> below, but I think this is neat demonstration of how far the out-of-the-box SMT tools can get you): </p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">order</span><span class="bp">.</span><span class="n">lattice</span> <span class="n">data</span><span class="bp">.</span><span class="n">nat</span><span class="bp">.</span><span class="n">gcd</span>

<span class="n">class</span> <span class="n">lattice&#39;</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">lattice</span><span class="bp">.</span><span class="n">has_inf</span> <span class="n">α</span><span class="o">,</span> <span class="n">lattice</span><span class="bp">.</span><span class="n">has_sup</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">inf_comm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">x</span> <span class="err">⊓</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">y</span> <span class="err">⊓</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">inf_assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">x</span> <span class="err">⊓</span> <span class="n">y</span> <span class="err">⊓</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">x</span> <span class="err">⊓</span> <span class="o">(</span><span class="n">y</span> <span class="err">⊓</span> <span class="n">z</span><span class="o">))</span>
<span class="o">(</span><span class="n">sup_comm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">x</span> <span class="err">⊔</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">y</span> <span class="err">⊔</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">sup_assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">x</span> <span class="err">⊔</span> <span class="n">y</span> <span class="err">⊔</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">x</span> <span class="err">⊔</span> <span class="o">(</span><span class="n">y</span> <span class="err">⊔</span> <span class="n">z</span><span class="o">))</span>
<span class="o">(</span><span class="n">inf_absorb</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">x</span> <span class="err">⊓</span> <span class="o">(</span><span class="n">x</span> <span class="err">⊔</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">sup_absorb</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">x</span> <span class="err">⊔</span> <span class="o">(</span><span class="n">x</span> <span class="err">⊓</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">lattice&#39;</span>

<span class="n">attribute</span> <span class="o">[</span><span class="n">ematch</span><span class="o">]</span>
  <span class="n">inf_comm</span> <span class="n">inf_assoc</span> <span class="n">sup_comm</span> <span class="n">sup_assoc</span> <span class="n">inf_absorb</span> <span class="n">sup_absorb</span>

<span class="c1">-- inside the namespace, you can refer to the axioms without a prefix</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">lattice&#39;</span> <span class="n">α</span><span class="o">]</span>

<span class="c1">-- the footnote on Wikipedia tells you how to prove this!</span>
<span class="bp">@</span><span class="o">[</span><span class="n">ematch</span><span class="o">]</span><span class="kn">theorem</span> <span class="n">sup_idem</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="err">⊔</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">by</span> <span class="o">{[</span><span class="n">smt</span><span class="o">]</span> <span class="n">eblast</span><span class="o">}</span> <span class="c1">-- :^)</span>

<span class="bp">@</span><span class="o">[</span><span class="n">ematch</span><span class="o">]</span><span class="kn">theorem</span> <span class="n">inf_idem</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="err">⊓</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">by</span> <span class="o">{[</span><span class="n">smt</span><span class="o">]</span> <span class="n">eblast</span><span class="o">}</span>

<span class="kn">protected</span> <span class="n">def</span> <span class="n">le</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="err">⊓</span> <span class="n">y</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_le</span> <span class="n">α</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">lattice&#39;</span><span class="bp">.</span><span class="n">le</span><span class="bp">⟩</span>

<span class="bp">@</span><span class="o">[</span><span class="n">ematch</span><span class="o">]</span><span class="kn">lemma</span> <span class="n">le_unfold</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">y</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="err">⊓</span> <span class="n">y</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">refl</span>

<span class="bp">@</span><span class="o">[</span><span class="n">ematch</span><span class="o">]</span><span class="kn">theorem</span> <span class="n">le_def</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="bp">≤</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="err">⊓</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="bp">@</span><span class="o">[</span><span class="n">ematch</span><span class="o">]</span><span class="kn">theorem</span> <span class="n">le_refl</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">le_def</span><span class="o">,</span> <span class="n">inf_idem</span><span class="o">]</span>

<span class="c1">-- you can use `rw le_def at *` to unfold the definition everywhere</span>

<span class="c1">-- Wikipedia also tells you how to prove this one:</span>

<span class="bp">@</span><span class="o">[</span><span class="n">ematch</span><span class="o">]</span><span class="kn">theorem</span> <span class="n">le_def&#39;</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="bp">≤</span> <span class="n">y</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">y</span> <span class="bp">=</span> <span class="n">x</span> <span class="err">⊔</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">by</span> <span class="o">{</span><span class="n">split</span><span class="bp">;</span> <span class="n">intros</span><span class="bp">;</span> <span class="o">{[</span><span class="n">smt</span><span class="o">]</span> <span class="n">eblast</span><span class="o">}}</span>

<span class="bp">@</span><span class="o">[</span><span class="n">ematch</span><span class="o">]</span><span class="kn">theorem</span> <span class="n">le_trans</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">h&#39;</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">z</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">z</span> <span class="o">:=</span>
<span class="k">by</span> <span class="o">{[</span><span class="n">smt</span><span class="o">]</span> <span class="n">eblast</span><span class="o">}</span>

<span class="bp">@</span><span class="o">[</span><span class="n">ematch</span><span class="o">]</span><span class="kn">theorem</span> <span class="n">le_antisymm</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">h&#39;</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">by</span> <span class="o">{[</span><span class="n">smt</span><span class="o">]</span> <span class="n">eblast</span><span class="o">}</span>

<span class="bp">@</span><span class="o">[</span><span class="n">ematch</span><span class="o">]</span><span class="kn">theorem</span> <span class="n">le_sup_left</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">x</span> <span class="err">⊔</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">by</span> <span class="o">{[</span><span class="n">smt</span><span class="o">]</span> <span class="n">eblast</span><span class="o">}</span>

<span class="bp">@</span><span class="o">[</span><span class="n">ematch</span><span class="o">]</span><span class="kn">theorem</span> <span class="n">le_sup_right</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">x</span> <span class="err">⊔</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">by</span> <span class="o">{[</span><span class="n">smt</span><span class="o">]</span> <span class="n">eblast</span><span class="o">}</span>

<span class="bp">@</span><span class="o">[</span><span class="n">ematch</span><span class="o">]</span><span class="kn">theorem</span> <span class="n">sup_le</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">z</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">z</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="err">⊔</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">z</span> <span class="o">:=</span>
<span class="k">by</span> <span class="o">{[</span><span class="n">smt</span><span class="o">]</span> <span class="n">eblast</span><span class="o">}</span>

<span class="bp">@</span><span class="o">[</span><span class="n">ematch</span><span class="o">]</span><span class="kn">theorem</span> <span class="n">inf_le_left</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="err">⊓</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">by</span> <span class="o">{[</span><span class="n">smt</span><span class="o">]</span> <span class="n">eblast</span><span class="o">}</span>

<span class="bp">@</span><span class="o">[</span><span class="n">ematch</span><span class="o">]</span><span class="kn">theorem</span> <span class="n">inf_le_right</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="err">⊓</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">by</span> <span class="o">{[</span><span class="n">smt</span><span class="o">]</span> <span class="n">eblast</span><span class="o">}</span>

<span class="bp">@</span><span class="o">[</span><span class="n">ematch</span><span class="o">]</span><span class="kn">theorem</span> <span class="n">le_inf</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">z</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">y</span> <span class="err">⊓</span> <span class="n">z</span> <span class="o">:=</span>
<span class="k">by</span> <span class="o">{[</span><span class="n">smt</span><span class="o">]</span> <span class="n">eblast</span><span class="o">}</span>

<span class="kn">end</span> <span class="n">lattice&#39;</span>
</pre></div>

<a name="160133384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/eblast/near/160133384" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/79292eblast.html#160133384">Patrick Massot (Mar 06 2019 at 20:52)</a>:</h4>
<p>I would really love to understand better what finish is doing. Do you understand this?</p>

<a name="160150187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/eblast/near/160150187" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/79292eblast.html#160150187">Jesse Michael Han (Mar 06 2019 at 23:12)</a>:</h4>
<p>The person to ask is really <span class="user-mention" data-user-id="110865">@Jeremy Avigad</span>, but from what I can tell from looking at the source, it is essentially <code>eblast</code> (where <code>ematch</code> is iterated only up to 20 times,  each time followed by <code>cc</code>) wrapped with preprocessing and a tableaux prover.</p>
<p>The preprocessor negates the goal and normalizes the hypotheses by calling <code>simp</code> and pushing negations inwards. It also splits conjunctions and cases on existentials.</p>
<p>The final step is <code>auto.done</code>, which first tries <code>contradiction</code> (if your goal is provable using just classical propositional logic then after the preprocessing, this should close it). Otherwise, it essentially runs <code>eblast</code>, which heuristically instantiates <code>ematch</code> lemmas, hoping that enough is in context for <code>cc</code> to close the goal.</p>

<a name="160150889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/eblast/near/160150889" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/79292eblast.html#160150889">Jesse Michael Han (Mar 06 2019 at 23:23)</a>:</h4>
<p>(also, <code>finish</code> only parses a list of <code>simp</code> lemmas, while <code>[smt] eblast_using</code> will parse a list of <code>texpr</code>s).</p>

<a name="160154103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/eblast/near/160154103" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/79292eblast.html#160154103">Scott Morrison (Mar 07 2019 at 00:14)</a>:</h4>
<p>It's a real pity about the bug in eblast, that causes it to choke on any goals which have two instances of a typeclass, parametrised by different types (e.g. <code>ring A</code> and <code>ring B</code>). <code>eblast</code> is super powerful, and would prove a tonne of stuff, e.g. in category theory, but unusable in the presence of non-trivial type classes.</p>

<a name="160154108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/eblast/near/160154108" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/79292eblast.html#160154108">Scott Morrison (Mar 07 2019 at 00:14)</a>:</h4>
<p>Hopefully someday someone writes a new version of it!</p>

<a name="163371687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/eblast/near/163371687" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/79292eblast.html#163371687">Joseph Corneli (Apr 15 2019 at 11:31)</a>:</h4>
<p><span class="user-mention" data-user-id="116045">@Jesse Michael Han</span> could you comment on how this built-in SMT support compares with the <a href="https://github.com/leanprover/smt2_interface" target="_blank" title="https://github.com/leanprover/smt2_interface">https://github.com/leanprover/smt2_interface</a> ?</p>

<a name="163383513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/eblast/near/163383513" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/79292eblast.html#163383513">Jesse Michael Han (Apr 15 2019 at 14:21)</a>:</h4>
<p>I am not an expert, but I think the built-in SMT support is not quite an SMT solver, while <code>smt2_interface</code> implements a translation from Lean into first-order logic to send out to external SMT solvers, querying them for <code>sat</code> or <code>unsat</code>. I don't think they reconstruct Lean proofs from the proof traces produced by the external solvers, so they add an axiom that lets them treat external solvers like Z3 as oracles.</p>

<a name="163463863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/eblast/near/163463863" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/79292eblast.html#163463863">Joseph Corneli (Apr 16 2019 at 12:23)</a>:</h4>
<p>Thanks for the comment <span class="user-mention" data-user-id="116045">@Jesse Michael Han</span>. I tried this example, which follows the style of yours (I think). I suppose I wouldn't actually expect it to work since I'm mostly shooting in the dark, but the debugging message is not particularly informative.  Is this very far off working do you think?</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">constant</span> <span class="n">cos</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span>

<span class="bp">@</span><span class="o">[</span><span class="n">ematch</span><span class="o">]</span><span class="kn">theorem</span> <span class="n">cos_values</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="bp">∧</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">≥</span> <span class="bp">-</span><span class="mi">1</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="bp">@</span><span class="o">[</span><span class="n">ematch</span><span class="o">]</span><span class="kn">theorem</span> <span class="n">abs_values</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">abs</span> <span class="n">a</span> <span class="bp">&gt;</span> <span class="n">abs</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="bp">@</span><span class="o">[</span><span class="n">ematch</span><span class="o">]</span><span class="kn">theorem</span> <span class="n">cosine_shift</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">by</span> <span class="o">{[</span><span class="n">smt</span><span class="o">]</span> <span class="n">eblast</span><span class="o">}</span>
</pre></div>


<div class="codehilite"><pre><span></span>solve1 tactic failed, focused goal has not been solved
state:
x : ℝ
⊢ cos x + 2 ≠ 0
</pre></div>

<a name="163463983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/eblast/near/163463983" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/79292eblast.html#163463983">Joseph Corneli (Apr 16 2019 at 12:25)</a>:</h4>
<p>For the record I could successfully check the example with z3.</p>
<div class="codehilite"><pre><span></span>(set-logic AUFLIRA)
(declare-fun cos ( Real ) Real)
(set-option :numeral-as-real true)
;; Two basic rules that should combine to give us our conclusion
(assert (forall (( X Real )) (and (&lt;= (cos  X) 1) (&gt;= (cos  X ) (- 1)))))
(assert (forall (( A Real ) ( B Real )) (=&gt; (&gt; (abs A) (abs B)) (not (= (+ A B) 0)))))
;; negate the desired conclusion because we want to check for unsatisfiablity
(assert (forall (( X Real )) (= (+ (cos X) 2) 0)))
(check-sat)
(exit)
</pre></div>


<div class="codehilite"><pre><span></span>$ z3 -smt2 cosine_variant.smt2
unsat
</pre></div>

<a name="163465414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/eblast/near/163465414" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/79292eblast.html#163465414">Joseph Corneli (Apr 16 2019 at 12:45)</a>:</h4>
<p>There seems to only be one mention of eblast in mathlib, but I found this set of examples from a 2017 presentation: <a href="https://github.com/leanprover/presentations/tree/c2094a9da1fecf065fbf7b70a93ce90747cdfe1a/20170116_POPL/smt" target="_blank" title="https://github.com/leanprover/presentations/tree/c2094a9da1fecf065fbf7b70a93ce90747cdfe1a/20170116_POPL/smt">https://github.com/leanprover/presentations/tree/c2094a9da1fecf065fbf7b70a93ce90747cdfe1a/20170116_POPL/smt</a> -- aside from a bit of code drift that seems like a helpful guide...</p>

<a name="163465464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/eblast/near/163465464" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/79292eblast.html#163465464">Jesse Michael Han (Apr 16 2019 at 12:46)</a>:</h4>
<p><code>eblast</code> is <code>ematch, close</code> on a loop, so you can replace it with <code>ematch, ematch, ...</code> to see which lemmas it instantiates</p>

<a name="163465502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/eblast/near/163465502" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/79292eblast.html#163465502">Joseph Corneli (Apr 16 2019 at 12:47)</a>:</h4>
<p>I turned on tracing with <code>set_option trace.smt.ematch true</code> and got this:</p>
<div class="codehilite"><pre><span></span><span class="o">[</span><span class="n">smt</span><span class="bp">.</span><span class="n">ematch</span><span class="o">]</span> <span class="kn">instance</span> <span class="o">[</span><span class="n">abs_values</span><span class="o">],</span> <span class="n">generation</span><span class="o">:</span> <span class="mi">1</span>
<span class="n">abs</span> <span class="o">(</span><span class="n">cos</span> <span class="n">x</span><span class="o">)</span> <span class="bp">&gt;</span> <span class="n">abs</span> <span class="mi">2</span> <span class="bp">→</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">≠</span> <span class="mi">0</span>
<span class="o">[</span><span class="n">smt</span><span class="bp">.</span><span class="n">ematch</span><span class="o">]</span> <span class="kn">instance</span> <span class="o">[</span><span class="n">cos_values</span><span class="o">],</span> <span class="n">generation</span><span class="o">:</span> <span class="mi">1</span>
<span class="n">cos</span> <span class="n">x</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="bp">∧</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">≥</span> <span class="bp">-</span><span class="mi">1</span>
<span class="o">[</span><span class="n">smt</span><span class="bp">.</span><span class="n">ematch</span><span class="o">]</span> <span class="kn">instance</span><span class="o">,</span> <span class="n">generation</span><span class="o">:</span> <span class="mi">1</span><span class="o">,</span> <span class="n">after</span> <span class="n">preprocessing</span>
<span class="n">abs</span> <span class="o">(</span><span class="n">cos</span> <span class="n">x</span><span class="o">)</span> <span class="bp">&gt;</span> <span class="n">abs</span> <span class="mi">2</span> <span class="bp">→</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">≠</span> <span class="mi">0</span>
<span class="o">[</span><span class="n">smt</span><span class="bp">.</span><span class="n">ematch</span><span class="o">]</span> <span class="kn">instance</span><span class="o">,</span> <span class="n">generation</span><span class="o">:</span> <span class="mi">1</span><span class="o">,</span> <span class="n">after</span> <span class="n">preprocessing</span>
<span class="n">cos</span> <span class="n">x</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="bp">∧</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">≥</span> <span class="bp">-</span><span class="mi">1</span>
<span class="o">[</span><span class="n">smt</span><span class="bp">.</span><span class="n">ematch</span><span class="o">]</span> <span class="kn">instance</span> <span class="o">[</span><span class="n">le_antisymm&#39;</span><span class="o">],</span> <span class="n">generation</span><span class="o">:</span> <span class="mi">2</span>
<span class="o">(:</span><span class="n">cos</span> <span class="n">x</span> <span class="bp">≤</span> <span class="mi">1</span><span class="o">:)</span> <span class="bp">→</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span>
<span class="o">[</span><span class="n">smt</span><span class="bp">.</span><span class="n">ematch</span><span class="o">]</span> <span class="kn">instance</span><span class="o">,</span> <span class="n">generation</span><span class="o">:</span> <span class="mi">2</span><span class="o">,</span> <span class="n">after</span> <span class="n">preprocessing</span>
<span class="n">cos</span> <span class="n">x</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="bp">→</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span>
<span class="o">[</span><span class="n">smt</span><span class="bp">.</span><span class="n">ematch</span><span class="o">]</span> <span class="kn">instance</span> <span class="o">[</span><span class="n">le_trans</span><span class="o">],</span> <span class="n">generation</span><span class="o">:</span> <span class="mi">2</span>
<span class="n">cos</span> <span class="n">x</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="bp">→</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">cos</span> <span class="n">x</span>
<span class="o">[</span><span class="n">smt</span><span class="bp">.</span><span class="n">ematch</span><span class="o">]</span> <span class="kn">instance</span> <span class="o">[</span><span class="n">le_trans</span><span class="o">],</span> <span class="n">generation</span><span class="o">:</span> <span class="mi">3</span>
<span class="mi">1</span> <span class="bp">≤</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="bp">→</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="mi">1</span>
<span class="o">[</span><span class="n">smt</span><span class="bp">.</span><span class="n">ematch</span><span class="o">]</span> <span class="kn">instance</span> <span class="o">[</span><span class="n">le_antisymm&#39;</span><span class="o">],</span> <span class="n">generation</span><span class="o">:</span> <span class="mi">3</span>
<span class="o">(:</span><span class="mi">1</span> <span class="bp">≤</span> <span class="n">cos</span> <span class="n">x</span><span class="o">:)</span> <span class="bp">→</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="bp">→</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">cos</span> <span class="n">x</span>
<span class="o">[</span><span class="n">smt</span><span class="bp">.</span><span class="n">ematch</span><span class="o">]</span> <span class="kn">instance</span><span class="o">,</span> <span class="n">generation</span><span class="o">:</span> <span class="mi">2</span><span class="o">,</span> <span class="n">after</span> <span class="n">preprocessing</span>
<span class="n">cos</span> <span class="n">x</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="bp">→</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">cos</span> <span class="n">x</span>
<span class="o">[</span><span class="n">smt</span><span class="bp">.</span><span class="n">ematch</span><span class="o">]</span> <span class="kn">instance</span><span class="o">,</span> <span class="n">generation</span><span class="o">:</span> <span class="mi">3</span><span class="o">,</span> <span class="n">after</span> <span class="n">preprocessing</span>
<span class="mi">1</span> <span class="bp">≤</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="bp">→</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="mi">1</span>
<span class="o">[</span><span class="n">smt</span><span class="bp">.</span><span class="n">ematch</span><span class="o">]</span> <span class="kn">instance</span><span class="o">,</span> <span class="n">generation</span><span class="o">:</span> <span class="mi">3</span><span class="o">,</span> <span class="n">after</span> <span class="n">preprocessing</span>
<span class="mi">1</span> <span class="bp">≤</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="bp">→</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">cos</span> <span class="n">x</span>
<span class="o">[</span><span class="n">smt</span><span class="bp">.</span><span class="n">ematch</span><span class="o">]</span> <span class="kn">instance</span> <span class="o">[</span><span class="n">le_refl</span><span class="o">],</span> <span class="n">generation</span><span class="o">:</span> <span class="mi">3</span>
<span class="n">cos</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">cos</span> <span class="n">x</span>
<span class="o">[</span><span class="n">smt</span><span class="bp">.</span><span class="n">ematch</span><span class="o">]</span> <span class="kn">instance</span> <span class="o">[</span><span class="n">le_refl</span><span class="o">],</span> <span class="n">generation</span><span class="o">:</span> <span class="mi">4</span>
<span class="mi">1</span> <span class="bp">≤</span> <span class="mi">1</span>
<span class="o">[</span><span class="n">smt</span><span class="bp">.</span><span class="n">ematch</span><span class="o">]</span> <span class="kn">instance</span> <span class="o">[</span><span class="n">le_trans</span><span class="o">],</span> <span class="n">generation</span><span class="o">:</span> <span class="mi">3</span>
<span class="mi">1</span> <span class="bp">≤</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">→</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="n">cos</span> <span class="n">x</span>
<span class="o">[</span><span class="n">smt</span><span class="bp">.</span><span class="n">ematch</span><span class="o">]</span> <span class="kn">instance</span> <span class="o">[</span><span class="n">le_trans</span><span class="o">],</span> <span class="n">generation</span><span class="o">:</span> <span class="mi">3</span>
<span class="n">cos</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">cos</span> <span class="n">x</span>
<span class="o">[</span><span class="n">smt</span><span class="bp">.</span><span class="n">ematch</span><span class="o">]</span> <span class="kn">instance</span> <span class="o">[</span><span class="n">le_trans</span><span class="o">],</span> <span class="n">generation</span><span class="o">:</span> <span class="mi">4</span>
<span class="mi">1</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="bp">→</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">→</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="n">cos</span> <span class="n">x</span>
<span class="o">[</span><span class="n">smt</span><span class="bp">.</span><span class="n">ematch</span><span class="o">]</span> <span class="kn">instance</span> <span class="o">[</span><span class="n">le_trans</span><span class="o">],</span> <span class="n">generation</span><span class="o">:</span> <span class="mi">3</span>
<span class="n">cos</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="bp">→</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">≤</span> <span class="mi">1</span>
<span class="o">[</span><span class="n">smt</span><span class="bp">.</span><span class="n">ematch</span><span class="o">]</span> <span class="kn">instance</span> <span class="o">[</span><span class="n">le_trans</span><span class="o">],</span> <span class="n">generation</span><span class="o">:</span> <span class="mi">4</span>
<span class="mi">1</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="bp">→</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="bp">→</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="mi">1</span>
<span class="o">[</span><span class="n">smt</span><span class="bp">.</span><span class="n">ematch</span><span class="o">]</span> <span class="kn">instance</span> <span class="o">[</span><span class="n">le_trans</span><span class="o">],</span> <span class="n">generation</span><span class="o">:</span> <span class="mi">2</span>
<span class="n">cos</span> <span class="n">x</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="bp">→</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="bp">→</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">≤</span> <span class="mi">1</span>
<span class="o">[</span><span class="n">smt</span><span class="bp">.</span><span class="n">ematch</span><span class="o">]</span> <span class="kn">instance</span> <span class="o">[</span><span class="n">le_antisymm&#39;</span><span class="o">],</span> <span class="n">generation</span><span class="o">:</span> <span class="mi">3</span>
<span class="o">(:</span><span class="n">cos</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">cos</span> <span class="n">x</span><span class="o">:)</span> <span class="bp">→</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">cos</span> <span class="n">x</span>
<span class="o">[</span><span class="n">smt</span><span class="bp">.</span><span class="n">ematch</span><span class="o">]</span> <span class="kn">instance</span> <span class="o">[</span><span class="n">le_antisymm&#39;</span><span class="o">],</span> <span class="n">generation</span><span class="o">:</span> <span class="mi">4</span>
<span class="o">(:</span><span class="mi">1</span> <span class="bp">≤</span> <span class="mi">1</span><span class="o">:)</span> <span class="bp">→</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="bp">→</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span>
<span class="o">[</span><span class="n">smt</span><span class="bp">.</span><span class="n">ematch</span><span class="o">]</span> <span class="kn">instance</span><span class="o">,</span> <span class="n">generation</span><span class="o">:</span> <span class="mi">3</span><span class="o">,</span> <span class="n">after</span> <span class="n">preprocessing</span>
<span class="n">cos</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">cos</span> <span class="n">x</span>
<span class="o">[</span><span class="n">smt</span><span class="bp">.</span><span class="n">ematch</span><span class="o">]</span> <span class="kn">instance</span><span class="o">,</span> <span class="n">generation</span><span class="o">:</span> <span class="mi">4</span><span class="o">,</span> <span class="n">after</span> <span class="n">preprocessing</span>
<span class="mi">1</span> <span class="bp">≤</span> <span class="mi">1</span>
<span class="o">[</span><span class="n">smt</span><span class="bp">.</span><span class="n">ematch</span><span class="o">]</span> <span class="kn">instance</span><span class="o">,</span> <span class="n">generation</span><span class="o">:</span> <span class="mi">3</span><span class="o">,</span> <span class="n">after</span> <span class="n">preprocessing</span>
<span class="mi">1</span> <span class="bp">≤</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">→</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="n">cos</span> <span class="n">x</span>
<span class="o">[</span><span class="n">smt</span><span class="bp">.</span><span class="n">ematch</span><span class="o">]</span> <span class="kn">instance</span><span class="o">,</span> <span class="n">generation</span><span class="o">:</span> <span class="mi">3</span><span class="o">,</span> <span class="n">after</span> <span class="n">preprocessing</span>
<span class="n">cos</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">cos</span> <span class="n">x</span>
<span class="o">[</span><span class="n">smt</span><span class="bp">.</span><span class="n">ematch</span><span class="o">]</span> <span class="kn">instance</span><span class="o">,</span> <span class="n">generation</span><span class="o">:</span> <span class="mi">4</span><span class="o">,</span> <span class="n">after</span> <span class="n">preprocessing</span>
<span class="mi">1</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="bp">→</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">→</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="n">cos</span> <span class="n">x</span>
<span class="o">[</span><span class="n">smt</span><span class="bp">.</span><span class="n">ematch</span><span class="o">]</span> <span class="kn">instance</span><span class="o">,</span> <span class="n">generation</span><span class="o">:</span> <span class="mi">3</span><span class="o">,</span> <span class="n">after</span> <span class="n">preprocessing</span>
<span class="n">cos</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="bp">→</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">≤</span> <span class="mi">1</span>
<span class="o">[</span><span class="n">smt</span><span class="bp">.</span><span class="n">ematch</span><span class="o">]</span> <span class="kn">instance</span><span class="o">,</span> <span class="n">generation</span><span class="o">:</span> <span class="mi">4</span><span class="o">,</span> <span class="n">after</span> <span class="n">preprocessing</span>
<span class="mi">1</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="bp">→</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="bp">→</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="mi">1</span>
<span class="o">[</span><span class="n">smt</span><span class="bp">.</span><span class="n">ematch</span><span class="o">]</span> <span class="kn">instance</span><span class="o">,</span> <span class="n">generation</span><span class="o">:</span> <span class="mi">2</span><span class="o">,</span> <span class="n">after</span> <span class="n">preprocessing</span>
<span class="n">cos</span> <span class="n">x</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="bp">→</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="bp">→</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">≤</span> <span class="mi">1</span>
<span class="o">[</span><span class="n">smt</span><span class="bp">.</span><span class="n">ematch</span><span class="o">]</span> <span class="kn">instance</span><span class="o">,</span> <span class="n">generation</span><span class="o">:</span> <span class="mi">3</span><span class="o">,</span> <span class="n">after</span> <span class="n">preprocessing</span>
<span class="n">cos</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">cos</span> <span class="n">x</span>
<span class="o">[</span><span class="n">smt</span><span class="bp">.</span><span class="n">ematch</span><span class="o">]</span> <span class="kn">instance</span><span class="o">,</span> <span class="n">generation</span><span class="o">:</span> <span class="mi">4</span><span class="o">,</span> <span class="n">after</span> <span class="n">preprocessing</span>
<span class="mi">1</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="bp">→</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="bp">→</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span>
</pre></div>

<a name="163465598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/eblast/near/163465598" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/79292eblast.html#163465598">Jesse Michael Han (Apr 16 2019 at 12:48)</a>:</h4>
<p>right, so <code>ematch</code> just writes all these things down and then prays that <code>close</code> (which is just <code>cc</code>) can chain together these facts to close the goal</p>

<a name="163465638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/eblast/near/163465638" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/79292eblast.html#163465638">Jesse Michael Han (Apr 16 2019 at 12:49)</a>:</h4>
<p>there's an option to ask Z3 to produce a proof---maybe you'll see the discrepancy there</p>

<a name="163465644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/eblast/near/163465644" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/79292eblast.html#163465644">Joseph Corneli (Apr 16 2019 at 12:49)</a>:</h4>
<p>huh, OK!</p>

<a name="163466523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/eblast/near/163466523" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/79292eblast.html#163466523">Joseph Corneli (Apr 16 2019 at 13:01)</a>:</h4>
<p>Well here's the z3 proof, I'm not having a moment of clarity reviewing it. </p>
<div class="codehilite"><pre><span></span>(proof
(let (($x160 (forall ((X Real) )(! (let (($x154 (&gt;= (- 2.0) (- 1.0))))
 (let (($x151 (&lt;= (- 2.0) 1.0)))
 (and $x151 $x154))) :qid k!6))
 ))
 (let (($x178 (forall ((X Real) )(! false :qid k!6))
 ))
 (let ((?x179 (lambda ((X Real) )(let ((@x173 (monotonicity (rewrite (= (&lt;= (- 2.0) 1.0) true)) (rewrite (= (&gt;= (- 2.0) (- 1.0)) false)) (= (and (&lt;= (- 2.0) 1.0) (&gt;= (- 2.0) (- 1.0))) (and true false)))))
 (trans @x173 (rewrite (= (and true false) false)) (= (and (&lt;= (- 2.0) 1.0) (&gt;= (- 2.0) (- 1.0))) false))))
 ))
 (let ((@x186 (trans (quant-intro (proof-bind ?x179) (= $x160 $x178)) (elim-unused (= $x178 false)) (= $x160 false))))
 (let (($x40 (forall ((X Real) )(! (let ((?x23 (cos X)))
 (let (($x34 (&gt;= ?x23 (- 1.0))))
 (let (($x25 (&lt;= ?x23 1.0)))
 (and $x25 $x34)))) :qid k!6))
 ))
 (let ((?x161 (lambda ((X Real) )(let (($x154 (&gt;= (- 2.0) (- 1.0))))
 (let (($x151 (&lt;= (- 2.0) 1.0)))
 (let (($x157 (and $x151 $x154)))
 (let ((?x23 (cos X)))
 (let (($x34 (&gt;= ?x23 (- 1.0))))
 (let (($x25 (&lt;= ?x23 1.0)))
 (let (($x37 (and $x25 $x34)))
 (let (($x136 (= ?x23 (- 2.0))))
 (let (($x141 (forall ((X Real) )(! (let ((?x23 (cos X)))
 (= ?x23 (- 2.0))) :qid k!9))
 ))
 (let (($x127 (forall ((X Real) )(! (= (+ (cos X) 2.0) 0.0) :qid k!9))
 ))
 (let ((?x142 (lambda ((X Real) )(let (($x126 (= (+ (cos X) 2.0) 0.0)))
 (let ((@x134 (monotonicity (rewrite (= (+ (cos X) 2.0) (+ 2.0 (cos X)))) (= $x126 (= (+ 2.0 (cos X)) 0.0)))))
 (trans @x134 (rewrite (= (= (+ 2.0 (cos X)) 0.0) (= (cos X) (- 2.0)))) (= $x126 (= (cos X) (- 2.0)))))))
 ))
 (let ((@x146 (mp (asserted $x127) (quant-intro (proof-bind ?x142) (= $x127 $x141)) $x141)))
 (let ((@x156 (monotonicity (unit-resolution ((_ quant-inst X) (or (not $x141) $x136)) @x146 $x136) (= $x34 $x154))))
 (let ((@x153 (monotonicity (unit-resolution ((_ quant-inst X) (or (not $x141) $x136)) @x146 $x136) (= $x25 $x151))))
 (monotonicity @x153 @x156 (= $x37 $x157)))))))))))))))))
 ))
 (let (($x29 (forall ((X Real) )(! (let ((?x23 (cos X)))
 (let (($x25 (&lt;= ?x23 1.0)))
 (and $x25 (&gt;= ?x23 (- 1.0))))) :qid k!6))
 ))
 (let ((?x41 (lambda ((X Real) )(let ((?x23 (cos X)))
 (let (($x34 (&gt;= ?x23 (- 1.0))))
 (let (($x25 (&lt;= ?x23 1.0)))
 (let (($x37 (and $x25 $x34)))
 (let ((@x36 (monotonicity (rewrite (= (- 1.0) (- 1.0))) (= (&gt;= ?x23 (- 1.0)) $x34))))
 (monotonicity @x36 (= (and $x25 (&gt;= ?x23 (- 1.0))) $x37))))))))
 ))
 (let ((@x45 (mp (asserted $x29) (quant-intro (proof-bind ?x41) (= $x29 $x40)) $x40)))
 (mp (mp @x45 (quant-intro (proof-bind ?x161) (= $x40 $x160)) $x160) @x186 false)))))))))))
</pre></div>

<a name="163480087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/eblast/near/163480087" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/79292eblast.html#163480087">Jesse Michael Han (Apr 16 2019 at 15:33)</a>:</h4>
<p>it's probably doing something like, derive false from <code>cos x &lt;= -2</code> and <code>cos x &gt;= -1</code></p>
<p>from the <code>ematch</code> trace, we can see that <code>ematch</code> doesn't know how to move <code>1</code> to the other side of an inequality (and probably doesn't know how to derive the above contradiction either). I don't think it's very good at this kind of arithmetic; from playing around with it, it looks like marking <code>add_le_add_right</code> or the like as <code>@[ematch]</code> drastically slows down each <code>ematch</code> round</p>

<a name="163548319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/eblast/near/163548319" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/79292eblast.html#163548319">Joseph Corneli (Apr 17 2019 at 10:23)</a>:</h4>
<p>Thanks for having a further look <span class="user-mention" data-user-id="116045">@Jesse Michael Han</span>. It sounds like automating a proof inside Lean might need another reasoner that would take the final output from <code>ematch</code> and fiddle around with the arithmetic a bit.  However, I also noticed that the <code>ematch</code> trace for this example doesn't have much to say about <code>2</code>, or <code>-1</code> whereas it comes up with lots of things to say about <code>1</code> and <code>cos x</code>.  In this regard even having another "finisher" would <em>not</em> be enough.</p>
<p>Incidentally I find the proof produced by <code>veriT</code> a bit easier to read than the <code>z3</code> proof, so I've copied it below.  <code>veriT</code> required one extra hint <code>(assert (= C (cos A)))</code> to get started, but it doesn't do much with that.</p>
<div class="codehilite"><pre><span></span>(set-logic AUFLIRA)
(declare-fun cos ( Real ) Real)
(declare-fun A () Real)
(declare-fun C () Real)
(assert (= C (cos A)))
(assert (forall (( X Real )) (and (&lt;= (cos  X) 1) (&gt;= (cos  X ) (- 1)))))
(assert (forall (( A Real ) ( B Real )) (=&gt; (&gt; (abs A) (abs B)) (not (= (+ A B) 0)))))
(assert (forall (( X Real )) (= (+ (cos X) 2) 0)))
(check-sat)
</pre></div>


<div class="codehilite"><pre><span></span>1:(input ((= C (cos A))))
2:(input ((forall  (X Real) (and (&lt;= (cos X) 1) (&gt;= (cos X) (- 1))))))
3:(input ((forall  (A Real) (B Real) (=&gt; (&gt; (abs A) (abs B)) (not (= 0 (+ A B)))))))
4:(input ((forall  (X Real) (= 0 (+ (cos X) 2)))))
5:(tmp_betared ((forall  (@vr0 Real) (and (&lt;= (cos @vr0) 1) (&gt;= (cos @vr0) (- 1))))) 2)
6:(tmp_betared ((forall  (@vr1 Real) (@vr2 Real) (=&gt; (&gt; (abs @vr1) (abs @vr2)) (not (= 0 (+ @vr1 @vr2)))))) 3)
7:(tmp_betared ((forall  (@vr3 Real) (= 0 (+ (cos @vr3) 2)))) 4)
8:(tmp_qnt_tidy ((forall  (@vr4 Real) (and (&lt;= (cos @vr4) 1) (&gt;= (cos @vr4) (- 1))))) 5)
9:(tmp_qnt_tidy ((forall  (@vr4 Real) (@vr5 Real) (=&gt; (&gt; (abs @vr4) (abs @vr5)) (not (= 0 (+ @vr4 @vr5)))))) 6)
10:(tmp_qnt_tidy ((forall  (@vr4 Real) (= 0 (+ (cos @vr4) 2)))) 7)
11:(forall_inst ((or (not (forall  (@vr4 Real) (= 0 (+ (cos @vr4) 2)))) (= 0 (+ (cos A) 2)))))
12:(forall_inst ((or (not (forall  (@vr4 Real) (and (&lt;= (cos @vr4) 1) (&gt;= (cos @vr4) (- 1))))) (and (&lt;= (cos A) 1) (&gt;= (cos A) (- 1))))))
13:(or ((not (forall  (@vr4 Real) (= 0 (+ (cos @vr4) 2)))) (= 0 (+ (cos A) 2))) 11)
14:(resolution ((= 0 (+ (cos A) 2))) 13 10)
15:(and_pos ((not (and (&lt;= (cos A) 1) (&gt;= (cos A) (- 1)))) (&lt;= (cos A) 1)) 0)
16:(and_pos ((not (and (&lt;= (cos A) 1) (&gt;= (cos A) (- 1)))) (&gt;= (cos A) (- 1))) 1)
17:(or ((not (forall  (@vr4 Real) (and (&lt;= (cos @vr4) 1) (&gt;= (cos @vr4) (- 1))))) (and (&lt;= (cos A) 1) (&gt;= (cos A) (- 1)))) 12)
18:(resolution ((and (&lt;= (cos A) 1) (&gt;= (cos A) (- 1)))) 17 8)
19:(resolution ((&lt;= (cos A) 1)) 15 18)
20:(resolution ((&gt;= (cos A) (- 1))) 16 18)
21:(la_generic ((not (&gt;= (cos A) (- 1))) (not (= 0 (+ (cos A) 2)))))
22:(resolution () 21 14 20)
</pre></div>

<a name="163548754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/eblast/near/163548754" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/79292eblast.html#163548754">Joseph Corneli (Apr 17 2019 at 10:31)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> would the alternative approach you mentioned at <a href="https://github.com/leanprover/lean/issues/1940" target="_blank" title="https://github.com/leanprover/lean/issues/1940">https://github.com/leanprover/lean/issues/1940</a> be relevant to the problem here?</p>

<a name="163549505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/eblast/near/163549505" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/79292eblast.html#163549505">Joseph Corneli (Apr 17 2019 at 10:44)</a>:</h4>
<p>Am I correct in thinking that that's the code you have at <a href="https://github.com/semorrison/lean-rewrite-search" target="_blank" title="https://github.com/semorrison/lean-rewrite-search">https://github.com/semorrison/lean-rewrite-search</a> ?</p>

<a name="163605299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/eblast/near/163605299" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/79292eblast.html#163605299">Jesse Michael Han (Apr 17 2019 at 22:08)</a>:</h4>
<p>a pleasant example, from one of Pitt's linear algebra prelims:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span> <span class="n">basic</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span>

<span class="n">def</span> <span class="n">adj</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="bp">@</span><span class="o">[</span><span class="n">ematch</span><span class="o">]</span><span class="kn">lemma</span> <span class="n">adj_adj</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">adj</span> <span class="o">(</span><span class="n">adj</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="bp">@</span><span class="o">[</span><span class="n">ematch</span><span class="o">]</span><span class="kn">theorem</span> <span class="n">adj_antimul</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">adj</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">adj</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">adj</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="bp">@</span><span class="o">[</span><span class="n">ematch</span><span class="o">]</span><span class="n">def</span> <span class="n">is_unitary</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">adj</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">α</span><span class="o">))</span>

<span class="n">attribute</span> <span class="o">[</span><span class="n">ematch</span><span class="o">]</span> <span class="n">mul_assoc</span> <span class="c1">-- sadly necessary</span>

<span class="kn">theorem</span> <span class="n">normal_of_adjoint_eq_unitary_self</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">is_unitary</span> <span class="n">U</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">adj</span> <span class="n">T</span> <span class="bp">=</span> <span class="n">U</span> <span class="bp">*</span> <span class="n">T</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">T</span> <span class="bp">*</span> <span class="o">(</span><span class="n">adj</span> <span class="n">T</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">adj</span> <span class="n">T</span><span class="o">)</span> <span class="bp">*</span> <span class="n">T</span> <span class="o">:=</span>
<span class="k">by</span> <span class="o">{[</span><span class="n">smt</span><span class="o">]</span> <span class="n">eblast</span><span class="o">}</span>
</pre></div>

<a name="163605334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/eblast/near/163605334" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/79292eblast.html#163605334">Jesse Michael Han (Apr 17 2019 at 22:09)</a>:</h4>
<p><del>i'm very pleased that it even knows to insert the <code>1</code> and rewrite backwards using <code>is_unitary</code></del> oops, it only needs to reassociate and then rewrite with <code>is_unitary</code></p>

<a name="163605358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/eblast/near/163605358" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/79292eblast.html#163605358">Kevin Buzzard (Apr 17 2019 at 22:10)</a>:</h4>
<p>You should have seen the automatic theorem provers in action at AITP last week :-)</p>

<a name="163605439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/eblast/near/163605439" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/79292eblast.html#163605439">Kevin Buzzard (Apr 17 2019 at 22:10)</a>:</h4>
<p>But IIRC Lean is supposed to be bridging the gap between ATPs and ITPs so this is definitely a step in the right direction :-)</p>

<a name="164496228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/eblast/near/164496228" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/79292eblast.html#164496228">Scott Morrison (Apr 29 2019 at 23:03)</a>:</h4>
<p><span class="user-mention" data-user-id="122022">@Joseph Corneli</span>, no, <code>rewrite_search</code> will not do anything for your <code>cos x + 2 ≠ 0</code> problem. It searches (rather well, sometimes!) for chains of rewrites.</p>

<a name="164496238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/eblast/near/164496238" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/79292eblast.html#164496238">Scott Morrison (Apr 29 2019 at 23:03)</a>:</h4>
<p>Likely <code>normal_of_adjoint_eq_unitary_self</code> could be done, but I haven't checked.</p>

<a name="164622326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/eblast/near/164622326" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/79292eblast.html#164622326">Joseph Corneli (May 01 2019 at 13:17)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> thanks. I was just starting to read the description of rewrite search in the repo today.</p>

<a name="164622843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/eblast/near/164622843" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/79292eblast.html#164622843">Joseph Corneli (May 01 2019 at 13:27)</a>:</h4>
<p>I also read the Selsam and de Moura paper about congruence closure in ITT. That's maybe a closer comparison?</p>


{% endraw %}

{% include archive_update.html %}