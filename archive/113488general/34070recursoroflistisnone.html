---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/34070recursoroflistisnone.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/34070recursoroflistisnone.html">recursor_of "list" is none</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="171513840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/recursor_of%20%22list%22%20is%20none/near/171513840" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/34070recursoroflistisnone.html#171513840">Cyril Cohen (Jul 23 2019 at 12:38)</a>:</h4>
<p>Dear all, could someone tell me why the result of</p>
<div class="codehilite"><pre><span></span><span class="n">run_cmd</span> <span class="n">do</span> <span class="n">env</span> <span class="err">←</span> <span class="n">get_env</span><span class="o">,</span> <span class="k">let</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">env</span><span class="bp">.</span><span class="n">recursor_of</span> <span class="s2">&quot;list&quot;</span><span class="o">,</span> <span class="n">trace</span> <span class="n">r</span>
</pre></div>


<p>is <code>none</code>?</p>

<a name="171514476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/recursor_of%20%22list%22%20is%20none/near/171514476" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/34070recursoroflistisnone.html#171514476">Chris Hughes (Jul 23 2019 at 12:48)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="bp">#</span><span class="kn">eval</span> <span class="n">do</span> <span class="n">env</span> <span class="err">←</span> <span class="n">get_env</span><span class="o">,</span> <span class="k">let</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">env</span><span class="bp">.</span><span class="n">recursor_of</span> <span class="bp">`</span><span class="n">list</span><span class="bp">.</span><span class="n">rec</span><span class="o">,</span> <span class="n">trace</span> <span class="n">r</span> <span class="c1">--(some list)</span>
</pre></div>


<p>Looks like it returns a type given a recursor.</p>

<a name="171515311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/recursor_of%20%22list%22%20is%20none/near/171515311" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/34070recursoroflistisnone.html#171515311">Kenny Lau (Jul 23 2019 at 12:59)</a>:</h4>
<p>from my experiments it looks like that if it returns none, then the recursor is X.rec</p>

<a name="171515890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/recursor_of%20%22list%22%20is%20none/near/171515890" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/34070recursoroflistisnone.html#171515890">Chris Hughes (Jul 23 2019 at 13:05)</a>:</h4>
<p>Is there an inductive type whose recursor is not <code>X.rec</code>?</p>

<a name="171516178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/recursor_of%20%22list%22%20is%20none/near/171516178" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/34070recursoroflistisnone.html#171516178">Kenny Lau (Jul 23 2019 at 13:08)</a>:</h4>
<p>I don't think so</p>

<a name="171516952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/recursor_of%20%22list%22%20is%20none/near/171516952" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/34070recursoroflistisnone.html#171516952">Wojciech Nawrocki (Jul 23 2019 at 13:17)</a>:</h4>
<p>C++ doc says: "If  n is the name of an elimination rule in env, then return the name of the inductive datatype D<br>
    s.t. n is an elimination rule of D. Otherwise, return none."</p>

<a name="171586890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/recursor_of%20%22list%22%20is%20none/near/171586890" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/34070recursoroflistisnone.html#171586890">Cyril Cohen (Jul 24 2019 at 08:15)</a>:</h4>
<blockquote>
<p>C++ doc says: "If  n is the name of an elimination rule in env, then return the name of the inductive datatype D<br>
    s.t. n is an elimination rule of D. Otherwise, return none."</p>
</blockquote>
<p>Thanks! Looks like the lean doc is wrong (<code>Return the recursor of the given inductive datatype</code>). Where can I find the C++ doc?</p>

<a name="171587111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/recursor_of%20%22list%22%20is%20none/near/171587111" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/34070recursoroflistisnone.html#171587111">Cyril Cohen (Jul 24 2019 at 08:19)</a>:</h4>
<blockquote>
<p>Is there an inductive type whose recursor is not <code>X.rec</code>?</p>
</blockquote>
<p>Since <code>recursor_of</code> did not work, I am indeed using <code>X.rec</code>, but name-based meta-programming is not a very good practice in my experience.</p>

<a name="171588820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/recursor_of%20%22list%22%20is%20none/near/171588820" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/34070recursoroflistisnone.html#171588820">Mario Carneiro (Jul 24 2019 at 08:51)</a>:</h4>
<p>It's not always <code>rec</code> :/</p>

<a name="171588868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/recursor_of%20%22list%22%20is%20none/near/171588868" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/34070recursoroflistisnone.html#171588868">Mario Carneiro (Jul 24 2019 at 08:52)</a>:</h4>
<p>Sometimes it's <code>drec</code></p>

<a name="171588889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/recursor_of%20%22list%22%20is%20none/near/171588889" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/34070recursoroflistisnone.html#171588889">Mario Carneiro (Jul 24 2019 at 08:52)</a>:</h4>
<p>Or rather, I think <code>X.rec</code> always exists but it may not be primitive</p>

<a name="171589124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/recursor_of%20%22list%22%20is%20none/near/171589124" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/34070recursoroflistisnone.html#171589124">Mario Carneiro (Jul 24 2019 at 08:56)</a>:</h4>
<p>I don't see any docs, but from <a href="https://github.com/leanprover-community/lean/blob/master/src/library/vm/vm_environment.cpp#L183-L188" target="_blank" title="https://github.com/leanprover-community/lean/blob/master/src/library/vm/vm_environment.cpp#L183-L188">https://github.com/leanprover-community/lean/blob/master/src/library/vm/vm_environment.cpp#L183-L188</a> it looks like Wojciech's description is correct</p>

<a name="171589397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/recursor_of%20%22list%22%20is%20none/near/171589397" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/34070recursoroflistisnone.html#171589397">Mario Carneiro (Jul 24 2019 at 09:01)</a>:</h4>
<p>Looks like the code actually does that "name based meta-programming" <a href="https://github.com/leanprover-community/lean/blob/master/src/kernel/inductive/inductive.cpp#L183-L186" target="_blank" title="https://github.com/leanprover-community/lean/blob/master/src/kernel/inductive/inductive.cpp#L183-L186">https://github.com/leanprover-community/lean/blob/master/src/kernel/inductive/inductive.cpp#L183-L186</a></p>

<a name="171589501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/recursor_of%20%22list%22%20is%20none/near/171589501" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/34070recursoroflistisnone.html#171589501">Cyril Cohen (Jul 24 2019 at 09:03)</a>:</h4>
<blockquote>
<p>Or rather, I think <code>X.rec</code> always exists but it may not be primitive</p>
</blockquote>
<p>Oww,... I'd say it's always a primitive but not always the most general one (e.g. <code>eq.rec</code> is primitive but not as general as <code>eq.drec</code>). What is the general rule about <code>rec</code> vs <code>drec</code>?</p>

<a name="171589619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/recursor_of%20%22list%22%20is%20none/near/171589619" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/34070recursoroflistisnone.html#171589619">Cyril Cohen (Jul 24 2019 at 09:05)</a>:</h4>
<p>I am wrong it looks like <code>eq.drec</code> is actually programmed using <code>eq.rec</code>... so I did not yet find a case where <code>drec</code> is primitive and <code>rec</code> isn't...</p>

<a name="171590161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/recursor_of%20%22list%22%20is%20none/near/171590161" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/34070recursoroflistisnone.html#171590161">Mario Carneiro (Jul 24 2019 at 09:13)</a>:</h4>
<p>I got it confused. <code>rec</code> is always primitive, but it is dependent only if it doesn't eliminate to Prop. If it does eliminate to Prop then <code>drec</code> is the dependent one</p>

<a name="171590514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/recursor_of%20%22list%22%20is%20none/near/171590514" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/34070recursoroflistisnone.html#171590514">Cyril Cohen (Jul 24 2019 at 09:18)</a>:</h4>
<blockquote>
<p>I got it confused. <code>rec</code> is always primitive, but it is dependent only if it doesn't eliminate to Prop. If it does eliminate to Prop then <code>drec</code> is the dependent one</p>
</blockquote>
<p>ok.... could you tell me the rationale?</p>

<a name="171590633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/recursor_of%20%22list%22%20is%20none/near/171590633" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/34070recursoroflistisnone.html#171590633">Mario Carneiro (Jul 24 2019 at 09:20)</a>:</h4>
<p>No, this is me griping</p>

<a name="171590635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/recursor_of%20%22list%22%20is%20none/near/171590635" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/34070recursoroflistisnone.html#171590635">Cyril Cohen (Jul 24 2019 at 09:20)</a>:</h4>
<blockquote>
<p>I got it confused. <code>rec</code> is always primitive, but it is dependent only if it doesn't eliminate to Prop. If it does eliminate to Prop then <code>drec</code> is the dependent one</p>
</blockquote>
<p>I'm not sure I understood the rule... do you mean if it admits strong elimination? (i.e. elimination to Type of an inductive in Prop ?)</p>

<a name="171590667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/recursor_of%20%22list%22%20is%20none/near/171590667" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/34070recursoroflistisnone.html#171590667">Mario Carneiro (Jul 24 2019 at 09:21)</a>:</h4>
<p>Ah, actually it's not strong elimination that is the deciding factor, it is whether the inductive itself is a prop</p>

<a name="171590672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/recursor_of%20%22list%22%20is%20none/near/171590672" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/34070recursoroflistisnone.html#171590672">Mario Carneiro (Jul 24 2019 at 09:21)</a>:</h4>
<p>for example <code>or</code> and <code>eq</code> both have a <code>drec</code></p>

<a name="171590679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/recursor_of%20%22list%22%20is%20none/near/171590679" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/34070recursoroflistisnone.html#171590679">Mario Carneiro (Jul 24 2019 at 09:21)</a>:</h4>
<p>but <code>nat</code> doesn't</p>

<a name="171590751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/recursor_of%20%22list%22%20is%20none/near/171590751" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/34070recursoroflistisnone.html#171590751">Cyril Cohen (Jul 24 2019 at 09:22)</a>:</h4>
<p>ok, is it using proof irrelevance for prop to derive drec from rec? (because otherwise I do not see how it is possible)</p>

<a name="171590754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/recursor_of%20%22list%22%20is%20none/near/171590754" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/34070recursoroflistisnone.html#171590754">Mario Carneiro (Jul 24 2019 at 09:22)</a>:</h4>
<p>yes</p>

<a name="171590772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/recursor_of%20%22list%22%20is%20none/near/171590772" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/34070recursoroflistisnone.html#171590772">Mario Carneiro (Jul 24 2019 at 09:23)</a>:</h4>
<p>If I were king of lean I would make the dependent version always be called <code>rec</code> and always be primitive</p>

<a name="171590783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/recursor_of%20%22list%22%20is%20none/near/171590783" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/34070recursoroflistisnone.html#171590783">Cyril Cohen (Jul 24 2019 at 09:23)</a>:</h4>
<blockquote>
<p>yes</p>
</blockquote>
<p>ok, this will not make my life easy ^^'</p>

<a name="171590791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/recursor_of%20%22list%22%20is%20none/near/171590791" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/34070recursoroflistisnone.html#171590791">Mario Carneiro (Jul 24 2019 at 09:23)</a>:</h4>
<p>The fact that you can derive it from the non-dependent version is a cute fact but not worth breaking the pattern</p>

<a name="171590793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/recursor_of%20%22list%22%20is%20none/near/171590793" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/34070recursoroflistisnone.html#171590793">Cyril Cohen (Jul 24 2019 at 09:23)</a>:</h4>
<blockquote>
<p>If I were king of lean I would make the dependent version always be called <code>rec</code> and always be primitive</p>
</blockquote>
<p>Now you make me wish you were the king of lean</p>

<a name="171590894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/recursor_of%20%22list%22%20is%20none/near/171590894" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/34070recursoroflistisnone.html#171590894">Cyril Cohen (Jul 24 2019 at 09:25)</a>:</h4>
<p>Writing parametricity translation of inductive families is already difficult without having to take into account discrepancies in the patterns of primitives... :'(</p>

<a name="171594631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/recursor_of%20%22list%22%20is%20none/near/171594631" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/34070recursoroflistisnone.html#171594631">Sebastian Ullrich (Jul 24 2019 at 10:34)</a>:</h4>
<blockquote>
<p>If I were king of lean I would make the dependent version always be called <code>rec</code> and always be primitive</p>
</blockquote>
<p>Like this? <a href="https://github.com/leanprover/lean4/commit/a7d08d2f3dd608a70d41c92ca5559c2528e21ee5" target="_blank" title="https://github.com/leanprover/lean4/commit/a7d08d2f3dd608a70d41c92ca5559c2528e21ee5">https://github.com/leanprover/lean4/commit/a7d08d2f3dd608a70d41c92ca5559c2528e21ee5</a></p>


{% endraw %}

{% include archive_update.html %}