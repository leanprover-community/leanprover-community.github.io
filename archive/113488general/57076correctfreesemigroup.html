---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/57076correctfreesemigroup.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html">"correct" free semigroup</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="158737026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158737026" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158737026">Kenny Lau (Feb 17 2019 at 09:58)</a>:</h4>
<p>Which one is the correct version of free semigroup over a type?</p>

<a name="158737035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158737035" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158737035">Kenny Lau (Feb 17 2019 at 09:59)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="kn">inductive</span> <span class="n">free_semigroup</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="bp">|</span> <span class="n">of</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">free_semigroup</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">free_semigroup</span> <span class="bp">→</span> <span class="n">free_semigroup</span>

<span class="kn">namespace</span> <span class="n">free_semigroup</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>

<span class="n">def</span> <span class="n">mul</span> <span class="o">:</span> <span class="n">free_semigroup</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">free_semigroup</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">free_semigroup</span> <span class="n">α</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">of</span> <span class="n">x</span><span class="o">)</span> <span class="n">L2</span> <span class="o">:=</span> <span class="n">cons</span> <span class="n">x</span> <span class="n">L2</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">cons</span> <span class="n">x</span> <span class="n">L1</span><span class="o">)</span> <span class="n">L2</span> <span class="o">:=</span> <span class="n">cons</span> <span class="n">x</span> <span class="o">(</span><span class="n">mul</span> <span class="n">L1</span> <span class="n">L2</span><span class="o">)</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">semigroup</span> <span class="o">(</span><span class="n">free_semigroup</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">mul</span> <span class="o">:=</span> <span class="n">mul</span><span class="o">,</span>
  <span class="n">mul_assoc</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">L1</span> <span class="n">L2</span> <span class="n">L3</span><span class="o">,</span> <span class="n">free_semigroup</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">L1</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">rfl</span><span class="o">)</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">L1</span> <span class="n">ih</span><span class="o">,</span>
    <span class="n">congr_arg</span> <span class="o">(</span><span class="n">cons</span> <span class="n">x</span><span class="o">)</span> <span class="n">ih</span> <span class="o">}</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">semigroup</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>

<span class="n">def</span> <span class="n">lift</span> <span class="o">:</span> <span class="n">free_semigroup</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">of</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">x</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">cons</span> <span class="n">x</span> <span class="n">tl</span><span class="o">)</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">lift</span> <span class="n">tl</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">lift_of</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">lift</span> <span class="n">f</span> <span class="o">(</span><span class="n">of</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">lift_mul</span> <span class="o">(</span><span class="n">L1</span> <span class="n">L2</span><span class="o">)</span> <span class="o">:</span> <span class="n">lift</span> <span class="n">f</span> <span class="o">(</span><span class="n">L1</span> <span class="bp">*</span> <span class="n">L2</span><span class="o">)</span> <span class="bp">=</span> <span class="n">lift</span> <span class="n">f</span> <span class="n">L1</span> <span class="bp">*</span> <span class="n">lift</span> <span class="n">f</span> <span class="n">L2</span> <span class="o">:=</span>
<span class="n">free_semigroup</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">L1</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">rfl</span><span class="o">)</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">tl</span> <span class="n">ih</span><span class="o">,</span>
<span class="k">show</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">lift</span> <span class="n">f</span> <span class="o">(</span><span class="n">tl</span> <span class="bp">*</span> <span class="n">L2</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">lift</span> <span class="n">f</span> <span class="n">tl</span> <span class="bp">*</span> <span class="n">lift</span> <span class="n">f</span> <span class="n">L2</span><span class="o">,</span>
<span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">mul_assoc</span><span class="o">,</span> <span class="n">ih</span><span class="o">]</span>

<span class="kn">theorem</span> <span class="n">lift_unique</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">free_semigroup</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f</span> <span class="bp">=</span> <span class="n">lift</span> <span class="o">(</span><span class="n">f</span> <span class="err">∘</span> <span class="n">of</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">funext</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">L</span><span class="o">,</span> <span class="n">free_semigroup</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">L</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">rfl</span><span class="o">)</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">tl</span> <span class="n">ih</span><span class="o">,</span>
<span class="o">(</span><span class="n">hf</span> <span class="o">(</span><span class="n">of</span> <span class="n">x</span><span class="o">)</span> <span class="n">tl</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="err">$</span> <span class="n">congr_arg</span> <span class="bp">_</span> <span class="n">ih</span>

<span class="kn">end</span> <span class="n">free_semigroup</span>
</pre></div>

<a name="158737037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158737037" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158737037">Kenny Lau (Feb 17 2019 at 09:59)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">list</span><span class="bp">.</span><span class="n">basic</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="n">def</span> <span class="n">free_semigroup</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">L</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">L</span> <span class="bp">≠</span> <span class="o">[]</span> <span class="o">}</span>

<span class="kn">namespace</span> <span class="n">free_semigroup</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">semigroup</span> <span class="o">(</span><span class="n">free_semigroup</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">mul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">L1</span> <span class="n">L2</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">L1</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">++</span> <span class="n">L2</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">L1</span><span class="bp">.</span><span class="mi">2</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">append_eq_nil</span><span class="bp">.</span><span class="mi">1</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">mul_assoc</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">L1</span> <span class="n">L2</span> <span class="n">L3</span><span class="o">,</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">eq</span> <span class="err">$</span> <span class="n">list</span><span class="bp">.</span><span class="n">append_assoc</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">}</span>

<span class="n">def</span> <span class="n">of</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">free_semigroup</span> <span class="n">α</span> <span class="o">:=</span>
<span class="bp">⟨</span><span class="o">[</span><span class="n">x</span><span class="o">],</span> <span class="n">list</span><span class="bp">.</span><span class="n">cons_ne_nil</span> <span class="bp">_</span> <span class="bp">_⟩</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">semigroup</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>

<span class="n">def</span> <span class="n">lift&#39;</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">L</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">,</span> <span class="n">L</span> <span class="bp">≠</span> <span class="o">[]</span> <span class="bp">→</span> <span class="n">β</span>
<span class="bp">|</span> <span class="o">[]</span>            <span class="n">H</span>  <span class="o">:=</span> <span class="n">absurd</span> <span class="n">rfl</span> <span class="n">H</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">hd</span><span class="bp">::</span><span class="o">[])</span>      <span class="n">H</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">hd</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">hd</span><span class="bp">::</span><span class="n">hd2</span><span class="bp">::</span><span class="n">tl</span><span class="o">)</span> <span class="n">H</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">hd</span> <span class="bp">*</span> <span class="n">lift&#39;</span> <span class="o">(</span><span class="n">hd2</span><span class="bp">::</span><span class="n">tl</span><span class="o">)</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">cons_ne_nil</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span>

<span class="n">def</span> <span class="n">lift</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">free_semigroup</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">β</span> <span class="o">:=</span>
<span class="n">lift&#39;</span> <span class="n">f</span> <span class="n">L</span><span class="bp">.</span><span class="mi">1</span> <span class="n">L</span><span class="bp">.</span><span class="mi">2</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">lift_of</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">lift</span> <span class="n">f</span> <span class="o">(</span><span class="n">of</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">lift_mul</span> <span class="o">(</span><span class="n">L1</span> <span class="n">L2</span><span class="o">)</span> <span class="o">:</span> <span class="n">lift</span> <span class="n">f</span> <span class="o">(</span><span class="n">L1</span> <span class="bp">*</span> <span class="n">L2</span><span class="o">)</span> <span class="bp">=</span> <span class="n">lift</span> <span class="n">f</span> <span class="n">L1</span> <span class="bp">*</span> <span class="n">lift</span> <span class="n">f</span> <span class="n">L2</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">change</span> <span class="n">lift&#39;</span> <span class="n">f</span> <span class="o">(</span><span class="n">L1</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">++</span> <span class="n">L2</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span> <span class="bp">_</span> <span class="bp">=</span> <span class="n">lift&#39;</span> <span class="n">f</span> <span class="n">L1</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">_</span> <span class="bp">*</span> <span class="n">lift&#39;</span> <span class="n">f</span> <span class="n">L2</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">L1</span> <span class="k">with</span> <span class="n">L1</span> <span class="n">h1</span><span class="o">,</span> <span class="n">cases</span> <span class="n">L2</span> <span class="k">with</span> <span class="n">L2</span> <span class="n">h2</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">L1</span> <span class="k">with</span> <span class="n">hd</span> <span class="n">tl</span> <span class="n">ih</span><span class="o">,</span> <span class="o">{</span> <span class="n">exact</span> <span class="o">(</span><span class="n">h1</span> <span class="n">rfl</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span> <span class="o">},</span>
  <span class="n">cases</span> <span class="n">tl</span> <span class="k">with</span> <span class="n">hd2</span> <span class="n">tl</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">L2</span> <span class="k">with</span> <span class="n">hd3</span> <span class="n">tl2</span><span class="o">,</span> <span class="o">{</span> <span class="n">exact</span> <span class="o">(</span><span class="n">h2</span> <span class="n">rfl</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span> <span class="o">},</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="n">change</span> <span class="n">f</span> <span class="n">hd</span> <span class="bp">*</span> <span class="bp">_</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">hd</span> <span class="bp">*</span> <span class="bp">_</span> <span class="bp">*</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rw</span> <span class="n">mul_assoc</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">congr_arg</span> <span class="o">((</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">hd</span><span class="o">))</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">ih</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">cons_ne_nil</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span>
<span class="kn">end</span>

<span class="kn">theorem</span> <span class="n">lift_unique</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">free_semigroup</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f</span> <span class="bp">=</span> <span class="n">lift</span> <span class="o">(</span><span class="n">f</span> <span class="err">∘</span> <span class="n">of</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">funext</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">L</span><span class="o">,</span> <span class="n">H</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">list</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">L</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="o">(</span><span class="n">h</span> <span class="n">rfl</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">hd</span> <span class="n">tl</span> <span class="n">ih</span> <span class="n">h</span><span class="o">,</span> <span class="n">list</span><span class="bp">.</span><span class="n">cases_on</span> <span class="n">tl</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">ih</span> <span class="n">h</span><span class="o">,</span> <span class="n">rfl</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">hd2</span> <span class="n">tl</span> <span class="n">ih</span> <span class="n">h</span><span class="o">,</span> <span class="o">(</span><span class="n">hf</span> <span class="o">(</span><span class="n">of</span> <span class="n">hd</span><span class="o">)</span> <span class="bp">⟨</span><span class="n">hd2</span><span class="bp">::</span><span class="n">tl</span><span class="o">,</span> <span class="n">list</span><span class="bp">.</span><span class="n">cons_ne_nil</span> <span class="bp">_</span> <span class="bp">_⟩</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="err">$</span> <span class="n">congr_arg</span> <span class="bp">_</span> <span class="o">(</span><span class="n">ih</span> <span class="bp">_</span><span class="o">))</span> <span class="n">ih</span> <span class="n">h</span><span class="o">)</span> <span class="n">H</span>

<span class="kn">end</span> <span class="n">free_semigroup</span>
</pre></div>

<a name="158737153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158737153" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158737153">Mario Carneiro (Feb 17 2019 at 10:03)</a>:</h4>
<p>I would actually prefer A x list A over the subtype of nonempty lists</p>

<a name="158737306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158737306" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158737306">Kenny Lau (Feb 17 2019 at 10:08)</a>:</h4>
<p>aha, a third construction</p>

<a name="158738775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158738775" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158738775">Kenny Lau (Feb 17 2019 at 10:54)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">free_semigroup</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="o">:=</span>
<span class="n">α</span> <span class="bp">×</span> <span class="n">list</span> <span class="n">α</span>

<span class="kn">namespace</span> <span class="n">free_semigroup</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">semigroup</span> <span class="o">(</span><span class="n">free_semigroup</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">mul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">L1</span> <span class="n">L2</span><span class="o">,</span> <span class="o">(</span><span class="n">L1</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span> <span class="n">L1</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">++</span> <span class="n">L2</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">::</span> <span class="n">L2</span><span class="bp">.</span><span class="mi">2</span><span class="o">),</span>
  <span class="n">mul_assoc</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">L1</span> <span class="n">L2</span> <span class="n">L3</span><span class="o">,</span> <span class="n">prod</span><span class="bp">.</span><span class="n">ext</span> <span class="n">rfl</span> <span class="err">$</span> <span class="n">list</span><span class="bp">.</span><span class="n">append_assoc</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">}</span>

<span class="n">def</span> <span class="n">of</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">free_semigroup</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="o">[])</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">semigroup</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>

<span class="n">def</span> <span class="n">lift&#39;</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span>
<span class="bp">|</span> <span class="n">x</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">x</span>
<span class="bp">|</span> <span class="n">x</span> <span class="o">(</span><span class="n">hd</span><span class="bp">::</span><span class="n">tl</span><span class="o">)</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">lift&#39;</span> <span class="n">hd</span> <span class="n">tl</span>

<span class="n">def</span> <span class="n">lift</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">free_semigroup</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">β</span> <span class="o">:=</span>
<span class="n">lift&#39;</span> <span class="n">f</span> <span class="n">x</span><span class="bp">.</span><span class="mi">1</span> <span class="n">x</span><span class="bp">.</span><span class="mi">2</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">lift_of</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">lift</span> <span class="n">f</span> <span class="o">(</span><span class="n">of</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">lift_mul</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">lift</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">lift</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">lift</span> <span class="n">f</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">cases</span> <span class="n">x</span> <span class="k">with</span> <span class="n">x</span> <span class="n">L1</span><span class="o">,</span> <span class="n">cases</span> <span class="n">y</span> <span class="k">with</span> <span class="n">y</span> <span class="n">L2</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">L1</span> <span class="k">with</span> <span class="n">hd</span> <span class="n">tl</span> <span class="n">ih</span> <span class="n">generalizing</span> <span class="n">x</span><span class="o">,</span> <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="n">change</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">lift</span> <span class="n">f</span> <span class="o">((</span><span class="n">hd</span><span class="o">,</span> <span class="n">tl</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="n">L2</span><span class="o">))</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">lift</span> <span class="n">f</span> <span class="o">(</span><span class="n">hd</span><span class="o">,</span> <span class="n">tl</span><span class="o">)</span> <span class="bp">*</span> <span class="n">lift</span> <span class="n">f</span> <span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="n">L2</span><span class="o">),</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">ih</span><span class="o">,</span> <span class="n">mul_assoc</span><span class="o">]</span>
<span class="kn">end</span>

<span class="kn">theorem</span> <span class="n">lift_unique</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">free_semigroup</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f</span> <span class="bp">=</span> <span class="n">lift</span> <span class="o">(</span><span class="n">f</span> <span class="err">∘</span> <span class="n">of</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">funext</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">L</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">list</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">L</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">rfl</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hd</span> <span class="n">tl</span> <span class="n">ih</span> <span class="n">x</span><span class="o">,</span>
  <span class="o">(</span><span class="n">hf</span> <span class="o">(</span><span class="n">of</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">hd</span><span class="o">,</span> <span class="n">tl</span><span class="o">))</span><span class="bp">.</span><span class="n">trans</span> <span class="err">$</span> <span class="n">congr_arg</span> <span class="bp">_</span> <span class="err">$</span> <span class="n">ih</span> <span class="bp">_</span><span class="o">)</span> <span class="n">x</span>

<span class="kn">end</span> <span class="n">free_semigroup</span>
</pre></div>

<a name="158741011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158741011" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158741011">Kevin Buzzard (Feb 17 2019 at 12:03)</a>:</h4>
<p>The "core API" of a construction such as a free functor (or more generally some adjoint functor) is presumably the definition (e.g. an explicit construction of the free object) and the proof that it satisfies the universal property (which as Kenny pointed out to me recently is data, it's an equiv of hom-sets). As a mathematician I have been led to believe that any other property that a mathematician might want from the construction should be deducible from the universal property. </p>
<p>This leads me to several questions, which I have only recently begun to somehow understand from the point of view of Lean code. First, if one can prove the universal property for all three definitions, then perhaps one has all a mathematician needs, and so maybe a mathematician does not care which construction to use. From a CS point of view I would imagine there are more issues at stake though. What are these issues?</p>
<p>Second, I think I know examples -- although rather few -- where there are lemmas which are useful for a mathematician to have in practice, but which are perhaps more easily proved using the construction rather than the universal property. The one that immediately springs to mind is in the context of the tensor product of two modules <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10903em;">M</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span></span> over a commutative ring <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.00773em;">R</span></span></span></span>. It's a theorem that any element of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">M\otimes_R N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mbin"><span class="mbin">⊗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span></span> can be written (usually highly non-uniquely) as a finite sum <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>t</mi></msubsup><msub><mi>m</mi><mi>i</mi></msub><mo>⊗</mo><msub><mi>n</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\sum_{i=1}^t m_i\otimes n_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.933456em;"></span><span class="strut bottom" style="height:1.233166em;vertical-align:-0.29971000000000003em;"></span><span class="base"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.933456em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">i</span><span class="mrel mtight">=</span><span class="mord mathrm mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"></span></span></span></span></span><span class="mord"><span class="mord mathit">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mbin">⊗</span><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span>, where <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>m</mi><mi>i</mi></msub><mo>∈</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">m_i\in M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mrel">∈</span><span class="mord mathit" style="margin-right:0.10903em;">M</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mi>i</mi></msub><mo>∈</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">n_i\in N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mrel">∈</span><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span></span>. This is useful in commutative algebra to "reduce to the Noetherian case" -- any element of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">M\otimes_R N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mbin"><span class="mbin">⊗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span></span> is in the image of a natural map from <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>M</mi><mo mathvariant="normal">′</mo></msup><msub><mo>⊗</mo><mi>R</mi></msub><msup><mi>N</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">M'\otimes_R N'</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:0.901892em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">′</span></span></span></span></span></span></span></span></span><span class="mbin"><span class="mbin">⊗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> where <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>M</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">M'</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:0.751892em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>N</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">N'</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:0.751892em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> are finitely-generated submodules of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10903em;">M</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span></span>. If I remember correctly, the proof in Atiyah--Macdonald is "this follows from the explicit construction of the tensor product as a quotient of the free abelian group on pairs <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(m,n)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">(</span><span class="mord mathit">m</span><span class="mpunct">,</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>" rather than "this follows from the universal property". I have not thought about how a universal property proof would go, but it's tantamount to saying that the image of the universal bilinear map <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo>×</mo><mi>N</mi><mo>→</mo><mi>M</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">M\times N\to M\otimes_R N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mbin">×</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mbin"><span class="mbin">⊗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span></span> generates the tensor product.</p>
<p>And finally, there is the Strickland Predicate. For localisations I am currently very much of the opinion that Neil's definition of a predicate saying "if these criteria are satisfied, then this ring is isomorphic to the localisation of this ring" is a useful addition. The criteria are <em>not</em> "it satisfies the right universal property" and they are <em>not</em> "by the universal property there's a map from the localisation to this ring, and the criterion is that it's a bijection" (although of course they are provably equivalent to these predicates). Neil's predicate is more intrinsic to the situation, and my feeling is that his code seems to unify some work which I did multiple times in the schemes project. Is this something to do with the fact that we have lots of universes or is there a more fundamental issue at stake?</p>
<p>Can any of <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> , <span class="user-mention" data-user-id="110032">@Reid Barton</span> or <span class="user-mention" data-user-id="130308">@Neil Strickland</span>  enlighten me as to what is actually going on here?</p>

<a name="158741191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158741191" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158741191">Mario Carneiro (Feb 17 2019 at 12:08)</a>:</h4>
<p>As you've identified, the way that we want to interact with a type varies by application. Sometimes we want it to be an object with a universal property, sometimes we want it to be a concrete construction, sometimes we want it to be a <em>different</em> concrete construction. And when you throw in DTT you always wish that your view du jour is the definitional one, but that's not possible</p>

<a name="158741196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158741196" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158741196">Mario Carneiro (Feb 17 2019 at 12:08)</a>:</h4>
<p>What is possible is to provide a number of interfaces to the type so you have what you need for the application</p>

<a name="158741272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158741272" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158741272">Mario Carneiro (Feb 17 2019 at 12:11)</a>:</h4>
<p>As for Neil's predicate, you may have identified an important aspect here. It's not enough to know that A is isomorphic to B[1/f] usually - you want an actual isomorphism for computability reasons and also because you will want to say things about this map later</p>

<a name="158741279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158741279" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158741279">Kevin Buzzard (Feb 17 2019 at 12:11)</a>:</h4>
<p>So the correct choice for the definition of free semigroup is: look at all the code in the world which uses free semigroups, and in each case consider the definition which would have made the code easiest to write or to use (in the sense that you maximise the number of proofs which would have been <code>rfl</code>) and then you choose that definition?</p>

<a name="158741280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158741280" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158741280">Mario Carneiro (Feb 17 2019 at 12:11)</a>:</h4>
<p>If it's unique, then you can treat it as a predicate, but otherwise it's data</p>

<a name="158741285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158741285" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158741285">Kenny Lau (Feb 17 2019 at 12:11)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> for the tensor product case, it reduces to the facts that (1) tensor product commutes with direct limit and (2) every module is a direct limit of finitely generated modules</p>

<a name="158741337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158741337" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158741337">Kevin Buzzard (Feb 17 2019 at 12:12)</a>:</h4>
<p>Kenny -- exactly! So we can do a whole bunch of commutative algebra and universal properties and then come up with a beautiful conceptual proof of this fact.</p>

<a name="158741340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158741340" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158741340">Kevin Buzzard (Feb 17 2019 at 12:12)</a>:</h4>
<p>Or we can just say "oh look it's trivial from the construction"</p>

<a name="158741342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158741342" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158741342">Mario Carneiro (Feb 17 2019 at 12:12)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>  yes, although you can restrict attention to the theorems that should be in the free semigroup file (among all theorems in the world)</p>

<a name="158741355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158741355" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158741355">Kevin Buzzard (Feb 17 2019 at 12:13)</a>:</h4>
<p>So this sounds like an experimental science -- Kenny has three candidate definitions and there's no obvious algorithm to work out which is best -- we need the users to tell us.</p>

<a name="158741358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158741358" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158741358">Mario Carneiro (Feb 17 2019 at 12:13)</a>:</h4>
<p>There are more theorems to prove than just the universal property though</p>

<a name="158741359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158741359" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158741359">Kevin Buzzard (Feb 17 2019 at 12:13)</a>:</h4>
<p>Why?</p>

<a name="158741384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158741384" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158741384">Mario Carneiro (Feb 17 2019 at 12:14)</a>:</h4>
<p>If it was just that, then I agree that the quotient is best</p>

<a name="158741408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158741408" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158741408">Kevin Buzzard (Feb 17 2019 at 12:14)</a>:</h4>
<p>I'm serious -- a mathematician would say "prove the universal property; everything else follows from it"</p>

<a name="158741414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158741414" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158741414">Mario Carneiro (Feb 17 2019 at 12:14)</a>:</h4>
<p>is that the complete theory of free semigroups? If so I'm doubtful we even need the definition</p>

<a name="158741419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158741419" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158741419">Kevin Buzzard (Feb 17 2019 at 12:14)</a>:</h4>
<p>Let's say for the sake of argument that they have tonnes of applications everywhere.</p>

<a name="158741437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158741437" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158741437">Kevin Buzzard (Feb 17 2019 at 12:15)</a>:</h4>
<p>It's still the case that every theorem should follow from the universal property</p>

<a name="158741438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158741438" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158741438">Mario Carneiro (Feb 17 2019 at 12:15)</a>:</h4>
<p>Sure everything else follows from it, but that's just another way to say you've defined the free semigroup</p>

<a name="158741442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158741442" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158741442">Kevin Buzzard (Feb 17 2019 at 12:15)</a>:</h4>
<p>So what I'm asking is what the issues are in practice with this approach, because as a mathematician I am blind to them.</p>

<a name="158741444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158741444" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158741444">Mario Carneiro (Feb 17 2019 at 12:15)</a>:</h4>
<p>you could just write down any definition and say "everything else follows"... well follow already</p>

<a name="158741448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158741448" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158741448">Kevin Buzzard (Feb 17 2019 at 12:16)</a>:</h4>
<p>The one key piece of work is the universal property.</p>

<a name="158741491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158741491" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158741491">Mario Carneiro (Feb 17 2019 at 12:16)</a>:</h4>
<p>you won't really feel the issues until you use the definition</p>

<a name="158741495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158741495" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158741495">Kevin Buzzard (Feb 17 2019 at 12:16)</a>:</h4>
<p>I'm saying that once the universal property is proved, one might argue that the definition should never be used again</p>

<a name="158741499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158741499" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158741499">Mario Carneiro (Feb 17 2019 at 12:16)</a>:</h4>
<p>I'm considering the universal property as part of the definition here</p>

<a name="158741503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158741503" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158741503">Kevin Buzzard (Feb 17 2019 at 12:17)</a>:</h4>
<p>I mean the _construction_ should never be used again</p>

<a name="158741510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158741510" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158741510">Mario Carneiro (Feb 17 2019 at 12:17)</a>:</h4>
<p>sure, I guess... we'll have to see</p>

<a name="158741512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158741512" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158741512">Mario Carneiro (Feb 17 2019 at 12:17)</a>:</h4>
<p>that's the point</p>

<a name="158741514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158741514" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158741514">Kevin Buzzard (Feb 17 2019 at 12:17)</a>:</h4>
<p>I'm speaking as a mathematician here, I'm explaining the view of the world we preach</p>

<a name="158741518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158741518" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158741518">Mario Carneiro (Feb 17 2019 at 12:17)</a>:</h4>
<p>You just gave an example of sidestepping the universal property</p>

<a name="158741519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158741519" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158741519">Kevin Buzzard (Feb 17 2019 at 12:17)</a>:</h4>
<p>But my impression is that there are other issues at stake.</p>

<a name="158741521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158741521" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158741521">Kevin Buzzard (Feb 17 2019 at 12:17)</a>:</h4>
<p>i did. but remember that to <em>us</em>, we don't care which proof we use.</p>

<a name="158741563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158741563" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158741563">Kevin Buzzard (Feb 17 2019 at 12:18)</a>:</h4>
<p>Kenny's elaborate direct limit proof works fine.</p>

<a name="158741566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158741566" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158741566">Mario Carneiro (Feb 17 2019 at 12:18)</a>:</h4>
<p>right. But I'm saying take all the stuff you want to do on aggregate and look at what works best</p>

<a name="158741567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158741567" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158741567">Kevin Buzzard (Feb 17 2019 at 12:18)</a>:</h4>
<p>And the definition of "best" is...?</p>

<a name="158741574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158741574" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158741574">Mario Carneiro (Feb 17 2019 at 12:19)</a>:</h4>
<p>easiest to prove is one concrete answer to that</p>

<a name="158741636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158741636" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158741636">Mario Carneiro (Feb 17 2019 at 12:20)</a>:</h4>
<p>Here's one example from CS: The <code>option</code> monad is defined by two functions, <code>pure</code> (which is <code>option.some</code>) and <code>bind</code>. You can define <code>map</code> in terms of these two. But you might not want to</p>

<a name="158741645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158741645" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158741645">Mario Carneiro (Feb 17 2019 at 12:21)</a>:</h4>
<p>perhaps because <code>map</code> is easier to define than <code>bind</code>, or it has a more direct definition</p>

<a name="158741647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158741647" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158741647">Kevin Buzzard (Feb 17 2019 at 12:21)</a>:</h4>
<p>This is for rflability issues?</p>

<a name="158741651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158741651" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158741651">Mario Carneiro (Feb 17 2019 at 12:21)</a>:</h4>
<p>that too. You will probably get different defeqs this way</p>

<a name="158741693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158741693" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158741693">Mario Carneiro (Feb 17 2019 at 12:22)</a>:</h4>
<p>and that is <em>definitely</em> something that requires a case by case analysis: look at all the theorems in the world that use it directly and decide what the best defeq is</p>

<a name="158741700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158741700" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158741700">Mario Carneiro (Feb 17 2019 at 12:23)</a>:</h4>
<p>It even applies pretty directly in this case - there is a <code>map</code> function on <code>free_semigroup</code> that you can define directly or via the <code>lift</code></p>

<a name="158741701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158741701" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158741701">Kenny Lau (Feb 17 2019 at 12:23)</a>:</h4>
<p>PR'ed <code>map</code> as you said it :P</p>

<a name="158742262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158742262" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158742262">Kevin Buzzard (Feb 17 2019 at 12:41)</a>:</h4>
<blockquote>
<p>The criteria are <em>not</em> "it satisfies the right universal property" and they are <em>not</em> "by the universal property there's a map from the localisation to this ring, and the criterion is that it's a bijection" (although of course they are provably equivalent to these predicates). Neil's predicate is more intrinsic to the situation, and my feeling is that his code seems to unify some work which I did multiple times in the schemes project.</p>
</blockquote>
<p>It's more than that. The universal property for localisation of a ring <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.00773em;">R</span></span></span></span> at a submonoid <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span></span> is "for all rings <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">A</span></span></span></span> in all universes, and all ring maps <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>:</mo><mi>R</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">f:R\to A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mrel">:</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mrel">→</span><span class="mord mathit">A</span></span></span></span> sending <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span></span> to units, there's a unique map <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo>[</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>S</mi><mo>]</mo><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">R[1/S]\to A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mclose">]</span><span class="mrel">→</span><span class="mord mathit">A</span></span></span></span> extending <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span></span>. Neil's predicate does not quantify over universes. Is this important?</p>

<a name="158742358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158742358" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158742358">Mario Carneiro (Feb 17 2019 at 12:44)</a>:</h4>
<p>What's Neil's predicate again?</p>

<a name="158742634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158742634" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158742634">Kevin Buzzard (Feb 17 2019 at 12:54)</a>:</h4>
<p>It is a predicate on tuples <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>A</mi><mo separator="true">,</mo><mi>S</mi><mo separator="true">,</mo><mi>B</mi><mo separator="true">,</mo><mi>f</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(A,S,B,f)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">(</span><span class="mord mathit">A</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span>, where <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">A</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span> are (commutative) rings, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">f:A\to B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mrel">:</span><span class="mord mathit">A</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span> is a ring map, and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span></span> is a submonoid of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">A</span></span></span></span>.</p>

<a name="158742638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158742638" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158742638">Kevin Buzzard (Feb 17 2019 at 12:55)</a>:</h4>
<p>If the predicate is satisfied, then <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">f:A\to B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mrel">:</span><span class="mord mathit">A</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span> is isomorphic to the universal map <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>→</mo><mi>A</mi><mo>[</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>S</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">A\to A[1/S]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">A</span><span class="mrel">→</span><span class="mord mathit">A</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mclose">]</span></span></span></span>.</p>

<a name="158742693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158742693" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158742693">Kevin Buzzard (Feb 17 2019 at 12:56)</a>:</h4>
<p>The predicate is <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07847em;">X</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.22222em;">Y</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07153em;">Z</span></span></span></span>, where <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07847em;">X</span></span></span></span> is the statement that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>s</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(s)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">s</span><span class="mclose">)</span></span></span></span> is invertible in <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span> for all <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>∈</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">s\in S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="base"><span class="mord mathit">s</span><span class="mrel">∈</span><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.22222em;">Y</span></span></span></span> boils down to the statement that the induced map <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>[</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>S</mi><mo>]</mo><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A[1/S]\to B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">A</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mclose">]</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span> is injective and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07153em;">Z</span></span></span></span> boils down to the statement that it's surjective.</p>

<a name="158742703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158742703" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158742703">Kevin Buzzard (Feb 17 2019 at 12:57)</a>:</h4>
<p>So it offers an alternative criterion for checking that a ring is isomorphic to a localisation.</p>

<a name="158742704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158742704" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158742704">Kevin Buzzard (Feb 17 2019 at 12:57)</a>:</h4>
<p>Although I've not done it yet, I want to apply it in the following situation.</p>

<a name="158742758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158742758" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158742758">Kevin Buzzard (Feb 17 2019 at 12:59)</a>:</h4>
<p><a href="https://stacks.math.columbia.edu/tag/00EJ" target="_blank" title="https://stacks.math.columbia.edu/tag/00EJ">This lemma</a> in the Stacks Project says that a "sequence is exact", which is just maths code for saying that a certain map is injective and that the image of some map is the kernel of some other map.</p>

<a name="158742760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158742760" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158742760">Kevin Buzzard (Feb 17 2019 at 12:59)</a>:</h4>
<p>It is manifestly clear that replacing any object here with an isomorphic object will not change the truth of that statement.</p>

<a name="158742812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158742812" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158742812">Kevin Buzzard (Feb 17 2019 at 13:00)</a>:</h4>
<p>All the objects involved are localisations (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mi>f</mi></msub></mrow><annotation encoding="application/x-tex">R_f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"></span></span></span></span></span></span></span></span> just means <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo>[</mo><mn>1</mn><mi mathvariant="normal">/</mi><mo>⟨</mo><mi>f</mi><mo>⟩</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">R[1/\langle f\rangle]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mord mathrm">/</span><span class="mopen">⟨</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mclose">⟩</span><span class="mclose">]</span></span></span></span>)</p>

<a name="158742827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158742827" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158742827">Kevin Buzzard (Feb 17 2019 at 13:01)</a>:</h4>
<p>and what I want is an analogue of that statement but with the "concrete" localisations replaced with abstract rings which we happen to know are isomorphic to localisations</p>

<a name="158742830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158742830" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158742830">Kevin Buzzard (Feb 17 2019 at 13:01)</a>:</h4>
<p>because that's what I have in my application.</p>

<a name="158742874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158742874" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158742874">Kevin Buzzard (Feb 17 2019 at 13:02)</a>:</h4>
<p>Neil's way of thinking about this is I think the first step towards this.</p>

<a name="158742875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158742875" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158742875">Kevin Buzzard (Feb 17 2019 at 13:02)</a>:</h4>
<p>At least, until someone lets me rewrite isomorphisms.</p>

<a name="158742944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158742944" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158742944">Kevin Buzzard (Feb 17 2019 at 13:05)</a>:</h4>
<p>In Schemes 1, my original repo, this was a huge effort, consisting of a whole bunch of unreadable code which I knocked off the moment I saw a route through. In Schemes 2 I want <span class="user-mention" data-user-id="132858">@Ramon Fernandez Mir</span> to do it properly.</p>

<a name="158743057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158743057" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158743057">Kevin Buzzard (Feb 17 2019 at 13:09)</a>:</h4>
<p>I am envisaging a lemma with the same initial data  (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.00773em;">R</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span>) and hypothesis (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> generate the unit ideal) but whose statement is that if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">R_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">R_{ij}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">i</span><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"></span></span></span></span></span></span></span></span> are rings satisfying Neil's predicate (or the universal property, or anything we can check in our application) then the sequence is exact.</p>

<a name="158743061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158743061" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158743061">Kevin Buzzard (Feb 17 2019 at 13:09)</a>:</h4>
<p>This is all just some massive workaround still, because we can't rewrite isomorphisms.</p>

<a name="158744429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/158744429" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#158744429">Reid Barton (Feb 17 2019 at 13:53)</a>:</h4>
<p>By the way, for the thing about <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">M \otimes_R N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mbin"><span class="mbin">⊗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span></span>, you can do it like this. Let <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.13889em;">P</span></span></span></span> be the submodule of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">M \otimes_R N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mbin"><span class="mbin">⊗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span></span> generated by everything of the form <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>⊗</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m \otimes n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.58333em;"></span><span class="strut bottom" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="base"><span class="mord mathit">m</span><span class="mbin">⊗</span><span class="mord mathit">n</span></span></span></span> and consider the quotient map <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>N</mi><mo>→</mo><mo>(</mo><mi>M</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>N</mi><mo>)</mo><mi mathvariant="normal">/</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">M \otimes_R N \to (M \otimes_R N)/P</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mbin"><span class="mbin">⊗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mrel">→</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mbin"><span class="mbin">⊗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.13889em;">P</span></span></span></span>. This map sends all <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>⊗</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m \otimes n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.58333em;"></span><span class="strut bottom" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="base"><span class="mord mathit">m</span><span class="mbin">⊗</span><span class="mord mathit">n</span></span></span></span> to zero, so (by the uniqueness part of the universal property) it must be the zero map, and that means <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>=</mo><mi>M</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">P = M \otimes_R N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mbin"><span class="mbin">⊗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span></span>.</p>

<a name="159312484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/159312484" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#159312484">François G. Dorais (Feb 25 2019 at 04:44)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>  </p>
<blockquote>
<p>This is useful in commutative algebra to "reduce to the Noetherian case" </p>
</blockquote>
<p>This is called "compactness" in general and it applies to all first-order things (e.g. all algebraic stuff that a universal algebraist might want to look at). It's also what is often called "coherence" in category theoretic settings; this connection is perhaps best seen through <a href="https://ncatlab.org/nlab/show/Deligne+completeness+theorem" target="_blank" title="https://ncatlab.org/nlab/show/Deligne+completeness+theorem">Deligne's Completeness Theorem</a>.</p>

<a name="159317761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22correct%22%20free%20semigroup/near/159317761" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/57076correctfreesemigroup.html#159317761">Jesse Michael Han (Feb 25 2019 at 07:09)</a>:</h4>
<p>is there a precise statement about how "reduction to the Noetherian case" is an instance of applying Deligne's theorem? (do you have a topos in mind where e.g. sheaves of noetherian modules are the coherent abelian group objects, etc)</p>


{% endraw %}
