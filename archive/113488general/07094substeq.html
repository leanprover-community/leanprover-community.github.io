---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/07094substeq.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html">subst.eq</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="194269221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194269221" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194269221">Michael Beeson (Apr 16 2020 at 08:07)</a>:</h4>
<p>The following example generates errors in its last line.  I do not understand why.  Can someone please correct those lines for me?<br>
If we have a proof that  x ∈ single y   and  by definition single x = pair x x then we want to conclude x ∈  pair y y.  </p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">init</span>
<span class="kn">constant</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="kn">set_option</span> <span class="n">default_priority</span> <span class="mi">100</span>
<span class="n">reserve</span> <span class="kn">infix</span> <span class="bp">`</span> <span class="err">∈</span> <span class="bp">`</span> <span class="o">:</span> <span class="mi">49</span>
<span class="kn">constant</span> <span class="n">mem</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="kn">variables</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">:</span> <span class="n">M</span>
<span class="kn">infix</span> <span class="err">∈</span> <span class="o">:=</span> <span class="n">mem</span>
<span class="kn">constant</span> <span class="n">single</span><span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span>
<span class="kn">constant</span> <span class="n">pair</span><span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span>
<span class="kn">constant</span> <span class="n">single_definition</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">single</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">pair</span> <span class="n">x</span> <span class="n">x</span><span class="o">)</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">single_definition</span> <span class="n">y</span>  <span class="c">/-</span><span class="cm"> single y = pair y y -/</span>
<span class="kn">constant</span> <span class="n">h</span><span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">single</span> <span class="n">y</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">eq</span><span class="bp">.</span><span class="n">subst</span> <span class="o">(</span><span class="n">single_definition</span> <span class="n">y</span><span class="o">)</span> <span class="n">h</span>
<span class="bp">```</span> <span class="n">lean</span>
</pre></div>

<a name="194269280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194269280" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194269280">Yury G. Kudryashov (Apr 16 2020 at 08:08)</a>:</h4>
<p>Please use ```lean</p>

<a name="194269289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194269289" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194269289">Johan Commelin (Apr 16 2020 at 08:08)</a>:</h4>
<p>Pro tip:</p>
<div class="codehilite"><pre><span></span>```lean
code goes here
```
</pre></div>


<p>gives you syntax highlighting</p>

<a name="194269364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194269364" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194269364">Michael Beeson (Apr 16 2020 at 08:08)</a>:</h4>
<p>(deleted)</p>

<a name="194269425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194269425" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194269425">Michael Beeson (Apr 16 2020 at 08:09)</a>:</h4>
<p>(deleted)</p>

<a name="194269484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194269484" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194269484">Yury G. Kudryashov (Apr 16 2020 at 08:10)</a>:</h4>
<p>```lean</p>
<p>```</p>

<a name="194269522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194269522" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194269522">Yury G. Kudryashov (Apr 16 2020 at 08:10)</a>:</h4>
<p>three backquotes lean&lt;RET&gt;code&lt;RET&gt;three backquotes</p>

<a name="194269526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194269526" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194269526">Michael Beeson (Apr 16 2020 at 08:10)</a>:</h4>
<p>(deleted)</p>

<a name="194269540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194269540" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194269540">Yury G. Kudryashov (Apr 16 2020 at 08:10)</a>:</h4>
<p>Also you can edit old posts instead of creating new ones</p>

<a name="194269556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194269556" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194269556">Michael Beeson (Apr 16 2020 at 08:10)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">init</span>
<span class="kn">constant</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="kn">set_option</span> <span class="n">default_priority</span> <span class="mi">100</span>
<span class="n">reserve</span> <span class="kn">infix</span> <span class="bp">`</span> <span class="err">∈</span> <span class="bp">`</span> <span class="o">:</span> <span class="mi">49</span>
<span class="kn">constant</span> <span class="n">mem</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="kn">variables</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">:</span> <span class="n">M</span>
<span class="kn">infix</span> <span class="err">∈</span> <span class="o">:=</span> <span class="n">mem</span>
<span class="kn">constant</span> <span class="n">single</span><span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span>
<span class="kn">constant</span> <span class="n">pair</span><span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span>
<span class="kn">constant</span> <span class="n">single_definition</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">single</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">pair</span> <span class="n">x</span> <span class="n">x</span><span class="o">)</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">single_definition</span> <span class="n">y</span>  <span class="c">/-</span><span class="cm"> single y = pair y y -/</span>
<span class="kn">constant</span> <span class="n">h</span><span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">single</span> <span class="n">y</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">eq</span><span class="bp">.</span><span class="n">subst</span> <span class="o">(</span><span class="n">single_definition</span> <span class="n">y</span><span class="o">)</span> <span class="n">h</span>
</pre></div>

<a name="194269614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194269614" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194269614">Michael Beeson (Apr 16 2020 at 08:11)</a>:</h4>
<p>How do I edit (or in this case delete) old posts?</p>

<a name="194269715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194269715" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194269715">Patrick Massot (Apr 16 2020 at 08:12)</a>:</h4>
<p>There is a drop-down menu near the time stamp in the top-right corner</p>

<a name="194269738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194269738" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194269738">Patrick Massot (Apr 16 2020 at 08:12)</a>:</h4>
<p>Or the keybinding is e (if you are not editing a message of course)</p>

<a name="194269740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194269740" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194269740">Kevin Buzzard (Apr 16 2020 at 08:12)</a>:</h4>
<p>You don't need <code>import init</code>, it's imported automatically</p>

<a name="194269756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194269756" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194269756">Yury G. Kudryashov (Apr 16 2020 at 08:12)</a>:</h4>
<p>Try <code>example : x ∈ pair y y := single_definition y ▸ h x y</code> instead of <code>#check</code></p>

<a name="194269758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194269758" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194269758">Patrick Massot (Apr 16 2020 at 08:12)</a>:</h4>
<p>And your Lean code is <em>very</em> weird</p>

<a name="194269808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194269808" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194269808">Yury G. Kudryashov (Apr 16 2020 at 08:13)</a>:</h4>
<p>E.g. it says that any <code>x</code> belongs to <code>singleton y</code> for any <code>y</code></p>

<a name="194269855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194269855" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194269855">Johan Commelin (Apr 16 2020 at 08:13)</a>:</h4>
<p><span class="user-mention" data-user-id="284844">@Michael Beeson</span> Welcome! Can you tell us a little bit about the "background" for your question? What are you trying to achieve?</p>

<a name="194269874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194269874" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194269874">Johan Commelin (Apr 16 2020 at 08:14)</a>:</h4>
<p>Also, what tutorials/books have you followed?</p>

<a name="194269877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194269877" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194269877">Patrick Massot (Apr 16 2020 at 08:14)</a>:</h4>
<p>If you are coming from another proof assistant you should probably spend some time learning and asking basic questions.</p>

<a name="194269997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194269997" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194269997">Yury G. Kudryashov (Apr 16 2020 at 08:15)</a>:</h4>
<p>Probably you want</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">single</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">pair</span> <span class="n">y</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">single_definition</span> <span class="n">y</span> <span class="bp">▸</span> <span class="n">h</span>
</pre></div>


<p>instead of the last 2 lines.</p>

<a name="194270199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194270199" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194270199">Yury G. Kudryashov (Apr 16 2020 at 08:17)</a>:</h4>
<p>Note that <code>constant</code> defines a universal constant with no known properties (apart from those defined by <code>axiom</code>s)</p>

<a name="194270291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194270291" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194270291">Yury G. Kudryashov (Apr 16 2020 at 08:18)</a>:</h4>
<p>In particular, you will not be able to apply any lemmas you prove in your file, e.g., to <code>nat</code>.</p>

<a name="194270325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194270325" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194270325">Yury G. Kudryashov (Apr 16 2020 at 08:18)</a>:</h4>
<p>Or anything but <code>M</code>.</p>

<a name="194270408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194270408" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194270408">Yury G. Kudryashov (Apr 16 2020 at 08:19)</a>:</h4>
<p>If you want to have theorems/definitions that work for any <code>Type</code>, you should use <code>variable (M : Type*)</code> instead.</p>

<a name="194270438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194270438" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194270438">Michael Beeson (Apr 16 2020 at 08:19)</a>:</h4>
<p>I am reading Theorem Proving in Lean.   I'm trying with this example to understand eq.subst.   This is taken from a finite axiomatization of <br>
intuitionistic NF set theory that I'm formalizing in Lean as an introductory exercise.  I thought this WAS a basic question.</p>

<a name="194270530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194270530" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194270530">Michael Beeson (Apr 16 2020 at 08:20)</a>:</h4>
<p>Yes,  that's the intention, this is a first-order theory with model carried by M.</p>

<a name="194270554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194270554" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194270554">Kevin Buzzard (Apr 16 2020 at 08:20)</a>:</h4>
<p>It looks like a fine basic question to me. In Lean we essentially never use constants and axioms.</p>

<a name="194270637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194270637" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194270637">Michael Beeson (Apr 16 2020 at 08:21)</a>:</h4>
<p>I know,  but that's one way to do first-order logic in Lean.    There should be another way, using a class declaration, but the part of the manual I needed for that is apparently not written yet, so I went this route instead.  It is adequate.</p>

<a name="194270778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194270778" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194270778">Michael Beeson (Apr 16 2020 at 08:23)</a>:</h4>
<p>You never use constants and axioms in formalizing libraries of mathematics, of course,  but this is not what I'm doing here, I'm formalizing a first-order theory.</p>

<a name="194270784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194270784" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194270784">Yury G. Kudryashov (Apr 16 2020 at 08:23)</a>:</h4>
<p>You can use</p>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">Model</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="o">(</span><span class="n">single</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">pair</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">single_def</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">single</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">pair</span> <span class="n">x</span> <span class="n">x</span><span class="o">)</span>
</pre></div>

<a name="194270802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194270802" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194270802">Yury G. Kudryashov (Apr 16 2020 at 08:23)</a>:</h4>
<p>You can add more data and axioms</p>

<a name="194270829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194270829" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194270829">Michael Beeson (Apr 16 2020 at 08:23)</a>:</h4>
<p>I tried essentially that with  "class"  instead of structure.</p>

<a name="194270965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194270965" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194270965">Yury G. Kudryashov (Apr 16 2020 at 08:25)</a>:</h4>
<p>With <code>class</code> you'll need something like</p>
<div class="codehilite"><pre><span></span><span class="n">class</span> <span class="n">Model</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">single</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="bp">...</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">Model</span> <span class="n">M</span><span class="o">]</span>
</pre></div>

<a name="194271020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194271020" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194271020">Michael Beeson (Apr 16 2020 at 08:25)</a>:</h4>
<p>It complained that I'm not allowed "variables" inside a class.   <br>
That's when I switched to the other approach.</p>

<a name="194271069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194271069" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194271069">Yury G. Kudryashov (Apr 16 2020 at 08:26)</a>:</h4>
<p>Then you can <code>#check Model.single</code> and <code>#check Model.pair</code> to see what arguments explicit/implicit.</p>

<a name="194271136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194271136" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194271136">Yury G. Kudryashov (Apr 16 2020 at 08:26)</a>:</h4>
<p>You don't declare <code>variable</code>s inside a class. You list fields using the same syntax as for <code>structure</code> but move <code>M</code> to the argument.</p>

<a name="194271337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194271337" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194271337">Yury G. Kudryashov (Apr 16 2020 at 08:28)</a>:</h4>
<p>The error about <code>subst.eq</code> means the following. When you write <code>subst.eq h a</code>, Lean wants to know (a) the type of <code>h</code> (including all implicit args); (b) the type of your goal.</p>

<a name="194271404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194271404" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194271404">Yury G. Kudryashov (Apr 16 2020 at 08:29)</a>:</h4>
<p>So, it will never work with <code>#check</code> unless you use something like <code>show ..., from eq.subst h a</code></p>

<a name="194271556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194271556" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194271556">Michael Beeson (Apr 16 2020 at 08:30)</a>:</h4>
<p>OK.   Thank you, Yury,  for these helpful lessons.   I'll rework my code tomorrow .</p>

<a name="194350356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194350356" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194350356">Michael Beeson (Apr 16 2020 at 18:48)</a>:</h4>
<p>The following code generates an error if you uncomment the commented line.<br>
On the other hand if you uncomment the commented line and comment out the next line then <br>
it also generates an error.  So it looks like either of the last two lines is OK by itself but not together.<br>
What is going on here?   Also,   why does my section name have to be the same as my class name and both <br>
are ended together with one end command?  </p>
<div class="codehilite"><pre><span></span><span class="kn">set_option</span> <span class="n">default_priority</span> <span class="mi">100</span>
<span class="n">reserve</span> <span class="kn">infix</span> <span class="bp">`</span> <span class="err">∈</span> <span class="bp">`</span> <span class="o">:</span> <span class="mi">49</span>
<span class="kn">section</span> <span class="n">Model</span>
<span class="n">class</span>  <span class="n">Model</span> <span class="o">(</span><span class="n">M</span><span class="o">:</span><span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">mem</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="c">/-</span><span class="cm">infix ∈ := Model.binary_union-/</span>
<span class="o">(</span><span class="n">extensionality_axiom</span><span class="o">:</span>  <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">mem</span> <span class="n">x</span> <span class="n">a</span> <span class="bp">↔</span> <span class="n">mem</span> <span class="n">x</span> <span class="n">b</span><span class="o">)</span> <span class="bp">→</span> <span class="n">a</span><span class="bp">=</span><span class="n">b</span><span class="o">))</span>
<span class="kn">end</span> <span class="n">Model</span>
</pre></div>

<a name="194350791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194350791" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194350791">Alex J. Best (Apr 16 2020 at 18:52)</a>:</h4>
<p>The class consists of several fields, mem and extensionality_axiom in this case, the next line which isnt of the form <code>(name : Type)</code> is ending the definition of the class here, so when you uncomment the infix line lean thinks you are done with that class.<br>
The <code>end Model</code> only applies to the section, and doesn't need to have the same name as the class.</p>
<div class="codehilite"><pre><span></span><span class="kn">set_option</span> <span class="n">default_priority</span> <span class="mi">100</span>
<span class="n">reserve</span> <span class="kn">infix</span> <span class="bp">`</span> <span class="err">∈</span> <span class="bp">`</span> <span class="o">:</span> <span class="mi">49</span>
<span class="kn">section</span> <span class="n">Moodel</span>
<span class="n">class</span>  <span class="n">Model</span> <span class="o">(</span><span class="n">M</span><span class="o">:</span><span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">mem</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">extensionality_axiom</span><span class="o">:</span>  <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">mem</span> <span class="n">x</span> <span class="n">a</span> <span class="bp">↔</span> <span class="n">mem</span> <span class="n">x</span> <span class="n">b</span><span class="o">)</span> <span class="bp">→</span> <span class="n">a</span><span class="bp">=</span><span class="n">b</span><span class="o">))</span>

<span class="kn">infix</span> <span class="err">∈</span> <span class="o">:=</span> <span class="n">Model</span><span class="bp">.</span><span class="n">binary_union</span>
<span class="kn">end</span> <span class="n">Moodel</span>
</pre></div>

<a name="194350927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194350927" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194350927">Alex J. Best (Apr 16 2020 at 18:53)</a>:</h4>
<p>The infix doesn't work as lean doesn't know what <code>Model.binary_union</code> is btw.</p>

<a name="194351064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194351064" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194351064">Michael Beeson (Apr 16 2020 at 18:54)</a>:</h4>
<p>Thanks,   I understand the answer.  Now,  where can I put the infix declaration so it will work?   Not before the class, since it won't know what Model.mem is there.  Not after the class,  at least, if I want to use the infix notation inside the class.    And, not inside the class,<br>
since that will terminate the class definition.   um,  where then?</p>

<a name="194351618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194351618" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194351618">Alex J. Best (Apr 16 2020 at 18:58)</a>:</h4>
<p>You can do it like this</p>
<div class="codehilite"><pre><span></span><span class="n">class</span>  <span class="n">Model</span> <span class="o">(</span><span class="n">M</span><span class="o">:</span><span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">mem</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="kn">infix</span> <span class="bp">`</span> <span class="err">∈</span> <span class="bp">`</span><span class="o">:</span><span class="mi">1001</span> <span class="o">:=</span> <span class="n">mem</span><span class="o">)</span>
<span class="o">(</span><span class="n">extensionality_axiom</span><span class="o">:</span>  <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">a</span> <span class="bp">↔</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">b</span><span class="o">)</span> <span class="bp">→</span> <span class="n">a</span><span class="bp">=</span><span class="n">b</span><span class="o">))</span>
</pre></div>

<a name="194352083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194352083" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194352083">Kenny Lau (Apr 16 2020 at 19:01)</a>:</h4>
<p>it still isn't bracketed right btw</p>

<a name="194352244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194352244" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194352244">Alex J. Best (Apr 16 2020 at 19:02)</a>:</h4>
<p>The extensionality yeah?</p>

<a name="194352265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194352265" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194352265">Kenny Lau (Apr 16 2020 at 19:02)</a>:</h4>
<p>yeah</p>

<a name="194352770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194352770" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194352770">Alex J. Best (Apr 16 2020 at 19:06)</a>:</h4>
<p>Also I believe you have to redeclare the notation if you want to use it outside of the class as in</p>
<div class="codehilite"><pre><span></span><span class="kn">section</span> <span class="n">Model</span>

<span class="n">class</span>  <span class="n">Model</span> <span class="o">(</span><span class="n">M</span><span class="o">:</span><span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">mem</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="kn">infix</span> <span class="bp">`</span> <span class="err">∈</span> <span class="bp">`</span><span class="o">:</span><span class="mi">1001</span> <span class="o">:=</span> <span class="n">mem</span><span class="o">)</span>
<span class="o">(</span><span class="n">extensionality_axiom</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="n">a</span> <span class="bp">↔</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">b</span><span class="o">)</span> <span class="bp">→</span> <span class="n">a</span><span class="bp">=</span><span class="n">b</span><span class="o">))</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">Model</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">Model</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">extensionality_axiom</span>
<span class="kn">infix</span> <span class="bp">`</span> <span class="err">∈</span> <span class="bp">`</span> <span class="o">:=</span> <span class="n">Model</span><span class="bp">.</span><span class="n">mem</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">b</span>

<span class="kn">end</span> <span class="n">Model</span>
</pre></div>

<a name="194352818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194352818" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194352818">Michael Beeson (Apr 16 2020 at 19:07)</a>:</h4>
<p>oh,  oops about the bracketing.     But having binary_union in place of mem is just a cut-and-paste error<br>
as the actual file has mem there.</p>

<a name="194359049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194359049" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194359049">Michael Beeson (Apr 16 2020 at 19:58)</a>:</h4>
<p>I don't seem to have to redeclare the infix notation,  probably because at the top of my file I have</p>
<div class="codehilite"><pre><span></span><span class="kn">set_option</span> <span class="n">default_priority</span> <span class="mi">100</span>
<span class="n">reserve</span> <span class="kn">infix</span> <span class="bp">`</span> <span class="err">∈</span> <span class="bp">`</span> <span class="o">:</span> <span class="mi">49</span>
<span class="n">reserve</span> <span class="kn">infix</span> <span class="bp">`</span> <span class="err">⊆</span> <span class="bp">`</span> <span class="o">:</span> <span class="mi">49</span>
<span class="n">reserve</span> <span class="kn">infix</span> <span class="bp">`</span> <span class="err">∪</span> <span class="bp">`</span> <span class="o">:</span> <span class="mi">50</span>
<span class="n">reserve</span> <span class="kn">infix</span> <span class="bp">`</span> <span class="err">∩</span> <span class="bp">`</span> <span class="o">:</span> <span class="mi">50</span>
<span class="n">reserve</span> <span class="kn">infix</span> <span class="bp">`</span> <span class="bp">×</span> <span class="bp">`</span> <span class="o">:</span> <span class="mi">50</span>
</pre></div>

<a name="194359304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194359304" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194359304">Michael Beeson (Apr 16 2020 at 20:00)</a>:</h4>
<p>But I do definitely need the second "open Model".   Now I have two "open Model"  and only one "end Model".    I don't understand <br>
why I need the second "open Model".</p>

<a name="194359707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194359707" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194359707">Michael Beeson (Apr 16 2020 at 20:03)</a>:</h4>
<p>Also if I try to include the line</p>
<p>(@[simp]  single_definition: ∀ x, (single x = pair x x) )</p>
<p>it causes an error, while  without "@[simp]"   all is fine.</p>

<a name="194359843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194359843" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194359843">Alex J. Best (Apr 16 2020 at 20:04)</a>:</h4>
<p>Where is your second open Model? If you have a section called model and then a class inside it called <code>Model</code> then in order to refer to fields of the class <code>Model</code> by their name, instead of <code>Model.name</code> you can run <code>open Model</code>. I don't see the need for two (unless you are in a different section).</p>

<a name="194359963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194359963" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194359963">Alex J. Best (Apr 16 2020 at 20:05)</a>:</h4>
<p><code>section name</code> pairs with <code>end name</code>, and open is something different, I'd rename your section to something else (even just models to make the names not overlap personally.</p>

<a name="194359980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194359980" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194359980">Michael Beeson (Apr 16 2020 at 20:05)</a>:</h4>
<p>Here is   an initial segment of my file showing the two open Model commands.<br>
Well actually the first one is not an "open" command but a section command.  </p>
<div class="codehilite"><pre><span></span><span class="kn">set_option</span> <span class="n">default_priority</span> <span class="mi">100</span>
<span class="n">reserve</span> <span class="kn">infix</span> <span class="bp">`</span> <span class="err">∈</span> <span class="bp">`</span> <span class="o">:</span> <span class="mi">49</span>
<span class="n">reserve</span> <span class="kn">infix</span> <span class="bp">`</span> <span class="err">⊆</span> <span class="bp">`</span> <span class="o">:</span> <span class="mi">49</span>
<span class="n">reserve</span> <span class="kn">infix</span> <span class="bp">`</span> <span class="err">∪</span> <span class="bp">`</span> <span class="o">:</span> <span class="mi">50</span>
<span class="n">reserve</span> <span class="kn">infix</span> <span class="bp">`</span> <span class="err">∩</span> <span class="bp">`</span> <span class="o">:</span> <span class="mi">50</span>
<span class="n">reserve</span> <span class="kn">infix</span> <span class="bp">`</span> <span class="bp">×</span> <span class="bp">`</span> <span class="o">:</span> <span class="mi">50</span>

<span class="kn">section</span> <span class="n">Model</span>
<span class="n">class</span>  <span class="n">Model</span> <span class="o">(</span><span class="n">M</span><span class="o">:</span><span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">mem</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">subset</span><span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">phi</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">c</span><span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">V</span><span class="o">:</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">binary_union</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">union</span><span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">intersection</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">imp</span><span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">pair</span><span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">single</span><span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">ordered_pair</span><span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">product</span><span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">Rel</span><span class="o">:</span> <span class="n">M</span> <span class="bp">→</span>  <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">dom</span><span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">inv</span><span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="o">)</span>
<span class="o">(</span><span class="n">join</span><span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">SI</span><span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="o">)</span>  <span class="c">/-</span><span class="cm"> singleton_image -/</span>
<span class="o">(</span><span class="n">subset_relation</span><span class="o">:</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">equality_relation</span><span class="o">:</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">proj1</span><span class="o">:</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">proj2</span><span class="o">:</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span> <span class="n">single_definition</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">single</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">pair</span> <span class="n">x</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="kn">infix</span>  <span class="err">∈</span> <span class="o">:=</span>  <span class="n">mem</span> <span class="o">)</span>
<span class="o">(</span><span class="kn">infix</span> <span class="err">∪</span> <span class="o">:=</span> <span class="n">binary_union</span><span class="o">)</span>
<span class="o">(</span><span class="kn">infix</span> <span class="err">∩</span> <span class="o">:=</span> <span class="n">intersection</span><span class="o">)</span>
<span class="o">(</span><span class="kn">infix</span> <span class="bp">×</span> <span class="o">:=</span> <span class="n">product</span><span class="o">)</span>
<span class="o">(</span><span class="kn">infix</span> <span class="err">⊆</span> <span class="o">:=</span> <span class="n">subset</span><span class="o">)</span>
<span class="o">(</span><span class="n">extensionality_axiom</span><span class="o">:</span>  <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="n">a</span> <span class="bp">↔</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">b</span><span class="o">))</span> <span class="bp">→</span> <span class="n">a</span><span class="bp">=</span><span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">binary_union_axiom</span><span class="o">:</span>   <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="n">a</span> <span class="err">∪</span> <span class="n">b</span> <span class="bp">↔</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">a</span> <span class="bp">∨</span>  <span class="n">x</span> <span class="err">∈</span> <span class="n">b</span><span class="o">))</span>
<span class="o">(</span><span class="n">intersection_axiom</span><span class="o">:</span>  <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="n">a</span> <span class="err">∩</span>  <span class="n">b</span> <span class="bp">↔</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">a</span> <span class="bp">∧</span>  <span class="n">x</span> <span class="err">∈</span> <span class="n">b</span><span class="o">))</span>
<span class="o">(</span><span class="n">complement_axiom</span><span class="o">:</span>  <span class="bp">∀</span> <span class="n">a</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="n">c</span> <span class="n">a</span> <span class="bp">↔</span> <span class="bp">¬</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">a</span><span class="o">))</span>
<span class="o">(</span><span class="n">implication_axiom</span><span class="o">:</span>    <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="n">imp</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">b</span><span class="o">)))</span>
<span class="o">(</span><span class="n">emptyset_axiom</span><span class="o">:</span>   <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="bp">¬</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">phi</span><span class="o">))</span>
<span class="o">(</span><span class="n">pairing_axiom</span><span class="o">:</span>  <span class="bp">∀</span> <span class="n">x</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="n">pair</span> <span class="n">a</span> <span class="n">b</span>  <span class="bp">↔</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">∨</span>  <span class="n">x</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)))</span>
<span class="o">(</span><span class="n">ordered_pairing_axiom</span><span class="o">:</span>   <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="o">(</span><span class="n">ordered_pair</span> <span class="n">x</span> <span class="n">y</span>  <span class="bp">=</span> <span class="n">pair</span> <span class="n">x</span> <span class="o">(</span><span class="n">pair</span> <span class="n">x</span> <span class="n">y</span><span class="o">)))</span>
<span class="o">(</span><span class="n">domain</span><span class="o">:</span>  <span class="bp">∀</span> <span class="n">R</span><span class="o">,</span> <span class="o">(</span><span class="n">Rel</span> <span class="n">R</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="n">dom</span> <span class="n">R</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">y</span><span class="o">,</span> <span class="o">(</span><span class="n">ordered_pair</span> <span class="n">x</span> <span class="n">y</span>  <span class="err">∈</span> <span class="n">R</span><span class="o">))))</span>
<span class="o">(</span><span class="n">V_definition</span><span class="o">:</span>   <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">V</span><span class="o">))</span>
<span class="o">(</span><span class="n">Rel_definition</span><span class="o">:</span>  <span class="bp">∀</span> <span class="n">X</span><span class="o">,</span> <span class="o">(</span> <span class="n">Rel</span> <span class="n">X</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="o">(</span><span class="n">z</span> <span class="err">∈</span> <span class="n">X</span> <span class="bp">→</span>  <span class="bp">∃</span> <span class="n">a</span> <span class="n">b</span><span class="o">,(</span><span class="n">z</span> <span class="bp">=</span> <span class="n">ordered_pair</span> <span class="n">a</span> <span class="n">b</span><span class="o">))))</span>
<span class="o">(</span><span class="n">product_axiom</span><span class="o">:</span>   <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">u</span><span class="o">,</span> <span class="o">(</span><span class="n">u</span> <span class="err">∈</span> <span class="n">x</span> <span class="bp">×</span> <span class="n">y</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span> <span class="err">∈</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">b</span> <span class="err">∈</span> <span class="n">y</span> <span class="bp">∧</span> <span class="n">u</span> <span class="bp">=</span> <span class="n">ordered_pair</span> <span class="n">a</span> <span class="n">b</span> <span class="o">)))</span>
<span class="o">(</span><span class="n">inverse_axiom</span><span class="o">:</span>   <span class="bp">∀</span> <span class="n">R</span><span class="o">,</span> <span class="o">(</span><span class="n">Rel</span> <span class="n">R</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="o">(</span><span class="n">ordered_pair</span> <span class="n">x</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">inv</span> <span class="n">R</span> <span class="bp">↔</span> <span class="n">ordered_pair</span> <span class="n">y</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">R</span><span class="o">)))</span>
<span class="o">(</span><span class="n">equality_relation_axiom</span><span class="o">:</span>  <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">equality_relation</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">z</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="n">ordered_pair</span> <span class="n">z</span> <span class="n">z</span> <span class="o">)))</span>
<span class="o">(</span><span class="n">subset_definition</span><span class="o">:</span>   <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="err">⊆</span> <span class="n">y</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="o">(</span><span class="n">z</span> <span class="err">∈</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">y</span><span class="o">)))</span>
<span class="o">(</span><span class="n">subset_relation_axiom</span><span class="o">:</span>  <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="o">(</span><span class="n">ordered_pair</span> <span class="n">x</span> <span class="n">y</span>  <span class="err">∈</span> <span class="n">subset_relation</span> <span class="bp">↔</span> <span class="n">x</span> <span class="err">⊆</span> <span class="n">y</span><span class="o">))</span>
 <span class="o">(</span><span class="n">union_axiom</span><span class="o">:</span>   <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="n">union</span> <span class="n">y</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">z</span><span class="o">,</span> <span class="o">(</span><span class="n">z</span> <span class="err">∈</span> <span class="n">y</span> <span class="bp">∧</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">z</span><span class="o">)))</span>

 <span class="c">/-</span><span class="cm"> end of class definition because next line doesn&#39;t declare a member -/</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">M</span><span class="o">:</span><span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">Model</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="n">X</span> <span class="n">R</span> <span class="n">W</span><span class="o">:</span> <span class="n">M</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">Model</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">extensionality_axiom</span>



<span class="kn">end</span> <span class="n">Model</span>
</pre></div>

<a name="194360169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194360169" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194360169">Alex J. Best (Apr 16 2020 at 20:06)</a>:</h4>
<p>I only see one <code>open Model</code>!</p>

<a name="194360251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194360251" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194360251">Michael Beeson (Apr 16 2020 at 20:07)</a>:</h4>
<p>Yes,  but doesn't the section Model   command have the effect of opening the section?</p>

<a name="194360357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194360357" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194360357">Alex J. Best (Apr 16 2020 at 20:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="284844">Michael Beeson</span> <a href="#narrow/stream/113488-general/topic/subst.2Eeq/near/194359707" title="#narrow/stream/113488-general/topic/subst.2Eeq/near/194359707">said</a>:</p>
<blockquote>
<p>Also if I try to include the line</p>
<p>(@[simp]  single_definition: ∀ x, (single x = pair x x) )</p>
<p>it causes an error, while  without "@[simp]"   all is fine.</p>
</blockquote>
<p>you won't  need to tag these definitions with <code>simp</code>, the tag <code>@[simp]</code> can be used on lemmas or theorems to make the simplifier try to apply them in later proofs.</p>

<a name="194360414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194360414" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194360414">Alex J. Best (Apr 16 2020 at 20:08)</a>:</h4>
<p>Yes, the <code>open Model</code> command refers to the <code>class Model</code> here</p>

<a name="194360516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194360516" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194360516">Michael Beeson (Apr 16 2020 at 20:09)</a>:</h4>
<p>So  maybe it's crazy to name the section and the class both Model.</p>

<a name="194360541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194360541" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194360541">Alex J. Best (Apr 16 2020 at 20:09)</a>:</h4>
<p>Without it you can't refer to <code>extensionality_axiom</code> without prefixing it <code>Model.extensionality_axiom</code>, its a convenience thing only.</p>

<a name="194361004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194361004" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194361004">Michael Beeson (Apr 16 2020 at 20:13)</a>:</h4>
<p>So you can "open"  either a section or a class,  and you can "end"  a section.    I can't, however, either "close" or "end" a class afer opening it.</p>

<a name="194361075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194361075" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194361075">Michael Beeson (Apr 16 2020 at 20:14)</a>:</h4>
<p>Oh wait, maybe you can't "open" a section; only a class.</p>

<a name="194361426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194361426" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194361426">Kevin Buzzard (Apr 16 2020 at 20:17)</a>:</h4>
<p>You are not using any of the functionality of sections, and if you don't really know what they are then it might be best to remove <code>section Model</code> and <code>end Model</code> completely. I don't know what you think they're doing, but they are just some organisational principle for managing variables in a principled manner, and in particular <code>section Model/end Model</code> may as well say <code>section xyzzy/end xyzzy</code>; they do not affect your Model class in any way.</p>

<a name="194361519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194361519" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194361519">Kevin Buzzard (Apr 16 2020 at 20:18)</a>:</h4>
<p><a href="https://leanprover.github.io/theorem_proving_in_lean/interacting_with_lean.html#more-on-sections" title="https://leanprover.github.io/theorem_proving_in_lean/interacting_with_lean.html#more-on-sections">sections</a></p>

<a name="194361581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194361581" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194361581">Michael Beeson (Apr 16 2020 at 20:18)</a>:</h4>
<p>What I thought they were doing was limiting the scope of my variables to the section.</p>

<a name="194361646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194361646" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194361646">Kevin Buzzard (Apr 16 2020 at 20:18)</a>:</h4>
<p>Right.</p>

<a name="194361771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194361771" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194361771">Michael Beeson (Apr 16 2020 at 20:19)</a>:</h4>
<p>But regardless of sections,  there must be a way to undo the effect of "opening" a class.</p>

<a name="194361774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194361774" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194361774">Kevin Buzzard (Apr 16 2020 at 20:19)</a>:</h4>
<p>But given that you don't have anything going on outside the section, or any reason to limit the scope of the variables to any subset of your code right now, why not just remove it for now?</p>

<a name="194361943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194361943" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194361943">Kevin Buzzard (Apr 16 2020 at 20:20)</a>:</h4>
<p>I don't know what you think "opening" a class means, but <code>open foo</code> simply means that you no longer have to type <code>foo.bar</code>, you can just type <code>bar</code> instead.</p>

<a name="194361947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194361947" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194361947">Michael Beeson (Apr 16 2020 at 20:20)</a>:</h4>
<p>I put a section command in just in accordance with the general principle that global variables are bad, bad, bad.</p>

<a name="194362007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194362007" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194362007">Kevin Buzzard (Apr 16 2020 at 20:21)</a>:</h4>
<p>I don't think that these are the kind of variables for which that principle holds.</p>

<a name="194362150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194362150" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194362150">Michael Beeson (Apr 16 2020 at 20:22)</a>:</h4>
<p>Well it doesn't matter anyway as this is never going to be more than a one-file project.</p>

<a name="194362174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194362174" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194362174">Kevin Buzzard (Apr 16 2020 at 20:22)</a>:</h4>
<p>You are not really globally defining X to mean anything when you write <code>variable (X : foo)</code>, you're just telling Lean that if it sees an <code>X</code> in the middle of a definition and you didn't bother saying what it was, then it's a <code>foo</code>.</p>

<a name="194362300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194362300" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194362300">Michael Beeson (Apr 16 2020 at 20:23)</a>:</h4>
<p>Well,  if six months from now in another file I forget to declare X   and I have inputted this file then Lean will infer the wrong type for X and I might waste an hour figuring out what's going on.</p>

<a name="194362344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194362344" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194362344">Kevin Buzzard (Apr 16 2020 at 20:23)</a>:</h4>
<p>That is not true. That's what I'm saying.</p>

<a name="194362415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194362415" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194362415">Marc Huisinga (Apr 16 2020 at 20:24)</a>:</h4>
<p>from the code i've seen, sections are mostly used for managing <code>variable</code> commands, and namespaces are mostly used for avoiding global variables (<a href="https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html#namespaces" title="https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html#namespaces">https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html#namespaces</a>)</p>

<a name="194362448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194362448" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194362448">Kevin Buzzard (Apr 16 2020 at 20:24)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">variable</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">X</span> <span class="bp">+</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">two_mul</span> <span class="n">X</span> <span class="c1">-- here X is an integer</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">-- here it&#39;s a bool, but only because we didn&#39;t say what it was</span>
</pre></div>

<a name="194362579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194362579" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194362579">Kevin Buzzard (Apr 16 2020 at 20:25)</a>:</h4>
<p>If you import this file in another file then <code>variable (X : bool)</code> will no longer apply, and if you use <code>X</code> without saying what it is you'll get an error. <code>variable</code> is just a local trick in a file to save you having to always say that X is a bool in the theorems you're proving <em>in this file</em></p>

<a name="194362748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194362748" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194362748">Kevin Buzzard (Apr 16 2020 at 20:26)</a>:</h4>
<p>It's more a device to save typing than anything else.</p>

<a name="194362921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194362921" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194362921">Michael Beeson (Apr 16 2020 at 20:28)</a>:</h4>
<p>Aha!   So  to speak,  all "variable declarations"  are static,   in the sense that their scope is limited to a file. </p>
<p>That has the possibly nasty effect that   "input foo"  is not the same thing as pasting the contents of foo where you <br>
have the input command.</p>

<a name="194362969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194362969" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194362969">Kevin Buzzard (Apr 16 2020 at 20:28)</a>:</h4>
<p>Lean has a set-up for handling notation, and it's not what you are using.</p>

<a name="194363030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194363030" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194363030">Kevin Buzzard (Apr 16 2020 at 20:29)</a>:</h4>
<p>There is no input command, there is only an import command, and it can only take place at the very top of the file, so this is not an issue.</p>

<a name="194363339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194363339" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194363339">Michael Beeson (Apr 16 2020 at 20:30)</a>:</h4>
<p>I mean "import".     </p>
<p>Now if  file1  has a variable declaration of X and file2  has "import file1"  then the declaration of X <br>
will not have effect in file 2.  But if I replace the import command with the contents of file 1  then <br>
the declaration of X will  have effect in  file 2.</p>

<a name="194363430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194363430" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194363430">Michael Beeson (Apr 16 2020 at 20:31)</a>:</h4>
<p>Regarding "Lean has a way and I'm not using it",   I'm here on Zulip to learn Lean, so please point me in the right direction.</p>

<a name="194363476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194363476" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194363476">Kevin Buzzard (Apr 16 2020 at 20:31)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">class</span> <span class="n">Model</span> <span class="o">(</span><span class="n">M</span><span class="o">:</span><span class="kt">Type</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">has_mem</span> <span class="n">M</span> <span class="n">M</span><span class="o">,</span> <span class="n">has_subset</span> <span class="n">M</span><span class="o">,</span> <span class="n">has_union</span> <span class="n">M</span><span class="o">,</span> <span class="n">has_inter</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">phi</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">c</span><span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">V</span><span class="o">:</span> <span class="n">M</span><span class="o">)</span>
<span class="bp">...</span>
</pre></div>

<a name="194363699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194363699" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194363699">Kevin Buzzard (Apr 16 2020 at 20:33)</a>:</h4>
<p><code>binary_union</code> is called <code>union</code>, and <code>union</code> is called <code>Union</code></p>

<a name="194363848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194363848" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194363848">Michael Beeson (Apr 16 2020 at 20:34)</a>:</h4>
<p>Well,  but I'm trying to write a self-contained first-order theory.  I don't want to import any axioms from elsewhere about the primitive symbols.</p>

<a name="194363879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194363879" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194363879">Kevin Buzzard (Apr 16 2020 at 20:34)</a>:</h4>
<p>There are no axioms. The things you're extending are just notation.</p>

<a name="194364055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194364055" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194364055">Michael Beeson (Apr 16 2020 at 20:36)</a>:</h4>
<p>So your point is that by using extends has_mem,   I could avoid the need to declare (infix  ∈ :=  mem )     ?</p>

<a name="194364076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194364076" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194364076">Kevin Buzzard (Apr 16 2020 at 20:36)</a>:</h4>
<p>Right -- <code>has_mem</code> has done all that for you.</p>

<a name="194364124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194364124" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194364124">Michael Beeson (Apr 16 2020 at 20:37)</a>:</h4>
<p>But "(infix  ∈ :=  mem )"  is not longer than  "extends has_mem"</p>

<a name="194364171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194364171" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194364171">Michael Beeson (Apr 16 2020 at 20:37)</a>:</h4>
<p>But anyway,  I understand now that I could do it that way, thanks.</p>

<a name="194364184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194364184" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194364184">Kevin Buzzard (Apr 16 2020 at 20:37)</a>:</h4>
<p>The advantage of doing it the way I'm suggesting is that you can use the notation immediately, even in the axioms for your class.</p>

<a name="194364271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194364271" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194364271">Michael Beeson (Apr 16 2020 at 20:38)</a>:</h4>
<p>But I did use it in the axioms,  by putting the axioms after the (infix  ∈ :=  mem ) lines  (once someone showed me how to do that inside the class.</p>

<a name="194364323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194364323" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194364323">Kevin Buzzard (Apr 16 2020 at 20:39)</a>:</h4>
<p>I have no idea whether that will work in practice. I have never seen anyone declare infix notation within a class before.</p>

<a name="194364407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194364407" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194364407">Michael Beeson (Apr 16 2020 at 20:39)</a>:</h4>
<p>Well,  it seems to work.   Thanks to the wizards here on Zulip.  <br>
Anyway now I have TWO ways to do it so I am double happy.</p>

<a name="194364539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194364539" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194364539">Michael Beeson (Apr 16 2020 at 20:40)</a>:</h4>
<p>There are however other things that I do not know even ONE way to do.   For example  use  notation {a, b}  for pair a b. <br>
This has something to do with "foldr"    and I stared at the example in  TPIL  quite a while but could not make it work.<br>
So can we do that too with "extends" ?</p>

<a name="194364578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194364578" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194364578">Kevin Buzzard (Apr 16 2020 at 20:41)</a>:</h4>
<p>That notation is already taken in Lean, so it will be touch and go if you try to redefine it.</p>

<a name="194364617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194364617" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194364617">Kevin Buzzard (Apr 16 2020 at 20:41)</a>:</h4>
<p>Actually, it already means more than one thing, so maybe it will be fine ;-)</p>

<a name="194364738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194364738" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194364738">Marc Huisinga (Apr 16 2020 at 20:42)</a>:</h4>
<p>the foldr example is the one for lists, right?</p>

<a name="194364768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194364768" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194364768">Michael Beeson (Apr 16 2020 at 20:43)</a>:</h4>
<p>Yes, that's the example I was staring at.</p>

<a name="194364804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194364804" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194364804">Alex J. Best (Apr 16 2020 at 20:43)</a>:</h4>
<p>I think the extends way will require less typing in the long run, you won't have to redeclare the notation to use it later. When I tried it I had to help lean with the types a bit more though: e.g.</p>
<div class="codehilite"><pre><span></span><span class="kn">section</span> <span class="n">Model</span>

<span class="n">class</span> <span class="n">Model</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">has_mem</span> <span class="n">M</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">extensionality_axiom</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">M</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="n">a</span> <span class="bp">↔</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">b</span><span class="o">))</span> <span class="bp">→</span> <span class="n">a</span><span class="bp">=</span><span class="n">b</span><span class="o">)</span> <span class="c1">-- I had to add : M after a b here</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">Model</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">Model</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">extensionality_axiom</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">b</span>

<span class="kn">end</span> <span class="n">Model</span>
</pre></div>

<a name="194364932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194364932" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194364932">Marc Huisinga (Apr 16 2020 at 20:44)</a>:</h4>
<p>in that case the notation is a bit more involved because lists can have arbitrary length. for pairs you can get away with less involved notation commands.</p>

<a name="194365276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194365276" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194365276">Marc Huisinga (Apr 16 2020 at 20:47)</a>:</h4>
<p>it has been a while since i have fiddled with notation, and getting the priorities right is always a bit tricky ...</p>

<a name="194366101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194366101" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194366101">Michael Beeson (Apr 16 2020 at 20:54)</a>:</h4>
<p>Anyway this is not a serious problem for me.   I'm fine with typing "pair a b"  instead of {a, b}  for the duration of this exercise.</p>

<a name="194366141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194366141" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194366141">Marc Huisinga (Apr 16 2020 at 20:54)</a>:</h4>
<p>taking your example from above, this works (for pair):</p>
<div class="codehilite"><pre><span></span><span class="kn">section</span> <span class="n">Model</span>
<span class="n">class</span>  <span class="n">Model</span> <span class="o">(</span><span class="n">M</span><span class="o">:</span><span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">mem</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">subset</span><span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">phi</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">c</span><span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">V</span><span class="o">:</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">binary_union</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">union</span><span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">intersection</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">imp</span><span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">pair</span><span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">single</span><span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">ordered_pair</span><span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">product</span><span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">Rel</span><span class="o">:</span> <span class="n">M</span> <span class="bp">→</span>  <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">dom</span><span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">inv</span><span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="o">)</span>
<span class="o">(</span><span class="n">join</span><span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">SI</span><span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="o">)</span>  <span class="c">/-</span><span class="cm"> singleton_image -/</span>
<span class="o">(</span><span class="n">subset_relation</span><span class="o">:</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">equality_relation</span><span class="o">:</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">proj1</span><span class="o">:</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">proj2</span><span class="o">:</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">single_definition</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">single</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">pair</span> <span class="n">x</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="kn">infix</span> <span class="err">∈</span> <span class="o">:=</span> <span class="n">mem</span> <span class="o">)</span>
<span class="o">(</span><span class="kn">infix</span> <span class="err">∪</span> <span class="o">:=</span> <span class="n">binary_union</span><span class="o">)</span>
<span class="o">(</span><span class="kn">infix</span> <span class="err">∩</span> <span class="o">:=</span> <span class="n">intersection</span><span class="o">)</span>
<span class="o">(</span><span class="kn">infix</span> <span class="bp">×</span> <span class="o">:=</span> <span class="n">product</span><span class="o">)</span>
<span class="o">(</span><span class="kn">infix</span> <span class="err">⊆</span> <span class="o">:=</span> <span class="n">subset</span><span class="o">)</span>
<span class="o">(</span><span class="kn">notation</span> <span class="bp">`</span><span class="o">{</span><span class="bp">`</span> <span class="n">a</span> <span class="bp">`</span><span class="o">,</span><span class="bp">`</span> <span class="n">b</span> <span class="bp">`</span><span class="o">}</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">pair</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">extensionality_axiom</span><span class="o">:</span>  <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="n">a</span> <span class="bp">↔</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">b</span><span class="o">))</span> <span class="bp">→</span> <span class="n">a</span><span class="bp">=</span><span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">binary_union_axiom</span><span class="o">:</span>   <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="n">a</span> <span class="err">∪</span> <span class="n">b</span> <span class="bp">↔</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">a</span> <span class="bp">∨</span>  <span class="n">x</span> <span class="err">∈</span> <span class="n">b</span><span class="o">))</span>
<span class="o">(</span><span class="n">intersection_axiom</span><span class="o">:</span>  <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="n">a</span> <span class="err">∩</span>  <span class="n">b</span> <span class="bp">↔</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">a</span> <span class="bp">∧</span>  <span class="n">x</span> <span class="err">∈</span> <span class="n">b</span><span class="o">))</span>
<span class="o">(</span><span class="n">complement_axiom</span><span class="o">:</span>  <span class="bp">∀</span> <span class="n">a</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="n">c</span> <span class="n">a</span> <span class="bp">↔</span> <span class="bp">¬</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">a</span><span class="o">))</span>
<span class="o">(</span><span class="n">implication_axiom</span><span class="o">:</span>    <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="n">imp</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">b</span><span class="o">)))</span>
<span class="o">(</span><span class="n">emptyset_axiom</span><span class="o">:</span>   <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="bp">¬</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">phi</span><span class="o">))</span>
<span class="o">(</span><span class="n">pairing_axiom</span><span class="o">:</span>  <span class="bp">∀</span> <span class="n">x</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="o">{</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">}</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">∨</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)))</span>
<span class="o">(</span><span class="n">ordered_pairing_axiom</span><span class="o">:</span>   <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="o">(</span><span class="n">ordered_pair</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">=</span> <span class="o">{</span><span class="n">x</span><span class="o">,</span> <span class="o">{</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">}}))</span>
<span class="o">(</span><span class="n">domain</span><span class="o">:</span>  <span class="bp">∀</span> <span class="n">R</span><span class="o">,</span> <span class="o">(</span><span class="n">Rel</span> <span class="n">R</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="n">dom</span> <span class="n">R</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">y</span><span class="o">,</span> <span class="o">(</span><span class="n">ordered_pair</span> <span class="n">x</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">R</span><span class="o">))))</span>
<span class="o">(</span><span class="n">V_definition</span><span class="o">:</span>   <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="n">V</span><span class="o">))</span>
<span class="o">(</span><span class="n">Rel_definition</span><span class="o">:</span>  <span class="bp">∀</span> <span class="n">X</span><span class="o">,</span> <span class="o">(</span> <span class="n">Rel</span> <span class="n">X</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="o">(</span><span class="n">z</span> <span class="err">∈</span> <span class="n">X</span> <span class="bp">→</span>  <span class="bp">∃</span> <span class="n">a</span> <span class="n">b</span><span class="o">,(</span><span class="n">z</span> <span class="bp">=</span> <span class="n">ordered_pair</span> <span class="n">a</span> <span class="n">b</span><span class="o">))))</span>
<span class="o">(</span><span class="n">product_axiom</span><span class="o">:</span>   <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">u</span><span class="o">,</span> <span class="o">(</span><span class="n">u</span> <span class="err">∈</span> <span class="n">x</span> <span class="bp">×</span> <span class="n">y</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span> <span class="err">∈</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">b</span> <span class="err">∈</span> <span class="n">y</span> <span class="bp">∧</span> <span class="n">u</span> <span class="bp">=</span> <span class="n">ordered_pair</span> <span class="n">a</span> <span class="n">b</span> <span class="o">)))</span>
<span class="o">(</span><span class="n">inverse_axiom</span><span class="o">:</span>   <span class="bp">∀</span> <span class="n">R</span><span class="o">,</span> <span class="o">(</span><span class="n">Rel</span> <span class="n">R</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="o">(</span><span class="n">ordered_pair</span> <span class="n">x</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">inv</span> <span class="n">R</span> <span class="bp">↔</span> <span class="n">ordered_pair</span> <span class="n">y</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">R</span><span class="o">)))</span>
<span class="o">(</span><span class="n">equality_relation_axiom</span><span class="o">:</span>  <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">equality_relation</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">z</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="n">ordered_pair</span> <span class="n">z</span> <span class="n">z</span> <span class="o">)))</span>
<span class="o">(</span><span class="n">subset_definition</span><span class="o">:</span>   <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="err">⊆</span> <span class="n">y</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="o">(</span><span class="n">z</span> <span class="err">∈</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">y</span><span class="o">)))</span>
<span class="o">(</span><span class="n">subset_relation_axiom</span><span class="o">:</span>  <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="o">(</span><span class="n">ordered_pair</span> <span class="n">x</span> <span class="n">y</span>  <span class="err">∈</span> <span class="n">subset_relation</span> <span class="bp">↔</span> <span class="n">x</span> <span class="err">⊆</span> <span class="n">y</span><span class="o">))</span>
 <span class="o">(</span><span class="n">union_axiom</span><span class="o">:</span>   <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="n">union</span> <span class="n">y</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">z</span><span class="o">,</span> <span class="o">(</span><span class="n">z</span> <span class="err">∈</span> <span class="n">y</span> <span class="bp">∧</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">z</span><span class="o">)))</span>
</pre></div>


<p>not sure if this works well, though.</p>

<a name="194366273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194366273" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194366273">Michael Beeson (Apr 16 2020 at 20:55)</a>:</h4>
<p>Great!   Thank you very much!  That is cool.   No "foldr"  involved.</p>

<a name="194366330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194366330" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194366330">Marc Huisinga (Apr 16 2020 at 20:56)</a>:</h4>
<p>yes, the <code>foldr</code> handles lists of arbitrary lengths</p>

<a name="194369201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194369201" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194369201">Andrew Ashworth (Apr 16 2020 at 21:23)</a>:</h4>
<p>is intuitionistic NF set theory this? <a href="http://us.metamath.org/nfeuni/mmnf.html" title="http://us.metamath.org/nfeuni/mmnf.html">http://us.metamath.org/nfeuni/mmnf.html</a></p>

<a name="194393042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194393042" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194393042">Michael Beeson (Apr 17 2020 at 03:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110025">Andrew Ashworth</span> <a href="#narrow/stream/113488-general/topic/subst.2Eeq/near/194369201" title="#narrow/stream/113488-general/topic/subst.2Eeq/near/194369201">said</a>:</p>
<blockquote>
<p>is intuitionistic NF set theory this? <a href="http://us.metamath.org/nfeuni/mmnf.html" title="http://us.metamath.org/nfeuni/mmnf.html">http://us.metamath.org/nfeuni/mmnf.html</a></p>
</blockquote>
<p>No,  that is a finite axiomatization of classical NF.     If you want to know what NF is, look it up in Wikipedia or the Stanford Encyclopedia of Philosophy.   Intuitionistic NF is simply NF with only intuitionistic logic.</p>

<a name="194393122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194393122" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194393122">Michael Beeson (Apr 17 2020 at 03:38)</a>:</h4>
<p>Now I guess I have everything working.  Here is a small sample.   You will see that I had to repeat the notation command outside the class; if you remove it it doesn't work.   Also inside the classs it needs to be in parentheses and outside the class it may not be in parentheses.  God knows why.   Anyway,  this file and the larger file from which I abstracted it is working.   Now, I can move on to my original question about subst.eq for which this topic is named.   But not in this message.</p>
<div class="codehilite"><pre><span></span><span class="kn">set_option</span> <span class="n">default_priority</span> <span class="mi">100</span>
<span class="n">reserve</span> <span class="kn">infix</span> <span class="bp">`</span> <span class="err">∈</span> <span class="bp">`</span> <span class="o">:</span> <span class="mi">49</span>
<span class="n">class</span>  <span class="n">Model</span> <span class="o">(</span><span class="n">M</span><span class="o">:</span><span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">mem</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">pair</span><span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">single</span><span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="kn">infix</span>  <span class="err">∈</span>  <span class="o">:=</span>  <span class="n">mem</span> <span class="o">)</span>
<span class="o">(</span><span class="kn">notation</span> <span class="bp">`</span><span class="o">{</span><span class="bp">`</span> <span class="n">a</span> <span class="bp">`</span><span class="o">,</span><span class="bp">`</span> <span class="n">b</span> <span class="bp">`</span><span class="o">}</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">pair</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">extensionality_axiom</span><span class="o">:</span>  <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">mem</span> <span class="n">x</span> <span class="n">a</span> <span class="bp">↔</span> <span class="n">mem</span> <span class="n">x</span> <span class="n">b</span><span class="o">))</span> <span class="bp">→</span> <span class="n">a</span><span class="bp">=</span><span class="n">b</span><span class="o">)</span>
<span class="o">(</span> <span class="n">single_definition</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">single</span> <span class="n">x</span> <span class="bp">=</span> <span class="o">{</span><span class="n">x</span><span class="o">,</span><span class="n">x</span><span class="o">})</span>
<span class="o">(</span><span class="kn">notation</span> <span class="bp">`</span><span class="o">{</span><span class="bp">`</span> <span class="n">a</span> <span class="bp">`</span><span class="o">,</span><span class="bp">`</span> <span class="n">b</span> <span class="bp">`</span><span class="o">}</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">pair</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">Model</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">M</span><span class="o">:</span><span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">Model</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="n">X</span> <span class="n">R</span> <span class="n">W</span><span class="o">:</span> <span class="n">M</span><span class="o">)</span>
<span class="kn">constant</span> <span class="n">p</span><span class="o">:</span><span class="n">a</span><span class="bp">=</span><span class="n">b</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">eq</span><span class="bp">.</span><span class="n">symm</span><span class="o">(</span><span class="n">single_definition</span> <span class="n">x</span><span class="o">)</span>

<span class="kn">notation</span> <span class="bp">`</span><span class="o">{</span><span class="bp">`</span> <span class="n">a</span> <span class="bp">`</span><span class="o">,</span><span class="bp">`</span> <span class="n">b</span> <span class="bp">`</span><span class="o">}</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">pair</span> <span class="n">a</span> <span class="n">b</span>
<span class="kn">lemma</span> <span class="n">single_definition_reverse</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">:</span><span class="n">M</span><span class="o">,</span> <span class="o">{</span><span class="n">x</span><span class="o">,</span><span class="n">x</span><span class="o">}</span>  <span class="bp">=</span> <span class="n">single</span> <span class="n">x</span> <span class="o">:=</span>
   <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">eq</span><span class="bp">.</span><span class="n">symm</span><span class="o">(</span><span class="n">single_definition</span> <span class="n">x</span><span class="o">)</span>
</pre></div>

<a name="194397384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194397384" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194397384">Scott Morrison (Apr 17 2020 at 05:51)</a>:</h4>
<p>I'd advise not attempting to use <code>{ ... , ... }</code> in custom notation. The core parser has special handling for braces, and you are just going to suffer down the line.</p>

<a name="194400775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194400775" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194400775">Mario Carneiro (Apr 17 2020 at 06:57)</a>:</h4>
<p>If you want to use the braces notation, you should try to do it by implementing <code>has_insert</code> and <code>has_emptyc</code> instead</p>

<a name="194400841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194400841" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194400841">Michael Beeson (Apr 17 2020 at 06:58)</a>:</h4>
<p>Two questions about the following code:   (1) Why after the declaration of constant h  does #check not return the type of h just declared<br>
but instead the more complicated type in the next line?  and (2)  Can anyone show me how to prove the example in the <br>
last line using eq.subst  on single_definition?    The 'elaborator'  doesn't come up with the object h M x y that you need and I <br>
don't see how I can come up with it either.</p>
<div class="codehilite"><pre><span></span><span class="kn">set_option</span> <span class="n">default_priority</span> <span class="mi">100</span>
<span class="n">reserve</span> <span class="kn">infix</span> <span class="bp">`</span> <span class="err">∈</span> <span class="bp">`</span> <span class="o">:</span> <span class="mi">49</span>
<span class="n">class</span>  <span class="n">Model</span> <span class="o">(</span><span class="n">M</span><span class="o">:</span><span class="kt">Type</span><span class="o">)</span>  <span class="o">:=</span>
<span class="o">(</span><span class="n">mem</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">pair</span><span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">single</span><span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="kn">infix</span>  <span class="err">∈</span>  <span class="o">:=</span>  <span class="n">mem</span> <span class="o">)</span>
<span class="o">(</span><span class="kn">notation</span> <span class="bp">`</span><span class="o">{</span><span class="bp">`</span> <span class="n">a</span> <span class="bp">`</span><span class="o">,</span><span class="bp">`</span> <span class="n">b</span> <span class="bp">`</span><span class="o">}</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">pair</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">extensionality_axiom</span><span class="o">:</span>  <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">mem</span> <span class="n">x</span> <span class="n">a</span> <span class="bp">↔</span> <span class="n">mem</span> <span class="n">x</span> <span class="n">b</span><span class="o">))</span> <span class="bp">→</span> <span class="n">a</span><span class="bp">=</span><span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">pairing_axiom</span><span class="o">:</span>  <span class="bp">∀</span> <span class="n">x</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="o">{</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">}</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">∨</span>  <span class="n">x</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)))</span>
<span class="o">(</span> <span class="n">single_definition</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">single</span> <span class="n">x</span> <span class="bp">=</span> <span class="o">{</span><span class="n">x</span><span class="o">,</span><span class="n">x</span><span class="o">})</span>
<span class="o">(</span><span class="kn">notation</span> <span class="bp">`</span><span class="o">{</span><span class="bp">`</span> <span class="n">a</span> <span class="bp">`</span><span class="o">,</span><span class="bp">`</span> <span class="n">b</span> <span class="bp">`</span><span class="o">}</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">pair</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">Model</span>
<span class="kn">infix</span>  <span class="err">∈</span> <span class="o">:=</span>  <span class="n">mem</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="o">{</span><span class="bp">`</span> <span class="n">a</span> <span class="bp">`</span><span class="o">,</span><span class="bp">`</span> <span class="n">b</span> <span class="bp">`</span><span class="o">}</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">pair</span> <span class="n">a</span> <span class="n">b</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">M</span><span class="o">:</span><span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">Model</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="n">X</span> <span class="n">R</span> <span class="n">W</span><span class="o">:</span> <span class="n">M</span><span class="o">)</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">eq</span><span class="bp">.</span><span class="n">symm</span><span class="o">(</span><span class="n">single_definition</span> <span class="n">x</span><span class="o">)</span>
<span class="kn">lemma</span> <span class="n">single_definition_reverse</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">:</span><span class="n">M</span><span class="o">,</span> <span class="o">{</span><span class="n">x</span><span class="o">,</span><span class="n">x</span><span class="o">}</span>  <span class="bp">=</span> <span class="n">single</span> <span class="n">x</span> <span class="o">:=</span>
   <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">eq</span><span class="bp">.</span><span class="n">symm</span><span class="o">(</span><span class="n">single_definition</span> <span class="n">x</span><span class="o">)</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">single_definition</span> <span class="n">x</span>

<span class="kn">constant</span> <span class="n">h</span><span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">single</span> <span class="n">y</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">h</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">h</span> <span class="n">M</span> <span class="n">x</span> <span class="n">y</span>
<span class="kn">example</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="o">{</span><span class="n">y</span><span class="o">,</span><span class="n">y</span><span class="o">}</span> <span class="o">:=</span> <span class="n">single_definition</span> <span class="n">y</span> <span class="bp">▸</span> <span class="n">h</span> <span class="n">M</span> <span class="n">x</span> <span class="n">y</span>

<span class="c">/-</span><span class="cm"> example :  ∀ x, x ∈ {x,x} :=   ??  -/</span>
</pre></div>

<a name="194401044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194401044" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194401044">Michael Beeson (Apr 17 2020 at 07:01)</a>:</h4>
<p>OK but notation is not the issue here.    If I take out the braces and just use pair  I will still have the problem with not<br>
understanding the type of h.</p>

<a name="194401119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194401119" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194401119">Michael Beeson (Apr 17 2020 at 07:02)</a>:</h4>
<p>And besides I am not going "down the line" very far with this.   I'm only going to prove a few theorems in this one file to see what <br>
I can learn.   And it's easier to read the familiar notation {x,y} for unordered pair.</p>

<a name="194402017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194402017" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194402017">Michael Beeson (Apr 17 2020 at 07:14)</a>:</h4>
<p>The first question I asked,  how to prove x \in {x,x},    I've deleted.    You don't have  x \in single x  to <br>
work with .   That will only be available AFTER you prove x \in {x,x} from the pairing axiom.   So never mind <br>
that now-deleted question.</p>

<a name="194402463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194402463" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194402463">Mario Carneiro (Apr 17 2020 at 07:20)</a>:</h4>
<p>Your constant <code>h</code> pulls in the variables <code>x</code> and <code>y</code> from the <code>variables</code> line in order to produce a universally quantified axiom asserting that <code>x \in single y</code> for all x and y, which is certainly not what you want</p>

<a name="194402533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194402533" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194402533">Mario Carneiro (Apr 17 2020 at 07:20)</a>:</h4>
<p>You should let <code>h</code> be a variable too</p>

<a name="194402602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194402602" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194402602">Michael Beeson (Apr 17 2020 at 07:21)</a>:</h4>
<p>I don't want to keep that line more than a few minutes, or however long it takes to understand Lean's response.   It's not for any other purpose.</p>

<a name="194402610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194402610" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194402610">Mario Carneiro (Apr 17 2020 at 07:21)</a>:</h4>
<p>that's what <code>variable</code> is for</p>

<a name="194402654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194402654" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194402654">Mario Carneiro (Apr 17 2020 at 07:22)</a>:</h4>
<p><code>constant</code> is basically a synonym of <code>axiom</code></p>

<a name="194402681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194402681" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194402681">Mario Carneiro (Apr 17 2020 at 07:22)</a>:</h4>
<p>and it is easy to accidentally write inconsistent axioms so we try to avoid these commands entirely</p>

<a name="194402714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194402714" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194402714">Mario Carneiro (Apr 17 2020 at 07:23)</a>:</h4>
<p>If you want to scope your <code>variable</code> declarations to a portion of the file, use <code>section ... end</code></p>

<a name="194402817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194402817" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194402817">Michael Beeson (Apr 17 2020 at 07:24)</a>:</h4>
<p>So if I write 'variable'  instead of 'constant' there then Lean responds to the check as I expected,  differently than with 'constant'.</p>

<a name="194402860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194402860" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194402860">Mario Carneiro (Apr 17 2020 at 07:25)</a>:</h4>
<p>If you want a temporary notation, use <code>local notation</code> instead of <code>notation</code>. This will override all other uses of the notation, so you probably won't be able to use <code>{x | p x}</code> or <code>{x // p x}</code> or <code>{x, y, z}</code> on sets, finsets and other such things, until the end of the enclosing section</p>

<a name="194402864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194402864" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194402864">Scott Morrison (Apr 17 2020 at 07:25)</a>:</h4>
<p>We really should remove <code>axiom</code> and <code>constant</code>. :-)</p>

<a name="194402882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194402882" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194402882">Scott Morrison (Apr 17 2020 at 07:25)</a>:</h4>
<p>Or at least attach warning lights to them. :-)</p>

<a name="194402885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194402885" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194402885">Michael Beeson (Apr 17 2020 at 07:25)</a>:</h4>
<p>I'm never using 'constant'  in files I intend to keep more than 15 minutes.</p>

<a name="194402888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194402888" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194402888">Mario Carneiro (Apr 17 2020 at 07:25)</a>:</h4>
<p>There is a good reason for <code>axiom</code> and <code>constant</code> to exist</p>

<a name="194402955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194402955" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194402955">Scott Morrison (Apr 17 2020 at 07:26)</a>:</h4>
<p>I appreciate their uses --- just we seem to see lots of people learning Lean using them in unusual ways.</p>

<a name="194402958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194402958" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194402958">Michael Beeson (Apr 17 2020 at 07:26)</a>:</h4>
<p>Well,  I learned of their existence by reading Theorem Proving in Lean,  not by reading source files.</p>

<a name="194403035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194403035" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194403035">Mario Carneiro (Apr 17 2020 at 07:27)</a>:</h4>
<p>I don't know how we could make them easier to use correctly</p>

<a name="194403059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194403059" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194403059">Mario Carneiro (Apr 17 2020 at 07:27)</a>:</h4>
<p>The usage in TPIL is also an important one, where you just want to posit some things and not worry about setting them up</p>

<a name="194403077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194403077" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194403077">Michael Beeson (Apr 17 2020 at 07:27)</a>:</h4>
<p>Exactly,  that's what I'm doing here.</p>

<a name="194403146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194403146" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194403146">Mario Carneiro (Apr 17 2020 at 07:28)</a>:</h4>
<p>but you can usually get the equivalent by replacing <code>constant foo : type</code> with <code>def foo : type := sorry</code></p>

<a name="194403164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194403164" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194403164">Mario Carneiro (Apr 17 2020 at 07:28)</a>:</h4>
<p>and that at least gives you a nice warning that you are cheating</p>

<a name="194403309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194403309" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194403309">Mario Carneiro (Apr 17 2020 at 07:30)</a>:</h4>
<p>In your example file, I could see the things at the top of the file being constants and axioms, but the stuff at the bottom should definitely be variables</p>

<a name="194403329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194403329" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194403329">Michael Beeson (Apr 17 2020 at 07:30)</a>:</h4>
<p>Mario,   you said that my constant declaration produces a proof of a universally quantified formula.   That accounts for the x y in the <br>
next line and the M comes from the implicit parameter in the variable declaration.</p>

<a name="194403362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194403362" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194403362">Mario Carneiro (Apr 17 2020 at 07:31)</a>:</h4>
<p>If you are using a one letter name, that's a strong indication that you want a variable, because <code>constant</code>s go into the global namespace</p>

<a name="194403436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194403436" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194403436">Mario Carneiro (Apr 17 2020 at 07:32)</a>:</h4>
<p>all <code>constant</code>, <code>axiom</code>, <code>def</code>, <code>theorem</code> declarations go into the global environment, and there is no local context there. So you have to universally quantify, nothing else would make sense</p>

<a name="194403529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194403529" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194403529">Michael Beeson (Apr 17 2020 at 07:32)</a>:</h4>
<p>The stuff at the bottom is intended to last 15 minutes only so it doesn't matter.    And now that you've explained that <br>
my constant h  produces a proof of a universally quantified formula,  I understand the output.   And the only thing yet to do <br>
is look at the source code that accomplishes that.</p>

<a name="194403580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194403580" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194403580">Mario Carneiro (Apr 17 2020 at 07:33)</a>:</h4>
<p>just replace <code>constant</code> with <code>variable</code> and everything else should work</p>

<a name="194403600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194403600" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194403600">Mario Carneiro (Apr 17 2020 at 07:33)</a>:</h4>
<p>and also <code>h M x y</code> with <code>h</code></p>

<a name="194403650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194403650" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194403650">Michael Beeson (Apr 17 2020 at 07:34)</a>:</h4>
<p>Regarding the stuff  "at the top" of the file,   there was yesterday a lot of discussion about how to formalize a first-order theory <br>
in lean.   Plan A:   constants and axioms.    Plan B:  use a structure.    Plan C:  use a class.   So this code is using Plan C.  And I also<br>
implemented Plan A.</p>

<a name="194403718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194403718" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194403718">Michael Beeson (Apr 17 2020 at 07:35)</a>:</h4>
<p>Yes,  I already tried replacing constant with variable and saw that it does work.    So thank you (and the rest of you) for <br>
explaining this.   I guess I have this straight now.</p>

<a name="194403731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194403731" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194403731">Mario Carneiro (Apr 17 2020 at 07:35)</a>:</h4>
<p>For an industrial strength implementation, something that is going into mathlib, you should use plan B or plan C. But for your own file plan A is probably easier</p>

<a name="194403846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194403846" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194403846">Mario Carneiro (Apr 17 2020 at 07:36)</a>:</h4>
<p>in this particular case I think plan C is good because it will give you access to all the notations without much difficulty</p>

<a name="194403865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194403865" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194403865">Mario Carneiro (Apr 17 2020 at 07:37)</a>:</h4>
<p>You could look at <code>set_theory.zfc</code> for inspiration on setting up set theory</p>

<a name="194493937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194493937" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194493937">Michael Beeson (Apr 17 2020 at 20:11)</a>:</h4>
<p>In the following code,  the inference by eq.subst in the last line fails,  though its arguments are as desired as shown by the <br>
preceding #check commands.   I know the reason for this failure but not the cure.   The reason is that eq.subst takes two <br>
arguments,  the first an equality x= y and the second of the form P x,   and produces P y.   The elaborator uses higher-order unification to synthesize the appropriate P  in case the second argument doesn't already have the form of an application to x.    In the example at hand,  it has to synthesize P = \lambda z. x \in z,   which is too much for it to manage.  That is the interpretation of the error you get, which ends up with "but the expected type must be shown".    Can anyone tell me how to fix this? </p>
<div class="codehilite"><pre><span></span><span class="kn">set_option</span> <span class="n">default_priority</span> <span class="mi">100</span>
<span class="n">reserve</span> <span class="kn">infix</span> <span class="bp">`</span> <span class="err">∈</span> <span class="bp">`</span> <span class="o">:</span> <span class="mi">49</span>
<span class="n">class</span>  <span class="n">Model</span> <span class="o">(</span><span class="n">M</span><span class="o">:</span><span class="kt">Type</span><span class="o">)</span>  <span class="o">:=</span>
<span class="o">(</span><span class="n">mem</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">pair</span><span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">single</span><span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="kn">infix</span>  <span class="err">∈</span>  <span class="o">:=</span>  <span class="n">mem</span> <span class="o">)</span>
<span class="o">(</span><span class="kn">notation</span> <span class="bp">`</span><span class="o">{</span><span class="bp">`</span> <span class="n">a</span> <span class="bp">`</span><span class="o">,</span><span class="bp">`</span> <span class="n">b</span> <span class="bp">`</span><span class="o">}</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">pair</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">extensionality_axiom</span><span class="o">:</span>  <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">mem</span> <span class="n">x</span> <span class="n">a</span> <span class="bp">↔</span> <span class="n">mem</span> <span class="n">x</span> <span class="n">b</span><span class="o">))</span> <span class="bp">→</span> <span class="n">a</span><span class="bp">=</span><span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">pairing_axiom</span><span class="o">:</span>  <span class="bp">∀</span> <span class="n">x</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="o">{</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">}</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">∨</span>  <span class="n">x</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)))</span>
<span class="o">(</span> <span class="n">single_definition</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">single</span> <span class="n">x</span> <span class="bp">=</span> <span class="o">{</span><span class="n">x</span><span class="o">,</span><span class="n">x</span><span class="o">})</span>
<span class="o">(</span><span class="kn">notation</span> <span class="bp">`</span><span class="o">{</span><span class="bp">`</span> <span class="n">a</span> <span class="bp">`</span><span class="o">,</span><span class="bp">`</span> <span class="n">b</span> <span class="bp">`</span><span class="o">}</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">pair</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">Model</span>
<span class="kn">infix</span>  <span class="err">∈</span> <span class="o">:=</span>  <span class="n">mem</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="o">{</span><span class="bp">`</span> <span class="n">a</span> <span class="bp">`</span><span class="o">,</span><span class="bp">`</span> <span class="n">b</span> <span class="bp">`</span><span class="o">}</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">pair</span> <span class="n">a</span> <span class="n">b</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">M</span><span class="o">:</span><span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">Model</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="n">X</span> <span class="n">R</span> <span class="n">W</span><span class="o">:</span> <span class="n">M</span><span class="o">)</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">eq</span><span class="bp">.</span><span class="n">symm</span><span class="o">(</span><span class="n">single_definition</span> <span class="n">x</span><span class="o">)</span>


<span class="kn">lemma</span> <span class="n">single_definition_reverse</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">:</span><span class="n">M</span><span class="o">,</span> <span class="o">{</span><span class="n">x</span><span class="o">,</span><span class="n">x</span><span class="o">}</span>  <span class="bp">=</span> <span class="n">single</span> <span class="n">x</span> <span class="o">:=</span>
   <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">eq</span><span class="bp">.</span><span class="n">symm</span><span class="o">(</span><span class="n">single_definition</span> <span class="n">x</span><span class="o">)</span>


 <span class="kn">variable</span> <span class="n">h</span><span class="o">:</span><span class="n">x</span><span class="bp">=</span><span class="n">y</span>

 <span class="bp">#</span><span class="kn">check</span>  <span class="o">(</span><span class="n">pairing_axiom</span> <span class="n">x</span> <span class="n">y</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="o">(</span><span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="n">h</span><span class="o">)</span> <span class="c">/-</span><span class="cm"> x ∈ {y,y} -/</span>
 <span class="bp">#</span><span class="kn">check</span>  <span class="o">(</span><span class="n">single_definition_reverse</span> <span class="n">M</span> <span class="n">y</span> <span class="o">)</span>   <span class="c">/-</span><span class="cm"> {y,y} = single y -/</span>

 <span class="bp">#</span><span class="kn">check</span> <span class="n">eq</span><span class="bp">.</span><span class="n">subst</span>  <span class="o">(</span><span class="n">single_definition_reverse</span> <span class="n">M</span> <span class="n">y</span> <span class="o">)</span>
            <span class="o">((</span><span class="n">pairing_axiom</span> <span class="n">x</span> <span class="n">y</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="o">(</span><span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="n">h</span><span class="o">))</span>
            <span class="c">/-</span><span class="cm"> expecting x ∈ single y  but get error -/</span>
</pre></div>

<a name="194495215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194495215" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194495215">Andrew Ashworth (Apr 17 2020 at 20:23)</a>:</h4>
<p>Well, higher order unification is difficult. When it fails, you may need to explicitly provide the motive with the <code>@</code> annotation</p>

<a name="194495479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194495479" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194495479">Patrick Massot (Apr 17 2020 at 20:26)</a>:</h4>
<p>What are you trying to achieve with all those <code>eq.subst</code>? I've been using Lean for more than two years and I've written <code>eq.subst</code> anywhere.</p>

<a name="194495497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194495497" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194495497">Patrick Massot (Apr 17 2020 at 20:26)</a>:</h4>
<p>It looks very much like you're going against the flow of Lean.</p>

<a name="194495577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194495577" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194495577">Andrew Ashworth (Apr 17 2020 at 20:27)</a>:</h4>
<p>He is doing exercises to learn Lean</p>

<a name="194495661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194495661" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194495661">Patrick Massot (Apr 17 2020 at 20:28)</a>:</h4>
<p>I understand this. But they look like very weird exercises.</p>

<a name="194495686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194495686" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194495686">Patrick Massot (Apr 17 2020 at 20:28)</a>:</h4>
<p>Fighting Lean instead of letting it work for you.</p>

<a name="194495778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194495778" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194495778">Andrew Ashworth (Apr 17 2020 at 20:29)</a>:</h4>
<p>He is a logician doing logic? Such a person might be more concerned with the foundations than others in this chat <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>

<a name="194495863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194495863" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194495863">Michael Beeson (Apr 17 2020 at 20:30)</a>:</h4>
<p>I have x \in {y,y}  and I have {y,y} = single y,  and I want to conclude  x \in single y.<br>
I do not see any reason to consider that a "weird" exercise.   Just answer the question, if you can, please,  no need to comment on <br>
whether you like the question or not.</p>

<a name="194496087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194496087" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194496087">Andrew Ashworth (Apr 17 2020 at 20:32)</a>:</h4>
<p>Anyway, it is often the case that you need to help Lean unify things. This is discussed further in 6.10 of TPIL. You can go a long way with judicious use of the <code>@</code> operator and explicit expected type annotations using the <code>:</code> operator.</p>

<a name="194496353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194496353" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194496353">Patrick Massot (Apr 17 2020 at 20:34)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="o">{</span><span class="n">y</span><span class="o">,</span><span class="n">y</span><span class="o">}</span> <span class="bp">→</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">single</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">by</span> <span class="o">{</span> <span class="n">intro</span><span class="o">,</span> <span class="n">rwa</span> <span class="n">single_definition</span> <span class="n">y</span> <span class="o">}</span>
</pre></div>


<p>See? If you explain what you want to achieve then people can help you, even if you don't like reading comments.</p>

<a name="194497214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194497214" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194497214">Michael Beeson (Apr 17 2020 at 20:43)</a>:</h4>
<p>My aim is not just to prove that little fact.   My aim is to understand how Lean works.   The tactic rwa has a very complicated definition.<br>
I did not know about rwa  and I'm grateful to learn about it.  But my aim here is not just to get Lean to say some proof is correct.  I am trying to understand how Lean works.    eq.subst is no doubt important to rewrite_cfg which occurs in the first line of the definition of rwa. <br>
It is bound to be the "guts"  of equality reasoning.    That simple first-order equality reasoning requires higher-order unification that sometimes fails,  even on very simple examples, is interesting and not very wonderful.</p>

<a name="194497363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194497363" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194497363">Michael Beeson (Apr 17 2020 at 20:44)</a>:</h4>
<p>But you DID  give me a way to prove that example,  and again,  thank you for that.   <br>
Andrew,  can it be done with @ as well,  without using a complicated tactic?</p>

<a name="194497474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194497474" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194497474">Koundinya Vajjha (Apr 17 2020 at 20:45)</a>:</h4>
<p>You can try: <code>#check @eq.subst _ _ _ _ (single_definition_reverse M y ) ((pairing_axiom x y y).2 (or.inl h))</code></p>

<a name="194498359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194498359" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194498359">Andrew Ashworth (Apr 17 2020 at 20:52)</a>:</h4>
<p>Higher order unification not being very wonderful in Lean 3 was a deliberate design choice. There was a lot more effort put into heuristics for solving it in Lean 2, but it was impossible to figure out why things wouldn't unify. So it is much dumber, but easier to reason about in Lean 3. The time it takes to do unification is also much lower; which is actually something people worry about when reasoning about large proofs.</p>

<a name="194498928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194498928" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194498928">Michael Beeson (Apr 17 2020 at 20:57)</a>:</h4>
<p>It seems from the penultimate paragraph of 6.11 in TPIL, that the attribute of eq.subst itself is what is important here, <br>
and it is set to [elab_as_eliminator], which apparently tells it to turn on higher-order unification.     I guess if you put @ in front of the call you are indicating that you are going to provide some types yourself.  No examples are given in TPIL 6.11 of how to do that.</p>

<a name="194499125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194499125" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194499125">Andrew Ashworth (Apr 17 2020 at 20:59)</a>:</h4>
<p>I think it's first introduced in section 2.9</p>

<a name="194500226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194500226" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194500226">Michael Beeson (Apr 17 2020 at 21:08)</a>:</h4>
<p>Ah,  at the end of 2.9 is the definition of @.  So  @eq.subst   is eq.subst with all arguments required explicitly.  <br>
And you can see from #check @eq.subst  what the implicit arguments are.   And #check @@eq.subst only makes <br>
some of the implicit arguments be required.  So I'm beginning to see how this works.</p>

<a name="194500264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194500264" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194500264">Michael Beeson (Apr 17 2020 at 21:09)</a>:</h4>
<p>Thank you for pointing me to the end of 2.9.</p>

<a name="194500504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194500504" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194500504">Michael Beeson (Apr 17 2020 at 21:10)</a>:</h4>
<p>You are not providing "types".   You are providing  formerly-implicit arguments.    The text in section 6.11  could be clarified and <br>
a pointer to 2.9  would be nice.</p>

<a name="194500592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194500592" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194500592">Michael Beeson (Apr 17 2020 at 21:11)</a>:</h4>
<p>So then somewhere in the guts of rwa,   there is a workaround for this problem.   I'm guessing that higher-order unification <br>
is abandoned and some good old-fashioned substitution is used.</p>

<a name="194500701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194500701" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194500701">Michael Beeson (Apr 17 2020 at 21:12)</a>:</h4>
<p>After all rewrite technology long predates higher-order unification and is much, much more efficient.</p>

<a name="194501082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194501082" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194501082">Patrick Massot (Apr 17 2020 at 21:17)</a>:</h4>
<p>The answer is probably in <a href="https://github.com/leanprover-community/lean/blob/2414e7acd83fd7699966ac19aacb4755ce9d5332/src/library/tactic/rewrite_tactic.cpp#L32-L101" title="https://github.com/leanprover-community/lean/blob/2414e7acd83fd7699966ac19aacb4755ce9d5332/src/library/tactic/rewrite_tactic.cpp#L32-L101">https://github.com/leanprover-community/lean/blob/2414e7acd83fd7699966ac19aacb4755ce9d5332/src/library/tactic/rewrite_tactic.cpp#L32-L101</a></p>

<a name="194501299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194501299" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194501299">Andrew Ashworth (Apr 17 2020 at 21:20)</a>:</h4>
<p>doesn't it look so much nicer in Lean 4? <a href="https://github.com/leanprover/lean4/blob/dd4fac2a7b337d75ddfcd42cc1bf02d2b3219a1d/src/Init/Lean/Meta/Tactic/Rewrite.lean" title="https://github.com/leanprover/lean4/blob/dd4fac2a7b337d75ddfcd42cc1bf02d2b3219a1d/src/Init/Lean/Meta/Tactic/Rewrite.lean">https://github.com/leanprover/lean4/blob/dd4fac2a7b337d75ddfcd42cc1bf02d2b3219a1d/src/Init/Lean/Meta/Tactic/Rewrite.lean</a></p>

<a name="194501363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194501363" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194501363">Andrew Ashworth (Apr 17 2020 at 21:21)</a>:</h4>
<p>Probably not <span aria-label="grinning face with smiling eyes" class="emoji emoji-1f601" role="img" title="grinning face with smiling eyes">:grinning_face_with_smiling_eyes:</span></p>

<a name="194507817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194507817" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194507817">Mario Carneiro (Apr 17 2020 at 22:26)</a>:</h4>
<p><span class="user-mention" data-user-id="284844">@Michael Beeson</span>  The major downside of proving lemmas with <code>#check</code> like this is that you haven't provided the expected type. This is crucial for the <code>elab_as_eliminator</code> elaboration method used for functions like <code>eq.subst</code>. You should use <code>example</code> or <code>theorem</code>  to state your goals, then provide proofs of them, rather than using <code>#check</code>. Or if you must use <code>#check</code>, use <code>#check (term : type)</code> instead of just <code>#check term</code>.</p>

<a name="194508304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194508304" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194508304">Mario Carneiro (Apr 17 2020 at 22:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="284844">Michael Beeson</span> <a href="#narrow/stream/113488-general/topic/subst.2Eeq/near/194500701" title="#narrow/stream/113488-general/topic/subst.2Eeq/near/194500701">said</a>:</p>
<blockquote>
<p>After all rewrite technology long predates higher-order unification and is much, much more efficient.</p>
</blockquote>
<p>Lean doesn't actually do higher order unification in the sense used in this sentence. The <code>elab_as_eliminator</code> method solves higher order unification problems using essentially a rewrite: When matching <code>P t</code> against the goal <code>|- g</code>, it finds all occurrences of <code>t</code> in <code>g</code>, replaces them with <code>x</code>, and <code>P</code> becomes <code>\lam x,</code> of the result.</p>

<a name="194508343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194508343" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194508343">Mario Carneiro (Apr 17 2020 at 22:33)</a>:</h4>
<p>this is obviously not complete as a proof procedure but it is an easy heuristic to understand</p>

<a name="194560508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194560508" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194560508">Michael Beeson (Apr 18 2020 at 19:40)</a>:</h4>
<p>If anyone cares,  here's the way to make eq.subst work correctly using @@.    What I learned from this:<br>
How @ and @@ work;  that first-order equality reasoning with eq.subst requires using @@ and helping out <br>
the higher-order unification by hand;  hence rwa  is sometimes better;  perhaps (probably) rwa doesn't use<br>
higher-order unification at all.   What I have yet to learn:  why eq.subst DOES work in some algebraic examples<br>
I saw in TPIL,  and why they are easier than this apparently mindlessly simple example that doesn't work without using  @@.</p>
<div class="codehilite"><pre><span></span><span class="kn">set_option</span> <span class="n">default_priority</span> <span class="mi">100</span>
<span class="n">reserve</span> <span class="kn">infix</span> <span class="bp">`</span> <span class="err">∈</span> <span class="bp">`</span> <span class="o">:</span> <span class="mi">49</span>
<span class="n">class</span>  <span class="n">Model</span> <span class="o">(</span><span class="n">M</span><span class="o">:</span><span class="kt">Type</span><span class="o">)</span>  <span class="o">:=</span>
<span class="o">(</span><span class="n">mem</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">pair</span><span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">single</span><span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="kn">infix</span>  <span class="err">∈</span>  <span class="o">:=</span>  <span class="n">mem</span> <span class="o">)</span>
<span class="o">(</span><span class="kn">notation</span> <span class="bp">`</span><span class="o">{</span><span class="bp">`</span> <span class="n">a</span> <span class="bp">`</span><span class="o">,</span><span class="bp">`</span> <span class="n">b</span> <span class="bp">`</span><span class="o">}</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">pair</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">extensionality_axiom</span><span class="o">:</span>  <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">mem</span> <span class="n">x</span> <span class="n">a</span> <span class="bp">↔</span> <span class="n">mem</span> <span class="n">x</span> <span class="n">b</span><span class="o">))</span> <span class="bp">→</span> <span class="n">a</span><span class="bp">=</span><span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">pairing_axiom</span><span class="o">:</span>  <span class="bp">∀</span> <span class="n">x</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="o">{</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">}</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">∨</span>  <span class="n">x</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)))</span>
<span class="o">(</span> <span class="n">single_definition</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">single</span> <span class="n">x</span> <span class="bp">=</span> <span class="o">{</span><span class="n">x</span><span class="o">,</span><span class="n">x</span><span class="o">})</span>
<span class="o">(</span><span class="kn">notation</span> <span class="bp">`</span><span class="o">{</span><span class="bp">`</span> <span class="n">a</span> <span class="bp">`</span><span class="o">,</span><span class="bp">`</span> <span class="n">b</span> <span class="bp">`</span><span class="o">}</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">pair</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">Model</span>
<span class="kn">infix</span>  <span class="err">∈</span> <span class="o">:=</span>  <span class="n">mem</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="o">{</span><span class="bp">`</span> <span class="n">a</span> <span class="bp">`</span><span class="o">,</span><span class="bp">`</span> <span class="n">b</span> <span class="bp">`</span><span class="o">}</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">pair</span> <span class="n">a</span> <span class="n">b</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">M</span><span class="o">:</span><span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">Model</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="n">X</span> <span class="n">R</span> <span class="n">W</span><span class="o">:</span> <span class="n">M</span><span class="o">)</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">eq</span><span class="bp">.</span><span class="n">symm</span><span class="o">(</span><span class="n">single_definition</span> <span class="n">x</span><span class="o">)</span>


<span class="kn">lemma</span> <span class="n">single_definition_reverse</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">:</span><span class="n">M</span><span class="o">,</span> <span class="o">{</span><span class="n">x</span><span class="o">,</span><span class="n">x</span><span class="o">}</span>  <span class="bp">=</span> <span class="n">single</span> <span class="n">x</span> <span class="o">:=</span>
   <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">eq</span><span class="bp">.</span><span class="n">symm</span><span class="o">(</span><span class="n">single_definition</span> <span class="n">x</span><span class="o">)</span>


 <span class="kn">variable</span> <span class="n">h</span><span class="o">:</span><span class="n">x</span><span class="bp">=</span><span class="n">y</span>

 <span class="bp">#</span><span class="kn">check</span> <span class="n">h</span>
 <span class="bp">#</span><span class="kn">check</span> <span class="n">nat</span>

 <span class="bp">#</span><span class="kn">check</span>  <span class="o">(</span><span class="n">pairing_axiom</span> <span class="n">x</span> <span class="n">y</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="o">(</span><span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="n">h</span><span class="o">)</span> <span class="c">/-</span><span class="cm"> x ∈ {y,y} -/</span>
 <span class="bp">#</span><span class="kn">check</span>  <span class="o">(</span><span class="n">single_definition_reverse</span> <span class="n">M</span> <span class="n">y</span> <span class="o">)</span>   <span class="c">/-</span><span class="cm"> {y,y} = single y -/</span>

 <span class="kn">example</span><span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="o">{</span><span class="n">y</span><span class="o">,</span><span class="n">y</span><span class="o">}</span> <span class="bp">→</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">single</span> <span class="n">y</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">intro</span><span class="o">,</span> <span class="n">rwa</span> <span class="n">single_definition</span> <span class="n">y</span><span class="o">}</span>

 <span class="bp">#</span><span class="kn">check</span> <span class="n">eq</span><span class="bp">.</span><span class="n">subst</span>
 <span class="bp">#</span><span class="kn">check</span> <span class="bp">@@</span><span class="n">eq</span><span class="bp">.</span><span class="n">subst</span>

  <span class="bp">#</span><span class="kn">check</span> <span class="bp">@@</span><span class="n">eq</span><span class="bp">.</span><span class="n">subst</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">z</span><span class="o">,</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">z</span><span class="o">)</span> <span class="o">(</span><span class="n">single_definition_reverse</span> <span class="n">M</span> <span class="n">y</span> <span class="o">)</span>
            <span class="o">((</span><span class="n">pairing_axiom</span> <span class="n">x</span> <span class="n">y</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="o">(</span><span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="n">h</span><span class="o">))</span>
</pre></div>

<a name="194562583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194562583" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194562583">Mario Carneiro (Apr 18 2020 at 20:40)</a>:</h4>
<blockquote>
<p>that first-order equality reasoning with eq.subst requires using @@ and helping out the higher-order unification by hand</p>
</blockquote>
<p>This is not true. As I said above, what it requires is the expected type, which is almost always available when you use lean the way it is expecting you to</p>

<a name="194562606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194562606" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194562606">Mario Carneiro (Apr 18 2020 at 20:41)</a>:</h4>
<p>Lean's elaboration works from the outside in. It is important to understand this if you want to understand how to predict elaboration errors</p>

<a name="194562723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194562723" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194562723">Patrick Massot (Apr 18 2020 at 20:44)</a>:</h4>
<p>Mario, could you elaborate on this latest message?</p>

<a name="194562736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194562736" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194562736">Patrick Massot (Apr 18 2020 at 20:45)</a>:</h4>
<p>Maybe with some tricky example?</p>

<a name="194562810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194562810" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194562810">Kenny Lau (Apr 18 2020 at 20:46)</a>:</h4>
<p>if you write <code>(a : A) = (b : B)</code>, Lean will try to coerce <code>b</code> to have type <code>A</code></p>

<a name="194562823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194562823" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194562823">Kenny Lau (Apr 18 2020 at 20:47)</a>:</h4>
<p>Lean elaborates from left to right</p>

<a name="194562883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194562883" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194562883">Patrick Massot (Apr 18 2020 at 20:48)</a>:</h4>
<p>I understand left to right. Mario wrote "from the outside in".</p>

<a name="194562893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194562893" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194562893">Mario Carneiro (Apr 18 2020 at 20:48)</a>:</h4>
<p>The coercion arrows in <code>(n + n : int)</code> where <code>n : nat</code> go as <code>\u n + \u n</code> because lean is working from the outside in, it delays the coercion until it can't do anything else</p>

<a name="194562895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194562895" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194562895">Patrick Massot (Apr 18 2020 at 20:48)</a>:</h4>
<p>I sort of know that, because it's useful to debug coercion issues. But I'd like to know more</p>

<a name="194562923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194562923" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194562923">Kenny Lau (Apr 18 2020 at 20:49)</a>:</h4>
<p>"left to right" is just "outside in" for prefix notation</p>

<a name="194562924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194562924" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194562924">Mario Carneiro (Apr 18 2020 at 20:49)</a>:</h4>
<p>There are more extreme examples where elaboration literally just stops because it did things in the wrong order</p>

<a name="194562944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194562944" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194562944">Mario Carneiro (Apr 18 2020 at 20:49)</a>:</h4>
<p>You could say left to right and outside in</p>

<a name="194562992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194562992" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194562992">Mario Carneiro (Apr 18 2020 at 20:50)</a>:</h4>
<p>or "prefix traversal" of the term if you know about that</p>

<a name="194563324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194563324" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194563324">Mario Carneiro (Apr 18 2020 at 20:58)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">)</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span><span class="bp">.</span><span class="n">succ</span> <span class="c1">-- works</span>
<span class="kn">example</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">=</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">)</span> <span class="bp">+</span> <span class="n">n</span> <span class="c1">-- fails</span>
<span class="kn">example</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">)</span> <span class="bp">+</span> <span class="n">n</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">=</span> <span class="n">n</span> <span class="c1">-- works</span>
<span class="kn">example</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">+</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">n</span> <span class="c1">-- fails</span>
<span class="kn">example</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="n">n</span><span class="bp">.</span><span class="n">succ</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">)</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span> <span class="c1">-- fails</span>
<span class="kn">example</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">)</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span> <span class="c1">-- works</span>
</pre></div>


<p>To determine which of these will work, you have to know that <code>n.succ</code> fails immediately if the type of <code>n</code> is not yet known, and the elaboration proceeds in prefix order trying to assign types to all the subterms</p>

<a name="194563459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194563459" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194563459">Patrick Massot (Apr 18 2020 at 21:01)</a>:</h4>
<p>The only difficult one for me is <code>example := ∀ n, (n.succ:ℕ) + n = n -- fails</code></p>

<a name="194563527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194563527" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194563527">Mario Carneiro (Apr 18 2020 at 21:02)</a>:</h4>
<p>There, you know that <code>n.succ</code>, whatever it is, has type <code>nat</code>, but you still don't know what type <code>n</code> has</p>

<a name="194563538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194563538" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194563538">Patrick Massot (Apr 18 2020 at 21:02)</a>:</h4>
<p>It looks to me the type ascription is outside the <code>n.succ</code> so it should come first</p>

<a name="194563551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194563551" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194563551">Mario Carneiro (Apr 18 2020 at 21:02)</a>:</h4>
<p>it does</p>

<a name="194563560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194563560" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194563560">Mario Carneiro (Apr 18 2020 at 21:03)</a>:</h4>
<p>but it's not good enough because it might be <code>T.succ : T -&gt; nat</code> and <code>n</code> has type <code>T</code></p>

<a name="194563603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194563603" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194563603">Patrick Massot (Apr 18 2020 at 21:04)</a>:</h4>
<p>I see</p>

<a name="194563604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194563604" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194563604">Mario Carneiro (Apr 18 2020 at 21:04)</a>:</h4>
<p>the reason dot notation fails immediately is that if the type isn't figured out right now, we don't even know what function we are applying so type inference fails utterly</p>

<a name="194563615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194563615" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194563615">Patrick Massot (Apr 18 2020 at 21:05)</a>:</h4>
<p>Makes sense</p>

<a name="194563624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194563624" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194563624">Mario Carneiro (Apr 18 2020 at 21:05)</a>:</h4>
<p>It could probably be improved a bit if it holds off on elaborating this subtree and finishes up the other siblings before trying again; that would eliminate the left-right dependence</p>

<a name="194571498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194571498" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194571498">Michael Beeson (Apr 19 2020 at 00:38)</a>:</h4>
<p>(deleted)</p>

<a name="194577787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194577787" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194577787">Michael Beeson (Apr 19 2020 at 04:07)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">variables</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span><span class="n">nat</span><span class="o">)</span>
<span class="kn">constant</span> <span class="n">f</span><span class="o">:</span> <span class="n">nat</span><span class="bp">-&gt;</span><span class="n">nat</span><span class="bp">-&gt;</span><span class="kt">Prop</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">z</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="n">z</span><span class="o">)</span><span class="n">y</span>
</pre></div>


<p>I expected to get f x y,  but instead I get back the unreduced term.<br>
Why?</p>

<a name="194577840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194577840" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194577840">Mario Carneiro (Apr 19 2020 at 04:09)</a>:</h4>
<p><code>#check</code> doesn't reduce anything, it just typechecks the term</p>

<a name="194577841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194577841" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194577841">Mario Carneiro (Apr 19 2020 at 04:09)</a>:</h4>
<p>use <code>#reduce</code> for this</p>

<a name="194577872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194577872" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194577872">Mario Carneiro (Apr 19 2020 at 04:10)</a>:</h4>
<p>be warned that <code>#reduce</code> fails on most nontrivial examples</p>

<a name="194577899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194577899" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194577899">Mario Carneiro (Apr 19 2020 at 04:11)</a>:</h4>
<p>also you are mixing <code>variable</code> and <code>constant</code> again</p>

<a name="194577901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194577901" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194577901">Mario Carneiro (Apr 19 2020 at 04:11)</a>:</h4>
<p>the same example works with everything a <code>variable</code></p>

<a name="194577944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194577944" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194577944">Michael Beeson (Apr 19 2020 at 04:12)</a>:</h4>
<p>#reduce works on this example.   So what can I put in my code to get that done,  as opposed to at the command level?</p>

<a name="194577950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194577950" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194577950">Mario Carneiro (Apr 19 2020 at 04:13)</a>:</h4>
<p>you don't have to write anything, reduction happens automatically as necessary</p>

<a name="194577956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194577956" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194577956">Michael Beeson (Apr 19 2020 at 04:13)</a>:</h4>
<p>Sorry about variables and constants, but I'm not even saving this file.<br>
Well, reduction doesn't seem to happen automatically in my code...</p>

<a name="194577957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194577957" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194577957">Mario Carneiro (Apr 19 2020 at 04:13)</a>:</h4>
<p>do you have any target theorem?</p>

<a name="194577959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194577959" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194577959">Mario Carneiro (Apr 19 2020 at 04:13)</a>:</h4>
<p>I'm not sure what saving the file has to do with anything</p>

<a name="194577998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194577998" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194577998">Mario Carneiro (Apr 19 2020 at 04:14)</a>:</h4>
<p>I'm saying that <code>variable</code> is better suited for short lived terms</p>

<a name="194578005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194578005" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194578005">Mario Carneiro (Apr 19 2020 at 04:15)</a>:</h4>
<p>reduction happens when it is forced to happen</p>

<a name="194578014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194578014" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194578014">Mario Carneiro (Apr 19 2020 at 04:15)</a>:</h4>
<p>but doing reduction eagerly would be a very bad idea</p>

<a name="194578018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194578018" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194578018">Michael Beeson (Apr 19 2020 at 04:15)</a>:</h4>
<p>OK  I got the point about variables,  I'll try to do better in the future.</p>

<a name="194578035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194578035" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194578035">Mario Carneiro (Apr 19 2020 at 04:16)</a>:</h4>
<p>because most definitions are sitting on a huge stack of other definitions such that a full reduction would result in an astronomically large term</p>

<a name="194578073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194578073" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194578073">Mario Carneiro (Apr 19 2020 at 04:16)</a>:</h4>
<p>this is why <code>#reduce</code> fails</p>

<a name="194578082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194578082" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194578082">Mario Carneiro (Apr 19 2020 at 04:16)</a>:</h4>
<p>so instead reduction is performed only when there is a type mismatch in an application</p>

<a name="194578084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194578084" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194578084">Mario Carneiro (Apr 19 2020 at 04:16)</a>:</h4>
<p>and only enough to resolve the difference</p>

<a name="194578130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194578130" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194578130">Mario Carneiro (Apr 19 2020 at 04:18)</a>:</h4>
<p>for an example using <code>#check</code>, consider <code>#check (rfl : (λ z, f x z)y = f x y)</code></p>

<a name="194578161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194578161" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194578161">Mario Carneiro (Apr 19 2020 at 04:19)</a>:</h4>
<p>since <code>rfl</code> is a proof of <code>a = a</code>, lean has to reduce the lhs until it matches the rhs in order to agree that this is type correct</p>

<a name="194581129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194581129" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194581129">Michael Beeson (Apr 19 2020 at 05:55)</a>:</h4>
<p>TPIL says that attributes are applied to definitions in order to solve this problem.</p>

<a name="194583201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194583201" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194583201">Mario Carneiro (Apr 19 2020 at 07:05)</a>:</h4>
<p>what problem?</p>

<a name="194583260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subst.eq/near/194583260" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/07094substeq.html#194583260">Mario Carneiro (Apr 19 2020 at 07:06)</a>:</h4>
<p>The <code>@[reducible]</code> attribute can be applied to a definition as a hint for certain tactics to unfold more definitions than they normally would during unification, but they still don't reduce unless they need to</p>


{% endraw %}

{% include archive_update.html %}