---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/89725elaborationissuechallenge.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/89725elaborationissuechallenge.html">elaboration issue challenge</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="191282282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/elaboration%20issue%20challenge/near/191282282" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/89725elaborationissuechallenge.html#191282282">Patrick Massot (Mar 20 2020 at 18:19)</a>:</h4>
<p>I have a great new elaboration issue for the most experts users of this distinguished place. The only bad point is it's not minimized. In order to play, you need to <code>leanproject get mathlib:sgouezel_multilinear</code>, then <code>code mathlib_sgouezel_multilinear</code> and open <code>analysis/normed_space/multilinear</code> and go to line 247. Have a quick look at the statement of the next lemma, and take the firm decision to fix that ugly string of underscores.</p>
<p>Now, before that lemma, end the multilinear_map namespace, and paste the following section:</p>
<div class="codehilite"><pre><span></span><span class="kn">section</span>
<span class="c1">--set_option pp.implicit true</span>
<span class="kn">lemma</span>  <span class="n">multilinear_map</span><span class="bp">.</span><span class="n">restr_norm_le</span> <span class="o">{</span><span class="n">k</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">â„•</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">multilinear_map</span> <span class="err">ğ•œ</span> <span class="o">(</span><span class="bp">Î»</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">G</span><span class="o">)</span> <span class="n">Eâ‚‚</span><span class="o">)</span>
  <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">))</span> <span class="o">(</span><span class="n">hk</span> <span class="o">:</span> <span class="n">s</span><span class="bp">.</span><span class="n">card</span> <span class="bp">=</span> <span class="n">k</span><span class="o">)</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">â„</span><span class="o">}</span>
  <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">âˆ€</span> <span class="n">m</span><span class="o">,</span> <span class="err">âˆ¥</span><span class="n">f</span> <span class="n">m</span><span class="err">âˆ¥</span> <span class="bp">â‰¤</span> <span class="n">C</span> <span class="bp">*</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">prod</span> <span class="o">(</span><span class="bp">Î»</span><span class="n">i</span><span class="o">,</span> <span class="err">âˆ¥</span><span class="n">m</span> <span class="n">i</span><span class="err">âˆ¥</span><span class="o">))</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span> <span class="bp">â†’</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span>
<span class="err">âˆ¥</span><span class="n">f</span><span class="bp">.</span><span class="n">restr</span>  <span class="n">s</span> <span class="n">hk</span> <span class="n">z</span> <span class="n">v</span><span class="err">âˆ¥</span> <span class="bp">â‰¤</span> <span class="n">C</span> <span class="bp">*</span> <span class="err">âˆ¥</span><span class="n">z</span><span class="err">âˆ¥</span> <span class="err">^</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="n">k</span><span class="o">)</span> <span class="bp">*</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">prod</span> <span class="o">(</span><span class="bp">Î»</span><span class="n">i</span><span class="o">,</span> <span class="err">âˆ¥</span><span class="n">v</span> <span class="n">i</span><span class="err">âˆ¥</span><span class="o">)</span>  <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">sorry</span>
<span class="kn">end</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="bp">â„•</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">multilinear_map</span> <span class="err">ğ•œ</span> <span class="o">(</span><span class="bp">Î»</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">G</span><span class="o">)</span> <span class="n">Eâ‚‚</span><span class="o">)</span>
  <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">))</span> <span class="o">(</span><span class="n">hk</span> <span class="o">:</span> <span class="n">s</span><span class="bp">.</span><span class="n">card</span> <span class="bp">=</span> <span class="n">k</span><span class="o">)</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">â„</span><span class="o">}</span>
  <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">âˆ€</span> <span class="n">m</span><span class="o">,</span> <span class="err">âˆ¥</span><span class="n">f</span> <span class="n">m</span><span class="err">âˆ¥</span> <span class="bp">â‰¤</span> <span class="n">C</span> <span class="bp">*</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">prod</span> <span class="o">(</span><span class="bp">Î»</span><span class="n">i</span><span class="o">,</span> <span class="err">âˆ¥</span><span class="n">m</span> <span class="n">i</span><span class="err">âˆ¥</span><span class="o">))</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span> <span class="bp">â†’</span> <span class="n">G</span><span class="o">)</span>
<span class="n">include</span> <span class="n">H</span>

<span class="kn">lemma</span> <span class="n">multilinear_map</span><span class="bp">.</span><span class="n">restr_norm_le&#39;</span> <span class="o">:</span> <span class="err">âˆ¥</span><span class="n">f</span><span class="bp">.</span><span class="n">restr</span>  <span class="n">s</span> <span class="n">hk</span> <span class="n">z</span> <span class="n">v</span><span class="err">âˆ¥</span> <span class="bp">â‰¤</span> <span class="n">C</span> <span class="bp">*</span> <span class="err">âˆ¥</span><span class="n">z</span><span class="err">âˆ¥</span> <span class="err">^</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="n">k</span><span class="o">)</span> <span class="bp">*</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">prod</span> <span class="o">(</span><span class="bp">Î»</span><span class="n">i</span><span class="o">,</span> <span class="err">âˆ¥</span><span class="n">v</span> <span class="n">i</span><span class="err">âˆ¥</span><span class="o">)</span>
 <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">sorry</span>
<span class="kn">end</span>
<span class="kn">end</span>
</pre></div>

<a name="191282330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/elaboration%20issue%20challenge/near/191282330" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/89725elaborationissuechallenge.html#191282330">Patrick Massot (Mar 20 2020 at 18:19)</a>:</h4>
<p>Note how the first statement is rejected, and the second one is accepted.</p>

<a name="191282408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/elaboration%20issue%20challenge/near/191282408" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/89725elaborationissuechallenge.html#191282408">Patrick Massot (Mar 20 2020 at 18:20)</a>:</h4>
<p>On surface level, the only difference is the second lemma has all arguments passed as variables.</p>

<a name="191282481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/elaboration%20issue%20challenge/near/191282481" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/89725elaborationissuechallenge.html#191282481">Patrick Massot (Mar 20 2020 at 18:20)</a>:</h4>
<p>Now un-comment the <code>set_option</code> line, replace the first statement by <code>sorry</code> and spot the differences in context.</p>

<a name="191282773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/elaboration%20issue%20challenge/near/191282773" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/89725elaborationissuechallenge.html#191282773">Patrick Massot (Mar 20 2020 at 18:23)</a>:</h4>
<p>Did you get it? It's in the <code>[âˆ€i, add_comm_group (Mâ‚ i)]</code> argument to <code>multilinear_map</code>. Here <code>Mâ‚</code> is the constant function from <code>fin n</code> to <code>Type</code> with value <code>G</code>.</p>

<a name="191282940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/elaboration%20issue%20challenge/near/191282940" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/89725elaborationissuechallenge.html#191282940">Patrick Massot (Mar 20 2020 at 18:24)</a>:</h4>
<p>When it works, the inferred instance features  boring naked <code>G</code>. In the failing case you'll see <code>(Î» (i : fin n), G) i</code>.</p>

<a name="191283009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/elaboration%20issue%20challenge/near/191283009" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/89725elaborationissuechallenge.html#191283009">Patrick Massot (Mar 20 2020 at 18:24)</a>:</h4>
<p>Now the challenge is to explain the issue, and PR a fix to Lean 3.7.3.</p>

<a name="191283246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/elaboration%20issue%20challenge/near/191283246" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/89725elaborationissuechallenge.html#191283246">Patrick Massot (Mar 20 2020 at 18:26)</a>:</h4>
<p>Let me ping <span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> since this happens in his PR.</p>

<a name="191291490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/elaboration%20issue%20challenge/near/191291490" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/89725elaborationissuechallenge.html#191291490">Kevin Buzzard (Mar 20 2020 at 19:30)</a>:</h4>
<p>Is it documented that <code>leanproject get mathlib:sgouezel_multilinear</code> works to get a mathlib branch? I hadn't realised this, I've been getting mathlib and then switching branches and getting the oleans. This way is much cooler :-)</p>

<a name="191292545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/elaboration%20issue%20challenge/near/191292545" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/89725elaborationissuechallenge.html#191292545">Kevin Buzzard (Mar 20 2020 at 19:40)</a>:</h4>
<p>So the failure gives the error</p>
<div class="codehilite"><pre><span></span>type mismatch at application
  multilinear_map.restr f
term
  f
has type
  multilinear_map ğ•œ (Î» (i : fin n), G) Eâ‚‚ : Type (max wG wâ‚‚)
but is expected to have type
  multilinear_map ?m_1 (Î» (i : fin ?m_2), ?m_3) ?m_4 : Type (max ? ?)
</pre></div>


<p>which is the kind of frustrating error which one sees occasionally, because clearly one can solve for the metavariables. Are you saying that you might be able to understand this failure and perhaps the prettyprinter is lying to us?</p>

<a name="191301193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/elaboration%20issue%20challenge/near/191301193" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/89725elaborationissuechallenge.html#191301193">Patrick Massot (Mar 20 2020 at 20:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113488-general/topic/elaboration.20issue.20challenge/near/191291490" title="#narrow/stream/113488-general/topic/elaboration.20issue.20challenge/near/191291490">said</a>:</p>
<blockquote>
<p>Is it documented that <code>leanproject get mathlib:sgouezel_multilinear</code> works to get a mathlib branch? I hadn't realised this, I've been getting mathlib and then switching branches and getting the oleans. This way is much cooler :-)</p>
</blockquote>
<p>Yes, last paragraph of "Getting an existing Lean project" at <a href="https://github.com/leanprover-community/mathlib-tools/blob/master/README.md#getting-an-existing-lean-project" target="_blank" title="https://github.com/leanprover-community/mathlib-tools/blob/master/README.md#getting-an-existing-lean-project">https://github.com/leanprover-community/mathlib-tools/blob/master/README.md#getting-an-existing-lean-project</a></p>

<a name="191301414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/elaboration%20issue%20challenge/near/191301414" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/89725elaborationissuechallenge.html#191301414">Patrick Massot (Mar 20 2020 at 20:57)</a>:</h4>
<p>Elaboration fails to fill in metavariables presumably because it fails some class instance search, because there is application which is not <code>random.choice(['alpha', 'beta', 'gamma', 'delta', 'zeta'])</code>-reduced.</p>

<a name="191301542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/elaboration%20issue%20challenge/near/191301542" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/89725elaborationissuechallenge.html#191301542">Johan Commelin (Mar 20 2020 at 20:58)</a>:</h4>
<p>Aren't you missing <code>eta</code>?</p>

<a name="191301626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/elaboration%20issue%20challenge/near/191301626" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/89725elaborationissuechallenge.html#191301626">Patrick Massot (Mar 20 2020 at 20:59)</a>:</h4>
<p>Do you think it's <code>eta</code>? Doesn't sound likely to my ear <span aria-label="grinning" class="emoji emoji-1f600" role="img" title="grinning">:grinning:</span></p>

<a name="191301772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/elaboration%20issue%20challenge/near/191301772" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/89725elaborationissuechallenge.html#191301772">Johan Commelin (Mar 20 2020 at 21:00)</a>:</h4>
<p><a href="https://en.wikipedia.org/wiki/Lambda_calculus#Reduction" target="_blank" title="https://en.wikipedia.org/wiki/Lambda_calculus#Reduction">https://en.wikipedia.org/wiki/Lambda_calculus#Reduction</a></p>

<a name="191301836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/elaboration%20issue%20challenge/near/191301836" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/89725elaborationissuechallenge.html#191301836">Patrick Massot (Mar 20 2020 at 21:01)</a>:</h4>
<p>Wikipedia says beta</p>

<a name="191301875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/elaboration%20issue%20challenge/near/191301875" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/89725elaborationissuechallenge.html#191301875">Patrick Massot (Mar 20 2020 at 21:01)</a>:</h4>
<p>Johan was looking there too :)</p>

<a name="191301912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/elaboration%20issue%20challenge/near/191301912" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/89725elaborationissuechallenge.html#191301912">Johan Commelin (Mar 20 2020 at 21:01)</a>:</h4>
<p>Ooh, I was just complaining that your Russian roulette was missing out on some options.</p>

<a name="191301932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/elaboration%20issue%20challenge/near/191301932" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/89725elaborationissuechallenge.html#191301932">Patrick Massot (Mar 20 2020 at 21:01)</a>:</h4>
<p>I know.</p>

<a name="191302033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/elaboration%20issue%20challenge/near/191302033" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/89725elaborationissuechallenge.html#191302033">Patrick Massot (Mar 20 2020 at 21:02)</a>:</h4>
<p>We should have a general purpose Zulip shortcut to insert <code>random.choice(['alpha', 'beta', 'gamma', 'delta', 'eta' 'zeta'])</code></p>

<a name="191302130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/elaboration%20issue%20challenge/near/191302130" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/89725elaborationissuechallenge.html#191302130">Patrick Massot (Mar 20 2020 at 21:03)</a>:</h4>
<p>In the mean time, I hope some expert will have a look, or at least <span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span>  will post his standard: "this is fixed in Lean 4" message.</p>

<a name="191342096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/elaboration%20issue%20challenge/near/191342096" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/89725elaborationissuechallenge.html#191342096">Patrick Massot (Mar 21 2020 at 11:50)</a>:</h4>
<p><span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> it's a bit sad no expert seems to have anything to say here, but I still recommend you but the multilinear map in a variable (you can leave everything else in the lemma), and have the nice statement.</p>

<a name="191343069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/elaboration%20issue%20challenge/near/191343069" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/89725elaborationissuechallenge.html#191343069">Gabriel Ebner (Mar 21 2020 at 12:20)</a>:</h4>
<p>Since you're calling the experts, I can give you one more workaround:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span>  <span class="n">multilinear_map</span><span class="bp">.</span><span class="n">restr_norm_le</span> <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="bp">â„•</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="o">(</span><span class="n">multilinear_map</span> <span class="err">ğ•œ</span> <span class="o">(</span><span class="bp">Î»</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">G</span><span class="o">)</span> <span class="n">Eâ‚‚</span> <span class="o">:</span> <span class="bp">_</span><span class="o">))</span>
  <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">))</span> <span class="o">(</span><span class="n">hk</span> <span class="o">:</span> <span class="n">s</span><span class="bp">.</span><span class="n">card</span> <span class="bp">=</span> <span class="n">k</span><span class="o">)</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">â„</span><span class="o">}</span>
  <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">âˆ€</span> <span class="n">m</span><span class="o">,</span> <span class="err">âˆ¥</span><span class="n">f</span> <span class="n">m</span><span class="err">âˆ¥</span> <span class="bp">â‰¤</span> <span class="n">C</span> <span class="bp">*</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">prod</span> <span class="o">(</span><span class="bp">Î»</span><span class="n">i</span><span class="o">,</span> <span class="err">âˆ¥</span><span class="n">m</span> <span class="n">i</span><span class="err">âˆ¥</span><span class="o">))</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span> <span class="bp">â†’</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span>
<span class="err">âˆ¥</span><span class="n">f</span><span class="bp">.</span><span class="n">restr</span>  <span class="n">s</span> <span class="n">hk</span> <span class="n">z</span> <span class="n">v</span><span class="err">âˆ¥</span> <span class="bp">â‰¤</span> <span class="n">C</span> <span class="bp">*</span> <span class="err">âˆ¥</span><span class="n">z</span><span class="err">âˆ¥</span> <span class="err">^</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="n">k</span><span class="o">)</span> <span class="bp">*</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">prod</span> <span class="o">(</span><span class="bp">Î»</span><span class="n">i</span><span class="o">,</span> <span class="err">âˆ¥</span><span class="n">v</span> <span class="n">i</span><span class="err">âˆ¥</span><span class="o">)</span>  <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>

<a name="191343086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/elaboration%20issue%20challenge/near/191343086" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/89725elaborationissuechallenge.html#191343086">Gabriel Ebner (Mar 21 2020 at 12:21)</a>:</h4>
<p>I assume that is also the elaboration difference between variables and arguments: types of variables are apparently elaborated without expected type, but arguments are elaborated with expected type <code>Sort*</code>.</p>

<a name="191343828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/elaboration%20issue%20challenge/near/191343828" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/89725elaborationissuechallenge.html#191343828">Patrick Massot (Mar 21 2020 at 12:40)</a>:</h4>
<p>Thanks Gabriel!</p>

<a name="191343849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/elaboration%20issue%20challenge/near/191343849" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/89725elaborationissuechallenge.html#191343849">Patrick Massot (Mar 21 2020 at 12:40)</a>:</h4>
<p>SÃ©bastien, did you see that?</p>

<a name="191344618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/elaboration%20issue%20challenge/near/191344618" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/89725elaborationissuechallenge.html#191344618">Kevin Buzzard (Mar 21 2020 at 13:02)</a>:</h4>
<p>If we went through Lean's library and replaced every <code>(a : A)</code> function input with <code>(a : (A : _))</code> would anything break?</p>

<a name="191345900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/elaboration%20issue%20challenge/near/191345900" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/89725elaborationissuechallenge.html#191345900">Mario Carneiro (Mar 21 2020 at 13:34)</a>:</h4>
<p>it seems unlikely, but lean works in mysterious ways</p>

<a name="191347374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/elaboration%20issue%20challenge/near/191347374" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/89725elaborationissuechallenge.html#191347374">Sebastian Ullrich (Mar 21 2020 at 14:09)</a>:</h4>
<p>In Lean 4, there will actually be no difference between variables and regular parameters, because the former are simply macros and are re-elaborated inside each declaration that uses them.</p>

<a name="191347524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/elaboration%20issue%20challenge/near/191347524" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/89725elaborationissuechallenge.html#191347524">Kevin Buzzard (Mar 21 2020 at 14:13)</a>:</h4>
<p>Here is a version which uses only mathlib master and uses much less of it:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">analysis</span><span class="bp">.</span><span class="n">normed_space</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">variables</span>

<span class="o">{</span><span class="err">ğ•œ</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span>
<span class="o">[</span><span class="n">nondiscrete_normed_field</span> <span class="err">ğ•œ</span><span class="o">]</span>
<span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span>
<span class="o">[</span><span class="n">normed_group</span> <span class="n">G</span><span class="o">]</span>
<span class="o">[</span><span class="n">normed_space</span> <span class="err">ğ•œ</span> <span class="n">G</span><span class="o">]</span>
<span class="o">{</span><span class="n">I</span> <span class="n">J</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span>

<span class="kn">structure</span> <span class="n">mm</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">Mâ‚</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">â†’</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="bp">âˆ€</span> <span class="n">i</span>  <span class="o">:</span> <span class="n">I</span><span class="o">,</span> <span class="n">add_comm_group</span> <span class="o">(</span><span class="n">Mâ‚</span> <span class="n">i</span><span class="o">)]</span>
<span class="o">[</span><span class="bp">âˆ€</span> <span class="n">i</span> <span class="o">:</span> <span class="n">I</span><span class="o">,</span> <span class="n">module</span> <span class="n">R</span> <span class="o">(</span><span class="n">Mâ‚</span> <span class="n">i</span><span class="o">)]</span>
<span class="bp">.</span>

<span class="c1">-- M&#39; is implicit and we will show that Lean can&#39;t guess it below</span>
<span class="n">def</span> <span class="n">mmrest</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">M&#39;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M&#39;</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M&#39;</span><span class="o">]</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
  <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">mm</span> <span class="n">R</span> <span class="n">I</span> <span class="o">(</span><span class="bp">Î»</span> <span class="n">i</span> <span class="o">:</span> <span class="n">I</span><span class="o">,</span> <span class="n">M&#39;</span><span class="o">))</span> <span class="o">:</span> <span class="n">mm</span> <span class="n">R</span> <span class="n">I</span> <span class="o">(</span><span class="bp">Î»</span> <span class="n">j</span> <span class="o">:</span> <span class="n">I</span><span class="o">,</span> <span class="n">M&#39;</span><span class="o">)</span> <span class="o">:=</span> <span class="n">F</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">mm</span> <span class="err">ğ•œ</span> <span class="n">I</span> <span class="o">(</span><span class="bp">Î»</span> <span class="n">i</span> <span class="o">:</span> <span class="n">I</span><span class="o">,</span> <span class="n">G</span><span class="o">))</span>

<span class="c1">-- works fine</span>
<span class="kn">lemma</span> <span class="n">restr_norm_le</span> <span class="o">:</span> <span class="n">mmrest</span> <span class="err">ğ•œ</span> <span class="n">I</span> <span class="n">F</span> <span class="bp">=</span> <span class="n">mmrest</span> <span class="err">ğ•œ</span> <span class="n">I</span> <span class="n">F</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="c1">-- also works</span>
<span class="kn">lemma</span> <span class="n">restr_norm_le&#39;</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="o">(</span><span class="n">mm</span> <span class="err">ğ•œ</span> <span class="n">I</span> <span class="o">(</span><span class="bp">Î»</span> <span class="n">i</span> <span class="o">:</span> <span class="n">I</span><span class="o">,</span> <span class="n">G</span><span class="o">)))</span> <span class="o">:</span>
<span class="bp">@</span><span class="n">mmrest</span> <span class="err">ğ•œ</span> <span class="bp">_</span> <span class="n">G</span> <span class="bp">_</span> <span class="bp">_</span>  <span class="n">I</span> <span class="n">F</span> <span class="bp">=</span> <span class="n">mmrest</span> <span class="err">ğ•œ</span> <span class="n">I</span> <span class="n">F</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">refl</span> <span class="c1">-- removing G makes it fail</span>

<span class="c1">-- Lean can&#39;t guess G</span>
<span class="kn">lemma</span> <span class="n">restr_norm_le&#39;&#39;</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="o">(</span><span class="n">mm</span> <span class="err">ğ•œ</span> <span class="n">I</span> <span class="o">(</span><span class="bp">Î»</span> <span class="n">i</span> <span class="o">:</span> <span class="n">I</span><span class="o">,</span> <span class="n">G</span><span class="o">)))</span> <span class="o">:</span>
<span class="n">mmrest</span> <span class="err">ğ•œ</span> <span class="n">I</span> <span class="n">F</span> <span class="bp">=</span> <span class="n">mmrest</span> <span class="err">ğ•œ</span> <span class="n">I</span> <span class="n">F</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">refl</span> <span class="c1">-- fails</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">type mismatch at application</span>
<span class="cm">  mmrest ğ•œ I F</span>
<span class="cm">term</span>
<span class="cm">  F</span>
<span class="cm">has type</span>
<span class="cm">  mm ğ•œ I (Î» (i : I), G)</span>
<span class="cm">but is expected to have type</span>
<span class="cm">  mm ğ•œ I (Î» (i : I), ?m_1)</span>
<span class="cm">-/</span>
</pre></div>

<a name="191347579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/elaboration%20issue%20challenge/near/191347579" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/89725elaborationissuechallenge.html#191347579">Kevin Buzzard (Mar 21 2020 at 14:14)</a>:</h4>
<p>Lean is failing to infer <code>G</code> from <code>(Î» i : I, G)</code></p>

<a name="191347763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/elaboration%20issue%20challenge/near/191347763" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/89725elaborationissuechallenge.html#191347763">Kevin Buzzard (Mar 21 2020 at 14:18)</a>:</h4>
<p>When it succeeds. <code>F</code> has type</p>
<div class="codehilite"><pre><span></span>F :
  @mm ğ•œ
    (@normed_ring.to_ring ğ•œ
       (@normed_field.to_normed_ring ğ•œ (@nondiscrete_normed_field.to_normed_field ğ•œ _inst_1)))
    I
    (Î» (i : I), G)
    (Î» (i : I), @normed_group.to_add_comm_group G _inst_2)
    (Î» (i : I),
       @normed_space.to_module ğ•œ G (@nondiscrete_normed_field.to_normed_field ğ•œ _inst_1) _inst_2 _inst_3)
</pre></div>


<p>and when it fails, it has the defeq type</p>
<div class="codehilite"><pre><span></span>  @mm ğ•œ
    (@normed_ring.to_ring ğ•œ
       (@normed_field.to_normed_ring ğ•œ (@nondiscrete_normed_field.to_normed_field ğ•œ _inst_1)))
    I
    (Î» (i : I), G)
    (Î» (i : I), @normed_group.to_add_comm_group ((Î» (i : I), G) i) _inst_2)
    (Î» (i : I),
       @normed_space.to_module ğ•œ ((Î» (i : I), G) i) (@nondiscrete_normed_field.to_normed_field ğ•œ _inst_1) _inst_2
         _inst_3)
</pre></div>

<a name="191348138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/elaboration%20issue%20challenge/near/191348138" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/89725elaborationissuechallenge.html#191348138">Gabriel Ebner (Mar 21 2020 at 14:27)</a>:</h4>
<p>The issue lies in unification: we need to solve <code>?m1 =?= (fun x, G) i</code> where <code>?m1</code> may not contain <code>i</code>.</p>

<a name="191348194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/elaboration%20issue%20challenge/near/191348194" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/89725elaborationissuechallenge.html#191348194">Kevin Buzzard (Mar 21 2020 at 14:28)</a>:</h4>
<p>How about <code>?m1=G</code>?</p>

<a name="191348419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/elaboration%20issue%20challenge/near/191348419" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/89725elaborationissuechallenge.html#191348419">Sebastien Gouezel (Mar 21 2020 at 14:33)</a>:</h4>
<p>I have fixed the PR following <span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> 's advice. Thanks Gabriel!</p>

<a name="191348553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/elaboration%20issue%20challenge/near/191348553" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/89725elaborationissuechallenge.html#191348553">Kevin Buzzard (Mar 21 2020 at 14:36)</a>:</h4>
<p>Another fix would be to make the implicit variable explicit -- the one which unification can't guess.</p>

<a name="191348584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/elaboration%20issue%20challenge/near/191348584" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/89725elaborationissuechallenge.html#191348584">Kevin Buzzard (Mar 21 2020 at 14:37)</a>:</h4>
<p>You are asking Lean to guess <code>G from </code>(f : multilinear_map ğ•œ (Î» i : fin n, G) Eâ‚‚)` and perhaps we learn here that it is not always capable of such guesses.</p>

<a name="191349317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/elaboration%20issue%20challenge/near/191349317" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/89725elaborationissuechallenge.html#191349317">Gabriel Ebner (Mar 21 2020 at 14:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113488-general/topic/elaboration.20issue.20challenge/near/191348194" title="#narrow/stream/113488-general/topic/elaboration.20issue.20challenge/near/191348194">said</a>:</p>
<blockquote>
<p>How about <code>?m1=G</code>?</p>
</blockquote>
<p>This is exactly the solution that we would like, <em>in this case</em>.  So you say, "how about we just beta-reduce the right-hand side whenever we assign a meta-variable"?  And in this case, it would work.  However changes in the unifier have the unfortunate habit of breaking things elsewhere in unexpected places.  Since it is not 100% clear to me that this the right behavior, I'm not too eager to change the unifier unless this problem pops up more often.</p>

<a name="191349748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/elaboration%20issue%20challenge/near/191349748" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/89725elaborationissuechallenge.html#191349748">Kevin Buzzard (Mar 21 2020 at 15:01)</a>:</h4>
<p>I see!</p>

<a name="191352293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/elaboration%20issue%20challenge/near/191352293" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/89725elaborationissuechallenge.html#191352293">Patrick Stevens (Mar 21 2020 at 15:58)</a>:</h4>
<p>Forgive the noob question, but this made me think about a problem I encountered earlier today: is it possible to manually assign a metavariable? If I have <code>m1</code> in scope in a goal, can I specify <code>m1</code> somehow without having to track down where exactly the metavariable arose?</p>

<a name="191352377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/elaboration%20issue%20challenge/near/191352377" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/89725elaborationissuechallenge.html#191352377">Johan Commelin (Mar 21 2020 at 16:00)</a>:</h4>
<p>It means that you'll have multiple goals.</p>

<a name="191352402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/elaboration%20issue%20challenge/near/191352402" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/89725elaborationissuechallenge.html#191352402">Johan Commelin (Mar 21 2020 at 16:00)</a>:</h4>
<p>So you can use <code>swap 4</code> to jump to goal number 4. And use <code>exact foobar</code> close it.</p>

<a name="191352411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/elaboration%20issue%20challenge/near/191352411" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/89725elaborationissuechallenge.html#191352411">Johan Commelin (Mar 21 2020 at 16:00)</a>:</h4>
<p>You will have to figure out manually which goal corresponds to <code>?m1</code></p>

<a name="191352754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/elaboration%20issue%20challenge/near/191352754" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/89725elaborationissuechallenge.html#191352754">Kevin Buzzard (Mar 21 2020 at 16:06)</a>:</h4>
<p>I think that in general you might want to try and avoid metavariables in goals. Usually when one appears for me, I instantly stomp on it by changing the line which created it. It is often not hard to do this, it is usually an <code>_</code> which just needed to be filled in explicitly. Having metavariables around can actually mess you up, some tactics can get confused for example.</p>


{% endraw %}

{% include archive_update.html %}