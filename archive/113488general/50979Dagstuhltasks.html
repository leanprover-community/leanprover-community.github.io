---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/50979Dagstuhltasks.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/50979Dagstuhltasks.html">Dagstuhl tasks</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="135961777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dagstuhl%20tasks/near/135961777" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50979Dagstuhltasks.html#135961777">Neil Strickland (Oct 17 2018 at 10:00)</a>:</h4>
<p>Some of you will have seen my post on Mathoverflow (<a href="https://mathoverflow.net/q/311159" target="_blank" title="https://mathoverflow.net/q/311159">https://mathoverflow.net/q/311159</a>) where I described some tasks that I would like to see formalised for expository purposes, with extensive annotation.  I have carried out two of the tasks, and attempted to write useful annotations,  as shown on these pages:</p>
<p><a href="http://neil-strickland.staff.shef.ac.uk/dagstuhl/Systems/Lean_mathlib/Tasks/primes/" target="_blank" title="http://neil-strickland.staff.shef.ac.uk/dagstuhl/Systems/Lean_mathlib/Tasks/primes/">http://neil-strickland.staff.shef.ac.uk/dagstuhl/Systems/Lean_mathlib/Tasks/primes/</a> (infinitely many primes)<br>
<a href="http://neil-strickland.staff.shef.ac.uk/dagstuhl/Systems/Lean_mathlib/Tasks/nilpotents/" target="_blank" title="http://neil-strickland.staff.shef.ac.uk/dagstuhl/Systems/Lean_mathlib/Tasks/nilpotents/">http://neil-strickland.staff.shef.ac.uk/dagstuhl/Systems/Lean_mathlib/Tasks/nilpotents/</a> (the ideal of nilpotents)</p>
<p>These are part of a larger set of pages that are under construction.  I would be interested to hear comments.<br>
My annotations include a number of confessions of confusion or ignorance, and I would be happy for<br>
people to enlighten me.  There are doubtless other misunderstandings as well that I have not flagged.</p>
<p>Note that these formalisations are designed to optimise comprehensibility for users who know a lot<br>
of mathematics but are new to proof assistants; I am not aiming for efficiency, or for consistency <br>
with standard Lean style in cases where that conflicts with comprehensibility.</p>

<a name="135963881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dagstuhl%20tasks/near/135963881" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50979Dagstuhltasks.html#135963881">Johan Commelin (Oct 17 2018 at 10:48)</a>:</h4>
<p><span class="user-mention" data-user-id="130308">@Neil Strickland</span> Cool display mode! In the past there has been discussion here on Zulip on how  to generate html docs. This looks really nice. I suppose you could steel a syntax highlighter from somewhere (maybe VScode?) and use that as well.</p>

<a name="135964031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dagstuhl%20tasks/near/135964031" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50979Dagstuhltasks.html#135964031">Johan Commelin (Oct 17 2018 at 10:52)</a>:</h4>
<p>Also, if you don't care about Lean/mathlib style guides, I would suggest calling the type underlying your <code>comm_ring</code> just <code>R</code> instead of <code>α</code>.</p>

<a name="135964166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dagstuhl%20tasks/near/135964166" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50979Dagstuhltasks.html#135964166">Johan Commelin (Oct 17 2018 at 10:56)</a>:</h4>
<p>You write</p>
<blockquote>
<p>(There is no obvious way to supply an alternative name; Lean rejects <code>variable [R : comm_ring α]</code>, for reasons that are not clear to me.)</p>
</blockquote>
<p>That is very weird, because Scott is doing this all the time in his category libs. Do you get an actual error?<br>
Maybe you should write <code>include R</code> afterwards. That will include the instance in all your local contexts. Does that help?</p>

<a name="135964326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dagstuhl%20tasks/near/135964326" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50979Dagstuhltasks.html#135964326">Johan Commelin (Oct 17 2018 at 11:00)</a>:</h4>
<p>You also write</p>
<blockquote>
<p>The resulting heuristics are often effective, but it is also fairly common for the simplifier to apply rules in a way that is unhelpful. In those cases one can instead use the <code>rewrite</code> tactic (which can be abbreviated as <code>rw</code>) to give finer control over what rules are applied in what order. </p>
</blockquote>
<p>You might want to mention <code>simp only</code> and <code>simp [-rule]</code> that can be used to avoid bad simplification steps.</p>

<a name="135964342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dagstuhl%20tasks/near/135964342" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50979Dagstuhltasks.html#135964342">Johan Commelin (Oct 17 2018 at 11:01)</a>:</h4>
<p>By the way, I must say that I really like these files! You wrote really extensive comments. Thanks a lot!</p>

<a name="135964796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dagstuhl%20tasks/near/135964796" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50979Dagstuhltasks.html#135964796">Neil Strickland (Oct 17 2018 at 11:12)</a>:</h4>
<p>I hadn't noticed the <code>simp only</code> thing, thanks for pointing that out.  I will have a look and see whether that makes some steps easier.</p>

<a name="135964801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dagstuhl%20tasks/near/135964801" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50979Dagstuhltasks.html#135964801">Johan Commelin (Oct 17 2018 at 11:12)</a>:</h4>
<p><span class="user-mention" data-user-id="130308">@Neil Strickland</span> Do you just want us to spam all our feedback into this thread? Or how should we organise this?</p>

<a name="135964958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dagstuhl%20tasks/near/135964958" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50979Dagstuhltasks.html#135964958">Neil Strickland (Oct 17 2018 at 11:16)</a>:</h4>
<p>That's a good question.  I was thinking of putting the whole set of pages and associated code (including Coq and Isabelle stuff) on GitHub, but that will require some organisation, and I haven't really decided on the right structure.  So we should probably just use this thread for the time being.</p>

<a name="135964963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dagstuhl%20tasks/near/135964963" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50979Dagstuhltasks.html#135964963">Kevin Buzzard (Oct 17 2018 at 11:16)</a>:</h4>
<p>Yes I already have some comments about your nilpotent proof</p>

<a name="135964985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dagstuhl%20tasks/near/135964985" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50979Dagstuhltasks.html#135964985">Kevin Buzzard (Oct 17 2018 at 11:17)</a>:</h4>
<p>(although I am currently on a tram in Sheffield -- are you coming to lunch with me?)</p>

<a name="135965059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dagstuhl%20tasks/near/135965059" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50979Dagstuhltasks.html#135965059">Kevin Buzzard (Oct 17 2018 at 11:19)</a>:</h4>
<p>Lines 520-620 or so -- these are of no interest to mathematicians and you never need all these intermediate lemmas. You can prove what you want in a couple of lines but it's incomprehensible in some sense. Proving these fiddly things is hard for beginners</p>

<a name="135973624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dagstuhl%20tasks/near/135973624" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50979Dagstuhltasks.html#135973624">Floris van Doorn (Oct 17 2018 at 13:44)</a>:</h4>
<blockquote>
<p>The definition comes from the file mathlib/data/nat/basic.lean (but I do not know a completely automatic way to obtain that information).</p>
</blockquote>
<p>You can go to the location where the definition was defined either by ctrl+click, or by clicking on it, and then pressing F12. That will in particular give you the file in which it was defined.</p>

<a name="135974877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dagstuhl%20tasks/near/135974877" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50979Dagstuhltasks.html#135974877">Bryan Gin-ge Chen (Oct 17 2018 at 14:07)</a>:</h4>
<p>A few minor typos in the annotations to "primes": </p>
<ul>
<li>
<p>line 10, "The declaration of <code>min_fac_prime</code> has the shape:" the declaration that follows is missing <code>&lt;span class="code&gt;&lt;/span&gt;</code> around it.</p>
</li>
<li>
<p>line 13, "the implicit arguments 𝑝 and 𝑛 are deduced from the context." However, the code uses <code>@dvd_fact</code>.</p>
</li>
<li>
<p>line 15, "The syntax <code>(...).mpr</code> extracts the left-to-right half of this equivalence," should be "right-to-left".</p>
</li>
</ul>

<a name="135975155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dagstuhl%20tasks/near/135975155" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50979Dagstuhltasks.html#135975155">Bryan Gin-ge Chen (Oct 17 2018 at 14:13)</a>:</h4>
<p>Have you seen <a href="https://github.com/leanprover-community/mathlib/tree/tutorials/tutorials" target="_blank" title="https://github.com/leanprover-community/mathlib/tree/tutorials/tutorials">the work in the "tutorials" branch in leanprover-community</a>? The files <code>two_add_two.lean</code> and <code>partitions.lean</code> tackle tasks 1 and 5 from your MO post, respectively.</p>

<a name="135975455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dagstuhl%20tasks/near/135975455" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50979Dagstuhltasks.html#135975455">Floris van Doorn (Oct 17 2018 at 14:18)</a>:</h4>
<blockquote>
<p>Maybe you should write <code>include R</code> afterwards.</p>
</blockquote>
<p>This is correct. Lean doesn't automatically inserts variables, unless they are <strong>explicitly</strong> mentioned in the definition. For example, if I write</p>
<div class="codehilite"><pre><span></span>variables {α β : Type}
def my_id (a : α) : α := a
</pre></div>


<p>Then the definition <code>my_id</code> does <em>not</em> have <code>β</code> as an argument. If you want to explicitly add a variable/parameter <code>x</code> to all following definitions, you can write <code>include x</code> (and stop doing it with <code>omit x</code>). Because type-class variables are almost never <em>explicitly</em> mentioned, the (quite arbitrary) convention was added that if you don't give a type-class variable a name, it is automatically included if all variables in its type are included (so the variable <code>[comm_ring α]</code> is included when <code>α</code> is included).</p>

<a name="135983921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dagstuhl%20tasks/near/135983921" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50979Dagstuhltasks.html#135983921">Kevin Buzzard (Oct 17 2018 at 16:31)</a>:</h4>
<p>(deleted)</p>

<a name="135983922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dagstuhl%20tasks/near/135983922" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50979Dagstuhltasks.html#135983922">Kevin Buzzard (Oct 17 2018 at 16:31)</a>:</h4>
<p>PS <code>data.nat.binomial</code> was written by <span class="user-mention" data-user-id="110044">@Chris Hughes</span>  -- an Imperial maths undergraduate :-)</p>

<a name="135984404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dagstuhl%20tasks/near/135984404" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50979Dagstuhltasks.html#135984404">Neil Strickland (Oct 17 2018 at 16:38)</a>:</h4>
<p><span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span>  and <span class="user-mention" data-user-id="112680">@Johan Commelin</span> : are you happy for me to steal <code>two_add_two.lean</code> and <code>partitions.lean</code> and adapt them to the same framework that I have used for primes and nilpotents?</p>

<a name="135984428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dagstuhl%20tasks/near/135984428" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50979Dagstuhltasks.html#135984428">Johan Commelin (Oct 17 2018 at 16:39)</a>:</h4>
<p>I'm completely fine with that.</p>

<a name="135984549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dagstuhl%20tasks/near/135984549" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50979Dagstuhltasks.html#135984549">Kevin Buzzard (Oct 17 2018 at 16:40)</a>:</h4>
<p><span class="user-mention" data-user-id="130308">@Neil Strickland</span>  At line 528 you have <code>p := n + m + 1</code> and <code>Sn_gt_k : n + 1 &gt; k</code> and you want <code>m &lt; p - k</code>. Here's a relatively painless proof which avoids a bunch of intermediate steps.</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">nat</span><span class="bp">.</span><span class="n">basic</span>
<span class="c1">--lines 516-624</span>
<span class="kn">example</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="n">k</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">Sn_gt_k</span> <span class="o">:</span> <span class="n">k</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">):</span>
<span class="k">let</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span> <span class="k">in</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">p</span> <span class="bp">-</span> <span class="n">k</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">apply</span> <span class="n">nat</span><span class="bp">.</span><span class="n">lt_sub_right_of_add_lt</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">lt_of_lt_of_le</span> <span class="o">(</span><span class="n">add_lt_add_left</span> <span class="n">Sn_gt_k</span> <span class="n">m</span><span class="o">),</span>
  <span class="n">simp</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>

<a name="135984621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dagstuhl%20tasks/near/135984621" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50979Dagstuhltasks.html#135984621">Kevin Buzzard (Oct 17 2018 at 16:41)</a>:</h4>
<p>I think it's hard for learners to prove these things -- I have to a certain extent got a nose for which way to go now, but it wouldn't surprise me if Chris, Kenny or Mario could pull off a one-liner. However the real point should be that this is trivial to a mathematician so ideally should be done with a tactic. I tried <code>linarith</code> (as did you) and I couldn't get it to work. Should it work?</p>

<a name="135985306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dagstuhl%20tasks/near/135985306" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50979Dagstuhltasks.html#135985306">Bryan Gin-ge Chen (Oct 17 2018 at 16:54)</a>:</h4>
<p>I'm fine with that too.</p>

<a name="135986207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dagstuhl%20tasks/near/135986207" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50979Dagstuhltasks.html#135986207">Kevin Buzzard (Oct 17 2018 at 17:07)</a>:</h4>
<div class="codehilite"><pre><span></span> <span class="kn">lemma</span> <span class="n">npz_mul_right</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">xR</span> <span class="o">:</span> <span class="n">next_pow_zero</span> <span class="n">x</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">next_pow_zero</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">begin</span>
    <span class="n">rw</span> <span class="n">mul_comm</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">npz_mul_left</span> <span class="n">y</span> <span class="n">x</span> <span class="n">n</span> <span class="n">xR</span>
  <span class="kn">end</span>
</pre></div>

<a name="135986423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dagstuhl%20tasks/near/135986423" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50979Dagstuhltasks.html#135986423">Kevin Buzzard (Oct 17 2018 at 17:11)</a>:</h4>
<p>Computer scientists like writing their proofs backwards because then they don't get extra hypotheses cluttering up the context ("things that used to be the goal" are not remembered, whereas old hypotheses are)</p>

<a name="135986424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dagstuhl%20tasks/near/135986424" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50979Dagstuhltasks.html#135986424">Kevin Buzzard (Oct 17 2018 at 17:11)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="k">have</span> <span class="n">Z2</span> <span class="o">:</span> <span class="o">(</span><span class="n">n</span> <span class="bp">*</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span>
    <span class="k">by</span> <span class="n">simp</span><span class="o">[</span><span class="n">add_mul</span><span class="o">,</span><span class="n">mul_add</span><span class="o">,</span><span class="n">mul_one</span><span class="o">,</span><span class="n">one_mul</span><span class="o">,</span><span class="n">add_assoc</span><span class="o">],</span>
</pre></div>


<p>I would just put <code>by ring</code> because why not.</p>

<a name="135986431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dagstuhl%20tasks/near/135986431" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50979Dagstuhltasks.html#135986431">Johan Commelin (Oct 17 2018 at 17:11)</a>:</h4>
<p><span class="user-mention" data-user-id="130308">@Neil Strickland</span> In the post by Kevin (above this one) you can see that <code>x</code> and <code>n</code> can be determined from <code>xR</code>. So you can make them implicit, by wrapping them in <code>{}</code> instead of <code>()</code>.</p>

<a name="135987203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dagstuhl%20tasks/near/135987203" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50979Dagstuhltasks.html#135987203">Kevin Buzzard (Oct 17 2018 at 17:25)</a>:</h4>
<p>The reason it's not dealt with automatically by <code>simp</code> is I believe that Leo removed <code>add_mul</code> and <code>mul_add</code> from the list of simp rules because of some CS reasons.</p>

<a name="135987623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dagstuhl%20tasks/near/135987623" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50979Dagstuhltasks.html#135987623">Kevin Buzzard (Oct 17 2018 at 17:31)</a>:</h4>
<p>Do you ever use <code>nilpotent_mul_right</code>and <code>npz_mul_right</code> ?</p>

<a name="135992615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dagstuhl%20tasks/near/135992615" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50979Dagstuhltasks.html#135992615">Mario Carneiro (Oct 17 2018 at 18:44)</a>:</h4>
<blockquote>
<p>because of some CS reasons</p>
</blockquote>
<p>aka exponential blowup</p>

<a name="135992675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dagstuhl%20tasks/near/135992675" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50979Dagstuhltasks.html#135992675">Kevin Buzzard (Oct 17 2018 at 18:45)</a>:</h4>
<p>Like I said</p>

<a name="135992862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dagstuhl%20tasks/near/135992862" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50979Dagstuhltasks.html#135992862">Mario Carneiro (Oct 17 2018 at 18:49)</a>:</h4>
<blockquote>
<p>There are mechanisms that allow Lean to obtain a commutative ring structure automatically from a field structure where necessary, but the resulting commutative ring structure is anonymous. It has been found convenient to include the line</p>
<p><code>instance : comm_ring ℚ          := by apply_instance</code></p>
<p>in data/rat.lean, which allows us to use the notation rat.comm_ring to refer to the standard commutative ring structure on $\mathbb{Q}$. </p>
</blockquote>
<p>Actually this is just to make it faster for lean to discover that Q has a comm_ring instance. Not sure if you want to mention that though.</p>

<a name="135993054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dagstuhl%20tasks/near/135993054" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50979Dagstuhltasks.html#135993054">Mario Carneiro (Oct 17 2018 at 18:52)</a>:</h4>
<blockquote>
<p>There is no obvious way to supply an alternative name; Lean rejects variable [R : comm_ring α], for reasons that are not clear to me.</p>
</blockquote>
<p>Johan already mentioned this a bit, but unnamed instance variables are automatically included whenever the variable they reference is included, while a named variable is only included if it is used directly. So if you want to name an instance variable you have to put <code>include R</code> so it gets included even when it is not referenced.</p>

<a name="135993577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dagstuhl%20tasks/near/135993577" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50979Dagstuhltasks.html#135993577">Mario Carneiro (Oct 17 2018 at 19:01)</a>:</h4>
<blockquote>
<p>We are given a proof (denoted n_le_m) that $n\leq m$. We now apply the theorem nat.succ_le_succ to convert it to a proof that $n+1\leq m+1$. Note that the conclusion of nat.succ_le_succ is actually that succ n ≤ succ m, where succ is the successor function as in Peano arithmetic. One needs to unwind the definitions of $1$ and $+$ to see that n + 1 is the same as succ n. It is not clear to me under what circumstances this unwinding happens automatically, but it seems to work here. </p>
</blockquote>
<p>Unfolding of definitions like this happens, quite aggressively, when lean expects something of type T and you give it something of type T', and it tries to figure out why T and T' are the same (definitionally equal). Most tactics, on the other hand, are sensitive to the exact way you write an expression, so for example <code>rw</code> would not work on a term of type <code>next_pow_zero</code> even though it is an equality after some unfolding. You can also obtain the result of line 18 in a more automatic way by using <code>unfold next_pow_zero at xR</code>.</p>

<a name="135993697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dagstuhl%20tasks/near/135993697" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50979Dagstuhltasks.html#135993697">Mario Carneiro (Oct 17 2018 at 19:03)</a>:</h4>
<p>L19:</p>
<blockquote>
<p>Note that we have given the name Sn_le_Sm to our conclusion. The Lean documentation says that one can use the keyword have with no label, and use the keyword this to refer to the most recently proved statement. However, this does not seem to work here. I think that this is because we are in tactic mode, and anonymous have only works outside that mode. But the full story is not clear to me. </p>
</blockquote>
<p>Anonymous have should work here. You can put <code>have : n + 1 ≤ m + 1 := (succ_le_succ n_le_m),</code> on this line and use <code>this</code> instead of <code>Sn_le_Sm</code> in L21, and it should work. If not, let me know what error you get</p>

<a name="135998372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dagstuhl%20tasks/near/135998372" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50979Dagstuhltasks.html#135998372">Mario Carneiro (Oct 17 2018 at 20:24)</a>:</h4>
<p>Unless you specifically want to focus on nat subtraction and how annoying it is to work with for pedagogical reasons, I would suggest using <code>le.dest</code> to avoid it altogether. This also gives you a chance to use <code>rcases</code> which I think is worth calling out.</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">npz_shift</span>
  <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">xR</span> <span class="o">:</span> <span class="n">next_pow_zero</span> <span class="n">x</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">n_le_m</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">m</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">next_pow_zero</span> <span class="n">x</span> <span class="n">m</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">unfold</span> <span class="n">next_pow_zero</span> <span class="n">at</span> <span class="n">xR</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">succ_le_succ</span> <span class="n">n_le_m</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">k</span><span class="o">,</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">+</span> <span class="n">k</span> <span class="bp">=</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">le</span><span class="bp">.</span><span class="n">dest</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">this</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">k</span><span class="o">,</span> <span class="n">SnkSm</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="k">show</span> <span class="n">x</span><span class="err">^</span><span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="err">←</span> <span class="n">SnkSm</span><span class="o">,</span> <span class="bp">_</span><span class="n">root_</span><span class="bp">.</span><span class="n">pow_add</span><span class="o">,</span> <span class="n">xR</span><span class="o">,</span> <span class="n">zero_mul</span><span class="o">],</span>
<span class="kn">end</span>
</pre></div>

<a name="136000972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dagstuhl%20tasks/near/136000972" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50979Dagstuhltasks.html#136000972">Mario Carneiro (Oct 17 2018 at 21:08)</a>:</h4>
<p>Here's a proof of <code>npz_add</code> with a few comments of my own. I tried not to over-optimize it and keep it pedagogical:</p>
<div class="codehilite"><pre><span></span><span class="c1">-- The first few parameters are implicit because they follow from the types of xR and yR</span>
<span class="kn">lemma</span> <span class="n">npz_add</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span>
  <span class="o">(</span><span class="n">xR</span> <span class="o">:</span> <span class="n">next_pow_zero</span> <span class="n">x</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">yR</span> <span class="o">:</span> <span class="n">next_pow_zero</span> <span class="n">y</span> <span class="n">m</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">next_pow_zero</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">unfold</span> <span class="n">next_pow_zero</span> <span class="n">at</span> <span class="n">xR</span> <span class="n">yR</span> <span class="err">⊢</span><span class="o">,</span>
  <span class="c1">-- we want to unfold this definition everywhere so it doesn&#39;t get in the way</span>
  <span class="k">let</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">suffices</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">k</span> <span class="err">∈</span> <span class="o">(</span><span class="n">range</span> <span class="o">(</span><span class="n">succ</span> <span class="n">p</span><span class="o">))),</span>
    <span class="n">x</span> <span class="err">^</span> <span class="n">k</span> <span class="bp">*</span> <span class="n">y</span> <span class="err">^</span> <span class="o">(</span><span class="n">p</span> <span class="bp">-</span> <span class="n">k</span><span class="o">)</span> <span class="bp">*</span> <span class="err">↑</span><span class="o">(</span><span class="n">choose</span> <span class="n">p</span> <span class="n">k</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
  <span class="c1">-- Let us use suffices so that we know why we are proving this</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="k">calc</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span><span class="err">^</span><span class="n">p</span>
        <span class="bp">=</span> <span class="o">(</span><span class="n">range</span> <span class="o">(</span><span class="n">succ</span> <span class="n">p</span><span class="o">))</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">k</span><span class="o">,</span> <span class="n">x</span> <span class="err">^</span> <span class="n">k</span> <span class="bp">*</span> <span class="n">y</span> <span class="err">^</span> <span class="o">(</span><span class="n">p</span> <span class="bp">-</span> <span class="n">k</span><span class="o">)</span> <span class="bp">*</span> <span class="err">↑</span><span class="o">(</span><span class="n">choose</span> <span class="n">p</span> <span class="n">k</span><span class="o">))</span>
        <span class="o">:</span> <span class="n">add_pow</span> <span class="n">x</span> <span class="n">y</span> <span class="n">p</span> <span class="c1">-- use binomial theorem</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">range</span> <span class="o">(</span><span class="n">succ</span> <span class="n">p</span><span class="o">))</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">k</span><span class="o">,</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">α</span><span class="o">))</span>
        <span class="o">:</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum_congr</span> <span class="n">rfl</span> <span class="n">this</span> <span class="c1">-- use the assumption</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">sum_const_zero</span> <span class="o">},</span>
  <span class="c1">-- note for Neil: use {} instead of begin end to make it clearer that syntax</span>
  <span class="c1">-- in tactic mode is different than term mode.</span>
  <span class="c1">-- Similarly &#39;by&#39; is unnecessary in tactic mode</span>
  <span class="n">intros</span> <span class="n">k</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">k_lt_Sp</span> <span class="o">:</span> <span class="n">k</span> <span class="bp">&lt;</span> <span class="n">p</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">mem_range</span><span class="bp">.</span><span class="n">mp</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">k_le_p</span> <span class="o">:</span> <span class="n">k</span> <span class="bp">≤</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">le_of_lt_succ</span> <span class="n">k_lt_Sp</span><span class="o">,</span>
  <span class="c1">-- note the name of the theorem is derivable from the statement (very important!)</span>
  <span class="n">rcases</span> <span class="n">le_or_gt</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">k</span> <span class="k">with</span> <span class="n">Sn_le_k</span> <span class="bp">|</span> <span class="n">Sn_gt_k</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rcases</span> <span class="n">le</span><span class="bp">.</span><span class="n">dest</span> <span class="n">Sn_le_k</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">j</span><span class="o">,</span> <span class="n">Z0</span><span class="bp">⟩</span><span class="o">,</span> <span class="c1">-- note Z0 : (n + 1) + j = k</span>
    <span class="k">have</span> <span class="n">Z1</span> <span class="o">:</span> <span class="n">x</span> <span class="err">^</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">xR</span><span class="o">,</span>
    <span class="c1">-- Note at this point that theorem Z2 is actually a special case</span>
    <span class="c1">-- of npz_shift, so maybe we should go back and generalize it? Exercise for the reader</span>
    <span class="k">have</span> <span class="n">Z2</span> <span class="o">:</span> <span class="n">x</span> <span class="err">^</span> <span class="n">k</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="err">←</span> <span class="n">Z0</span><span class="o">,</span> <span class="c1">-- x ^ (n + 1 + j) = 0</span>
        <span class="bp">_</span><span class="n">root_</span><span class="bp">.</span><span class="n">pow_add</span><span class="o">,</span> <span class="c1">-- x ^ (n + 1) * x ^ j = 0</span>
        <span class="n">Z1</span><span class="o">,</span> <span class="c1">-- 0 * x ^ j = 0</span>
        <span class="n">zero_mul</span><span class="o">]</span> <span class="o">},</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">Z2</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="k">have</span> <span class="n">k_le_n</span> <span class="o">:</span> <span class="n">k</span> <span class="bp">≤</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">lt_succ_iff</span><span class="bp">.</span><span class="n">mp</span> <span class="n">Sn_gt_k</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">le</span><span class="bp">.</span><span class="n">dest</span> <span class="n">k_le_n</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">j</span><span class="o">,</span> <span class="n">Z0</span><span class="bp">⟩</span><span class="o">,</span> <span class="c1">-- Z0 : k + j = n</span>
    <span class="k">have</span> <span class="n">Z4</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">-</span> <span class="n">k</span> <span class="bp">=</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">+</span> <span class="n">j</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">apply</span> <span class="n">nat</span><span class="bp">.</span><span class="n">sub_eq_of_eq_add</span><span class="o">,</span>
      <span class="c1">-- get rid of the subtraction because nat subtraction sucks</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">p</span><span class="o">,</span> <span class="n">Z0</span><span class="bp">.</span><span class="n">symm</span><span class="o">]</span> <span class="o">},</span>
      <span class="c1">-- After unfolding p and using Z0.symm : n = k + j, the goal is</span>
      <span class="c1">-- (k + j) + m + 1 = k + (m + 1 + j) which simp can handle</span>
      <span class="c1">-- (just associativity and commutativity of addition)</span>
    <span class="k">have</span> <span class="n">Z6</span> <span class="o">:</span> <span class="n">y</span> <span class="err">^</span> <span class="o">(</span><span class="n">p</span> <span class="bp">-</span> <span class="n">k</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">Z4</span><span class="o">,</span> <span class="bp">_</span><span class="n">root_</span><span class="bp">.</span><span class="n">pow_add</span><span class="o">,</span> <span class="n">yR</span><span class="o">,</span> <span class="n">zero_mul</span><span class="o">]</span> <span class="o">},</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">Z6</span><span class="o">]</span> <span class="o">}</span>
<span class="kn">end</span>
</pre></div>

<a name="136009280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dagstuhl%20tasks/near/136009280" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50979Dagstuhltasks.html#136009280">Alex J. Best (Oct 17 2018 at 23:59)</a>:</h4>
<p>Hi <span class="user-mention" data-user-id="130308">@Neil Strickland</span>  the viewer is really cool! The tex doesn't load for me though but if I add <code>MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
</code> to viewer.js line 102 above  <code>this.show_comment(0);</code> it does.</p>

<a name="136015026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dagstuhl%20tasks/near/136015026" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50979Dagstuhltasks.html#136015026">Neil Strickland (Oct 18 2018 at 02:08)</a>:</h4>
<p>Thanks to everyone for your feedback.  I am working on incorporating it and also improving my infrastructure in various ways; I will report back in a day or two.</p>

<a name="136016513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dagstuhl%20tasks/near/136016513" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50979Dagstuhltasks.html#136016513">Scott Morrison (Oct 18 2018 at 02:47)</a>:</h4>
<p>I'd love to see your infrastructure turn into <code>leandoc</code>. :-)</p>

<a name="136016580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dagstuhl%20tasks/near/136016580" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50979Dagstuhltasks.html#136016580">Scott Morrison (Oct 18 2018 at 02:49)</a>:</h4>
<p>Can I suggest that you don't embed html in the source code, but use markdown instead? I don't think we're ever going to want to include html in source files, but markdown ($ ... $ for math is of course fine) is great.</p>

<a name="136026586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dagstuhl%20tasks/near/136026586" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50979Dagstuhltasks.html#136026586">David Michael Roberts (Oct 18 2018 at 07:56)</a>:</h4>
<p><span class="user-mention" data-user-id="130308">@Neil Strickland</span> I am using the latest version of Chrome (69.0.3497.100 (Official Build) (64-bit)) on OS X 10.10.5 and I see this: <a href="/user_uploads/3121/Cb0AG3O7WFQGsv-jamxweKyi/Screen-Shot-2018-10-18-at-6.25.03-pm.png" target="_blank" title="Screen-Shot-2018-10-18-at-6.25.03-pm.png">Code from "There are infinitely many primes"</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/Cb0AG3O7WFQGsv-jamxweKyi/Screen-Shot-2018-10-18-at-6.25.03-pm.png" target="_blank" title="Code from &quot;There are infinitely many primes&quot;"><img src="/user_uploads/3121/Cb0AG3O7WFQGsv-jamxweKyi/Screen-Shot-2018-10-18-at-6.25.03-pm.png"></a></div>

<a name="136053537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dagstuhl%20tasks/near/136053537" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50979Dagstuhltasks.html#136053537">Bryan Gin-ge Chen (Oct 18 2018 at 16:15)</a>:</h4>
<p>Line 145 in <code>nilpotents</code>:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">is_reduced</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
</pre></div>


<blockquote>
<p>I am not completely clear about the mechanism for handling implicit and explicit arguments here. At the beginning of this file we opened a section and had the declaration <code>variable {α : Type u}</code>. [...] It seems that the declaration here overrides the default behaviour and converts <code>𝛼</code> to an explicit argument. The ring structure on <code>𝛼</code> remains an implicit argument handled by typeclass inference, however. </p>
</blockquote>
<p>It's my understanding that when you explicitly include in a <code>def</code> some variable <code>𝛼</code> with the same name as one in an earlier <code>variable</code> declaration, lean locally creates a new variable which is unrelated to the other <code>𝛼</code>; in particular, previous typeclass assignments won't apply to the new <code>𝛼</code>, and that's why you had to put in <code>[comm_ring 𝛼]</code> here again. </p>
<p>To convert an existing variable from implicit to explicit, write <code>variable (𝛼)</code> on the line before this definition. Then when you want to let <code>𝛼</code> be implicit again (presumably after 158), you can write <code>variable {𝛼}</code>.</p>

<a name="136055004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dagstuhl%20tasks/near/136055004" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50979Dagstuhltasks.html#136055004">Bryan Gin-ge Chen (Oct 18 2018 at 16:34)</a>:</h4>
<p>Typo in the comments to line 153-154 in <code>nilpotents</code>: there's a missing space in "<code>init/data/setoid.lean</code>in".</p>
<p>Including the types explicitly in lines 153 and 159 would make things more readable to me: <code> def reduced_quotient (α : Type*) [comm_ring α] : Type* :=</code> and <code>instance reduced_quotient_mk_is_ring_hom : is_ring_hom quotient_ring.mk :=</code>.</p>
<p>I'm not sure what "further problems related to implicit arguments" occurred that required you to write lines 168-178 but if you say more perhaps we can figure it out.</p>


{% endraw %}

{% include archive_update.html %}