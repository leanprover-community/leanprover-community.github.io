---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/93009Reusingfinsetprodfactsforlists.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/93009Reusingfinsetprodfactsforlists.html">Reusing `finset.prod` facts for lists</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="183934979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reusing%20%60finset.prod%60%20facts%20for%20lists/near/183934979" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/93009Reusingfinsetprodfactsforlists.html#183934979">Yury G. Kudryashov (Dec 20 2019 at 13:26)</a>:</h4>
<p>Hi, is there any good way to reuse facts about <code>finset.prod</code> for lists? E.g., I'd like to have something like <code>∀ l : list α, (fin_range (length l)).prod (λ i, l.nth_le i.1 i.2) = l.prod</code>.</p>

<a name="183935029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reusing%20%60finset.prod%60%20facts%20for%20lists/near/183935029" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/93009Reusingfinsetprodfactsforlists.html#183935029">Yury G. Kudryashov (Dec 20 2019 at 13:27)</a>:</h4>
<p>My problem is that it's not easy to apply general facts about products/sums over <code>finset</code>s (e.g., AM-GM inequality) to get a similar inequality for products/sums over lists.</p>

<a name="183935119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reusing%20%60finset.prod%60%20facts%20for%20lists/near/183935119" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/93009Reusingfinsetprodfactsforlists.html#183935119">Yury G. Kudryashov (Dec 20 2019 at 13:28)</a>:</h4>
<p>With lists it's much easier to apply it to specific numbers (e.g., to deduce AM-GM for 2, 3, 4 numbers out of the general case).</p>

<a name="183944815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reusing%20%60finset.prod%60%20facts%20for%20lists/near/183944815" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/93009Reusingfinsetprodfactsforlists.html#183944815">Mario Carneiro (Dec 20 2019 at 15:25)</a>:</h4>
<p>I guess that theorem is possible (assuming the multiplication is commutative and associative), but the LHS looks pretty hard to work with</p>

<a name="183944884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reusing%20%60finset.prod%60%20facts%20for%20lists/near/183944884" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/93009Reusingfinsetprodfactsforlists.html#183944884">Mario Carneiro (Dec 20 2019 at 15:26)</a>:</h4>
<p>You can always coerce a list to a finset and apply the prod operation there</p>

<a name="183948835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reusing%20%60finset.prod%60%20facts%20for%20lists/near/183948835" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/93009Reusingfinsetprodfactsforlists.html#183948835">Yury G. Kudryashov (Dec 20 2019 at 16:08)</a>:</h4>
<p>Does coercion remove duplicates?</p>

<a name="183948915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reusing%20%60finset.prod%60%20facts%20for%20lists/near/183948915" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/93009Reusingfinsetprodfactsforlists.html#183948915">Johan Commelin (Dec 20 2019 at 16:09)</a>:</h4>
<p>I guess it does.</p>

<a name="183951638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reusing%20%60finset.prod%60%20facts%20for%20lists/near/183951638" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/93009Reusingfinsetprodfactsforlists.html#183951638">Kevin Buzzard (Dec 20 2019 at 16:42)</a>:</h4>
<p>You could coerce to a multiset and apply the prod operation there.</p>

<a name="183954911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reusing%20%60finset.prod%60%20facts%20for%20lists/near/183954911" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/93009Reusingfinsetprodfactsforlists.html#183954911">Chris Hughes (Dec 20 2019 at 17:20)</a>:</h4>
<p>For every <code>list A</code> there's a function <code>fin n - &gt; A</code>, so you can <code>finset.sum univ</code> over this function.</p>

<a name="183956353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reusing%20%60finset.prod%60%20facts%20for%20lists/near/183956353" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/93009Reusingfinsetprodfactsforlists.html#183956353">Kevin Buzzard (Dec 20 2019 at 17:39)</a>:</h4>
<p>...and that's the reason why nobody bothers to build any more infrastructure for sums over lists and multisets ;-)</p>

<a name="183963235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reusing%20%60finset.prod%60%20facts%20for%20lists/near/183963235" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/93009Reusingfinsetprodfactsforlists.html#183963235">Chris Hughes (Dec 20 2019 at 19:06)</a>:</h4>
<p>That's true for multisets. You still need lists for non commutative products.</p>

<a name="183985762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reusing%20%60finset.prod%60%20facts%20for%20lists/near/183985762" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/93009Reusingfinsetprodfactsforlists.html#183985762">Yury G. Kudryashov (Dec 21 2019 at 00:06)</a>:</h4>
<p><span class="user-mention" data-user-id="110044">@Chris Hughes</span> I wrote one such function above. However I'd like to have a theorem like <code>∀ l : list α, (fin_range (length l)).prod (λ i, l.nth_le i.1 i.2) = l.prod</code> or <code>∀ (l : list α) (f : α → β), (fin_range (length l)).prod (λ i, f(l.nth_le) i.1 i.2) = (l.map f).prod</code> to be able to transfer facts from sums/prods over a finset to sums/prods of <code>list.map</code>.</p>

<a name="183986178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reusing%20%60finset.prod%60%20facts%20for%20lists/near/183986178" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/93009Reusingfinsetprodfactsforlists.html#183986178">Yury G. Kudryashov (Dec 21 2019 at 00:15)</a>:</h4>
<p>Another way to deduce <code>∀ a b c wa wb wc : nnreal, wa + wb + wc = 1 → a^wa * b^wb * c^wc ≤ wa * a + wb * b + wc * c</code> from <code>∀ {α : Type*} (s : finset α) (w z : α → ℝ≥0) (hw' : s.sum w = 1) : (s.prod (λ i, (z i) ^ (w i))) ≤ s.sum (λ i, w i * z i)</code> is welcome. Here I assume <code>has_pow nnreal nnreal := ⟨λ x r, nnreal.of_real (x:ℝ)^(r:ℝ)⟩</code>.</p>

<a name="183988075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reusing%20%60finset.prod%60%20facts%20for%20lists/near/183988075" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/93009Reusingfinsetprodfactsforlists.html#183988075">Yury G. Kudryashov (Dec 21 2019 at 00:59)</a>:</h4>
<p>With lists I can do this:</p>
<div class="codehilite"><pre><span></span><span class="n">noncomputable</span> <span class="kn">instance</span> <span class="n">nnreal</span><span class="bp">.</span><span class="n">has_pow_nnreal</span> <span class="o">:</span> <span class="n">has_pow</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="n">p</span> <span class="n">r</span><span class="o">,</span> <span class="n">nnreal</span><span class="bp">.</span><span class="n">of_real</span> <span class="err">$</span> <span class="o">(</span><span class="n">p</span><span class="o">:</span><span class="n">ℝ</span><span class="o">)</span><span class="err">^</span><span class="o">(</span><span class="n">r</span><span class="o">:</span><span class="n">ℝ</span><span class="o">)</span><span class="bp">⟩</span>

<span class="kn">theorem</span> <span class="n">list</span><span class="bp">.</span><span class="n">am_gm_weighted</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span> <span class="bp">×</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="o">))</span> <span class="o">(</span><span class="n">hw</span> <span class="o">:</span> <span class="o">(</span><span class="n">l</span><span class="bp">.</span><span class="n">map</span> <span class="n">prod</span><span class="bp">.</span><span class="n">fst</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">l</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">i</span><span class="bp">.</span><span class="n">snd</span><span class="o">)</span> <span class="err">^</span> <span class="o">(</span><span class="n">i</span><span class="bp">.</span><span class="n">fst</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span> <span class="bp">×</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="o">))</span><span class="bp">.</span><span class="n">prod</span> <span class="bp">≤</span>
    <span class="o">(</span><span class="n">l</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span><span class="bp">.</span><span class="n">fst</span> <span class="bp">*</span> <span class="n">i</span><span class="bp">.</span><span class="n">snd</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span> <span class="bp">×</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="o">))</span><span class="bp">.</span><span class="n">sum</span> <span class="o">:=</span>
<span class="n">sorry</span>

<span class="kn">theorem</span> <span class="n">am_gm3</span> <span class="o">(</span><span class="n">w₁</span> <span class="n">w₂</span> <span class="n">w₃</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">hw</span> <span class="o">:</span> <span class="n">w₁</span> <span class="bp">+</span> <span class="n">w₂</span> <span class="bp">+</span> <span class="n">w₃</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">x₁</span> <span class="n">x₂</span> <span class="n">x₃</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x₁</span> <span class="err">^</span> <span class="n">w₁</span> <span class="bp">*</span> <span class="n">x₂</span> <span class="err">^</span> <span class="n">w₂</span> <span class="bp">*</span> <span class="n">x₃</span> <span class="err">^</span> <span class="n">w₃</span> <span class="bp">≤</span> <span class="n">w₁</span> <span class="bp">*</span> <span class="n">x₁</span> <span class="bp">+</span> <span class="n">w₂</span> <span class="bp">*</span> <span class="n">x₂</span> <span class="bp">+</span> <span class="n">w₃</span> <span class="bp">*</span> <span class="n">x₃</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">mul_assoc</span><span class="o">]</span> <span class="kn">using</span> <span class="n">list</span><span class="bp">.</span><span class="n">am_gm_weighted</span> <span class="o">[(</span><span class="n">w₁</span><span class="o">,</span> <span class="n">x₁</span><span class="o">),</span> <span class="o">(</span><span class="n">w₂</span><span class="o">,</span> <span class="n">x₂</span><span class="o">),</span> <span class="o">(</span><span class="n">w₃</span><span class="o">,</span> <span class="n">x₃</span><span class="o">)]</span> <span class="o">(</span><span class="k">by</span> <span class="n">simpa</span> <span class="kn">using</span> <span class="n">hw</span><span class="o">)</span>
</pre></div>


<p>However I can't quickly deduce <code>am_gm3</code> from</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">finset</span><span class="bp">.</span><span class="n">am_gm_weighted</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">w</span> <span class="n">z</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hw</span> <span class="o">:</span> <span class="n">s</span><span class="bp">.</span><span class="n">sum</span> <span class="n">w</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">s</span><span class="bp">.</span><span class="n">prod</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">z</span> <span class="n">i</span><span class="o">)</span> <span class="err">^</span> <span class="o">(</span><span class="n">w</span> <span class="n">i</span><span class="o">))</span> <span class="bp">≤</span> <span class="n">s</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">w</span> <span class="n">i</span> <span class="bp">*</span> <span class="n">z</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span>
</pre></div>


{% endraw %}

{% include archive_update.html %}