---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/67367InfinityHotel.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html">Infinity Hotel</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="176112619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176112619" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176112619">Reid Barton (Sep 19 2019 at 15:46)</a>:</h4>
<p><a href="https://competition.isabelle.systems/competitions/contest/13/tasks/2/" target="_blank" title="https://competition.isabelle.systems/competitions/contest/13/tasks/2/">This</a> Proof Ground problem is actually almost exactly a lemma I want. Would somebody (<span class="user-mention" data-user-id="111080">@Floris van Doorn</span>?) like to PR a solution to mathlib?<br>
Maybe as a mathlib lemma, it is more natural to use <code>equiv</code> in place of <code>bijective</code>, and replace the target <code>nat</code> by <code>denumerable</code></p>

<a name="176113991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176113991" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176113991">Mario Carneiro (Sep 19 2019 at 15:58)</a>:</h4>
<p>I discussed this with floris after the competition. I think it generalizes to embedding B &lt; A when A is an infinite cardinal</p>

<a name="176115715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176115715" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176115715">Kevin Buzzard (Sep 19 2019 at 16:17)</a>:</h4>
<p>Assuming AC, a+b=max(a,b) so A-B bijects with A-f(B)</p>

<a name="176127061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176127061" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176127061">Floris van Doorn (Sep 19 2019 at 18:19)</a>:</h4>
<p>Yes, I'm going to PR this to mathlib. The current statement I am proving is</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">extend_function_of_lt</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">s</span> <span class="err">↪</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="bp">#</span><span class="n">s</span> <span class="bp">&lt;</span> <span class="bp">#</span><span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="o">(</span><span class="n">α</span> <span class="err">≃</span> <span class="n">β</span><span class="o">))</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">α</span> <span class="err">≃</span> <span class="n">β</span><span class="o">),</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">s</span><span class="o">,</span> <span class="n">g</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span>
</pre></div>

<a name="176127152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176127152" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176127152">Floris van Doorn (Sep 19 2019 at 18:20)</a>:</h4>
<p>Here <code>#</code> means <code>cardinal.mk</code></p>

<a name="176127813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176127813" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176127813">Floris van Doorn (Sep 19 2019 at 18:26)</a>:</h4>
<p>I have already proved this in the case where <code>#α</code> is infinite.</p>
<p><del>Now that I think of this, when <code>α</code> is infinite, I should probably replace the assumption <code>#s &lt; #α</code> with the weaker condition <code>#(-s : set α) = #α</code> (I already proved the lemma that the former implies the latter).</del><br>
EDIT: Oh wait, then it's false.</p>

<a name="176164017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176164017" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176164017">Mario Carneiro (Sep 20 2019 at 04:20)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> Could you elaborate on that proof? a+b=a does not imply a-b=a for cardinals</p>

<a name="176170582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176170582" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176170582">Kevin Buzzard (Sep 20 2019 at 07:21)</a>:</h4>
<p>I was imagining the generalisation being this: if B&lt;A is a subset, and |B|&lt;|A|, then any injection f:B -&gt; A can be extended to a bijection A -&gt; A. The proof is: write C=A\B and D=A\f(B) and observe that |C|=|A|=|D|. Did I slip up?</p>

<a name="176171411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176171411" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176171411">Mario Carneiro (Sep 20 2019 at 07:39)</a>:</h4>
<p>Those facts are all true but I'm not sure how you are arguing them</p>

<a name="176171464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176171464" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176171464">Mario Carneiro (Sep 20 2019 at 07:40)</a>:</h4>
<p>actually you forgot to assume A is infinite, else |C|=|A| fails</p>

<a name="176171515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176171515" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176171515">Chris Hughes (Sep 20 2019 at 07:41)</a>:</h4>
<p>I proved something similar as part of algebraic closure.</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">set_theory</span><span class="bp">.</span><span class="n">schroeder_bernstein</span>

<span class="kn">open</span> <span class="n">set</span> <span class="n">function</span>
<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span>
<span class="n">noncomputable</span> <span class="n">theory</span>
<span class="n">local</span> <span class="n">attribute</span> <span class="o">[</span><span class="kn">instance</span><span class="o">]</span> <span class="n">classical</span><span class="bp">.</span><span class="n">dec</span>

<span class="kn">lemma</span> <span class="n">thing_aux</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">Z</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">}</span> <span class="o">(</span><span class="n">fxy</span> <span class="o">:</span> <span class="n">X</span> <span class="err">↪</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">fxz</span> <span class="o">:</span> <span class="n">X</span> <span class="err">↪</span> <span class="n">Z</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hYZ</span> <span class="o">:</span> <span class="o">(</span><span class="n">Z</span> <span class="err">↪</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">→</span> <span class="n">false</span><span class="o">)</span> <span class="o">:</span> <span class="err">↥</span><span class="bp">-</span><span class="n">range</span> <span class="n">fxy</span><span class="bp">.</span><span class="mi">1</span> <span class="err">↪</span> <span class="err">↥</span><span class="bp">-</span><span class="n">range</span> <span class="n">fxz</span><span class="bp">.</span><span class="mi">1</span> <span class="o">:=</span>
<span class="n">classical</span><span class="bp">.</span><span class="n">choice</span> <span class="err">$</span> <span class="n">or</span><span class="bp">.</span><span class="n">resolve_left</span> <span class="n">embedding</span><span class="bp">.</span><span class="n">total</span> <span class="err">$</span>
  <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">f</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">hYZ</span> <span class="err">$</span>
    <span class="k">calc</span> <span class="n">Z</span> <span class="err">↪</span> <span class="n">range</span> <span class="n">fxz</span> <span class="err">⊕</span> <span class="err">↥</span><span class="bp">-</span><span class="n">range</span> <span class="n">fxz</span> <span class="o">:</span>
      <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">sum_compl</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="bp">.</span><span class="n">to_embedding</span>
    <span class="bp">...</span> <span class="err">↪</span> <span class="n">range</span> <span class="n">fxy</span> <span class="err">⊕</span> <span class="err">↥</span><span class="bp">-</span><span class="n">range</span> <span class="n">fxy</span> <span class="o">:</span>
      <span class="n">embedding</span><span class="bp">.</span><span class="n">sum_congr</span>
        <span class="o">(((</span><span class="n">equiv</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="bp">_</span> <span class="n">fxz</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="bp">.</span><span class="n">to_embedding</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span>
          <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="bp">_</span> <span class="n">fxy</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span><span class="bp">.</span><span class="n">to_embedding</span><span class="o">)</span>
        <span class="n">f</span>
    <span class="bp">...</span> <span class="err">↪</span> <span class="n">Y</span> <span class="o">:</span> <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">sum_compl</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="n">to_embedding</span>

<span class="n">def</span> <span class="n">thing</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">Z</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">}</span> <span class="o">(</span><span class="n">fxy</span> <span class="o">:</span> <span class="n">X</span> <span class="err">↪</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">fxz</span> <span class="o">:</span> <span class="n">X</span> <span class="err">↪</span> <span class="n">Z</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hYZ</span> <span class="o">:</span> <span class="o">(</span><span class="n">Z</span> <span class="err">↪</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">→</span> <span class="n">false</span><span class="o">)</span> <span class="o">:</span> <span class="n">Y</span> <span class="err">↪</span> <span class="n">Z</span> <span class="o">:=</span>
<span class="k">calc</span> <span class="n">Y</span> <span class="err">↪</span> <span class="n">range</span> <span class="n">fxy</span> <span class="err">⊕</span> <span class="err">↥</span><span class="bp">-</span><span class="n">range</span> <span class="n">fxy</span> <span class="o">:</span> <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">sum_compl</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="bp">.</span><span class="n">to_embedding</span>
<span class="bp">...</span> <span class="err">↪</span> <span class="n">range</span> <span class="n">fxz</span> <span class="err">⊕</span> <span class="err">↥</span><span class="bp">-</span><span class="n">range</span> <span class="n">fxz</span> <span class="o">:</span> <span class="n">embedding</span><span class="bp">.</span><span class="n">sum_congr</span>
  <span class="o">((</span><span class="n">equiv</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="bp">_</span> <span class="n">fxy</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="bp">.</span><span class="n">to_embedding</span><span class="bp">.</span><span class="n">trans</span>
    <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="bp">_</span> <span class="n">fxz</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span><span class="bp">.</span><span class="n">to_embedding</span><span class="o">)</span>
  <span class="o">(</span><span class="n">thing_aux</span> <span class="n">fxy</span> <span class="n">fxz</span> <span class="n">hYZ</span><span class="o">)</span>
<span class="bp">...</span> <span class="err">↪</span> <span class="n">Z</span> <span class="o">:</span> <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">sum_compl</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="n">to_embedding</span>

<span class="kn">lemma</span> <span class="n">thing_commutes</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">Z</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">}</span>  <span class="o">(</span><span class="n">fxy</span> <span class="o">:</span> <span class="n">X</span> <span class="err">↪</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">fxz</span> <span class="o">:</span> <span class="n">X</span> <span class="err">↪</span> <span class="n">Z</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hYZ</span> <span class="o">:</span> <span class="o">(</span><span class="n">Z</span> <span class="err">↪</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">→</span> <span class="n">false</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">thing</span> <span class="n">fxy</span> <span class="n">fxz</span> <span class="n">hYZ</span> <span class="o">(</span><span class="n">fxy</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">fxz</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">have</span> <span class="o">(</span><span class="bp">⟨</span><span class="n">fxy</span> <span class="n">x</span><span class="o">,</span> <span class="n">mem_range_self</span> <span class="bp">_⟩</span> <span class="o">:</span> <span class="n">range</span> <span class="n">fxy</span><span class="o">)</span> <span class="bp">=</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="bp">_</span> <span class="n">fxy</span><span class="bp">.</span><span class="mi">2</span> <span class="n">x</span><span class="o">,</span> <span class="k">from</span> <span class="n">rfl</span><span class="o">,</span>
<span class="k">begin</span>
  <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">thing</span><span class="o">,</span> <span class="n">embedding</span><span class="bp">.</span><span class="n">trans_apply</span><span class="o">,</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">trans_apply</span><span class="o">,</span> <span class="n">function</span><span class="bp">.</span><span class="n">comp</span><span class="o">,</span>
    <span class="n">equiv</span><span class="bp">.</span><span class="n">to_embedding_coe_fn</span><span class="o">],</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">equiv</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">sum_compl_symm_apply_of_mem</span> <span class="o">(</span><span class="n">mem_range_self</span> <span class="bp">_</span><span class="o">),</span>
    <span class="n">embedding</span><span class="bp">.</span><span class="n">sum_congr_apply_inl</span><span class="o">,</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">sum_compl_apply_inl</span><span class="o">,</span>
    <span class="n">embedding</span><span class="bp">.</span><span class="n">trans_apply</span><span class="o">,</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">to_embedding_coe_fn</span><span class="o">,</span> <span class="n">this</span><span class="o">,</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">symm_apply_apply</span><span class="o">],</span>
  <span class="n">refl</span>
<span class="kn">end</span>
</pre></div>

<a name="176171600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176171600" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176171600">Chris Hughes (Sep 20 2019 at 07:43)</a>:</h4>
<p>Somehow the assumption <code>(Z ↪ Y) → false</code> should be turned into <code>(Z ↪ X) → false</code></p>

<a name="176171613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176171613" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176171613">Mario Carneiro (Sep 20 2019 at 07:43)</a>:</h4>
<p>isn't that just transitivity?</p>

<a name="176171779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176171779" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176171779">Mario Carneiro (Sep 20 2019 at 07:46)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> I think your proof sketch is basically what floris did in the competition</p>

<a name="176171805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176171805" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176171805">Mario Carneiro (Sep 20 2019 at 07:47)</a>:</h4>
<p>it would be nice to reduce it to a one liner of mathlib lemmas though</p>

<a name="176172005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176172005" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176172005">Mario Carneiro (Sep 20 2019 at 07:50)</a>:</h4>
<p>Unfortunately I don't see how to apply chris's lemma directly here</p>

<a name="176172043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176172043" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176172043">Mario Carneiro (Sep 20 2019 at 07:51)</a>:</h4>
<p>it only seems to construct an injection from Y to Z where |Y|&lt;|Z|, and the only obvious candidates are Y=B and Z=A, or Y=f(B) and Z=A, and neither is particularly helpful</p>

<a name="176172190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176172190" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176172190">Mario Carneiro (Sep 20 2019 at 07:54)</a>:</h4>
<p>In this situation, we want Y=Z=A, but then <code>(Z ↪ Y) → false</code> fails</p>

<a name="176172323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176172323" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176172323">Chris Hughes (Sep 20 2019 at 07:56)</a>:</h4>
<p>But in the infinite case can we weaken the assumption to <code>(Z ↪ X) → false</code>?</p>

<a name="176172337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176172337" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176172337">Kevin Buzzard (Sep 20 2019 at 07:57)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  I don't understand why you're calling it a sketch ;-)</p>

<a name="176172345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176172345" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176172345">Mario Carneiro (Sep 20 2019 at 07:57)</a>:</h4>
<p>you have to reference actual theorems, and also prove the side conditions</p>

<a name="176172396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176172396" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176172396">Mario Carneiro (Sep 20 2019 at 07:58)</a>:</h4>
<p>ideally the formal proof should actually be that short, but the side conditions are messy here</p>

<a name="176172398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176172398" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176172398">Kevin Buzzard (Sep 20 2019 at 07:58)</a>:</h4>
<p>The argument would convince any mathematician. That's the level where we operate. What we really need is an interface where I can just say what I said to you and then let tactics do the rest.</p>

<a name="176172418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176172418" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176172418">Kevin Buzzard (Sep 20 2019 at 07:59)</a>:</h4>
<p>we can try <code>cases, refl</code> on the side conditions or whatever. It's all noise.</p>

<a name="176172422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176172422" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176172422">Mario Carneiro (Sep 20 2019 at 07:59)</a>:</h4>
<p>you also didn't prove what you claimed to... there are lots of issues with treating that literally as a proof</p>

<a name="176172457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176172457" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176172457">Kevin Buzzard (Sep 20 2019 at 08:00)</a>:</h4>
<p>Can you give me specific examples of issues? I'd be happy to talk about this but I have to run</p>

<a name="176172507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176172507" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176172507">Kevin Buzzard (Sep 20 2019 at 08:00)</a>:</h4>
<p>I think my proof is "math-complete"</p>

<a name="176172517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176172517" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176172517">Mario Carneiro (Sep 20 2019 at 08:00)</a>:</h4>
<p>it's absolutely a sketch, but it's enough hints for a competent mathematician to fill in the rest of the proof</p>

<a name="176172545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176172545" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176172545">Mario Carneiro (Sep 20 2019 at 08:00)</a>:</h4>
<p>but you should never confuse "enough to communicate the main ideas" with "proof"</p>

<a name="176172592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176172592" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176172592">Johan Commelin (Sep 20 2019 at 08:01)</a>:</h4>
<p>Isn't that the definition of <em>proof</em>?</p>

<a name="176172651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176172651" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176172651">Mario Carneiro (Sep 20 2019 at 08:02)</a>:</h4>
<p>for one thing, communication depends on the target audience; computers should be treated as a particularly dumb student</p>

<a name="176172782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176172782" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176172782">Mario Carneiro (Sep 20 2019 at 08:04)</a>:</h4>
<p>it is not really possible to give an actual definition of "proof" if you take that position seriously... in the limit, anything that is logically derivable can be considered "proof by trivial"</p>

<a name="176172862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176172862" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176172862">Mario Carneiro (Sep 20 2019 at 08:06)</a>:</h4>
<p>This is trending philosophical, but one property I want the word "proof" to have is that it's objective or at least societally defined, whereas "communication" is context dependent</p>

<a name="176173043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176173043" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176173043">Mario Carneiro (Sep 20 2019 at 08:09)</a>:</h4>
<p>Really, I prefer to just sidestep the whole matter and only talk about formal proof, which has a proper definition, but it makes it difficult for me to interpret Kevin when he wants a raised eyebrow to constitute a valid proof</p>

<a name="176173760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176173760" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176173760">Patrick Massot (Sep 20 2019 at 08:21)</a>:</h4>
<p>It depends whose eyebrow it is.</p>

<a name="176175662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176175662" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176175662">Mario Carneiro (Sep 20 2019 at 08:53)</a>:</h4>
<p>Here's the closest I got to Kevin's sketch, modulo the cardinality fact:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">set_theory</span><span class="bp">.</span><span class="n">cardinal</span>

<span class="n">local</span> <span class="kn">prefix</span> <span class="bp">`#`</span> <span class="o">:=</span> <span class="n">cardinal</span><span class="bp">.</span><span class="n">mk</span>
<span class="kn">theorem</span> <span class="n">mk_eq_mk</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">α</span> <span class="err">≃</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="bp">#</span><span class="n">α</span> <span class="bp">=</span> <span class="bp">#</span><span class="n">β</span> <span class="o">:=</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">sound</span> <span class="bp">⟨</span><span class="n">h</span><span class="bp">⟩</span>
<span class="kn">theorem</span> <span class="n">foo</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">#</span><span class="n">S</span> <span class="bp">&lt;</span> <span class="bp">#</span><span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="bp">#</span><span class="o">(</span><span class="bp">-</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">#</span><span class="n">α</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="err">↪</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">X</span> <span class="err">↪</span> <span class="n">Z</span><span class="o">)</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="bp">#</span><span class="n">X</span> <span class="bp">&lt;</span> <span class="bp">#</span><span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="bp">#</span><span class="n">Y</span> <span class="bp">=</span> <span class="bp">#</span><span class="n">Z</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">e</span> <span class="o">:</span> <span class="n">Y</span> <span class="err">≃</span> <span class="n">Z</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">e</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">g</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">have</span> <span class="n">e1</span> <span class="o">:</span> <span class="bp">#</span><span class="o">(</span><span class="bp">-</span><span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="n">f</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">_</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">#</span><span class="n">Y</span> <span class="o">:=</span> <span class="n">foo</span> <span class="o">(</span><span class="k">by</span> <span class="n">rwa</span> <span class="o">[</span><span class="err">←</span> <span class="n">mk_eq_mk</span> <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="n">f</span> <span class="n">f</span><span class="bp">.</span><span class="mi">2</span><span class="o">)]),</span>
  <span class="k">have</span> <span class="n">e2</span> <span class="o">:</span> <span class="bp">#</span><span class="o">(</span><span class="bp">-</span><span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="n">g</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">_</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">#</span><span class="n">Z</span> <span class="o">:=</span> <span class="n">foo</span> <span class="o">(</span><span class="k">by</span> <span class="n">rwa</span> <span class="o">[</span><span class="err">←</span> <span class="n">h₂</span><span class="o">,</span> <span class="err">←</span> <span class="n">mk_eq_mk</span> <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="n">g</span> <span class="n">g</span><span class="bp">.</span><span class="mi">2</span><span class="o">)]),</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">h₂</span><span class="o">,</span> <span class="err">←</span> <span class="n">e2</span><span class="o">]</span> <span class="n">at</span> <span class="n">e1</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">exact</span> <span class="n">e1</span> <span class="k">with</span> <span class="n">e1</span><span class="o">,</span>
  <span class="n">classical</span><span class="o">,</span>
  <span class="n">refine</span> <span class="bp">⟨</span><span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">sum_compl</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="bp">.</span><span class="n">trans</span> <span class="o">((</span><span class="n">equiv</span><span class="bp">.</span><span class="n">sum_congr</span> <span class="bp">_</span> <span class="n">e1</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">sum_compl</span> <span class="bp">_</span><span class="o">)),</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="n">f</span> <span class="n">f</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="n">g</span> <span class="n">g</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">equiv</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">sum_compl_symm_apply_of_mem</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_range_self</span><span class="o">],</span>
    <span class="n">rw</span> <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">symm_apply_eq</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span> <span class="n">simp</span> <span class="o">}</span>
<span class="kn">end</span>
</pre></div>

<a name="176177182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176177182" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176177182">Kevin Buzzard (Sep 20 2019 at 09:18)</a>:</h4>
<p>the cardinal fact is proved like this: If b&lt;a then a=b+(a-b)=max(b,a-b), hence a-b=a.</p>

<a name="176177224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176177224" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176177224">Kevin Buzzard (Sep 20 2019 at 09:19)</a>:</h4>
<p>Maybe some automatic theorem prover can find that fact about cardinals given what is in mathlib?</p>

<a name="176177403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176177403" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176177403">Kevin Buzzard (Sep 20 2019 at 09:22)</a>:</h4>
<p>I'm taking a look at your proof. It's annoying that hovering over <code>equiv.set.sum_compl</code> doesn't show me its type -- I think this is because we're in tactic mode.</p>

<a name="176177882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176177882" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176177882">Mario Carneiro (Sep 20 2019 at 09:30)</a>:</h4>
<p>Note that the cardinal fact as I've stated it is false, so if you think you have proved it you should not trust your proof</p>

<a name="176177918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176177918" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176177918">Mario Carneiro (Sep 20 2019 at 09:31)</a>:</h4>
<p>it would be pretty difficult to get nitpick or whatever counterexample generator to find why the statement is false too</p>

<a name="176177996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176177996" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176177996">Mario Carneiro (Sep 20 2019 at 09:32)</a>:</h4>
<p>actually scratch that - the problem is with finite sets so they can probably handle it</p>

<a name="176178115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176178115" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176178115">Mario Carneiro (Sep 20 2019 at 09:34)</a>:</h4>
<p>In chris's proof he uses calc blocks instead to build the equivs, which looks a bit nicer</p>

<a name="176178141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176178141" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176178141">Kevin Buzzard (Sep 20 2019 at 09:34)</a>:</h4>
<p>I thought we were talking about the infinite case now. All this a+b=max(a,b) is only true in the infinite case, I've been assuming infinite.</p>
<p>Your proof is extraordinary.</p>
<div class="codehilite"><pre><span></span>⊢ ⇑(equiv.trans (equiv.symm (equiv.set.sum_compl (set.range ⇑f)))
         (equiv.trans (equiv.sum_congr (equiv.trans (equiv.symm (equiv.set.range ⇑f _)) (equiv.set.range ⇑g _)) e1)
            (equiv.set.sum_compl (set.range ⇑g))))
      (⇑f x) =
    ⇑g x
</pre></div>


<p>We prove this by saying "...and the diagram obviously commutes". What is going on? This is trivial stuff.</p>

<a name="176178162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176178162" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176178162">Mario Carneiro (Sep 20 2019 at 09:35)</a>:</h4>
<p>there are side conditions</p>

<a name="176178164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176178164" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176178164">Kevin Buzzard (Sep 20 2019 at 09:35)</a>:</h4>
<p>I can prove this whole thing by drawing one picture.</p>

<a name="176178169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176178169" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176178169">Mario Carneiro (Sep 20 2019 at 09:35)</a>:</h4>
<p>no, you can state the problem by drawing a picture</p>

<a name="176178182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176178182" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176178182">Kevin Buzzard (Sep 20 2019 at 09:36)</a>:</h4>
<p>There aren't any side conditions. Assuming foo, we can prove the existence theorem. This is a really great example of a proof which can be done by a simple picture.</p>

<a name="176178227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176178227" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176178227">Mario Carneiro (Sep 20 2019 at 09:36)</a>:</h4>
<p>The only thing I wrote in the proof are side conditions</p>

<a name="176178232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176178232" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176178232">Mario Carneiro (Sep 20 2019 at 09:36)</a>:</h4>
<p>everything else is indeed being handled by simp</p>

<a name="176178244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176178244" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176178244">Kevin Buzzard (Sep 20 2019 at 09:36)</a>:</h4>
<p>wow</p>

<a name="176178280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176178280" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176178280">Mario Carneiro (Sep 20 2019 at 09:37)</a>:</h4>
<p>The proof sketch you gave me essentially covers the first two lines of the proof</p>

<a name="176178290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176178290" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176178290">Mario Carneiro (Sep 20 2019 at 09:37)</a>:</h4>
<p>you never said what the bijection is or how to build it</p>

<a name="176178294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176178294" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176178294">Mario Carneiro (Sep 20 2019 at 09:38)</a>:</h4>
<p>that's all "type tetris"</p>

<a name="176178340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176178340" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176178340">Mario Carneiro (Sep 20 2019 at 09:38)</a>:</h4>
<p>with side conditions in the middle of it all</p>

<a name="176178474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176178474" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176178474">Mario Carneiro (Sep 20 2019 at 09:40)</a>:</h4>
<p>I think side conditions are the bane of any theorem prover, because there is no good way to write them, which makes it easy to ignore them for expositional purposes in math</p>

<a name="176178561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176178561" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176178561">Kevin Buzzard (Sep 20 2019 at 09:42)</a>:</h4>
<p><a href="/user_uploads/3121/FkyNkwO2aDMqTtrmgrUVbTo8/IMG_20190920_104043021.jpg" target="_blank" title="IMG_20190920_104043021.jpg">IMG_20190920_104043021.jpg</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/FkyNkwO2aDMqTtrmgrUVbTo8/IMG_20190920_104043021.jpg" target="_blank" title="IMG_20190920_104043021.jpg"><img src="/user_uploads/3121/FkyNkwO2aDMqTtrmgrUVbTo8/IMG_20190920_104043021.jpg"></a></div>

<a name="176178668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176178668" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176178668">Kevin Buzzard (Sep 20 2019 at 09:44)</a>:</h4>
<p>Where is <code>equiv.set.sum_compl_symm_apply_of_mem</code> in my picture? What is going on?</p>

<a name="176178672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176178672" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176178672">Mario Carneiro (Sep 20 2019 at 09:44)</a>:</h4>
<p>Where's the bijection? I'm not even sure where f is in the picture</p>

<a name="176178680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176178680" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176178680">Kevin Buzzard (Sep 20 2019 at 09:44)</a>:</h4>
<p>Two down arrows are f and g.</p>

<a name="176178697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176178697" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176178697">Kevin Buzzard (Sep 20 2019 at 09:45)</a>:</h4>
<p>The bijection is because I identified the two sets Y and Z, the top halves are the same, and the bottom halves biject by a trivial lemma which I proved elsewhere on the board.</p>

<a name="176178729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176178729" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176178729">Mario Carneiro (Sep 20 2019 at 09:45)</a>:</h4>
<p><code>equiv.set.sum_compl_symm_apply_of_mem </code> says that if you are on the top half of the picture then you can go from y to the top half of y</p>

<a name="176178730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176178730" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176178730">Kevin Buzzard (Sep 20 2019 at 09:45)</a>:</h4>
<p>I am working in the category of sets equipped with a map from X, so somehow the commutativity of the diagrams just all gets swallowed up by the machine.</p>

<a name="176178778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176178778" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176178778">Kevin Buzzard (Sep 20 2019 at 09:46)</a>:</h4>
<p>Maybe I am using some better structure than you.</p>

<a name="176178793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176178793" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176178793">Mario Carneiro (Sep 20 2019 at 09:46)</a>:</h4>
<p>in lean there are two additional points in the picture, Y and Z</p>

<a name="176178804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176178804" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176178804">Mario Carneiro (Sep 20 2019 at 09:47)</a>:</h4>
<p>and maps from Y to the parts of Y</p>

<a name="176178833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176178833" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176178833">Kevin Buzzard (Sep 20 2019 at 09:47)</a>:</h4>
<p>Aah, this is one of these instances where a mathematician thinks "set-theoretically" and all these issues melt away.</p>

<a name="176178840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176178840" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176178840">Mario Carneiro (Sep 20 2019 at 09:47)</a>:</h4>
<p>sure I'd love to do that, but DTT</p>

<a name="176178842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176178842" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176178842">Kevin Buzzard (Sep 20 2019 at 09:47)</a>:</h4>
<p>(all the maps become the identity map in some sense)</p>

<a name="176178893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176178893" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176178893">Mario Carneiro (Sep 20 2019 at 09:48)</a>:</h4>
<p>actually it doesn't really solve anything, it just removes the function <code>equiv.set.sum_compl_symm_apply_of_mem</code> and leaves the side condition</p>

<a name="176178900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176178900" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176178900">Kevin Buzzard (Sep 20 2019 at 09:48)</a>:</h4>
<p>Are we missing a tactic which does arguments like this?</p>

<a name="176178912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176178912" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176178912">Mario Carneiro (Sep 20 2019 at 09:48)</a>:</h4>
<p>meh</p>

<a name="176178915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176178915" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176178915">Mario Carneiro (Sep 20 2019 at 09:48)</a>:</h4>
<p>"like this" is never enough</p>

<a name="176178927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176178927" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176178927">Mario Carneiro (Sep 20 2019 at 09:49)</a>:</h4>
<p>I generalize from &gt;1 example</p>

<a name="176178930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176178930" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176178930">Kevin Buzzard (Sep 20 2019 at 09:49)</a>:</h4>
<p>given that Y \ f(X) bijects with Z \ g(X), figure out the rest yourself. Is that too much for an AI?</p>

<a name="176178953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176178953" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176178953">Mario Carneiro (Sep 20 2019 at 09:49)</a>:</h4>
<p>Probably not</p>

<a name="176179017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Infinity%20Hotel/near/176179017" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/67367InfinityHotel.html#176179017">Mario Carneiro (Sep 20 2019 at 09:50)</a>:</h4>
<p>I can imagine an SMT prover can get this, but when it's all embedded in lean some things get obscured</p>


{% endraw %}

{% include archive_update.html %}