---
layout: archive
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/85297KevinstalkatBigProof.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/85297KevinstalkatBigProof.html">Kevin's talk at Big Proof</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="166800148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Kevin%27s%20talk%20at%20Big%20Proof/near/166800148" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/85297KevinstalkatBigProof.html#166800148">Scott Morrison (May 29 2019 at 09:54)</a>:</h4>
<p>I've just uploaded <a href="https://youtu.be/PSQq0RbgWH8" target="_blank" title="https://youtu.be/PSQq0RbgWH8">Kevin's talk</a> at the Big Proof meeting at Edinburgh.</p>
<div class="youtube-video message_inline_image"><a data-id="PSQq0RbgWH8" href="https://youtu.be/PSQq0RbgWH8" target="_blank" title="https://youtu.be/PSQq0RbgWH8"><img src="https://i.ytimg.com/vi/PSQq0RbgWH8/default.jpg"></a></div>

<a name="166801608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Kevin%27s%20talk%20at%20Big%20Proof/near/166801608" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/85297KevinstalkatBigProof.html#166801608">Kevin Buzzard (May 29 2019 at 10:20)</a>:</h4>
<p><a href="http://wwwf.imperial.ac.uk/~buzzard/docs/buzzard_big_proof2019.pdf" target="_blank" title="http://wwwf.imperial.ac.uk/~buzzard/docs/buzzard_big_proof2019.pdf">http://wwwf.imperial.ac.uk/~buzzard/docs/buzzard_big_proof2019.pdf</a></p>

<a name="166806202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Kevin%27s%20talk%20at%20Big%20Proof/near/166806202" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/85297KevinstalkatBigProof.html#166806202">Keeley Hoek (May 29 2019 at 11:39)</a>:</h4>
<p>What if there was a theorem prover where whenever you declared a structure, unless you explicitly declared that you wouldn't (with the <code>evil</code> keyword or something :D), you had to provide a notion of isomorphism, and it was then illegal to make a definition which used the structure without that definition being transportable over under your defined notion of isomorphism?</p>

<a name="166806271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Kevin%27s%20talk%20at%20Big%20Proof/near/166806271" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/85297KevinstalkatBigProof.html#166806271">Johan Commelin (May 29 2019 at 11:40)</a>:</h4>
<p>Isn't that more or less HoTT?</p>

<a name="166806276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Kevin%27s%20talk%20at%20Big%20Proof/near/166806276" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/85297KevinstalkatBigProof.html#166806276">Keeley Hoek (May 29 2019 at 11:40)</a>:</h4>
<p>I have no idea</p>

<a name="166806304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Kevin%27s%20talk%20at%20Big%20Proof/near/166806304" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/85297KevinstalkatBigProof.html#166806304">Johan Commelin (May 29 2019 at 11:40)</a>:</h4>
<p>HoTT even figures out the notion of isomorphism for you</p>

<a name="166806374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Kevin%27s%20talk%20at%20Big%20Proof/near/166806374" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/85297KevinstalkatBigProof.html#166806374">Keeley Hoek (May 29 2019 at 11:41)</a>:</h4>
<p>hmm. I don't know anything about HoTT. But that world seems scary---and for some reason spheres are different!</p>
<p>I just want <code>is_local R</code> to have an (autogenerated) proof that it is preserved by ring isomorphism!!</p>

<a name="166806448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Kevin%27s%20talk%20at%20Big%20Proof/near/166806448" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/85297KevinstalkatBigProof.html#166806448">Keeley Hoek (May 29 2019 at 11:42)</a>:</h4>
<p>I just love the aesthetic of <code>evil def dagger_category := ...</code></p>

<a name="166808352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Kevin%27s%20talk%20at%20Big%20Proof/near/166808352" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/85297KevinstalkatBigProof.html#166808352">Mario Carneiro (May 29 2019 at 12:11)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> Here's your missing M1F problem:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">set_theory</span><span class="bp">.</span><span class="n">zfc</span>

<span class="kn">namespace</span> <span class="n">Set</span>

<span class="n">def</span> <span class="n">of_nat</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">Set</span>
<span class="bp">|</span> <span class="mi">0</span>     <span class="o">:=</span> <span class="err">∅</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">insert</span> <span class="o">(</span><span class="n">of_nat</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">of_nat</span> <span class="n">n</span><span class="o">)</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="bp">ℕ</span> <span class="n">Set</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">of_nat</span><span class="bp">⟩</span>

<span class="kn">theorem</span> <span class="n">omega_nat</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="err">↑</span><span class="n">n</span> <span class="err">∈</span> <span class="n">omega</span>
<span class="bp">|</span> <span class="mi">0</span>     <span class="o">:=</span> <span class="n">omega_zero</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">omega_succ</span> <span class="o">(</span><span class="n">omega_nat</span> <span class="n">n</span><span class="o">)</span>

<span class="kn">theorem</span> <span class="n">singleton_subset</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">Set</span><span class="o">}</span> <span class="o">:</span> <span class="o">{</span><span class="n">a</span><span class="o">}</span> <span class="err">⊆</span> <span class="n">b</span> <span class="bp">↔</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">b</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">h</span> <span class="o">(</span><span class="n">mem_singleton</span><span class="bp">.</span><span class="mi">2</span> <span class="n">rfl</span><span class="o">),</span> <span class="bp">λ</span> <span class="n">H</span> <span class="n">c</span> <span class="n">h</span><span class="o">,</span> <span class="o">((</span><span class="bp">@</span><span class="n">mem_singleton</span> <span class="n">c</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">▸</span> <span class="n">H</span><span class="bp">⟩</span>

<span class="kn">theorem</span> <span class="n">ne_empty_of_mem</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">Set</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≠</span> <span class="err">∅</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">h0</span><span class="o">,</span> <span class="n">Set</span><span class="bp">.</span><span class="n">mem_empty</span> <span class="n">a</span> <span class="o">(</span><span class="n">h0</span> <span class="bp">▸</span> <span class="n">h</span><span class="o">)</span>

<span class="kn">theorem</span> <span class="n">insert_ne_empty</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">Set</span><span class="o">)</span> <span class="o">:</span> <span class="n">insert</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">≠</span> <span class="err">∅</span> <span class="o">:=</span>
<span class="n">ne_empty_of_mem</span> <span class="err">$</span> <span class="n">mem_insert</span><span class="bp">.</span><span class="mi">2</span> <span class="err">$</span> <span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="n">rfl</span>

<span class="kn">theorem</span> <span class="n">succ_ne_empty</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="err">↑</span><span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">Set</span><span class="o">)</span> <span class="bp">≠</span> <span class="err">∅</span> <span class="o">:=</span> <span class="n">insert_ne_empty</span> <span class="bp">_</span> <span class="bp">_</span>

<span class="kn">end</span> <span class="n">Set</span>
<span class="kn">open</span> <span class="n">Set</span>

<span class="n">def</span> <span class="n">X</span> <span class="o">:</span> <span class="n">Set</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="o">:=</span> <span class="o">{</span><span class="err">↑</span><span class="mi">1</span><span class="o">,</span> <span class="err">↑</span><span class="mi">2</span><span class="o">,</span> <span class="o">{</span><span class="err">↑</span><span class="mi">2</span><span class="o">},</span> <span class="o">{</span><span class="err">↑</span><span class="mi">1</span><span class="o">,</span> <span class="err">↑</span><span class="mi">2</span><span class="o">}}</span>

<span class="kn">theorem</span> <span class="n">two_mem_X</span> <span class="o">:</span> <span class="err">↑</span><span class="mi">2</span> <span class="err">∈</span> <span class="n">X</span> <span class="o">:=</span>
<span class="n">mem_insert</span><span class="bp">.</span><span class="mi">2</span> <span class="err">$</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="err">$</span> <span class="n">mem_insert</span><span class="bp">.</span><span class="mi">2</span> <span class="err">$</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="err">$</span> <span class="n">mem_insert</span><span class="bp">.</span><span class="mi">2</span> <span class="err">$</span> <span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="n">rfl</span>

<span class="kn">example</span> <span class="o">:</span> <span class="o">{</span><span class="err">↑</span><span class="mi">2</span><span class="o">}</span> <span class="err">∈</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">mem_insert</span><span class="bp">.</span><span class="mi">2</span> <span class="err">$</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="err">$</span> <span class="n">mem_insert</span><span class="bp">.</span><span class="mi">2</span> <span class="err">$</span> <span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="n">rfl</span>

<span class="kn">example</span> <span class="o">:</span> <span class="o">{</span><span class="err">↑</span><span class="mi">2</span><span class="o">}</span> <span class="err">⊆</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">singleton_subset</span><span class="bp">.</span><span class="mi">2</span> <span class="n">two_mem_X</span>

<span class="kn">example</span> <span class="o">:</span> <span class="bp">¬</span> <span class="err">↑</span><span class="mi">2</span> <span class="err">⊆</span> <span class="n">X</span> <span class="o">:=</span> <span class="k">begin</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">replace</span> <span class="n">h</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">h</span> <span class="err">∅</span> <span class="o">(</span><span class="k">show</span> <span class="err">↑</span><span class="mi">0</span> <span class="err">∈</span> <span class="o">{</span><span class="err">↑</span><span class="mi">0</span><span class="o">,</span> <span class="err">↑</span><span class="mi">1</span><span class="o">},</span> <span class="k">from</span> <span class="n">mem_insert</span><span class="bp">.</span><span class="mi">2</span> <span class="err">$</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="err">$</span> <span class="n">mem_singleton</span><span class="bp">.</span><span class="mi">2</span> <span class="n">rfl</span><span class="o">),</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">mem_insert</span><span class="bp">.</span><span class="mi">1</span> <span class="n">h</span> <span class="k">with</span> <span class="n">e</span> <span class="bp">|</span> <span class="n">h</span><span class="o">,</span> <span class="n">exact</span> <span class="o">(</span><span class="n">insert_ne_empty</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="n">e</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">mem_insert</span><span class="bp">.</span><span class="mi">1</span> <span class="n">h</span> <span class="k">with</span> <span class="n">e</span> <span class="bp">|</span> <span class="n">h</span><span class="o">,</span> <span class="n">exact</span> <span class="o">(</span><span class="n">insert_ne_empty</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="n">e</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">mem_insert</span><span class="bp">.</span><span class="mi">1</span> <span class="n">h</span> <span class="k">with</span> <span class="n">e</span> <span class="bp">|</span> <span class="n">h</span><span class="o">,</span> <span class="n">exact</span> <span class="o">(</span><span class="n">succ_ne_empty</span> <span class="bp">_</span><span class="o">)</span> <span class="n">e</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">mem_insert</span><span class="bp">.</span><span class="mi">1</span> <span class="n">h</span> <span class="k">with</span> <span class="n">e</span> <span class="bp">|</span> <span class="n">h</span><span class="o">,</span> <span class="n">exact</span> <span class="o">(</span><span class="n">succ_ne_empty</span> <span class="bp">_</span><span class="o">)</span> <span class="n">e</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">mem_empty</span> <span class="bp">_</span> <span class="n">h</span>
<span class="kn">end</span>
</pre></div>

<a name="166808451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Kevin%27s%20talk%20at%20Big%20Proof/near/166808451" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/85297KevinstalkatBigProof.html#166808451">Mario Carneiro (May 29 2019 at 12:12)</a>:</h4>
<p>I originally wrote <code>lists</code> to help solve this problem, but ZFC set theory approach works too. With <code>lists</code> the whole thing is decidable so you could just use <code>dec_trivial</code> for everything</p>

<a name="166808487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Kevin%27s%20talk%20at%20Big%20Proof/near/166808487" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/85297KevinstalkatBigProof.html#166808487">Kenny Lau (May 29 2019 at 12:13)</a>:</h4>
<p>don't we have <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>ω</mi></msub></mrow><annotation encoding="application/x-tex">V_\omega</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.03588em;">ω</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> in mathlib or something</p>

<a name="166808495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Kevin%27s%20talk%20at%20Big%20Proof/near/166808495" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/85297KevinstalkatBigProof.html#166808495">Mario Carneiro (May 29 2019 at 12:13)</a>:</h4>
<p>yeah, that's <code>lists</code>, more or less</p>

<a name="166808556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Kevin%27s%20talk%20at%20Big%20Proof/near/166808556" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/85297KevinstalkatBigProof.html#166808556">Mario Carneiro (May 29 2019 at 12:14)</a>:</h4>
<p>it's actually finite ZFA</p>

<a name="166808666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Kevin%27s%20talk%20at%20Big%20Proof/near/166808666" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/85297KevinstalkatBigProof.html#166808666">Mario Carneiro (May 29 2019 at 12:16)</a>:</h4>
<p>so <code>X</code> here is a member of <code>lists nat</code> where the <code>nat</code> gives atoms at the bottom like <code>1</code> and <code>2</code>. Here I used finite von Neumann ordinals for 1 and 2 and so the final part is a bit tricky since you have to show that the empty set is not equal to <code>1</code> or <code>2</code></p>

<a name="166812545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Kevin%27s%20talk%20at%20Big%20Proof/near/166812545" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/85297KevinstalkatBigProof.html#166812545">Scott Morrison (May 29 2019 at 13:09)</a>:</h4>
<blockquote>
<p>What if there was a theorem prover where whenever you declared a structure, unless you explicitly declared that you wouldn't (with the <code>evil</code> keyword or something :D), you had to provide a notion of isomorphism, and it was then illegal to make a definition which used the structure without that definition being transportable over under your defined notion of isomorphism?</p>
</blockquote>
<p>I think this is just a matter of not ever writing <code>def my_predicate (X : Type) [group X] : Prop := ...</code>, and instead writing <code>def my_predicate_functorial (G : core Group) ⥤ Prop := ...</code>.</p>
<p>One then hopes that the <code>map</code> field of the functor can be built by automation. Once that automation is in place, one goes back to just writing <br>
<code>def my_predicate (X : Type) [group X] : Prop := ...</code>, but with <code>@[derive iso_functorial]</code> prepended, and then you have transport of structure using the tactic <code>iso_induction</code> Yiming is writing.</p>

<a name="166814959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Kevin%27s%20talk%20at%20Big%20Proof/near/166814959" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/85297KevinstalkatBigProof.html#166814959">Keeley Hoek (May 29 2019 at 13:33)</a>:</h4>
<p><code>isodef my_predicate (X : Type) [group X] : Prop := ...</code></p>

<a name="166818965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Kevin%27s%20talk%20at%20Big%20Proof/near/166818965" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/85297KevinstalkatBigProof.html#166818965">Johan Commelin (May 29 2019 at 14:09)</a>:</h4>
<p>The difference between <code>@[derive iso_functorial] def</code> and <code>isodef</code> is not too big... I could handle that.</p>

<a name="166835756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Kevin%27s%20talk%20at%20Big%20Proof/near/166835756" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/85297KevinstalkatBigProof.html#166835756">Johan Commelin (May 29 2019 at 17:07)</a>:</h4>
<p>We (read: Mario and Floris) solved Larry's challenge in 3 days. Let's see what the other communities can do with Kevin's challenges (-;</p>

<a name="166838802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Kevin%27s%20talk%20at%20Big%20Proof/near/166838802" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/85297KevinstalkatBigProof.html#166838802">Kevin Buzzard (May 29 2019 at 17:40)</a>:</h4>
<p>I had a long talk to Larry Paulson after my talk. He was interested in how it all happened. Someone (I forgot who :-( ) told me that they were very sorry to lose Floris! Maybe they were from Nijmegen? Maybe it was Freek. </p>
<p>I am leaving Big Proof now :-/ I have a talk to give in London tomorrow and I also need to get back to Imperial because I have an unformalisation project to supervise! The project is to take data.filter.basic and translate it into pdf form :-) Patrick told me that he didn't know a good reference for this stuff.</p>

<a name="166838870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Kevin%27s%20talk%20at%20Big%20Proof/near/166838870" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/85297KevinstalkatBigProof.html#166838870">Johan Commelin (May 29 2019 at 17:41)</a>:</h4>
<p>Wow! <em>unformalisation</em>. That sounds like we're living the future.</p>

<a name="166839450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Kevin%27s%20talk%20at%20Big%20Proof/near/166839450" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/85297KevinstalkatBigProof.html#166839450">Kevin Buzzard (May 29 2019 at 17:48)</a>:</h4>
<p>I don't know how many Lean people there were at Big Proof 2017, but I really felt that we were the dominant tribe in Big Proof 2019. There was me, Sander Dahmen, Rob Lewis, Patrick Massot, Neil Strickland, Ed Ayers, Jeremy Avigad, Scott Morrison, and also all the people I've forgotten because I'm a fool. On the Isabelle side there was Larry Paulson, his post-docs Angeliki Koutsoukou Argyraki and Wenda Li, and Manuel Eberl and Mohammad Abdulaziz from Munich, and then representing other systems we had Peter Koepke and John Harrison (who I'd never met before and who is a really nice guy). I'm trying to list all the people who were into formalising mathematics; I have probably forgotten some people; I'll edit if I've made any real howlers.</p>
<p>I found it very interesting talking to the Isabelle people.</p>

<a name="166841061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Kevin%27s%20talk%20at%20Big%20Proof/near/166841061" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/85297KevinstalkatBigProof.html#166841061">Kevin Buzzard (May 29 2019 at 18:06)</a>:</h4>
<p>Wojciech Nawrocki was also there.</p>

<a name="166841936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Kevin%27s%20talk%20at%20Big%20Proof/near/166841936" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/85297KevinstalkatBigProof.html#166841936">Johan Commelin (May 29 2019 at 18:15)</a>:</h4>
<p>I'm proof reading the print proofs of one of my papers, and I realised that it has a nice example of the mathematicians code of honour:</p>
<ul>
<li>Definition 1.a: two gadgets X and Y are called <em>quasi-compatible</em> if blah...</li>
<li>Definition 1.b: two gadgets X and Y are called <em>strongly quasi-compatible</em> if blah... and bleh...</li>
<li>Remark: <span aria-label="warning" class="emoji emoji-26a0" role="img" title="warning">:warning:</span> it is not known whether strong quasi-compatibility is an equivalence relation.</li>
</ul>

<a name="166842198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Kevin%27s%20talk%20at%20Big%20Proof/near/166842198" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/85297KevinstalkatBigProof.html#166842198">Johan Commelin (May 29 2019 at 18:18)</a>:</h4>
<p>I don't spend a word on whether <em>quasi-compatibility</em> is an equivalence relation. And the warning/remark was only added after Deligne pointed out to me that I should add the warning. <span aria-label="grinning face with smiling eyes" class="emoji emoji-1f601" role="img" title="grinning face with smiling eyes">:grinning_face_with_smiling_eyes:</span></p>

<a name="166850159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Kevin%27s%20talk%20at%20Big%20Proof/near/166850159" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/85297KevinstalkatBigProof.html#166850159">Floris van Doorn (May 29 2019 at 19:49)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>  Yeah, I did my master thesis under supervision of Freek, so it was probably him.</p>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> Thanks for the nice video of the talk! And great talk as always, Kevin!</p>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> I've also done some unformalization of HoTT proofs, where the formal proof existed before it was written up anywhere.</p>

<a name="166858411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Kevin%27s%20talk%20at%20Big%20Proof/near/166858411" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/85297KevinstalkatBigProof.html#166858411">David Michael Roberts (May 29 2019 at 21:23)</a>:</h4>
<blockquote>
<p>What if there was a theorem prover where whenever you declared a structure, unless you explicitly declared that you wouldn't (with the <code>evil</code> keyword or something :D), you had to provide a notion of isomorphism, and it was then illegal to make a definition which used the structure without that definition being transportable over under your defined notion of isomorphism?</p>
</blockquote>
<p>Something based on Bourbaki's set theory? That would be evil.</p>

<a name="167095854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Kevin%27s%20talk%20at%20Big%20Proof/near/167095854" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/85297KevinstalkatBigProof.html#167095854">Kevin Buzzard (Jun 02 2019 at 00:10)</a>:</h4>
<p><a href="https://xenaproject.wordpress.com/2019/06/02/equality-part-3-canonical-isomorphism/" target="_blank" title="https://xenaproject.wordpress.com/2019/06/02/equality-part-3-canonical-isomorphism/">https://xenaproject.wordpress.com/2019/06/02/equality-part-3-canonical-isomorphism/</a></p>
<p><span class="user-mention" data-user-id="130272">@David Michael Roberts</span> grilled me on Twitter a bit about my claims about equality and how it's confused with canonical isomorphism by even the greatest mathematicians. I wrote some more about this on my blog, stuff which didn't make it into the talk. </p>
<p>The more I think about canonical isomorphism, the more I realise how impossible it is to make a tactic which does everything a mathematician does with it -- not least because some stuff we do with it is really quite subtle.</p>

<a name="167152809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Kevin%27s%20talk%20at%20Big%20Proof/near/167152809" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/85297KevinstalkatBigProof.html#167152809">Johan Commelin (Jun 03 2019 at 03:48)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> Here are some marvellous code snippets to kickstart your week: <a href="https://github.com/leanprover-community/mathlib/search?q=canonical&amp;unscoped_q=canonical" target="_blank" title="https://github.com/leanprover-community/mathlib/search?q=canonical&amp;unscoped_q=canonical">https://github.com/leanprover-community/mathlib/search?q=canonical&amp;unscoped_q=canonical</a></p>

<a name="167519597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Kevin%27s%20talk%20at%20Big%20Proof/near/167519597" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/85297KevinstalkatBigProof.html#167519597">Reid Barton (Jun 06 2019 at 20:29)</a>:</h4>
<p><a href="/user_uploads/3121/1A93I7zDB6sia-NBym9GWFP3/32uczu.jpg" target="_blank" title="32uczu.jpg">32uczu.jpg</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/1A93I7zDB6sia-NBym9GWFP3/32uczu.jpg" target="_blank" title="32uczu.jpg"><img src="/user_uploads/3121/1A93I7zDB6sia-NBym9GWFP3/32uczu.jpg"></a></div>


{% endraw %}
