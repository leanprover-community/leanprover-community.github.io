---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/37680Verifyingadeterministicalgorithm.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/37680Verifyingadeterministicalgorithm.html">Verifying a deterministic algorithm</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="192793709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Verifying%20a%20deterministic%20algorithm/near/192793709" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37680Verifyingadeterministicalgorithm.html#192793709">Kevin Buzzard (Apr 03 2020 at 12:08)</a>:</h4>
<p>Let's say that someone ports a random number generator to Lean where you can seed it (default seed is 37) and then it just gives you a function from nat to real or nat to the nats which are at most N or whatever. Using this someone could formalise an algorithm like Miller Rabin and then this could be a pseudo primality checker for large numbers. But how could one formalise the assertion that "the miller rabin test tried with 100 randomly generated primes will give the right answer with probability 99.99999999%"?</p>

<a name="192793759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Verifying%20a%20deterministic%20algorithm/near/192793759" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37680Verifyingadeterministicalgorithm.html#192793759">Kevin Buzzard (Apr 03 2020 at 12:09)</a>:</h4>
<p>I mean, formalising the things mathematicians say when they justify these sorts of claims</p>

<a name="192793968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Verifying%20a%20deterministic%20algorithm/near/192793968" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37680Verifyingadeterministicalgorithm.html#192793968">Gabriel Ebner (Apr 03 2020 at 12:11)</a>:</h4>
<p>The assertion is just a statement about the probability of a certain set (where the seed is a (uniformly distributed) random variable).</p>

<a name="192794048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Verifying%20a%20deterministic%20algorithm/near/192794048" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37680Verifyingadeterministicalgorithm.html#192794048">Kevin Buzzard (Apr 03 2020 at 12:12)</a>:</h4>
<p>Maybe there's some function which eats a proposition depending on a stream input and returns a number between zero and one which we never compute</p>

<a name="192794283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Verifying%20a%20deterministic%20algorithm/near/192794283" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37680Verifyingadeterministicalgorithm.html#192794283">Kevin Buzzard (Apr 03 2020 at 12:14)</a>:</h4>
<p>I see, and I can then prove that the probability you pass for a given input is at least 3/4 or whatever</p>

<a name="192794330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Verifying%20a%20deterministic%20algorithm/near/192794330" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37680Verifyingadeterministicalgorithm.html#192794330">Kevin Buzzard (Apr 03 2020 at 12:15)</a>:</h4>
<p>Without ever explicitly computing it</p>

<a name="192795112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Verifying%20a%20deterministic%20algorithm/near/192795112" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37680Verifyingadeterministicalgorithm.html#192795112">Gabriel Ebner (Apr 03 2020 at 12:23)</a>:</h4>
<p>It's been some time since I've looked at Miler-Rabin.  IIRC (and read wikipedia), then in order to check that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> is prime, you check for a random <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>&lt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">a &lt; n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>d</mi></msup><mo>≢</mo><mn>1</mn><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a^d \not\equiv 1 (n)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.043548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mrow><msup><mn>2</mn><mi>r</mi></msup><mi>d</mi></mrow></msup><mo>≢</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a^{2^r d} \not\equiv -1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.07442em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.87998em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7385428571428572em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span><span class="mord mathdefault mtight">d</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span> for all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>&lt;</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">r &lt; s</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn><mo>=</mo><msup><mn>2</mn><mi>s</mi></msup><mi>d</mi></mrow><annotation encoding="application/x-tex">n-1 = 2^sd</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span></span></span></span><span class="mord mathdefault">d</span></span></span></span>.  The number <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> is prime iff no such <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> exists.  If <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> is not prime, the probability of picking such an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> is at least <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mi mathvariant="normal">/</mi><mn>4</mn></mrow><annotation encoding="application/x-tex">3/4</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mord">/</span><span class="mord">4</span></span></span></span>.</p>

<a name="192795654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Verifying%20a%20deterministic%20algorithm/near/192795654" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37680Verifyingadeterministicalgorithm.html#192795654">Gabriel Ebner (Apr 03 2020 at 12:28)</a>:</h4>
<p>So you'd get a function <code>test : fin n → Prop</code> with <code>volume test ≥ 3/4</code>.  You can then also define a function <code>(fin m → fin n) → Prop</code> that does the test multiple times.  I'm not sure how exactly you would hook this up with a PRNG, you'd probably need some theorems about the distribution of the values of the PRNG.</p>

<a name="192796342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Verifying%20a%20deterministic%20algorithm/near/192796342" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37680Verifyingadeterministicalgorithm.html#192796342">Mario Carneiro (Apr 03 2020 at 12:35)</a>:</h4>
<p>I don't think there is anything meaningful you can do to hook up the PRNG, at the end of the day you just get one number. You might be able to take the preimage of the probability distribution across the PRNG to give a bound on the volume of the set of "good" seed values, but then you just stick 37 in and hope it's one of the good ones</p>

<a name="192796482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Verifying%20a%20deterministic%20algorithm/near/192796482" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37680Verifyingadeterministicalgorithm.html#192796482">Mario Carneiro (Apr 03 2020 at 12:36)</a>:</h4>
<p>You might also have trouble proving that iterating the test increases the volume past 3/4, since proving independence is somewhere between very difficult and false</p>

<a name="192797174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Verifying%20a%20deterministic%20algorithm/near/192797174" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37680Verifyingadeterministicalgorithm.html#192797174">Gabriel Ebner (Apr 03 2020 at 12:43)</a>:</h4>
<p>The part about the independence of the values of the PRNG is a good point, though the probability of finding a witness should still converge to 1 since the PRNG hopefully enumerates all values.</p>
<p>There are two questions here though:</p>
<ol>
<li>How to verify the Miller-Rabin algorithm.  Here the answer is probably to ignore the PRNG and just compute the probability of the test directly, which isn't too hard.</li>
<li>How to run it as a tactic to disprove primality.  I completely agree with you here.  Just stick in the randomly chosen values 2, 3, 5, 7, and 11 and pray that you find a witness.</li>
</ol>

<a name="192797530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Verifying%20a%20deterministic%20algorithm/near/192797530" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37680Verifyingadeterministicalgorithm.html#192797530">Mario Carneiro (Apr 03 2020 at 12:45)</a>:</h4>
<p>Unless it's a ludicrously large number, an easier way to get a witness is to ask a CAS to find a factor</p>

<a name="192797666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Verifying%20a%20deterministic%20algorithm/near/192797666" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37680Verifyingadeterministicalgorithm.html#192797666">Gabriel Ebner (Apr 03 2020 at 12:46)</a>:</h4>
<p>I'd even say "<em>in particular</em> if it's a ludicrously large number".</p>

<a name="192797770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Verifying%20a%20deterministic%20algorithm/near/192797770" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37680Verifyingadeterministicalgorithm.html#192797770">Mario Carneiro (Apr 03 2020 at 12:47)</a>:</h4>
<p>But I agree with the general spirit of the question; I've been struggling with finding the "proof content" of probabilistic proofs for years</p>

<a name="192797908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Verifying%20a%20deterministic%20algorithm/near/192797908" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37680Verifyingadeterministicalgorithm.html#192797908">Mario Carneiro (Apr 03 2020 at 12:48)</a>:</h4>
<p>it always boils down to relying on open questions like the algorithmic randomness of prime numbers after suitable preprocessing</p>

<a name="192798121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Verifying%20a%20deterministic%20algorithm/near/192798121" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37680Verifyingadeterministicalgorithm.html#192798121">Gabriel Ebner (Apr 03 2020 at 12:50)</a>:</h4>
<p>They're not probabilistic proofs, they're probabilistic algorithms.  And their correctness (= probability that they return the correct result) does not rely on any open questions AFAICT.</p>

<a name="192798252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Verifying%20a%20deterministic%20algorithm/near/192798252" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37680Verifyingadeterministicalgorithm.html#192798252">Mario Carneiro (Apr 03 2020 at 12:51)</a>:</h4>
<p>I mean the correctness of the over all procedure of taking a test like this, running it 10 or 20 times, and arguing that the chance that the theorem is false is now less than the probability of hardware failure</p>

<a name="192798255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Verifying%20a%20deterministic%20algorithm/near/192798255" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37680Verifyingadeterministicalgorithm.html#192798255">Gabriel Ebner (Apr 03 2020 at 12:51)</a>:</h4>
<p>I also feel a bit uneasy that these algorithms return an imprecise answer to a binary question, but that doesn't change the fact that they are correct in a very precise sense.</p>

<a name="192798353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Verifying%20a%20deterministic%20algorithm/near/192798353" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37680Verifyingadeterministicalgorithm.html#192798353">Gabriel Ebner (Apr 03 2020 at 12:52)</a>:</h4>
<p>Yes, that's precisely the part I don't like either.</p>

<a name="192801829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Verifying%20a%20deterministic%20algorithm/near/192801829" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37680Verifyingadeterministicalgorithm.html#192801829">Kevin Buzzard (Apr 03 2020 at 13:17)</a>:</h4>
<p>You're pure computer scientists.</p>

<a name="192803915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Verifying%20a%20deterministic%20algorithm/near/192803915" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37680Verifyingadeterministicalgorithm.html#192803915">Bryan Gin-ge Chen (Apr 03 2020 at 13:32)</a>:</h4>
<p>This discussion reminds me a bit of <a href="https://mathoverflow.net/questions/309191/how-to-be-rigorous-about-combinatorial-algorithms" title="https://mathoverflow.net/questions/309191/how-to-be-rigorous-about-combinatorial-algorithms">this MO question</a> which I remember reading and being confused about right before I learned about Lean. </p>
<p>What notable algorithms do we currently have in non <code>meta</code> mathlib? There's the extended GCD stuff by Mario in <code>data.int.gcd</code>, some sort algorithms in <code>data.list.sort</code> and some other stuff on data structures like <code>data.hash_maps</code>, anything else that I'm missing? (I guess any <code>def</code> is in some sense an algorithm, so really I'm asking about what mathematicians might label algorithms.)</p>

<a name="192805262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Verifying%20a%20deterministic%20algorithm/near/192805262" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37680Verifyingadeterministicalgorithm.html#192805262">Mario Carneiro (Apr 03 2020 at 13:42)</a>:</h4>
<p>there are association lists in <code>data.list.alist</code>, R-B maps in core, and <code>ordmap</code> is an implementation of 2/3 size balanced binary trees a la Haskell's Data.Map on a long outdated branch of mathlib. I once had a plan to formalize most of Okasaki's book on functional data structures, but it was dead on arrival because lean 3 doesn't have thunks so half of the algorithms don't work (at least not at the stated performance bounds)</p>

<a name="192805389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Verifying%20a%20deterministic%20algorithm/near/192805389" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37680Verifyingadeterministicalgorithm.html#192805389">Reid Barton (Apr 03 2020 at 13:43)</a>:</h4>
<p>For these probabilistic algorithms I don't think you can avoid modeling the PRNG output as a random variable (in the sense of probability theory).</p>

<a name="192805495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Verifying%20a%20deterministic%20algorithm/near/192805495" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37680Verifyingadeterministicalgorithm.html#192805495">Mario Carneiro (Apr 03 2020 at 13:44)</a>:</h4>
<p>but that's... at best unjustified</p>

<a name="192805532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Verifying%20a%20deterministic%20algorithm/near/192805532" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37680Verifyingadeterministicalgorithm.html#192805532">Reid Barton (Apr 03 2020 at 13:44)</a>:</h4>
<p>Right, which is precisely why you can't do better in a theorem prover <span aria-label="slight smile" class="emoji emoji-1f642" role="img" title="slight smile">:slight_smile:</span></p>

<a name="192805605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Verifying%20a%20deterministic%20algorithm/near/192805605" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37680Verifyingadeterministicalgorithm.html#192805605">Reid Barton (Apr 03 2020 at 13:45)</a>:</h4>
<p>The most you could even hope to be true is that your PRNG looks random to someone with bounded computational power</p>

<a name="192805638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Verifying%20a%20deterministic%20algorithm/near/192805638" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37680Verifyingadeterministicalgorithm.html#192805638">Reid Barton (Apr 03 2020 at 13:45)</a>:</h4>
<p>but I don't think anyone knows how to prove any statement of that form</p>

<a name="192805648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Verifying%20a%20deterministic%20algorithm/near/192805648" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37680Verifyingadeterministicalgorithm.html#192805648">Mario Carneiro (Apr 03 2020 at 13:45)</a>:</h4>
<p>for all you know there is some deep number theory reason that the method your PRNG uses is disproportionally likely to pick Miller-Rabin false negatives</p>

<a name="192806254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Verifying%20a%20deterministic%20algorithm/near/192806254" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37680Verifyingadeterministicalgorithm.html#192806254">Reid Barton (Apr 03 2020 at 13:50)</a>:</h4>
<p>Well, you might believe that this is actually false (because false negatives are rare, and you could detect them in polynomial time by doing a polynomial time deterministic primality test) but how would you ever prove it?</p>

<a name="192806847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Verifying%20a%20deterministic%20algorithm/near/192806847" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37680Verifyingadeterministicalgorithm.html#192806847">Reid Barton (Apr 03 2020 at 13:54)</a>:</h4>
<p>and for your application you would even need to prove it with effective bounds</p>

<a name="192808195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Verifying%20a%20deterministic%20algorithm/near/192808195" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37680Verifyingadeterministicalgorithm.html#192808195">Ryan Lahfa (Apr 03 2020 at 14:05)</a>:</h4>
<p>That's a small contribution, but AFAIK, people have been successful at modelling some CSPRNG behaviors using Z3 solvers: <a href="https://alephsecurity.com/2019/09/02/Z3-for-webapp-security/" title="https://alephsecurity.com/2019/09/02/Z3-for-webapp-security/">https://alephsecurity.com/2019/09/02/Z3-for-webapp-security/</a> — I don't know how feasible it would be to reproduce this in Lean (and how useful?) — but I guess this is far from the ideal desired outcome of this discussion.</p>

<a name="192809225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Verifying%20a%20deterministic%20algorithm/near/192809225" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37680Verifyingadeterministicalgorithm.html#192809225">Mario Carneiro (Apr 03 2020 at 14:12)</a>:</h4>
<p>Yeah, unfortunately the only thing that seems to be possible in this space is <em>disproving</em> that certain random number generators are good</p>


{% endraw %}

{% include archive_update.html %}