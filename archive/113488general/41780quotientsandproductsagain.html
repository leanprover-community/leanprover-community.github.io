---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/41780quotientsandproductsagain.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/41780quotientsandproductsagain.html">quotients and products again</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="187317995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotients%20and%20products%20again/near/187317995" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/41780quotientsandproductsagain.html#187317995">Reid Barton (Feb 03 2020 at 23:51)</a>:</h4>
<p>If <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>A</mi><mi>i</mi></msub><msub><mo stretchy="false">)</mo><mrow><mi>i</mi><mo>∈</mo><mi>I</mi></mrow></msub></mrow><annotation encoding="application/x-tex">(A_i)_{i \in I}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">∈</span><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.17737em;"><span></span></span></span></span></span></span></span></span></span> is a family of sets and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">R_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is an equivalence relation on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, then writing <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span> for the product of the relations <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">R_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, there is a map <span class="tex-error">$$(\product A_i) / R \to \product (A_i / R_i)$$</span>. Classically this map has an inverse: given an element on the right hand side, we can choose a representative of each factor and assemble them to a representative of a preimage. In mathlib it is implemented <a href="https://github.com/leanprover-community/mathlib/blob/4aa3eee46f0c7764481c6f3ada8897efa7c6d2c9/src/data/quot.lean#L126" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/4aa3eee46f0c7764481c6f3ada8897efa7c6d2c9/src/data/quot.lean#L126">here</a> and this has been discussed on Zulip <a href="#narrow/stream/116395-maths/topic/Transfer.20homomorphism/near/128131542" title="#narrow/stream/116395-maths/topic/Transfer.20homomorphism/near/128131542">here</a>, <a href="#narrow/stream/116395-maths/topic/quotients.20and.20lifts.20for.20functions.20of.20arbitrary.20arity/near/150709555" title="#narrow/stream/116395-maths/topic/quotients.20and.20lifts.20for.20functions.20of.20arbitrary.20arity/near/150709555">here</a>, <a href="#narrow/stream/113489-new-members/topic/quotient.20of.20product/near/167512475" title="#narrow/stream/113489-new-members/topic/quotient.20of.20product/near/167512475">here</a> and <a href="#narrow/stream/113488-general/topic/computability/near/168199717" title="#narrow/stream/113488-general/topic/computability/near/168199717">here</a>.</p>
<p>My question today is, can I consider this inverse map to be "constructive"? After all, even though it apparently requires an axiom to define it in Lean, it is also the case that it has a computational interpretation (namely, the identity), because the computational representation of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi mathvariant="normal">/</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">A/R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span> is just that of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>. Since I don't actually know what it means to be "constructive", maybe a better question is: can this inverse be defined in HoTT without axioms? (Maybe <span class="user-mention" data-user-id="111080">@Floris van Doorn</span> <span class="user-mention" data-user-id="233147">@Ulrik Buchholtz</span>?)</p>

<a name="187318092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotients%20and%20products%20again/near/187318092" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/41780quotientsandproductsagain.html#187318092">Reid Barton (Feb 03 2020 at 23:52)</a>:</h4>
<p>(In HoTT, assume that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is a set/0-type and that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub><mi mathvariant="normal">/</mi><msub><mi>R</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_i/R_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is the ordinary set quotient.)</p>

<a name="187319055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotients%20and%20products%20again/near/187319055" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/41780quotientsandproductsagain.html#187319055">Reid Barton (Feb 04 2020 at 00:08)</a>:</h4>
<p>Another thing I don't really understand. Constructively, is there a difference between a quotient map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>A</mi><mi mathvariant="normal">/</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">A \to A/R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span> and a general surjective map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \to B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>? The map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>A</mi><mi mathvariant="normal">/</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">A \to A/R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span> satisfies "descent", whereas it seems like a general surjection might not. But I don't understand the proof in the HoTT book which claims to prove that the map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi mathvariant="normal">/</mi><mi>R</mi><mo>→</mo><mi>A</mi><mi mathvariant="normal">/</mi><mi mathvariant="normal">/</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">A/R \to A//R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mord">/</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span> is an isomorphism, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi mathvariant="normal">/</mi><mi mathvariant="normal">/</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">A//R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mord">/</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span> is the set of equivalence classes (Theorem 6.10.6).</p>

<a name="187319404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotients%20and%20products%20again/near/187319404" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/41780quotientsandproductsagain.html#187319404">Reid Barton (Feb 04 2020 at 00:14)</a>:</h4>
<p>Chris keeps bringing up the case where all the relations are the always true relation, so I guess the first question is whether truncation commutes with (infinite) products.</p>

<a name="187319656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotients%20and%20products%20again/near/187319656" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/41780quotientsandproductsagain.html#187319656">Reid Barton (Feb 04 2020 at 00:19)</a>:</h4>
<p>Oh, apparently this is exactly the axiom of choice? I don't know why I find this to be so confusing</p>

<a name="187320260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotients%20and%20products%20again/near/187320260" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/41780quotientsandproductsagain.html#187320260">Chris Hughes (Feb 04 2020 at 00:32)</a>:</h4>
<p>I got confused about the same thing and asked a question here about why you couldn't do choice constructively. I <a href="#narrow/stream/113488-general/topic/computability/near/170805335" title="#narrow/stream/113488-general/topic/computability/near/170805335">answered</a> it myself. If the domain is a quotient then you get contradictions if you do it the "computable" way. </p>
<p>If you consider the identity function from <code>trunc bool -&gt; trunc bool</code>, and try to make a <code>trunc (trunc bool -&gt; bool)</code> the "computable" way, then you end up with a function defined to be two different things on the same input.</p>

<a name="187333768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotients%20and%20products%20again/near/187333768" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/41780quotientsandproductsagain.html#187333768">Floris van Doorn (Feb 04 2020 at 06:30)</a>:</h4>
<p>I think saying that the computational interpretation of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi mathvariant="normal">/</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">A / R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span> is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> is misleading. Sure, that's how it is implemented in the untrusted evaluator of Lean, but of course you cannot constructively (or even classically) identify them. For example, with this "computational interpretation" you might think we can constructively define a map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi mathvariant="normal">/</mi><mi>R</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">A / R \to A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>, which of course, we cannot.</p>
<p>Maybe it's helpful to think about how it would be implemented in a cubical type theory, where you have points from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>, paths from the relation (so point in the context of an interval variable), and then compositions of those paths.</p>
<p>I'm quite sure that requiring an inverse to the map from the quotient-of-products to product-of-quotients is exactly the axiom of choice. To define the map in the other way, you have infinitely many elements in a quotient, and you need a choice function to assume they're all representatives so that you can define a function with them.</p>

<a name="187583575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotients%20and%20products%20again/near/187583575" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/41780quotientsandproductsagain.html#187583575">Jeremy Avigad (Feb 06 2020 at 20:07)</a>:</h4>
<p>I stumbled across exactly this question a little more than a year ago, and, coincidentally, asked some of the local HoTT / DTT people here about a couple of weeks ago.</p>
<p>The principle seems to me to be reasonably constructive, in it is compatible with code extraction (as you say, interpreting the map as the identity function). It is also equivalent to a natural generalization of the lifting property for quotients. </p>
<p>Andrew Swan points out that if you formulate it in the context of HoTT (using HITs for quotients), the principle implies choice. What follows is an email he sent me.</p>
<p>"I had another look at the axiom you asked about today. If I understand it right, then it does entail choice, at least in the presence of propositional truncation and quotients, as they would be defined in HoTT. The main idea is that given a family of types D : A -&gt; Set, we can define B to be the sigma type Σ A D and take the relation R to identify (a, d) and (a', d') when a = a'. Given a term of type Π (a : A) || D a ||, we can get a well defined function g: A -&gt; B/R. Then given an element of (A -&gt; B)/R' in the fibre of g, we can show that there merely exists a choice function for D, i.e. get a term of type || Π (a : A) (D a) ||. It was a good chance to practice my agda, so I did formalised version of the argument."</p>

<a name="187614136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quotients%20and%20products%20again/near/187614136" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/41780quotientsandproductsagain.html#187614136">Chris Hughes (Feb 07 2020 at 05:08)</a>:</h4>
<blockquote>
<p>The principle seems to me to be reasonably constructive, in it is compatible with code extraction (as you say, interpreting the map as the identity function). It is also equivalent to a natural generalization of the lifting property for quotients.</p>
</blockquote>
<p>It's not really compatible with code extraction because interpreting it as the identity is inconsistent. If I make a <code>meta def</code> using <code>quot.unquot</code> to give it the obvious computable interpretation, then I can write a <code>decidable true</code> instance that evaluates to <code>ff</code>.</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">quot</span> <span class="n">data</span><span class="bp">.</span><span class="n">setoid</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">quotient_choice</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">s</span> <span class="o">:</span> <span class="n">setoid</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">quotient</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="n">quotient</span> <span class="o">(</span><span class="bp">@</span><span class="n">pi_setoid</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">s</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">quotient</span><span class="bp">.</span><span class="n">mk</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">quot</span><span class="bp">.</span><span class="n">unquot</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">))</span>

<span class="c1">--applying choice to the identity map</span>
<span class="n">def</span> <span class="n">decidable_true</span>
  <span class="o">(</span><span class="n">quotient_choice</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">s</span> <span class="o">:</span> <span class="n">setoid</span> <span class="n">β</span><span class="o">]</span>
    <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">quotient</span> <span class="n">s</span><span class="o">),</span> <span class="n">quotient</span> <span class="o">(</span><span class="bp">@</span><span class="n">pi_setoid</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">s</span><span class="o">)))</span> <span class="o">:</span>
  <span class="n">decidable</span> <span class="n">true</span> <span class="o">:=</span>
<span class="c1">-- ⊤ is the always true relation</span>
<span class="k">by</span> <span class="n">letI</span> <span class="o">:</span> <span class="n">setoid</span> <span class="n">bool</span> <span class="o">:=</span> <span class="err">⊤</span><span class="bp">;</span> <span class="n">exact</span>
<span class="n">quot</span><span class="bp">.</span><span class="n">rec_on_subsingleton</span> <span class="o">(</span><span class="bp">@</span><span class="n">quotient_choice</span> <span class="o">(</span><span class="bp">@</span><span class="n">quotient</span> <span class="n">bool</span> <span class="err">⊤</span><span class="o">)</span> <span class="n">bool</span> <span class="err">⊤</span> <span class="n">id</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">decidable_of_iff</span> <span class="o">(</span><span class="n">f</span> <span class="err">⟦</span><span class="n">ff</span><span class="err">⟧</span> <span class="bp">=</span> <span class="n">f</span> <span class="err">⟦</span><span class="n">tt</span><span class="err">⟧</span><span class="o">)</span>
    <span class="o">(</span><span class="n">iff_true_intro</span> <span class="o">(</span><span class="n">congr_arg</span> <span class="n">f</span> <span class="o">(</span><span class="n">quotient</span><span class="bp">.</span><span class="n">sound</span> <span class="n">trivial</span><span class="o">))))</span>

<span class="bp">#</span><span class="kn">eval</span> <span class="n">decidable_true</span> <span class="bp">@</span><span class="n">quotient_choice</span> <span class="c1">--ff</span>
</pre></div>


{% endraw %}

{% include archive_update.html %}