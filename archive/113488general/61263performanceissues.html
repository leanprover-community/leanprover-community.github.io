---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/61263performanceissues.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/61263performanceissues.html">performance issues</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="170783022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/performance%20issues/near/170783022" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/61263performanceissues.html#170783022">Kenny Lau (Jul 13 2019 at 09:38)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="k">by</span> <span class="n">apply_instance</span> <span class="o">:</span> <span class="n">comm_ring</span> <span class="n">α</span><span class="o">)</span> <span class="c1">-- _inst_7</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="k">by</span> <span class="n">apply_instance</span> <span class="o">:</span> <span class="n">comm_ring</span> <span class="o">(</span><span class="n">mv_polynomial</span> <span class="n">σ</span> <span class="n">α</span><span class="o">))</span> <span class="c1">-- mv_polynomial.comm_ring</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="k">by</span> <span class="n">apply_instance</span> <span class="o">:</span> <span class="bp">_</span><span class="n">root_</span><span class="bp">.</span><span class="n">algebra</span> <span class="n">α</span> <span class="o">(</span><span class="n">mv_polynomial</span> <span class="n">σ</span> <span class="n">α</span><span class="o">))</span> <span class="c1">-- algebra.mv_polynomial α σ</span>
<span class="kn">set_option</span> <span class="n">pp</span><span class="bp">.</span><span class="n">implicit</span> <span class="n">true</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="bp">@</span><span class="err">«</span><span class="n">K</span><span class="err">ä</span><span class="n">hler</span><span class="err">»</span><span class="bp">.</span><span class="n">add_comm_group</span> <span class="n">α</span> <span class="o">(</span><span class="n">mv_polynomial</span> <span class="n">σ</span> <span class="n">α</span><span class="o">)</span> <span class="bp">_</span><span class="n">inst_7</span> <span class="n">mv_polynomial</span><span class="bp">.</span><span class="n">comm_ring</span> <span class="o">(</span><span class="n">algebra</span><span class="bp">.</span><span class="n">mv_polynomial</span> <span class="n">α</span> <span class="n">σ</span><span class="o">))</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">@«Kähler».add_comm_group α (@mv_polynomial σ α (@comm_ring.to_comm_semiring α _inst_7)) _inst_7</span>
<span class="cm">  (@mv_polynomial.comm_ring α σ (λ (a b : σ), _inst_6 a b) (λ (a b : α), _inst_8 a b) _inst_7)</span>
<span class="cm">  (@algebra.mv_polynomial α _inst_7 (λ (a b : α), _inst_8 a b) σ (λ (a b : σ), _inst_6 a b)) :</span>
<span class="cm">  add_comm_group</span>
<span class="cm">    (@«Kähler» α (@mv_polynomial σ α (@comm_ring.to_comm_semiring α _inst_7)) _inst_7</span>
<span class="cm">       (@mv_polynomial.comm_ring α σ (λ (a b : σ), _inst_6 a b) (λ (a b : α), _inst_8 a b) _inst_7)</span>
<span class="cm">       (@algebra.mv_polynomial α _inst_7 (λ (a b : α), _inst_8 a b) σ (λ (a b : σ), _inst_6 a b)))</span>
<span class="cm">-/</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="err">«</span><span class="n">K</span><span class="err">ä</span><span class="n">hler</span><span class="err">»</span><span class="bp">.</span><span class="n">add_comm_group</span> <span class="n">α</span> <span class="o">(</span><span class="n">mv_polynomial</span> <span class="n">σ</span> <span class="n">α</span><span class="o">))</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">@«Kähler».add_comm_group α (@mv_polynomial σ α (@comm_ring.to_comm_semiring α _inst_7)) _inst_7</span>
<span class="cm">  (@mv_polynomial.comm_ring α σ (λ (a b : σ), _inst_6 a b) (λ (a b : α), _inst_8 a b) _inst_7)</span>
<span class="cm">  (@algebra.mv_polynomial α _inst_7 (λ (a b : α), _inst_8 a b) σ (λ (a b : σ), _inst_6 a b)) :</span>
<span class="cm">  add_comm_group</span>
<span class="cm">    (@«Kähler» α (@mv_polynomial σ α (@comm_ring.to_comm_semiring α _inst_7)) _inst_7</span>
<span class="cm">       (@mv_polynomial.comm_ring α σ (λ (a b : σ), _inst_6 a b) (λ (a b : α), _inst_8 a b) _inst_7)</span>
<span class="cm">       (@algebra.mv_polynomial α _inst_7 (λ (a b : α), _inst_8 a b) σ (λ (a b : σ), _inst_6 a b)))</span>
<span class="cm">-/</span>
</pre></div>

<a name="170783024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/performance%20issues/near/170783024" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/61263performanceissues.html#170783024">Kenny Lau (Jul 13 2019 at 09:38)</a>:</h4>
<p>given that the first four checks are quick, why is the last one slow?</p>

<a name="170784002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/performance%20issues/near/170784002" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/61263performanceissues.html#170784002">Kenny Lau (Jul 13 2019 at 10:13)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> this is making me unable to do anything related to A^n</p>

<a name="170785541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/performance%20issues/near/170785541" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/61263performanceissues.html#170785541">Kevin Buzzard (Jul 13 2019 at 11:06)</a>:</h4>
<p><span class="user-mention" data-user-id="111080">@Floris van Doorn</span> is this anything to do with the timeouts I was having in Amsterdam?</p>

<a name="170785610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/performance%20issues/near/170785610" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/61263performanceissues.html#170785610">Kevin Buzzard (Jul 13 2019 at 11:09)</a>:</h4>
<p>Making instances for structures is an art and it definitely helps if you know how lean is filling in instances. Unification can struggle when presented with two defeq but not syntactically equal instances because it's defeq detector might not try hard enough. This means that if you make a new object like one forms or kaehler or whatever you want to call them, you should make sure that the instances that type class inference knows about are such that it has very little chance of getting into such a mess</p>

<a name="170785653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/performance%20issues/near/170785653" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/61263performanceissues.html#170785653">Kevin Buzzard (Jul 13 2019 at 11:10)</a>:</h4>
<p>Floris taught me this in Amsterdam but I don't know if it's your problem</p>

<a name="170786393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/performance%20issues/near/170786393" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/61263performanceissues.html#170786393">Kevin Buzzard (Jul 13 2019 at 11:35)</a>:</h4>
<p>I had more instances than I needed and this was messing things up. Floris fixed it by changing the priority of some of the easier ones to something lower than the default</p>

<a name="170786547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/performance%20issues/near/170786547" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/61263performanceissues.html#170786547">Kevin Buzzard (Jul 13 2019 at 11:40)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> if you look at the type class trace can you see explicitly which instance is being found? Is it syntactically equal to the one you use when it's quick? In other words, is it taking a long time to find syntactically the right instance, or a short time to find a defeq but not syntactically equal instance?</p>

<a name="170786560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/performance%20issues/near/170786560" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/61263performanceissues.html#170786560">Kevin Buzzard (Jul 13 2019 at 11:41)</a>:</h4>
<p>If the latter then you can meddle with the instance priorities, or make some instances local instances, to change the behaviour</p>

<a name="170806368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/performance%20issues/near/170806368" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/61263performanceissues.html#170806368">Floris van Doorn (Jul 13 2019 at 21:45)</a>:</h4>
<p>This might be the same problem. <br>
My suspicion in the 5th <code>#check</code> maybe some implicit (type-class) arguments are different when doing the type-class search (compared to the first 4 checks), which causes trouble for Lean.</p>

<a name="170806372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/performance%20issues/near/170806372" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/61263performanceissues.html#170806372">Floris van Doorn (Jul 13 2019 at 21:45)</a>:</h4>
<p>The problem I had with Kevin in the Perfectoid Project was that we needed to synthesize that some function <code>f : α → β</code> in their project was a group homomorphism. There was an instance <code>f.is_group_hom</code> saying exactly that, except that the <em>instance</em> that <code>β</code> was a group was different in the instance and in the type class problem. In the existing instance it was <code>comm_group.to_group β.comm_group</code> and in the type class problem we had is was <code>comm_group.to_group (linear_ordered_comm_group.to_comm_group β.linear_ordered_comm_group)</code>. Here <code>linear_ordered_comm_group</code> is a new class in their project, extending <code>comm_group</code>, with the old structure command turned on. Now the instance of <code>β.linear_ordered_comm_group</code> was defined extending <code>β.comm_group</code>, which means that the equality <code>linear_ordered_comm_group.to_comm_group β.linear_ordered_comm_group = β.comm_group</code> holds definitionally. However, the only way to establish this definitional equality is to establish the definitional equality of all fields. I don't know exactly why, but this was really hard for Lean during type class resolution. It caused a deterministic time-out.</p>

<a name="170806420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/performance%20issues/near/170806420" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/61263performanceissues.html#170806420">Floris van Doorn (Jul 13 2019 at 21:46)</a>:</h4>
<p>The reasons I know/suspect that this was the problem:</p>
<ul>
<li>The timeout disappeared when we explicitly gave this (and only this) instance</li>
<li>The type class trace showed that the instance <code>f.is_group_hom</code> is tried, but never said <code>failed is_def_eq</code>. I think that indicates the timeout happened while this instance was checked.</li>
</ul>

<a name="170806491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/performance%20issues/near/170806491" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/61263performanceissues.html#170806491">Floris van Doorn (Jul 13 2019 at 21:49)</a>:</h4>
<p>Therefore I think we should adhere to the following guideline, if possible:</p>
<blockquote>
<p>If you prove <code>instA : classA X</code> and <code>instB : classB X</code> and <code>classB</code> extends <code>classA</code> then <code>instA</code> should not be an instance. If the <code>instA</code> instance is used, it can cause extra unnecessary unification work during type class inference (if those instances are used as <em>arguments</em> of other definitions/instances). This can cause (deterministic) timeouts. It is especially bad with the old structure command option, and it even happens when both possible instances of <code>classA</code> are definitionally equal.</p>
</blockquote>
<p>One problem is that this is not always possible: maybe <code>instA</code> needs fewer or weaker hypotheses. But we should be aware of this potential problem.</p>

<a name="170806502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/performance%20issues/near/170806502" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/61263performanceissues.html#170806502">Floris van Doorn (Jul 13 2019 at 21:49)</a>:</h4>
<p>This guideline is definitely violated for <code>mv_polynomial</code>, so maybe this is the same issue Kenny is facing.</p>

<a name="170806569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/performance%20issues/near/170806569" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/61263performanceissues.html#170806569">Floris van Doorn (Jul 13 2019 at 21:51)</a>:</h4>
<p>As an aside, the reason we were in this mess was that I advised Kevin to use the old structure command for <code>linear_ordered_comm_group</code>, to be more in the mathlib style, and this caused the problem. With the new structure command the issue didn't exist, presumably because the definitional equality <code>linear_ordered_comm_group.to_comm_group β.linear_ordered_comm_group = β.comm_group</code> is really easy in that case (since <code>linear_ordered_comm_group.to_comm_group</code> is then a field of the structure.</p>


{% endraw %}

{% include archive_update.html %}