---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/72553outparam.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html">out_param</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="160994372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/160994372" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#160994372">Sebastien Gouezel (Mar 17 2019 at 11:05)</a>:</h4>
<p>I thought that <code>out_param</code> should have disappeared from modules, but in <code>analysis.normed_space.basic</code> there are the following lines:</p>
<div class="codehilite"><pre><span></span><span class="n">class</span> <span class="n">normed_space</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">out_param</span> <span class="err">$</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">out_param</span> <span class="err">$</span> <span class="n">normed_field</span> <span class="n">α</span><span class="o">]</span>
  <span class="kn">extends</span> <span class="n">normed_group</span> <span class="n">β</span><span class="o">,</span> <span class="n">vector_space</span> <span class="n">α</span> <span class="n">β</span> <span class="o">:=</span>
</pre></div>


<p>I don't understand them, which is not a big deal, but I wanted to check that they should not be changed.</p>

<a name="160994379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/160994379" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#160994379">Patrick Massot (Mar 17 2019 at 11:05)</a>:</h4>
<p>I asked the same question last week...</p>

<a name="160994380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/160994380" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#160994380">Sebastien Gouezel (Mar 17 2019 at 11:05)</a>:</h4>
<p>And what answer did you get?</p>

<a name="160994432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/160994432" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#160994432">Patrick Massot (Mar 17 2019 at 11:07)</a>:</h4>
<p>none</p>

<a name="160995259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/160995259" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#160995259">Kevin Buzzard (Mar 17 2019 at 11:34)</a>:</h4>
<p><a href="#narrow/stream/116395-maths/topic/out_param.20again/near/160275177" title="#narrow/stream/116395-maths/topic/out_param.20again/near/160275177">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/out_param.20again/near/160275177</a></p>

<a name="160995442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/160995442" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#160995442">Sebastien Gouezel (Mar 17 2019 at 11:40)</a>:</h4>
<p>Thansk for the pointer. Indeed, this is the very same question!</p>

<a name="164911736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164911736" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164911736">Sebastien Gouezel (May 05 2019 at 09:48)</a>:</h4>
<p>I am having problems with out_param in the following situation. Suppose <code>M</code> is a <code>C^1</code> manifold, with respect to a base field <code>k</code> and a model vector space <code>E</code>. I want to define the tangent space at a point <code>x</code>, by taking equivalence classes of vectors in charts. The maths are not important. The point is that <code>k</code> is relevant (you may want to consider a complex manifold as a real manifold), so just as for linear maps it should be explicit in the definition of the tangent space. However, there will always be one single model space <code>E</code>, so I don't want to have it as an explicit parameter in the definition: it should rather be inferred from the manifold instance in the context. I tried to write this as (with everything in <code>Type</code> to avoid potential universe issues):</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">tangent_space_unfolded</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">nondiscrete_normed_field</span> <span class="n">k</span><span class="o">]</span> <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="n">out_param</span> <span class="err">$</span> <span class="kt">Type</span><span class="o">}</span>
  <span class="o">[</span><span class="n">out_param</span> <span class="err">$</span> <span class="n">normed_space</span> <span class="n">k</span> <span class="n">E</span><span class="o">]</span>
  <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">manifold</span> <span class="n">E</span> <span class="o">(</span><span class="n">times_cont_diff_groupoid</span> <span class="mi">1</span> <span class="n">k</span> <span class="n">E</span><span class="o">)</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
  <span class="o">{</span><span class="n">e</span> <span class="o">:</span> <span class="n">local_homeomorph</span> <span class="n">M</span> <span class="n">E</span> <span class="bp">//</span> <span class="n">e</span> <span class="err">∈</span> <span class="n">chart</span> <span class="o">(</span><span class="n">times_cont_diff_groupoid</span> <span class="mi">1</span> <span class="n">k</span> <span class="n">E</span><span class="o">)</span> <span class="n">M</span> <span class="bp">∧</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">e</span><span class="bp">.</span><span class="n">source</span><span class="o">}</span> <span class="bp">×</span> <span class="n">E</span>
</pre></div>


<p>(notice the <code>out_param</code> on <code>E</code> and <code>normed_space k E</code>). However, when I try to use this definition, <code>E</code> is not inferred. For instance, with</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">tangent_vector_equiv_rel</span> <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">nondiscrete_normed_field</span> <span class="n">k</span><span class="o">]</span> <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_space</span> <span class="n">k</span> <span class="n">E</span><span class="o">]</span>
  <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">manifold</span> <span class="n">E</span> <span class="o">(</span><span class="n">times_cont_diff_groupoid</span> <span class="mi">1</span> <span class="n">k</span> <span class="n">E</span><span class="o">)</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">tangent_space_unfolded</span> <span class="n">k</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">true</span>
</pre></div>


<p>I get the red squiggle under <code>p : tangent_space_unfolded k x</code> with the complaint</p>
<div class="codehilite"><pre><span></span><span class="n">don&#39;t</span> <span class="n">know</span> <span class="n">how</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">placeholder</span>
<span class="kn">context</span><span class="o">:</span>
<span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_1</span> <span class="o">:</span> <span class="n">nondiscrete_normed_field</span> <span class="n">k</span><span class="o">,</span>
<span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_2</span> <span class="o">:</span> <span class="n">normed_space</span> <span class="n">k</span> <span class="n">E</span><span class="o">,</span>
<span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_3</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">M</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_4</span> <span class="o">:</span> <span class="n">manifold</span> <span class="n">E</span> <span class="o">(</span><span class="n">times_cont_diff_groupoid</span> <span class="mi">1</span> <span class="n">k</span> <span class="n">E</span><span class="o">)</span> <span class="n">M</span><span class="o">,</span>
<span class="n">x</span> <span class="o">:</span> <span class="n">M</span>
<span class="err">⊢</span> <span class="n">out_param</span> <span class="kt">Type</span>
</pre></div>


<p>If I make the parameter <code>E</code> explicit, on the other hand, everything is fine.</p>
<p>There are very few places in the library where <code>out_param</code> is used, so I don't have enough examples (or documentation) to understand what the right syntax should be. Is it impossible to do what I would like?</p>

<a name="164912212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912212" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912212">Mario Carneiro (May 05 2019 at 10:01)</a>:</h4>
<p>out_param goes on instances and class definitions</p>

<a name="164912263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912263" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912263">Mario Carneiro (May 05 2019 at 10:02)</a>:</h4>
<p>you can't just put it on a single definition, it's tied in to the whole instance search problem for that typeclass</p>

<a name="164912316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912316" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912316">Mario Carneiro (May 05 2019 at 10:04)</a>:</h4>
<p>In this case, if you want <code>k</code> to determine <code>E</code> in <code>normed_space</code>, you would need to mark <code>E</code> as <code>out_param</code> in the definition of <code>normed_space</code>. I guess that's not what you want</p>

<a name="164912334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912334" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912334">Sebastien Gouezel (May 05 2019 at 10:04)</a>:</h4>
<p>I don't want <code>k</code> to determine <code>E</code>, I want the manifold instance together with <code>k</code> to determine <code>E</code>.</p>

<a name="164912354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912354" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912354">Mario Carneiro (May 05 2019 at 10:05)</a>:</h4>
<p>but the manifold instance already mentions E</p>

<a name="164912407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912407" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912407">Mario Carneiro (May 05 2019 at 10:06)</a>:</h4>
<p>So you want to trigger the search <code>manifold ?E (times_cont_diff_groupoid 1 k ?E) M</code>?</p>

<a name="164912409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912409" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912409">Sebastien Gouezel (May 05 2019 at 10:06)</a>:</h4>
<p>Yes. I guess I don't understand at all what out_param does. What I would like to happen when Lean encounters <code>tangent_space k x</code>: it looks in the context for a instance of <code>manifold ?m1 (times_cont_diff_groupoid 1 k ?m1) M</code>, and if it finds one it picks it at <code>E</code>.</p>

<a name="164912420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912420" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912420">Mario Carneiro (May 05 2019 at 10:07)</a>:</h4>
<p>or is it <code>manifold ?E ?X M</code></p>

<a name="164912424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912424" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912424">Mario Carneiro (May 05 2019 at 10:08)</a>:</h4>
<p>what is that second argument?</p>

<a name="164912467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912467" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912467">Sebastien Gouezel (May 05 2019 at 10:08)</a>:</h4>
<p>It is really <code>manifold ?m1 (times_cont_diff_groupoid 1 k ?m1) M</code> that it should look for.</p>

<a name="164912470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912470" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912470">Sebastien Gouezel (May 05 2019 at 10:08)</a>:</h4>
<p>It is a groupoid, i.e., a set of local homeomorphisms between <code>M</code> and <code>E</code>.</p>

<a name="164912539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912539" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912539">Mario Carneiro (May 05 2019 at 10:10)</a>:</h4>
<p>can you make another class?</p>

<a name="164912541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912541" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912541">Mario Carneiro (May 05 2019 at 10:10)</a>:</h4>
<p>like <code>model_space M ?E</code> or something</p>

<a name="164912543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912543" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912543">Mario Carneiro (May 05 2019 at 10:10)</a>:</h4>
<p>that implies <code>manifold ?E (times_cont_diff_groupoid 1 k ?E) M</code></p>

<a name="164912624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912624" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912624">Mario Carneiro (May 05 2019 at 10:13)</a>:</h4>
<p>I am wary of that typeclass arg. You can probably make lean search for it because lean typeclass search has no hygiene, but that's also why typeclass search is starting to fall over in mathlib</p>

<a name="164912628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912628" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912628">Sebastien Gouezel (May 05 2019 at 10:13)</a>:</h4>
<p>What I could do is mark <code>E</code> as out_param in the definition of manifold. Except that this is not OK as there can be different model spaces depending on whether one considers a space as a real or complex manifold. So, it would really have to depend on both <code>k</code> and <code>M</code>. I can build a new class <code>smooth_manifold k ?E M</code> with <code>E</code> as an out_param, and see how this goes.</p>

<a name="164912685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912685" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912685">Sebastien Gouezel (May 05 2019 at 10:15)</a>:</h4>
<p>Being a manifold is definitely a type class, just as good as being a ring or a topological space. The only difference is that it has more structure built in, so it depends on more stuff but that's the way math is.</p>

<a name="164913172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164913172" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164913172">Mario Carneiro (May 05 2019 at 10:28)</a>:</h4>
<p>The problem isn't the math, it's the use of <code>(times_cont_diff_groupoid 1 k ?E)</code> as one of the arguments to the class. It's too dependent for my liking (it's not even a type IIUC)</p>

<a name="164913454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164913454" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164913454">Sebastien Gouezel (May 05 2019 at 10:36)</a>:</h4>
<p>For each groupoid <code>G</code>, you have a notion of manifold based on this groupoid. For instance, <code>C^infty</code> manifolds, or manifolds with boundary, or manifold with corners, or contact manifolds, or orientable manifolds, or whatever. Each of these structures gives you access to some objects on the manifold. My idea is to set up a set of instances between these structures, so that when you have a contact manifold then you also get automatically a smooth structure, an oriented structure, and so on, just by typeclass inference. I have the impression that this is precisely the kind of things at which typeclass inference is good, but maybe I am missing something.</p>

<a name="164913667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164913667" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164913667">Mario Carneiro (May 05 2019 at 10:43)</a>:</h4>
<p>could you put the definition of <code>manifold</code>? I'm confused about the type of everything here</p>

<a name="164915110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164915110" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164915110">Sebastien Gouezel (May 05 2019 at 11:24)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">structure_groupoid</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">members</span>      <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">local_homeomorph</span> <span class="n">α</span> <span class="n">α</span><span class="o">))</span>
<span class="o">(</span><span class="n">comp</span>         <span class="o">:</span> <span class="bp">∀</span><span class="n">e</span> <span class="n">e&#39;</span> <span class="o">:</span> <span class="n">local_homeomorph</span> <span class="n">α</span> <span class="n">α</span><span class="o">,</span> <span class="n">e</span> <span class="err">∈</span> <span class="n">members</span> <span class="bp">→</span> <span class="n">e&#39;</span> <span class="err">∈</span> <span class="n">members</span> <span class="bp">→</span> <span class="n">e</span> <span class="bp">→</span><span class="err">ₕ</span> <span class="n">e&#39;</span> <span class="err">∈</span> <span class="n">members</span><span class="o">)</span>
<span class="o">(</span><span class="n">inv</span>          <span class="o">:</span> <span class="bp">∀</span><span class="n">e</span> <span class="o">:</span> <span class="n">local_homeomorph</span> <span class="n">α</span> <span class="n">α</span><span class="o">,</span> <span class="n">e</span> <span class="err">∈</span> <span class="n">members</span> <span class="bp">→</span> <span class="n">e</span><span class="bp">.</span><span class="n">symm</span> <span class="err">∈</span> <span class="n">members</span><span class="o">)</span>
<span class="o">(</span><span class="n">id_mem</span>       <span class="o">:</span> <span class="n">local_homeomorph</span><span class="bp">.</span><span class="n">refl</span> <span class="n">α</span> <span class="err">∈</span> <span class="n">members</span><span class="o">)</span>
<span class="o">(</span><span class="n">locality</span>     <span class="o">:</span> <span class="bp">∀</span><span class="n">e</span> <span class="o">:</span> <span class="n">local_homeomorph</span> <span class="n">α</span> <span class="n">α</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span><span class="n">x</span> <span class="err">∈</span> <span class="n">e</span><span class="bp">.</span><span class="n">source</span><span class="o">,</span> <span class="bp">∃</span><span class="n">s</span><span class="o">,</span> <span class="n">is_open</span> <span class="n">s</span> <span class="bp">∧</span>
                  <span class="n">x</span> <span class="err">∈</span> <span class="n">s</span> <span class="bp">∧</span> <span class="n">e</span><span class="bp">.</span><span class="n">restr</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">members</span><span class="o">)</span> <span class="bp">→</span> <span class="n">e</span> <span class="err">∈</span> <span class="n">members</span><span class="o">)</span>
<span class="o">(</span><span class="n">eq_on_source</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">e</span> <span class="n">e&#39;</span> <span class="o">:</span> <span class="n">local_homeomorph</span> <span class="n">α</span> <span class="n">α</span><span class="o">,</span> <span class="n">e</span> <span class="err">∈</span> <span class="n">members</span> <span class="bp">→</span> <span class="n">e&#39;</span> <span class="bp">≈</span> <span class="n">e</span> <span class="bp">→</span> <span class="n">e&#39;</span> <span class="err">∈</span> <span class="n">members</span><span class="o">)</span>

<span class="n">class</span> <span class="n">manifold</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">structure_groupoid</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">chart</span>  <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">local_homeomorph</span> <span class="n">β</span> <span class="n">α</span><span class="o">))</span>
<span class="o">(</span><span class="n">compat</span> <span class="o">:</span> <span class="bp">∀</span><span class="n">e</span> <span class="n">e&#39;</span> <span class="o">:</span> <span class="n">local_homeomorph</span> <span class="n">β</span> <span class="n">α</span><span class="o">,</span> <span class="n">e</span> <span class="err">∈</span> <span class="n">chart</span> <span class="bp">→</span> <span class="n">e&#39;</span> <span class="err">∈</span> <span class="n">chart</span> <span class="bp">→</span> <span class="n">e</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">→</span><span class="err">ₕ</span> <span class="n">e&#39;</span> <span class="err">∈</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">cover</span>  <span class="o">:</span> <span class="bp">∀</span><span class="n">x</span><span class="o">,</span> <span class="bp">∃</span><span class="n">e</span> <span class="o">:</span> <span class="n">local_homeomorph</span> <span class="n">β</span> <span class="n">α</span><span class="o">,</span> <span class="n">e</span> <span class="err">∈</span> <span class="n">chart</span> <span class="bp">∧</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">e</span><span class="bp">.</span><span class="n">source</span><span class="o">)</span>
</pre></div>


<p>One could also go for a manifold structure just by picking the charts and the cover condition (this would be a <code>has_chart</code> class, say, similar to <code>has_add</code> and friends), and say that the manifold structure is compatible with a given groupoid if the compat condition holds (in the same way as one can add properties extending <code>has_add</code> making it into a group, a ring, a module, and so on).</p>

<a name="164918445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164918445" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164918445">Mario Carneiro (May 05 2019 at 13:00)</a>:</h4>
<p>Okay, I see. I guess this definition of <code>manifold</code> differs from the earlier one though, since <code>α</code> is implicit now but the other one had three explicit args</p>

<a name="164918467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164918467" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164918467">Mario Carneiro (May 05 2019 at 13:02)</a>:</h4>
<p>The order of inference still seems a bit weird to me. Can't manifolds have multiple model vector spaces? Like a manifold with different dimensions at different points</p>

<a name="164918521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164918521" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164918521">Sebastien Gouezel (May 05 2019 at 13:02)</a>:</h4>
<p>Yes, you're right. I had tried to make the argument explicit to see if it made a difference, but it didn't so I came back to my original definition with alpha implicit.</p>

<a name="164918552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164918552" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164918552">Mario Carneiro (May 05 2019 at 13:04)</a>:</h4>
<p>It seems pretty natural to me that you should say M is a C^1 R^n manifold, and both R,n,M are required args</p>

<a name="164918598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164918598" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164918598">Sebastien Gouezel (May 05 2019 at 13:04)</a>:</h4>
<p>In the most standard definition, the model space is the same everywhere (and so the dimension is the same everywhere). If you really want to have a manifold with different local dimensions with this definition, you can by taking as a model space the union of all R^n over varying n, but this is not very natural.</p>

<a name="164918604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164918604" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164918604">Mario Carneiro (May 05 2019 at 13:04)</a>:</h4>
<p>that's not a vector space</p>

<a name="164918609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164918609" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164918609">Sebastien Gouezel (May 05 2019 at 13:04)</a>:</h4>
<p>The thing is that the groupoid <code>G</code> already contains the information about alpha.</p>

<a name="164918627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164918627" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164918627">Sebastien Gouezel (May 05 2019 at 13:05)</a>:</h4>
<p>The model space does not need to be a vector space (and in many applications it isn't)</p>

<a name="164918923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164918923" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164918923">Sebastien Gouezel (May 05 2019 at 13:12)</a>:</h4>
<p>An important example to keep in mind, however, is a complex manifold of dimension <code>n</code>, modelled over <code>C^n</code>, that you also want to think of as a manifold of dimension <code>2n</code> modelled over <code>R^{2n}</code>. So not everything can be implicit.</p>

<a name="164918936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164918936" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164918936">Mario Carneiro (May 05 2019 at 13:13)</a>:</h4>
<p>I think I want this definition to be explicit in all the args k E G M</p>

<a name="164918986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164918986" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164918986">Mario Carneiro (May 05 2019 at 13:14)</a>:</h4>
<p>but you should keep things variable when possible. For example <code>tangent_space_unfolded</code> seems to be unnecessarily specializing on the groupoid</p>

<a name="164919128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164919128" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164919128">Mario Carneiro (May 05 2019 at 13:18)</a>:</h4>
<p>Even if there is "only one" model space up to isomorphism doesn't mean there's only one up to defeq</p>

<a name="164919149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164919149" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164919149">Mario Carneiro (May 05 2019 at 13:19)</a>:</h4>
<p>In particular I'm sure there will be ways to combine stuff in mathlib to get other isomorphic things like (R^2)^n that we also want to talk about</p>

<a name="164920531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164920531" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164920531">Sebastien Gouezel (May 05 2019 at 13:57)</a>:</h4>
<p>You want to be able to speak of the tangent space to many manifolds, for instance to C^infty manifolds or to contact manifolds. If there is an instance saying that a C^infty manifold is a C^1 manifold, or that a contact manifold is a C^1 manifold, then you get the tangent space for all of them at once.</p>

<a name="164922955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164922955" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164922955">Mario Carneiro (May 05 2019 at 14:59)</a>:</h4>
<p>I mean that you have specialized to C^1 but the definition works in any groupoid, or at least that part of it does</p>

<a name="164923063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164923063" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164923063">Mario Carneiro (May 05 2019 at 15:01)</a>:</h4>
<p>Also, given that the C^1 groupoid is data here, I think that those instances you just said are going to cause diamond problems</p>

<a name="164923205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164923205" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164923205">Mario Carneiro (May 05 2019 at 15:04)</a>:</h4>
<p>Looking at your definition of manifold, it seems like <code>G</code> isn't actually necessary to define the manifold itself. You can have one manifold structure and assert that it is compatible with a variety of groupoids</p>

<a name="164923296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164923296" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164923296">Mario Carneiro (May 05 2019 at 15:06)</a>:</h4>
<p>That also solves the problem of these composite constraints in the typeclass, since you then have <code>[manifold A B] [is_C1_manifold A B]</code> instead of <code>[manifold A (C1_groupoid A) B]</code></p>

<a name="164923307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164923307" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164923307">Mario Carneiro (May 05 2019 at 15:07)</a>:</h4>
<p>where <code>is_C1_manifold</code> is a Prop</p>

<a name="164923427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164923427" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164923427">Sebastien Gouezel (May 05 2019 at 15:11)</a>:</h4>
<p>I agree it is a good idea to separate the manifold structure, i.e., the data given by the charts, from the regularity of the charts, i.e., the fact that the charts belong to some groupoid. I'll try this route, thanks!</p>

<a name="164924256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164924256" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164924256">Sebastien Gouezel (May 05 2019 at 15:34)</a>:</h4>
<p>In fact, I am not so sure I gain anything with this. The two options are</p>
<ul>
<li>Just a typeclass <code>[manifold A G B]</code>, which contains data (the charts) and a proposition (the fact that the changes of charts belong to <code>G</code>)</li>
<li>Two typeclasses, <code>[manifold A B]</code> containing the charts, and <code>[has_smoothness_class A G B]</code> (assuming <code>[manifold A B]</code>), which is only Prop, asserting that the changes of charts belong to <code>G</code>.</li>
</ul>
<p>Whe one sets up instances, with the second point of view the set of charts is fixed, and one only asserts, say, that if a manifold is C^oo then it is C^1 for the same charts. In the first approach, one would get an instance from <code>[manifold A (C^oo) B]</code> to <code>[manifold A C^1 B]</code>, keeping the same charts but asserting that they belong to the larger groupoid <code>C^1</code>. I don't see why the first approach would give rise to diamonds, as the data between the instances does not change, so whatever the path between the instances one should get defeq stuff, right?</p>

<a name="164925952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164925952" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164925952">Mario Carneiro (May 05 2019 at 16:20)</a>:</h4>
<p>In the first approach, the manifold itself is different when it is inferred by a different route</p>

<a name="164925958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164925958" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164925958">Mario Carneiro (May 05 2019 at 16:20)</a>:</h4>
<p>because the manifold instance depends on G</p>

<a name="164926035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164926035" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164926035">Mario Carneiro (May 05 2019 at 16:22)</a>:</h4>
<p>I guess you are saying that the typeclass instance itself might not be defeq but the <code>charts</code> projection is</p>

<a name="164926046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164926046" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164926046">Sebastien Gouezel (May 05 2019 at 16:22)</a>:</h4>
<p>I don't get it. The manifold is made of data (the charts) and Props. Whatever way you go, you get the same data (it does not change through the instances), and the props are irrelevant. How could it not be defeq?</p>

<a name="164926065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164926065" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164926065">Mario Carneiro (May 05 2019 at 16:23)</a>:</h4>
<p>The manifold lives in a different type</p>

<a name="164926120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164926120" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164926120">Mario Carneiro (May 05 2019 at 16:24)</a>:</h4>
<p><code>manifold A (C1_groupoid A (C1_of_C^oo)) B</code> vs <code>manifold A (C1_groupoid A (C1_of_C^2 (C^2_of_C^oo))) B</code> or something</p>

<a name="164926147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164926147" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164926147">Mario Carneiro (May 05 2019 at 16:25)</a>:</h4>
<p>because the dependencies are different, these can't even be propositionally equal</p>

<a name="164927540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164927540" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164927540">Sebastien Gouezel (May 05 2019 at 17:03)</a>:</h4>
<p>I still don't get it, sorry, I am a little bit slow. Suppose you have three instances</p>
<div class="codehilite"><pre><span></span><span class="kn">instance</span> <span class="n">C1_of_C3</span> <span class="o">[</span><span class="n">manifold</span> <span class="o">(</span><span class="n">C</span><span class="err">^</span><span class="mi">3</span><span class="bp">_</span><span class="n">groupoid</span> <span class="n">E</span><span class="o">)</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">manifold</span> <span class="o">(</span><span class="n">C</span><span class="err">^</span><span class="mi">1</span><span class="bp">_</span><span class="n">groupoid</span> <span class="n">E</span><span class="o">)</span> <span class="n">M</span>
<span class="kn">instance</span> <span class="n">C2_of_C3</span> <span class="o">[</span><span class="n">manifold</span> <span class="o">(</span><span class="n">C</span><span class="err">^</span><span class="mi">3</span><span class="bp">_</span><span class="n">groupoid</span> <span class="n">E</span><span class="o">)</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">manifold</span> <span class="o">(</span><span class="n">C</span><span class="err">^</span><span class="mi">2</span><span class="bp">_</span><span class="n">groupoid</span> <span class="n">E</span><span class="o">)</span> <span class="n">M</span>
<span class="kn">instance</span> <span class="n">C1_of_C2</span> <span class="o">[</span><span class="n">manifold</span> <span class="o">(</span><span class="n">C</span><span class="err">^</span><span class="mi">2</span><span class="bp">_</span><span class="n">groupoid</span> <span class="n">E</span><span class="o">)</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">manifold</span> <span class="o">(</span><span class="n">C</span><span class="err">^</span><span class="mi">1</span><span class="bp">_</span><span class="n">groupoid</span> <span class="n">E</span><span class="o">)</span> <span class="n">M</span>
</pre></div>


<p>Then the path C1_of_C3 seems to me to be completely equivalent to the composition of C2_of_C3 and C1_of_C2. And the types do not seem to depend on the chosen path.</p>

<a name="164928029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164928029" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164928029">Mario Carneiro (May 05 2019 at 17:17)</a>:</h4>
<p>Actually I think I'm the one that's slow. Feel free to ignore my ramblings, I must be tired. I think you are right. However, this kind of instance search seems like a bad idea - there are lots and lots of values of k in C^k, and I'm sure in the right context you will be able to get some silliness like a search for <code>has_zero nat</code> ending up at <code>manifold (C^57_groupoid R) nat</code></p>

<a name="164928400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164928400" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164928400">Sebastien Gouezel (May 05 2019 at 17:29)</a>:</h4>
<p>I am only planning to register the ones with 0, 1 and infinity. And prove the general statement, but not register it as an instance (if necessary, it can be registered locally).</p>


{% endraw %}
