---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/72553outparam.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html">out_param</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="160994372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/160994372" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#160994372">Sebastien Gouezel (Mar 17 2019 at 11:05)</a>:</h4>
<p>I thought that <code>out_param</code> should have disappeared from modules, but in <code>analysis.normed_space.basic</code> there are the following lines:</p>
<div class="codehilite"><pre><span></span><span class="n">class</span> <span class="n">normed_space</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">out_param</span> <span class="err">$</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">out_param</span> <span class="err">$</span> <span class="n">normed_field</span> <span class="n">α</span><span class="o">]</span>
  <span class="kn">extends</span> <span class="n">normed_group</span> <span class="n">β</span><span class="o">,</span> <span class="n">vector_space</span> <span class="n">α</span> <span class="n">β</span> <span class="o">:=</span>
</pre></div>


<p>I don't understand them, which is not a big deal, but I wanted to check that they should not be changed.</p>

<a name="160994379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/160994379" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#160994379">Patrick Massot (Mar 17 2019 at 11:05)</a>:</h4>
<p>I asked the same question last week...</p>

<a name="160994380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/160994380" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#160994380">Sebastien Gouezel (Mar 17 2019 at 11:05)</a>:</h4>
<p>And what answer did you get?</p>

<a name="160994432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/160994432" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#160994432">Patrick Massot (Mar 17 2019 at 11:07)</a>:</h4>
<p>none</p>

<a name="160995259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/160995259" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#160995259">Kevin Buzzard (Mar 17 2019 at 11:34)</a>:</h4>
<p><a href="#narrow/stream/116395-maths/topic/out_param.20again/near/160275177" title="#narrow/stream/116395-maths/topic/out_param.20again/near/160275177">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/out_param.20again/near/160275177</a></p>

<a name="160995442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/160995442" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#160995442">Sebastien Gouezel (Mar 17 2019 at 11:40)</a>:</h4>
<p>Thansk for the pointer. Indeed, this is the very same question!</p>

<a name="164911736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164911736" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164911736">Sebastien Gouezel (May 05 2019 at 09:48)</a>:</h4>
<p>I am having problems with out_param in the following situation. Suppose <code>M</code> is a <code>C^1</code> manifold, with respect to a base field <code>k</code> and a model vector space <code>E</code>. I want to define the tangent space at a point <code>x</code>, by taking equivalence classes of vectors in charts. The maths are not important. The point is that <code>k</code> is relevant (you may want to consider a complex manifold as a real manifold), so just as for linear maps it should be explicit in the definition of the tangent space. However, there will always be one single model space <code>E</code>, so I don't want to have it as an explicit parameter in the definition: it should rather be inferred from the manifold instance in the context. I tried to write this as (with everything in <code>Type</code> to avoid potential universe issues):</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">tangent_space_unfolded</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">nondiscrete_normed_field</span> <span class="n">k</span><span class="o">]</span> <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="n">out_param</span> <span class="err">$</span> <span class="kt">Type</span><span class="o">}</span>
  <span class="o">[</span><span class="n">out_param</span> <span class="err">$</span> <span class="n">normed_space</span> <span class="n">k</span> <span class="n">E</span><span class="o">]</span>
  <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">manifold</span> <span class="n">E</span> <span class="o">(</span><span class="n">times_cont_diff_groupoid</span> <span class="mi">1</span> <span class="n">k</span> <span class="n">E</span><span class="o">)</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
  <span class="o">{</span><span class="n">e</span> <span class="o">:</span> <span class="n">local_homeomorph</span> <span class="n">M</span> <span class="n">E</span> <span class="bp">//</span> <span class="n">e</span> <span class="err">∈</span> <span class="n">chart</span> <span class="o">(</span><span class="n">times_cont_diff_groupoid</span> <span class="mi">1</span> <span class="n">k</span> <span class="n">E</span><span class="o">)</span> <span class="n">M</span> <span class="bp">∧</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">e</span><span class="bp">.</span><span class="n">source</span><span class="o">}</span> <span class="bp">×</span> <span class="n">E</span>
</pre></div>


<p>(notice the <code>out_param</code> on <code>E</code> and <code>normed_space k E</code>). However, when I try to use this definition, <code>E</code> is not inferred. For instance, with</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">tangent_vector_equiv_rel</span> <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">nondiscrete_normed_field</span> <span class="n">k</span><span class="o">]</span> <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_space</span> <span class="n">k</span> <span class="n">E</span><span class="o">]</span>
  <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">manifold</span> <span class="n">E</span> <span class="o">(</span><span class="n">times_cont_diff_groupoid</span> <span class="mi">1</span> <span class="n">k</span> <span class="n">E</span><span class="o">)</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">tangent_space_unfolded</span> <span class="n">k</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">true</span>
</pre></div>


<p>I get the red squiggle under <code>p : tangent_space_unfolded k x</code> with the complaint</p>
<div class="codehilite"><pre><span></span><span class="n">don&#39;t</span> <span class="n">know</span> <span class="n">how</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">placeholder</span>
<span class="kn">context</span><span class="o">:</span>
<span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_1</span> <span class="o">:</span> <span class="n">nondiscrete_normed_field</span> <span class="n">k</span><span class="o">,</span>
<span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_2</span> <span class="o">:</span> <span class="n">normed_space</span> <span class="n">k</span> <span class="n">E</span><span class="o">,</span>
<span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_3</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">M</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_4</span> <span class="o">:</span> <span class="n">manifold</span> <span class="n">E</span> <span class="o">(</span><span class="n">times_cont_diff_groupoid</span> <span class="mi">1</span> <span class="n">k</span> <span class="n">E</span><span class="o">)</span> <span class="n">M</span><span class="o">,</span>
<span class="n">x</span> <span class="o">:</span> <span class="n">M</span>
<span class="err">⊢</span> <span class="n">out_param</span> <span class="kt">Type</span>
</pre></div>


<p>If I make the parameter <code>E</code> explicit, on the other hand, everything is fine.</p>
<p>There are very few places in the library where <code>out_param</code> is used, so I don't have enough examples (or documentation) to understand what the right syntax should be. Is it impossible to do what I would like?</p>

<a name="164912212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912212" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912212">Mario Carneiro (May 05 2019 at 10:01)</a>:</h4>
<p>out_param goes on instances and class definitions</p>

<a name="164912263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912263" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912263">Mario Carneiro (May 05 2019 at 10:02)</a>:</h4>
<p>you can't just put it on a single definition, it's tied in to the whole instance search problem for that typeclass</p>

<a name="164912316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912316" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912316">Mario Carneiro (May 05 2019 at 10:04)</a>:</h4>
<p>In this case, if you want <code>k</code> to determine <code>E</code> in <code>normed_space</code>, you would need to mark <code>E</code> as <code>out_param</code> in the definition of <code>normed_space</code>. I guess that's not what you want</p>

<a name="164912334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912334" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912334">Sebastien Gouezel (May 05 2019 at 10:04)</a>:</h4>
<p>I don't want <code>k</code> to determine <code>E</code>, I want the manifold instance together with <code>k</code> to determine <code>E</code>.</p>

<a name="164912354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912354" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912354">Mario Carneiro (May 05 2019 at 10:05)</a>:</h4>
<p>but the manifold instance already mentions E</p>

<a name="164912407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912407" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912407">Mario Carneiro (May 05 2019 at 10:06)</a>:</h4>
<p>So you want to trigger the search <code>manifold ?E (times_cont_diff_groupoid 1 k ?E) M</code>?</p>

<a name="164912409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912409" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912409">Sebastien Gouezel (May 05 2019 at 10:06)</a>:</h4>
<p>Yes. I guess I don't understand at all what out_param does. What I would like to happen when Lean encounters <code>tangent_space k x</code>: it looks in the context for a instance of <code>manifold ?m1 (times_cont_diff_groupoid 1 k ?m1) M</code>, and if it finds one it picks it at <code>E</code>.</p>

<a name="164912420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912420" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912420">Mario Carneiro (May 05 2019 at 10:07)</a>:</h4>
<p>or is it <code>manifold ?E ?X M</code></p>

<a name="164912424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912424" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912424">Mario Carneiro (May 05 2019 at 10:08)</a>:</h4>
<p>what is that second argument?</p>

<a name="164912467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912467" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912467">Sebastien Gouezel (May 05 2019 at 10:08)</a>:</h4>
<p>It is really <code>manifold ?m1 (times_cont_diff_groupoid 1 k ?m1) M</code> that it should look for.</p>

<a name="164912470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912470" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912470">Sebastien Gouezel (May 05 2019 at 10:08)</a>:</h4>
<p>It is a groupoid, i.e., a set of local homeomorphisms between <code>M</code> and <code>E</code>.</p>

<a name="164912539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912539" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912539">Mario Carneiro (May 05 2019 at 10:10)</a>:</h4>
<p>can you make another class?</p>

<a name="164912541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912541" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912541">Mario Carneiro (May 05 2019 at 10:10)</a>:</h4>
<p>like <code>model_space M ?E</code> or something</p>

<a name="164912543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912543" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912543">Mario Carneiro (May 05 2019 at 10:10)</a>:</h4>
<p>that implies <code>manifold ?E (times_cont_diff_groupoid 1 k ?E) M</code></p>

<a name="164912624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912624" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912624">Mario Carneiro (May 05 2019 at 10:13)</a>:</h4>
<p>I am wary of that typeclass arg. You can probably make lean search for it because lean typeclass search has no hygiene, but that's also why typeclass search is starting to fall over in mathlib</p>

<a name="164912628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912628" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912628">Sebastien Gouezel (May 05 2019 at 10:13)</a>:</h4>
<p>What I could do is mark <code>E</code> as out_param in the definition of manifold. Except that this is not OK as there can be different model spaces depending on whether one considers a space as a real or complex manifold. So, it would really have to depend on both <code>k</code> and <code>M</code>. I can build a new class <code>smooth_manifold k ?E M</code> with <code>E</code> as an out_param, and see how this goes.</p>

<a name="164912685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912685" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912685">Sebastien Gouezel (May 05 2019 at 10:15)</a>:</h4>
<p>Being a manifold is definitely a type class, just as good as being a ring or a topological space. The only difference is that it has more structure built in, so it depends on more stuff but that's the way math is.</p>

<a name="164913172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164913172" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164913172">Mario Carneiro (May 05 2019 at 10:28)</a>:</h4>
<p>The problem isn't the math, it's the use of <code>(times_cont_diff_groupoid 1 k ?E)</code> as one of the arguments to the class. It's too dependent for my liking (it's not even a type IIUC)</p>

<a name="164913454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164913454" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164913454">Sebastien Gouezel (May 05 2019 at 10:36)</a>:</h4>
<p>For each groupoid <code>G</code>, you have a notion of manifold based on this groupoid. For instance, <code>C^infty</code> manifolds, or manifolds with boundary, or manifold with corners, or contact manifolds, or orientable manifolds, or whatever. Each of these structures gives you access to some objects on the manifold. My idea is to set up a set of instances between these structures, so that when you have a contact manifold then you also get automatically a smooth structure, an oriented structure, and so on, just by typeclass inference. I have the impression that this is precisely the kind of things at which typeclass inference is good, but maybe I am missing something.</p>

<a name="164913667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164913667" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164913667">Mario Carneiro (May 05 2019 at 10:43)</a>:</h4>
<p>could you put the definition of <code>manifold</code>? I'm confused about the type of everything here</p>

<a name="164915110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164915110" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164915110">Sebastien Gouezel (May 05 2019 at 11:24)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">structure_groupoid</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">members</span>      <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">local_homeomorph</span> <span class="n">α</span> <span class="n">α</span><span class="o">))</span>
<span class="o">(</span><span class="n">comp</span>         <span class="o">:</span> <span class="bp">∀</span><span class="n">e</span> <span class="n">e&#39;</span> <span class="o">:</span> <span class="n">local_homeomorph</span> <span class="n">α</span> <span class="n">α</span><span class="o">,</span> <span class="n">e</span> <span class="err">∈</span> <span class="n">members</span> <span class="bp">→</span> <span class="n">e&#39;</span> <span class="err">∈</span> <span class="n">members</span> <span class="bp">→</span> <span class="n">e</span> <span class="bp">→</span><span class="err">ₕ</span> <span class="n">e&#39;</span> <span class="err">∈</span> <span class="n">members</span><span class="o">)</span>
<span class="o">(</span><span class="n">inv</span>          <span class="o">:</span> <span class="bp">∀</span><span class="n">e</span> <span class="o">:</span> <span class="n">local_homeomorph</span> <span class="n">α</span> <span class="n">α</span><span class="o">,</span> <span class="n">e</span> <span class="err">∈</span> <span class="n">members</span> <span class="bp">→</span> <span class="n">e</span><span class="bp">.</span><span class="n">symm</span> <span class="err">∈</span> <span class="n">members</span><span class="o">)</span>
<span class="o">(</span><span class="n">id_mem</span>       <span class="o">:</span> <span class="n">local_homeomorph</span><span class="bp">.</span><span class="n">refl</span> <span class="n">α</span> <span class="err">∈</span> <span class="n">members</span><span class="o">)</span>
<span class="o">(</span><span class="n">locality</span>     <span class="o">:</span> <span class="bp">∀</span><span class="n">e</span> <span class="o">:</span> <span class="n">local_homeomorph</span> <span class="n">α</span> <span class="n">α</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span><span class="n">x</span> <span class="err">∈</span> <span class="n">e</span><span class="bp">.</span><span class="n">source</span><span class="o">,</span> <span class="bp">∃</span><span class="n">s</span><span class="o">,</span> <span class="n">is_open</span> <span class="n">s</span> <span class="bp">∧</span>
                  <span class="n">x</span> <span class="err">∈</span> <span class="n">s</span> <span class="bp">∧</span> <span class="n">e</span><span class="bp">.</span><span class="n">restr</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">members</span><span class="o">)</span> <span class="bp">→</span> <span class="n">e</span> <span class="err">∈</span> <span class="n">members</span><span class="o">)</span>
<span class="o">(</span><span class="n">eq_on_source</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">e</span> <span class="n">e&#39;</span> <span class="o">:</span> <span class="n">local_homeomorph</span> <span class="n">α</span> <span class="n">α</span><span class="o">,</span> <span class="n">e</span> <span class="err">∈</span> <span class="n">members</span> <span class="bp">→</span> <span class="n">e&#39;</span> <span class="bp">≈</span> <span class="n">e</span> <span class="bp">→</span> <span class="n">e&#39;</span> <span class="err">∈</span> <span class="n">members</span><span class="o">)</span>

<span class="n">class</span> <span class="n">manifold</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">structure_groupoid</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">chart</span>  <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">local_homeomorph</span> <span class="n">β</span> <span class="n">α</span><span class="o">))</span>
<span class="o">(</span><span class="n">compat</span> <span class="o">:</span> <span class="bp">∀</span><span class="n">e</span> <span class="n">e&#39;</span> <span class="o">:</span> <span class="n">local_homeomorph</span> <span class="n">β</span> <span class="n">α</span><span class="o">,</span> <span class="n">e</span> <span class="err">∈</span> <span class="n">chart</span> <span class="bp">→</span> <span class="n">e&#39;</span> <span class="err">∈</span> <span class="n">chart</span> <span class="bp">→</span> <span class="n">e</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">→</span><span class="err">ₕ</span> <span class="n">e&#39;</span> <span class="err">∈</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">cover</span>  <span class="o">:</span> <span class="bp">∀</span><span class="n">x</span><span class="o">,</span> <span class="bp">∃</span><span class="n">e</span> <span class="o">:</span> <span class="n">local_homeomorph</span> <span class="n">β</span> <span class="n">α</span><span class="o">,</span> <span class="n">e</span> <span class="err">∈</span> <span class="n">chart</span> <span class="bp">∧</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">e</span><span class="bp">.</span><span class="n">source</span><span class="o">)</span>
</pre></div>


<p>One could also go for a manifold structure just by picking the charts and the cover condition (this would be a <code>has_chart</code> class, say, similar to <code>has_add</code> and friends), and say that the manifold structure is compatible with a given groupoid if the compat condition holds (in the same way as one can add properties extending <code>has_add</code> making it into a group, a ring, a module, and so on).</p>

<a name="164918445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164918445" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164918445">Mario Carneiro (May 05 2019 at 13:00)</a>:</h4>
<p>Okay, I see. I guess this definition of <code>manifold</code> differs from the earlier one though, since <code>α</code> is implicit now but the other one had three explicit args</p>

<a name="164918467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164918467" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164918467">Mario Carneiro (May 05 2019 at 13:02)</a>:</h4>
<p>The order of inference still seems a bit weird to me. Can't manifolds have multiple model vector spaces? Like a manifold with different dimensions at different points</p>

<a name="164918521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164918521" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164918521">Sebastien Gouezel (May 05 2019 at 13:02)</a>:</h4>
<p>Yes, you're right. I had tried to make the argument explicit to see if it made a difference, but it didn't so I came back to my original definition with alpha implicit.</p>

<a name="164918552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164918552" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164918552">Mario Carneiro (May 05 2019 at 13:04)</a>:</h4>
<p>It seems pretty natural to me that you should say M is a C^1 R^n manifold, and both R,n,M are required args</p>

<a name="164918598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164918598" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164918598">Sebastien Gouezel (May 05 2019 at 13:04)</a>:</h4>
<p>In the most standard definition, the model space is the same everywhere (and so the dimension is the same everywhere). If you really want to have a manifold with different local dimensions with this definition, you can by taking as a model space the union of all R^n over varying n, but this is not very natural.</p>

<a name="164918604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164918604" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164918604">Mario Carneiro (May 05 2019 at 13:04)</a>:</h4>
<p>that's not a vector space</p>

<a name="164918609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164918609" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164918609">Sebastien Gouezel (May 05 2019 at 13:04)</a>:</h4>
<p>The thing is that the groupoid <code>G</code> already contains the information about alpha.</p>

<a name="164918627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164918627" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164918627">Sebastien Gouezel (May 05 2019 at 13:05)</a>:</h4>
<p>The model space does not need to be a vector space (and in many applications it isn't)</p>

<a name="164918923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164918923" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164918923">Sebastien Gouezel (May 05 2019 at 13:12)</a>:</h4>
<p>An important example to keep in mind, however, is a complex manifold of dimension <code>n</code>, modelled over <code>C^n</code>, that you also want to think of as a manifold of dimension <code>2n</code> modelled over <code>R^{2n}</code>. So not everything can be implicit.</p>

<a name="164918936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164918936" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164918936">Mario Carneiro (May 05 2019 at 13:13)</a>:</h4>
<p>I think I want this definition to be explicit in all the args k E G M</p>

<a name="164918986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164918986" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164918986">Mario Carneiro (May 05 2019 at 13:14)</a>:</h4>
<p>but you should keep things variable when possible. For example <code>tangent_space_unfolded</code> seems to be unnecessarily specializing on the groupoid</p>

<a name="164919128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164919128" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164919128">Mario Carneiro (May 05 2019 at 13:18)</a>:</h4>
<p>Even if there is "only one" model space up to isomorphism doesn't mean there's only one up to defeq</p>

<a name="164919149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164919149" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164919149">Mario Carneiro (May 05 2019 at 13:19)</a>:</h4>
<p>In particular I'm sure there will be ways to combine stuff in mathlib to get other isomorphic things like (R^2)^n that we also want to talk about</p>

<a name="164920531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164920531" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164920531">Sebastien Gouezel (May 05 2019 at 13:57)</a>:</h4>
<p>You want to be able to speak of the tangent space to many manifolds, for instance to C^infty manifolds or to contact manifolds. If there is an instance saying that a C^infty manifold is a C^1 manifold, or that a contact manifold is a C^1 manifold, then you get the tangent space for all of them at once.</p>

<a name="164922955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164922955" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164922955">Mario Carneiro (May 05 2019 at 14:59)</a>:</h4>
<p>I mean that you have specialized to C^1 but the definition works in any groupoid, or at least that part of it does</p>

<a name="164923063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164923063" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164923063">Mario Carneiro (May 05 2019 at 15:01)</a>:</h4>
<p>Also, given that the C^1 groupoid is data here, I think that those instances you just said are going to cause diamond problems</p>

<a name="164923205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164923205" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164923205">Mario Carneiro (May 05 2019 at 15:04)</a>:</h4>
<p>Looking at your definition of manifold, it seems like <code>G</code> isn't actually necessary to define the manifold itself. You can have one manifold structure and assert that it is compatible with a variety of groupoids</p>

<a name="164923296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164923296" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164923296">Mario Carneiro (May 05 2019 at 15:06)</a>:</h4>
<p>That also solves the problem of these composite constraints in the typeclass, since you then have <code>[manifold A B] [is_C1_manifold A B]</code> instead of <code>[manifold A (C1_groupoid A) B]</code></p>

<a name="164923307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164923307" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164923307">Mario Carneiro (May 05 2019 at 15:07)</a>:</h4>
<p>where <code>is_C1_manifold</code> is a Prop</p>

<a name="164923427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164923427" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164923427">Sebastien Gouezel (May 05 2019 at 15:11)</a>:</h4>
<p>I agree it is a good idea to separate the manifold structure, i.e., the data given by the charts, from the regularity of the charts, i.e., the fact that the charts belong to some groupoid. I'll try this route, thanks!</p>

<a name="164924256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164924256" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164924256">Sebastien Gouezel (May 05 2019 at 15:34)</a>:</h4>
<p>In fact, I am not so sure I gain anything with this. The two options are</p>
<ul>
<li>Just a typeclass <code>[manifold A G B]</code>, which contains data (the charts) and a proposition (the fact that the changes of charts belong to <code>G</code>)</li>
<li>Two typeclasses, <code>[manifold A B]</code> containing the charts, and <code>[has_smoothness_class A G B]</code> (assuming <code>[manifold A B]</code>), which is only Prop, asserting that the changes of charts belong to <code>G</code>.</li>
</ul>
<p>Whe one sets up instances, with the second point of view the set of charts is fixed, and one only asserts, say, that if a manifold is C^oo then it is C^1 for the same charts. In the first approach, one would get an instance from <code>[manifold A (C^oo) B]</code> to <code>[manifold A C^1 B]</code>, keeping the same charts but asserting that they belong to the larger groupoid <code>C^1</code>. I don't see why the first approach would give rise to diamonds, as the data between the instances does not change, so whatever the path between the instances one should get defeq stuff, right?</p>

<a name="164925952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164925952" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164925952">Mario Carneiro (May 05 2019 at 16:20)</a>:</h4>
<p>In the first approach, the manifold itself is different when it is inferred by a different route</p>

<a name="164925958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164925958" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164925958">Mario Carneiro (May 05 2019 at 16:20)</a>:</h4>
<p>because the manifold instance depends on G</p>

<a name="164926035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164926035" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164926035">Mario Carneiro (May 05 2019 at 16:22)</a>:</h4>
<p>I guess you are saying that the typeclass instance itself might not be defeq but the <code>charts</code> projection is</p>

<a name="164926046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164926046" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164926046">Sebastien Gouezel (May 05 2019 at 16:22)</a>:</h4>
<p>I don't get it. The manifold is made of data (the charts) and Props. Whatever way you go, you get the same data (it does not change through the instances), and the props are irrelevant. How could it not be defeq?</p>

<a name="164926065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164926065" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164926065">Mario Carneiro (May 05 2019 at 16:23)</a>:</h4>
<p>The manifold lives in a different type</p>

<a name="164926120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164926120" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164926120">Mario Carneiro (May 05 2019 at 16:24)</a>:</h4>
<p><code>manifold A (C1_groupoid A (C1_of_C^oo)) B</code> vs <code>manifold A (C1_groupoid A (C1_of_C^2 (C^2_of_C^oo))) B</code> or something</p>

<a name="164926147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164926147" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164926147">Mario Carneiro (May 05 2019 at 16:25)</a>:</h4>
<p>because the dependencies are different, these can't even be propositionally equal</p>

<a name="164927540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164927540" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164927540">Sebastien Gouezel (May 05 2019 at 17:03)</a>:</h4>
<p>I still don't get it, sorry, I am a little bit slow. Suppose you have three instances</p>
<div class="codehilite"><pre><span></span><span class="kn">instance</span> <span class="n">C1_of_C3</span> <span class="o">[</span><span class="n">manifold</span> <span class="o">(</span><span class="n">C</span><span class="err">^</span><span class="mi">3</span><span class="bp">_</span><span class="n">groupoid</span> <span class="n">E</span><span class="o">)</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">manifold</span> <span class="o">(</span><span class="n">C</span><span class="err">^</span><span class="mi">1</span><span class="bp">_</span><span class="n">groupoid</span> <span class="n">E</span><span class="o">)</span> <span class="n">M</span>
<span class="kn">instance</span> <span class="n">C2_of_C3</span> <span class="o">[</span><span class="n">manifold</span> <span class="o">(</span><span class="n">C</span><span class="err">^</span><span class="mi">3</span><span class="bp">_</span><span class="n">groupoid</span> <span class="n">E</span><span class="o">)</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">manifold</span> <span class="o">(</span><span class="n">C</span><span class="err">^</span><span class="mi">2</span><span class="bp">_</span><span class="n">groupoid</span> <span class="n">E</span><span class="o">)</span> <span class="n">M</span>
<span class="kn">instance</span> <span class="n">C1_of_C2</span> <span class="o">[</span><span class="n">manifold</span> <span class="o">(</span><span class="n">C</span><span class="err">^</span><span class="mi">2</span><span class="bp">_</span><span class="n">groupoid</span> <span class="n">E</span><span class="o">)</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">manifold</span> <span class="o">(</span><span class="n">C</span><span class="err">^</span><span class="mi">1</span><span class="bp">_</span><span class="n">groupoid</span> <span class="n">E</span><span class="o">)</span> <span class="n">M</span>
</pre></div>


<p>Then the path C1_of_C3 seems to me to be completely equivalent to the composition of C2_of_C3 and C1_of_C2. And the types do not seem to depend on the chosen path.</p>

<a name="164928029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164928029" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164928029">Mario Carneiro (May 05 2019 at 17:17)</a>:</h4>
<p>Actually I think I'm the one that's slow. Feel free to ignore my ramblings, I must be tired. I think you are right. However, this kind of instance search seems like a bad idea - there are lots and lots of values of k in C^k, and I'm sure in the right context you will be able to get some silliness like a search for <code>has_zero nat</code> ending up at <code>manifold (C^57_groupoid R) nat</code></p>

<a name="164928400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164928400" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164928400">Sebastien Gouezel (May 05 2019 at 17:29)</a>:</h4>
<p>I am only planning to register the ones with 0, 1 and infinity. And prove the general statement, but not register it as an instance (if necessary, it can be registered locally).</p>

<a name="193281536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193281536" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193281536">Yury G. Kudryashov (Apr 08 2020 at 07:05)</a>:</h4>
<p>What is the purpose of <code>out_param</code>? It says something about output parameters in typeclasses but in <code>has_insert α γ</code> the first parameter is <code>out_param</code>.</p>

<a name="193281595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193281595" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193281595">Yury G. Kudryashov (Apr 08 2020 at 07:06)</a>:</h4>
<p>I'm trying to turn <code>singleton</code> into a typeclass <code>has_singleton</code> + <code>lawful_singleton</code>.</p>

<a name="193281613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193281613" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193281613">Yury G. Kudryashov (Apr 08 2020 at 07:06)</a>:</h4>
<p>So that we can have <code>{a} = {x | x = a}</code></p>

<a name="193282260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193282260" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193282260">Yury G. Kudryashov (Apr 08 2020 at 07:15)</a>:</h4>
<p>It seems that Lean interprets <code>{x}</code> as <code>insert x ∅</code>, not as <code>singleton x</code>.</p>

<a name="193282600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193282600" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193282600">Johan Commelin (Apr 08 2020 at 07:19)</a>:</h4>
<p>Yup, there are plans to change this... but I don't think there's a PR yet. I think Mario has a PR related to this to core lean (about how <code>{x,y, ..., z}</code> is defined</p>

<a name="193282695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193282695" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193282695">Kenny Lau (Apr 08 2020 at 07:20)</a>:</h4>
<p>man, a lot of proofs would break (at least those that I write, because I never use <code>simp</code>)</p>

<a name="193282732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193282732" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193282732">Yury G. Kudryashov (Apr 08 2020 at 07:21)</a>:</h4>
<p>I thought that it already calls <code>singleton</code>, and we just have to change <code>def singleton</code> in the library. I was wrong, so let's wait for Mario (I don't want to touch C++ lean code).</p>

<a name="193282820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193282820" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193282820">Kenny Lau (Apr 08 2020 at 07:22)</a>:</h4>
<p>core lean doesn't mean C++ lean code</p>

<a name="193282824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193282824" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193282824">Yury G. Kudryashov (Apr 08 2020 at 07:22)</a>:</h4>
<p>If you use <code>singleton</code>, then you probably use <code>mem_singleton_iff</code>. We'll need to change its proof to <code>iff.rfl</code>, then most proofs should work.</p>

<a name="193282837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193282837" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193282837">Yury G. Kudryashov (Apr 08 2020 at 07:22)</a>:</h4>
<p>Parsing of <code>{x, y, ...}</code> happens in C++.</p>

<a name="193282860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193282860" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193282860">Yury G. Kudryashov (Apr 08 2020 at 07:23)</a>:</h4>
<p><a href="https://github.com/leanprover-community/lean/pull/153/files" title="https://github.com/leanprover-community/lean/pull/153/files">https://github.com/leanprover-community/lean/pull/153/files</a></p>

<a name="193282888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193282888" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193282888">Kenny Lau (Apr 08 2020 at 07:23)</a>:</h4>
<p>oh, interesting</p>

<a name="193283346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193283346" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193283346">Yury G. Kudryashov (Apr 08 2020 at 07:28)</a>:</h4>
<p>Even more interesting: <em>parsing</em> of <code>{x}</code> calls <code>singleton</code> but <em>pretty printing</em> relies on <code>singleton x = insert x ∅</code>.</p>

<a name="193283504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193283504" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193283504">Yury G. Kudryashov (Apr 08 2020 at 07:30)</a>:</h4>
<p>So if I redefine <code>singleton x</code>, then <code>{x}</code> in the input will parse as <code>singleton x</code>, then printed as <code>singleton x</code> while <code>insert x ∅</code>  will be printed as <code>{x}</code>.</p>

<a name="193283512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193283512" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193283512">Yury G. Kudryashov (Apr 08 2020 at 07:30)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> <span class="user-mention" data-user-id="110043">@Gabriel Ebner</span></p>

<a name="193283574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193283574" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193283574">Mario Carneiro (Apr 08 2020 at 07:31)</a>:</h4>
<p>The C++ change is already done and in the PR queue</p>

<a name="193283584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193283584" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193283584">Mario Carneiro (Apr 08 2020 at 07:31)</a>:</h4>
<p>(it's broken because C++11 but that's another matter)</p>

<a name="193283646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193283646" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193283646">Mario Carneiro (Apr 08 2020 at 07:32)</a>:</h4>
<p>the change you are talking about is entirely in lean</p>

<a name="193283775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193283775" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193283775">Mario Carneiro (Apr 08 2020 at 07:34)</a>:</h4>
<p>I don't know whether it should be okay to have <code>insert x empty</code>get printed as <code>{x}</code> or not. It basically boils down to whether we think we can reliably retain that form for literals</p>

<a name="193283826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193283826" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193283826">Yury G. Kudryashov (Apr 08 2020 at 07:34)</a>:</h4>
<p>It seems that you're changing the parser, not the printer.</p>

<a name="193283836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193283836" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193283836">Mario Carneiro (Apr 08 2020 at 07:34)</a>:</h4>
<p>I would expect things like <code>simp</code> to easily break this (rewriting the inner <code>singleton a</code> to <code>insert a empty</code> in order to have a more uniform layout) and then the printer will give you the messy version</p>

<a name="193283867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193283867" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193283867">Mario Carneiro (Apr 08 2020 at 07:35)</a>:</h4>
<p>The change in the PR is only about parsing</p>

<a name="193283889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193283889" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193283889">Mario Carneiro (Apr 08 2020 at 07:35)</a>:</h4>
<p>Here I'm talking about the printing issue you pointed out</p>

<a name="193283952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193283952" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193283952">Yury G. Kudryashov (Apr 08 2020 at 07:36)</a>:</h4>
<p>The problem is that <code>singleton x</code> is printed as <code>singleton x</code>, not <code>{x}</code>.</p>

<a name="193283955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193283955" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193283955">Jasmin Blanchette (Apr 08 2020 at 07:36)</a>:</h4>
<p>I'm joining the conversation midway, but printing <code>insert x empty</code> as <code>{x}</code> is what Isabelle does. Likewise, <code>insert x (insert y empty)</code> is printed as <code>{x, y}</code>. It works well in practice.</p>

<a name="193283961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193283961" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193283961">Mario Carneiro (Apr 08 2020 at 07:36)</a>:</h4>
<p>and I should revise my earlier statement - if you want to change the printing behavior that's a C++ change</p>

<a name="193283981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193283981" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193283981">Mario Carneiro (Apr 08 2020 at 07:36)</a>:</h4>
<p><span class="user-mention" data-user-id="121058">@Jasmin Blanchette</span> the issue is the lack of consistency between parser and printer here</p>

<a name="193284008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193284008" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193284008">Mario Carneiro (Apr 08 2020 at 07:37)</a>:</h4>
<p>I would bet the printer is currently "forgiving" and will use the sugared notation for either of <code>insert ... insert singleton</code> and <code>insert ... insert empty</code></p>

<a name="193284023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193284023" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193284023">Mario Carneiro (Apr 08 2020 at 07:37)</a>:</h4>
<p>but the parser can't be round-tripping in this situation</p>

<a name="193284103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193284103" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193284103">Yury G. Kudryashov (Apr 08 2020 at 07:38)</a>:</h4>
<p>No, I tried to redefine <code>singleton</code>, and the printer is not forgiving.</p>

<a name="193284143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193284143" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193284143">Mario Carneiro (Apr 08 2020 at 07:39)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="n">insert</span> <span class="mi">1</span> <span class="o">(</span><span class="n">insert</span> <span class="mi">2</span> <span class="o">(</span><span class="n">insert</span> <span class="mi">3</span> <span class="err">∅</span><span class="o">)):</span><span class="n">set</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="c1">-- {3, 2, 1} : set ℕ</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="n">insert</span> <span class="mi">1</span> <span class="o">(</span><span class="n">insert</span> <span class="mi">2</span> <span class="o">(</span><span class="n">singleton</span> <span class="mi">3</span><span class="o">)):</span><span class="n">set</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="c1">-- {3, 2, 1} : set ℕ</span>
</pre></div>

<a name="193284159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193284159" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193284159">Yury G. Kudryashov (Apr 08 2020 at 07:39)</a>:</h4>
<p>Did you redefine <code>singleton</code>?</p>

<a name="193284161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193284161" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193284161">Mario Carneiro (Apr 08 2020 at 07:39)</a>:</h4>
<p>no, this is stock lean</p>

<a name="193284212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193284212" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193284212">Yury G. Kudryashov (Apr 08 2020 at 07:40)</a>:</h4>
<p>If you redefine <code>singleton</code>, then it stops working.</p>

<a name="193284510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193284510" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193284510">Johan Commelin (Apr 08 2020 at 07:44)</a>:</h4>
<p>I wouldn't mind if <code>insert x empty</code> doesn't print as <code>{x}</code>. If <code>{x}</code> is meant to be <code>singleton x</code> and that is no longer defeq to <code>insert x empty</code> I think it is actually a feature if the printer doesn't hide that.</p>

<a name="193284540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193284540" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193284540">Mario Carneiro (Apr 08 2020 at 07:44)</a>:</h4>
<p>Here's a MWE subset of core to demonstrate the printing behavior:</p>
<div class="codehilite"><pre><span></span><span class="n">prelude</span>
<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span>
<span class="n">class</span> <span class="n">has_emptyc</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">emptyc</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">@</span><span class="o">[</span><span class="kn">reducible</span><span class="o">]</span> <span class="n">def</span> <span class="n">out_param</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span> <span class="o">:=</span> <span class="n">α</span>
<span class="n">class</span> <span class="n">has_insert</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">out_param</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">u</span><span class="o">))</span> <span class="o">(</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">insert</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">γ</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span>
<span class="kn">export</span> <span class="n">has_insert</span> <span class="o">(</span><span class="n">insert</span><span class="o">)</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="err">∅</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">has_emptyc</span><span class="bp">.</span><span class="n">emptyc</span> <span class="bp">_</span>
<span class="n">def</span> <span class="n">singleton</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">has_emptyc</span> <span class="n">γ</span><span class="o">]</span> <span class="o">[</span><span class="n">has_insert</span> <span class="n">α</span> <span class="n">γ</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">γ</span> <span class="o">:=</span>
<span class="n">has_insert</span><span class="bp">.</span><span class="n">insert</span> <span class="n">a</span> <span class="o">(</span><span class="n">has_emptyc</span><span class="bp">.</span><span class="n">emptyc</span> <span class="bp">_</span><span class="o">)</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">has_emptyc</span> <span class="n">γ</span><span class="o">]</span> <span class="o">[</span><span class="n">has_insert</span> <span class="n">α</span> <span class="n">γ</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="n">insert</span> <span class="n">a</span> <span class="o">(</span><span class="n">insert</span> <span class="n">b</span> <span class="o">(</span><span class="n">insert</span> <span class="n">c</span> <span class="err">∅</span><span class="o">)):</span><span class="n">γ</span><span class="o">)</span> <span class="c1">-- {c, b, a} : γ</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="n">insert</span> <span class="n">a</span> <span class="o">(</span><span class="n">insert</span> <span class="n">b</span> <span class="o">(</span><span class="n">singleton</span> <span class="n">c</span><span class="o">)):</span><span class="n">γ</span><span class="o">)</span> <span class="c1">-- {c, b, a} : γ</span>
</pre></div>

<a name="193284577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193284577" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193284577">Mario Carneiro (Apr 08 2020 at 07:45)</a>:</h4>
<p>Changing the definition of <code>singleton</code> doesn't affect parsing or printing:</p>
<div class="codehilite"><pre><span></span><span class="n">prelude</span>
<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span>
<span class="n">class</span> <span class="n">has_emptyc</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">emptyc</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">@</span><span class="o">[</span><span class="kn">reducible</span><span class="o">]</span> <span class="n">def</span> <span class="n">out_param</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span> <span class="o">:=</span> <span class="n">α</span>
<span class="n">class</span> <span class="n">has_insert</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">out_param</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">u</span><span class="o">))</span> <span class="o">(</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">insert</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">γ</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span>
<span class="kn">export</span> <span class="n">has_insert</span> <span class="o">(</span><span class="n">insert</span><span class="o">)</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="err">∅</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">has_emptyc</span><span class="bp">.</span><span class="n">emptyc</span> <span class="bp">_</span>
<span class="n">def</span> <span class="n">singleton</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">has_emptyc</span> <span class="n">γ</span><span class="o">]</span> <span class="o">[</span><span class="n">has_insert</span> <span class="n">α</span> <span class="n">γ</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">γ</span> <span class="o">:=</span>
<span class="n">has_insert</span><span class="bp">.</span><span class="n">insert</span> <span class="n">a</span> <span class="o">(</span><span class="n">has_insert</span><span class="bp">.</span><span class="n">insert</span> <span class="n">a</span> <span class="o">(</span><span class="n">has_emptyc</span><span class="bp">.</span><span class="n">emptyc</span> <span class="bp">_</span><span class="o">))</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">has_emptyc</span> <span class="n">γ</span><span class="o">]</span> <span class="o">[</span><span class="n">has_insert</span> <span class="n">α</span> <span class="n">γ</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="n">insert</span> <span class="n">a</span> <span class="o">(</span><span class="n">insert</span> <span class="n">b</span> <span class="o">(</span><span class="n">insert</span> <span class="n">c</span> <span class="err">∅</span><span class="o">)):</span><span class="n">γ</span><span class="o">)</span> <span class="c1">-- {c, b, a} : γ</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="n">insert</span> <span class="n">a</span> <span class="o">(</span><span class="n">insert</span> <span class="n">b</span> <span class="o">(</span><span class="n">singleton</span> <span class="n">c</span><span class="o">)):</span><span class="n">γ</span><span class="o">)</span> <span class="c1">-- {c, b, a} : γ</span>
</pre></div>

<a name="193284925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193284925" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193284925">Mario Carneiro (Apr 08 2020 at 07:49)</a>:</h4>
<p>Using a typeclass version breaks it:</p>
<div class="codehilite"><pre><span></span><span class="n">class</span> <span class="n">has_singleton</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">out_param</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">u</span><span class="o">))</span> <span class="o">(</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">singleton</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span>
<span class="n">def</span> <span class="n">singleton</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">has_singleton</span> <span class="n">α</span> <span class="n">γ</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">γ</span> <span class="o">:=</span>
<span class="n">has_singleton</span><span class="bp">.</span><span class="n">singleton</span> <span class="bp">_</span> <span class="n">a</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">has_emptyc</span> <span class="n">γ</span><span class="o">]</span> <span class="o">[</span><span class="n">has_insert</span> <span class="n">α</span> <span class="n">γ</span><span class="o">]</span> <span class="o">[</span><span class="n">has_singleton</span> <span class="n">α</span> <span class="n">γ</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="n">insert</span> <span class="n">a</span> <span class="o">(</span><span class="n">insert</span> <span class="n">b</span> <span class="o">(</span><span class="n">insert</span> <span class="n">c</span> <span class="err">∅</span><span class="o">)):</span><span class="n">γ</span><span class="o">)</span> <span class="c1">-- {c, b, a} : γ</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="n">insert</span> <span class="n">a</span> <span class="o">(</span><span class="n">insert</span> <span class="n">b</span> <span class="o">(</span><span class="n">singleton</span> <span class="n">c</span><span class="o">)):</span><span class="n">γ</span><span class="o">)</span> <span class="c1">-- insert a (insert b (singleton c)) : γ</span>
</pre></div>


<p>but this is clearly because it's counting arguments wrong:</p>
<div class="codehilite"><pre><span></span><span class="n">class</span> <span class="n">has_singleton</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">out_param</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">u</span><span class="o">))</span> <span class="o">(</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">singleton</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span>
<span class="n">def</span> <span class="n">singleton</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">has_singleton</span> <span class="n">α</span> <span class="n">γ</span><span class="o">]</span> <span class="o">[</span><span class="n">has_singleton</span> <span class="n">α</span> <span class="n">γ</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">γ</span> <span class="o">:=</span>
<span class="n">has_singleton</span><span class="bp">.</span><span class="n">singleton</span> <span class="bp">_</span> <span class="n">a</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">has_emptyc</span> <span class="n">γ</span><span class="o">]</span> <span class="o">[</span><span class="n">has_insert</span> <span class="n">α</span> <span class="n">γ</span><span class="o">]</span> <span class="o">[</span><span class="n">has_singleton</span> <span class="n">α</span> <span class="n">γ</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="n">insert</span> <span class="n">a</span> <span class="o">(</span><span class="n">insert</span> <span class="n">b</span> <span class="o">(</span><span class="n">insert</span> <span class="n">c</span> <span class="err">∅</span><span class="o">)):</span><span class="n">γ</span><span class="o">)</span> <span class="c1">-- {c, b, a} : γ</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="n">insert</span> <span class="n">a</span> <span class="o">(</span><span class="n">insert</span> <span class="n">b</span> <span class="o">(</span><span class="n">singleton</span> <span class="n">c</span><span class="o">)):</span><span class="n">γ</span><span class="o">)</span> <span class="c1">-- {c, b, a} : γ</span>
</pre></div>

<a name="193285010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193285010" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193285010">Mario Carneiro (Apr 08 2020 at 07:50)</a>:</h4>
<p>it presumably relies on the contents of the singleton to be in argument # 5</p>

<a name="193285050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193285050" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193285050">Yury G. Kudryashov (Apr 08 2020 at 07:51)</a>:</h4>
<p>Thank you! I only tried the typeclass version, and didn't guess that it relies on argument index.</p>

<a name="193285162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193285162" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193285162">Yury G. Kudryashov (Apr 08 2020 at 07:52)</a>:</h4>
<p>Yes, <code>frontends/lean/pp.cpp</code> has <code>is_constant(get_app_fn(e), get_singleton_name()) &amp;&amp; get_app_num_args(e) == 5</code></p>

<a name="193285225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193285225" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193285225">Mario Carneiro (Apr 08 2020 at 07:53)</a>:</h4>
<p>I can't test it because the other bug gets in the way, but I would expect <code>export has_singleton (singleton)</code> to also break printing, since now the name of the singleton constructor is <code>has_singleton.singleton</code> instead of <code>_root_.singleton</code></p>

<a name="193285356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193285356" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193285356">Yury G. Kudryashov (Apr 08 2020 at 07:55)</a>:</h4>
<p>Thank you for the explanation. I think that now I know how to do it.</p>

<a name="193285391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193285391" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193285391">Yury G. Kudryashov (Apr 08 2020 at 07:55)</a>:</h4>
<p>BTW, why our notation for <code>sUnion</code> doesn't conflict with the one from stdlib?</p>

<a name="193285491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193285491" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193285491">Yury G. Kudryashov (Apr 08 2020 at 07:56)</a>:</h4>
<p>Ignore.</p>

<a name="193285848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193285848" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193285848">Mario Carneiro (Apr 08 2020 at 08:00)</a>:</h4>
<p>heh, problem solved:</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">class</span><span class="o">]</span> <span class="kn">inductive</span> <span class="n">unit</span> <span class="bp">|</span> <span class="n">star</span>
<span class="n">attribute</span> <span class="o">[</span><span class="kn">instance</span><span class="o">]</span> <span class="n">unit</span><span class="bp">.</span><span class="n">star</span>
<span class="n">def</span> <span class="n">singleton</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">has_singleton</span> <span class="n">α</span> <span class="n">γ</span><span class="o">]</span> <span class="o">[</span><span class="n">unit</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">γ</span> <span class="o">:=</span>
<span class="n">has_singleton</span><span class="bp">.</span><span class="n">singleton</span> <span class="bp">_</span> <span class="n">a</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">has_emptyc</span> <span class="n">γ</span><span class="o">]</span> <span class="o">[</span><span class="n">has_insert</span> <span class="n">α</span> <span class="n">γ</span><span class="o">]</span> <span class="o">[</span><span class="n">has_singleton</span> <span class="n">α</span> <span class="n">γ</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="n">insert</span> <span class="n">a</span> <span class="o">(</span><span class="n">insert</span> <span class="n">b</span> <span class="o">(</span><span class="n">insert</span> <span class="n">c</span> <span class="err">∅</span><span class="o">)):</span><span class="n">γ</span><span class="o">)</span> <span class="c1">-- {c, b, a} : γ</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="n">insert</span> <span class="n">a</span> <span class="o">(</span><span class="n">insert</span> <span class="n">b</span> <span class="o">(</span><span class="n">singleton</span> <span class="n">c</span><span class="o">)):</span><span class="n">γ</span><span class="o">)</span> <span class="c1">-- {c, b, a} : γ</span>
</pre></div>

<a name="193285919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193285919" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193285919">Johan Commelin (Apr 08 2020 at 08:01)</a>:</h4>
<p>Isn't it easier to change a <code>5</code> into a <code>4</code>?</p>

<a name="193285933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193285933" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193285933">Mario Carneiro (Apr 08 2020 at 08:01)</a>:</h4>
<p>not from lean</p>

<a name="193285956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193285956" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193285956">Johan Commelin (Apr 08 2020 at 08:01)</a>:</h4>
<p>Sure... but we are changing core Lean anyway</p>

<a name="193285970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193285970" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193285970">Mario Carneiro (Apr 08 2020 at 08:01)</a>:</h4>
<p>I wonder if it is worth making <code>unit</code> a class for implicit dummy args like this</p>

<a name="193286404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193286404" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193286404">Mario Carneiro (Apr 08 2020 at 08:06)</a>:</h4>
<p>more fun with confusing the printer:</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">class</span><span class="o">]</span> <span class="kn">inductive</span> <span class="n">unit</span> <span class="bp">|</span> <span class="n">star</span>
<span class="n">attribute</span> <span class="o">[</span><span class="kn">instance</span><span class="o">]</span> <span class="n">unit</span><span class="bp">.</span><span class="n">star</span>
<span class="n">def</span> <span class="n">singleton</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">has_singleton</span> <span class="n">α</span> <span class="n">γ</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">unit</span><span class="o">]</span> <span class="o">:</span> <span class="n">γ</span> <span class="o">:=</span>
<span class="n">has_singleton</span><span class="bp">.</span><span class="n">singleton</span> <span class="bp">_</span> <span class="n">a</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">has_emptyc</span> <span class="n">γ</span><span class="o">]</span> <span class="o">[</span><span class="n">has_insert</span> <span class="n">α</span> <span class="n">γ</span><span class="o">]</span> <span class="o">[</span><span class="n">has_singleton</span> <span class="n">α</span> <span class="n">γ</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="n">insert</span> <span class="n">a</span> <span class="o">(</span><span class="n">insert</span> <span class="n">b</span> <span class="o">(</span><span class="n">insert</span> <span class="n">c</span> <span class="err">∅</span><span class="o">)):</span><span class="n">γ</span><span class="o">)</span> <span class="c1">-- {c, b, a} : γ</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="n">insert</span> <span class="n">a</span> <span class="o">(</span><span class="n">insert</span> <span class="n">b</span> <span class="o">(</span><span class="n">singleton</span> <span class="n">c</span><span class="o">)):</span><span class="n">γ</span><span class="o">)</span> <span class="c1">-- {(), b, a} : γ</span>
</pre></div>

<a name="193286432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193286432" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193286432">Mario Carneiro (Apr 08 2020 at 08:06)</a>:</h4>
<p>also amusing that lean already knows that <code>unit</code> is printed as <code>()</code></p>

<a name="193286752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193286752" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193286752">Kenny Lau (Apr 08 2020 at 08:10)</a>:</h4>
<p>so the printer has access to definitions of stuffs?</p>

<a name="193286920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193286920" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193286920">Mario Carneiro (Apr 08 2020 at 08:12)</a>:</h4>
<p>Thinking about this a bit more, I think I want the printer to stay the way it is w.r.t. sugaring both kinds of enumerated set. There are already a ton of places where the printer doesn't round trip, for example when there are non-canonical instances, or when you mix <code>succ</code> and <code>bit0</code>/<code>bit1</code></p>
<div class="codehilite"><pre><span></span><span class="bp">#</span><span class="kn">check</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero</span> <span class="c1">-- 1 : ℕ</span>
<span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="n">has_one</span><span class="bp">.</span><span class="n">one</span> <span class="bp">ℕ</span> <span class="bp">_</span> <span class="c1">-- 1 : ℕ</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero</span><span class="o">)</span> <span class="c1">-- 2 : ℕ</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_one</span><span class="bp">.</span><span class="n">one</span> <span class="bp">ℕ</span> <span class="bp">_</span><span class="o">)</span> <span class="c1">-- nat.succ 1 : ℕ</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">bit1</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_one</span><span class="bp">.</span><span class="n">one</span> <span class="bp">ℕ</span> <span class="bp">_</span><span class="o">)</span> <span class="c1">-- 3 : ℕ</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">bit1</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero</span><span class="o">)</span> <span class="c1">-- 3 : ℕ</span>
</pre></div>

<a name="193286986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193286986" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193286986">Mario Carneiro (Apr 08 2020 at 08:13)</a>:</h4>
<p>The printer is completely dumbly going over the term thinking it knows what's up, but you can easily mislead it</p>

<a name="193287022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193287022" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193287022">Johan Commelin (Apr 08 2020 at 08:13)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> But if we implement the changes then <code>singleton x</code> is not defeq to <code>insert x ∅</code>, right? So <code>{x} = {x}</code> is not provable by <code>rfl</code>...</p>

<a name="193287086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193287086" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193287086">Mario Carneiro (Apr 08 2020 at 08:14)</a>:</h4>
<p>did you think we had that property before?</p>

<a name="193287100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193287100" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193287100">Yury G. Kudryashov (Apr 08 2020 at 08:14)</a>:</h4>
<p>Why not?</p>

<a name="193287149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193287149" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193287149">Johan Commelin (Apr 08 2020 at 08:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/out_param/near/193287086" title="#narrow/stream/113488-general/topic/out_param/near/193287086">said</a>:</p>
<blockquote>
<p>did you think we had that property before?</p>
</blockquote>
<p>Maybe not, but this one is going to trip up a lot of people</p>

<a name="193287182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193287182" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193287182">Johan Commelin (Apr 08 2020 at 08:15)</a>:</h4>
<p>Why can't we just make the printer not do fancy things with <code>insert x ∅</code>? And have a <code>simp</code>-lemma that turns it into <code>singleton x</code></p>

<a name="193287185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193287185" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193287185">Yury G. Kudryashov (Apr 08 2020 at 08:15)</a>:</h4>
<p>I think that most people won't meet <code>insert x empty</code></p>

<a name="193287265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193287265" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193287265">Johan Commelin (Apr 08 2020 at 08:16)</a>:</h4>
<p>Hmmm, that's probably right</p>

<a name="193287443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193287443" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193287443">Mario Carneiro (Apr 08 2020 at 08:18)</a>:</h4>
<p>I think it's fine to say "most people won't meet it" but I would prefer for the failure mode to be confusing printing rather than a 10x blowup of the printed term.</p>

<a name="193287471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193287471" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193287471">Mario Carneiro (Apr 08 2020 at 08:19)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">group</span>

<span class="kn">example</span> <span class="o">:</span> <span class="bp">@</span><span class="n">has_one</span><span class="bp">.</span><span class="n">one</span> <span class="bp">ℕ</span> <span class="bp">_</span> <span class="bp">=</span> <span class="bp">@</span><span class="n">has_one</span><span class="bp">.</span><span class="n">one</span> <span class="o">(</span><span class="n">multiplicative</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="bp">_</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="c1">-- ⊢ 1 = 1</span>
  <span class="n">exact</span> <span class="n">rfl</span><span class="o">,</span> <span class="c1">-- fail</span>
<span class="kn">end</span>
</pre></div>

<a name="193287542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193287542" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193287542">Mario Carneiro (Apr 08 2020 at 08:19)</a>:</h4>
<p>it's trivially easy to come up with examples along these lines</p>

<a name="193287550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193287550" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193287550">Johan Commelin (Apr 08 2020 at 08:19)</a>:</h4>
<p>Of course</p>

<a name="193287592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193287592" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193287592">Mario Carneiro (Apr 08 2020 at 08:20)</a>:</h4>
<p>the printer should really be viewed as a "best effort" thing</p>

<a name="193287613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193287613" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193287613">Mario Carneiro (Apr 08 2020 at 08:20)</a>:</h4>
<p>at least as long as you aren't using <code>pp.all</code></p>

<a name="193287653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193287653" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193287653">Yury G. Kudryashov (Apr 08 2020 at 08:20)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Do you have a Lean built with your <a href="https://github.com/leanprover-community/lean/issues/153" title="https://github.com/leanprover-community/lean/issues/153">lean#153</a> applied?</p>

<a name="193287692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193287692" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193287692">Mario Carneiro (Apr 08 2020 at 08:21)</a>:</h4>
<p>no, why?</p>

<a name="193287709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193287709" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193287709">Mario Carneiro (Apr 08 2020 at 08:21)</a>:</h4>
<p>I have a pretty good idea what will happen</p>

<a name="193287768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193287768" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193287768">Yury G. Kudryashov (Apr 08 2020 at 08:22)</a>:</h4>
<p>I wonder how <code>#check ({0, 1} : set nat)</code> will work.</p>

<a name="193287788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193287788" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193287788">Mario Carneiro (Apr 08 2020 at 08:22)</a>:</h4>
<p>it will produce the term <code>insert 0 (singleton 1)</code></p>

<a name="193287805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193287805" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193287805">Yury G. Kudryashov (Apr 08 2020 at 08:22)</a>:</h4>
<p>And how will it be pretty-printed?</p>

<a name="193287830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193287830" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193287830">Yury G. Kudryashov (Apr 08 2020 at 08:23)</a>:</h4>
<p><code>{0, 1}</code> or <code>{1, 0}</code>?</p>

<a name="193287831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/193287831" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#193287831">Mario Carneiro (Apr 08 2020 at 08:23)</a>:</h4>
<p>Actually, I guess I should have fixed the printer too in that PR since the printer will indeed print <code>{1, 0}</code></p>


{% endraw %}

{% include archive_update.html %}