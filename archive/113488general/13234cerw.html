---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/13234cerw.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html">cerw</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="147925618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147925618" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147925618">Johan Commelin (Nov 18 2018 at 18:23)</a>:</h4>
<p>I am a complete newbie when it comes to tactic writing. Here is a request for a tactic, and I have no idea how realistic it is. Suppose I have an isomorphism <code>h : X ≅ Y</code> in some category <code>C</code>. And suppose I have some other term <code>foo : bar X</code>, then I would like to have a tactic <code>cerw</code> (category-<code>erw</code>) that tries to figure out if <code>bar</code> is some sort of <code>category_theory.functor.obj</code> and if so, replaces <code>X</code> with <code>Y</code>.<br>
I realise this request is a bit vague. I would be happy to flesh out the details.</p>

<a name="147929231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147929231" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147929231">Scott Morrison (Nov 18 2018 at 20:13)</a>:</h4>
<p>HI Johan,</p>

<a name="147929239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147929239" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147929239">Scott Morrison (Nov 18 2018 at 20:13)</a>:</h4>
<p>I started writing this, as <code>iso_induction</code>.</p>

<a name="147929248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147929248" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147929248">Scott Morrison (Nov 18 2018 at 20:14)</a>:</h4>
<p>This is intended as my start of an answer to all our questions about transport of structure.</p>

<a name="147929296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147929296" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147929296">Scott Morrison (Nov 18 2018 at 20:14)</a>:</h4>
<p>It is not at all done, but it is certainly doable, and I would love to do it!</p>

<a name="147929420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147929420" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147929420">Scott Morrison (Nov 18 2018 at 20:17)</a>:</h4>
<p>Have a look at <a href="https://github.com/semorrison/lean-category-theory/blob/master/src/category_theory/iso_induction.lean" target="_blank" title="https://github.com/semorrison/lean-category-theory/blob/master/src/category_theory/iso_induction.lean">https://github.com/semorrison/lean-category-theory/blob/master/src/category_theory/iso_induction.lean</a></p>

<a name="147929421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147929421" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147929421">Scott Morrison (Nov 18 2018 at 20:18)</a>:</h4>
<p>for the idea</p>

<a name="147929468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147929468" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147929468">Scott Morrison (Nov 18 2018 at 20:18)</a>:</h4>
<p>It is not quite that same as <code>iso_rw</code>, but the same tooling would be required to make that work.</p>

<a name="147929531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147929531" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147929531">Scott Morrison (Nov 18 2018 at 20:20)</a>:</h4>
<p><code>iso_induction</code> takes a hypotheses <code>X \iso Y</code>, and tries to replace all appearances of <code>X</code> with <code>Y</code>, by writing everything in a form where <code>X</code> appears as the argument of a functor.</p>

<a name="147946598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147946598" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147946598">Johan Commelin (Nov 19 2018 at 05:40)</a>:</h4>
<p>Cool. That's going to be very useful!</p>

<a name="147946650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147946650" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147946650">Johan Commelin (Nov 19 2018 at 05:43)</a>:</h4>
<p>I am afraid that <code>monoid.ext</code> will be considered intollerable abuse of the type class system.</p>

<a name="147951652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147951652" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147951652">Scott Morrison (Nov 19 2018 at 08:17)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span>, what's wrong with <code>monoid.ext</code>?</p>
<div class="codehilite"><pre><span></span>@[extensionality] lemma monoid.ext {α : Type u} (m n : monoid α)
  (mul : ∀ x y : α, (by haveI := m; exact x * y) = (by haveI := n; exact x * y)) : m = n :=
</pre></div>

<a name="147951699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147951699" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147951699">Mario Carneiro (Nov 19 2018 at 08:18)</a>:</h4>
<p>looks good to me</p>

<a name="147951701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147951701" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147951701">Scott Morrison (Nov 19 2018 at 08:18)</a>:</h4>
<p>Is it the two different uses of <code>haveI</code> that you're worried about?</p>

<a name="147951704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147951704" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147951704">Johan Commelin (Nov 19 2018 at 08:18)</a>:</h4>
<p>Aah, wait. You aren't actually asking that there are two instances of <code>monoid α</code></p>

<a name="147951707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147951707" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147951707">Johan Commelin (Nov 19 2018 at 08:18)</a>:</h4>
<p>I read to fast.</p>

<a name="147951709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147951709" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147951709">Scott Morrison (Nov 19 2018 at 08:18)</a>:</h4>
<p>No, no square brackets for this lemma!</p>

<a name="147951792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147951792" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147951792">Mario Carneiro (Nov 19 2018 at 08:21)</a>:</h4>
<p>do you have groupoids? that's an obvious thing to prove about <code>isos</code></p>

<a name="147951911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147951911" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147951911">Mario Carneiro (Nov 19 2018 at 08:24)</a>:</h4>
<p>also it's not clear to me why <code>monoid_transport</code> isn't proven directly and it becomes the map part of <code>monoid_type_constructor</code></p>

<a name="161111092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161111092" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161111092">Scott Morrison (Mar 19 2019 at 01:03)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>, <span class="user-mention" data-user-id="112680">@Johan Commelin</span>, resuming an old thread about transport of structure along isomorphisms, I wonder if you could have a look at <a href="https://github.com/leanprover-community/mathlib/blob/a3d685fd6b12f86ac4e31b344d6405e30268e4f4/test/iso_induction.lean" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/a3d685fd6b12f86ac4e31b344d6405e30268e4f4/test/iso_induction.lean">tests/iso_induction.lean</a> on the <code>iso_induction</code> branch. In particular, my idea is that it may be possible to synthesise things like <code>submodule_functor</code>, <code>ideal_functor</code>, and <code>is_local_functor</code>, stubbed out in the file, completely automatically.</p>
<p>If that's the case, then being able to prove <code>is_local_ring S</code> given hypotheses <code>h : is_local_ring R</code> and <code>f : R \iso S</code> should be pretty doable via tactics that look like <code>iso_subst f; exact h</code>.</p>
<p>Really the question becomes --- if you look in the partial proofs of <code>submodule_functor</code> I've been writing, can you write down _exactly_ why every mathematician knows exactly what to do at every step? :-) This is the sort of thing <code>tidy</code> is aimed at, but it's not up to the task quite yet.</p>

<a name="161111356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161111356" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161111356">Kevin Buzzard (Mar 19 2019 at 01:08)</a>:</h4>
<p>Did you see Mario's effort on this question? My lean time has been 100% taken up with perfectoids recently so I didn't look at it</p>

<a name="161111388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161111388" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161111388">Scott Morrison (Mar 19 2019 at 01:09)</a>:</h4>
<p>No, maybe I didn't... <span class="user-mention" data-user-id="110049">@Mario Carneiro</span>, could you give me a pointer?</p>

<a name="161111397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161111397" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161111397">Scott Morrison (Mar 19 2019 at 01:09)</a>:</h4>
<p>(Have to disappear for a few hours, but I'll read up afterwards.)</p>

<a name="161111484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161111484" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161111484">Mario Carneiro (Mar 19 2019 at 01:10)</a>:</h4>
<p><a href="#narrow/stream/116395-maths/topic/Perfectoid.20spaces/near/159808751" title="#narrow/stream/116395-maths/topic/Perfectoid.20spaces/near/159808751">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfectoid.20spaces/near/159808751</a></p>

<a name="161111781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161111781" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161111781">Scott Morrison (Mar 19 2019 at 01:16)</a>:</h4>
<p>Okay, that is cool. :-)</p>

<a name="161111805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161111805" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161111805">Scott Morrison (Mar 19 2019 at 01:17)</a>:</h4>
<p>A lot of automation is going to be needed still, before the mathematicians can cope with this. :-)</p>

<a name="161111915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161111915" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161111915">Mario Carneiro (Mar 19 2019 at 01:19)</a>:</h4>
<p>right, this was really an exercise in finding out what major infrastructure components were missing in the automation we all expect</p>

<a name="161111924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161111924" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161111924">Mario Carneiro (Mar 19 2019 at 01:19)</a>:</h4>
<p><code>equiv.rel</code> in particular turned out to be important</p>

<a name="161111996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161111996" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161111996">Mario Carneiro (Mar 19 2019 at 01:20)</a>:</h4>
<p>eventually, <code>transfer</code> should be able to do the job of proving the last few theorems, although stuff about transferring ideals and other things will all need to be explicitly stated, at least, and marked for use with <code>transfer</code></p>

<a name="161126312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161126312" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161126312">Johan Commelin (Mar 19 2019 at 07:09)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> I'll try to write up the kind of proofs that I expect <code>tidy</code> to generate</p>

<a name="161130454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161130454" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161130454">Scott Morrison (Mar 19 2019 at 08:31)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span>, maybe it's not worth doing any now. The functoriality argument for <code>submodule</code> needs to rely on deeper layers of functoriality, anyway. May I should try writing the actual <code>iso_subst</code> and <code>iso_rw</code>tactic, because they'll in turn be used by the <code>[derive]</code> handler for functoriality and iso_functoriality instances...</p>

<a name="161130529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161130529" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161130529">Scott Morrison (Mar 19 2019 at 08:32)</a>:</h4>
<p>Also, I need to understand Mario's approach properly. I haven't understood yet how general it will be. (I'm initially a little worried taking about ring equivalences, and monoid equivalences, and .... all separately, rather than building the machinery abstractly at the level of isomorphisms in some category, but maybe I don't know what I'm talking about here. :-)</p>

<a name="161134135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161134135" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161134135">Kevin Buzzard (Mar 19 2019 at 09:32)</a>:</h4>
<p>I wanted to do some linear_ordered_comm_group equivalences for the perfectoid project and I've been slowly but surely writing <code>monoid_equiv</code>, <code>group_equiv</code>, <code>le_equiv</code>, <code>mul_equiv</code>, <code>add_group_equiv</code>, ...</p>

<a name="161136269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161136269" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161136269">Scott Morrison (Mar 19 2019 at 10:07)</a>:</h4>
<p>Hmmm... use bundled objects, bundled morphisms, set up the category instances, and get for free uniform notation and lemmas for all these notions of equivalence. I'm not really sure how plausible it is, but it seems a desirable goal.</p>

<a name="161136889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161136889" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161136889">Johan Commelin (Mar 19 2019 at 10:17)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> I've documented my attempt in a copy of your file. Pushed to the branch.</p>

<a name="161136898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161136898" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161136898">Johan Commelin (Mar 19 2019 at 10:17)</a>:</h4>
<p>It stops halfway because things got annoying.</p>

<a name="161136906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161136906" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161136906">Johan Commelin (Mar 19 2019 at 10:17)</a>:</h4>
<p>And because you said that I maybe shouldn't do it anyway <span aria-label="lol" class="emoji emoji-1f606" role="img" title="lol">:lol:</span></p>

<a name="161138152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161138152" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161138152">Kevin Buzzard (Mar 19 2019 at 10:34)</a>:</h4>
<p>...<code>has_zero_equiv</code>, <code>has_one_equiv</code>, ...</p>

<a name="161336619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161336619" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161336619">Kevin Buzzard (Mar 21 2019 at 11:34)</a>:</h4>
<p>I had an issue with transferring information along an isomorphism which took me two days of hard work to solve. During this time I learnt what I think might be a valuable lesson, so I'll just document it here.</p>
<p>If <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">G</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.08125em;">H</span></span></span></span> are isomorphic groups, and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>J</mi></mrow><annotation encoding="application/x-tex">J</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.09618em;">J</span></span></span></span> is a normal subgroup of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">G</span></span></span></span> with corresponding normal subgroups <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07153em;">K</span></span></span></span> of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.08125em;">H</span></span></span></span>, then <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mi mathvariant="normal">/</mi><mi>J</mi></mrow><annotation encoding="application/x-tex">G/J</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">G</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.09618em;">J</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mi mathvariant="normal">/</mi><mi>K</mi></mrow><annotation encoding="application/x-tex">H/K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.08125em;">H</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.07153em;">K</span></span></span></span> are isomorphic. </p>
<p>I proved this in Lean. I set up <code>group_equiv</code> and proved, amongst other things, <code>group_equiv.trans</code>. I then proved that if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϕ</mi><mo>:</mo><mi>G</mi><mo>→</mo><mi>H</mi></mrow><annotation encoding="application/x-tex">\phi:G\to H</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit">ϕ</span><span class="mrel">:</span><span class="mord mathit">G</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.08125em;">H</span></span></span></span> was a group isomorphism and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07153em;">K</span></span></span></span> was a normal subgroup of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.08125em;">H</span></span></span></span> then <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mi mathvariant="normal">/</mi><msup><mi>ϕ</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>(</mo><mi>K</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">G/\phi^{-1}(K)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">G</span><span class="mord mathrm">/</span><span class="mord"><span class="mord mathit">ϕ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathrm mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="mclose">)</span></span></span></span> was isomorphic to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mi mathvariant="normal">/</mi><mi>K</mi></mrow><annotation encoding="application/x-tex">H/K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.08125em;">H</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.07153em;">K</span></span></span></span>. This seemed to me like a good idea at the time, but in retrospect I think it was my mistake. I then proved the moronic theorem that if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">G</span></span></span></span> was a group and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>J</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">J_1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.09618em;">J</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.09618em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>J</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">J_2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.09618em;">J</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.09618em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> were two subgroups which were equal, then <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mi mathvariant="normal">/</mi><msub><mi>J</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">G/J_1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">G</span><span class="mord mathrm">/</span><span class="mord"><span class="mord mathit" style="margin-right:0.09618em;">J</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.09618em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> was isomorphic to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mi mathvariant="normal">/</mi><msub><mi>J</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">G/J_2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">G</span><span class="mord mathrm">/</span><span class="mord"><span class="mord mathit" style="margin-right:0.09618em;">J</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.09618em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span>. I proved this theorem because I know that ridiculous theorems of this form are sometimes what needs to be done. I then used transitivity to prove the <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mi mathvariant="normal">/</mi><mi>J</mi><mo>≅</mo><mi>H</mi><mi mathvariant="normal">/</mi><mi>K</mi></mrow><annotation encoding="application/x-tex">G/J\cong H/K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">G</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.09618em;">J</span><span class="mrel">≅</span><span class="mord mathit" style="margin-right:0.08125em;">H</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.07153em;">K</span></span></span></span> result and things were fine, until I wanted to start transporting things along the corresponding isomorphism and nothing seemed to unfold nicely and it was a nightmare. </p>
<p>Independently of working on this quotient issue we were working on another isomorphism issue -- if two integral domains are isomorphic then their fields of fractions are isomorphic. In fact Johan was working on this a couple of weeks ago, and he wrote <a href="https://github.com/leanprover-community/mathlib/blob/098c2cb1d1dab5f42260a6fe999abc252ceba313/src/ring_theory/localization.lean#L335" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/098c2cb1d1dab5f42260a6fe999abc252ceba313/src/ring_theory/localization.lean#L335">equiv_of_equiv</a>. This is a much better approach! This does the entire job in one go -- he has a hypothesis the analogue of which would be <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϕ</mi><mo>(</mo><mi>J</mi><mo>)</mo><mo>=</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">\phi(J)=K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">ϕ</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.09618em;">J</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.07153em;">K</span></span></span></span>. But preimages are slightly easier to work with than images, because image involves an existence statement which is not there with preimage. In summary then, I think this is the sort of theorem one should prove (and indeed I have proved in the perfectoid project):</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">group_equiv</span><span class="bp">.</span><span class="n">quotient</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">H</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">group</span> <span class="n">H</span><span class="o">]</span>
  <span class="o">(</span><span class="n">he</span> <span class="o">:</span> <span class="n">group_equiv</span> <span class="n">G</span> <span class="n">H</span><span class="o">)</span> <span class="o">(</span><span class="n">J</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="o">)</span> <span class="o">[</span><span class="n">normal_subgroup</span> <span class="n">J</span><span class="o">]</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="n">set</span> <span class="n">H</span><span class="o">)</span> <span class="o">[</span><span class="n">normal_subgroup</span> <span class="n">K</span><span class="o">]</span>
  <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">he</span><span class="bp">.</span><span class="n">to_equiv</span> <span class="bp">⁻¹</span><span class="err">&#39;</span> <span class="n">K</span> <span class="bp">=</span> <span class="n">J</span><span class="o">)</span> <span class="o">:</span>
<span class="n">group_equiv</span> <span class="o">(</span><span class="n">quotient_group</span><span class="bp">.</span><span class="n">quotient</span> <span class="n">J</span><span class="o">)</span> <span class="o">(</span><span class="n">quotient_group</span><span class="bp">.</span><span class="n">quotient</span> <span class="n">K</span><span class="o">)</span> <span class="o">:=</span>
</pre></div>


<p>It's interesting to note that all these thoughts about exactly what statements should be proved here are perhaps evidence for mathematicians that things are not quite as simple as they might seem when it comes to <code>transfer</code> or <code>cerw</code> or whatever we're calling it now. "If <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">G</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.08125em;">H</span></span></span></span> are isomorphic, with normal subgroups <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>J</mi></mrow><annotation encoding="application/x-tex">J</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.09618em;">J</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07153em;">K</span></span></span></span> identified with each other, then <em>obviously</em> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mi mathvariant="normal">/</mi><mi>J</mi><mo>=</mo><mi>H</mi><mi mathvariant="normal">/</mi><mi>K</mi></mrow><annotation encoding="application/x-tex">G/J=H/K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">G</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.09618em;">J</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.08125em;">H</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.07153em;">K</span></span></span></span>". Yeah but I've just found out the hard way that formalising this statement and proof the wrong way can cause a lot of pain later down the line.</p>

<a name="161336748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161336748" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161336748">Mario Carneiro (Mar 21 2019 at 11:36)</a>:</h4>
<p>I actually suggest neither preimages nor images, but rather a relation <code>equiv.rel(phi) J K</code></p>

<a name="161336800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161336800" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161336800">Mario Carneiro (Mar 21 2019 at 11:37)</a>:</h4>
<p>it can be defined to be the preimage equality though</p>

<a name="161336873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161336873" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161336873">Mario Carneiro (Mar 21 2019 at 11:38)</a>:</h4>
<p>or rather, it is the <code>equiv.rel</code> of the map <code>set J -&gt; set K</code> induced by <code>phi</code></p>

<a name="161336915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161336915" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161336915">Kevin Buzzard (Mar 21 2019 at 11:39)</a>:</h4>
<p>In practice the thing which was crucial for me was that the actual map can be defined "all in one go" using <code>lift</code>, rather than the way I had built it. This opens the door to things unfolding nicely.</p>

<a name="161336918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161336918" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161336918">Mario Carneiro (Mar 21 2019 at 11:39)</a>:</h4>
<p>The advantage of the relation is you get something more symmetric, which you can prove theorems about swaps and such</p>

<a name="161336980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161336980" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161336980">Mario Carneiro (Mar 21 2019 at 11:40)</a>:</h4>
<p>and it will fold nicely into future work on getting <code>transfer</code> to automate this stuff</p>

<a name="161336991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161336991" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161336991">Kevin Buzzard (Mar 21 2019 at 11:40)</a>:</h4>
<p>Right -- this is why I'm posting this in the cerw thread. I'd like to have a transfer thread really.</p>

<a name="161337046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161337046" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161337046">Kevin Buzzard (Mar 21 2019 at 11:41)</a>:</h4>
<p>Writing the perfectoid project has really taught me a lot about Lean's type theory, it has been a wonderful experience; I am now finally beginning to understand, and sometimes even solve myself, issues where what I want is trivial in maths but Lean won't buy it. These are, to me at least, the most frustrating things about using Lean.</p>

<a name="161337131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161337131" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161337131">Kevin Buzzard (Mar 21 2019 at 11:42)</a>:</h4>
<p>In particular I am beginning to understand more about the difficulties of transferring the things which transfer so naturally in mathematics, like this statement that if R and S are isomorphic rings and R is local then S is.</p>

<a name="161337178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161337178" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161337178">Mario Carneiro (Mar 21 2019 at 11:43)</a>:</h4>
<p>Do you follow the general strategy I tried to outline in that earlier stuff with <code>is_maximal_ideal</code>? For types, you want to define an equiv mapping (i.e. <code>A ~=r B</code> implies <code>ideal A ~= ideal B</code>), and for predicates you want to prove stuff about preserving <code>equiv.rel</code> on the component types</p>

<a name="161337309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161337309" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161337309">Mario Carneiro (Mar 21 2019 at 11:45)</a>:</h4>
<p>If done correctly these should be compositional, in that if you have some complicated definition and you have the appropriate transfer lemmas for all the pieces of the definition then there is a straightforward way to put them all together to get the analogous transfer lemma for your definition</p>

<a name="161337470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161337470" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161337470">Mario Carneiro (Mar 21 2019 at 11:47)</a>:</h4>
<p>You have the right idea with that lemma but to fit the mold <code>h2</code> should have the type <code>(equiv_set he).rel J K</code> where <code>equiv_set : A ~= B -&gt; set A ~= set B</code></p>

<a name="161337565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161337565" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161337565">Kevin Buzzard (Mar 21 2019 at 11:48)</a>:</h4>
<p>No I still did not sit down and look at the <code>is_maximal_ideal</code> stuff. Maybe this was an error. I am just highly focussed on the perfectoid project at the minute and am being ruthless. We're nearly there -- I can see the light at the end of the tunnel and the incentive to just keep working on it is very strong. I was up until 3am last night working on it and then up again at 7am doing more.</p>

<a name="161337680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161337680" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161337680">Mario Carneiro (Mar 21 2019 at 11:50)</a>:</h4>
<p>no problem, indeed if you have already proven your version of the statement then that's great. I'm thinking more in terms of how to link it up into a general theory, where you don't need any creativity to put the lemmas together</p>

<a name="161337712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161337712" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161337712">Mario Carneiro (Mar 21 2019 at 11:51)</a>:</h4>
<p>because we can't write a tactic to do the work for us until it's an utterly routine exercise</p>

<a name="161337741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161337741" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161337741">Kevin Buzzard (Mar 21 2019 at 11:51)</a>:</h4>
<p>I'm looking at it now.</p>
<div class="codehilite"><pre><span></span><span class="kn">instance</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">ring</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">α</span> <span class="err">≃</span><span class="n">r</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨λ_</span><span class="o">,</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">,</span> <span class="bp">λ</span><span class="n">e</span><span class="o">,</span> <span class="n">e</span><span class="bp">.</span><span class="n">to_equiv</span><span class="bp">⟩</span>
</pre></div>


<p>I did not put coe_to_fun instances for group_equiv and monoid_equiv and preorder_equiv and mul_equiv and add_equiv and all the other equivs, because there was not one for ring_equiv. Now I see you've put one in. Shall I put coercions in for all the other ones?</p>

<a name="161337798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161337798" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161337798">Kevin Buzzard (Mar 21 2019 at 11:52)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/789" target="_blank" title="https://github.com/leanprover-community/mathlib/issues/789">#789</a></p>

<a name="161337805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161337805" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161337805">Kevin Buzzard (Mar 21 2019 at 11:52)</a>:</h4>
<p><a href="#narrow/stream/144837-PR-reviews/topic/.23789.20extensions.20of.20equiv" title="#narrow/stream/144837-PR-reviews/topic/.23789.20extensions.20of.20equiv">https://leanprover.zulipchat.com/#narrow/stream/144837-PR-reviews/topic/.23789.20extensions.20of.20equiv</a></p>

<a name="161337871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161337871" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161337871">Kevin Buzzard (Mar 21 2019 at 11:53)</a>:</h4>
<p>Fancy a review of what I've PR'ed so far? ;-)</p>

<a name="161422525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161422525" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161422525">Johan Commelin (Mar 22 2019 at 05:51)</a>:</h4>
<blockquote>
<p>I actually suggest neither preimages nor images, but rather a relation <code>equiv.rel(phi) J K</code></p>
</blockquote>
<p>If we take this idea seriously (which is I guess the main claim of "Theorems for free") should we then also define <code>add_equiv</code> in terms of <code>equiv.rel (has_add.add A) (has_add.add B)</code>?</p>

<a name="161422596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161422596" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161422596">Johan Commelin (Mar 22 2019 at 05:53)</a>:</h4>
<p>After all, the <code>equiv.rel</code> between <code>A</code> and <code>B</code> induces an <code>equiv.rel</code> between <code>A → A → A</code> and <code>B → B → B</code>.</p>

<a name="161423159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161423159" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161423159">Mario Carneiro (Mar 22 2019 at 06:08)</a>:</h4>
<p>you don't need to define this specifically, it is <code>f.rel =&gt; f.rel =&gt; f.rel</code> if <code>f : A ~= B</code></p>

<a name="161424480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161424480" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161424480">Johan Commelin (Mar 22 2019 at 06:45)</a>:</h4>
<p>Sure... my question is: should we use those facts in the definition of <code>add_equiv</code>, <code>mul_equiv</code>, <code>le_equiv</code>, etc...</p>

<a name="161424537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161424537" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161424537">Johan Commelin (Mar 22 2019 at 06:46)</a>:</h4>
<p>If we use <code>rel</code> in their definitions, does that help down the line with inferring equivs, or transporting stuff?</p>

<a name="161424917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161424917" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161424917">Mario Carneiro (Mar 22 2019 at 06:56)</a>:</h4>
<p>the definition of add_equiv et al doesn't use any of this</p>

<a name="161424939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161424939" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161424939">Mario Carneiro (Mar 22 2019 at 06:57)</a>:</h4>
<p>rather, add_equiv et al are used to define the relations at the base case</p>

<a name="162359060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/162359060" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#162359060">Alexander Bentkamp (Apr 02 2019 at 18:04)</a>:</h4>
<p>(deleted)</p>

<a name="162629834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/162629834" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#162629834">Kevin Buzzard (Apr 05 2019 at 14:50)</a>:</h4>
<p>Hey <span class="user-mention" data-user-id="110172">@Assia Mahboubi</span> . A commutative ring is called _local_ if it has a unique maximal ideal. If you find a mathematician and ask them the following question: "if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.00773em;">R</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span></span> are isomorphic rings, and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.00773em;">R</span></span></span></span> is local, is <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span></span> local?", then I think they will struggle to say anything useful other than "the answer is obviously yes". This is because "local", like every other predicate on rings that a mathematician uses, is constant on isomorphism classes. Unfortunately it turns out that there are completely valid predicates which no mathematician cares about but which do not have this property (e.g. <code>P X := X = R</code>). If you had to prove this statement about local rings in Coq, how would it go? Can you get it for free, or cheaply? The people here are trying to make a tactic which does it, and progress is being made, but I think we're not there yet.</p>


{% endraw %}

{% include archive_update.html %}