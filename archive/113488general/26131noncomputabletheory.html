---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/26131noncomputabletheory.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/26131noncomputabletheory.html">noncomputable theory</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="192772130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/noncomputable%20theory/near/192772130" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/26131noncomputabletheory.html#192772130">Kevin Buzzard (Apr 03 2020 at 08:36)</a>:</h4>
<p>I remember <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> once saying something of the form "I wish people wouldn't start files with <code>noncomputable theory</code>". It now occurs over 100 times in mathlib. Is what is going on the following? In a file with no <code>noncomputable theory</code> in it, If I incorrectly do or don't mark a definition as noncomputable then Lean will typically tell me. But if I start a file with <code>noncomputable theory</code> then this check is just switched off. Is it then the case that various possibly-computable functions get marked as noncomputable? Does this change anything? Could a combination of a linter and a way of temporarily switching off <code>noncomputable theory</code> do something about this, or have I just misunderstood what <code>noncomputable theory</code> is doing? Of course I'm not suggesting that <code>topology/metric_space/*</code> be made computable, this clearly shouldn't be done in mathlib which has made the decision to be resolutely classical (thank goodness!) -- but I'm just wondering whether we have computable functions incorrectly tagged as noncomputable.</p>

<a name="192772742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/noncomputable%20theory/near/192772742" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/26131noncomputabletheory.html#192772742">Alex J. Best (Apr 03 2020 at 08:42)</a>:</h4>
<p>I just made a file put noncomputable theory at the start and made a <code>def</code> and eval'd it, worked fine, so it seems adding noncomputable theory doesn't stop basic functions from being computable, just removes the warning when you "accidentally" make something noncomputable.</p>

<a name="192774748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/noncomputable%20theory/near/192774748" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/26131noncomputabletheory.html#192774748">Kevin Buzzard (Apr 03 2020 at 08:59)</a>:</h4>
<p>I wonder why Mario was complaining then? Maybe I misremembered?</p>

<a name="192775251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/noncomputable%20theory/near/192775251" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/26131noncomputabletheory.html#192775251">Alex J. Best (Apr 03 2020 at 09:02)</a>:</h4>
<p><a href="#narrow/stream/113488-general/topic/computability/near/168198880" title="#narrow/stream/113488-general/topic/computability/near/168198880">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168198880</a></p>

<a name="192782206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/noncomputable%20theory/near/192782206" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/26131noncomputabletheory.html#192782206">Kevin Buzzard (Apr 03 2020 at 10:05)</a>:</h4>
<p>Me : "I just don't get why computability is important to me if I just want to make mathematical objects and state and prove theorems about them."</p>
<p>Mario : "It's not, unless you are Anrdej Bauer"</p>
<p>This is not right. I might not be <em>interested</em> in it, but if I want to do mathematics in Lean "the way mathmaticians do it" then I am absolutely relying on it.</p>

<a name="192782272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/noncomputable%20theory/near/192782272" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/26131noncomputabletheory.html#192782272">Kevin Buzzard (Apr 03 2020 at 10:05)</a>:</h4>
<p>because I absolutely need high-powered tactics like <code>ring</code></p>

<a name="192782381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/noncomputable%20theory/near/192782381" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/26131noncomputabletheory.html#192782381">Kevin Buzzard (Apr 03 2020 at 10:06)</a>:</h4>
<p>I need <code>details_left_to_the_interested_reader</code>, that's the kind of tactic which will get generic mathematicians interested. <code>simp</code>on steroids.</p>

<a name="192783166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/noncomputable%20theory/near/192783166" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/26131noncomputabletheory.html#192783166">Mario Carneiro (Apr 03 2020 at 10:15)</a>:</h4>
<p>I don't recall making this specific complaint</p>

<a name="192783353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/noncomputable%20theory/near/192783353" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/26131noncomputabletheory.html#192783353">Mario Carneiro (Apr 03 2020 at 10:16)</a>:</h4>
<blockquote>
<p>In a file with no noncomputable theory in it, If I incorrectly do or don't mark a definition as noncomputable then Lean will typically tell me. But if I start a file with noncomputable theory then this check is just switched off.</p>
</blockquote>
<p>Actually, the check isn't switched off, the <code>noncomputable</code> marking is inferred rather than checked. If you look at <code>def</code>s made in a file with <code>noncomputable theory</code>, you will see that they are still being marked <code>noncomputable</code>, you just don't have to write this keyword on the def yourself</p>

<a name="192783419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/noncomputable%20theory/near/192783419" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/26131noncomputabletheory.html#192783419">Mario Carneiro (Apr 03 2020 at 10:17)</a>:</h4>
<p>and defs that are actually computable will not be unnecessarily marked <code>noncomputable</code></p>

<a name="192784933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/noncomputable%20theory/near/192784933" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/26131noncomputabletheory.html#192784933">Mario Carneiro (Apr 03 2020 at 10:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113488-general/topic/noncomputable.20theory/near/192782206" title="#narrow/stream/113488-general/topic/noncomputable.20theory/near/192782206">said</a>:</p>
<blockquote>
<p>Me : "I just don't get why computability is important to me if I just want to make mathematical objects and state and prove theorems about them."</p>
<p>Mario : "It's not, unless you are Anrdej Bauer"</p>
<p>This is not right. I might not be <em>interested</em> in it, but if I want to do mathematics in Lean "the way mathmaticians do it" then I am absolutely relying on it.</p>
</blockquote>
<p>This is an argument for why you should care that tactics, i.e. programs meant to be run, are computable. It is not an argument for why e.g. real numbers, algebraic varieties, or multivariate polynomials should be computable. Tactics are already <code>meta</code>, which means they are essentially opting out to the "proofy" part of lean, which means if they didn't fit in the "programming" part of lean either they would be useless. So these functions are all expected to be computable. For non-<code>meta</code> functions, there is a proofy aspect, and you can opt out of the "programming" part by using <code>noncomputable</code>. My point is that in most or all of these cases, you the mathematician don't have to ever care about that marking, it only concerns programming applications.</p>
<p>It may turn out that there is some part of lean that is in the intersection of both of these worlds, such as <code>nat</code> or <code>int</code> or <code>list A</code>, where we want the functions to be both non-<code>meta</code> and computable, because the types serve both purposes. However, it is often the case that the best way to represent something for programming is not the best way for proofs, so even in these cases having a distinction is useful. In fact, even in these three cases, this is exactly what happens. <code>nat</code> and <code>int</code> are only good for computation because of a dirty hack in the lean VM to replace the incredibly inefficient unary representation with a bignum arithmetic package. If you had to do this in lean the type <code>gmp_nat</code> would be significantly more complicated and would certainly not look like an inductive type with zero and succ. The computational content of <code>list A</code> is a singly linked list, which is well known not to be the best way to store lists of values in a computer by a pretty significant margin. Here we have the <code>buffer A</code> type as an alternative, but it's not as nice for proving theorems.</p>
<p>So I think that to a first approximation there is little overlap between "lean for proofs" and "lean for programming". Having the ability to do both at once is nice, but usually this requires a trade off between the computationally efficient thing and the easy to prove thing. So when you are doing maths just forget about computability, and when you are doing programming choose the best types for the job.</p>

<a name="192790625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/noncomputable%20theory/near/192790625" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/26131noncomputabletheory.html#192790625">Kevin Buzzard (Apr 03 2020 at 11:40)</a>:</h4>
<p>Re list A and buffer A we can prove the theorems about lists and you can use the transfer tactic to port the theorems into theorems about buffers</p>

<a name="192791131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/noncomputable%20theory/near/192791131" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/26131noncomputabletheory.html#192791131">Kevin Buzzard (Apr 03 2020 at 11:43)</a>:</h4>
<p>The <code>ring</code> tactic works with the real numbers and I really need it on the real numbers for pedagogical purposes. The real numbers aren't computable but if there were no <code>ring</code> tactic I would have left long ago. Scott's tactic <code>obviously</code> make it clear that this is what we mathematicians are aiming for -- a system that can do the obvious bits</p>

<a name="192791205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/noncomputable%20theory/near/192791205" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/26131noncomputabletheory.html#192791205">Kevin Buzzard (Apr 03 2020 at 11:44)</a>:</h4>
<p>But for that all the computability stuff is super important</p>

<a name="192791308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/noncomputable%20theory/near/192791308" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/26131noncomputabletheory.html#192791308">Kevin Buzzard (Apr 03 2020 at 11:45)</a>:</h4>
<p>I'm just putting it all together that's all. Why doesn't a transfer tactic solve your buffer list woes?</p>

<a name="192795342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/noncomputable%20theory/near/192795342" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/26131noncomputabletheory.html#192795342">Mario Carneiro (Apr 03 2020 at 12:25)</a>:</h4>
<blockquote>
<p>Re list A and buffer A we can prove the theorems about lists and you can use the transfer tactic to port the theorems into theorems about buffers</p>
</blockquote>
<p>Right, I think this should be the preferred method. This is how all the theorems about <code>num</code> are proved, and if we wrote a <code>gmp_nat</code> type it would also be presumably isomorphic to <code>nat</code> and hence we could do the same trick. But this is only underscoring the importance of separating the implementation type from the abstract mathematical type</p>

<a name="192795535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/noncomputable%20theory/near/192795535" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/26131noncomputabletheory.html#192795535">Mario Carneiro (Apr 03 2020 at 12:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113488-general/topic/noncomputable.20theory/near/192791131" title="#narrow/stream/113488-general/topic/noncomputable.20theory/near/192791131">said</a>:</p>
<blockquote>
<p>The <code>ring</code> tactic works with the real numbers and I really need it on the real numbers for pedagogical purposes. The real numbers aren't computable but if there were no <code>ring</code> tactic I would have left long ago. Scott's tactic <code>obviously</code> make it clear that this is what we mathematicians are aiming for -- a system that can do the obvious bits</p>
</blockquote>
<p>The <code>ring</code> tactic does not work on real numbers, it works on <code>expr</code>, which is a perfectly reasonable computable type. It just so happens that the <code>expr</code>s that it manipulates are talking about real numbers, but by moving to meta land even the most complicated noncomputable mathematical types become computable again because everything is an <code>expr</code></p>

<a name="192795695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/noncomputable%20theory/near/192795695" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/26131noncomputabletheory.html#192795695">Mario Carneiro (Apr 03 2020 at 12:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113488-general/topic/noncomputable.20theory/near/192791205" title="#narrow/stream/113488-general/topic/noncomputable.20theory/near/192791205">said</a>:</p>
<blockquote>
<p>But for that all the computability stuff is super important</p>
</blockquote>
<p>Nope, <code>ring</code> should demonstrate this fairly well - for tactics it doesn't matter at all if the type that is being discussed is computable</p>

<a name="192795856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/noncomputable%20theory/near/192795856" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/26131noncomputabletheory.html#192795856">Mario Carneiro (Apr 03 2020 at 12:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113488-general/topic/noncomputable.20theory/near/192791308" title="#narrow/stream/113488-general/topic/noncomputable.20theory/near/192791308">said</a>:</p>
<blockquote>
<p>Why doesn't a transfer tactic solve your buffer list woes?</p>
</blockquote>
<p>I think it does, and in the proofs in <code>data.num.lemmas</code> I think you will actually see a poor man's transfer tactic in there. This kind of thing is one of the primary motivating examples for the transfer tactic</p>

<a name="192907982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/noncomputable%20theory/near/192907982" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/26131noncomputabletheory.html#192907982">Anton Lorenzen (Apr 04 2020 at 13:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113488-general/topic/noncomputable.20theory/near/192790625" title="#narrow/stream/113488-general/topic/noncomputable.20theory/near/192790625">said</a>:</p>
<blockquote>
<p>Re list A and buffer A we can prove the theorems about lists and you can use the transfer tactic to port the theorems into theorems about buffers</p>
</blockquote>
<p>That sounds super useful for doing computations in Lean! Could it be used to transfer the lemmas about <code>data.finset</code> to lemmas about a red-black tree? Mathlib matrices to sparse matrices? Reals to floating point numbers up to some error margin?</p>

<a name="192908411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/noncomputable%20theory/near/192908411" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/26131noncomputabletheory.html#192908411">Kevin Buzzard (Apr 04 2020 at 13:48)</a>:</h4>
<p>I am not sure about the reals because those types are not isomorphic</p>

<a name="192908705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/noncomputable%20theory/near/192908705" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/26131noncomputabletheory.html#192908705">Alex J. Best (Apr 04 2020 at 13:55)</a>:</h4>
<p>As Kevin says, you need two equivalent types, so I'm not sure what the first example you mention means. The second is totally the sort of thing transfer should do. And as for the third fixed precision floating points are not the same as the reals, but perhaps the equivalence (cauchy sequences) &lt;-&gt; (cauchy sequences with a fixed convergence rate) is another example in the direction you are thinking.</p>

<a name="192913121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/noncomputable%20theory/near/192913121" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/26131noncomputabletheory.html#192913121">Mario Carneiro (Apr 04 2020 at 15:33)</a>:</h4>
<p>Actually <code>transfer</code> doesn't require isomorphism. It requires a couple things depending on what operators it sees, but for example you can enter a forall binder if the relation is bi-total, which means <code>(∀b, ∃a, R a b) ∧ (∀a, ∃b, R a b)</code></p>

<a name="192913192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/noncomputable%20theory/near/192913192" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/26131noncomputabletheory.html#192913192">Mario Carneiro (Apr 04 2020 at 15:34)</a>:</h4>
<p>The proof of properties of <code>int</code> by transfer from <code>nat x nat</code> is very much not an isomorphism</p>


{% endraw %}

{% include archive_update.html %}