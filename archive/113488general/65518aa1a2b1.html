---
layout: archive
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/65518aa1a2b1.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/65518aa1a2b1.html">`[a,a+1,a+2,...,b-1]`?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="124393624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60%5Ba%2Ca%2B1%2Ca%2B2%2C...%2Cb-1%5D%60%3F/near/124393624" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/65518aa1a2b1.html#124393624">Kevin Buzzard (Mar 30 2018 at 01:51)</a>:</h4>
<p>Is there a name in Lean for the list (or multiset, or finset)<code>[a,a+1,a+2,...,b-1]</code>?</p>

<a name="124393662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60%5Ba%2Ca%2B1%2Ca%2B2%2C...%2Cb-1%5D%60%3F/near/124393662" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/65518aa1a2b1.html#124393662">Kevin Buzzard (Mar 30 2018 at 01:52)</a>:</h4>
<p>python <code>range(a,b)</code></p>

<a name="124393957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60%5Ba%2Ca%2B1%2Ca%2B2%2C...%2Cb-1%5D%60%3F/near/124393957" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/65518aa1a2b1.html#124393957">Kenny Lau (Mar 30 2018 at 02:02)</a>:</h4>
<div class="codehilite"><pre><span></span>def range : nat → nat → list nat
| a 0     := []
| 0 1     := [0]
| a 1     := []
| a (b+2) := if b+1 &lt; a then [] else range a (b+1) ++ [nat.succ b]
</pre></div>

<a name="124394370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60%5Ba%2Ca%2B1%2Ca%2B2%2C...%2Cb-1%5D%60%3F/near/124394370" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/65518aa1a2b1.html#124394370">Mario Carneiro (Mar 30 2018 at 02:18)</a>:</h4>
<p>You will notice that most of the properties of <code>list.range</code> are proven by using an auxiliary definition <code>list.range'</code>, which is very similar to the list you have described. <code>list.range' s n</code> is the list <code>[s, s+1, ..., s+n-1]</code>, so your <code>range</code> function is <code>list.range' a (b-a)</code>. The definition of range' using start and length instead of start and end is of course because it has better properties wrt induction - it's not possible to have a range that goes to a value less than it starts with, and it's best to encode that directly in the definition</p>

<a name="124394477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60%5Ba%2Ca%2B1%2Ca%2B2%2C...%2Cb-1%5D%60%3F/near/124394477" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/65518aa1a2b1.html#124394477">Kenny Lau (Mar 30 2018 at 02:23)</a>:</h4>
<div class="codehilite"><pre><span></span>def range : nat → nat → list nat
| a 0     := []
| a (b+1) := if b &lt; a then [] else range a b ++ [b]
</pre></div>


{% endraw %}
