---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/90404unifyfailsinthepresenceofbinders.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/90404unifyfailsinthepresenceofbinders.html">unify fails in the presence of binders</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="173632081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unify%20fails%20in%20the%20presence%20of%20binders/near/173632081" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90404unifyfailsinthepresenceofbinders.html#173632081">Cyril Cohen (Aug 20 2019 at 06:18)</a>:</h4>
<p>I encountered the following problem: <code>nat.pred</code> and <code>nat.pred._main</code> unify well, but if I eta-expant them, unification fails! Does someone have an explanation?</p>
<div class="codehilite"><pre><span></span><span class="n">run_cmd</span> <span class="n">do</span>
  <span class="k">let</span> <span class="n">trace_unify</span> <span class="o">(</span><span class="n">e1</span> <span class="n">e2</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span> <span class="o">(</span><span class="n">do</span>
    <span class="n">trace</span> <span class="err">$</span> <span class="s2">&quot;try to unify &quot;</span> <span class="bp">++</span> <span class="n">to_string</span> <span class="n">e1</span> <span class="bp">++</span> <span class="s2">&quot; with &quot;</span> <span class="bp">++</span> <span class="n">to_string</span> <span class="n">e2</span><span class="o">,</span>
    <span class="n">unify</span> <span class="n">e1</span> <span class="n">e2</span> <span class="n">transparency</span><span class="bp">.</span><span class="n">all</span><span class="o">,</span>
    <span class="n">trace</span> <span class="err">$</span> <span class="s2">&quot;unify successful between &quot;</span> <span class="bp">++</span> <span class="n">to_string</span> <span class="n">e1</span> <span class="bp">++</span> <span class="s2">&quot; with &quot;</span> <span class="bp">++</span> <span class="n">to_string</span> <span class="n">e2</span><span class="o">),</span>
  <span class="k">let</span> <span class="n">c1</span> <span class="o">:</span> <span class="n">expr</span> <span class="n">tt</span> <span class="o">:=</span> <span class="n">const</span> <span class="bp">`</span><span class="n">nat</span><span class="bp">.</span><span class="n">pred</span> <span class="o">[],</span>
  <span class="k">let</span> <span class="n">c2</span> <span class="o">:</span> <span class="n">expr</span> <span class="n">tt</span> <span class="o">:=</span> <span class="n">const</span> <span class="bp">`</span><span class="n">nat</span><span class="bp">.</span><span class="n">pred</span><span class="bp">._</span><span class="n">main</span> <span class="o">[],</span>
  <span class="n">trace_unify</span> <span class="n">c1</span> <span class="n">c2</span><span class="o">,</span> <span class="c1">-- success</span>
  <span class="n">trace</span> <span class="s2">&quot;&quot;</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">eta_nat</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">lam</span> <span class="bp">`</span><span class="n">n</span> <span class="n">bid</span> <span class="o">(</span><span class="n">const</span> <span class="bp">`</span><span class="n">nat</span> <span class="o">[])</span> <span class="err">$</span> <span class="n">mk_app</span> <span class="n">t</span> <span class="o">[</span><span class="n">var</span> <span class="mi">0</span><span class="o">],</span>
  <span class="n">trace_unify</span> <span class="o">(</span><span class="n">eta_nat</span> <span class="n">c1</span><span class="o">)</span> <span class="o">(</span><span class="n">eta_nat</span> <span class="n">c2</span><span class="o">)</span> <span class="c1">-- failure!</span>
</pre></div>

<a name="173638904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unify%20fails%20in%20the%20presence%20of%20binders/near/173638904" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90404unifyfailsinthepresenceofbinders.html#173638904">Rob Lewis (Aug 20 2019 at 08:40)</a>:</h4>
<p>I had no idea the syntax <code>let eta_nat t := ...</code> is allowed, heh.</p>

<a name="173638918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unify%20fails%20in%20the%20presence%20of%20binders/near/173638918" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90404unifyfailsinthepresenceofbinders.html#173638918">Rob Lewis (Aug 20 2019 at 08:41)</a>:</h4>
<p>I'll look into this when I have a minute.</p>

<a name="173649746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unify%20fails%20in%20the%20presence%20of%20binders/near/173649746" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90404unifyfailsinthepresenceofbinders.html#173649746">Rob Lewis (Aug 20 2019 at 11:40)</a>:</h4>
<p>I'm not sure what's going on. Does the elaborator use a special method for constants defined using the equation compiler? What's the relevant difference between <code>n_id</code> and <code>n_id2</code> here?</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">n_id</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">k</span><span class="bp">+</span><span class="mi">1</span>

<span class="kn">set_option</span> <span class="n">pp</span><span class="bp">.</span><span class="n">all</span> <span class="n">true</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">n_id</span> <span class="c1">-- n_id._main</span>

<span class="n">def</span> <span class="n">n_id2</span> <span class="o">:=</span> <span class="n">n_id</span><span class="bp">._</span><span class="n">main</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">n_id</span> <span class="bp">=</span> <span class="n">n_id2</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">-- succeeds</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">n_id</span> <span class="bp">=</span> <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">n_id</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">-- fails</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">n_id</span> <span class="bp">=</span> <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">n_id</span> <span class="n">n</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">dsimp</span><span class="o">,</span> <span class="n">refl</span><span class="o">}</span> <span class="c1">-- succeeds</span>
<span class="c1">-- proof term:</span>
<span class="c1">-- @id.{0} (@eq.{1} (nat → nat) n_id (λ (n : nat), n_id n)) (@eq.refl.{1} (nat → nat) n_id)</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">n_id</span> <span class="bp">=</span> <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">n_id</span> <span class="n">n</span> <span class="o">:=</span> <span class="c1">-- fails</span>
<span class="bp">@</span><span class="n">id</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="o">(</span><span class="bp">@</span><span class="n">eq</span><span class="bp">.</span><span class="o">{</span><span class="mi">1</span><span class="o">}</span> <span class="o">(</span><span class="n">nat</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="n">n_id</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="n">n_id</span> <span class="n">n</span><span class="o">))</span> <span class="o">(</span><span class="bp">@</span><span class="n">eq</span><span class="bp">.</span><span class="n">refl</span><span class="bp">.</span><span class="o">{</span><span class="mi">1</span><span class="o">}</span> <span class="o">(</span><span class="n">nat</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="n">n_id</span><span class="o">)</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">n_id2</span> <span class="bp">=</span> <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">n_id2</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">-- succeeds</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">n_id</span> <span class="bp">=</span> <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">n_id2</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">-- succeeds</span>
</pre></div>

<a name="173651377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unify%20fails%20in%20the%20presence%20of%20binders/near/173651377" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90404unifyfailsinthepresenceofbinders.html#173651377">Cyril Cohen (Aug 20 2019 at 12:08)</a>:</h4>
<p>that's really weird, do you know who would know what's happening?</p>

<a name="173655079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unify%20fails%20in%20the%20presence%20of%20binders/near/173655079" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90404unifyfailsinthepresenceofbinders.html#173655079">Rob Lewis (Aug 20 2019 at 13:02)</a>:</h4>
<p>This is bizarre. The declarations <code>n_id</code> and <code>n_id2</code> are completely identical, unless there are attributes that aren't being printed. I'm not familiar with the elaborator code base, but it looks plausible that it's handling constants from the equation compiler differently.</p>

<a name="173655136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unify%20fails%20in%20the%20presence%20of%20binders/near/173655136" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90404unifyfailsinthepresenceofbinders.html#173655136">Rob Lewis (Aug 20 2019 at 13:03)</a>:</h4>
<p>I can't say for sure without stepping through it.</p>

<a name="173655175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unify%20fails%20in%20the%20presence%20of%20binders/near/173655175" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90404unifyfailsinthepresenceofbinders.html#173655175">Rob Lewis (Aug 20 2019 at 13:03)</a>:</h4>
<p>Maybe <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> or <span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span> know? But Mario's reaction doesn't seem promising.</p>

<a name="173655308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unify%20fails%20in%20the%20presence%20of%20binders/near/173655308" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90404unifyfailsinthepresenceofbinders.html#173655308">Wojciech Nawrocki (Aug 20 2019 at 13:05)</a>:</h4>
<p>Does Lean have a special case for typechecking via eta in the kernel? Since eta is derivable but iirc not part of the core algorithmic defeq rules</p>

<a name="173655310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unify%20fails%20in%20the%20presence%20of%20binders/near/173655310" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90404unifyfailsinthepresenceofbinders.html#173655310">Mario Carneiro (Aug 20 2019 at 13:05)</a>:</h4>
<p>I would guess it is some elaborator thing. It certainly wouldn't be the first time the elaborator shows weird edge case behaviors when you mess with reducibility settings and auxiliaries</p>

<a name="173655339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unify%20fails%20in%20the%20presence%20of%20binders/near/173655339" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90404unifyfailsinthepresenceofbinders.html#173655339">Mario Carneiro (Aug 20 2019 at 13:05)</a>:</h4>
<p>I'm 99% sure the kernel has no problem accepting this proof</p>

<a name="173655463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unify%20fails%20in%20the%20presence%20of%20binders/near/173655463" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90404unifyfailsinthepresenceofbinders.html#173655463">Chris Hughes (Aug 20 2019 at 13:07)</a>:</h4>
<p>works</p>
<div class="codehilite"><pre><span></span><span class="n">run_cmd</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">add_decl</span> <span class="err">$</span> <span class="n">declaration</span><span class="bp">.</span><span class="n">thm</span> <span class="bp">`</span><span class="n">nat</span><span class="bp">.</span><span class="n">pred_eq_pred_main</span> <span class="o">[]</span>
  <span class="bp">`</span><span class="o">((</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">pred</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">pred</span><span class="bp">._</span><span class="n">main</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">pure</span> <span class="bp">`</span><span class="o">(</span><span class="bp">@</span><span class="n">rfl</span> <span class="bp">_</span> <span class="n">nat</span><span class="bp">.</span><span class="n">pred</span><span class="o">))</span>
</pre></div>

<a name="173655494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unify%20fails%20in%20the%20presence%20of%20binders/near/173655494" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90404unifyfailsinthepresenceofbinders.html#173655494">Mario Carneiro (Aug 20 2019 at 13:07)</a>:</h4>
<p>eta is part of the core rules. It's not a reduction but it is handled in the preprocessing stage in a way that should be complete</p>

<a name="173655921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unify%20fails%20in%20the%20presence%20of%20binders/near/173655921" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90404unifyfailsinthepresenceofbinders.html#173655921">Cyril Cohen (Aug 20 2019 at 13:12)</a>:</h4>
<p>I guess the weirdest part is that <code>n_id = λ n, n_id2 n := rfl</code> succeeds while <code>n_id = λ n, n_id n := rfl</code> fails</p>

<a name="173656453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unify%20fails%20in%20the%20presence%20of%20binders/near/173656453" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90404unifyfailsinthepresenceofbinders.html#173656453">Rob Lewis (Aug 20 2019 at 13:18)</a>:</h4>
<p><span class="user-mention" data-user-id="110193">@Cyril Cohen</span> For your original issue: if you really need to check if things are defeq instead of unifying them, you could follow Chris' example -- if you can add a declaration proving they're equal by <code>rfl</code>, then they're defeq, and this skips the elaborator. Otherwise, maybe you could <code>dsimp</code> with an empty simp set before unifying:</p>
<div class="codehilite"><pre><span></span><span class="n">run_cmd</span> <span class="n">do</span>
  <span class="k">let</span> <span class="n">trace_unify</span> <span class="o">(</span><span class="n">e1</span> <span class="n">e2</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span> <span class="o">(</span><span class="n">do</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">simp_lemmas</span><span class="bp">.</span><span class="n">mk</span><span class="o">,</span>
    <span class="n">e1</span> <span class="err">←</span> <span class="n">s</span><span class="bp">.</span><span class="n">dsimplify</span> <span class="o">[]</span> <span class="n">e1</span> <span class="bp">&lt;|&gt;</span> <span class="n">return</span> <span class="n">e1</span><span class="o">,</span> <span class="n">e2</span> <span class="err">←</span> <span class="n">s</span><span class="bp">.</span><span class="n">dsimplify</span> <span class="o">[]</span> <span class="n">e2</span> <span class="bp">&lt;|&gt;</span> <span class="n">return</span> <span class="n">e2</span><span class="o">,</span>
    <span class="n">trace</span> <span class="err">$</span> <span class="s2">&quot;try to unify &quot;</span> <span class="bp">++</span> <span class="n">to_string</span> <span class="n">e1</span> <span class="bp">++</span> <span class="s2">&quot; with &quot;</span> <span class="bp">++</span> <span class="n">to_string</span> <span class="n">e2</span><span class="o">,</span>
    <span class="n">unify</span> <span class="n">e1</span> <span class="n">e2</span> <span class="n">transparency</span><span class="bp">.</span><span class="n">all</span><span class="o">,</span>
    <span class="n">trace</span> <span class="err">$</span> <span class="s2">&quot;unify successful between &quot;</span> <span class="bp">++</span> <span class="n">to_string</span> <span class="n">e1</span> <span class="bp">++</span> <span class="s2">&quot; with &quot;</span> <span class="bp">++</span> <span class="n">to_string</span> <span class="n">e2</span><span class="o">),</span>
  <span class="k">let</span> <span class="n">c1</span> <span class="o">:</span> <span class="n">expr</span> <span class="n">tt</span> <span class="o">:=</span> <span class="n">const</span> <span class="bp">`</span><span class="n">nat</span><span class="bp">.</span><span class="n">pred</span> <span class="o">[],</span>
  <span class="k">let</span> <span class="n">c2</span> <span class="o">:</span> <span class="n">expr</span> <span class="n">tt</span> <span class="o">:=</span> <span class="n">const</span> <span class="bp">`</span><span class="n">nat</span><span class="bp">.</span><span class="n">pred</span><span class="bp">._</span><span class="n">main</span> <span class="o">[],</span>
  <span class="n">trace_unify</span> <span class="n">c1</span> <span class="n">c2</span><span class="o">,</span> <span class="c1">-- success</span>
  <span class="n">trace</span> <span class="s2">&quot;&quot;</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">eta_nat</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">lam</span> <span class="bp">`</span><span class="n">n</span> <span class="n">bid</span> <span class="o">(</span><span class="n">const</span> <span class="bp">`</span><span class="n">nat</span> <span class="o">[])</span> <span class="err">$</span> <span class="n">mk_app</span> <span class="n">t</span> <span class="o">[</span><span class="n">var</span> <span class="mi">0</span><span class="o">],</span>
  <span class="n">trace_unify</span> <span class="o">(</span><span class="n">eta_nat</span> <span class="n">c1</span><span class="o">)</span> <span class="o">(</span><span class="n">eta_nat</span> <span class="n">c2</span><span class="o">)</span>
</pre></div>

<a name="173656880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unify%20fails%20in%20the%20presence%20of%20binders/near/173656880" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90404unifyfailsinthepresenceofbinders.html#173656880">Cyril Cohen (Aug 20 2019 at 13:22)</a>:</h4>
<p><span class="user-mention" data-user-id="110596">@Rob Lewis</span> I really need to unify, my example was a reduced case originating from a real unification problem. I will try to dsimp, thanks for your advice.</p>

<a name="173658781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unify%20fails%20in%20the%20presence%20of%20binders/near/173658781" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90404unifyfailsinthepresenceofbinders.html#173658781">Cyril Cohen (Aug 20 2019 at 13:43)</a>:</h4>
<p><span class="user-mention" data-user-id="110596">@Rob Lewis</span> your solution seems to work for eta expansion, but eta expansion was sadly a special case of my problem. Here is another example of failure which I would like to work...</p>
<div class="codehilite"><pre><span></span><span class="n">run_cmd</span> <span class="n">do</span>
  <span class="k">let</span> <span class="n">trace_unify</span> <span class="o">(</span><span class="n">e1</span> <span class="n">e2</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span> <span class="o">(</span><span class="n">do</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">simp_lemmas</span><span class="bp">.</span><span class="n">mk</span><span class="o">,</span>
    <span class="n">e1</span> <span class="err">←</span> <span class="n">s</span><span class="bp">.</span><span class="n">dsimplify</span> <span class="o">[]</span> <span class="n">e1</span> <span class="bp">&lt;|&gt;</span> <span class="n">return</span> <span class="n">e1</span><span class="o">,</span> <span class="n">e2</span> <span class="err">←</span> <span class="n">s</span><span class="bp">.</span><span class="n">dsimplify</span> <span class="o">[]</span> <span class="n">e2</span> <span class="bp">&lt;|&gt;</span> <span class="n">return</span> <span class="n">e2</span><span class="o">,</span>
    <span class="n">trace</span> <span class="err">$</span> <span class="s2">&quot;try to unify &quot;</span> <span class="bp">++</span> <span class="n">to_string</span> <span class="n">e1</span> <span class="bp">++</span> <span class="s2">&quot; with &quot;</span> <span class="bp">++</span> <span class="n">to_string</span> <span class="n">e2</span><span class="o">,</span>
    <span class="n">unify</span> <span class="n">e1</span> <span class="n">e2</span> <span class="n">transparency</span><span class="bp">.</span><span class="n">all</span><span class="o">,</span>
    <span class="n">trace</span> <span class="err">$</span> <span class="s2">&quot;unify successful between &quot;</span> <span class="bp">++</span> <span class="n">to_string</span> <span class="n">e1</span> <span class="bp">++</span> <span class="s2">&quot; with &quot;</span> <span class="bp">++</span> <span class="n">to_string</span> <span class="n">e2</span><span class="o">),</span>
  <span class="n">t1</span> <span class="err">←</span> <span class="n">to_expr</span> <span class="bp">``</span><span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a0</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="n">n_id</span><span class="bp">._</span><span class="n">main</span> <span class="n">a0</span> <span class="bp">=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero</span><span class="o">),</span> <span class="c1">-- removing `= nat.zero` here</span>
  <span class="n">t2</span> <span class="err">←</span> <span class="n">to_expr</span> <span class="bp">``</span><span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a0</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="n">n_id</span> <span class="n">a0</span> <span class="bp">=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero</span><span class="o">),</span> <span class="c1">-- and here makes it work</span>
  <span class="n">trace_unify</span> <span class="n">t1</span> <span class="n">t2</span>
</pre></div>

<a name="173658916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unify%20fails%20in%20the%20presence%20of%20binders/near/173658916" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90404unifyfailsinthepresenceofbinders.html#173658916">Cyril Cohen (Aug 20 2019 at 13:45)</a>:</h4>
<p>(and in my real example it is not a λ but a Π)</p>


{% endraw %}

{% include archive_update.html %}