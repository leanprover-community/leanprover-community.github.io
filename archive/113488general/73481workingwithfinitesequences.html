---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/73481workingwithfinitesequences.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html">working with finite sequences</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="123486171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123486171" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123486171">Kevin Buzzard (Mar 09 2018 at 10:39)</a>:</h4>
<p>Kenny and I will need to do some work with finite sequences to prove that affine schemes are schemes. Here is an example of the sorts of issues we are running into.</p>
<p>We have a definition <code>generate (S : set alpha)</code> -- for generating submodules of rings, but the same sort of question would arise for generating subgroups of groups or subspaces of vector spaces. Kenny has defined <code>generate S</code> to be <code>{ x | ∀ (T : set α) [is_submodule T], S ⊆ T → x ∈ T }</code> which is fine mathematically but now we need the "concrete" definition of the module generated by S, that is, the x such that there exists some finite sequence <code>s1,s2,..,sn</code> of elements of S and some finite sequence <code>r1,r2,...,rn</code> of the underlying ring alpha such that <code>x=r1*s1+r2*s2+...+rn*sn</code>. I can think of lots of ways to implement this but I have no feeling as to which one is "right" in this situation. I definitely want to allow repeats amongst the r's, and they are ordered. Should we go with asserting the existence of two lists of size n, or a map from <code>fin n</code> to S, or a map from <code>range n</code> to S, or some other approach? I am pretty sure that any of these suggestions would work but I don't know which one is most idiomatic (is that the right word?) for Lean. We are going to want to do the sorts of things that mathematicians would do with these lists -- form the sum of <code>ri*si</code> over i, choose an element from the list with some property, concatenate two lists, prove that the sum up to n+1 is the sum up to n plus the last term, blah blah blah. Obviously we'll also want to prove that the two definitions of generate are equivalent.</p>
<p>If the answer is "tell us more specifically exactly what you want to do with these lists" then I could try to do that. Could it be the case that it doesn't really matter what we choose, and all methods should work fine?</p>

<a name="123486400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123486400" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123486400">Johannes Hölzl (Mar 09 2018 at 10:47)</a>:</h4>
<p>so <code>generate</code> is <code>span</code> in <code>algebra.linear_algebra</code>?</p>

<a name="123486446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123486446" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123486446">Kevin Buzzard (Mar 09 2018 at 10:48)</a>:</h4>
<p>Probably. We're using it for generating ideals of a ring here.</p>

<a name="123486453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123486453" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123486453">Johannes Hölzl (Mar 09 2018 at 10:49)</a>:</h4>
<p>If you use <code>span</code> you already got a representation as <code>finsupp</code>, i.e. a map from the base ring into the module with finite support.</p>

<a name="123486454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123486454" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123486454">Kevin Buzzard (Mar 09 2018 at 10:49)</a>:</h4>
<p>One of Leo's comments on some recent PR is "I think this is an anti-idiom." I am just trying to avoid being anti-idiomatic :-)</p>

<a name="123486510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123486510" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123486510">Johannes Hölzl (Mar 09 2018 at 10:50)</a>:</h4>
<p>The nice thing of <code>finsupp</code> is that you can ignore the order, I usually do all the operations on it using the <code>finsupp.sum</code> operator.<br>
I guess you do not really need a order on the elements?</p>

<a name="123486517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123486517" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123486517">Kevin Buzzard (Mar 09 2018 at 10:51)</a>:</h4>
<p>No but we need a way to biject the r_i and the s_i</p>

<a name="123486523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123486523" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123486523">Kevin Buzzard (Mar 09 2018 at 10:51)</a>:</h4>
<p>so we could have a map from an unordered finite type to R and a map from the same type to S, for example</p>

<a name="123486568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123486568" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123486568">Kevin Buzzard (Mar 09 2018 at 10:52)</a>:</h4>
<p>On the other hand we might well sometimes want to prove things by induction on n, the size of the sequence</p>

<a name="123486689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123486689" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123486689">Johannes Hölzl (Mar 09 2018 at 10:57)</a>:</h4>
<p>I think you don't need the index type at all! You can do induction directly on finsupp itself, (or on its support).<br>
By avoiding this arbitrary index type you avoid a lot of data to carry around. It is common in mathematics to write down <code>x_1 ... x_n</code> and then go on to prove something by induction on <code>n</code>.  But in many cases this is unnecessary, and much easier (and maybe more idiomatic) to do it in an unordered fashion. In you case you directly take a function <code>R -&gt;_0 S</code> (the <code>_0</code> indicates that it is a finsupp function), I would assume this encodes enough information for your proofs.</p>

<a name="123486962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123486962" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123486962">Kevin Buzzard (Mar 09 2018 at 11:07)</a>:</h4>
<p>In the finsupp approach I seem to need a random index type X, so that if I have a ring R and a subset S then I can write down maps X-&gt;R and X-&gt;S with finite support. So I might not need n and fin n but surely I still need an index type, if this is what X is.</p>

<a name="123487064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123487064" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123487064">Kevin Buzzard (Mar 09 2018 at 11:11)</a>:</h4>
<p>If the suggestion is that the span is the elements a in R such that there exists some type X and finsupp maps f : X -&gt; R and g : X -&gt; S such that  a = sum f x * g x, then to add two such maps together I would need that if f1 : X -&gt; R and f2 : Y -&gt; R are finsupp maps then f1+f2 : X disjoint_union Y -&gt; R is a finsupp. Presumably lemmas such as this are already there?</p>

<a name="123487147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123487147" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123487147">Johannes Hölzl (Mar 09 2018 at 11:14)</a>:</h4>
<p>There is no need for an arbitrary index type. The idea is that you represent a span as <code>R -&gt;_0 S</code>, there are no further index types. An element <code>x \in span S</code>is represented as: <code>\exists f : R -&gt;_0 S, x = \sum_{(r, s) \in f} r * s</code></p>

<a name="123487159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123487159" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123487159">Johannes Hölzl (Mar 09 2018 at 11:15)</a>:</h4>
<p><code>\sum_{(r, s) \in f}</code> is actually written <code>f.sum (\lam r s, ...)</code> in lean.</p>

<a name="123487161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123487161" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123487161">Johannes Hölzl (Mar 09 2018 at 11:15)</a>:</h4>
<p>So there is a special summation operator over the elements in <code>f</code>.</p>

<a name="123487777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123487777" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123487777">Kevin Buzzard (Mar 09 2018 at 11:38)</a>:</h4>
<p>Aah I see! But this looks problematic because I don't see how to add the elements corresponding to two such maps. I would need maps S -&gt;_0 R instead. Can you envisage this causing any problems?</p>

<a name="123487831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123487831" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123487831">Kevin Buzzard (Mar 09 2018 at 11:40)</a>:</h4>
<p>I would also need lemmas of the form "if s is in S and if I define f :  S -&gt;_0 R by f(t)=ite (t=s) 1 0 then f.sum ... = s". Are these already there?</p>

<a name="123487842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123487842" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123487842">Kevin Buzzard (Mar 09 2018 at 11:41)</a>:</h4>
<p>and things of the form "if f : S -&gt;_0 R has image size n+1 then I can write it as g+h with g of image size n and h of image size 1".</p>

<a name="123487843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123487843" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123487843">Kevin Buzzard (Mar 09 2018 at 11:41)</a>:</h4>
<p>What I am hoping for is being able to avoid writing all the infrastructure myself ;-)</p>

<a name="123488231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123488231" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123488231">Johannes Hölzl (Mar 09 2018 at 11:55)</a>:</h4>
<p>I'm sorry, of course it would be <code>S -&gt;_0 R</code>!</p>

<a name="123488337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123488337" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123488337">Johannes Hölzl (Mar 09 2018 at 11:58)</a>:</h4>
<p><code>f(t) = ite (t=s) 1 0</code> is available for finsupp, it's called <code>single s r</code>, which maps <code>s -&gt; r</code> and nothing else.</p>

<a name="123488399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123488399" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123488399">Johannes Hölzl (Mar 09 2018 at 12:00)</a>:</h4>
<p>We can easily proof a special case statement saying essentially: <code>f = 0 \/ \exists f' r s, r /= 0 /\ s \notin f' /\ f = f' + single s r</code></p>

<a name="123491030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123491030" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123491030">Kevin Buzzard (Mar 09 2018 at 13:34)</a>:</h4>
<p>Thanks as ever for your comment Johannes. Although I don't really understand why finsupps are better than any of the approaches I outlined, I certainly trust your judgement and will use this approach.</p>

<a name="123493235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123493235" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123493235">Johannes Hölzl (Mar 09 2018 at 14:45)</a>:</h4>
<p>What brings finsupp: it doesn't  duplicate elements, it avoids any order on your elements, and there is only one data/variables etc to handle .</p>
<ul>
<li>Duplication might be very annoying in induction proofs, where you walk over your elements and then be sure that they do not appear at a later point. This might require removing them from the later list, and hence requiring a strong induction principle.</li>
<li>The order is annoying when you create a linear combination. Depending on how you create them it might be a problem. </li>
</ul>
<p>Does this give a better idea why finsupp is better than lists of pairs, multisets of pairs or two functions indexed by a finite type?</p>

<a name="123496322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123496322" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123496322">Kevin Buzzard (Mar 09 2018 at 16:12)</a>:</h4>
<p>Thank you for these explanations. I can see that finsupp is fundamentally different to all my proposals, because for all the ways I suggested (1) I need an extra type and (2) I have an implicit order, neither of which are necessary. I guess what I don't really understand is how important these differences are in practice. I guess the point is that if I don't need some structure when implementing an idea then I should try and implement the idea without introducing the structure.</p>

<a name="123506889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123506889" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123506889">Patrick Massot (Mar 09 2018 at 20:34)</a>:</h4>
<p>This S -&gt;_0 R is a nice trick but it won't work for non commutative laws</p>

<a name="123506905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123506905" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123506905">Patrick Massot (Mar 09 2018 at 20:34)</a>:</h4>
<p>So it's bad from the point of view of developing general idioms</p>

<a name="123506920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123506920" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123506920">Patrick Massot (Mar 09 2018 at 20:35)</a>:</h4>
<p>Also, what about <a href="http://www-sop.inria.fr/marelle/bigops/main.pdf" target="_blank" title="http://www-sop.inria.fr/marelle/bigops/main.pdf">www-sop.inria.fr/marelle/bigops/main.pdf</a> ? Did mathlib learn from this?</p>

<a name="123512358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123512358" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123512358">Kenny Lau (Mar 09 2018 at 22:39)</a>:</h4>
<p><span class="user-mention" data-user-email="johannes.hoelzl@gmx.de" data-user-id="110294">@Johannes Hölzl</span> how does induction work on finsupp?</p>

<a name="123512504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123512504" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123512504">Mario Carneiro (Mar 09 2018 at 22:43)</a>:</h4>
<p>The support of a finsupp is a <code>finite</code> set, so you can use <code>finite.induction</code></p>

<a name="123512728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123512728" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123512728">Kenny Lau (Mar 09 2018 at 22:48)</a>:</h4>
<p><span class="user-mention" data-user-email="di.gama@gmail.com" data-user-id="110049">@Mario Carneiro</span> so I <code>case</code> it to get <code>finite</code> before I induction it?</p>

<a name="123512731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123512731" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123512731">Kenny Lau (Mar 09 2018 at 22:48)</a>:</h4>
<p>but then how do I use the functions from <code>finsupp</code>?</p>

<a name="123512800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123512800" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123512800">Mario Carneiro (Mar 09 2018 at 22:50)</a>:</h4>
<p>Maybe a better question is: what are you trying to prove? Are you sure you need to use induction? Most facts about finsupp that are proven by induction should already be lemmas</p>

<a name="123512815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123512815" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123512815">Mario Carneiro (Mar 09 2018 at 22:50)</a>:</h4>
<p>and don't case the function, just use <code>finsupp.support</code></p>

<a name="123512955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123512955" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123512955">Kenny Lau (Mar 09 2018 at 22:55)</a>:</h4>
<p>I guess I don't need induction then</p>

<a name="123512961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123512961" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123512961">Kenny Lau (Mar 09 2018 at 22:55)</a>:</h4>
<div class="codehilite"><pre><span></span>/-- `image f s` is the forward image of `s` under `f`. -/
def image (f : α → β) (s : finset α) : finset β := (s.1.map f).to_finset
</pre></div>


<p>is there a way for the function to know that the input is in <code>s</code>?</p>

<a name="123513140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123513140" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123513140">Mario Carneiro (Mar 09 2018 at 23:00)</a>:</h4>
<p>you could precompose with <code>finset.attach</code></p>

<a name="123531200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123531200" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123531200">Johannes Hölzl (Mar 10 2018 at 10:45)</a>:</h4>
<p>we can also add a special induction rule for finsupp, which would be based on the induction on the support itself. However, it would give one a better view, i.e. look somehow like <code>finsupp.induction_on {P : (S -&gt;_0 R) -&gt; Prop} (f : S -&gt;_0 R) (h0 : P 0) (h1 : \all f s r, s \notin f -&gt; P f -&gt; P (f + single s r)) : P f</code> . Then you got a induction rule which carries on the data as expected.</p>

<a name="123531331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123531331" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123531331">Johannes Hölzl (Mar 10 2018 at 10:50)</a>:</h4>
<p>I think the idiom we want to have is: represent your data in the somehow optimal way. So if one works with commutative spaces, like modules,  finsupp carries the least necessary information. If one is working in a non commutative setting they might want to use lists, or freely generated groups, or ordered maps etc.</p>

<a name="123533781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123533781" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123533781">Johannes Hölzl (Mar 10 2018 at 12:37)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> indeed Coq has a nice and flexible big operator library. But it is very much based on canonical structures which is hard to copy in Lean itself. Also as Leans algebraic hierarchy will change in the future we will see how big operators might look like in the future.</p>

<a name="123538907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123538907" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123538907">Patrick Massot (Mar 10 2018 at 16:10)</a>:</h4>
<p>I'm confused. I was under the impression that canonical structure was Coq's name for type class inference.</p>

<a name="123544288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123544288" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123544288">Johannes Hölzl (Mar 10 2018 at 19:47)</a>:</h4>
<p>AFAIK Coq has two type class mechanisms, one is called type classes, and is similar to Lean's type class mechanism. And canonical structures, which are very different. I still don't understand canonical structures, but I think it works in a way that the unifier somehow creates a structure based on unification constraints, so from <code>?x.1 =?= A</code> and <code>?x.2 =?= B</code> it will create <code>?x =?= (A, B)</code>.</p>

<a name="123544529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123544529" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123544529">Johannes Hölzl (Mar 10 2018 at 19:57)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> and <span class="user-mention" data-user-id="110064">@Kenny Lau</span>  I worked a little bit on finsupp: it got computable, i.e. the projection of the support of a finsupp are now rfl-lemmas. But more important: I added a induction lemma <code>finsupp.induction_on</code>.</p>

<a name="123544950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123544950" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123544950">Kenny Lau (Mar 10 2018 at 20:14)</a>:</h4>
<p>thanks</p>

<a name="123546318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123546318" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123546318">Kevin Buzzard (Mar 10 2018 at 21:08)</a>:</h4>
<p>Oh many thanks Johannes. I think I might understand Lean well enough to formulate precisely the statement I want from this finsupp approach. I really want to make working with finite objects easier for mathematicians. I was there when Chris told Kenny that he had formalised Lagrange's Theorem and Kenny was visibly impressed. Mathematicians use finite objects in certain ways which are natural to them but which seem to be hard to do (at least for me) in Lean.</p>

<a name="123546377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123546377" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123546377">Kevin Buzzard (Mar 10 2018 at 21:11)</a>:</h4>
<p>Lagrange's theorem in mathematics (in the usual language of ZFC) says that if S is a finite set of size n, and if there's an equivalence relation on S such that all the equivalence classes have the same size d, then n is the product of d and the number m of equivalence classes.</p>

<a name="123546378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123546378" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123546378">Kevin Buzzard (Mar 10 2018 at 21:11)</a>:</h4>
<p>Well, it is a related statement :-)</p>

<a name="123546423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123546423" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123546423">Kevin Buzzard (Mar 10 2018 at 21:13)</a>:</h4>
<p>And this is a statement which is so obvious to a mathematician that it really doesn't need a proof, it should just be by some tactic because it is as obvious as the statement that if x y and z are real numbers then <code>x * (y + z) = x * y + x * z</code>, i.e. something which one can assume without any comment.</p>

<a name="123546424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123546424" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123546424">Kevin Buzzard (Mar 10 2018 at 21:13)</a>:</h4>
<p>But in Lean I look at that statement and my first thought is that I can see about 10 ways of formalizing it and I have no idea which ones will be easy to use.</p>

<a name="123546461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123546461" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123546461">Kevin Buzzard (Mar 10 2018 at 21:14)</a>:</h4>
<p>So in my mind this is an area which it would be really nice to work on.</p>

<a name="123546665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123546665" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123546665">Kevin Buzzard (Mar 10 2018 at 21:23)</a>:</h4>
<p>In fact let me also state the original example from commutative ring theory which got me thinking about this whole issue. Here is an example of a statement and a proof from the Stacks Project (written in ZFC). The statement is this. Say <code>R</code> is  a ring, and we have some n&gt;=2 and some elements <code>f1,f2...,fn</code> of <code>R</code> and positive integers <code>e1,e2,...,en</code> such that (a) <code>fi^ei*r=0</code> for all <code>i</code> and (b) there exists some <code>r1,r2,...,rn</code> in <code>R</code> such that the sum of <code>ri*fi</code> equals <code>1</code>. Then <code>r=0</code>.</p>

<a name="123546708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123546708" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123546708">Kevin Buzzard (Mar 10 2018 at 21:24)</a>:</h4>
<p>The proof is just by calc, and it goes:</p>

<a name="123546709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123546709" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123546709">Kevin Buzzard (Mar 10 2018 at 21:24)</a>:</h4>
<p><code>1=sum ri * fi</code></p>

<a name="123546718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123546718" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123546718">Kevin Buzzard (Mar 10 2018 at 21:25)</a>:</h4>
<p><code>=(sum ri * fi)^N</code> where <code>N</code> is something big that we might not even bother to state if we were sloppy, but maybe we would say "Oh N=the sum of the ei should probably work" if we were being careful</p>

<a name="123546719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123546719" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123546719">Kevin Buzzard (Mar 10 2018 at 21:25)</a>:</h4>
<p>and then say "so done by the multinomial theorem".</p>

<a name="123546760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123546760" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123546760">Kevin Buzzard (Mar 10 2018 at 21:26)</a>:</h4>
<p>I know I can do that in Lean but I just look at it and it looks difficult to me.</p>

<a name="123546762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123546762" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123546762">Kevin Buzzard (Mar 10 2018 at 21:26)</a>:</h4>
<p>it's not something I want to be stuck on or bothered with. I just defined sheaves on a topological space in Lean without batting an eyelid and that's a gazillion times more complicated to a mathematician</p>

<a name="123546769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123546769" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123546769">Kevin Buzzard (Mar 10 2018 at 21:27)</a>:</h4>
<p>I don't want finite sets and sequences to be hard.</p>

<a name="123546813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123546813" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123546813">Kevin Buzzard (Mar 10 2018 at 21:28)</a>:</h4>
<p>Maybe we would let the students "fill in the details as an exercise"</p>

<a name="123546917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123546917" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123546917">Kevin Buzzard (Mar 10 2018 at 21:32)</a>:</h4>
<p>but if I saw anyone write just something like "(sum ri fi)^N=sum_{t_1,t_2,...,t_n nats with sum N}(multinomial (N) (t1,t2,...,tn))r1^t1 r2^t2..rn^tn f1^t1 f2^t2 .. fn^tn and each term annihiliates r because the sum of the ti is the sum of the ei so clearly ti&gt;=ei for some i"</p>

<a name="123546928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123546928" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123546928">Kevin Buzzard (Mar 10 2018 at 21:33)</a>:</h4>
<p>A mathematician wouldn't be expected to write much more than that. But why do I look at that and think that it needs some planning in Lean? I want to just be able to write that easily, i.e. formulate it in an idiomatic way in DTT and prove it with a tactic.</p>

<a name="123546979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123546979" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123546979">Kevin Buzzard (Mar 10 2018 at 21:35)</a>:</h4>
<p>I know Chris has proved some version of the binomial theorem in Lean, it's on his github.</p>

<a name="123547019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123547019" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123547019">Kevin Buzzard (Mar 10 2018 at 21:36)</a>:</h4>
<p>But I don't know if it is the "right" version, or even whether it makes sense to ask that there is a "right" version of the binomial or multinomial theorems.</p>

<a name="123547095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123547095" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123547095">Kevin Buzzard (Mar 10 2018 at 21:39)</a>:</h4>
<p>Somehow for a mathematician there is just one multinomial theorem, which might not even have been stated in the correct generality in your undergraduate class (the theorem states what the expansion of (x1+x2+...+xn)^N is, but what are those xi? The stats lecturer needs multinomial theorem to be covered ASAP because they need it for their course, so we do it in the first term, and I want to make the assertion that the x_i are a ring, but I can't because they don't know what a ring is. So I just say that x_i are real numbers because it will keep the stats person happy.</p>

<a name="123547102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123547102" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123547102">Kevin Buzzard (Mar 10 2018 at 21:39)</a>:</h4>
<p>and then if anyone ever asks later on I just say "oh yeah of course it works for any ring, probably my proof generalizes"</p>

<a name="123547147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123547147" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123547147">Kevin Buzzard (Mar 10 2018 at 21:40)</a>:</h4>
<p>We teach maths in the wrong order :-)</p>

<a name="123547155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123547155" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123547155">Kevin Buzzard (Mar 10 2018 at 21:41)</a>:</h4>
<p>They do all this stuff in applied maths in year 1 where they're brutally re-arranging all sorts of sums and products on the basis that "one day you'll see that this was all rigorous after all, or at least most of it was, there was that bit in the Fourier Transform section that is actually a bit more complicated than you'd like"</p>

<a name="123571601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123571601" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123571601">Kevin Buzzard (Mar 11 2018 at 14:31)</a>:</h4>
<p>I'll quote some stuff from earlier in the finite sequences thread and add some more stuff.</p>

<a name="123571912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123571912" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123571912">Kevin Buzzard (Mar 11 2018 at 14:44)</a>:</h4>
<p>General Mathematical Principle 1): "If you partition a finite set up into <code>m</code> subsets of size <code>d</code> then your set has size <code>m*d</code>". The mathematician says "this is one of several equivalent definitions of multiplication, so done". In Lean we might formulate it like this: if <code>S</code> is a finite type of size <code>n</code> (i.e. there are exactly <code>n</code> distinct terms of type <code>S</code>), and if there's an equivalence relation on <code>S</code> such that all the equivalence classes have the same size <code>d</code>, then <code>n</code> is the product of <code>d</code> and the number <code>m</code> of equivalence classes. Already in Lean it seems to me that one has to make a decision about how to formalise this because there are several possibilities. Should <code>S</code> be a finset, a fintype, or a set S for which <code>finite S</code> is true? What if we are given <code>S</code> as a subtype and we don't even know it's finite, and want to prove this from the fact that we can partition it up into <code>m</code> subsets of size <code>d</code>? Would I be right in thinking that there is no one "idiomatic" way to prove a Lean version of General Mathematical Principle 1? Or might there be one general canonical way of expressing this principle in Lean such that all instances of the principle which mathematicians want to use can be deduced from this canonical formulation?</p>

<a name="123571965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123571965" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123571965">Kevin Buzzard (Mar 11 2018 at 14:47)</a>:</h4>
<p>General Mathematical Principle 2) Obvious Finite Sum facts. Sum from <code>i=a</code> to <code>i=b</code> of <code>f(i)</code> plus sum from <code>i=b+1</code> to <code>i=c</code> of <code>f(i)</code> equals sum from <code>i=a</code> to <code>i=c</code> of <code>f(i)</code>. Sum from <code>0</code> to <code>n</code> of <code>f(i)</code> equals sum from <code>0</code> to <code>n</code> of <code>f(n-i)</code>. Sum from <code>a</code> to <code>n+1</code> of <code>f(i) equals sum from </code>a<code> to </code>n<code> of </code>f(i)<code>, plus </code>f(n+1)`.</p>

<a name="123572147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123572147" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123572147">Kevin Buzzard (Mar 11 2018 at 14:55)</a>:</h4>
<p>Again all of these things would be things a mathematician would write without even commenting on why these things were true. Again in Lean I see lots of ways of implementing the statements, based on whether we decide to sum over a list, or a different kind of finite object: there is <code>finset.sum</code> but summing from 0 or 1 to <code>n</code> is a very common use case in mathematics. Should I just implement these theorems myself using list.range and fold?</p>

<a name="123572150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123572150" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123572150">Kevin Buzzard (Mar 11 2018 at 14:55)</a>:</h4>
<div class="codehilite"><pre><span></span>/-- sum_from_one_to n f sums f(i) for 1&lt;=i&lt;=n -/
definition sum_from_one_to {α : Type*} [has_add α] [has_zero α] (n : ℕ) (f : ℕ → α) : α := sorry

theorem sum_from_one_to.rec {α : Type*} [has_add α] [has_zero α]
  (n : ℕ) (f : ℕ → α) : sum_from_one_to (n+1) f = f (n+1) + sum_from_one_to n f  := sorry

/-- sum_from_zeo_to n f sums f(i) for 0&lt;=i&lt;=n -/
definition sum_from_zero_to {α : Type*} [has_add α] [has_zero α] (n : ℕ) (f : ℕ → α) : α := sorry

theorem sum_from_zero_to.rec {α : Type*} [has_add α] [has_zero α]
  (n : ℕ) (f : ℕ → α) : sum_from_zero_to (n+1) f = f (n+1) + sum_from_zero_to n f  := sorry

/-- sum_from_to a n f sums f(i) for a&lt;=i&lt;=n -/
definition sum_from_to {α : Type*} [has_add α] [has_zero α]
  (a : ℕ) (n : ℕ) (H : a ≤ n + 1) (f : ℕ → α) : α := sorry

theorem sum_from_to.rec {α : Type*} [has_add α] [has_zero α]
  (a : ℕ) (n : ℕ) (f : ℕ → α) : sum_from_to a (n+1) _ f = f (n+1) + sum_from_to a n _ f  := sorry

theorem sum_from_to_rec&#39; {α : Type*} [has_add α] [has_zero α]
  (a : ℕ) (n : ℕ) (f : ℕ → α) : sum_from_to a n _ f = f a + sum_from_to (a+1) n _ f  := sorry
</pre></div>

<a name="123572152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123572152" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123572152">Kevin Buzzard (Mar 11 2018 at 14:55)</a>:</h4>
<p>That sort of thing. Is that sufficiently close to something which is there already that I shouldn't bother? I want a mathematician-friendly interface for these things.</p>

<a name="123572192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123572192" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123572192">Kevin Buzzard (Mar 11 2018 at 14:56)</a>:</h4>
<p>Oh also, summing <code>f i j</code> over <code>i</code> and then <code>j</code> should be the same as summing over <code>j</code> and then over <code>i</code>.</p>

<a name="123572194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123572194" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123572194">Chris Hughes (Mar 11 2018 at 14:56)</a>:</h4>
<p>To prove S is finite from the partition, you could use <code>set.fintype_Union</code>. The combination of the following two lemmas, I wrote, should be enough to prove the stuff you're talking about, as I needed this stuff for Lagrange.</p>
<div class="codehilite"><pre><span></span><span class="kn">instance</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">quot</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">of_surjective</span> <span class="o">(</span><span class="n">quot</span><span class="bp">.</span><span class="n">mk</span> <span class="n">r</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">quot</span><span class="bp">.</span><span class="n">exists_rep</span> <span class="bp">_</span><span class="o">)</span>

<span class="kn">lemma</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum_const</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">β</span><span class="o">]</span>
    <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum</span> <span class="n">s</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">add_monoid</span><span class="bp">.</span><span class="n">smul</span> <span class="n">b</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">card</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">finset</span><span class="bp">.</span><span class="n">induction_on</span> <span class="n">s</span> <span class="o">(</span><span class="k">by</span> <span class="n">simp</span><span class="o">)</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">s</span> <span class="n">h</span> <span class="n">hi</span><span class="o">,</span>
<span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">finset</span><span class="bp">.</span><span class="n">sum_insert</span> <span class="n">h</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">card_insert_of_not_mem</span> <span class="n">h</span><span class="o">,</span> <span class="n">hi</span><span class="o">,</span> <span class="n">smul_succ</span><span class="o">]</span>

<span class="kn">theorem</span> <span class="n">card_quot</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">card</span> <span class="n">α</span> <span class="bp">=</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">univ</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">quot</span> <span class="n">r</span><span class="o">))</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">card</span> <span class="o">{</span><span class="n">a</span> <span class="bp">//</span> <span class="n">quot</span><span class="bp">.</span><span class="n">mk</span> <span class="n">r</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">x</span><span class="o">})</span> <span class="o">:=</span>
<span class="n">card_sigma</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">{</span><span class="n">a</span> <span class="bp">//</span> <span class="n">quot</span><span class="bp">.</span><span class="n">mk</span> <span class="n">r</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">x</span><span class="o">})</span> <span class="bp">▸</span>
<span class="n">card_congr</span> <span class="bp">⟨λ</span> <span class="n">x</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">quot</span><span class="bp">.</span><span class="n">mk</span> <span class="n">r</span> <span class="n">x</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩⟩</span><span class="o">,</span> <span class="bp">λ</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="bp">λ</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="bp">⟨_⟩⟩</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span>
</pre></div>


<p>I think the final lemma might be easier to use with <code>{a // quot.mk r a = x}</code> substituted for <code>{a // r a (quot.out x)}</code></p>

<a name="123572199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123572199" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123572199">Kevin Buzzard (Mar 11 2018 at 14:57)</a>:</h4>
<p>I suspect that I can cobble together proofs of these things. Somehow I am asking something slightly different.</p>

<a name="123572201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123572201" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123572201">Kevin Buzzard (Mar 11 2018 at 14:57)</a>:</h4>
<p>I am asking how to implement these general principles in such a way that mathematicians will be able to use them in a painless way.</p>

<a name="123572244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123572244" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123572244">Kevin Buzzard (Mar 11 2018 at 14:58)</a>:</h4>
<p>For example, let's say I ask some mathematicians to prove that the sum of the first <code>n</code> integers is <code>n(n+1)/2</code>. If I asked them to prove this in an exam they would prove it by induction. They would observe that it's trivial for n=0 and then do the few lines of algebra which gets from n to n+1 and then say done by induction.</p>

<a name="123572290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123572290" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123572290">Kevin Buzzard (Mar 11 2018 at 15:00)</a>:</h4>
<p>But in Lean they immediately need to make a call about how to formalise the statement and I can see several possibilities. And for each possibility there is a different theorem which supplies the fact that one can prove results of this kind by induction.</p>

<a name="123572347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123572347" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123572347">Chris Hughes (Mar 11 2018 at 15:02)</a>:</h4>
<p>I had to do stuff similar to that for power series. My method was</p>
<div class="codehilite"><pre><span></span><span class="n">local</span> <span class="kn">notation</span> <span class="n">f</span> <span class="bp">`</span> <span class="err">∑</span> <span class="bp">`</span> <span class="o">:</span> <span class="mi">90</span> <span class="n">n</span> <span class="o">:</span> <span class="mi">90</span>  <span class="o">:=</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">range</span> <span class="n">n</span><span class="o">)</span> <span class="n">f</span>

<span class="kn">lemma</span> <span class="n">sum_range_succ</span> <span class="o">:</span> <span class="n">f</span> <span class="err">∑</span> <span class="n">succ</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">f</span> <span class="err">∑</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="n">n</span> <span class="err">∉</span> <span class="n">finset</span><span class="bp">.</span><span class="n">range</span> <span class="n">n</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">finset</span><span class="bp">.</span><span class="n">mem_range</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">lt_irrefl</span> <span class="bp">_</span><span class="o">,</span>
<span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">finset</span><span class="bp">.</span><span class="n">range_succ</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum_insert</span> <span class="n">h</span><span class="o">]</span>
</pre></div>


<p>and then you have the induction principle. This way I still get all the lemmas about <code>finset.sum</code>, like <code>finset.sum_le_sum</code>. Similar notation could be defined for sums between integers and products.<br>
The main downside to this notation is it requires commutativity</p>

<a name="123572348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123572348" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123572348">Kevin Buzzard (Mar 11 2018 at 15:02)</a>:</h4>
<p>Similarly, one could imagine being given a big group <code>G</code>, which is not finite, and then having a subtype <code>H</code> which is not yet known to be finite, and writing down a subgroup <code>N</code> of <code>H</code> and proving that <code>N</code> is finite and that there are only finitely many left cosets for <code>N</code> in <code>H</code>. That looks like quite a natural way to me of proving that <code>H</code> is finite. It is something I would let a student assume without comment if they wrote this in an exam.</p>

<a name="123572353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123572353" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123572353">Kevin Buzzard (Mar 11 2018 at 15:03)</a>:</h4>
<p>So here you're summing from 0 to <code>n-1</code>, right?</p>

<a name="123572354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123572354" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123572354">Chris Hughes (Mar 11 2018 at 15:03)</a>:</h4>
<p>yes, slightly annoying.</p>

<a name="123572355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123572355" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123572355">Kevin Buzzard (Mar 11 2018 at 15:03)</a>:</h4>
<p>Although this is I am sure very pythonic, I think that in practice mathematicians often sum from either <code>0</code> to <code>n</code> or from <code>1</code> to <code>n</code></p>

<a name="123572402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123572402" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123572402">Kevin Buzzard (Mar 11 2018 at 15:05)</a>:</h4>
<p>So I think we need some notation for this plus a way of using it which is natural for mathematicians. Already when writing that sorried code above I noticed there was an issue with trying to figure out where the mathematician should insert the observation that <code>a&lt;=n+1</code> when summing from <code>a</code> to <code>n</code> (as otherwise this notation is not good).</p>

<a name="123572404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123572404" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123572404">Kevin Buzzard (Mar 11 2018 at 15:05)</a>:</h4>
<p>Note that this is not an issue when <code>a&lt;=1</code>.</p>

<a name="123572451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123572451" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123572451">Chris Hughes (Mar 11 2018 at 15:07)</a>:</h4>
<p>For that stuff about groups,  you could use<br>
<code>lemma group_equiv_cosets_times_subgroup (hs : is_subgroup s) : nonempty (α ≃ (cosets s × s))</code> in group_theory in mathlib, and <code>fintype.of_equiv</code> should do it quite easily.</p>

<a name="123573203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123573203" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123573203">Patrick Massot (Mar 11 2018 at 15:37)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> did you read that Coq paper I linked to?</p>

<a name="123573244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123573244" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123573244">Kevin Buzzard (Mar 11 2018 at 15:38)</a>:</h4>
<p>No, I've been really busy all week on other things. I was just trying to catch up with everything today. What Coq paper are you talking about?</p>

<a name="123573439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123573439" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123573439">Kevin Buzzard (Mar 11 2018 at 15:46)</a>:</h4>
<p>The multinomial theorem is a particularly interesting example of a "finite sum fact" because the assertion is that <code>(x1+x2+...+xn)^N</code> is a sum over the "obviously finite" set of nats <code>e1,e2,...,en</code> whose sum is <code>N</code>. Somehow a mathematician does no work at all when proving that this set is finite, it is obvious because all the <code>e_i</code> are bounded by <code>N</code>. But in Lean I would have to think about how to implement this, which is not really what I want to do. What is the "correct" formulation of the multinomial theorem in Lean? n is typically fixed and the induction is on <code>N</code> in the normal proof -- if you try induction on <code>n</code> then you will get embroiled in more complicated multinomial coefficient identities. But maybe this doesn't even matter. Even proving the "obvious" statement that if <code>e1+e2+...+en=N</code> then <code>e_i&lt;=N</code> seems like it might be some work. Is there any way of making some general theorems which mathematics students will be able to apply instinctively if they understand about nat but have no clue about fintype etc?</p>

<a name="123573440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123573440" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123573440">Patrick Massot (Mar 11 2018 at 15:46)</a>:</h4>
<p>The one from this thread: <a href="http://www-sop.inria.fr/marelle/bigops/main.pdf" target="_blank" title="http://www-sop.inria.fr/marelle/bigops/main.pdf">www-sop.inria.fr/marelle/bigops/main.pdf</a></p>

<a name="123573449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123573449" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123573449">Patrick Massot (Mar 11 2018 at 15:47)</a>:</h4>
<p>It's Coq's answer to your questions</p>

<a name="123573536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123573536" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123573536">Patrick Massot (Mar 11 2018 at 15:50)</a>:</h4>
<p>But Johannes says it may use some magic that Lean doesn't have (yet?). <span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span> what do you think about this canonical instance thing? Is it already in Lean? Will it be in Lean 4?</p>

<a name="123573792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123573792" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123573792">Andrew Ashworth (Mar 11 2018 at 16:00)</a>:</h4>
<p>i had no idea what a canonical structure was, but this paper was informative: <a href="https://hal.inria.fr/hal-00816703v1/document" target="_blank" title="https://hal.inria.fr/hal-00816703v1/document">https://hal.inria.fr/hal-00816703v1/document</a></p>

<a name="123573884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123573884" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123573884">Andrew Ashworth (Mar 11 2018 at 16:04)</a>:</h4>
<p>from my 5-minute scanning of the paper, it seems like additional functionality for the type-class inference algorithm</p>

<a name="123573886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123573886" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123573886">Sebastian Ullrich (Mar 11 2018 at 16:04)</a>:</h4>
<p>There are no plans to add canonical structures to Lean. I just read that paper as well (the conclusion at least), and it doesn't really list any advantages over type classes.</p>

<a name="123573938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123573938" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123573938">Patrick Massot (Mar 11 2018 at 16:06)</a>:</h4>
<p>Then why does <span class="user-mention" data-user-id="110294">@Johannes Hölzl</span> wrote this allows the big operators lib in Coq and it would be hard to do the same in Lean?</p>

<a name="123573945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123573945" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123573945">Patrick Massot (Mar 11 2018 at 16:07)</a>:</h4>
<p><a href="#narrow/stream/113488-general/subject/working.20with.20finite.20sequences/near/123533781" title="#narrow/stream/113488-general/subject/working.20with.20finite.20sequences/near/123533781">https://leanprover.zulipchat.com/#narrow/stream/113488-general/subject/working.20with.20finite.20sequences/near/123533781</a></p>

<a name="123573988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123573988" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123573988">Kevin Buzzard (Mar 11 2018 at 16:09)</a>:</h4>
<p>The "canonical big operators" paper that Patrick drew my attention to seems to be very relevant to some of the issues here, but it is always talking about canonical structures.</p>

<a name="123573990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123573990" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123573990">Patrick Massot (Mar 11 2018 at 16:09)</a>:</h4>
<p>Maybe we should ping <span class="user-mention" data-user-id="110172">@Assia Mahboubi</span> for more information here</p>

<a name="123578193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123578193" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123578193">Kevin Buzzard (Mar 11 2018 at 18:53)</a>:</h4>
<p>So I am reading through her "Canonical Structures for the working Coq user" paper. The first example (bottom of p3, top of p4) seems to be easily solvable with type classes. I think it would be more helpful for me to see a problem which Canonical Structures solved naturally but which the type class system does not solve so naturally.</p>

<a name="123598603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123598603" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123598603">Johannes Hölzl (Mar 12 2018 at 08:05)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> I don't know if canonical structures have an advantage over Lean's type classes. I also don't think so. The difference canonical structurs &lt;-&gt; type classes just means that we can not take the Coq approach to big operators one-to-one, but we need to see what a good approach in Lean is.</p>

<a name="123602227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123602227" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123602227">Kevin Buzzard (Mar 12 2018 at 10:12)</a>:</h4>
<p>I am actively interested in this to the point that I am even trying to read the papers. I would love to hear <span class="user-mention" data-user-id="110172">@Assia Mahboubi</span> 's thoughts on this issue. At the end of the day one of the things I am extremely interested in currently is trying to teach undergraduate mathematicians how to write undergraduate level mathematics in Lean. And the fact that Kenny Lau (who in a 2 week period wrote a bunch of Lean code to do MSc-level mathematics which localised an arbitrary ring at a multiplicative set and proved all the key lemmas which I needed for schemes), told me that he had real trouble proving Lagrange's theorem (which is a triviality to a mathematician) in Lean, makes me really think that there needs to be some progress here. How can I help? All I can see so far is that there are about three ways of formalising the underlying combinatorial statement because there are about three ways of working with the concept which the ZFC'ist knows as "a finite set". I am still not at all clear as to whether the best idea is to formalise all of them, or to formalise one of them and then to encourage the end users to use that one.</p>

<a name="123602320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123602320" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123602320">Kevin Buzzard (Mar 12 2018 at 10:15)</a>:</h4>
<p>Could it really be the case that in practice in Lean, a mathematician might find that the finite group they are interested in today is a fintype, the one they are interested in tomorrow is a finset, and the one they are interested in the day after tomorrow is a group law on <code>fin 60</code>? Does that mean that they are doing it wrong, or does that mean that we need to be able to seamlessly translate all of these into one "canonical type for working with finite groups", or does that mean that the basic infrastructure needs to be written in all cases? These are fundamental questions and I do not have a clue as to what the best approach is.</p>

<a name="123603424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123603424" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123603424">Mario Carneiro (Mar 12 2018 at 10:51)</a>:</h4>
<p>I'm actually a bit confused by your question and the purpose of your investigation. Mathlib already has a variety of mechanisms for dealing with finiteness in all its guises, and they are tested and used effectively in a variety of situations. What more do you want?</p>

<a name="123603933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123603933" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123603933">Chris Hughes (Mar 12 2018 at 11:06)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> I think the question is, there are loads of things dealing with finite sets, how do people know which one to use in which circumstance?</p>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> Finite groups always have to be a type, since <code>group</code> takes a type as an argument, and defining operations on finsets is messy. I tend to use finite sets mostly, and then coerce into a type whenever necessary, and not use finsets unless I'm doing <code>finset.sum</code> or I have to prove something 'obvious' about fintypes. I imagine finsets are better than finite sets for computability, which I don't really care about. There are things that I still don't really understand about finite sets like why for sets <code>finite s</code> and <code>fintype s</code>are both defined, given that the library doesn't usually try to avoid using choice. I always just use fintype s.</p>

<a name="123604007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123604007" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123604007">Mario Carneiro (Mar 12 2018 at 11:09)</a>:</h4>
<p>Not using choice isn't the only reason to be constructive. Computable functions are literally evaluable by the VM, and mathlib is in part a programming library (reminder: it was once called stdlib)</p>

<a name="123604056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123604056" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123604056">Mario Carneiro (Mar 12 2018 at 11:10)</a>:</h4>
<p>It's also often more convenient to work with a typeclass <code>fintype</code> rather than a predicate <code>finite</code></p>

<a name="123604059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123604059" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123604059">Mario Carneiro (Mar 12 2018 at 11:10)</a>:</h4>
<p>but they each have their uses, and after some discussion we decided to keep both</p>

<a name="123604072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123604072" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123604072">Mario Carneiro (Mar 12 2018 at 11:11)</a>:</h4>
<p>If your theorem has a natural statement with both, then why not have two theorems?</p>

<a name="123604073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123604073" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123604073">Chris Hughes (Mar 12 2018 at 11:11)</a>:</h4>
<p>I get that. What I don't understand is what is the advantage of finite over noncomputable fintype, given that neither is computable?</p>

<a name="123604112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123604112" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123604112">Mario Carneiro (Mar 12 2018 at 11:12)</a>:</h4>
<p><code>finite</code> is a Prop, so it has prop irrelevance stuff</p>

<a name="123604113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123604113" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123604113">Mario Carneiro (Mar 12 2018 at 11:12)</a>:</h4>
<p>and it can be shoved into a <code>set</code>, etc</p>

<a name="123604123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123604123" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123604123">Mario Carneiro (Mar 12 2018 at 11:13)</a>:</h4>
<p>Most of the time using the wrong notion will simply be a type error, and that's your hint at the different uses of each</p>

<a name="123604126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123604126" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123604126">Mario Carneiro (Mar 12 2018 at 11:13)</a>:</h4>
<p>i.e. there is no <code>finite.sum</code> but there is <code>finset.sum</code></p>

<a name="123604180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123604180" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123604180">Chris Hughes (Mar 12 2018 at 11:15)</a>:</h4>
<p>That makes sense. I think the answer to <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> 's question is that you just have to learn the differences between all the different forms of finite sets.</p>

<a name="123604190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123604190" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123604190">Chris Hughes (Mar 12 2018 at 11:15)</a>:</h4>
<p>You can't really get away with trying to only use one of them</p>

<a name="123604231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123604231" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123604231">Mario Carneiro (Mar 12 2018 at 11:16)</a>:</h4>
<p>right, they aren't <em>alternatives</em>, they are in complementary distribution</p>

<a name="123610882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123610882" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123610882">Kevin Buzzard (Mar 12 2018 at 14:35)</a>:</h4>
<p>My question is this. Let's say I am about to write some teaching material to show 1st year undergraduate mathematicians how to formally verify the proof of Lagrange's theorem that they have seen in their undergraduate mathematics lectures. My goal is to make the Lean version of this proof look like the maths version, presented in a natural if somewhat pedantic way. If a student works through this material (which does not yet exist but I hope it will exist in the very near future) then at some point they will need to assert that some group or set is finite of size n. When they do this, I will have to teach them something about how Lean handles finite objects. Is there a natural "idiomatic" choice of how to model this situation in Lean, or should I simply write the teaching material for, say, finsets and fintypes? What I am trying to establish is whether somehow there is one "idiomatic" way to prove that if X is a finite object which has been broken up into m disjoint subobjects each of which have size d, then the size of X is m*d. What I am trying to stress is that in maths (i.e. in ZFC) this is _one theorem_. In Lean is it several theorems, and I should be expected to use whatever DTT-translation of this one ZFC theorem is appropriate given the way I have formalised the situation, or is there one DTT theorem that I should prove and then I should deduce the other variants from this theorem? If someone comes up in the future with a completely different DTT way of modelling finite sets, should I be expecting to port the proof of this one ZFC theorem to this new set-up? Is that how it works?</p>

<a name="123611726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123611726" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123611726">Kevin Buzzard (Mar 12 2018 at 14:57)</a>:</h4>
<p>Similarly, there is only one multinomial theorem in ZFC. It says that if n is a nat and x1,x2,..,xn are n elements of a ring (or even a semiring) and if N is a nat, then (x1+x2+...+xn)^N is a sum, over the finite set of n-tuples (e1,e2,..,en) of nats such that the sum of the ei is N, of some multinomial coefficient times x1^e1 x2^e2 ... xn^en. If I were to formalise this in Lean I am going to have to make a call about what exactly I am summing over. So I have the same question. Is there some "canonical" answer to this in Lean, or should I consider all the multitude of ways that this finite set can be modelled in type theory and prove the multinomial theorem in every case, or should I consider all the multitude of ways that this finite set can be modelled in type theory, choose one of them, prove the multinomial theorem for that one, and then deduce it for the others using some low-tech stuff which I can be 100 percent sure that mathematicians won't be interested in because they don't care about applying the identity function in set theory.</p>

<a name="123611809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123611809" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123611809">Kevin Buzzard (Mar 12 2018 at 14:59)</a>:</h4>
<p>The reason I am actively interested in these questions now is that I am going to write a lot of teaching materials for mathematics undergraduates, showing them how to do undergraduate level mathematics in Lean, so I really have to engage with the issue that whilst I can now do this kind of mathematics myself in Lean, I do not know the "best" way to do it, and I do not want to teach bad ways of doing things. I hope I have made my questions sufficiently precise that someone can say something illuminating about which path to take.</p>

<a name="123611899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123611899" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123611899">Kevin Buzzard (Mar 12 2018 at 15:00)</a>:</h4>
<p>The tl;dr is basically "Formalise Lagrange's theorem in Lean, taking care to explain why you chose this way of doing it".</p>

<a name="123611907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123611907" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123611907">Kevin Buzzard (Mar 12 2018 at 15:01)</a>:</h4>
<p>and similarly for the multinomial theorem</p>

<a name="123703741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123703741" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123703741">Assia Mahboubi (Mar 14 2018 at 14:14)</a>:</h4>
<p>Hi <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> , I have been away from zulip for a while, and I missed this very interesting discussion. I hope it's not too late to contribute. But there seem to be several interleaved topics here. <br>
So I'll start with the trouble with the Lagrange trivial theorem.  From my experience, there are two issues behind the formalization of this lemma. One is finiteness, but there is also a matter of avoiding to introduce "too many types" in the story.<br>
At the end of the day, finite group theory is about studying the relative properties of subgroups, not much about the relative properties of the elements of a given group. So it should be easy to write (and not unreasonably difficult to prove) statements about groups (as opposed to statements about their elements). Therefore, it is a good idea to introduce a type for groups which can be easily combined, that is groups sharing the same law (and neutral element). And to reason about the (sub)groups of a same "domain". <br>
As far as I can see, this is not the approach taken by <span class="user-mention" data-user-id="110294">@Johannes Hölzl</span> <a href="https://github.com/leanprover/mathlib/blob/4ceb545f7e07431263e1131a9c9524a28de99472/group_theory/subgroup.lean#L88" target="_blank" title="https://github.com/leanprover/mathlib/blob/4ceb545f7e07431263e1131a9c9524a28de99472/group_theory/subgroup.lean#L88">here</a>.<br>
I was not able to find the proof by Chris that you mention, so may be you know all this very well already. Sorry for the noise in that case.<br>
If not, and  since you wrote that: </p>
<blockquote>
<p>I am actively interested in this to the point that I am even trying to read the papers. </p>
</blockquote>
<p>then I would suggest (sorry for the self recommendation) this note: <a href="https://hal.inria.fr/hal-00825074/file/main.pdf" target="_blank" title="https://hal.inria.fr/hal-00825074/file/main.pdf">https://hal.inria.fr/hal-00825074/file/main.pdf</a> . Skip the beginning and start p.4.  </p>
<p>In mathcomp, the "master" version of  Lagrange theorem is <a href="https://github.com/math-comp/math-comp/blob/3d59940ff4601713e8395f6b7e5c525501183731/mathcomp/fingroup/fingroup.v#L1959" target="_blank" title="https://github.com/math-comp/math-comp/blob/3d59940ff4601713e8395f6b7e5c525501183731/mathcomp/fingroup/fingroup.v#L1959">here</a>. I would suggest first looking to the statement rather than  to the proof scripts. This one says that for any 2 (finite) groups G, H, the cardinal of the intersection of G and H, multiplied by the number of G-right cosets for elements in H (this is the index), is the cardinal of G. It is  followed by a litany of variants and corollaries. The line where G and H are assumed to be sugroups of a same domain is <a href="https://github.com/math-comp/math-comp/blob/3d59940ff4601713e8395f6b7e5c525501183731/mathcomp/fingroup/fingroup.v#L1957" target="_blank" title="https://github.com/math-comp/math-comp/blob/3d59940ff4601713e8395f6b7e5c525501183731/mathcomp/fingroup/fingroup.v#L1957">here</a>.</p>

<a name="123704159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123704159" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123704159">Assia Mahboubi (Mar 14 2018 at 14:26)</a>:</h4>
<blockquote>
<p>Should <code>S</code> be a finset, a fintype, or a set S for which <code>finite S</code> is true? What if we are given <code>S</code> as a subtype and we don't even know it's finite, and want to prove this from the fact that we can partition it up into <code>m</code> subsets of size <code>d</code>? </p>
</blockquote>
<p>This one is easy: if this situation is really going to happen (proving finiteness from a presentation as a finite partition into finites), then <code>S</code> should be a non-necessarily finite set, and you would then add the <code>finite S</code> property to your conclusion.</p>

<a name="123704233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123704233" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123704233">Kevin Buzzard (Mar 14 2018 at 14:28)</a>:</h4>
<p>Aah yes of course, if you don't know it's finite yet then it had better not be a type which is provably finite :-) What I am still confused about is whether one should prove three theorems (one for finsets, one for fintypes and one for finite sets) all of which say "if it's a disjoint union of X things of size Y, it has X*Y" or whether one should prove one theorem for one of them and deduce the analogous theorems for the other two. The reason this is troublesome for me is that in ZFC this is one theorem and some way I am still uncomfortable about making it three theorems in DTT.</p>

<a name="123704819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123704819" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123704819">Andrew Ashworth (Mar 14 2018 at 14:43)</a>:</h4>
<p>this might be a dumb question, but shouldn't it be the case that if it holds for fintypes, it holds for finite sets and finsets?</p>

<a name="123704826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123704826" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123704826">Andrew Ashworth (Mar 14 2018 at 14:43)</a>:</h4>
<p>the constructive interpretation is stronger than the classical ones</p>

<a name="123704896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123704896" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123704896">Andrew Ashworth (Mar 14 2018 at 14:44)</a>:</h4>
<p>therefore if I knew a theorem was true and had a constructive interpretation I would prove that first and derive if for the others</p>

<a name="123704982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123704982" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123704982">Assia Mahboubi (Mar 14 2018 at 14:46)</a>:</h4>
<blockquote>
<p>There are no plans to add canonical structures to Lean. I just read that paper as well (the conclusion at least), and it doesn't really list any advantages over type classes.</p>
</blockquote>
<p>Canonical structures/instances were implemented in Coq 10 years before type classes, by Amokrane Saïbi, who coined the name. The authors of the Coq type classes mechanism were not aware of canonical structures (which should really be called canonical instances). As far as I can tell, the "type class" vocabulary has been borrowed from the Haskell programming language, where it means something related but different though. The Mathematical components library started using canonical structures well before type classes became usable in Coq.</p>
<p>I am not sure that the exact difference between the two is very relevant to this thread. But for what it's worth the main advantage (a big one for my own usage) is that the user has full control on the instance searching strategy, for each class she declares. In Coq, instance look-up can become very subtle to control and result in seemingly non-terminating type-checking.  Lean might very well be much better behaved in that respect, I have not tried enough. But it is difficult to illustrate this kind of trouble on toy examples, as one needs a non-trival hierarchy and a few instances populating it.</p>

<a name="123705329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123705329" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123705329">Assia Mahboubi (Mar 14 2018 at 14:54)</a>:</h4>
<blockquote>
<p>Then why does <span class="user-mention" data-user-id="110294">@Johannes Hölzl</span> wrote this allows the big operators lib in Coq and it would be hard to do the same in Lean?</p>
</blockquote>
<p>I do not Lean well enough to assess the feasibility of this transposition. <span class="user-mention" data-user-id="110294">@Johannes Hölzl</span> is much more knowledgeable than I am... However I do not understand his post as saying that it would be hard but as saying that it would not be a straightforward direct transposition, as the inference mechanism used is a bit different. It might not be too hard though. Also, the big operators library uses its own, independent, hierarchy of structures (flavours of monoids) . Then operations of commutative rings for examples are declared as instances of these structures so that the corresponding infrastructure material becomes available. So in principle a big operator library on this model could start as an independent development.</p>

<a name="123705348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123705348" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123705348">Andrew Ashworth (Mar 14 2018 at 14:55)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>  it reminds me of your observation that "wow, lean developers really make metric spaces a subclass of topological spaces". all metric spaces are topological spaces, but not all topological spaces are metric-able . in the same way, (my poor understanding here is that) all fintypes can be considered as a finset or finite set, but the reverse isn't true</p>
<p>I think you could define it once for fintypes and then a tactic to move a proof on fintypes to a proof on finite sets</p>

<a name="123705421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123705421" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123705421">Kevin Buzzard (Mar 14 2018 at 14:56)</a>:</h4>
<blockquote>
<p>this might be a dumb question, but shouldn't it be the case that if it holds for fintypes, it holds for finite sets and finsets?</p>
</blockquote>
<p>Well it holds for all of them so of course your assertion must be true :-) I don't know what "the constructive interpretation is stronger than the classical ones" actually means :-( because I have been classical for so long and have no feeling at all for constructive mathematics. But are you saying that I should prove it for fintypes and deduce it for the others? Johannes' proof doesn't use any finiteness at all, he just proves that G bijects with H x (G/H) in general, which is a stronger statement but I would imagine is not constructive (in fact I pretty much know for sure that it is not, if you had a given bijection then I imagine you would be able to choose an element in each coset, which surely requires the axiom of choice).</p>

<a name="123705611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123705611" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123705611">Andrew Ashworth (Mar 14 2018 at 15:00)</a>:</h4>
<p>all I mean by stronger is that for all Propositions, if it holds for fintype, it must hold for a finite set</p>

<a name="123705682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123705682" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123705682">Kevin Buzzard (Mar 14 2018 at 15:02)</a>:</h4>
<p>A mathematician wouldn't say "all metric spaces are topological spaces", they would say that there is a canonical construction that starts with a metric space and produces a completely different object, namely a topological space. It's easy to give examples of different metric spaces which give rise to the same topological space (e.g. take a metric space and then just double the metric, i.e. decree that every point is now twice as far from every other point as it used to be, like changing from miles to kilometres). My surprise was the fact that this construction had been embedded not as a functor from metric spaces to topological spaces, but as part of the definition of a metric space, when manifestly it is just extra junk which follows automatically from the definition of the functor and the axioms of a metric space. As a mathematician I am concerned about this, because in my normal working life I am interested in structures which are a bazillion times more complicated than topological spaces, and if we want every functor to be a forgetful functor then in Lean it sounds a priori that these objects will be terrifying. However since I have learnt about how Lean can be told to fill in structure fields automatically I am less concerned about this (although it still sounds like a very anti-computer-science thing to do: if I just defined you a metric space then why are you now going through the motions to define a topology on it when I might never be using it?)</p>

<a name="123705779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123705779" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123705779">Andrew Ashworth (Mar 14 2018 at 15:05)</a>:</h4>
<p>this is because of how type-class inference works as a prolog-like search :)</p>

<a name="123705791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123705791" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123705791">Andrew Ashworth (Mar 14 2018 at 15:05)</a>:</h4>
<p>if you imagine a hierarchy of types, it starts at the top and goes down</p>

<a name="123705799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123705799" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123705799">Kevin Buzzard (Mar 14 2018 at 15:05)</a>:</h4>
<blockquote>
<p>all I mean by stronger is that for all Propositions, if it holds for fintype, it must hold for a finite set</p>
</blockquote>
<p>It might not be quite as easy -- e.g. if one proves that a subtype of a product of finitely many fintypes is a fintype, then it will be true that a subset of a product of finitely many finite sets is a finite set, but one can't just prove it by saying "every finite set is a fintype", one has to also prove that the functor from finite sets to fintypes commutes with a bunch of structures and furthermore that constructions on one side have some mirror on the other side.</p>

<a name="123705885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123705885" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123705885">Andrew Ashworth (Mar 14 2018 at 15:07)</a>:</h4>
<p>it may not be trivial, but it can be automated</p>

<a name="123705932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123705932" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123705932">Andrew Ashworth (Mar 14 2018 at 15:08)</a>:</h4>
<p>that's the whole point of the relator construction used in defining lean's integers (I think, somebody better at Lean than me  correct me if I'm wrong).</p>

<a name="123705939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123705939" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123705939">Kevin Buzzard (Mar 14 2018 at 15:08)</a>:</h4>
<p>And if my understanding is correct then if you want to do all this with the type class inference system then you are going to need to carry the fintype around as part of the structure of the finite set, and that might mean re-defining the finite set structure</p>

<a name="123706109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123706109" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123706109">Kevin Buzzard (Mar 14 2018 at 15:12)</a>:</h4>
<p>My gut feeling is that you will need theorems such as "there's a bijection between the subsets of a finite set and the subtypes of a finite type, and the bijection preserves cardinality" -- that sort of thing. I am definitely not an expert in these matters and maybe it's all much easier than I am suggesting, but I hope I am getting my point across: currently I feel like every theorem about finite sets in ZFC seems to be translating into three theorems in DTT and I am still sort-of confused about which one I should be proving, or whether I should be proving all of them.</p>

<a name="123706183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123706183" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123706183">Andrew Ashworth (Mar 14 2018 at 15:14)</a>:</h4>
<p>yes, exactly, you prove the bijection exists and a few other properties (i've never used relator) and then get a tactic out that moves proofs on fintype to finset</p>

<a name="123706198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123706198" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123706198">Andrew Ashworth (Mar 14 2018 at 15:15)</a>:</h4>
<p>then, going forward, you write one proof for fintype and automatically get the other two</p>

<a name="123706211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123706211" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123706211">Kevin Buzzard (Mar 14 2018 at 15:15)</a>:</h4>
<p>To go back to the other example, the multinomial theorem is a theorem that says (x1+x2+...+xn)^N = big finite sum of terms. In ZFC you just sum over the finite set {e1,e2,...,en} with ei all nats and their sum has to be N. If I formalise the multinomial theorem using a sum over a fintype, is it conceivable that someone in the future will want it but with a sum over a finite set instead? And if this happens, is it because they wrote bad code, or are they expected to deduce the formulation they want from the one I give them, or am I expected to prove three or four versions of the multinomial theorem? Here I could be summing over a finset, a fintype, a finite set or even a carefully-chosen finsupp type thing I suspect.</p>

<a name="123706510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123706510" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123706510">Andrew Ashworth (Mar 14 2018 at 15:22)</a>:</h4>
<p>you could imagine defining a type class <code>has_sum</code> and providing instances for all of the above, that would make it easy to use, but not easy to write</p>

<a name="123706590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123706590" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123706590">Andrew Ashworth (Mar 14 2018 at 15:25)</a>:</h4>
<p>but this is really getting above my paygrade, i feel like johannes or mario would have a more informed opinion</p>

<a name="123706648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123706648" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123706648">Kevin Buzzard (Mar 14 2018 at 15:26)</a>:</h4>
<p>I should make clear my intentions here -- what I really really want to be able to do is to make things look easy for undergraduate mathematicians, who are used to the ZFC way. They only see one Lagrange theorem, and it's a theorem about finite groups, which are finite sets with some extra structure. They only see one multinomial theorem. When they sum from 1 to n (and they do, we often start at 1) they really do not care if [1...n] is a finset, fintype, list or whatever. They're just summing from 1 to n. I want to make Lean look like this to them because now I understand that this is possible -- I can tell them to type "import xena" on line 1 and then just do what I say to do all this sort of stuff. What I am unsure about is the best way of implementing it.</p>

<a name="123706670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123706670" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123706670">Kevin Buzzard (Mar 14 2018 at 15:27)</a>:</h4>
<p>That is why I am asking all these weird questions. I want to write infrastructure which they will never see, cover it up with functions which I will point them to, and then hopefully deal with all their issues relatively easily.</p>

<a name="123706688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123706688" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123706688">Kevin Buzzard (Mar 14 2018 at 15:27)</a>:</h4>
<p>And I just don't know if this is easy or unfeasible.</p>

<a name="123706753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123706753" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123706753">Kevin Buzzard (Mar 14 2018 at 15:29)</a>:</h4>
<p>But I want to get on and write it.</p>

<a name="123706763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123706763" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123706763">Kevin Buzzard (Mar 14 2018 at 15:29)</a>:</h4>
<p>Because it is in everyone's interests that mathematicians begin to think of these proof verification tools as normal, and easy to use.</p>

<a name="123706807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123706807" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123706807">Kevin Buzzard (Mar 14 2018 at 15:30)</a>:</h4>
<p>And currently (for mathematicians) they are neither.</p>

<a name="123706844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123706844" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123706844">Andrew Ashworth (Mar 14 2018 at 15:31)</a>:</h4>
<p>no need to edit that last sentence, it's true for cs as well</p>

<a name="123723502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123723502" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123723502">Mario Carneiro (Mar 14 2018 at 21:54)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> I'm not sure you understood my point before, but let me say it this way: <code>finset</code> and <code>finite</code> are not interchangeable in any sense. They apply to completely different things - <code>finset A</code> is the collection of finite subsets of <code>A</code>, while <code>finite s</code> is a proof that <code>s</code> is a finite set. There are some obvious relations between these two, and they are all true, but "S is finite" and "the fin-powerset of A" just aren't the same concept and they need two different names.</p>

<a name="123723576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123723576" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123723576">Mario Carneiro (Mar 14 2018 at 21:56)</a>:</h4>
<p>On the other hand, <code>fintype</code> is almost interchangeable with <code>finite</code>, in the sense that it is discussing roughly the same concept. Again there are applicability differences: <code>fintype A</code> takes a type, while <code>finite s</code> takes a set, and moreover the definition of <code>finite s = nonempty (fintype s)</code> should give you a strong hint at which is more generally applicable.</p>

<a name="123725943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123725943" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123725943">Kevin Buzzard (Mar 14 2018 at 22:57)</a>:</h4>
<p>OK so <code>fintype &gt;&gt; finite</code> and now it's just between <code>fintype</code> and <code>finset</code>. Now the problem I envisage is that if someone puts a group structure on something of type <code>fintype</code> and then proves Lagrange's Theorem for it, can someone else now come along with  a group structure on something of type <code>finset</code> and not be able to use it?</p>

<a name="123725986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123725986" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123725986">Chris Hughes (Mar 14 2018 at 22:58)</a>:</h4>
<p>You can't define a group structure on something of type finset.</p>

<a name="123725987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123725987" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123725987">Kevin Buzzard (Mar 14 2018 at 22:58)</a>:</h4>
<p>Oh!</p>

<a name="123726007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123726007" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123726007">Kevin Buzzard (Mar 14 2018 at 22:59)</a>:</h4>
<p>Can I get to "the underlying set"?</p>

<a name="123726069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123726069" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123726069">Chris Hughes (Mar 14 2018 at 23:00)</a>:</h4>
<p>{x | x in s}</p>

<a name="123726071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123726071" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123726071">Kevin Buzzard (Mar 14 2018 at 23:00)</a>:</h4>
<p>Oh meh the "underlying set" is an equivalence class of lists</p>

<a name="123726086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123726086" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123726086">Chris Hughes (Mar 14 2018 at 23:00)</a>:</h4>
<p>There's a function in mathlib somewhere that does that, finset.to_set or something</p>

<a name="123726114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123726114" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123726114">Kevin Buzzard (Mar 14 2018 at 23:01)</a>:</h4>
<p>your notation seems to work fine</p>

<a name="123726157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123726157" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123726157">Kevin Buzzard (Mar 14 2018 at 23:02)</a>:</h4>
<p>it makes a set</p>

<a name="123726169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123726169" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123726169">Kevin Buzzard (Mar 14 2018 at 23:02)</a>:</h4>
<p><code>def T := {x // x ∈ v}</code> also works</p>

<a name="123726174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123726174" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123726174">Chris Hughes (Mar 14 2018 at 23:02)</a>:</h4>
<p>\u s might even work</p>

<a name="123726183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123726183" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123726183">Kevin Buzzard (Mar 14 2018 at 23:03)</a>:</h4>
<p>I stay away from \u</p>

<a name="123726189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123726189" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123726189">Chris Hughes (Mar 14 2018 at 23:03)</a>:</h4>
<p>why?</p>

<a name="123726192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123726192" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123726192">Mario Carneiro (Mar 14 2018 at 23:03)</a>:</h4>
<p>A "finite group" is a group whose elements are enumerated by a finset. That is <code>fintype</code>. There is no other reasonable interpretation here</p>

<a name="123726193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123726193" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123726193">Kevin Buzzard (Mar 14 2018 at 23:03)</a>:</h4>
<p>I have always forgotten what it means 5 minutes after I use it</p>

<a name="123726248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123726248" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123726248">Kevin Buzzard (Mar 14 2018 at 23:04)</a>:</h4>
<p>So the Lean word for "finite set" really is <code>fintype</code>? This is the type which I need to focus on when working with finite objects?</p>

<a name="123726249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123726249" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123726249">Mario Carneiro (Mar 14 2018 at 23:04)</a>:</h4>
<p>a particular finset is not a type, so it can't have a group structure</p>

<a name="123726261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123726261" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123726261">Chris Hughes (Mar 14 2018 at 23:04)</a>:</h4>
<p>Probably lots of useful stuff to put in docs. instances are on types, and function are generally on types.</p>

<a name="123726263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123726263" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123726263">Kevin Buzzard (Mar 14 2018 at 23:04)</a>:</h4>
<p>I see. A finset is just a term, which has a type but which isn't a type</p>

<a name="123726283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123726283" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123726283">Mario Carneiro (Mar 14 2018 at 23:05)</a>:</h4>
<p>If you have a finset <code>s</code>, then the type <code>{x // x \in s}</code> is a fintype, because it is enumerated by <code>s</code></p>

<a name="123726339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123726339" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123726339">Mario Carneiro (Mar 14 2018 at 23:07)</a>:</h4>
<p>One warning I should give is that <code>fintype</code> is in the "constructive fragment", which is to say that a construction of a <code>fintype</code> from other <code>fintype</code>s should be computable if possible</p>

<a name="123726394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123726394" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123726394">Kevin Buzzard (Mar 14 2018 at 23:08)</a>:</h4>
<p>Some of my misunderstanding in this thread is because I have never worked with any of these finite objects before, so was asking questions which I could imagine could be well-formulated but in retrospect might not make any sense.</p>

<a name="123726460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123726460" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123726460">Kevin Buzzard (Mar 14 2018 at 23:10)</a>:</h4>
<p>So I can't put a group structure "on a list", as it were. You see I am befuddled by all this set theory. <em>everything is a set</em> in set theory so you can attempt to put any structure on anything, in some sense.</p>

<a name="123726461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123726461" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123726461">Mario Carneiro (Mar 14 2018 at 23:10)</a>:</h4>
<p>I think that once you work with these for a bit, you will notice the "complementary distribution" stuff I said: it's not actually a problem which to use in most cases, since they aren't interchangeable, so use the one that makes sense and it will probably be the right one</p>

<a name="123726462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123726462" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123726462">Kevin Buzzard (Mar 14 2018 at 23:10)</a>:</h4>
<p>Not every term is a type.</p>

<a name="123726473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123726473" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123726473">Kevin Buzzard (Mar 14 2018 at 23:11)</a>:</h4>
<p><code>use the one that makes sense and it will probably be the right one</code> oh but I don't want to go back there.</p>

<a name="123726476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123726476" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123726476">Kevin Buzzard (Mar 14 2018 at 23:11)</a>:</h4>
<p>That's exactly what starts getting me worried.</p>

<a name="123726530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123726530" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123726530">Kevin Buzzard (Mar 14 2018 at 23:12)</a>:</h4>
<p>because it then sounds like someone else might be in some other situation where another choice is the right one for them, and then we will need two theorems that say the same thing, one for each choice. At least I can envisage that this might be the case. Does this simply not happen in practice?</p>

<a name="123726538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123726538" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123726538">Mario Carneiro (Mar 14 2018 at 23:12)</a>:</h4>
<p>My point is that there is no choice, only one of them will make sense in a given situation</p>

<a name="123726606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123726606" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123726606">Kevin Buzzard (Mar 14 2018 at 23:15)</a>:</h4>
<p>As I say, I think that to a certain extent it is my inexperience with type theory, and my attempt to push naive ideas over from set theory in an incorrect way, which have led me to this confusion. I am having to learn a new foundation for a subject which I know very well and for which I have have thought hard about foundational issues over the last few decades. Now I have to completely rewire myself. This is why I am so keen to teach students, because at the end of the day I don't think it matters what your foundation is.</p>

<a name="123726612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123726612" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123726612">Kevin Buzzard (Mar 14 2018 at 23:15)</a>:</h4>
<p>but their minds haven't been polluted with ZFC yet.</p>

<a name="123726628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123726628" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123726628">Mario Carneiro (Mar 14 2018 at 23:16)</a>:</h4>
<p>I think these issues come up in set theory too, which has enough soft typing to make sense of these ideas, if not formally</p>

<a name="123726675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123726675" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123726675">Mario Carneiro (Mar 14 2018 at 23:16)</a>:</h4>
<p>If you have a list (x1, x2, x3), it's "elements" are some nonsense kuratowski stuff, that's not what you meant</p>

<a name="123726805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123726805" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123726805">Kevin Buzzard (Mar 14 2018 at 23:20)</a>:</h4>
<p>No sure, it's the same with group theory, maybe a group is a 3-tuple or something, but we know what we mean by "elements" in any given case.</p>

<a name="123726820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123726820" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123726820">Kevin Buzzard (Mar 14 2018 at 23:21)</a>:</h4>
<p>The point is that we can almost always coerce some elements out of the set, whereas in type theory it is just dawning on me that sometimes there is no "underlying type".</p>

<a name="123726864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123726864" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123726864">Kevin Buzzard (Mar 14 2018 at 23:22)</a>:</h4>
<p>In set theory, even 4 is a set, so I could put a group law on it.</p>

<a name="123726865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123726865" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123726865">Kevin Buzzard (Mar 14 2018 at 23:22)</a>:</h4>
<p>It's only just dawning on me that this doesn't even make sense in type theory.</p>

<a name="123726887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123726887" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123726887">Kevin Buzzard (Mar 14 2018 at 23:23)</a>:</h4>
<p>Contrast my behaviour with Chris, who knows no set theory -- I am a professor and he is an undergraduate who has seen no set theory, and in some sense he has the advantage here because he realises what a nonsense idea it is to start putting a group structure on the number 4</p>

<a name="123726893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123726893" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123726893">Kevin Buzzard (Mar 14 2018 at 23:23)</a>:</h4>
<p>whereas it's just something I've always known can be done but was junk.</p>

<a name="123726957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123726957" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123726957">Kevin Buzzard (Mar 14 2018 at 23:25)</a>:</h4>
<p>But year after year after year in mathematics departments we are going to be teaching them either set theory, or no foundations at all. Any move to change this in the past would have been met with "but set theory is _fine_! It's worked for 100 years and who cares about the junk theorems".</p>

<a name="123727008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123727008" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123727008">Kevin Buzzard (Mar 14 2018 at 23:26)</a>:</h4>
<p>I wonder if they teach type theory courses in the computer science department? Is that likely?</p>

<a name="123727016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123727016" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123727016">Kevin Buzzard (Mar 14 2018 at 23:26)</a>:</h4>
<p>I know they teach Haskell in term 1 year 1</p>

<a name="123727033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123727033" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123727033">Kevin Buzzard (Mar 14 2018 at 23:27)</a>:</h4>
<p>but I wonder if they take it any further.</p>

<a name="123727119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123727119" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123727119">Kevin Buzzard (Mar 14 2018 at 23:29)</a>:</h4>
<p><code>https://psvg.doc.ic.ac.uk/2018/03/14/formal-methods-meets-js.html</code></p>

<a name="123727120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123727120" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123727120">Kevin Buzzard (Mar 14 2018 at 23:29)</a>:</h4>
<p><a href="https://psvg.doc.ic.ac.uk/2018/03/14/formal-methods-meets-js.html" target="_blank" title="https://psvg.doc.ic.ac.uk/2018/03/14/formal-methods-meets-js.html">https://psvg.doc.ic.ac.uk/2018/03/14/formal-methods-meets-js.html</a></p>

<a name="123727121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123727121" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123727121">Kevin Buzzard (Mar 14 2018 at 23:29)</a>:</h4>
<p>happening about 50 metres from my office on Monday.</p>

<a name="123727178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123727178" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123727178">Kevin Buzzard (Mar 14 2018 at 23:30)</a>:</h4>
<p>Do I care about javascript program verification?</p>

<a name="123727257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123727257" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123727257">Kevin Buzzard (Mar 14 2018 at 23:32)</a>:</h4>
<p><a href="https://psvg.doc.ic.ac.uk/teaching/separationlogic.html" target="_blank" title="https://psvg.doc.ic.ac.uk/teaching/separationlogic.html">https://psvg.doc.ic.ac.uk/teaching/separationlogic.html</a></p>

<a name="123727260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123727260" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123727260">Kevin Buzzard (Mar 14 2018 at 23:32)</a>:</h4>
<p>any use for Lean?</p>

<a name="123727264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123727264" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123727264">Kevin Buzzard (Mar 14 2018 at 23:32)</a>:</h4>
<p>I even know some of these people</p>

<a name="123728543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123728543" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123728543">Simon Hudon (Mar 15 2018 at 00:14)</a>:</h4>
<p>That looks pretty useful. I started a separation logic package, in parts so that I can learn from it and in parts because it's useful</p>

<a name="123736197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123736197" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123736197">Mario Carneiro (Mar 15 2018 at 05:01)</a>:</h4>
<blockquote>
<p>In set theory, even 4 is a set, so I could put a group law on it.</p>
</blockquote>
<p>The only difference between set theory and type theory here is that in type theory these are <em>formally</em> disallowed where in set theory they are just stupid things no one would ever bother to do. (In this case, 4 actually has a reasonable set theoretic interpretation, as the ordinal 4 = {0, 1, 2, 3}, and I can see at least one natural group on this set, but usually this isn't the case, you get some modeling specific thing that is "brittle" in the same sense as I've discussed with brittle proofs. It breaks an abstraction barrier.)</p>

<a name="123736291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/123736291" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#123736291">Mario Carneiro (Mar 15 2018 at 05:05)</a>:</h4>
<p>The point I'm trying to make is that type theory should not be a major change from the mathematician's status quo. It is only disallowing things that we were all trying to avoid in the first place (i.e. junk theorems), so unless you were abusing the abstractions you shouldn't even notice the difference. (And if you were, well there are some coercions you will need to insert, like <code>4</code> -&gt; <code>fin 4</code>.)</p>

<a name="124550511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/124550511" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#124550511">Kenny Lau (Apr 02 2018 at 23:19)</a>:</h4>
<blockquote>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> and <span class="user-mention" data-user-id="110064">@Kenny Lau</span>  I worked a little bit on finsupp: it got computable, i.e. the projection of the support of a finsupp are now rfl-lemmas. But more important: I added a induction lemma <code>finsupp.induction_on</code>.</p>
</blockquote>
<p>I just realized that this breaks my tensor product, but I suppose it will make it easier</p>

<a name="124550578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/124550578" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#124550578">Kenny Lau (Apr 02 2018 at 23:21)</a>:</h4>
<p>Do you see any easy proof of this?</p>
<div class="codehilite"><pre><span></span>theorem structural_theorem (f : free_abelian_group β γ) :
  ∃ S : finset (free_abelian_group β γ), (∀ g ∈ S, ∃ (x : β) (y : γ) (n : ℤ) (H : n ≠ 0), g = finsupp.single (x, y) n) ∧ S.sum id = f :=
</pre></div>

<a name="124551662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/working%20with%20finite%20sequences/near/124551662" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/73481workingwithfinitesequences.html#124551662">Kenny Lau (Apr 02 2018 at 23:49)</a>:</h4>
<p>nvm, I proved it</p>


{% endraw %}
