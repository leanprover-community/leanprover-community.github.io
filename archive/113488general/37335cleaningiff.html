---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/37335cleaningiff.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/37335cleaningiff.html">cleaning iff</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="174212351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174212351" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37335cleaningiff.html#174212351">Patrick Massot (Aug 27 2019 at 09:47)</a>:</h4>
<p><span class="user-mention" data-user-id="110865">@Jeremy Avigad</span> in particular: another area (besides calculations) where I'm always angry about automation is many proofs that are only unpackaging and repackaging stuff. The following is an example abstracted from a topological groups and filter context:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_sub</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">S</span> <span class="n">T</span> <span class="o">:</span> <span class="n">set</span> <span class="err">$</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
 <span class="o">(</span><span class="bp">∀</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">},</span> <span class="n">V</span> <span class="err">∈</span> <span class="n">S</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">t</span> <span class="err">∈</span> <span class="n">T</span><span class="o">),</span> <span class="n">set</span><span class="bp">.</span><span class="n">prod</span> <span class="n">t</span> <span class="n">t</span> <span class="err">⊆</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">α</span><span class="o">),</span> <span class="n">x</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">-</span> <span class="n">x</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span> <span class="bp">⁻¹</span><span class="err">&#39;</span> <span class="n">V</span><span class="o">))</span> <span class="bp">↔</span>
    <span class="bp">∀</span> <span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">),</span> <span class="n">U</span> <span class="err">∈</span> <span class="n">S</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">M</span> <span class="err">∈</span> <span class="n">T</span><span class="o">),</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">-</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">U</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>

<a name="174212424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174212424" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37335cleaningiff.html#174212424">Patrick Massot (Aug 27 2019 at 09:48)</a>:</h4>
<p>This has no mathematical content (in the sense that a mathematician wouldn't understand what requires a proof here).</p>

<a name="174212570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174212570" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37335cleaningiff.html#174212570">Patrick Massot (Aug 27 2019 at 09:50)</a>:</h4>
<p>What I would like Lean to do is at least to peel-off layers that are common to both lines.</p>

<a name="174212582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174212582" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37335cleaningiff.html#174212582">Patrick Massot (Aug 27 2019 at 09:50)</a>:</h4>
<p>Note that in this specific example, <code>by simp [subset_def]</code> works.</p>

<a name="174212794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174212794" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37335cleaningiff.html#174212794">Patrick Massot (Aug 27 2019 at 09:53)</a>:</h4>
<p>But it takes time to reach that conclusion. I also experimented writing the following stupid tactic:</p>
<div class="codehilite"><pre><span></span><span class="kn">open</span> <span class="n">tactic</span>
<span class="n">meta</span> <span class="n">def</span> <span class="n">clean_step</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">do</span> <span class="n">tgt</span> <span class="err">←</span> <span class="n">target</span><span class="o">,</span>
   <span class="k">match</span> <span class="n">tgt</span> <span class="k">with</span>
   <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="err">%%</span><span class="n">a</span> <span class="bp">→</span> <span class="err">%%</span><span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">`</span><span class="o">[</span><span class="n">intros</span><span class="o">]</span>
   <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="err">%%</span><span class="n">a</span> <span class="bp">↔</span> <span class="err">%%</span><span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="k">match</span> <span class="n">a</span> <span class="k">with</span>
                     <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="err">%%</span><span class="n">c</span> <span class="bp">→</span> <span class="err">%%</span><span class="n">d</span><span class="o">)</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">c</span><span class="bp">.</span><span class="n">has_var</span> <span class="k">then</span> <span class="bp">`</span><span class="o">[</span><span class="n">apply</span> <span class="n">imp_congr</span><span class="o">]</span> <span class="k">else</span> <span class="bp">`</span><span class="o">[</span><span class="n">apply</span> <span class="n">forall_congr</span><span class="o">]</span>
                     <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">Exists</span> <span class="err">%%</span><span class="n">c</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">`</span><span class="o">[</span><span class="n">apply</span> <span class="n">exists_congr</span><span class="o">]</span>
                     <span class="bp">|</span> <span class="bp">_</span> <span class="o">:=</span> <span class="bp">`</span><span class="o">[</span><span class="n">exact</span> <span class="n">iff</span><span class="bp">.</span><span class="n">rfl</span><span class="o">]</span>
                     <span class="kn">end</span>
   <span class="bp">|</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">fail</span> <span class="s2">&quot;Goal is not a forall, implies or iff&quot;</span>
   <span class="kn">end</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span><span class="bp">.</span><span class="n">clean_iff</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span> <span class="n">do</span> <span class="n">repeat</span> <span class="n">clean_step</span>
</pre></div>


<p>doing the peeling-off. In the example above, it reduces the goal to <code>set.prod s s ⊆ (λ (x : α × α), x.snd - x.fst) ⁻¹' a ↔  ∀ (x y : α), x ∈ s → y ∈ s → y - x ∈ a</code> which can be closed by <code>library_search</code>, which is pretty good I think. Should we try to make a smarter version of that tactic?</p>

<a name="174213553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174213553" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37335cleaningiff.html#174213553">Johan Commelin (Aug 27 2019 at 10:04)</a>:</h4>
<p>I've wanted such a "mild" congr tactic as well.</p>

<a name="174226236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174226236" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37335cleaningiff.html#174226236">Reid Barton (Aug 27 2019 at 13:04)</a>:</h4>
<p>This does feel like something within the scope of congr</p>

<a name="174229806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174229806" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37335cleaningiff.html#174229806">Jeremy Avigad (Aug 27 2019 at 13:41)</a>:</h4>
<p>I have had to do similar things, with crazy lambdas and corner brackets. It is funny how much of mathematics is just unpacking and repacking information. This is something that a decent tableau prover should do. (I am disappointed that <code>finish</code> is no help.) It is worth experimenting to see how useful a <code>congr</code>-like tactic is, though eventually it would be nice to see this subsumed by general automation.</p>

<a name="174229918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174229918" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37335cleaningiff.html#174229918">Patrick Massot (Aug 27 2019 at 13:42)</a>:</h4>
<p>I have no opinion about what kind of automation should do it, I only say <em>I</em> don't want to do it.</p>

<a name="174230252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174230252" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37335cleaningiff.html#174230252">Patrick Massot (Aug 27 2019 at 13:46)</a>:</h4>
<p>Here is my short answer to your "automation for the working mathematician" wish-list question:</p>
<ul>
<li>elaboration that works, including coercions, especially to functions, and type class resolution</li>
<li>calculations where I only give the intermediate steps I would write on paper, using <code>ring</code>, <code>abel</code> and their non-existent extensions to other algebraic structures, and non-linear <code>linarith</code></li>
<li>packing/unpacking stuff</li>
</ul>

<a name="174231499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174231499" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37335cleaningiff.html#174231499">Jeremy Avigad (Aug 27 2019 at 13:58)</a>:</h4>
<p>Thanks! I really am taking notes and gathering all the comments I received.</p>

<a name="174231785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174231785" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37335cleaningiff.html#174231785">Patrick Massot (Aug 27 2019 at 14:02)</a>:</h4>
<p>I would have never guessed that when I started Lean and everything was confusing, but today it's clear that elaboration is by far the most important aspect. I spend most of my wasted time fighting the elaborator (and parser maybe).</p>

<a name="174231906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174231906" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37335cleaningiff.html#174231906">Johan Commelin (Aug 27 2019 at 14:03)</a>:</h4>
<p>With good-old-paper-maths you could offload those fights to the reader (-;</p>

<a name="174231930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174231930" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37335cleaningiff.html#174231930">Patrick Massot (Aug 27 2019 at 14:03)</a>:</h4>
<p>This and so many other boring details</p>

<a name="174231934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174231934" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37335cleaningiff.html#174231934">Johan Commelin (Aug 27 2019 at 14:03)</a>:</h4>
<p>The elaborator is the formalisation of "left as an exercise for the reader" <span aria-label="stuck out tongue wink" class="emoji emoji-1f61c" role="img" title="stuck out tongue wink">:stuck_out_tongue_wink:</span></p>

<a name="174232508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174232508" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37335cleaningiff.html#174232508">Jeremy Avigad (Aug 27 2019 at 14:09)</a>:</h4>
<p>One important question is what should be done by the elaborator and what should be done by automation at a later stage. The elaborator should be focused on filling in information that is absolutely essential to make sense of an expression. It may be putting too much of a burden on the elaborator to expect it to prove that an operation is commutative or a set is finite. Maybe that is best done by another process later on, that acts when all the implicit data has been inferred.</p>

<a name="174233034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174233034" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37335cleaningiff.html#174233034">Patrick Massot (Aug 27 2019 at 14:14)</a>:</h4>
<p>Let me prove once more that I have no idea how type classes work, and ask: why is it stupid to insert the following two mechanisms into type class search:</p>
<ul>
<li>allow to write <code>instance_for `X my_class := explicit_instance or by apply_instance</code> where, as usual, <code> `X </code> is a name. Then every type Lean wants to infer an instance for <code>my_type X</code> use the database created by that line. </li>
<li>If the previous method fails,  class search <code>[my_class X Y Z...]</code> by a search by name head_symbol_of_X.class_name</li>
</ul>
<p>If both fail then use the current algorithm. To me it sounds like this would solve most of the cases where Lean fails or take forever to find an instance. For instance we have files in the perfectoid space where <code>K</code> denotes a field, and it does so for 1000 lines.  And each proof involves Lean searching at least twice for <code>comm_ring K</code>. It sounds like looking at a hash table under key <code>K</code> would be much faster.</p>

<a name="174233591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174233591" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37335cleaningiff.html#174233591">Patrick Massot (Aug 27 2019 at 14:20)</a>:</h4>
<p>I don't think I want to put a burden on the elaborator. I only want coercions and type class search to do their jobs. And also, I'd like the elaborator to stop thinking every numeral is in nat</p>

<a name="174237114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174237114" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37335cleaningiff.html#174237114">Sebastian Ullrich (Aug 27 2019 at 14:59)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> Adding a head index (i.e. exactly what <code>simp</code> uses) to the instance search is definitely something we have been thinking about. Though I believe Leo already has new plans for the whole algorithm we haven't talked about yet, so I won't speculate any further for now.</p>

<a name="174237153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174237153" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37335cleaningiff.html#174237153">Johan Commelin (Aug 27 2019 at 14:59)</a>:</h4>
<p>Does that mean it will only become as slow as <code>simp</code> is? (See the other thread...)</p>

<a name="174237166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174237166" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37335cleaningiff.html#174237166">Sebastian Ullrich (Aug 27 2019 at 14:59)</a>:</h4>
<p>no</p>


{% endraw %}

{% include archive_update.html %}