---
layout: archive
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/04284linarith.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html">linarith</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="148096612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148096612" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148096612">Johan Commelin (Nov 21 2018 at 08:53)</a>:</h4>
<p>Shouldn't <code>linarith</code> be able to take care of this?</p>
<div class="codehilite"><pre><span></span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span>
<span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span>
<span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span>
<span class="n">ha</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">a</span><span class="bp">.</span><span class="n">val</span> <span class="bp">&lt;</span> <span class="n">i</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="n">b</span><span class="bp">.</span><span class="n">val</span> <span class="bp">&lt;</span> <span class="n">i</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span>
<span class="n">H</span> <span class="o">:</span> <span class="n">a</span><span class="bp">.</span><span class="n">val</span> <span class="bp">≤</span> <span class="n">b</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span>
<span class="n">a_1</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="o">(</span><span class="n">a</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span> <span class="bp">&gt;</span> <span class="n">b</span><span class="bp">.</span><span class="n">val</span>
<span class="err">⊢</span> <span class="n">false</span>
</pre></div>

<a name="148096896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148096896" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148096896">Kenny Lau (Nov 21 2018 at 09:00)</a>:</h4>
<p>I thought it has been made clear that <code>linarith</code> doesn't deal with <code>nat</code></p>

<a name="148097084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148097084" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148097084">Patrick Massot (Nov 21 2018 at 09:05)</a>:</h4>
<p>After <code>apply ha</code> it should be an easy target for <code>mono</code> but it doesn't work <span class="emoji emoji-2639" title="sad">:sad:</span></p>

<a name="148097138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148097138" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148097138">Patrick Massot (Nov 21 2018 at 09:06)</a>:</h4>
<p><span class="user-mention" data-user-id="110026">@Simon Hudon</span> </p>
<div class="codehilite"><pre><span></span>import tactic.monotonicity

example (n : ℕ)
(i : fin (n + 1 + 1))
(a b : fin (n + 1))
(ha : ¬a.val &lt; i.val)
(h : b.val &lt; i.val)
(H : a.val ≤ b.val)
(a_1 : nat.succ (a.val) &gt; b.val) : false :=
begin
  apply ha,
  mono*,  -- does nothing :-(
  exact calc a.val ≤ _ : H
  ... &lt; _ : h,
end
</pre></div>

<a name="148097160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148097160" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148097160">Rob Lewis (Nov 21 2018 at 09:07)</a>:</h4>
<p>Change <code>nat.succ (a.val)</code> to <code>a.val + 1</code>.</p>

<a name="148097178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148097178" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148097178">Patrick Massot (Nov 21 2018 at 09:08)</a>:</h4>
<p>This is the first thing I tried, but it changes nothing</p>

<a name="148097262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148097262" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148097262">Kenny Lau (Nov 21 2018 at 09:09)</a>:</h4>
<p>maybe stop (over)relying on tactics</p>

<a name="148097310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148097310" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148097310">Rob Lewis (Nov 21 2018 at 09:10)</a>:</h4>
<p>Oh, change <code>ha</code> to <code>a.val ≥ i.val</code>.</p>

<a name="148097329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148097329" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148097329">Patrick Massot (Nov 21 2018 at 09:11)</a>:</h4>
<p>that works</p>

<a name="148097395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148097395" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148097395">Patrick Massot (Nov 21 2018 at 09:12)</a>:</h4>
<p>Kenny, the discussion is not really about how to prove that particular goal. It's about having a toolset which gets rid of hundred of stupid goals like this, that would otherwise break our proof flow and concentration</p>

<a name="148097485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148097485" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148097485">Rob Lewis (Nov 21 2018 at 09:14)</a>:</h4>
<p>There's something wrong with the routine that makes <code>linarith</code> work for <code>nat</code> and the part that deals with negated hypotheses, I'll look into it when I have a minute.</p>

<a name="148097660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148097660" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148097660">Patrick Massot (Nov 21 2018 at 09:18)</a>:</h4>
<p>Nice! In the mean time, Johan can use <code>replace ha := le_of_not_lt ha ; linarith</code> to close that goal</p>

<a name="148097675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148097675" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148097675">Rob Lewis (Nov 21 2018 at 09:18)</a>:</h4>
<p>Or <code>apply ha; linarith</code>.</p>

<a name="148097682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148097682" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148097682">Patrick Massot (Nov 21 2018 at 09:18)</a>:</h4>
<p>indeed</p>

<a name="148099129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148099129" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148099129">Sebastien Gouezel (Nov 21 2018 at 09:49)</a>:</h4>
<p>Another <code>linarith</code>wishlist entry: if there is an assumption <code>abs x ≤ c</code>, convert it to <code>x ≤ c</code> and <code>-x ≤ c</code>.</p>

<a name="148101337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148101337" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148101337">Rob Lewis (Nov 21 2018 at 10:36)</a>:</h4>
<p>There are various unfolding/preprocessing things like that, that <code>linarith</code> could do. Writing a separate tactic that unfolds <code>abs</code> would be very easy, and you could even add <code>meta def linarith' := unfold_abs; linarith</code> if you wanted. But I'm not sure that bundling all these things into the main tactic is a good idea.</p>

<a name="148101362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148101362" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148101362">Rob Lewis (Nov 21 2018 at 10:37)</a>:</h4>
<p>There's now a PR open to fix Johan's problem, btw.</p>

<a name="148101659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148101659" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148101659">Sebastien Gouezel (Nov 21 2018 at 10:45)</a>:</h4>
<p>OK, I understand. I can definitely unfold it by hand when needed. I am just motivated by the principle of maximal laziness.</p>

<a name="148104169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148104169" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148104169">Johan Commelin (Nov 21 2018 at 11:34)</a>:</h4>
<p><span class="user-mention" data-user-id="110596">@Rob Lewis</span> Cool! Thanks a lot.</p>

<a name="148104182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148104182" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148104182">Johan Commelin (Nov 21 2018 at 11:35)</a>:</h4>
<p>Now there is still the problem with <code>nat.succ _</code> vs <code>_ + 1</code>. Could that be fixed as well?</p>

<a name="148104248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148104248" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148104248">Johan Commelin (Nov 21 2018 at 11:36)</a>:</h4>
<p>Because then I could run <code>split_ifs with foo bar; {ext, simp, linarith}</code> and be done with it. Otherwise I need to explicitly <code>change</code> my goal for each goal. Or should I write a custom simp-lemma for this, that I use locally?</p>

<a name="148104284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148104284" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148104284">Johan Commelin (Nov 21 2018 at 11:37)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">δ_monotone</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="o">[</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">])</span> <span class="o">:</span> <span class="n">monotone</span> <span class="o">(</span><span class="n">δ</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">change</span> <span class="n">a</span><span class="bp">.</span><span class="n">val</span> <span class="bp">≤</span> <span class="n">b</span><span class="bp">.</span><span class="n">val</span> <span class="n">at</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">dsimp</span> <span class="o">[</span><span class="n">fin</span><span class="bp">.</span><span class="n">succ_above</span><span class="o">],</span>
  <span class="n">split_ifs</span> <span class="k">with</span> <span class="n">ha</span> <span class="n">hb</span><span class="bp">;</span>
  <span class="n">try</span> <span class="o">{</span> <span class="n">ext1</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="n">linarith</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">ext1</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="n">change</span> <span class="bp">_</span> <span class="bp">≤</span> <span class="bp">_</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">linarith</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">ext1</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="n">change</span> <span class="bp">_</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="bp">_</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">linarith</span> <span class="o">}</span>
<span class="kn">end</span>
</pre></div>

<a name="148104414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148104414" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148104414">Rob Lewis (Nov 21 2018 at 11:40)</a>:</h4>
<p><span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> If you don't want to do it by hand, you can finish this and use it (or modify it to fit your purposes). Just use <code>unfold_abs; linarith</code> in place of <code>linarith</code>, or define an alias for that.</p>
<div class="codehilite"><pre><span></span><span class="kn">open</span> <span class="n">tactic</span>
<span class="kn">lemma</span> <span class="n">le_and_le_of_abs_le</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_linear_ordered_comm_group</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">abs</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">∧</span> <span class="bp">-</span><span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="o">:=</span>
<span class="n">sorry</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">unfold_abs</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">local_context</span> <span class="bp">&gt;&gt;=</span> <span class="n">list</span><span class="bp">.</span><span class="n">mmap&#39;</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="n">try</span> <span class="o">(</span><span class="n">mk_app</span> <span class="bp">`</span><span class="n">le_and_le_of_abs_le</span> <span class="o">[</span><span class="n">e</span><span class="o">]</span> <span class="bp">&gt;&gt;=</span> <span class="n">cases</span><span class="o">))</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">abs</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">abs</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">unfold_abs</span>
<span class="kn">end</span>
</pre></div>

<a name="148104502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148104502" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148104502">Rob Lewis (Nov 21 2018 at 11:41)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> This falls into the same basket as Sebastien's request. There are lots of constants that can be unfolded or rewritten into a form that <code>linarith</code> will handle. I don't want to build them all in. You can just add <code>nat.succ_eq_add_one</code> to the <code>simp</code> call.</p>

<a name="148104578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148104578" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148104578">Johan Commelin (Nov 21 2018 at 11:42)</a>:</h4>
<p>Ok, thanks, will do.</p>

<a name="148104774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148104774" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148104774">Johan Commelin (Nov 21 2018 at 11:47)</a>:</h4>
<blockquote>
<p>maybe stop (over)relying on tactics</p>
</blockquote>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> Can you golf this?</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">δ_monotone</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="o">[</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">])</span> <span class="o">:</span> <span class="n">monotone</span> <span class="o">(</span><span class="n">δ</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">a</span><span class="bp">.</span><span class="n">val</span> <span class="bp">≤</span> <span class="n">b</span><span class="bp">.</span><span class="n">val</span><span class="o">),</span>
<span class="k">by</span> <span class="n">dsimp</span> <span class="o">[</span><span class="n">fin</span><span class="bp">.</span><span class="n">succ_above</span><span class="o">]</span><span class="bp">;</span> <span class="n">split_ifs</span> <span class="k">with</span> <span class="n">ha</span> <span class="n">hb</span><span class="bp">;</span> <span class="o">{</span> <span class="n">ext1</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ_eq_add_one</span><span class="o">],</span> <span class="n">linarith</span> <span class="o">}</span>
</pre></div>


<p>You can find it here: <a href="https://github.com/leanprover-community/mathlib/blob/simplicial/algebraic_topology/simplex_category.lean#L33-L35" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/simplicial/algebraic_topology/simplex_category.lean#L33-L35">https://github.com/leanprover-community/mathlib/blob/simplicial/algebraic_topology/simplex_category.lean#L33-L35</a></p>

<a name="148105362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148105362" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148105362">Johan Commelin (Nov 21 2018 at 12:00)</a>:</h4>
<p><span class="user-mention" data-user-id="110596">@Rob Lewis</span> So presumably goals of this form are also outside the scope of <code>linarith</code>?</p>
<div class="codehilite"><pre><span></span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span>
<span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span>
<span class="n">H</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">j</span><span class="o">,</span>
<span class="n">a</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span>
<span class="n">h</span> <span class="o">:</span> <span class="n">a</span><span class="bp">.</span><span class="n">val</span> <span class="bp">&lt;</span> <span class="n">i</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span>
<span class="n">h_1</span> <span class="o">:</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">cast_succ</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">succ</span> <span class="n">j</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span>
<span class="n">h_2</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">a</span><span class="bp">.</span><span class="n">val</span> <span class="bp">&lt;</span> <span class="n">j</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span>
<span class="n">h_3</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">succ</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span> <span class="bp">&lt;</span> <span class="n">i</span><span class="bp">.</span><span class="n">val</span>
<span class="err">⊢</span> <span class="n">a</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">+</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">+</span> <span class="n">a</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span>
</pre></div>


<p>I have 7 goals that are all of this form or another... I would like to kill them all in one go.</p>

<a name="148105382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148105382" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148105382">Johan Commelin (Nov 21 2018 at 12:00)</a>:</h4>
<p>Sorry, I should paste context...</p>

<a name="148105384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148105384" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148105384">Kevin Buzzard (Nov 21 2018 at 12:00)</a>:</h4>
<p>So these are nats?</p>

<a name="148105470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148105470" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148105470">Kevin Buzzard (Nov 21 2018 at 12:03)</a>:</h4>
<p>What is the argument in maths?</p>

<a name="148105480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148105480" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148105480">Rob Lewis (Nov 21 2018 at 12:03)</a>:</h4>
<p>Um, <code>linarith</code> doesn't know anything about the relation between <code>fin</code> and <code>fin.val</code>, or anything about <code>fin.succ</code> or <code>fin.cast_succ</code>.</p>

<a name="148105484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148105484" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148105484">Kevin Buzzard (Nov 21 2018 at 12:03)</a>:</h4>
<p>I am not sure you can ask <code>linarith</code> to start unfolding <code>fin.succ</code> or stuff like that</p>

<a name="148105487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148105487" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148105487">Kevin Buzzard (Nov 21 2018 at 12:03)</a>:</h4>
<p>There will be a never-ending list of things you want it to unfold.</p>

<a name="148105530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148105530" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148105530">Rob Lewis (Nov 21 2018 at 12:04)</a>:</h4>
<p>Basically, those are a bunch of random inequalities between distinct variables, not even all of the same type.</p>

<a name="148105541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148105541" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148105541">Rob Lewis (Nov 21 2018 at 12:04)</a>:</h4>
<p>The only thing <code>linarith</code> will learn is that <code>j.val &lt; i.val</code>.</p>

<a name="148105559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148105559" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148105559">Kevin Buzzard (Nov 21 2018 at 12:05)</a>:</h4>
<p>What about <code>x ∈ {a : ℕ | a &gt; 5}</code> ? That unfolds to an inequality, but it's surely not <code>linarith</code>'s job to figure that out.</p>

<a name="148105571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148105571" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148105571">Kenny Lau (Nov 21 2018 at 12:05)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> there must be such a function in mathlib</p>

<a name="148105575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148105575" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148105575">Kenny Lau (Nov 21 2018 at 12:06)</a>:</h4>
<p>(or not)</p>

<a name="148105617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148105617" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148105617">Kenny Lau (Nov 21 2018 at 12:06)</a>:</h4>
<p>(yes it’s decidable)</p>

<a name="148105647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148105647" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148105647">Rob Lewis (Nov 21 2018 at 12:07)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> right, see my last few comments. <span class="emoji emoji-1f642" title="slight smile">:slight_smile:</span> Infinitely many things can unfold to linear inequalities. If <code>linarith</code> tries everything possible it will be unpredictable and slow.</p>

<a name="148105717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148105717" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148105717">Johan Commelin (Nov 21 2018 at 12:09)</a>:</h4>
<p>Cool, I'm getting the hang of this! <span class="user-mention" data-user-id="110596">@Rob Lewis</span> Thanks for your help. I'm starting to understand how to play with <code>linarith</code>.<br>
After:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">simplicial_identity₁</span> <span class="o">{</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="o">[</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">]}</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">j</span><span class="o">)</span> <span class="o">:</span> <span class="n">δ</span> <span class="n">j</span><span class="bp">.</span><span class="n">succ</span> <span class="err">∘</span> <span class="n">δ</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">δ</span> <span class="n">i</span><span class="bp">.</span><span class="n">cast_succ</span> <span class="err">∘</span> <span class="n">δ</span> <span class="n">j</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">change</span> <span class="n">i</span><span class="bp">.</span><span class="n">val</span> <span class="bp">≤</span> <span class="n">j</span><span class="bp">.</span><span class="n">val</span> <span class="n">at</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">funext</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">dsimp</span> <span class="o">[</span><span class="n">fin</span><span class="bp">.</span><span class="n">succ_above</span><span class="o">],</span>
  <span class="n">split_ifs</span><span class="bp">;</span> <span class="o">{</span> <span class="n">try</span> <span class="o">{</span><span class="n">ext1</span><span class="o">},</span> <span class="n">try</span> <span class="o">{</span><span class="n">simp</span> <span class="o">[</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ_eq_add_one</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span><span class="o">},</span> <span class="n">try</span> <span class="o">{</span><span class="n">linarith</span><span class="o">}</span> <span class="o">},</span>
<span class="kn">end</span>
</pre></div>


<p>Before:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">simplicial_identity₁</span> <span class="o">{</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="o">[</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">]}</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">j</span><span class="o">)</span> <span class="o">:</span> <span class="n">δ</span> <span class="n">j</span><span class="bp">.</span><span class="n">succ</span> <span class="err">∘</span> <span class="n">δ</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">δ</span> <span class="n">i</span><span class="bp">.</span><span class="n">cast_succ</span> <span class="err">∘</span> <span class="n">δ</span> <span class="n">j</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">funext</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">dsimp</span> <span class="o">[</span><span class="n">fin</span><span class="bp">.</span><span class="n">succ_above</span><span class="o">],</span>
  <span class="n">by_cases</span> <span class="n">hja</span> <span class="o">:</span> <span class="o">(</span><span class="n">j</span><span class="bp">.</span><span class="n">val</span> <span class="bp">&lt;</span> <span class="n">a</span><span class="bp">.</span><span class="n">val</span><span class="o">),</span>
  <span class="o">{</span> <span class="k">have</span> <span class="n">hja&#39;</span> <span class="o">:</span> <span class="o">((</span><span class="n">fin</span><span class="bp">.</span><span class="n">succ</span> <span class="n">j</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">succ</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">begin</span>
      <span class="n">simp</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ_le_succ</span> <span class="n">hja</span><span class="o">,</span>
    <span class="kn">end</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hia</span> <span class="o">:</span> <span class="o">((</span><span class="n">i</span><span class="bp">.</span><span class="n">cast_succ</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">succ</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">begin</span>
      <span class="n">simp</span><span class="o">,</span>
      <span class="n">refine</span> <span class="o">(</span><span class="n">lt_of_le_of_lt</span> <span class="n">H</span> <span class="bp">_</span><span class="o">),</span>
      <span class="n">exact</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">le_trans</span> <span class="n">hja</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">le_succ</span> <span class="n">a</span><span class="bp">.</span><span class="n">val</span><span class="o">))</span>
    <span class="kn">end</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">if_pos</span> <span class="n">hja</span><span class="o">,</span> <span class="n">if_pos</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">le_trans</span> <span class="n">H</span> <span class="n">hja</span><span class="o">),</span> <span class="n">if_pos</span> <span class="n">hja&#39;</span><span class="o">,</span> <span class="n">if_pos</span> <span class="n">hia</span><span class="o">]},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">dif_neg</span> <span class="n">hja</span><span class="o">],</span>
    <span class="n">by_cases</span> <span class="n">hia</span> <span class="o">:</span> <span class="o">(</span><span class="n">i</span><span class="bp">.</span><span class="n">val</span> <span class="bp">≤</span> <span class="n">a</span><span class="bp">.</span><span class="n">val</span><span class="o">),</span>
    <span class="o">{</span> <span class="k">have</span> <span class="n">hia&#39;</span> <span class="o">:</span> <span class="o">((</span><span class="n">fin</span><span class="bp">.</span><span class="n">raise</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">raise</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span> <span class="o">:=</span> <span class="n">hia</span><span class="o">,</span>

      <span class="k">have</span> <span class="n">hja&#39;</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">j</span><span class="bp">.</span><span class="n">succ</span><span class="bp">.</span><span class="n">val</span> <span class="bp">≤</span> <span class="n">a</span><span class="bp">.</span><span class="n">succ</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span> <span class="o">:=</span>
      <span class="k">begin</span>
        <span class="n">simp</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ_le_succ</span> <span class="n">hja</span>
      <span class="kn">end</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">dif_pos</span> <span class="n">hia</span><span class="o">,</span> <span class="n">dif_pos</span> <span class="n">hia&#39;</span><span class="o">,</span> <span class="n">dif_neg</span> <span class="n">hja&#39;</span><span class="o">],</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">fin</span><span class="bp">.</span><span class="n">raise</span><span class="o">],</span>
      <span class="n">apply</span> <span class="n">fin</span><span class="bp">.</span><span class="n">eq_of_veq</span><span class="o">,</span>
      <span class="n">simp</span><span class="o">},</span>
    <span class="o">{</span> <span class="k">have</span> <span class="n">hja&#39;</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">j</span><span class="bp">.</span><span class="n">succ</span><span class="bp">.</span><span class="n">val</span> <span class="bp">≤</span> <span class="n">a</span><span class="bp">.</span><span class="n">raise</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span> <span class="o">:=</span>
      <span class="k">begin</span>
        <span class="n">simp</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">le_trans</span> <span class="n">hja</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">le_succ</span> <span class="n">j</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span>
      <span class="kn">end</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">hia&#39;</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">((</span><span class="n">fin</span><span class="bp">.</span><span class="n">raise</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">raise</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span> <span class="o">:=</span>
      <span class="k">begin</span>
        <span class="n">unfold</span> <span class="n">fin</span><span class="bp">.</span><span class="n">raise</span><span class="o">,</span> <span class="n">exact</span> <span class="n">hia</span>
      <span class="kn">end</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">dif_neg</span> <span class="n">hia</span><span class="o">,</span> <span class="n">dif_neg</span> <span class="n">hja&#39;</span><span class="o">,</span> <span class="n">dif_neg</span> <span class="n">hia&#39;</span><span class="o">]}}</span>
<span class="kn">end</span>
</pre></div>

<a name="148106009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148106009" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148106009">Johan Commelin (Nov 21 2018 at 12:15)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> Do you mean it should be provable by <code>dec_trivial</code>?</p>

<a name="148122480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148122480" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148122480">Simon Hudon (Nov 21 2018 at 16:48)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> <span class="user-mention" data-user-id="110596">@Rob Lewis</span> Did the problem turn out to be <code>mono</code>?</p>

<a name="148122892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148122892" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148122892">Patrick Massot (Nov 21 2018 at 16:54)</a>:</h4>
<p><code>linarith</code> doesn't use <code>mono</code> so the bug in <code>linarith</code> had nothing to do with <code>mono</code> (and is now fixed). But I'm still disappointed I can't get <code>mono</code> to help here</p>

<a name="148123052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148123052" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148123052">Patrick Massot (Nov 21 2018 at 16:56)</a>:</h4>
<p>You can try, what I posted right after pinging you is a MWE</p>

<a name="148123091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148123091" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148123091">Patrick Massot (Nov 21 2018 at 16:57)</a>:</h4>
<p>search for "does nothing" in this thread</p>

<a name="148124879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148124879" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148124879">Simon Hudon (Nov 21 2018 at 17:23)</a>:</h4>
<p>I wouldn't expect it to do anything in that case. What would you expect it to do?</p>

<a name="148125029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148125029" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148125029">Patrick Massot (Nov 21 2018 at 17:25)</a>:</h4>
<p>I would expect it to close the goal</p>

<a name="148128435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148128435" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148128435">Simon Hudon (Nov 21 2018 at 18:23)</a>:</h4>
<p>You mean using mixed transitivity? It doesn’t do that. What it does is identify a monotonic function on either side of a relation. &lt; is that relation in your case but it doesn’t have a monotonic function on both sides.</p>

<a name="148128458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148128458" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148128458">Simon Hudon (Nov 21 2018 at 18:23)</a>:</h4>
<p>If you want, you can treat &lt; as the monotonic function and -&gt; as the relation.</p>

<a name="148128569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148128569" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148128569">Simon Hudon (Nov 21 2018 at 18:25)</a>:</h4>
<p>To do that, you need to do <code>revert h</code> before mono.</p>

<a name="148131648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148131648" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148131648">Patrick Massot (Nov 21 2018 at 19:18)</a>:</h4>
<p>This is sad. We need something like <code>cc</code> for inequality, working together with <code>mono</code></p>

<a name="148131680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148131680" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148131680">Simon Hudon (Nov 21 2018 at 19:19)</a>:</h4>
<p>Maybe something like what I did for tfae would work for that</p>

<a name="148131689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148131689" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148131689">Patrick Massot (Nov 21 2018 at 19:19)</a>:</h4>
<p>Except <code>tfae</code> doesn't work <span class="emoji emoji-2639" title="sad">:sad:</span></p>

<a name="148131747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148131747" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148131747">Patrick Massot (Nov 21 2018 at 19:20)</a>:</h4>
<p>The following is ridiculous but gives hope:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">≤</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="n">h&#39;</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">≤</span> <span class="n">r</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">≤</span> <span class="n">r</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">refine</span> <span class="n">le_trans</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">swap</span><span class="o">,</span>
  <span class="n">tauto</span><span class="o">,</span>
  <span class="n">tauto</span>
<span class="kn">end</span>
</pre></div>

<a name="148131762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148131762" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148131762">Patrick Massot (Nov 21 2018 at 19:21)</a>:</h4>
<p>This is the kind goal I hope some "<code>cc</code> for inequalities" would solve</p>

<a name="148131878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148131878" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148131878">Simon Hudon (Nov 21 2018 at 19:23)</a>:</h4>
<p>What is tricky for this kind of tactic is that one would expect it to work in the case of mixed transitivity which makes selecting a relation a bit more difficult. I could do it specifically for <code>&lt;</code> and <code>≤</code> to simplify things but it's a bit disappointing in terms of generality</p>

<a name="148131995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148131995" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148131995">Simon Hudon (Nov 21 2018 at 19:25)</a>:</h4>
<p>But in the situations that you're showing, it seems like the kind of stuff <code>linarith</code> should handle</p>

<a name="148135817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148135817" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148135817">Rob Lewis (Nov 21 2018 at 20:36)</a>:</h4>
<p>Patrick, can you elaborate on what you mean by "cc for inequalities"?</p>

<a name="148135937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148135937" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148135937">Chris Hughes (Nov 21 2018 at 20:38)</a>:</h4>
<p>I think he more or less means solvable using linear order axioms, without any algebra.</p>

<a name="148135954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148135954" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148135954">Chris Hughes (Nov 21 2018 at 20:39)</a>:</h4>
<p>But I think linarith does those.</p>

<a name="148136093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148136093" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148136093">Rob Lewis (Nov 21 2018 at 20:41)</a>:</h4>
<p>Ah. Yeah, linarith does those. But I guess it requires some extra algebraic structure on the type that isn't always necessary.</p>

<a name="148136290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148136290" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148136290">Chris Hughes (Nov 21 2018 at 20:45)</a>:</h4>
<p>And maybe preorder axioms and partial order axioms would be nice as well.</p>

<a name="148136993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148136993" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148136993">Rob Lewis (Nov 21 2018 at 20:59)</a>:</h4>
<p>Indeed. A tactic for this kind of transitivity reasoning would be a nice project for someone who wants to learn about writing tactics. <span class="emoji emoji-1f609" title="wink">:wink:</span></p>

<a name="148136997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148136997" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148136997">Rob Lewis (Nov 21 2018 at 20:59)</a>:</h4>
<p>Note, I haven't really looked into <code>mono</code> yet, so I'm not sure how much overlap there is.</p>

<a name="148137165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148137165" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148137165">Simon Hudon (Nov 21 2018 at 21:03)</a>:</h4>
<p>There isn't much overlap actually. To implement this tactic, tfae would be more helpful. It calculates the transitive closure of implication on the local assumptions.</p>

<a name="148137182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148137182" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148137182">Simon Hudon (Nov 21 2018 at 21:04)</a>:</h4>
<p>You replace implication by a preorder and you'd get what Patrick is talking about with the additional difficulty of handling <code>&lt;</code> properly</p>

<a name="148137301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148137301" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148137301">Rob Lewis (Nov 21 2018 at 21:06)</a>:</h4>
<p>Ah, sure. Sounds reasonable enough.</p>

<a name="148140643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148140643" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148140643">Patrick Massot (Nov 21 2018 at 22:16)</a>:</h4>
<p>I'd love to try to understand how to adapt <code>tfae</code> here, but again I don't think this would be reasonable before we get a deterministic behavior from <code>tfae</code></p>

<a name="148181673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148181673" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148181673">Kenny Lau (Nov 22 2018 at 15:30)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> I see someone has figured out the function in mathlib</p>

<a name="148187179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148187179" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148187179">Johan Commelin (Nov 22 2018 at 17:24)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> Wait, which function in mathlib are you referring to?</p>

<a name="148190141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148190141" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148190141">Kenny Lau (Nov 22 2018 at 18:39)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> <code>fin.succ_above</code></p>

<a name="148191135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148191135" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148191135">Johan Commelin (Nov 22 2018 at 19:07)</a>:</h4>
<p>Aah, yes, I'm using that one. Was that answering a question of mine?</p>

<a name="148191179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148191179" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148191179">Johan Commelin (Nov 22 2018 at 19:08)</a>:</h4>
<p>Or maybe you just think it is confusing notation? It probably is...</p>

<a name="148191834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148191834" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148191834">Kenny Lau (Nov 22 2018 at 19:29)</a>:</h4>
<p>never mind, ignore me</p>

<a name="148254707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148254707" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148254707">Scott Morrison (Nov 23 2018 at 23:59)</a>:</h4>
<p>More requests: are these reasonable to expect from <code>linarith</code>?</p>
<div class="codehilite"><pre><span></span>n m : ℕ,
h₁ : n &lt; m,
⊢ n + 1 ≤ m
</pre></div>


<p>and</p>
<div class="codehilite"><pre><span></span>n m l : ℕ,
a_left : n ≤ l,
a_right : l &lt; n + (m - n)
⊢ l &lt; m
</pre></div>


<p>and</p>
<div class="codehilite"><pre><span></span>a_left : n ≤ l,
a_right : l &lt; m
⊢ l &lt; n + (m - n)
</pre></div>

<a name="148256879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148256879" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148256879">Kenny Lau (Nov 24 2018 at 01:16)</a>:</h4>
<blockquote>
<p>The following is ridiculous but gives hope:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">≤</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="n">h&#39;</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">≤</span> <span class="n">r</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">≤</span> <span class="n">r</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">refine</span> <span class="n">le_trans</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">swap</span><span class="o">,</span>
  <span class="n">tauto</span><span class="o">,</span>
  <span class="n">tauto</span>
<span class="kn">end</span>
</pre></div>


<p>This is the kind of goal I hope some "<code>cc</code> for inequalities" would solve</p>
</blockquote>
<p>So like this?</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">nat</span><span class="bp">.</span><span class="n">basic</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span><span class="bp">.</span><span class="n">cc_inequality</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="bp">`</span><span class="o">[</span><span class="n">transitivity</span><span class="bp">;</span> <span class="n">tauto</span><span class="o">]</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">≤</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="n">h&#39;</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">≤</span> <span class="n">r</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">≤</span> <span class="n">r</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">cc_inequality</span>
</pre></div>

<a name="148263754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148263754" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148263754">Johan Commelin (Nov 24 2018 at 05:33)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> Your first question is <code>exact h1</code>, so I would hope that <code>linarith</code> could do it.  The second and third are nasty because they use nat-subtraction. I think we still need a <code>num_cast</code> tactic that would lift it to <code>int</code>, and then <code>linarith</code> could do the job.</p>

<a name="148265222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148265222" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148265222">Andrew Ashworth (Nov 24 2018 at 06:27)</a>:</h4>
<p>Cooper will kill these, if you're willing to use another dependency</p>

<a name="148265691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148265691" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148265691">Scott Morrison (Nov 24 2018 at 06:42)</a>:</h4>
<p>Am I allowed to import <code>cooper</code> into <code>data.nat.basic</code>? :-)</p>

<a name="148265692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148265692" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148265692">Scott Morrison (Nov 24 2018 at 06:42)</a>:</h4>
<p>Thanks for the suggestion, I will try out cooper!</p>

<a name="148270921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148270921" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148270921">Rob Lewis (Nov 24 2018 at 09:54)</a>:</h4>
<p><code>linarith</code> will not prove any of those. Think of it as a tactic for linear rational inequalities.  If a goal over <code>int</code> is still provable when you replace <code>int</code> with <code>rat</code>, it will still work. Inequalities over <code>nat</code> are cast to inequalities over <code>int</code>, with extra assumptions that all atoms are nonnegative. Applications of nat subtraction are treated as atoms.</p>

<a name="148270931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148270931" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148270931">Rob Lewis (Nov 24 2018 at 09:55)</a>:</h4>
<p>The first one isn't true in a dense order. The second ones involve properties of nat subtraction beyond nonnegativity.</p>

<a name="148270979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148270979" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148270979">Rob Lewis (Nov 24 2018 at 09:56)</a>:</h4>
<p><code>cooper</code> isn't in mathlib, it's in Seul's repository. Use it, of course, but incorporating it into mathlib is a bigger discussion.</p>

<a name="148271514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148271514" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148271514">Bryan Gin-ge Chen (Nov 24 2018 at 10:13)</a>:</h4>
<p>Would it be possible to edit <code>linarith</code> so that it automatically knows that variables coerced from nat are nonnegative? Compare:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span><span class="n">a</span><span class="bp">≥</span><span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="mi">3</span><span class="o">:</span><span class="n">ℚ</span><span class="o">)</span><span class="bp">/</span><span class="mi">4</span> <span class="bp">≤</span> <span class="o">(</span><span class="mi">4</span><span class="o">:</span><span class="n">ℚ</span><span class="o">)</span> <span class="bp">+</span> <span class="n">a</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">linarith</span> <span class="c1">--works</span>
<span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="mi">3</span><span class="o">:</span><span class="n">ℚ</span><span class="o">)</span><span class="bp">/</span><span class="mi">4</span> <span class="bp">≤</span> <span class="o">(</span><span class="mi">4</span><span class="o">:</span><span class="n">ℚ</span><span class="o">)</span> <span class="bp">+</span> <span class="err">↑</span><span class="n">a</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">linarith</span> <span class="c1">-- fails</span>
<span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span><span class="n">a</span><span class="bp">≥</span><span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="mi">3</span><span class="o">:</span><span class="n">ℚ</span><span class="o">)</span><span class="bp">/</span><span class="mi">4</span> <span class="bp">≤</span> <span class="o">(</span><span class="mi">4</span><span class="o">:</span><span class="n">ℚ</span><span class="o">)</span> <span class="bp">+</span> <span class="err">↑</span><span class="n">a</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">linarith</span> <span class="c1">-- even this fails</span>
</pre></div>

<a name="148273249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148273249" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148273249">Rob Lewis (Nov 24 2018 at 11:07)</a>:</h4>
<p><code>linarith</code> isn't a smart tactic. It does one thing (linear rational arithmetic) very well, and by coincidence, sometimes it can do things with <code>nat</code> and <code>int</code>. In your second example, it doesn't know any connection between <code>a</code> and <code>↑a</code>, and why should it? Instead of a cast, that could be <code>abs</code>, or <code>square</code>, or any nonnegative function. In the very special case when it sees an inequality over <code>nat</code>, it will cast it to <code>int</code> and add the nonnegativity hypotheses. But it won't go digging through the input looking for things it can learn are nonnegative. That's a kind of preprocessing that can be done separately.</p>

<a name="148273254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148273254" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148273254">Rob Lewis (Nov 24 2018 at 11:08)</a>:</h4>
<p>The third example is a little different. It sees the <code>a &gt;= 0</code> hypothesis, and casts it to <code>int</code>. But the overall problem is in <code>rat</code>.</p>

<a name="148273298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148273298" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148273298">Rob Lewis (Nov 24 2018 at 11:08)</a>:</h4>
<p>In general, there's no well-defined type of the "overall problem," since you could have hypotheses over many different types.</p>

<a name="148273305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148273305" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148273305">Rob Lewis (Nov 24 2018 at 11:09)</a>:</h4>
<p>It could try to guess what type to cast to, or it could cast to every type that appears. This wouldn't be so unreasonable.</p>

<a name="148283001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/linarith/near/148283001" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04284linarith.html#148283001">Bryan Gin-ge Chen (Nov 24 2018 at 16:24)</a>:</h4>
<p>Thanks for explaining! As always, there was a lot of complexity lurking here that I didn't appreciate.</p>


{% endraw %}
