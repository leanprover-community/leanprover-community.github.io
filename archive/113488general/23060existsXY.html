---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/23060existsXY.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html">exists (X) (Y)</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="126709974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/126709974" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#126709974">Kevin Buzzard (May 18 2018 at 03:54)</a>:</h4>
<p><code>topological_space.is_topological_basis</code> has, as part of its definition, <code>∃ (t₃ : set α) (H : t₃ ∈ s), x ∈ t₃ ∧ ...</code>, that is, "there exists a set with some property such that..."</p>

<a name="126709984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/126709984" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#126709984">Kevin Buzzard (May 18 2018 at 03:54)</a>:</h4>
<p>So I've just sat down to write some trivial thing and it's ended up like this:</p>

<a name="126709996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/126709996" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#126709996">Kevin Buzzard (May 18 2018 at 03:55)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">analysis</span><span class="bp">.</span><span class="n">topology</span><span class="bp">.</span><span class="n">topological_space</span>
<span class="kn">universe</span> <span class="n">u</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">{</span><span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">X</span><span class="o">)}</span>

<span class="kn">definition</span> <span class="n">basis_nhds</span> <span class="o">(</span><span class="n">HB</span> <span class="o">:</span> <span class="n">topological_space</span><span class="bp">.</span><span class="n">is_topological_basis</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span><span class="n">U</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span> <span class="bp">//</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">U</span> <span class="bp">∧</span> <span class="n">U</span> <span class="err">∈</span> <span class="n">B</span><span class="o">}</span>

<span class="n">noncomputable</span> <span class="kn">instance</span> <span class="n">basis_nhds_has_so_called_sup</span> <span class="o">(</span><span class="n">HB</span> <span class="o">:</span> <span class="n">topological_space</span><span class="bp">.</span><span class="n">is_topological_basis</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span>
<span class="n">lattice</span><span class="bp">.</span><span class="n">has_sup</span> <span class="o">(</span><span class="n">basis_nhds</span> <span class="n">HB</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">sup</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">Us</span> <span class="n">Vs</span><span class="o">,</span> <span class="k">begin</span>
    <span class="n">cases</span> <span class="o">(</span><span class="n">classical</span><span class="bp">.</span><span class="n">indefinite_description</span> <span class="bp">_</span> <span class="o">(</span><span class="n">HB</span><span class="bp">.</span><span class="mi">1</span> <span class="n">Us</span><span class="bp">.</span><span class="mi">1</span> <span class="n">Us</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">2</span> <span class="n">Vs</span><span class="bp">.</span><span class="mi">1</span> <span class="n">Vs</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">2</span> <span class="n">x</span> <span class="bp">⟨</span><span class="n">Us</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span><span class="n">Vs</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">1</span><span class="bp">⟩</span><span class="o">))</span>
      <span class="k">with</span> <span class="n">W</span> <span class="n">HW</span><span class="o">,</span>
    <span class="n">cases</span> <span class="o">(</span><span class="n">classical</span><span class="bp">.</span><span class="n">indefinite_description</span> <span class="bp">_</span> <span class="n">HW</span><span class="o">)</span> <span class="k">with</span> <span class="n">HB</span> <span class="n">HW</span><span class="o">,</span>
    <span class="n">exact</span> <span class="bp">⟨</span><span class="n">W</span><span class="o">,</span><span class="bp">⟨</span><span class="n">HW</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span><span class="n">HB</span><span class="bp">⟩⟩</span>
  <span class="kn">end</span>
<span class="o">}</span>
</pre></div>

<a name="126710000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/126710000" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#126710000">Kevin Buzzard (May 18 2018 at 03:55)</a>:</h4>
<p>[this is all your fault <span class="user-mention" data-user-id="110064">@Kenny Lau</span> ]</p>

<a name="126710018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/126710018" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#126710018">Kevin Buzzard (May 18 2018 at 03:55)</a>:</h4>
<p>I want to define a function "sup", so I need some classical stuff to pull out witnesses for the exists</p>

<a name="126710067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/126710067" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#126710067">Kevin Buzzard (May 18 2018 at 03:56)</a>:</h4>
<p>and I have to run it twice because it's "exists this, such that exists that, such that..."</p>

<a name="126710139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/126710139" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#126710139">Kevin Buzzard (May 18 2018 at 03:57)</a>:</h4>
<p>Based on the "it's trivial so write a one-liner in term mode" principle I'd ideally like to write a one-liner in term mode, but writing <code>classical.indefinite_description</code> twice fills up most of the line already :-/</p>

<a name="126710140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/126710140" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#126710140">Kevin Buzzard (May 18 2018 at 03:57)</a>:</h4>
<p>Is there a trick I'm missing?</p>

<a name="126717885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/126717885" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#126717885">Reid Barton (May 18 2018 at 06:51)</a>:</h4>
<p>This only saves one of your lines, but for <code>∃ (H : p), q</code> where <code>p</code> is a <code>Prop</code>, check out <code>Exists.fst</code> and <code>Exists.snd</code>.<br>
You can eliminate the second line and change the third to <code>exact ⟨W,⟨HW.snd.1,HW.fst⟩⟩</code></p>

<a name="126718073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/126718073" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#126718073">Reid Barton (May 18 2018 at 06:55)</a>:</h4>
<p>This little detail about how <code>∃ t₃∈s, ...</code> means <code>∃ t₃, ∃ H : (t₃∈s), ...</code> is a bit annoying in this case, but using <code>.fst</code> and <code>.snd</code> you can pretty much pretend it actually means <code>∃ t₃, t₃∈s ∧ ...</code></p>

<a name="126719052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/126719052" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#126719052">Kevin Buzzard (May 18 2018 at 07:17)</a>:</h4>
<p>Here's a mathlib-free version of what I'm moaning about:</p>

<a name="126719053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/126719053" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#126719053">Kevin Buzzard (May 18 2018 at 07:17)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="o">{</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">q</span> <span class="n">x</span><span class="o">}</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">H1</span> <span class="o">:</span> <span class="n">p</span> <span class="n">x</span><span class="o">),</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">cases</span> <span class="o">(</span><span class="n">classical</span><span class="bp">.</span><span class="n">indefinite_description</span> <span class="bp">_</span> <span class="n">H</span><span class="o">)</span> <span class="k">with</span> <span class="n">x</span> <span class="n">H2</span><span class="o">,</span>
  <span class="n">cases</span> <span class="o">(</span><span class="n">classical</span><span class="bp">.</span><span class="n">indefinite_description</span> <span class="bp">_</span> <span class="n">H2</span><span class="o">)</span> <span class="k">with</span> <span class="n">H3</span> <span class="n">H4</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">r</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span><span class="n">H3</span><span class="o">,</span><span class="n">H4</span><span class="bp">⟩</span>
<span class="kn">end</span>
</pre></div>

<a name="126719176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/126719176" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#126719176">Reid Barton (May 18 2018 at 07:21)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="o">{</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">q</span> <span class="n">x</span><span class="o">}</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">H1</span> <span class="o">:</span> <span class="n">p</span> <span class="n">x</span><span class="o">),</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">cases</span> <span class="o">(</span><span class="n">classical</span><span class="bp">.</span><span class="n">indefinite_description</span> <span class="bp">_</span> <span class="n">H</span><span class="o">)</span> <span class="k">with</span> <span class="n">x</span> <span class="n">H2</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">r</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span><span class="n">H2</span><span class="bp">.</span><span class="n">fst</span><span class="o">,</span><span class="n">H2</span><span class="bp">.</span><span class="n">snd</span><span class="bp">⟩</span>
<span class="kn">end</span>
</pre></div>

<a name="126719179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/126719179" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#126719179">Kevin Buzzard (May 18 2018 at 07:21)</a>:</h4>
<p>Aah I see <span class="user-mention" data-user-id="110032">@Reid Barton</span>  -- thanks for these tips.</p>

<a name="126719190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/126719190" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#126719190">Kevin Buzzard (May 18 2018 at 07:21)</a>:</h4>
<p>I hadn't really internalised why there were two exists, or the trick with "exists proof".</p>

<a name="126719195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/126719195" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#126719195">Reid Barton (May 18 2018 at 07:22)</a>:</h4>
<p>or</p>
<div class="codehilite"><pre><span></span><span class="k">let</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span><span class="n">H2</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">classical</span><span class="bp">.</span><span class="n">indefinite_description</span> <span class="bp">_</span> <span class="n">H</span> <span class="k">in</span> <span class="n">r</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span><span class="n">H2</span><span class="bp">.</span><span class="n">fst</span><span class="o">,</span><span class="n">H2</span><span class="bp">.</span><span class="n">snd</span><span class="bp">⟩</span>
</pre></div>

<a name="126719240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/126719240" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#126719240">Kevin Buzzard (May 18 2018 at 07:22)</a>:</h4>
<p>let cases := classical.indefinite_description _ :-/</p>

<a name="126722300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/126722300" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#126722300">Mario Carneiro (May 18 2018 at 08:52)</a>:</h4>
<p>I would prefer to do the proof in two stages, first showing it's directed and then extracting the witness</p>
<div class="codehilite"><pre><span></span>section
variables {X : Type u} [topological_space X] {B : set (set X)}
variables (HB : topological_space.is_topological_basis B) (x : X)
include HB

definition basis_nhds := {U : set X // x ∈ U ∧ U ∈ B}

theorem basis_nhds_directed (U V : basis_nhds HB x) :
  ∃ W : basis_nhds HB x, W.1 ⊆ U.1 ∧ W.1 ⊆ V.1 :=
let ⟨W, h₁, h₂, h₃⟩ := HB.1 _ U.2.2 _ V.2.2 _ ⟨U.2.1, V.2.1⟩ in
⟨⟨W, h₂, h₁⟩, set.subset_inter_iff.1 h₃⟩

noncomputable instance basis_nhds_has_so_called_sup :
  lattice.has_sup (basis_nhds HB x) :=
{ sup := λ Us Vs, classical.some (basis_nhds_directed HB x Us Vs) }
end
</pre></div>


<p>You don't need <code>indefinite_description</code> here since you don't need the proof part for the definition</p>

<a name="126722619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/126722619" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#126722619">Kevin Buzzard (May 18 2018 at 09:01)</a>:</h4>
<p>Of course I need it the moment I want to prove <code>le_sup_left</code>, but I got distracted by all the function.comp shenannigans in the other thread and never got to this bit :-/</p>

<a name="126722676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/126722676" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#126722676">Kevin Buzzard (May 18 2018 at 09:03)</a>:</h4>
<p>This is a much better approach though -- my initial attempt ran into problems when I tried proving <code>le_sup_left</code> because my definition used tactics so wouldn't unfold definitionally when I wanted it to. This is a much better idea.</p>

<a name="126722729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/126722729" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#126722729">Kevin Buzzard (May 18 2018 at 09:04)</a>:</h4>
<p>So many tricks still to learn!</p>

<a name="126722943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/126722943" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#126722943">Mario Carneiro (May 18 2018 at 09:11)</a>:</h4>
<div class="codehilite"><pre><span></span>section
variables {X : Type u} [topological_space X] {B : set (set X)}
variables (HB : topological_space.is_topological_basis B) (x : X)
include HB

definition basis_nhds := {U : set X // x ∈ U ∧ U ∈ B}

instance : partial_order (basis_nhds HB x) :=
{ le := λ u v, v.1 ⊆ u.1,
  le_refl := λ u, set.subset.refl u.1,
  le_trans := λ u v w uv vw, set.subset.trans vw uv,
  le_antisymm := λ u v vu uv, subtype.eq $ set.subset.antisymm uv vu }

theorem basis_nhds_directed (U V : basis_nhds HB x) :
  ∃ W : basis_nhds HB x, U ≤ W ∧ V ≤ W :=
let ⟨W, h₁, h₂, h₃⟩ := HB.1 _ U.2.2 _ V.2.2 _ ⟨U.2.1, V.2.1⟩ in
⟨⟨W, h₂, h₁⟩, set.subset_inter_iff.1 h₃⟩

noncomputable instance basis_nhds_has_so_called_sup :
  lattice.has_sup (basis_nhds HB x) :=
{ sup := λ Us Vs, classical.some (basis_nhds_directed HB x Us Vs) }

theorem sup_le_left (u v : basis_nhds HB x) : u ≤ u ⊔ v :=
(classical.some_spec (basis_nhds_directed HB x u v)).1

theorem sup_le_right (u v : basis_nhds HB x) : v ≤ u ⊔ v :=
(classical.some_spec (basis_nhds_directed HB x u v)).2

end
</pre></div>

<a name="126722994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/126722994" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#126722994">Kevin Buzzard (May 18 2018 at 09:12)</a>:</h4>
<p>Indeed</p>

<a name="126723001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/126723001" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#126723001">Kevin Buzzard (May 18 2018 at 09:13)</a>:</h4>
<p>You missed a trick with le_antisymm though</p>

<a name="126723005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/126723005" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#126723005">Kevin Buzzard (May 18 2018 at 09:13)</a>:</h4>
<p>Oh actually maybe you didn't</p>

<a name="126723006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/126723006" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#126723006">Mario Carneiro (May 18 2018 at 09:13)</a>:</h4>
<p>I guess you can throw a <code>function.swap</code> in there if you want to be "point-free"</p>

<a name="126723007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/126723007" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#126723007">Kevin Buzzard (May 18 2018 at 09:13)</a>:</h4>
<p>Because the order is the other way</p>

<a name="126723050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/126723050" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#126723050">Mario Carneiro (May 18 2018 at 09:14)</a>:</h4>
<p>but also that circ madness is limited in usefulness since it's nondependent</p>

<a name="126723053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/126723053" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#126723053">Mario Carneiro (May 18 2018 at 09:14)</a>:</h4>
<p>so for example it wouldn't work in the definition of <code>sup</code></p>

<a name="126723104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/126723104" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#126723104">Kevin Buzzard (May 18 2018 at 09:16)</a>:</h4>
<p>You mean the HB and x screw it up?</p>

<a name="126723112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/126723112" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#126723112">Mario Carneiro (May 18 2018 at 09:16)</a>:</h4>
<p>no, the u and v do - the type of <code>basis_nhds_directed HB x u v</code> depends on them</p>

<a name="126723122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/126723122" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#126723122">Mario Carneiro (May 18 2018 at 09:17)</a>:</h4>
<p>if it worked, it would look something like <code>((∘) ∘ (∘)) classical.some (basis_nhds_directed HB x)</code></p>

<a name="126723126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/126723126" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#126723126">Kevin Buzzard (May 18 2018 at 09:17)</a>:</h4>
<p>So now all I need is for that PR to be accepted <span class="emoji emoji-1f609" title="wink">:wink:</span></p>

<a name="126723127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/126723127" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#126723127">Mario Carneiro (May 18 2018 at 09:17)</a>:</h4>
<p>There is a <code>dcomp</code> function which is dependent, but I don't think it has nice notation</p>

<a name="126723172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/126723172" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#126723172">Kevin Buzzard (May 18 2018 at 09:18)</a>:</h4>
<p>Unfortunately it looks like it might still need some work by someone who is in the middle of exams...</p>

<a name="126723187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/126723187" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#126723187">Mario Carneiro (May 18 2018 at 09:19)</a>:</h4>
<p>hm, lean doesn't like <code>((∘') ∘' (∘'))</code></p>

<a name="126723239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/126723239" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#126723239">Kevin Buzzard (May 18 2018 at 09:20)</a>:</h4>
<p>You're being sucked into the circ madness...</p>

<a name="126738602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/126738602" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#126738602">Kevin Buzzard (May 18 2018 at 18:26)</a>:</h4>
<p>So thanks for writing that proof for me Mario. I was completely on top of everything after Reid's comment about this trick for Exists so I knew I could write it, so I did the optimal thing of just writing it all myself anyway and then comparing with what you wrote. I missed the trick with <code>let ⟨W, h₁, h₂, h₃⟩ =...</code> -- I did the expansion using the trick Reid explained later on. But I also didn't use <code>include</code> and I carried <code>HB</code> around with me as an input variable. Aah, I see -- this is why you have used a section; include plays two roles and I'd only appreciated one of them until now. It can be used to insert hypotheses into the context in a tactic proof, but also to include variables into defintions in a section. I'll remark that I just learnt this by searching the pdf of TPIL for <code>include</code> -- I find the sphinx search very disappointing in this regard -- if you search the online docs for include then you just get the unenlightening response that the word is mentioned in every section, and are told the first occurrence of the word in each section; I would in this case far rather see all occurrences so I can try and spot which ones are in code blocks.</p>

<a name="127424574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/127424574" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#127424574">Patrick Massot (Jun 02 2018 at 02:31)</a>:</h4>
<p>It tried to read this thread but I still don't understand how to use <code>exists</code> classical stuff. How do you tell Lean about <code>example (X Y : Type) (f : X → Y) :  (∀ y : Y, ∃ x : X, f x = y) → (∃ g : Y → X, f ∘ g = id)</code></p>

<a name="127424633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/127424633" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#127424633">Reid Barton (Jun 02 2018 at 02:32)</a>:</h4>
<p>use <code>axiom_of_choice</code> on that hypothesis and then <code>funext</code></p>

<a name="127425370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/127425370" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#127425370">Patrick Massot (Jun 02 2018 at 02:50)</a>:</h4>
<p>Thanks you very much. </p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span>  <span class="o">(</span><span class="bp">∀</span> <span class="n">y</span> <span class="o">:</span> <span class="n">Y</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">g</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">X</span><span class="o">,</span> <span class="n">f</span> <span class="err">∘</span> <span class="n">g</span> <span class="bp">=</span> <span class="n">id</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">hyp</span><span class="o">,</span>
  <span class="n">replace</span> <span class="n">hyp</span> <span class="o">:=</span> <span class="n">classical</span><span class="bp">.</span><span class="n">axiom_of_choice</span> <span class="n">hyp</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">hyp</span> <span class="k">with</span> <span class="n">g</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">existsi</span> <span class="n">g</span><span class="o">,</span>
  <span class="n">funext</span> <span class="n">y</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">H</span> <span class="n">y</span>
<span class="kn">end</span>
</pre></div>


<p>works. I still have questions: is it what you had in mind? is there a simpler solution? can we hide this to mathematicians? can we avoid frightening stuff like <code>∃ (f_1 : Π (x : Y), (λ (y : Y), X) x), ∀ (x : Y), (λ (y : Y) (x : X), f x = y) x (f_1 x)</code> which is defeq to <code>∃ f_1 : Y → X, ∀ (x : Y), f (f_1 x) = x</code>?</p>

<a name="127425457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/127425457" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#127425457">Patrick Massot (Jun 02 2018 at 02:51)</a>:</h4>
<p>the frightening is what you get from <code>classical.axiom_of_choice hyp</code></p>

<a name="127425460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/127425460" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#127425460">Reid Barton (Jun 02 2018 at 02:51)</a>:</h4>
<p><code>set_option pp.beta true</code> should help</p>

<a name="127425513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/127425513" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#127425513">Patrick Massot (Jun 02 2018 at 02:52)</a>:</h4>
<p>perfect</p>

<a name="127425517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/127425517" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#127425517">Reid Barton (Jun 02 2018 at 02:52)</a>:</h4>
<p>And yeah, that's pretty much what I had in mind (or you can write it more succinctly in term mode)</p>

<a name="127425532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/127425532" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#127425532">Patrick Massot (Jun 02 2018 at 02:53)</a>:</h4>
<p>Why is this <code>pp.beta</code> not true by default?</p>

<a name="127425612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/127425612" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#127425612">Patrick Massot (Jun 02 2018 at 02:55)</a>:</h4>
<p>Is there any way to merge the two lines <code>replace hyp := classical.axiom_of_choice hyp,  cases hyp with g H,</code> into one <code>I_really_mean hyp with g H</code>?</p>

<a name="127425637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/127425637" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#127425637">Reid Barton (Jun 02 2018 at 02:55)</a>:</h4>
<p><code>cases</code> can take an expression, so you can inline the redefinition of <code>hyp</code></p>

<a name="127425640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/127425640" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#127425640">Patrick Massot (Jun 02 2018 at 02:55)</a>:</h4>
<p>I tried that and couldn't succeed</p>

<a name="127425681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/127425681" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#127425681">Reid Barton (Jun 02 2018 at 02:56)</a>:</h4>
<div class="codehilite"><pre><span></span>  <span class="n">intro</span> <span class="n">hyp</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">classical</span><span class="bp">.</span><span class="n">axiom_of_choice</span> <span class="n">hyp</span> <span class="k">with</span> <span class="n">g</span> <span class="n">H</span><span class="o">,</span>
<span class="c1">-- etc.</span>
</pre></div>

<a name="127425701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/127425701" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#127425701">Patrick Massot (Jun 02 2018 at 02:56)</a>:</h4>
<p>Ok, Lean is afraid of you</p>

<a name="127425704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/127425704" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#127425704">Reid Barton (Jun 02 2018 at 02:56)</a>:</h4>
<p>or</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span>  <span class="o">(</span><span class="bp">∀</span> <span class="n">y</span> <span class="o">:</span> <span class="n">Y</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">g</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">X</span><span class="o">,</span> <span class="n">f</span> <span class="err">∘</span> <span class="n">g</span> <span class="bp">=</span> <span class="n">id</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">hyp</span><span class="o">,</span>
  <span class="k">let</span> <span class="bp">⟨</span><span class="n">g</span><span class="o">,</span> <span class="n">H</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">classical</span><span class="bp">.</span><span class="n">axiom_of_choice</span> <span class="n">hyp</span> <span class="k">in</span>
  <span class="bp">⟨</span><span class="n">g</span><span class="o">,</span> <span class="n">funext</span> <span class="n">H</span><span class="bp">⟩</span>
</pre></div>

<a name="127425711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/127425711" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#127425711">Patrick Massot (Jun 02 2018 at 02:57)</a>:</h4>
<p>it didn't work with me before you wrote it</p>

<a name="127425735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/127425735" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#127425735">Patrick Massot (Jun 02 2018 at 02:57)</a>:</h4>
<p>I also tried various stuff involving <code>let</code>...</p>

<a name="127425809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/127425809" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#127425809">Reid Barton (Jun 02 2018 at 02:58)</a>:</h4>
<p>just remember that everything in term mode is subtly different from the corresponding thing in tactic mode and you should be fine <span class="emoji emoji-1f642" title="simple smile">:simple_smile:</span></p>

<a name="127425828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/127425828" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#127425828">Patrick Massot (Jun 02 2018 at 02:59)</a>:</h4>
<p>it's a bit confusing that the <code>funext</code> tactic takes the variable name as argument while the term version takes the quantified equality</p>

<a name="127425906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/127425906" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#127425906">Patrick Massot (Jun 02 2018 at 03:00)</a>:</h4>
<p>Anyway, I have to go back home now. Thank you very much Reid!</p>

<a name="127429106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/127429106" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#127429106">Kevin Buzzard (Jun 02 2018 at 04:00)</a>:</h4>
<p>Patrick I asked this very question here a month or two ago. Let me see if I can dig out the thread.</p>

<a name="127429119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/127429119" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#127429119">Kevin Buzzard (Jun 02 2018 at 04:00)</a>:</h4>
<p>All I remember is that I used the axiom of choice twice and Mario pointed out that I should only be using it once</p>

<a name="127429204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/127429204" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#127429204">Kevin Buzzard (Jun 02 2018 at 04:02)</a>:</h4>
<p><a href="#narrow/stream/113488-general/topic/cases.20eliminating.20into.20type" title="#narrow/stream/113488-general/topic/cases.20eliminating.20into.20type">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cases.20eliminating.20into.20type</a></p>

<a name="127429208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/127429208" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#127429208">Kevin Buzzard (Jun 02 2018 at 04:02)</a>:</h4>
<p>Maybe that will have some relevant material</p>

<a name="127431357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/127431357" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#127431357">Patrick Massot (Jun 02 2018 at 04:46)</a>:</h4>
<p>I thought so, bu I found the wrong thread when I searched. Thank you</p>

<a name="127515866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/127515866" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#127515866">Patrick Massot (Jun 04 2018 at 07:31)</a>:</h4>
<p>So, <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> and <span class="user-mention" data-user-id="110049">@Mario Carneiro</span>, should I PR something like:</p>
<div class="codehilite"><pre><span></span><span class="kn">namespace</span> <span class="n">tactic</span>
<span class="kn">namespace</span> <span class="n">interactive</span>
<span class="kn">open</span> <span class="n">interactive</span> <span class="n">interactive</span><span class="bp">.</span><span class="n">types</span>

<span class="c">/-</span><span class="cm">-</span>
<span class="cm">  `choice hyp with g H` takes an hypothesis `hyp` of the form</span>
<span class="cm">  `∀ (y : Y), ∃ (x : X), P x y` for some `P : X → Y → Prop` and outputs into</span>
<span class="cm">  context a function `g : Y → X` and a proposition `H` stating</span>
<span class="cm">  `∀ (y : Y), P (g y) y`. It presumably also works with dependent versions</span>
<span class="cm">  (see the actual type of `classical.axiom_of_choice`)</span>
<span class="cm">-/</span>
<span class="n">meta</span> <span class="n">def</span> <span class="n">choice</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">parse</span> <span class="n">cases_arg_p</span><span class="o">)</span> <span class="o">(</span><span class="n">ids</span> <span class="o">:</span> <span class="n">parse</span> <span class="n">with_ident_list</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">do</span> <span class="n">cases</span> <span class="o">(</span><span class="n">e</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span><span class="bp">``</span><span class="o">(</span><span class="n">classical</span><span class="bp">.</span><span class="n">axiom_of_choice</span> <span class="err">%%</span><span class="o">(</span><span class="n">e</span><span class="bp">.</span><span class="mi">2</span><span class="o">)))</span> <span class="n">ids</span>

<span class="kn">end</span> <span class="n">interactive</span>
<span class="kn">end</span> <span class="n">tactic</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span>  <span class="o">(</span><span class="bp">∀</span> <span class="n">y</span> <span class="o">:</span> <span class="n">Y</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">g</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">X</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">y</span><span class="o">,</span> <span class="n">P</span> <span class="o">(</span><span class="n">g</span> <span class="n">y</span><span class="o">)</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">hyp</span><span class="o">,</span>
  <span class="n">choice</span> <span class="n">hyp</span> <span class="k">with</span> <span class="n">g</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">existsi</span> <span class="n">g</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">H</span>
<span class="kn">end</span>
</pre></div>


<p>I know this is purely cosmetic, but I think it would help mathematicians to have a nice interface to choice.</p>

<a name="127515910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/127515910" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#127515910">Patrick Massot (Jun 04 2018 at 07:32)</a>:</h4>
<p>Of course this is a version of what Simon wrote in the other thread</p>

<a name="127516186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/127516186" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#127516186">Kevin Buzzard (Jun 04 2018 at 07:42)</a>:</h4>
<p>This is really nice and I want to be showing this to my 1st years.</p>

<a name="127516187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/127516187" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#127516187">Kevin Buzzard (Jun 04 2018 at 07:42)</a>:</h4>
<p>It was on my todo list to  get this into a xena library.</p>

<a name="127516194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/127516194" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#127516194">Kevin Buzzard (Jun 04 2018 at 07:43)</a>:</h4>
<p>Patrick -- can choice be used to replace cases everywhere?</p>

<a name="127516301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/127516301" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#127516301">Kevin Buzzard (Jun 04 2018 at 07:47)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> it's important we make a good interface for mathematicians, so they can learn more quickly.</p>

<a name="127516364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/exists%20%28X%29%20%28Y%29/near/127516364" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/23060existsXY.html#127516364">Kenny Lau (Jun 04 2018 at 07:49)</a>:</h4>
<p>Skolem normal form?</p>


{% endraw %}
